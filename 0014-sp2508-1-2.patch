From d71fee3e7a6f351e6a4416f125b963e22141e8c2 Mon Sep 17 00:00:00 2001
From: olegsvs <oleg.texet@gmail.com>
Date: Sun, 8 May 2016 22:33:51 +0300
Subject: [PATCH 014/117] sp2508 1/2

---
 drivers/misc/mediatek/cam_cal/inc/cam_cal.h        |    0
 drivers/misc/mediatek/cam_cal/inc/cam_cal_define.h |    0
 .../cam_cal/src/mt6735/cat24c16/cat24c16.c         |    0
 .../cam_cal/src/mt6735/cat24c16/cat24c16.h         |    0
 .../cam_cal/src/mt6735/imx135_otp/imx135_otp.c     |   14 +-
 .../cam_cal/src/mt6735/imx135_otp/imx135_otp.h     |    0
 .../src/mt6735/imx219_eeprom/imx219_eeprom.c       |    0
 .../src/mt6735/imx219_eeprom/imx219_eeprom.h       |    0
 drivers/misc/mediatek/camera/camera/Makefile       |    6 +
 drivers/misc/mediatek/camera/camera/dummyds.c      |    0
 drivers/misc/mediatek/camera/camera/kd_camera_hw.c | 1674 ++++++++++++++
 drivers/misc/mediatek/camera/camera/kd_camera_hw.h |   51 +
 drivers/misc/mediatek/imgsensor/inc/kd_imgsensor.h |   53 +-
 .../misc/mediatek/imgsensor/src/mt6735/Makefile    |   11 +
 .../imgsensor/src/mt6735/gc2155mipi_yuv/Makefile   |    4 +
 .../gc2155mipi_yuv_CameraCustomized.h              |  163 ++
 .../gc2155mipi_yuv_Camera_Sensor_para.h            |  158 ++
 .../mt6735/gc2155mipi_yuv/gc2155mipi_yuv_Sensor.c  | 2211 +++++++++++++++++++
 .../mt6735/gc2155mipi_yuv/gc2155mipi_yuv_Sensor.h  |  170 ++
 .../imgsensor/src/mt6735/gc2235_mipi_raw/Makefile  |    4 +
 .../src/mt6735/gc2235_mipi_raw/gc2235mipi_Sensor.c | 1587 +++++++++++++
 .../src/mt6735/gc2235_mipi_raw/gc2235mipi_Sensor.h |  120 +
 .../src/mt6735/gc2355_mipi_raw/gc2355mipi_Sensor.c |    0
 .../imgsensor/src/mt6735/gc2755_mipi_raw/Makefile  |    4 +
 .../src/mt6735/gc2755_mipi_raw/gc2755mipi_Sensor.c | 1406 ++++++++++++
 .../src/mt6735/gc2755_mipi_raw/gc2755mipi_Sensor.h |  144 ++
 .../mt6735/imx219_mipi_raw/imx219mipiraw_Sensor.c  |   12 +-
 .../mediatek/imgsensor/src/mt6735/kd_sensorlist.h  |   12 +
 .../imgsensor/src/mt6735/ov13850_mipi_raw/Makefile |    4 +
 .../src/mt6735/ov13850_mipi_raw/ov13850_otp.h      |   44 +
 .../src/mt6735/ov13850_mipi_raw/ov13850_otp_cal.c  |  529 +++++
 .../ov13850mipiraw_CameraCustomized.h              |   65 +
 .../ov13850mipiraw_Camera_Sensor_para.h            |   60 +
 .../ov13850_mipi_raw/ov13850mipiraw_Sensor.c       | 2081 +++++++++++++++++
 .../ov13850_mipi_raw/ov13850mipiraw_Sensor.h       |  123 ++
 .../src/mt6735/ov2680_mipi_raw/ov2680mipi_Sensor.c |   11 +-
 .../src/mt6735/ov5648_mipi_raw/ov5648mipi_Sensor.c |   35 +-
 .../imgsensor/src/mt6735/ov5670_mipi_raw/Makefile  |    4 +
 .../src/mt6735/ov5670_mipi_raw/ov5670mipi_Sensor.c | 1863 ++++++++++++++++
 .../src/mt6735/ov5670_mipi_raw/ov5670mipi_Sensor.h |  124 ++
 .../imgsensor/src/mt6735/ov8858_mipi_raw/Makefile  |    2 +-
 .../ov8858mipiraw_CameraCustomized.h               |   82 +
 .../ov8858mipiraw_Camera_Sensor_para.h             |   75 +
 .../mt6735/ov8858_mipi_raw/ov8858mipiraw_Sensor.c  |    6 +-
 .../mt6735/ov8858_mipi_raw/ov8858mipiraw_Sensor.h  |    0
 .../imgsensor/src/mt6735/ov8865_mipi_raw/Makefile  |    4 +
 .../mt6735/ov8865_mipi_raw/ov8865mipiraw_Sensor.c  | 2327 ++++++++++++++++++++
 .../mt6735/ov8865_mipi_raw/ov8865mipiraw_Sensor.h  |  119 +
 .../src/mt6735m/-sp2508_mipi_raw/Makefile          |    4 +
 .../mt6735m/-sp2508_mipi_raw/sp2508mipi_Sensor.c   | 1300 +++++++++++
 .../mt6735m/-sp2508_mipi_raw/sp2508mipi_Sensor.h   |  119 +
 .../misc/mediatek/imgsensor/src/mt6735m/Makefile   |   11 +
 .../gc0310_mipi_yuv/gc0310mipi_yuv_Sensor.c        |  237 +-
 .../src/mt6735m/gc0310main_mipi_yuv/Makefile       |    4 +
 .../gc0310mainmipi_yuv_CameraCustomized.h          |  135 ++
 .../gc0310mainmipi_yuv_Camera_Sensor_para.h        |  101 +
 .../gc0310mainmipi_yuv_Sensor.c                    | 2123 ++++++++++++++++++
 .../gc0310mainmipi_yuv_Sensor.h                    |   77 +
 .../imgsensor/src/mt6735m/gc0409_mipi_raw/Makefile |    4 +
 .../mt6735m/gc0409_mipi_raw/gc0409mipi_Sensor.c    | 1406 ++++++++++++
 .../mt6735m/gc0409_mipi_raw/gc0409mipi_Sensor.h    |  139 ++
 .../imgsensor/src/mt6735m/gc2155mipi_yuv/Makefile  |    4 +
 .../gc2155mipi_yuv_CameraCustomized.h              |  163 ++
 .../gc2155mipi_yuv_Camera_Sensor_para.h            |  158 ++
 .../mt6735m/gc2155mipi_yuv/gc2155mipi_yuv_Sensor.c | 2213 +++++++++++++++++++
 .../mt6735m/gc2155mipi_yuv/gc2155mipi_yuv_Sensor.h |  170 ++
 .../imgsensor/src/mt6735m/gc2235_mipi_raw/Makefile |    4 +
 .../mt6735m/gc2235_mipi_raw/gc2235mipi_Sensor.c    | 1435 ++++++++++++
 .../mt6735m/gc2235_mipi_raw/gc2235mipi_Sensor.h    |  144 ++
 .../mt6735m/gc2355_mipi_raw/gc2355mipi_Sensor.c    |  509 ++---
 .../mt6735m/gc2355_mipi_raw/gc2355mipi_Sensor.h    |   12 +-
 .../imgsensor/src/mt6735m/gc2755_mipi_raw/Makefile |    0
 .../mt6735m/gc2755_mipi_raw/gc2755mipi_Sensor.c    |  106 +-
 .../mt6735m/gc2755_mipi_raw/gc2755mipi_Sensor.h    |    8 +-
 .../imgsensor/src/mt6735m/gc5004_mipi_raw/Makefile |    2 +-
 .../mt6735m/gc5004_mipi_raw/gc5004mipiraw_Sensor.c |   15 +-
 .../mt6735m/gc5004_mipi_raw/gc5004mipiraw_Sensor.h |    0
 .../imgsensor/src/mt6735m/gc5024_mipi_raw/Makefile |    2 +-
 .../mt6735m/gc5024_mipi_raw/gc5024mipi_Sensor.c    |  105 +-
 .../mt6735m/gc5024_mipi_raw/gc5024mipi_Sensor.h    |    0
 .../src/mt6735m/hi545_mipi_raw/hi545mipi_Sensor.c  |  636 ++----
 .../src/mt6735m/hi545_mipi_raw/hi545mipi_Sensor.h  |    0
 .../imgsensor/src/mt6735m/imx145_mipi_raw/Makefile |    0
 .../mt6735m/imx145_mipi_raw/imx145mipiraw_Sensor.c |    0
 .../mt6735m/imx145_mipi_raw/imx145mipiraw_Sensor.h |    6 +-
 .../imgsensor/src/mt6735m/imx164_mipi_raw/Makefile |    3 +
 .../mt6735m/imx164_mipi_raw/imx164mipiraw_Sensor.c | 1168 +++++-----
 .../mt6735m/imx164_mipi_raw/imx164mipiraw_Sensor.h |   60 +-
 .../imgsensor/src/mt6735m/imx166_mipi_raw/Makefile |    4 +
 .../mt6735m/imx166_mipi_raw/imx166mipiraw_Sensor.c | 1939 ++++++++++++++++
 .../mt6735m/imx166_mipi_raw/imx166mipiraw_Sensor.h |  123 ++
 .../imgsensor/src/mt6735m/imx175_mipi_raw/Makefile |    2 +-
 .../mt6735m/imx175_mipi_raw/imx175mipiraw_Sensor.c | 1732 +++++++--------
 .../mt6735m/imx175_mipi_raw/imx175mipiraw_Sensor.h |   62 +-
 .../imgsensor/src/mt6735m/imx179_mipi_raw/Makefile |    1 -
 .../mt6735m/imx179_mipi_raw/imx179mipiraw_Sensor.c |  820 ++++---
 .../mt6735m/imx179_mipi_raw/imx179mipiraw_Sensor.h |   34 -
 .../src/mt6735m/imx179_mipi_raw_4lane/Makefile     |    5 +
 .../imx179_mipi_raw_4lane/imx179mipiraw_Sensor.c   | 2249 +++++++++++++++++++
 .../imx179_mipi_raw_4lane/imx179mipiraw_Sensor.h   |  178 ++
 .../mt6735m/imx219_mipi_raw/imx219mipiraw_Sensor.c |   16 +-
 .../mediatek/imgsensor/src/mt6735m/kd_sensorlist.c |   54 +-
 .../mediatek/imgsensor/src/mt6735m/kd_sensorlist.h |  182 +-
 .../mt6735m/ov2680_mipi_raw/ov2680mipi_Sensor.c    |    0
 .../mt6735m/ov2680_mipi_raw/ov2680mipi_Sensor.h    |    0
 .../mt6735m/ov5648_mipi_raw/ov5648mipi_Sensor.c    |   17 +-
 .../mt6735m/ov5648_mipi_raw/ov5648mipi_Sensor.h    |    0
 .../mt6735m/ov5670_mipi_raw/ov5670mipi_Sensor.c    |  122 +-
 .../imgsensor/src/mt6735m/ov5693_mipi_raw/Makefile |    5 +-
 .../mt6735m/ov5693_mipi_raw/ov5693mipi_Sensor.c    | 1821 +++++++++++++++
 .../mt6735m/ov5693_mipi_raw/ov5693mipi_Sensor.h    |  119 +
 .../imgsensor/src/mt6735m/ov8858_mipi_raw/Makefile |    0
 .../mt6735m/ov8858_mipi_raw/ov8858mipiraw_Sensor.c |   36 +-
 .../mt6735m/ov8858_mipi_raw/ov8858mipiraw_Sensor.h |    0
 .../ov8865mipiraw_CameraCustomized.h               |    0
 .../ov8865mipiraw_Camera_Sensor_para.h             |    0
 .../mt6735m/ov8865_mipi_raw/ov8865mipiraw_Sensor.c | 1251 ++++++-----
 .../imgsensor/src/mt6735m/ov9760_mipi_raw/Makefile |    2 +-
 .../mt6735m/ov9760_mipi_raw/ov9760mipiraw_Sensor.c |  105 +-
 .../mt6735m/ov9760_mipi_raw/ov9760mipiraw_Sensor.h |    0
 .../src/mt6735m/s5k3h5xa_mipi_raw/Makefile         |    3 +
 .../s5k3h5xa_mipi_raw/s5k3h5xamipiraw_Sensor.c     | 1672 ++++++++++++++
 .../s5k3h5xa_mipi_raw/s5k3h5xamipiraw_Sensor.h     |  123 ++
 .../src/mt6735m/s5k4e2gx_mipi_raw/Makefile         |    2 +-
 .../s5k4e2gx_mipi_raw/s5k4e2gxmipiraw_Sensor.c     |  188 +-
 .../s5k4e2gx_mipi_raw/s5k4e2gxmipiraw_Sensor.h     |    0
 .../s5k4h5yc_mipi_raw/s5k4h5ycmipiraw_Sensor.c     |   93 +-
 .../s5k4h5yc_mipi_raw/s5k4h5ycmipiraw_Sensor.h     |    0
 .../s5k5e2ya_mipi_raw/s5k5e2yamipiraw_Sensor.c     |   13 +-
 .../src/mt6735m/s5k5e2yasub_mipi_raw/Makefile      |    4 +
 .../s5k5e2yasubmipiraw_Sensor.c                    | 1868 ++++++++++++++++
 .../s5k5e2yasubmipiraw_Sensor.h                    |  129 ++
 .../imgsensor/src/mt6735m/sp0a20_yuv/Makefile      |    4 +
 .../sp0a20_yuv/sp0a20_yuv_CameraCustomized.h       |  204 ++
 .../sp0a20_yuv/sp0a20_yuv_Camera_Sensor_para.h     |  170 ++
 .../src/mt6735m/sp0a20_yuv/sp0a20_yuv_Sensor.c     | 2123 ++++++++++++++++++
 .../src/mt6735m/sp0a20_yuv/sp0a20_yuv_Sensor.h     |  133 ++
 .../imgsensor/src/mt6735m/sp2508_mipi_raw/Makefile |    2 +-
 .../mt6735m/sp2508_mipi_raw/sp2508mipiraw_Sensor.c | 1496 +++++++++++++
 .../mt6735m/sp2508_mipi_raw/sp2508mipiraw_Sensor.h |  144 ++
 .../imgsensor/src/mt6735m/sp5409_mipi_raw/Makefile |    2 +-
 .../mt6735m/sp5409_mipi_raw/sp5409mipi_Sensor.c    |  526 ++---
 .../mt6735m/sp5409_mipi_raw/sp5409mipi_Sensor.h    |    0
 .../src/mt6735m/sp5409sub_mipi_raw/Makefile        |    4 +
 .../sp5409sub_mipi_raw/sp5409submipi_Sensor.c      | 1319 +++++++++++
 .../sp5409sub_mipi_raw/sp5409submipi_Sensor.h      |  119 +
 .../imgsensor/src/mt6735m/sp8408_mipi_raw/Makefile |    0
 .../sp8408mipiraw_CameraCustomized.h               |    0
 .../sp8408mipiraw_Camera_Sensor_para.h             |    0
 .../mt6735m/sp8408_mipi_raw/sp8408mipiraw_Sensor.c |   65 +-
 .../mt6735m/sp8408_mipi_raw/sp8408mipiraw_Sensor.h |    0
 .../mt6735/benefit_m7/camera/camera/kd_camera_hw.c | 1131 +++++++---
 .../mt6735/benefit_m7/camera/camera/kd_camera_hw.h |   34 +-
 .../mach/mt6735/benefit_m7/dct/dct/codegen.dws     |  Bin 29776 -> 29782 bytes
 .../mach/mt6735/benefit_m7/dct/dct/cust_adc.dtsi   |    2 +-
 .../mach/mt6735/benefit_m7/dct/dct/cust_adc.h      |    2 +-
 .../mt6735/benefit_m7/dct/dct/cust_clk_buf.dtsi    |    2 +-
 .../mach/mt6735/benefit_m7/dct/dct/cust_clk_buf.h  |    2 +-
 .../mach/mt6735/benefit_m7/dct/dct/cust_eint.dtsi  |    2 +-
 .../mach/mt6735/benefit_m7/dct/dct/cust_eint.h     |    2 +-
 .../mach/mt6735/benefit_m7/dct/dct/cust_eint_md1.h |    2 +-
 .../mach/mt6735/benefit_m7/dct/dct/cust_gpio.dtsi  |    4 +-
 .../mt6735/benefit_m7/dct/dct/cust_gpio_boot.h     |    4 +-
 .../mt6735/benefit_m7/dct/dct/cust_gpio_usage.h    |    9 +-
 .../mach/mt6735/benefit_m7/dct/dct/cust_i2c.dtsi   |    2 +-
 .../mach/mt6735/benefit_m7/dct/dct/cust_i2c.h      |    2 +-
 .../mach/mt6735/benefit_m7/dct/dct/cust_kpd.dtsi   |    2 +-
 .../mach/mt6735/benefit_m7/dct/dct/cust_kpd.h      |    2 +-
 .../mt6735/benefit_m7/dct/dct/cust_md1_eint.dtsi   |    2 +-
 .../mach/mt6735/benefit_m7/dct/dct/cust_pmic.dtsi  |    2 +-
 .../mach/mt6735/benefit_m7/dct/dct/cust_power.h    |    2 +-
 .../mt6735/benefit_m7/dct/dct/mt6735m-pinfunc.h    |    2 +-
 .../mt6735/benefit_m7/dct/dct/pinctrl-mtk-mt6735.h |    2 +-
 .../mach/mt6735/benefit_m7/dct/dct/pmic_drv.c      |    2 +-
 .../mach/mt6735/benefit_m7/dct/dct/pmic_drv.h      |    2 +-
 include/generated/compile.h                        |    4 +-
 tools/dct/DCT.log                                  |    5 -
 177 files changed, 45764 insertions(+), 4693 deletions(-)
 mode change 100755 => 100644 drivers/misc/mediatek/cam_cal/inc/cam_cal.h
 mode change 100755 => 100644 drivers/misc/mediatek/cam_cal/inc/cam_cal_define.h
 mode change 100755 => 100644 drivers/misc/mediatek/cam_cal/src/mt6735/cat24c16/cat24c16.c
 mode change 100755 => 100644 drivers/misc/mediatek/cam_cal/src/mt6735/cat24c16/cat24c16.h
 mode change 100755 => 100644 drivers/misc/mediatek/cam_cal/src/mt6735/imx135_otp/imx135_otp.c
 mode change 100755 => 100644 drivers/misc/mediatek/cam_cal/src/mt6735/imx135_otp/imx135_otp.h
 mode change 100755 => 100644 drivers/misc/mediatek/cam_cal/src/mt6735/imx219_eeprom/imx219_eeprom.c
 mode change 100755 => 100644 drivers/misc/mediatek/cam_cal/src/mt6735/imx219_eeprom/imx219_eeprom.h
 create mode 100755 drivers/misc/mediatek/camera/camera/Makefile
 create mode 100644 drivers/misc/mediatek/camera/camera/dummyds.c
 create mode 100755 drivers/misc/mediatek/camera/camera/kd_camera_hw.c
 create mode 100644 drivers/misc/mediatek/camera/camera/kd_camera_hw.h
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/inc/kd_imgsensor.h
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735/gc2155mipi_yuv/Makefile
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735/gc2155mipi_yuv/gc2155mipi_yuv_CameraCustomized.h
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735/gc2155mipi_yuv/gc2155mipi_yuv_Camera_Sensor_para.h
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735/gc2155mipi_yuv/gc2155mipi_yuv_Sensor.c
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735/gc2155mipi_yuv/gc2155mipi_yuv_Sensor.h
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735/gc2235_mipi_raw/Makefile
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735/gc2235_mipi_raw/gc2235mipi_Sensor.c
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735/gc2235_mipi_raw/gc2235mipi_Sensor.h
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735/gc2355_mipi_raw/gc2355mipi_Sensor.c
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735/gc2755_mipi_raw/Makefile
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735/gc2755_mipi_raw/gc2755mipi_Sensor.c
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735/gc2755_mipi_raw/gc2755mipi_Sensor.h
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735/ov13850_mipi_raw/Makefile
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735/ov13850_mipi_raw/ov13850_otp.h
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735/ov13850_mipi_raw/ov13850_otp_cal.c
 create mode 100644 drivers/misc/mediatek/imgsensor/src/mt6735/ov13850_mipi_raw/ov13850mipiraw_CameraCustomized.h
 create mode 100644 drivers/misc/mediatek/imgsensor/src/mt6735/ov13850_mipi_raw/ov13850mipiraw_Camera_Sensor_para.h
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735/ov13850_mipi_raw/ov13850mipiraw_Sensor.c
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735/ov13850_mipi_raw/ov13850mipiraw_Sensor.h
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735/ov5670_mipi_raw/Makefile
 create mode 100644 drivers/misc/mediatek/imgsensor/src/mt6735/ov5670_mipi_raw/ov5670mipi_Sensor.c
 create mode 100644 drivers/misc/mediatek/imgsensor/src/mt6735/ov5670_mipi_raw/ov5670mipi_Sensor.h
 create mode 100644 drivers/misc/mediatek/imgsensor/src/mt6735/ov8858_mipi_raw/ov8858mipiraw_CameraCustomized.h
 create mode 100644 drivers/misc/mediatek/imgsensor/src/mt6735/ov8858_mipi_raw/ov8858mipiraw_Camera_Sensor_para.h
 mode change 100755 => 100644 drivers/misc/mediatek/imgsensor/src/mt6735/ov8858_mipi_raw/ov8858mipiraw_Sensor.h
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735/ov8865_mipi_raw/Makefile
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735/ov8865_mipi_raw/ov8865mipiraw_Sensor.c
 create mode 100644 drivers/misc/mediatek/imgsensor/src/mt6735/ov8865_mipi_raw/ov8865mipiraw_Sensor.h
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/-sp2508_mipi_raw/Makefile
 create mode 100644 drivers/misc/mediatek/imgsensor/src/mt6735m/-sp2508_mipi_raw/sp2508mipi_Sensor.c
 create mode 100644 drivers/misc/mediatek/imgsensor/src/mt6735m/-sp2508_mipi_raw/sp2508mipi_Sensor.h
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/gc0310main_mipi_yuv/Makefile
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/gc0310main_mipi_yuv/gc0310mainmipi_yuv_CameraCustomized.h
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/gc0310main_mipi_yuv/gc0310mainmipi_yuv_Camera_Sensor_para.h
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/gc0310main_mipi_yuv/gc0310mainmipi_yuv_Sensor.c
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/gc0310main_mipi_yuv/gc0310mainmipi_yuv_Sensor.h
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/gc0409_mipi_raw/Makefile
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/gc0409_mipi_raw/gc0409mipi_Sensor.c
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/gc0409_mipi_raw/gc0409mipi_Sensor.h
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/gc2155mipi_yuv/Makefile
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/gc2155mipi_yuv/gc2155mipi_yuv_CameraCustomized.h
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/gc2155mipi_yuv/gc2155mipi_yuv_Camera_Sensor_para.h
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/gc2155mipi_yuv/gc2155mipi_yuv_Sensor.c
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/gc2155mipi_yuv/gc2155mipi_yuv_Sensor.h
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/gc2235_mipi_raw/Makefile
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/gc2235_mipi_raw/gc2235mipi_Sensor.c
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/gc2235_mipi_raw/gc2235mipi_Sensor.h
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/gc2355_mipi_raw/gc2355mipi_Sensor.c
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/gc2755_mipi_raw/Makefile
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/gc2755_mipi_raw/gc2755mipi_Sensor.c
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/gc2755_mipi_raw/gc2755mipi_Sensor.h
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/gc5004_mipi_raw/gc5004mipiraw_Sensor.c
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/gc5004_mipi_raw/gc5004mipiraw_Sensor.h
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/gc5024_mipi_raw/Makefile
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/gc5024_mipi_raw/gc5024mipi_Sensor.c
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/gc5024_mipi_raw/gc5024mipi_Sensor.h
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/hi545_mipi_raw/hi545mipi_Sensor.c
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/hi545_mipi_raw/hi545mipi_Sensor.h
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/imx145_mipi_raw/Makefile
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/imx145_mipi_raw/imx145mipiraw_Sensor.c
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/imx145_mipi_raw/imx145mipiraw_Sensor.h
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/imx164_mipi_raw/Makefile
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/imx164_mipi_raw/imx164mipiraw_Sensor.c
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/imx164_mipi_raw/imx164mipiraw_Sensor.h
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/imx166_mipi_raw/Makefile
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/imx166_mipi_raw/imx166mipiraw_Sensor.c
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/imx166_mipi_raw/imx166mipiraw_Sensor.h
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/imx179_mipi_raw/Makefile
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/imx179_mipi_raw_4lane/Makefile
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/imx179_mipi_raw_4lane/imx179mipiraw_Sensor.c
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/imx179_mipi_raw_4lane/imx179mipiraw_Sensor.h
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/kd_sensorlist.c
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/kd_sensorlist.h
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/ov2680_mipi_raw/ov2680mipi_Sensor.c
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/ov2680_mipi_raw/ov2680mipi_Sensor.h
 mode change 100755 => 100644 drivers/misc/mediatek/imgsensor/src/mt6735m/ov5648_mipi_raw/ov5648mipi_Sensor.h
 mode change 100755 => 100644 drivers/misc/mediatek/imgsensor/src/mt6735m/ov5693_mipi_raw/Makefile
 create mode 100644 drivers/misc/mediatek/imgsensor/src/mt6735m/ov5693_mipi_raw/ov5693mipi_Sensor.c
 create mode 100644 drivers/misc/mediatek/imgsensor/src/mt6735m/ov5693_mipi_raw/ov5693mipi_Sensor.h
 mode change 100755 => 100644 drivers/misc/mediatek/imgsensor/src/mt6735m/ov8858_mipi_raw/Makefile
 mode change 100755 => 100644 drivers/misc/mediatek/imgsensor/src/mt6735m/ov8858_mipi_raw/ov8858mipiraw_Sensor.c
 mode change 100755 => 100644 drivers/misc/mediatek/imgsensor/src/mt6735m/ov8858_mipi_raw/ov8858mipiraw_Sensor.h
 mode change 100755 => 100644 drivers/misc/mediatek/imgsensor/src/mt6735m/ov8865_mipi_raw/ov8865mipiraw_CameraCustomized.h
 mode change 100755 => 100644 drivers/misc/mediatek/imgsensor/src/mt6735m/ov8865_mipi_raw/ov8865mipiraw_Camera_Sensor_para.h
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/ov8865_mipi_raw/ov8865mipiraw_Sensor.c
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/ov9760_mipi_raw/Makefile
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/ov9760_mipi_raw/ov9760mipiraw_Sensor.c
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/ov9760_mipi_raw/ov9760mipiraw_Sensor.h
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/s5k3h5xa_mipi_raw/Makefile
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/s5k3h5xa_mipi_raw/s5k3h5xamipiraw_Sensor.c
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/s5k3h5xa_mipi_raw/s5k3h5xamipiraw_Sensor.h
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/s5k4e2gx_mipi_raw/s5k4e2gxmipiraw_Sensor.c
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/s5k4e2gx_mipi_raw/s5k4e2gxmipiraw_Sensor.h
 mode change 100755 => 100644 drivers/misc/mediatek/imgsensor/src/mt6735m/s5k4h5yc_mipi_raw/s5k4h5ycmipiraw_Sensor.h
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/s5k5e2ya_mipi_raw/s5k5e2yamipiraw_Sensor.c
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/s5k5e2yasub_mipi_raw/Makefile
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/s5k5e2yasub_mipi_raw/s5k5e2yasubmipiraw_Sensor.c
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/s5k5e2yasub_mipi_raw/s5k5e2yasubmipiraw_Sensor.h
 create mode 100644 drivers/misc/mediatek/imgsensor/src/mt6735m/sp0a20_yuv/Makefile
 create mode 100644 drivers/misc/mediatek/imgsensor/src/mt6735m/sp0a20_yuv/sp0a20_yuv_CameraCustomized.h
 create mode 100644 drivers/misc/mediatek/imgsensor/src/mt6735m/sp0a20_yuv/sp0a20_yuv_Camera_Sensor_para.h
 create mode 100644 drivers/misc/mediatek/imgsensor/src/mt6735m/sp0a20_yuv/sp0a20_yuv_Sensor.c
 create mode 100644 drivers/misc/mediatek/imgsensor/src/mt6735m/sp0a20_yuv/sp0a20_yuv_Sensor.h
 create mode 100644 drivers/misc/mediatek/imgsensor/src/mt6735m/sp2508_mipi_raw/sp2508mipiraw_Sensor.c
 create mode 100644 drivers/misc/mediatek/imgsensor/src/mt6735m/sp2508_mipi_raw/sp2508mipiraw_Sensor.h
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/sp5409_mipi_raw/sp5409mipi_Sensor.c
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/sp5409_mipi_raw/sp5409mipi_Sensor.h
 create mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/sp5409sub_mipi_raw/Makefile
 create mode 100644 drivers/misc/mediatek/imgsensor/src/mt6735m/sp5409sub_mipi_raw/sp5409submipi_Sensor.c
 create mode 100644 drivers/misc/mediatek/imgsensor/src/mt6735m/sp5409sub_mipi_raw/sp5409submipi_Sensor.h
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/sp8408_mipi_raw/Makefile
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/sp8408_mipi_raw/sp8408mipiraw_CameraCustomized.h
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/sp8408_mipi_raw/sp8408mipiraw_Camera_Sensor_para.h
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/sp8408_mipi_raw/sp8408mipiraw_Sensor.c
 mode change 100644 => 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/sp8408_mipi_raw/sp8408mipiraw_Sensor.h
 mode change 100755 => 100644 drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/codegen.dws

diff --git a/drivers/misc/mediatek/cam_cal/inc/cam_cal.h b/drivers/misc/mediatek/cam_cal/inc/cam_cal.h
old mode 100755
new mode 100644
diff --git a/drivers/misc/mediatek/cam_cal/inc/cam_cal_define.h b/drivers/misc/mediatek/cam_cal/inc/cam_cal_define.h
old mode 100755
new mode 100644
diff --git a/drivers/misc/mediatek/cam_cal/src/mt6735/cat24c16/cat24c16.c b/drivers/misc/mediatek/cam_cal/src/mt6735/cat24c16/cat24c16.c
old mode 100755
new mode 100644
diff --git a/drivers/misc/mediatek/cam_cal/src/mt6735/cat24c16/cat24c16.h b/drivers/misc/mediatek/cam_cal/src/mt6735/cat24c16/cat24c16.h
old mode 100755
new mode 100644
diff --git a/drivers/misc/mediatek/cam_cal/src/mt6735/imx135_otp/imx135_otp.c b/drivers/misc/mediatek/cam_cal/src/mt6735/imx135_otp/imx135_otp.c
old mode 100755
new mode 100644
index 37fa0e6..c0d89d9
--- a/drivers/misc/mediatek/cam_cal/src/mt6735/imx135_otp/imx135_otp.c
+++ b/drivers/misc/mediatek/cam_cal/src/mt6735/imx135_otp/imx135_otp.c
@@ -167,16 +167,14 @@ bool start_read_otp(BYTE zone)
 
 int read_imx135_otp(u8 page, u16 offset, u8* data)
 {
-	static int page_old=-1;
-	if((page_old!=page)&&(!start_read_otp(page)))
-	  {
-	  CAM_CALERR("OTP Start read Page %d Fail!\n", page);
-	  return 0;
+	if(!start_read_otp(page))
+    {
+		CAM_CALERR("OTP Start read Page %d Fail!\n", page);
+		return 0;
 	} else {
-	  *data = read_cmos_sensor(offset);
-	  CAM_CALDB("OTP read page 0x%x offset 0x%x data 0x%x\n", page,offset,*data);
+		*data = read_cmos_sensor(offset);
+		//CAM_CALDB("OTP read page 0x%x offset 0x%x  data 0x%x\n", page,offset,*data);
 	}
-	page_old = page;
 	return 1;
 }
 
diff --git a/drivers/misc/mediatek/cam_cal/src/mt6735/imx135_otp/imx135_otp.h b/drivers/misc/mediatek/cam_cal/src/mt6735/imx135_otp/imx135_otp.h
old mode 100755
new mode 100644
diff --git a/drivers/misc/mediatek/cam_cal/src/mt6735/imx219_eeprom/imx219_eeprom.c b/drivers/misc/mediatek/cam_cal/src/mt6735/imx219_eeprom/imx219_eeprom.c
old mode 100755
new mode 100644
diff --git a/drivers/misc/mediatek/cam_cal/src/mt6735/imx219_eeprom/imx219_eeprom.h b/drivers/misc/mediatek/cam_cal/src/mt6735/imx219_eeprom/imx219_eeprom.h
old mode 100755
new mode 100644
diff --git a/drivers/misc/mediatek/camera/camera/Makefile b/drivers/misc/mediatek/camera/camera/Makefile
new file mode 100755
index 0000000..f7025fc
--- /dev/null
+++ b/drivers/misc/mediatek/camera/camera/Makefile
@@ -0,0 +1,6 @@
+#
+# Makefile for misc devices that really don't fit anywhere else.
+#
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+
+obj-y				+= dummyds.o kd_camera_hw.o
diff --git a/drivers/misc/mediatek/camera/camera/dummyds.c b/drivers/misc/mediatek/camera/camera/dummyds.c
new file mode 100644
index 0000000..e69de29
diff --git a/drivers/misc/mediatek/camera/camera/kd_camera_hw.c b/drivers/misc/mediatek/camera/camera/kd_camera_hw.c
new file mode 100755
index 0000000..7e33284
--- /dev/null
+++ b/drivers/misc/mediatek/camera/camera/kd_camera_hw.c
@@ -0,0 +1,1674 @@
+#include <linux/videodev2.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <asm/atomic.h>
+#include <linux/xlog.h>
+
+#include "kd_camera_hw.h"
+
+#include "kd_imgsensor.h"
+#include "kd_imgsensor_define.h"
+#include "kd_camera_feature.h"
+
+/******************************************************************************
+ * Debug configuration
+******************************************************************************/
+#define PFX "[kd_camera_hw]"
+#define PK_DBG_NONE(fmt, arg...)    do {} while (0)
+#define PK_DBG_FUNC(fmt, args...)    pr_debug(PFX  fmt, ##args)
+
+#define DEBUG_CAMERA_HW_K
+#ifdef DEBUG_CAMERA_HW_K
+#define PK_DBG PK_DBG_FUNC
+#define PK_ERR(fmt, arg...)   pr_err(fmt, ##arg)
+#define PK_XLOG_INFO(fmt, args...) \
+                do {    \
+                   pr_debug(PFX  fmt, ##args); \
+                } while(0)
+#else
+#define PK_DBG(a,...)
+#define PK_ERR(a,...)
+#define PK_XLOG_INFO(fmt, args...)
+#endif
+
+#ifndef FALSE
+  #define FALSE 0
+#endif
+#ifndef TRUE
+  #define TRUE 1
+#endif
+
+/*
+#ifndef BOOL
+typedef unsigned char BOOL;
+#endif
+*/
+
+/* Mark: need to verify whether ISP_MCLK1_EN is required in here //Jessy @2014/06/04*/
+extern void ISP_MCLK1_EN(BOOL En);
+
+int cntVCAMD =0;
+int cntVCAMA =0;
+int cntVCAMIO =0;
+int cntVCAMAF =0;
+int cntVCAMD_SUB =0;
+
+static DEFINE_SPINLOCK(kdsensor_pw_cnt_lock);
+
+
+bool _hwPowerOn(MT65XX_POWER powerId, int powerVolt, char *mode_name){
+
+	if( hwPowerOn( powerId,  powerVolt, mode_name))
+	{
+	    spin_lock(&kdsensor_pw_cnt_lock);
+		if(powerId==CAMERA_POWER_VCAM_D)
+			cntVCAMD+= 1;
+		else if(powerId==CAMERA_POWER_VCAM_A)
+			cntVCAMA+= 1;
+		else if(powerId==CAMERA_POWER_VCAM_IO)
+			cntVCAMIO+= 1;
+		else if(powerId==CAMERA_POWER_VCAM_AF)
+			cntVCAMAF+= 1;
+		else if(powerId==SUB_CAMERA_POWER_VCAM_D)
+			cntVCAMD_SUB+= 1;
+		spin_unlock(&kdsensor_pw_cnt_lock);
+		return true;
+	}
+	return false;
+}
+
+bool _hwPowerDown(MT65XX_POWER powerId, char *mode_name){
+
+	if( hwPowerDown( powerId, mode_name))
+	{
+	    spin_lock(&kdsensor_pw_cnt_lock);
+		if(powerId==CAMERA_POWER_VCAM_D)
+			cntVCAMD-= 1;
+		else if(powerId==CAMERA_POWER_VCAM_A)
+			cntVCAMA-= 1;
+		else if(powerId==CAMERA_POWER_VCAM_IO)
+			cntVCAMIO-= 1;
+		else if(powerId==CAMERA_POWER_VCAM_AF)
+			cntVCAMAF-= 1;
+		else if(powerId==SUB_CAMERA_POWER_VCAM_D)
+			cntVCAMD_SUB-= 1;
+		spin_unlock(&kdsensor_pw_cnt_lock);
+		return true;
+	}
+	return false;
+}
+
+void checkPowerBeforClose( char* mode_name)
+{
+
+	int i= 0;
+
+	PK_DBG("[checkPowerBeforClose]cntVCAMD:%d, cntVCAMA:%d,cntVCAMIO:%d, cntVCAMAF:%d, cntVCAMD_SUB:%d,\n",
+		cntVCAMD, cntVCAMA,cntVCAMIO,cntVCAMAF,cntVCAMD_SUB);
+
+
+	for(i=0;i<cntVCAMD;i++)
+		hwPowerDown(CAMERA_POWER_VCAM_D,mode_name);
+	for(i=0;i<cntVCAMA;i++)
+		hwPowerDown(CAMERA_POWER_VCAM_A,mode_name);
+	for(i=0;i<cntVCAMIO;i++)
+		hwPowerDown(CAMERA_POWER_VCAM_IO,mode_name);
+	for(i=0;i<cntVCAMAF;i++)
+		hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name);
+	for(i=0;i<cntVCAMD_SUB;i++)
+		hwPowerDown(SUB_CAMERA_POWER_VCAM_D,mode_name);
+
+	 cntVCAMD =0;
+	 cntVCAMA =0;
+	 cntVCAMIO =0;
+	 cntVCAMAF =0;
+	 cntVCAMD_SUB =0;
+
+}
+
+
+
+int kdCISModulePowerOn(CAMERA_DUAL_CAMERA_SENSOR_ENUM SensorIdx, char *currSensorName, BOOL On, char* mode_name)
+{
+
+u32 pinSetIdx = 0;//default main sensor
+bool camera_pdn_reverse = FALSE;
+bool camera_pdn1_reverse = FALSE;
+
+#define IDX_PS_CMRST 0
+#define IDX_PS_CMPDN 4
+#define IDX_PS_MODE 1
+#define IDX_PS_ON   2
+#define IDX_PS_OFF  3
+
+
+u32 pinSet[3][8] = {
+                        //for main sensor
+                     {  CAMERA_CMRST_PIN, // The reset pin of main sensor uses GPIO10 of mt6306, please call mt6306 API to set
+                        CAMERA_CMRST_PIN_M_GPIO,   /* mode */
+                        GPIO_OUT_ONE,              /* ON state */
+                        GPIO_OUT_ZERO,             /* OFF state */
+                        CAMERA_CMPDN_PIN,
+                        CAMERA_CMPDN_PIN_M_GPIO,
+                        GPIO_OUT_ONE,
+                        GPIO_OUT_ZERO,
+                     },
+                     //for sub sensor
+                     {  CAMERA_CMRST1_PIN,
+                        CAMERA_CMRST1_PIN_M_GPIO,
+                        GPIO_OUT_ONE,
+                        GPIO_OUT_ZERO,
+                        CAMERA_CMPDN1_PIN,
+                        CAMERA_CMPDN1_PIN_M_GPIO,
+                        GPIO_OUT_ONE,
+                        GPIO_OUT_ZERO,
+                     },
+                     //for main_2 sensor
+                     {  GPIO_CAMERA_INVALID,
+                        GPIO_CAMERA_INVALID,   /* mode */
+                        GPIO_OUT_ONE,               /* ON state */
+                        GPIO_OUT_ZERO,              /* OFF state */
+                        GPIO_CAMERA_INVALID,
+                        GPIO_CAMERA_INVALID,
+                        GPIO_OUT_ONE,
+                        GPIO_OUT_ZERO,
+                     }
+                   };
+
+
+
+    if (DUAL_CAMERA_MAIN_SENSOR == SensorIdx){
+        pinSetIdx = 0;
+    }
+    else if (DUAL_CAMERA_SUB_SENSOR == SensorIdx) {
+        pinSetIdx = 1;
+    }
+    else if (DUAL_CAMERA_MAIN_2_SENSOR == SensorIdx) {
+        pinSetIdx = 2;
+    }
+
+    if((pinSetIdx == 0) &&
+       currSensorName &&
+       ((0 == strcmp(SENSOR_DRVNAME_GC2755_MIPI_RAW, currSensorName)) ||
+		(0 == strcmp(SENSOR_DRVNAME_GC2355_MIPI_RAW, currSensorName)) ||
+		(0 == strcmp(SENSOR_DRVNAME_GC2235_MIPI_RAW, currSensorName)) ||
+		(0 == strcmp(SENSOR_DRVNAME_GC2145_MIPI_YUV, currSensorName)) ||
+        (0 == strcmp(SENSOR_DRVNAME_SP2508_MIPI_RAW, currSensorName)) ||
+        (0 == strcmp(SENSOR_DRVNAME_SP5409_MIPI_RAW, currSensorName)) ||
+		(0 == strcmp(SENSOR_DRVNAME_GC2155_MIPI_YUV, currSensorName)) ||
+        (0== strcmp(SENSOR_DRVNAME_GC0310MAIN_MIPI_YUV, currSensorName)) ||
+		(0 == strcmp(SENSOR_DRVNAME_GC0409MIPI_RAW, currSensorName))))
+    {
+        camera_pdn_reverse = TRUE;
+    }
+
+    if((pinSetIdx == 1) &&
+       currSensorName &&
+       ((0 == strcmp(SENSOR_DRVNAME_GC2755_MIPI_RAW, currSensorName)) ||
+        (0 == strcmp(SENSOR_DRVNAME_GC2355_MIPI_RAW, currSensorName)) ||
+        (0 == strcmp(SENSOR_DRVNAME_GC2235_MIPI_RAW, currSensorName)) ||
+		(0 == strcmp(SENSOR_DRVNAME_GC2145_MIPI_YUV, currSensorName)) ||
+		(0 == strcmp(SENSOR_DRVNAME_GC2155_MIPI_YUV, currSensorName)) ||
+        (0 == strcmp(SENSOR_DRVNAME_SP0A20_YUV, currSensorName))      ||
+        (0 == strcmp(SENSOR_DRVNAME_SP2508_MIPI_RAW, currSensorName)) ||
+        (0 == strcmp(SENSOR_DRVNAME_SP5409SUB_MIPI_RAW, currSensorName)) ||
+		(0 == strcmp(SENSOR_DRVNAME_GC0310_MIPI_YUV, currSensorName)) ||
+		(0 == strcmp(SENSOR_DRVNAME_GC0409MIPI_RAW, currSensorName))))
+    {
+        camera_pdn1_reverse = TRUE;
+    }
+
+    if(camera_pdn_reverse)
+    {
+        pinSet[0][IDX_PS_CMPDN+IDX_PS_ON] = GPIO_OUT_ZERO;
+        pinSet[0][IDX_PS_CMPDN+IDX_PS_OFF] = GPIO_OUT_ONE;
+    }
+
+    if(camera_pdn1_reverse)
+    {
+        pinSet[1][IDX_PS_CMPDN+IDX_PS_ON] = GPIO_OUT_ZERO;
+        pinSet[1][IDX_PS_CMPDN+IDX_PS_OFF] = GPIO_OUT_ONE;
+    }
+
+    //power ON
+    if (On) {
+
+            ISP_MCLK1_EN(1);
+
+        PK_DBG("[PowerON]pinSetIdx:%d, currSensorName: %s\n", pinSetIdx, currSensorName);
+#ifdef GPIO_CAMERA_AF_EN_PIN
+		mt_set_gpio_mode(GPIO_CAMERA_AF_EN_PIN,GPIO_MODE_00);
+		mt_set_gpio_dir(GPIO_CAMERA_AF_EN_PIN,GPIO_DIR_OUT);
+		mt_set_gpio_out(GPIO_CAMERA_AF_EN_PIN,GPIO_OUT_ONE);
+#endif
+
+
+        if ((currSensorName && (0 == strcmp(currSensorName,"imx135mipiraw")))||
+            (currSensorName && (0 == strcmp(currSensorName,"imx220mipiraw"))))
+        {
+            //First Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+
+            //AF_VCC
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
+
+            //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
+
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1000,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
+
+            //VCAM_IO
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(2);
+
+
+            //enable active sensor
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+        }
+        else if ((currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV2680_MIPI_RAW, currSensorName))) \
+                                                                                                      )
+        {
+            mt_set_gpio_mode(GPIO_CAMERA_LDO_EN_PIN,GPIO_MODE_00);
+            mt_set_gpio_dir(GPIO_CAMERA_LDO_EN_PIN,GPIO_DIR_OUT);
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ONE);
+            //First Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+
+
+            //VCAM_IO
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+        //        goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
+
+            //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+       //         goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
+            if(TRUE != _hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1600,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", SUB_CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(5);
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1600,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", CAMERA_POWER_VCAM_D);
+     //            goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
+
+            //AF_VCC
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+      //          goto _kdCISModulePowerOn_exit_;
+            }
+
+
+            mdelay(1);
+
+
+            //enable active sensor
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+
+            mdelay(2);
+
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+
+            }
+
+            mdelay(20);
+        }
+        else if (currSensorName && (0 == strcmp(SENSOR_DRVNAME_S5K3M2_MIPI_RAW, currSensorName))){
+        #ifdef GPIO_CAMERA_LDO_EN_PIN
+            mt_set_gpio_mode(GPIO_CAMERA_LDO_EN_PIN,GPIO_MODE_00);
+            mt_set_gpio_dir(GPIO_CAMERA_LDO_EN_PIN,GPIO_DIR_OUT);
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ONE);
+        #endif
+            //First Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){
+                    PK_DBG("[CAMERA LENS] set gpio mode  failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){
+                    PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){
+                    PK_DBG("[CAMERA LENS] set gpio         failed!! (CMPDN)\n");
+                }
+            }
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){
+                    PK_DBG("[CAMERA SENSOR] set gpio     mode failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){
+                    PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){
+                    PK_DBG("[CAMERA SENSOR] set gpio       failed!! (CMRST)\n");
+                }
+            }
+            //VCAM_D
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1100,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+                goto _kdCISModulePowerOn_exit_;
+            }
+            //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name)){
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+            //VCAM_IO
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name)){
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+            //AF_VCC
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name)){
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){
+                    PK_DBG("[CAMERA LENS] set gpio mode  failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){
+                    PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){
+                    PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");
+                }
+            }
+            mdelay(2);
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){
+                    PK_DBG("[CAMERA SENSOR] set gpio     mode failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){
+                    PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){
+                    PK_DBG("[CAMERA SENSOR] set gpio        failed!! (CMRST)\n");
+                }
+            }
+       }
+        else if(currSensorName && (0 == strcmp(SENSOR_DRVNAME_S5K4E2GX_MIPI_RAW, currSensorName)))
+        {
+
+        #ifdef GPIO_CAMERA_LDO_EN_PIN
+            mt_set_gpio_mode(GPIO_CAMERA_LDO_EN_PIN,GPIO_MODE_00);
+            mt_set_gpio_dir(GPIO_CAMERA_LDO_EN_PIN,GPIO_DIR_OUT);
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ONE);
+        #endif
+                mdelay(5); 
+            //First Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){
+                      PK_DBG("[CAMERA LENS] set gpio mode  failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){
+                      PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){
+                      PK_DBG("[CAMERA LENS] set gpio         failed!! (CMPDN)\n");
+                }
+            }    
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){
+                      PK_DBG("[CAMERA SENSOR] set gpio     mode failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){
+                      PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){
+                      PK_DBG("[CAMERA SENSOR] set gpio       failed!! (CMRST)\n");
+                }
+            } 
+
+            //VCAM_D        
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1200,mode_name))
+            {
+                     PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+                     goto _kdCISModulePowerOn_exit_;
+            }
+            mdelay(5);
+            //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+                goto _kdCISModulePowerOn_exit_;
+            }
+            mdelay(5);
+            //VCAM_IO
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                goto _kdCISModulePowerOn_exit_;
+            }
+            mdelay(5);
+             //AF_VCC
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                goto _kdCISModulePowerOn_exit_;
+            }
+            mdelay(5);
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){
+                      PK_DBG("[CAMERA LENS] set gpio mode  failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){
+                      PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){
+                      PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");
+                }
+            }
+            mdelay(2);
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){
+                        PK_DBG("[CAMERA SENSOR] set gpio     mode failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){
+                        PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){
+                        PK_DBG("[CAMERA SENSOR] set gpio        failed!! (CMRST)\n");
+                }
+
+            }
+        }
+        else if(currSensorName && (0 == strcmp(SENSOR_DRVNAME_S5K4H5YC_MIPI_RAW, currSensorName)))
+        {
+
+        #ifdef GPIO_CAMERA_LDO_EN_PIN
+            mt_set_gpio_mode(GPIO_CAMERA_LDO_EN_PIN,GPIO_MODE_00);
+            mt_set_gpio_dir(GPIO_CAMERA_LDO_EN_PIN,GPIO_DIR_OUT);
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ONE);
+        #endif
+                 
+            //First Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){
+                      PK_DBG("[CAMERA LENS] set gpio mode  failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){
+                      PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){
+                      PK_DBG("[CAMERA LENS] set gpio         failed!! (CMPDN)\n");
+                }
+            }    
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){
+                      PK_DBG("[CAMERA SENSOR] set gpio     mode failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){
+                      PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){
+                      PK_DBG("[CAMERA SENSOR] set gpio       failed!! (CMRST)\n");
+                }
+            } 
+
+            //VCAM_D        
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1200,mode_name))
+            {
+                     PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+                     goto _kdCISModulePowerOn_exit_;
+            }
+            //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+                goto _kdCISModulePowerOn_exit_;
+            }
+            //VCAM_IO
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                goto _kdCISModulePowerOn_exit_;
+            }
+             //AF_VCC
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){
+                      PK_DBG("[CAMERA LENS] set gpio mode  failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){
+                      PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){
+                      PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");
+                }
+            }
+            mdelay(2);
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){
+                        PK_DBG("[CAMERA SENSOR] set gpio     mode failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){
+                        PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){
+                        PK_DBG("[CAMERA SENSOR] set gpio        failed!! (CMRST)\n");
+                }
+
+            }
+        }
+        else if(currSensorName && (0 == strcmp(SENSOR_DRVNAME_S5K5E2YA_MIPI_RAW, currSensorName))){
+        #ifdef GPIO_CAMERA_LDO_EN_PIN
+            mt_set_gpio_mode(GPIO_CAMERA_LDO_EN_PIN,GPIO_MODE_00);
+            mt_set_gpio_dir(GPIO_CAMERA_LDO_EN_PIN,GPIO_DIR_OUT);
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ONE);
+        #endif
+     
+            //First Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){
+                      PK_DBG("[CAMERA LENS] set gpio mode  failed!! (CMPDN)\n");
+                }    
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){
+                      PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");
+                }    
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){
+                      PK_DBG("[CAMERA LENS] set gpio         failed!! (CMPDN)\n");
+                }    
+            }    
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){
+                      PK_DBG("[CAMERA SENSOR] set gpio     mode failed!! (CMRST)\n");
+                }    
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){
+                      PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");
+                }    
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){
+                      PK_DBG("[CAMERA SENSOR] set gpio       failed!! (CMRST)\n");
+                }    
+            }    
+            mdelay(1);
+
+            //VCAM_D        
+#if 1
+            if(TRUE != _hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1200,mode_name))
+                {
+                     PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+                     goto _kdCISModulePowerOn_exit_;
+                }
+            mdelay(1);
+#endif
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1200,mode_name))
+                {
+                     PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+                     goto _kdCISModulePowerOn_exit_;
+                }
+            mdelay(1);
+            //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+                goto _kdCISModulePowerOn_exit_;
+            }
+            mdelay(1);
+            //VCAM_IO
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                goto _kdCISModulePowerOn_exit_;
+            }
+            mdelay(1);
+
+            //AF_VCC
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+      //          goto _kdCISModulePowerOn_exit_;
+            }
+
+
+            mdelay(1);
+
+
+           if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){
+                      PK_DBG("[CAMERA LENS] set gpio mode  failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){
+                      PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){
+                      PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");
+                }
+            }
+
+
+            mdelay(2);
+
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){
+                        PK_DBG("[CAMERA SENSOR] set gpio     mode failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){
+                        PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){
+                        PK_DBG("[CAMERA SENSOR] set gpio        failed!! (CMRST)\n");
+                }
+
+            }
+        }
+
+        else if ((currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV5648_MIPI_RAW, currSensorName))) \
+			||(currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV9760_MIPI_RAW, currSensorName)))\
+                                                                                                      )
+        {
+		#ifdef GPIO_CAMERA_LDO_EN_PIN
+            mt_set_gpio_mode(GPIO_CAMERA_LDO_EN_PIN,GPIO_MODE_00);
+            mt_set_gpio_dir(GPIO_CAMERA_LDO_EN_PIN,GPIO_DIR_OUT);
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ONE);
+		#endif
+		
+            //First Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+
+
+            //VCAM_IO
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+        //        goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
+
+            //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+       //         goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
+#if 1
+            if(TRUE != _hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1500,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", SUB_CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+#endif
+
+            mdelay(5);
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1500,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", CAMERA_POWER_VCAM_D);
+     //            goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
+
+            //AF_VCC
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+      //          goto _kdCISModulePowerOn_exit_;
+            }
+
+
+            mdelay(1);
+
+
+            //enable active sensor
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+
+            mdelay(2);
+
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+
+            }
+
+            mdelay(20);
+        }
+        else if ((currSensorName && (0 == strcmp(SENSOR_DRVNAME_HI551_MIPI_RAW, currSensorName))) ||\
+                 (currSensorName && (0 == strcmp(SENSOR_DRVNAME_HI545_MIPI_RAW, currSensorName))) ||\
+                 (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV8858_MIPI_RAW, currSensorName))) ||\
+                 (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV5670_MIPI_RAW, currSensorName))) ||\
+                 (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV5693_MIPI_RAW, currSensorName))) ||\
+                 (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV8865_MIPI_RAW, currSensorName)))   \
+                                                                                                      )
+        {
+		#ifdef GPIO_CAMERA_LDO_EN_PIN
+            mt_set_gpio_mode(GPIO_CAMERA_LDO_EN_PIN,GPIO_MODE_00);
+            mt_set_gpio_dir(GPIO_CAMERA_LDO_EN_PIN,GPIO_DIR_OUT);
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ONE);
+		#endif
+		
+            //First Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+
+
+            //VCAM_IO
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+        //        goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
+
+            //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+       //         goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
+#if 1
+            if(TRUE != _hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1200,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", SUB_CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+#endif
+
+            mdelay(5);
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1200,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", CAMERA_POWER_VCAM_D);
+     //            goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
+
+            //AF_VCC
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+      //          goto _kdCISModulePowerOn_exit_;
+            }
+
+
+            mdelay(1);
+
+
+            //enable active sensor
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+
+            mdelay(2);
+
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+
+            }
+
+            mdelay(20);
+        }
+        else  if ((currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC0310_MIPI_YUV, currSensorName))) ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC0310MAIN_MIPI_YUV, currSensorName))) ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_SP0A20_YUV, currSensorName)))      ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_SP2508_MIPI_RAW, currSensorName)))      ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_SP5409_MIPI_RAW, currSensorName)))      ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_SP5409SUB_MIPI_RAW, currSensorName)))      ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC2755_MIPI_RAW, currSensorName))) ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC2145_MIPI_YUV, currSensorName))) ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC2235_MIPI_RAW, currSensorName))) ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC2355_MIPI_RAW, currSensorName))) ||\
+				  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC0409MIPI_RAW, currSensorName)))  \
+                                                                                                  )
+        {
+		#ifdef GPIO_CAMERA_LDO_EN_PIN
+           mt_set_gpio_mode(GPIO_CAMERA_LDO_EN_PIN,GPIO_MODE_00);
+           mt_set_gpio_dir(GPIO_CAMERA_LDO_EN_PIN,GPIO_DIR_OUT);
+           mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ONE);
+		#endif
+		#ifdef GPIO_CAMERASUB_LDO_EN_PIN
+           mt_set_gpio_mode(GPIO_CAMERASUB_LDO_EN_PIN,GPIO_MODE_00);
+           mt_set_gpio_dir(GPIO_CAMERASUB_LDO_EN_PIN,GPIO_DIR_OUT);
+           mt_set_gpio_out(GPIO_CAMERASUB_LDO_EN_PIN,GPIO_OUT_ONE);
+		#endif
+#if 0
+            //First Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+
+            mdelay(50);
+#endif
+            //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+         //       goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(10);
+
+            //VCAM_IO
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+          //      goto _kdCISModulePowerOn_exit_;
+            }
+#if 1
+            mdelay(10);
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1800,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", CAMERA_POWER_VCAM_D);
+           //      goto _kdCISModulePowerOn_exit_;
+            }
+#endif
+            mdelay(1);
+
+            if(TRUE != _hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1800,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", SUB_CAMERA_POWER_VCAM_D);
+     //            goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(10);
+#if 1//def VANZO_FEATURE_GC2755MIPIRAW_FOCUS_EN
+            //AF_VCC
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+#endif
+            mdelay(50);
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+                mdelay(5);
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+
+            }
+            mdelay(5);
+            //enable active sensor
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+                mdelay(5);
+                //if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            mdelay(5);
+        }
+        else  if ((currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC5004_MIPI_RAW,currSensorName))) ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC5024_MIPI_RAW,currSensorName))) \
+				                                                                                   )
+        {
+    #ifdef GPIO_CAMERA_LDO_EN_PIN
+           mt_set_gpio_mode(GPIO_CAMERA_LDO_EN_PIN,GPIO_MODE_00);
+           mt_set_gpio_dir(GPIO_CAMERA_LDO_EN_PIN,GPIO_DIR_OUT);
+           mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ONE);
+    #endif
+#if 0
+            //First Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+
+            mdelay(50);
+#endif
+            //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+         //       goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(10);
+
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1500,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", CAMERA_POWER_VCAM_D);
+           //      goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
+
+            //VCAM_IO
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+          //      goto _kdCISModulePowerOn_exit_;
+            }
+#if 0
+            mdelay(10);
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1800,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", CAMERA_POWER_VCAM_D);
+           //      goto _kdCISModulePowerOn_exit_;
+            }
+#endif
+            mdelay(1);
+
+            if(TRUE != _hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1800,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", SUB_CAMERA_POWER_VCAM_D);
+     //            goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(10);
+            //AF_VCC
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(50);
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+                mdelay(5);
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+
+            }
+            mdelay(5);
+            //enable active sensor
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+                mdelay(5);
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            mdelay(5);
+        }
+        else
+        {
+		#ifdef GPIO_CAMERA_LDO_EN_PIN
+           mt_set_gpio_mode(GPIO_CAMERA_LDO_EN_PIN,GPIO_MODE_00);
+           mt_set_gpio_dir(GPIO_CAMERA_LDO_EN_PIN,GPIO_DIR_OUT);
+           mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ONE);
+		#endif
+		
+            //First Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+
+            //VCAM_IO
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+                goto _kdCISModulePowerOn_exit_;
+            }
+            //VCAM_D
+            if(currSensorName && (0 == strcmp(SENSOR_DRVNAME_S5K2P8_MIPI_RAW, currSensorName)))
+            {
+                if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1200,mode_name))
+                {
+                     PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+                     goto _kdCISModulePowerOn_exit_;
+                }
+            }
+            else if(currSensorName && (0 == strcmp(SENSOR_DRVNAME_IMX219_MIPI_RAW, currSensorName)))
+            {
+                if(pinSetIdx == 0 && TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1200,mode_name))
+                {
+                     PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+                     goto _kdCISModulePowerOn_exit_;
+                }
+            }
+            else { // Main VCAMD max 1.5V
+                if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1500,mode_name))
+                {
+                     PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+                     goto _kdCISModulePowerOn_exit_;
+                }
+
+            }
+            if(TRUE != hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1500,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+
+
+
+             //AF_VCC
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(5);
+
+            //enable active sensor
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            mdelay(1);
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+        }
+    }
+    else {//power OFF
+
+        PK_DBG("[PowerOFF]pinSetIdx:%d\n", pinSetIdx);
+            ISP_MCLK1_EN(0);
+#ifdef GPIO_CAMERA_AF_EN_PIN
+			mt_set_gpio_out(GPIO_CAMERA_AF_EN_PIN,GPIO_OUT_ZERO);
+#endif
+
+
+        if ((currSensorName && (0 == strcmp(currSensorName,"imx135mipiraw")))||
+            (currSensorName && (0 == strcmp(currSensorName,"imx220mipiraw"))))
+
+        {
+            //Set Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            //Set Reset Pin Low
+             if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+
+            //AF_VCC
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                //return -EIO;
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_IO
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                //return -EIO;
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D), power id = %d \n",CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_A
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
+                //return -EIO;
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+        }
+        else if ((currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV2680_MIPI_RAW, currSensorName))) \
+                                                                                                      )
+        {
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ZERO);
+            //Set Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+     //            goto _kdCISModulePowerOn_exit_;
+            }
+            if(TRUE != _hwPowerDown(SUB_CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D), power id = %d \n",SUB_CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+            //VCAM_A
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
+                //return -EIO;
+     //           goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_IO
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                //return -EIO;
+      //          goto _kdCISModulePowerOn_exit_;
+            }
+
+            //AF_VCC
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                //return -EIO;
+       //         goto _kdCISModulePowerOn_exit_;
+            }
+
+        }
+        else if ((currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV5648_MIPI_RAW, currSensorName))) \
+			||(currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV9760_MIPI_RAW, currSensorName)))\
+                                                                                                      )
+        {
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ZERO);
+            //Set Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+     //            goto _kdCISModulePowerOn_exit_;
+            }
+#if 0
+            if(TRUE != _hwPowerDown(SUB_CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D), power id = %d \n",SUB_CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+#endif
+            //VCAM_A
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
+                //return -EIO;
+     //           goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_IO
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                //return -EIO;
+      //          goto _kdCISModulePowerOn_exit_;
+            }
+
+            //AF_VCC
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                //return -EIO;
+       //         goto _kdCISModulePowerOn_exit_;
+            }
+
+        }
+        else if ((currSensorName && (0 == strcmp(SENSOR_DRVNAME_HI551_MIPI_RAW, currSensorName))) ||\
+                 (currSensorName && (0 == strcmp(SENSOR_DRVNAME_HI545_MIPI_RAW, currSensorName))) ||\
+                 (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV8858_MIPI_RAW, currSensorName))) ||\
+                 (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV5670_MIPI_RAW, currSensorName))) ||\
+                 (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV8865_MIPI_RAW, currSensorName)))   \
+                                                                                                      )
+        {
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ZERO);
+            //Set Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+     //            goto _kdCISModulePowerOn_exit_;
+            }
+
+#if 1
+            if(TRUE != _hwPowerDown(SUB_CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D), power id = %d \n",SUB_CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+#endif
+            //VCAM_A
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
+                //return -EIO;
+     //           goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_IO
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                //return -EIO;
+      //          goto _kdCISModulePowerOn_exit_;
+            }
+
+            //AF_VCC
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                //return -EIO;
+       //         goto _kdCISModulePowerOn_exit_;
+            }
+
+        }
+        else  if ((currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC0310_MIPI_YUV, currSensorName))) ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC0310MAIN_MIPI_YUV, currSensorName))) ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_SP0A20_YUV, currSensorName)))      ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_SP2508_MIPI_RAW, currSensorName)))      ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_SP5409_MIPI_RAW, currSensorName)))      ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_SP5409SUB_MIPI_RAW, currSensorName)))      ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC2755_MIPI_RAW, currSensorName))) ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC2355_MIPI_RAW, currSensorName))) \
+                                                                                                  )
+        {
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ZERO);
+		#ifdef GPIO_CAMERASUB_LDO_EN_PIN
+           mt_set_gpio_mode(GPIO_CAMERASUB_LDO_EN_PIN,GPIO_MODE_00);
+           mt_set_gpio_dir(GPIO_CAMERASUB_LDO_EN_PIN,GPIO_DIR_OUT);
+           mt_set_gpio_out(GPIO_CAMERASUB_LDO_EN_PIN,GPIO_OUT_ZERO);
+		#endif
+            //Set Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+            #if 0
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+     //            goto _kdCISModulePowerOn_exit_;
+            }
+            #endif
+#if 1
+            if(TRUE != _hwPowerDown(SUB_CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D), power id = %d \n",SUB_CAMERA_POWER_VCAM_D);
+    //             goto _kdCISModulePowerOn_exit_;
+            }
+#endif
+            //VCAM_A
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
+                //return -EIO;
+     //           goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_IO
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                //return -EIO;
+      //          goto _kdCISModulePowerOn_exit_;
+            }
+#if 1//VANZO_FEATURE_GC2755MIPIRAW_FOCUS_EN
+            //AF_VCC
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                //return -EIO;
+       //         goto _kdCISModulePowerOn_exit_;
+            }
+#endif
+
+        } 
+        else if ((currSensorName && (0 == strcmp(SENSOR_DRVNAME_S5K4E2GX_MIPI_RAW, currSensorName))) \
+                                                                                                      )
+        {
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ZERO);
+            //Set Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+     //            goto _kdCISModulePowerOn_exit_;
+            }
+            //VCAM_A
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
+                //return -EIO;
+     //           goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_IO
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                //return -EIO;
+      //          goto _kdCISModulePowerOn_exit_;
+            }
+
+            //AF_VCC
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                //return -EIO;
+       //         goto _kdCISModulePowerOn_exit_;
+            }
+
+        }
+       else  if ((currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC5004_MIPI_RAW, currSensorName))) || \
+                (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC5024_MIPI_RAW,currSensorName))) \
+				                                                                                )
+        {
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ZERO);
+            //Set Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+            #if 1
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+     //            goto _kdCISModulePowerOn_exit_;
+            }
+            #endif
+#if 0
+            if(TRUE != _hwPowerDown(SUB_CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D), power id = %d \n",SUB_CAMERA_POWER_VCAM_D);
+    //             goto _kdCISModulePowerOn_exit_;
+            }
+#endif
+            //VCAM_A
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
+                //return -EIO;
+     //           goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_IO
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                //return -EIO;
+      //          goto _kdCISModulePowerOn_exit_;
+            }
+            //AF_VCC
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                //return -EIO;
+       //         goto _kdCISModulePowerOn_exit_;
+            }
+        }
+             else
+        {
+           mt_set_gpio_mode(GPIO_CAMERA_LDO_EN_PIN,GPIO_MODE_00);
+           mt_set_gpio_dir(GPIO_CAMERA_LDO_EN_PIN,GPIO_DIR_OUT);
+           mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ZERO);
+            //Set Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                    if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                    if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                    if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+
+            if(currSensorName && (0 == strcmp(SENSOR_DRVNAME_IMX219_MIPI_RAW, currSensorName)))
+	    {
+		if(pinSetIdx == 0 && TRUE != _hwPowerDown(CAMERA_POWER_VCAM_D, mode_name))
+		 {
+		   PK_DBG("[CAMERA SENSOR] main imx220 Fail to OFF core power (VCAM_D), power id = %d \n",CAMERA_POWER_VCAM_D);
+		   goto _kdCISModulePowerOn_exit_;
+		 }
+	    } else {
+
+	         if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_D,mode_name))
+	         {
+	            PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D), power id = %d \n",CAMERA_POWER_VCAM_D);
+	            goto _kdCISModulePowerOn_exit_;
+	          }
+	   }
+            if(TRUE != hwPowerDown(SUB_CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D),       power id = %d \n",SUB_CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+
+
+            //VCAM_A
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
+                //return -EIO;
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_IO
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                //return -EIO;
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            //AF_VCC
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                //return -EIO;
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+        }
+
+    }
+
+    return 0;
+
+_kdCISModulePowerOn_exit_:
+    return -EIO;
+
+}
+
+EXPORT_SYMBOL(kdCISModulePowerOn);
+
+//!--
+//
+
+
diff --git a/drivers/misc/mediatek/camera/camera/kd_camera_hw.h b/drivers/misc/mediatek/camera/camera/kd_camera_hw.h
new file mode 100644
index 0000000..a9c33b6
--- /dev/null
+++ b/drivers/misc/mediatek/camera/camera/kd_camera_hw.h
@@ -0,0 +1,51 @@
+#ifndef _KD_CAMERA_HW_H_
+#define _KD_CAMERA_HW_H_
+
+#include <mach/mt_gpio.h>
+
+#ifdef MTK_MT6306_SUPPORT
+#include <mach/dcl_sim_gpio.h>
+#endif
+
+#include <mach/mt_pm_ldo.h>
+#include "pmic_drv.h"
+
+//
+//Analog
+#define CAMERA_POWER_VCAM_A         PMIC_APP_MAIN_CAMERA_POWER_A
+//Digital
+#define CAMERA_POWER_VCAM_D         PMIC_APP_MAIN_CAMERA_POWER_D
+//AF
+#define CAMERA_POWER_VCAM_AF        PMIC_APP_MAIN_CAMERA_POWER_AF
+//digital io
+#define CAMERA_POWER_VCAM_IO        PMIC_APP_MAIN_CAMERA_POWER_IO
+//Digital for Sub
+#define SUB_CAMERA_POWER_VCAM_D     PMIC_APP_SUB_CAMERA_POWER_D
+
+
+//FIXME, should defined in DCT tool
+
+//Main sensor
+#define CAMERA_CMRST_PIN            GPIO_CAMERA_CMRST_PIN
+#define CAMERA_CMRST_PIN_M_GPIO     GPIO_CAMERA_CMRST_PIN_M_GPIO
+
+#define CAMERA_CMPDN_PIN            GPIO_CAMERA_CMPDN_PIN
+#define CAMERA_CMPDN_PIN_M_GPIO     GPIO_CAMERA_CMPDN_PIN_M_GPIO
+
+//FRONT sensor
+#define CAMERA_CMRST1_PIN           GPIO_CAMERA_CMRST1_PIN
+#define CAMERA_CMRST1_PIN_M_GPIO    GPIO_CAMERA_CMRST1_PIN_M_GPIO
+
+#define CAMERA_CMPDN1_PIN           GPIO_CAMERA_CMPDN1_PIN
+#define CAMERA_CMPDN1_PIN_M_GPIO    GPIO_CAMERA_CMPDN1_PIN_M_GPIO
+
+// Define I2C Bus Num
+#define SUPPORT_I2C_BUS_NUM1        0
+/* Vanzo:yucheng on: Mon, 06 Apr 2015 21:46:53 +0800
+ * Porting from wuzhiyong
+#define SUPPORT_I2C_BUS_NUM2        0
+ */
+#define SUPPORT_I2C_BUS_NUM2        2
+// End of Vanzo: yucheng
+
+#endif
diff --git a/drivers/misc/mediatek/imgsensor/inc/kd_imgsensor.h b/drivers/misc/mediatek/imgsensor/inc/kd_imgsensor.h
old mode 100644
new mode 100755
index 4b2f12e..3e12a0b
--- a/drivers/misc/mediatek/imgsensor/inc/kd_imgsensor.h
+++ b/drivers/misc/mediatek/imgsensor/inc/kd_imgsensor.h
@@ -99,11 +99,14 @@
 /* SENSOR CHIP VERSION */
 /*IMX*/
 #define IMX220_SENSOR_ID                        0x0220
+#define IMX145_SENSOR_ID                        0x0145
 #define IMX219_SENSOR_ID                        0x0219
 #define IMX215_SENSOR_ID                        0x0215
 #define IMX214_SENSOR_ID                        0x0214
-#define IMX164_SENSOR_ID                        0x0164
+#define IMX179_SENSOR_ID                        0x0179
+#define IMX175_SENSOR_ID                        0x0175
 #define IMX178_SENSOR_ID                        0x0178
+#define IMX164_SENSOR_ID                        0x0164
 #define IMX135_SENSOR_ID                        0x0135
 #define IMX132MIPI_SENSOR_ID                    0x0132
 #define IMX119_SENSOR_ID                        0x0119
@@ -111,6 +114,7 @@
 #define IMX091_SENSOR_ID                        0x0091
 #define IMX073_SENSOR_ID                        0x0046
 #define IMX058_SENSOR_ID                        0x0058
+#define IMX166_SENSOR_ID                        0x0152
 /*OV*/
 #define OV16825MIPI_SENSOR_ID                   0x016820
 #define OV13850_SENSOR_ID                       0xD850
@@ -161,13 +165,16 @@
 #define S5K53BEX_SENSOR_ID                      0x45A8
 #define S5K53BEB_SENSOR_ID                      0x87A8
 #define S5K5BAFX_SENSOR_ID                      0x05BA
+#define S5K4E2GX_SENSOR_ID                      0x4e20
 #define S5K5E2YA_SENSOR_ID                      0x5e20
+#define S5K5E2YASUB_SENSOR_ID                   0x5e21
 #define S5K4H5YX_2LANE_SENSOR_ID                0x485B
 #define S5K4H5YC_SENSOR_ID                      0x485B
 #define S5K83AFX_SENSOR_ID                      0x01C4
 #define S5K5CAGX_SENSOR_ID                      0x05ca
 #define S5K8AAYX_MIPI_SENSOR_ID                 0x08aa
 #define S5K8AAYX_SENSOR_ID                      0x08aa
+#define S5K3H5XA_SENSOR_ID                      0x3085
 /*HI*/
 #define HI841_SENSOR_ID                         0x0841
 #define HI707_SENSOR_ID                         0x00b8
@@ -206,20 +213,32 @@
 #define MT9P017_SENSOR_ID                       0x4800
 #define MT9P017MIPI_SENSOR_ID                   0x4800
 #define MT9T113MIPI_SENSOR_ID                   0x4680
-#define SP8408MIPI_SENSOR_ID 					0x1490
 /*GC*/
+#define GC2755_SENSOR_ID                        0x2655
 #define GC2355_SENSOR_ID                        0x2355
 #define GC2235_SENSOR_ID                        0x2235
+
+#define GC2235MIPI_SENSOR_ID                        0x2235
+
 #define GC2035_SENSOR_ID                        0x2035
 #define GC2145_SENSOR_ID                        0x2145
 #define GC0330_SENSOR_ID                        0xC1
 #define GC0329_SENSOR_ID                        0xC0
 #define GC0310_SENSOR_ID                        0xa310
+#define GC0310MAIN_SENSOR_ID                    0xa311
+#define GC2155MIPI_SENSOR_ID                    0x2155
 #define GC0313MIPI_YUV_SENSOR_ID                0xD0
+#define GC0409_SENSOR_ID                        0x0409
+#define GC5004MIPI_SENSOR_ID                    0x5004
+#define GC5024MIPI_SENSOR_ID                    0x5024
 /*SP*/
 #define SP0A19_YUV_SENSOR_ID                    0xA6
-#define SP2508MIPI_SENSOR_ID 					0x2508
+#define SP0A20_SENSOR_ID                        0x2b
+#define SP2508_SENSOR_ID                        0x2508
 #define SP2518_YUV_SENSOR_ID                    0x53
+#define SP5409MIPI_SENSOR_ID                    0x5409
+#define SP5409SUBMIPI_SENSOR_ID                    0x540a
+#define SP8408MIPI_SENSOR_ID                    0x1490
 /*A*/
 #define A5141MIPI_SENSOR_ID                     0x4800
 #define A5142MIPI_SENSOR_ID                     0x4800
@@ -238,7 +257,6 @@
 #define SIM120C_SENSOR_ID                       0x0012
 #define SID130B_SENSOR_ID                       0x001b
 #define SIC110A_SENSOR_ID                       0x000D
-#define IMX164_SENSOR_ID 0x0164
 #define SIV120B_SENSOR_ID                       0x0012
 /*PAS (PixArt Image)*/
 #define PAS105_SENSOR_ID                        0x0065
@@ -258,17 +276,22 @@
 /* SENSOR DEVICE DRIVER NAME */
 /*IMX*/
 #define SENSOR_DRVNAME_IMX220_MIPI_RAW          "imx220mipiraw"
+#define SENSOR_DRVNAME_IMX145_MIPI_RAW          "imx145mipiraw"
 #define SENSOR_DRVNAME_IMX219_MIPI_RAW          "imx219mipiraw"
 #define SENSOR_DRVNAME_IMX215_MIPI_RAW          "imx215mipiraw"
 #define SENSOR_DRVNAME_IMX214_MIPI_RAW          "imx214mipiraw"
-#define SENSOR_DRVNAME_IMX164_MIPI_RAW          "imx164mipiraw"
+#define SENSOR_DRVNAME_IMX179_MIPI_RAW          "imx179mipiraw"
+#define SENSOR_DRVNAME_IMX179_MIPI_RAW_4LANE     "imx179mipiraw4lane"
+#define SENSOR_DRVNAME_IMX175_MIPI_RAW          "imx175mipiraw"
 #define SENSOR_DRVNAME_IMX178_MIPI_RAW          "imx178mipiraw"
+#define SENSOR_DRVNAME_IMX164_MIPI_RAW          "imx164mipiraw"
 #define SENSOR_DRVNAME_IMX135_MIPI_RAW          "imx135mipiraw"
 #define SENSOR_DRVNAME_IMX132_MIPI_RAW          "imx132mipiraw"
 #define SENSOR_DRVNAME_IMX119_MIPI_RAW          "imx119mipiraw"
 #define SENSOR_DRVNAME_IMX105_MIPI_RAW          "imx105mipiraw"
 #define SENSOR_DRVNAME_IMX091_MIPI_RAW          "imx091mipiraw"
 #define SENSOR_DRVNAME_IMX073_MIPI_RAW          "imx073mipiraw"
+#define SENSOR_DRVNAME_IMX166_MIPI_RAW          "imx166mipiraw"
 /*OV*/
 #define SENSOR_DRVNAME_OV16825_MIPI_RAW         "ov16825mipiraw"
 #define SENSOR_DRVNAME_OV13850_MIPI_RAW         "ov13850mipiraw"
@@ -300,28 +323,28 @@
 #define SENSOR_DRVNAME_OV5642_YUV_SWI2C         "ov5642yuvswi2c"
 #define SENSOR_DRVNAME_OV4688_MIPI_RAW          "ov4688mipiraw"
 #define SENSOR_DRVNAME_OV3640_RAW               "ov3640"
-#define SENSOR_DRVNAME_IMX164_MIPI_RAW "imx164mipiraw"
 #define SENSOR_DRVNAME_OV3640_YUV               "ov3640yuv"
 #define SENSOR_DRVNAME_OV2722_MIPI_RAW          "ov2722mipiraw"
 #define SENSOR_DRVNAME_OV2680_MIPI_RAW          "ov2680mipiraw"
 #define SENSOR_DRVNAME_OV2659_YUV               "ov2659yuv"
 #define SENSOR_DRVNAME_OV2655_YUV               "ov2655yuv"
 #define SENSOR_DRVNAME_OV2650_RAW               "ov265x"
-
 /*S5K*/
 #define SENSOR_DRVNAME_S5K2P8_MIPI_RAW          "s5k2p8mipiraw"
 #define SENSOR_DRVNAME_S5K3M2_MIPI_RAW          "s5k3m2mipiraw"
 #define SENSOR_DRVNAME_S5K3H2YX_MIPI_RAW        "s5k3h2yxmipiraw"
-
 #define SENSOR_DRVNAME_S5K3H7Y_MIPI_RAW         "s5k3h7ymipiraw"
 #define SENSOR_DRVNAME_S5K4H5YC_MIPI_RAW        "s5k4h5ycmipiraw"
 #define SENSOR_DRVNAME_S5K4E1GA_MIPI_RAW        "s5k4e1gamipiraw"
 #define SENSOR_DRVNAME_S5K4ECGX_MIPI_YUV        "s5k4ecgxmipiyuv"
 #define SENSOR_DRVNAME_S5K5CAGX_YUV             "s5k5cagxyuv"
 #define SENSOR_DRVNAME_S5K4H5YX_2LANE_MIPI_RAW  "s5k4h5yx2lanemipiraw"
+#define SENSOR_DRVNAME_S5K4E2GX_MIPI_RAW   "s5k4e2gxmipiraw"
 #define SENSOR_DRVNAME_S5K5E2YA_MIPI_RAW        "s5k5e2yamipiraw"
+#define SENSOR_DRVNAME_S5K5E2YASUB_MIPI_RAW     "s5k5e2yasubmipiraw"
 #define SENSOR_DRVNAME_S5K8AAYX_MIPI_YUV        "s5k8aayxmipiyuv"
 #define SENSOR_DRVNAME_S5K8AAYX_YUV             "s5k8aayxyuv"
+#define SENSOR_DRVNAME_S5K3H5XA_MIPI_RAW        "s5k3h5xamipiraw"
 /*HI*/
 #define SENSOR_DRVNAME_HI841_MIPI_RAW           "hi841mipiraw"
 #define SENSOR_DRVNAME_HI707_YUV                "hi707yuv"
@@ -347,17 +370,28 @@
 /*GC*/
 #define SENSOR_DRVNAME_GC2035_YUV               "gc2035_yuv"
 #define SENSOR_DRVNAME_GC2235_RAW               "gc2235_raw"
+#define SENSOR_DRVNAME_GC2235_MIPI_RAW   	"gc2235mipiraw"
+#define SENSOR_DRVNAME_GC2755_MIPI_RAW          "gc2755mipiraw"
 #define SENSOR_DRVNAME_GC2355_MIPI_RAW          "gc2355mipiraw"
 #define SENSOR_DRVNAME_GC0330_YUV               "gc0330_yuv"
 #define SENSOR_DRVNAME_GC0329_YUV               "gc0329yuv"
 #define SENSOR_DRVNAME_GC2145_MIPI_YUV          "gc2145mipiyuv"
 #define SENSOR_DRVNAME_GC0310_MIPI_YUV          "gc0310mipiyuv"
+#define SENSOR_DRVNAME_GC0310MAIN_MIPI_YUV      "gc0310mainmipiyuv"
 #define SENSOR_DRVNAME_GC0310_YUV               "gc0310yuv"
+#define SENSOR_DRVNAME_GC2155_MIPI_YUV          "gc2155mipiyuv"
 #define SENSOR_DRVNAME_GC0313MIPI_YUV           "gc0313mipiyuv"
+#define SENSOR_DRVNAME_GC0409MIPI_RAW           "gc0409mipiraw"
+#define SENSOR_DRVNAME_GC5004_MIPI_RAW          "gc5004mipiraw"
+#define SENSOR_DRVNAME_GC5024_MIPI_RAW          "gc5024mipiraw"
 /*SP*/
 #define SENSOR_DRVNAME_SP0A19_YUV               "sp0a19yuv"
+#define SENSOR_DRVNAME_SP0A20_YUV               "sp0a20yuv"
+#define SENSOR_DRVNAME_SP2508_MIPI_RAW          "sp2508mipiraw"
 #define SENSOR_DRVNAME_SP2518_YUV               "sp2518yuv"
-#define SENSOR_DRVNAME_SP2508_MIPI_RAW 			"sp2508mipiraw"
+#define SENSOR_DRVNAME_SP5409_MIPI_RAW          "sp5409_mipi_raw"
+#define SENSOR_DRVNAME_SP5409SUB_MIPI_RAW          "sp5409sub_mipi_raw"
+#define SENSOR_DRVNAME_SP8408_MIPI_RAW          "sp8408_mipi_raw"
 /*A*/
 #define SENSOR_DRVNAME_A5141_MIPI_RAW           "a5141mipiraw"
 #define SENSOR_DRVNAME_A5142_MIPI_RAW           "a5142mipiraw"
@@ -374,7 +408,6 @@
 #define SENSOR_DRVNAME_MN34152_MIPI_RAW         "mn34152mipiraw"
 /*Toshiba*/
 #define SENSOR_DRVNAME_T4KA7_MIPI_RAW           "t4ka7mipiraw"
-#define SENSOR_DRVNAME_SP8408_MIPI_RAW "sp8408mipiraw"
 /*Others*/
 #define SENSOR_DRVNAME_SHARP3D_MIPI_YUV         "sharp3dmipiyuv"
 #define SENSOR_DRVNAME_T8EV5_YUV                "t8ev5_yuv"
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6735/Makefile
index cfa71bf..500c718 100644
--- a/drivers/misc/mediatek/imgsensor/src/mt6735/Makefile
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735/Makefile
@@ -10,8 +10,19 @@ endif
 endef
 
 obj-y				+= kd_sensorlist.o
+# Vanzo:wangfei on: Wed, 12 Nov 2014 21:06:42 +0800
+# for compatible the old style ,so use CUSTOM_KERNEL_IMGSENSOR
+custom_kernel_imgsensor := $(addsuffix /, $(shell echo $(CUSTOM_KERNEL_IMGSENSOR)))
+ifeq ($(custom_kernel_imgsensor),)
+# End of Vanzo:wangfei
 
 $(foreach drv,$(subst $\",,$(CONFIG_CUSTOM_KERNEL_IMGSENSOR)),$(eval $(call FILTER_PROJECT_DRV,$(drv))))
 custom_kernel_imgsensor := $(addsuffix /, $(shell echo $(platform_drv)))
+# Vanzo:wangfei on: Thu, 13 Nov 2014 16:15:59 +0800
+# added for project config prio the defconfig
+endif
+# End of Vanzo:wangfei
+
+$(info "the custom_kernel_imgsensor:$(custom_kernel_imgsensor)")
 obj-y += $(custom_kernel_imgsensor)
 $(info imgsensor drv by platform $(platform_drv))
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/gc2155mipi_yuv/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6735/gc2155mipi_yuv/Makefile
new file mode 100755
index 0000000..d4287c0
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735/gc2155mipi_yuv/Makefile
@@ -0,0 +1,4 @@
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+obj-y += gc2155mipi_yuv_Sensor.o
+
+
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/gc2155mipi_yuv/gc2155mipi_yuv_CameraCustomized.h b/drivers/misc/mediatek/imgsensor/src/mt6735/gc2155mipi_yuv/gc2155mipi_yuv_CameraCustomized.h
new file mode 100755
index 0000000..220f867
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735/gc2155mipi_yuv/gc2155mipi_yuv_CameraCustomized.h
@@ -0,0 +1,163 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*****************************************************************************
+*  Copyright Statement:
+*  --------------------
+*  This software is protected by Copyright and the information contained
+*  herein is confidential. The software may not be copied and the information
+*  contained herein may not be used or disclosed except with the written
+*  permission of MediaTek Inc. (C) 2008
+*
+*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
+*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
+*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
+*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
+*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
+*
+*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
+*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
+*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+*
+*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
+*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
+*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
+*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
+*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
+*
+*****************************************************************************/
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *   sensor.h
+ *
+ * Project:
+ * --------
+ *   DUMA
+ *
+ * Description:
+ * ------------
+ *   Header file of camera customized parameters.
+ *
+ *
+ * Author:
+ * -------
+ *   Leo Lee
+ *
+ *============================================================================
+ *             HISTORY
+ * Below this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *------------------------------------------------------------------------------
+ * $Revision:$
+ * $Modtime:$
+ * $Log:$
+ *
+ * [GC2155MIPIYUV V1.0.0]
+ * 8.17.2012 Leo.Lee
+ * .First Release
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by GalaxyCoreinc. DO NOT MODIFY!!
+ *============================================================================
+ ****************************************************************************/
+
+#ifndef __CAMERA_CUSTOMIZED_H
+#define __CAMERA_CUSTOMIZED_H
+
+// the angle between handset and sensor placement in clockwise, should be one of 0, 90, 270
+#define MAIN_SENSOR_ORIENTATION_ANGLE	90
+#define SUB_SENSOR_ORIENTATION_ANGLE	0		// do not care if the sub sensor does not exist
+
+
+// First, we think you hold the cell phone vertical.
+// Second, we suppose the direction of upward is 0
+// Third, it is 90, 180, 270 in clockwise
+// here we define the main sensor and sub sensor angles to deal with the jpeg orientation
+#define MAIN_SENSOR_TO_PHONE_ANGLE	90
+#define SUB_SENSOR_TO_PHONE_ANGLE	0
+
+
+#define CAM_SIZE_QVGA_WIDTH 	320
+#define CAM_SIZE_QVGA_HEIGHT 	240
+#define CAM_SIZE_VGA_WIDTH 		640
+#define CAM_SIZE_VGA_HEIGHT 	480
+#define CAM_SIZE_05M_WIDTH 		800
+#define CAM_SIZE_05M_HEIGHT 	600
+#define CAM_SIZE_1M_WIDTH 		1280
+#define CAM_SIZE_1M_HEIGHT 		960
+#define CAM_SIZE_2M_WIDTH 		1600
+#define CAM_SIZE_2M_HEIGHT 		1200
+#define CAM_SIZE_3M_WIDTH 		2048
+#define CAM_SIZE_3M_HEIGHT 		1536
+#define CAM_SIZE_5M_WIDTH 		2592
+#define CAM_SIZE_5M_HEIGHT 		1944
+
+// for main sensor
+#define MAIN_NUM_OF_PREVIEW_RESOLUTION 3
+#define MAIN_NUM_OF_VIDEO_RESOLUTION 4
+#define MAIN_NUM_OF_STILL_RESOLUTION 7
+#define MAIN_VIDEO_RESOLUTION_PROFILE		{{176,144},{320,240},{640,480},{720,480}}
+#define MAIN_PREVIEW_RESOLUTION_PROFILE	{{232,174},{320,240},{240,320}}
+#define MAIN_STILL_RESOLUTION_PROFILE		{{CAM_SIZE_QVGA_WIDTH,CAM_SIZE_QVGA_HEIGHT}, \
+									 {CAM_SIZE_VGA_WIDTH,CAM_SIZE_VGA_HEIGHT}, \
+									 {CAM_SIZE_05M_WIDTH,CAM_SIZE_05M_HEIGHT}, \
+									 {CAM_SIZE_1M_WIDTH,CAM_SIZE_1M_HEIGHT}, \
+									 {CAM_SIZE_2M_WIDTH,CAM_SIZE_2M_HEIGHT}, \
+									 {CAM_SIZE_3M_WIDTH,CAM_SIZE_3M_HEIGHT}, \
+									 {CAM_SIZE_5M_WIDTH,CAM_SIZE_5M_HEIGHT}}
+
+// if sub sensor does not exist, set all the parameters as 0
+#define SUB_NUM_OF_PREVIEW_RESOLUTION 0
+#define SUB_NUM_OF_VIDEO_RESOLUTION 0
+#define SUB_NUM_OF_STILL_RESOLUTION 0
+#define SUB_VIDEO_RESOLUTION_PROFILE		{{0,0}}
+#define SUB_PREVIEW_RESOLUTION_PROFILE		{{0,0}}
+#define SUB_STILL_RESOLUTION_PROFILE		{{0,0}}
+
+//#define NUM_OF_PREVIEW_RESOLUTION 	max(MAIN_NUM_OF_PREVIEW_RESOLUTION,SUB_NUM_OF_PREVIEW_RESOLUTION)
+//#define NUM_OF_VIDEO_RESOLUTION 	max(MAIN_NUM_OF_VIDEO_RESOLUTION,SUB_NUM_OF_VIDEO_RESOLUTION)
+//#define NUM_OF_STILL_RESOLUTION 	max(MAIN_NUM_OF_STILL_RESOLUTION,SUB_NUM_OF_STILL_RESOLUTION)
+
+#define NUM_OF_VIDEO_STREAM_BUFF	8	// Maximun is 8
+#endif
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/gc2155mipi_yuv/gc2155mipi_yuv_Camera_Sensor_para.h b/drivers/misc/mediatek/imgsensor/src/mt6735/gc2155mipi_yuv/gc2155mipi_yuv_Camera_Sensor_para.h
new file mode 100755
index 0000000..ee6afd3
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735/gc2155mipi_yuv/gc2155mipi_yuv_Camera_Sensor_para.h
@@ -0,0 +1,158 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*****************************************************************************
+*  Copyright Statement:
+*  --------------------
+*  This software is protected by Copyright and the information contained
+*  herein is confidential. The software may not be copied and the information
+*  contained herein may not be used or disclosed except with the written
+*  permission of MediaTek Inc. (C) 2008
+*
+*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
+*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
+*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
+*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
+*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
+*
+*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
+*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
+*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+*
+*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
+*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
+*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
+*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
+*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
+*
+*****************************************************************************/
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *   camera_sensor_para.h
+ *
+ * Project:
+ * --------
+ *   DUMA
+ *
+ * Description:
+ * ------------
+ *   Header file of Sensor tuning parameters that should be generated by CCT
+ *
+ *
+ * Author:
+ * -------
+ *   Leo Leo
+ *
+ *============================================================================
+ *             HISTORY
+ * Below this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *------------------------------------------------------------------------------
+ * $Revision:$
+ * $Modtime:$
+ * $Log:$
+ *
+ * [GC2155MIPIYUV V1.0.0]
+ * 8.17.2012 Leo.Lee
+ * .First Release
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by GalaxyCoreinc. DO NOT MODIFY!!
+ *============================================================================
+ ****************************************************************************/
+/* SENSOR FULL SIZE */
+#ifndef __CAMERA_SENSOR_PARA_H
+#define __CAMERA_SENSOR_PARA_H
+
+#define CAMERA_SENSOR_REG_DEFAULT_VALUE  \
+		/* ARRAY: SENSOR.reg[11] */\
+		{\
+			/* STRUCT: SENSOR.reg[0] */\
+			{\
+				/* SENSOR.reg[0].addr */ 0xFFFFFFFF, /* SENSOR.reg[0].para */ 0xFFFFFFFF\
+			},\
+			/* STRUCT: SENSOR.reg[1] */\
+			{\
+				/* SENSOR.reg[1].addr */ 0xFFFFFFFF, /* SENSOR.reg[1].para */ 0xFFFFFFFF\
+			},\
+			/* STRUCT: SENSOR.reg[2] */\
+			{\
+				/* SENSOR.reg[2].addr */ 0xFFFFFFFF, /* SENSOR.reg[2].para */ 0xFFFFFFFF\
+			},\
+			/* STRUCT: SENSOR.reg[3] */\
+			{\
+				/* SENSOR.reg[3].addr */ 0xFFFFFFFF, /* SENSOR.reg[3].para */ 0xFFFFFFFF\
+			},\
+			/* STRUCT: SENSOR.reg[4] */\
+			{\
+				/* SENSOR.reg[4].addr */ 0xFFFFFFFF, /* SENSOR.reg[4].para */ 0xFFFFFFFF\
+			},\
+			/* STRUCT: SENSOR.reg[5] */\
+			{\
+				/* SENSOR.reg[5].addr */ 0xFFFFFFFF, /* SENSOR.reg[5].para */ 0xFFFFFFFF\
+			},\
+			/* STRUCT: SENSOR.reg[6] */\
+			{\
+				/* SENSOR.reg[6].addr */ 0xFFFFFFFF, /* SENSOR.reg[6].para */ 0xFFFFFFFF\
+			},\
+			/* STRUCT: SENSOR.reg[7] */\
+			{\
+				/* SENSOR.reg[7].addr */ 0xFFFFFFFF, /* SENSOR.reg[7].para */ 0xFFFFFFFF\
+			},\
+			/* STRUCT: SENSOR.reg[8] */\
+			{\
+				/* SENSOR.reg[8].addr */ 0xFFFFFFFF, /* SENSOR.reg[8].para */ 0xFFFFFFFF\
+			},\
+			/* STRUCT: SENSOR.reg[9] */\
+			{\
+				/* SENSOR.reg[9].addr */ 0xFFFFFFFF, /* SENSOR.reg[9].para */ 0xFFFFFFFF\
+			},\
+			/* STRUCT: SENSOR.reg[10] */\
+			{\
+				/* SENSOR.reg[10].addr */ 0xFFFFFFFF, /* SENSOR.reg[10].para */ 0xFFFFFFFF\
+			}\
+		}
+
+#define CAMERA_SENSOR_CCT_DEFAULT_VALUE {{ 0xFFFFFFFF, 0xFFFFFFFF } ,{ 0xFFFFFFFF, 0xFFFFFFFF } ,{ 0xFFFFFFFF, 0xFFFFFFFF } ,{ 0xFFFFFFFF, 0xFFFFFFFF } ,{ 0xFFFFFFFF, 0xFFFFFFFF }}
+#endif /* __CAMERA_SENSOR_PARA_H */
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/gc2155mipi_yuv/gc2155mipi_yuv_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735/gc2155mipi_yuv/gc2155mipi_yuv_Sensor.c
new file mode 100755
index 0000000..5a53842
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735/gc2155mipi_yuv/gc2155mipi_yuv_Sensor.c
@@ -0,0 +1,2211 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*****************************************************************************
+*  Copyright Statement:
+*  --------------------
+*  This software is protected by Copyright and the information contained
+*  herein is confidential. The software may not be copied and the information
+*  contained herein may not be used or disclosed except with the written
+*  permission of MediaTek Inc. (C) 2008
+*
+*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
+*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
+*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
+*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
+*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
+*
+*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
+*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
+*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+*
+*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
+*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
+*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
+*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
+*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
+*
+*****************************************************************************/
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *   sensor.c
+ *
+ * Project:
+ * --------
+ *  
+ *
+ * Description:
+ * ------------
+ *   Source code of Sensor driver
+ *
+ *
+ * Author:
+ * -------
+ *   Leo Lee
+ *
+ *============================================================================
+ *             HISTORY
+ * Below this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *------------------------------------------------------------------------------
+ * $Revision:$
+ * $Modtime:$
+ * $Log:$
+ *
+ * [GC2155MIPIYUV V1.0.0]
+ * 8.17.2012 Leo.Lee
+ * .First Release
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by GalaxyCoreinc. DO NOT MODIFY!!
+ *============================================================================
+ ****************************************************************************/
+//#include <windows.h>
+//#include <memory.h>
+//#include <nkintr.h>
+//#include <ceddk.h>
+//#include <ceddk_exp.h>
+
+//#include "kal_release.h"
+//#include "i2c_exp.h"
+//#include "gpio_exp.h"
+//#include "msdk_exp.h"
+//#include "msdk_sensor_exp.h"
+//#include "msdk_isp_exp.h"
+//#include "base_regs.h"
+//#include "Sensor.h"
+//#include "camera_sensor_para.h"
+//#include "CameraCustomized.h"
+
+#include <linux/videodev2.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <asm/atomic.h>
+//#include <mach/mt6516_pll.h>
+
+#include "kd_camera_hw.h"
+#include "kd_imgsensor.h"
+#include "kd_imgsensor_define.h"
+#include "kd_imgsensor_errcode.h"
+#include "kd_camera_feature.h"
+
+#include "gc2155mipi_yuv_Sensor.h"
+#include "gc2155mipi_yuv_Camera_Sensor_para.h"
+#include "gc2155mipi_yuv_CameraCustomized.h"
+
+#define GC2155MIPIYUV_DEBUG
+#ifdef GC2155MIPIYUV_DEBUG
+#define SENSORDB printk
+#else
+#define SENSORDB(x,...)
+#endif
+
+#define GC2155MIPI_2Lane
+
+//#define DEBUG_SENSOR_GC2155MIPI
+
+#define  GC2155MIPI_SET_PAGE0    GC2155MIPI_write_cmos_sensor(0xfe,0x00)
+#define  GC2155MIPI_SET_PAGE1    GC2155MIPI_write_cmos_sensor(0xfe,0x01)
+#define  GC2155MIPI_SET_PAGE2    GC2155MIPI_write_cmos_sensor(0xfe,0x02)
+#define  GC2155MIPI_SET_PAGE3    GC2155MIPI_write_cmos_sensor(0xfe,0x03)
+
+
+extern int iReadRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u8 * a_pRecvData, u16 a_sizeRecvData, u16 i2cId);
+extern int iWriteRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u16 i2cId);
+/*************************************************************************
+* FUNCTION
+*    GC2155MIPI_write_cmos_sensor
+*
+* DESCRIPTION
+*    This function wirte data to CMOS sensor through I2C
+*
+* PARAMETERS
+*    addr: the 16bit address of register
+*    para: the 8bit value of register
+*
+* RETURNS
+*    None
+*
+* LOCAL AFFECTED
+*
+*************************************************************************/
+static void GC2155MIPI_write_cmos_sensor(kal_uint8 addr, kal_uint8 para)
+{
+kal_uint8 out_buff[2];
+
+    out_buff[0] = addr;
+    out_buff[1] = para;
+
+    iWriteRegI2C((u8*)out_buff , (u16)sizeof(out_buff), GC2155MIPI_WRITE_ID); 
+
+#if (defined(__GC2155MIPI_DEBUG_TRACE__))
+  if (sizeof(out_buff) != rt) printk("I2C write %x, %x error\n", addr, para);
+#endif
+}
+
+/*************************************************************************
+* FUNCTION
+*    GC2155MIPI_read_cmos_sensor
+*
+* DESCRIPTION
+*    This function read data from CMOS sensor through I2C.
+*
+* PARAMETERS
+*    addr: the 16bit address of register
+*
+* RETURNS
+*    8bit data read through I2C
+*
+* LOCAL AFFECTED
+*
+*************************************************************************/
+static kal_uint8 GC2155MIPI_read_cmos_sensor(kal_uint8 addr)
+{
+  kal_uint8 in_buff[1] = {0xFF};
+  kal_uint8 out_buff[1];
+  
+  out_buff[0] = addr;
+
+    if (0 != iReadRegI2C((u8*)out_buff , (u16) sizeof(out_buff), (u8*)in_buff, (u16) sizeof(in_buff), GC2155MIPI_WRITE_ID)) {
+        SENSORDB("ERROR: GC2155MIPI_read_cmos_sensor \n");
+    }
+
+#if (defined(__GC2155MIPI_DEBUG_TRACE__))
+  if (size != rt) printk("I2C read %x error\n", addr);
+#endif
+
+  return in_buff[0];
+}
+
+
+#ifdef DEBUG_SENSOR_GC2155MIPI
+#define gc2155mipi_OP_CODE_INI		0x00		/* Initial value. */
+#define gc2155mipi_OP_CODE_REG		0x01		/* Register */
+#define gc2155mipi_OP_CODE_DLY		0x02		/* Delay */
+#define gc2155mipi_OP_CODE_END		0x03		/* End of initial setting. */
+static kal_uint16 fromsd;
+
+typedef struct
+{
+	u16 init_reg;
+	u16 init_val;	/* Save the register value and delay tick */
+	u8 op_code;		/* 0 - Initial value, 1 - Register, 2 - Delay, 3 - End of setting. */
+} gc2155mipi_initial_set_struct;
+
+gc2155mipi_initial_set_struct gc2155mipi_Init_Reg[5000];
+
+static u32 strtol(const char *nptr, u8 base)
+{
+
+	printk("gc2155mipi___%s____\n",__func__); 
+
+	u8 ret;
+	if(!nptr || (base!=16 && base!=10 && base!=8))
+	{
+		printk("gc2155mipi %s(): NULL pointer input\n", __FUNCTION__);
+		return -1;
+	}
+	for(ret=0; *nptr; nptr++)
+	{
+		if((base==16 && *nptr>='A' && *nptr<='F') || 
+				(base==16 && *nptr>='a' && *nptr<='f') || 
+				(base>=10 && *nptr>='0' && *nptr<='9') ||
+				(base>=8 && *nptr>='0' && *nptr<='7') )
+		{
+			ret *= base;
+			if(base==16 && *nptr>='A' && *nptr<='F')
+				ret += *nptr-'A'+10;
+			else if(base==16 && *nptr>='a' && *nptr<='f')
+				ret += *nptr-'a'+10;
+			else if(base>=10 && *nptr>='0' && *nptr<='9')
+				ret += *nptr-'0';
+			else if(base>=8 && *nptr>='0' && *nptr<='7')
+				ret += *nptr-'0';
+		}
+		else
+			return ret;
+	}
+	return ret;
+}
+
+static u8 GC2155MIPI_Initialize_from_T_Flash()
+{
+	//FS_HANDLE fp = -1;				/* Default, no file opened. */
+	//u8 *data_buff = NULL;
+	u8 *curr_ptr = NULL;
+	u32 file_size = 0;
+	//u32 bytes_read = 0;
+	u32 i = 0, j = 0;
+	u8 func_ind[4] = {0};	/* REG or DLY */
+
+	printk("gc2155mipi___%s____11111111111111\n",__func__); 
+
+
+
+	struct file *fp; 
+	mm_segment_t fs; 
+	loff_t pos = 0; 
+	static u8 data_buff[10*1024] ;
+
+	fp = filp_open("/mnt/sdcard/gc2155mipi_sd.txt", O_RDONLY , 0); 
+	if (IS_ERR(fp)) 
+	{ 
+		printk("2155 create file error 1111111\n");  
+		return -1; 
+	} 
+	else
+	{
+		printk("2155 create file error 2222222\n");  
+	}
+	fs = get_fs(); 
+	set_fs(KERNEL_DS); 
+
+	file_size = vfs_llseek(fp, 0, SEEK_END);
+	vfs_read(fp, data_buff, file_size, &pos); 
+	//printk("%s %d %d\n", buf,iFileLen,pos); 
+	filp_close(fp, NULL); 
+	set_fs(fs);
+
+
+	printk("gc2155mipi___%s____22222222222222222\n",__func__); 
+
+
+
+	/* Start parse the setting witch read from t-flash. */
+	curr_ptr = data_buff;
+	while (curr_ptr < (data_buff + file_size))
+	{
+		while ((*curr_ptr == ' ') || (*curr_ptr == '\t'))/* Skip the Space & TAB */
+			curr_ptr++;				
+
+		if (((*curr_ptr) == '/') && ((*(curr_ptr + 1)) == '*'))
+		{
+			while (!(((*curr_ptr) == '*') && ((*(curr_ptr + 1)) == '/')))
+			{
+				curr_ptr++;		/* Skip block comment code. */
+			}
+
+			while (!((*curr_ptr == 0x0D) && (*(curr_ptr+1) == 0x0A)))
+			{
+				curr_ptr++;
+			}
+
+			curr_ptr += 2;						/* Skip the enter line */
+
+			continue ;
+		}
+
+		if (((*curr_ptr) == '/') || ((*curr_ptr) == '{') || ((*curr_ptr) == '}'))		/* Comment line, skip it. */
+		{
+			while (!((*curr_ptr == 0x0D) && (*(curr_ptr+1) == 0x0A)))
+			{
+				curr_ptr++;
+			}
+
+			curr_ptr += 2;						/* Skip the enter line */
+
+			continue ;
+		}
+		/* This just content one enter line. */
+		if (((*curr_ptr) == 0x0D) && ((*(curr_ptr + 1)) == 0x0A))
+		{
+			curr_ptr += 2;
+			continue ;
+		}
+		//printk(" curr_ptr1 = %s\n",curr_ptr);
+		memcpy(func_ind, curr_ptr, 3);
+
+
+		if (strcmp((const char *)func_ind, "REG") == 0)		/* REG */
+		{
+			curr_ptr += 6;				/* Skip "REG(0x" or "DLY(" */
+			gc2155mipi_Init_Reg[i].op_code = gc2155mipi_OP_CODE_REG;
+
+			gc2155mipi_Init_Reg[i].init_reg = strtol((const char *)curr_ptr, 16);
+			curr_ptr += 5;	/* Skip "00, 0x" */
+
+			gc2155mipi_Init_Reg[i].init_val = strtol((const char *)curr_ptr, 16);
+			curr_ptr += 4;	/* Skip "00);" */
+
+		}
+		else									/* DLY */
+		{
+			/* Need add delay for this setting. */ 
+			curr_ptr += 4;	
+			gc2155mipi_Init_Reg[i].op_code = gc2155mipi_OP_CODE_DLY;
+
+			gc2155mipi_Init_Reg[i].init_reg = 0xFF;
+			gc2155mipi_Init_Reg[i].init_val = strtol((const char *)curr_ptr,  10);	/* Get the delay ticks, the delay should less then 50 */
+		}
+		i++;
+
+
+		/* Skip to next line directly. */
+		while (!((*curr_ptr == 0x0D) && (*(curr_ptr+1) == 0x0A)))
+		{
+			curr_ptr++;
+		}
+		curr_ptr += 2;
+	}
+
+	/* (0xFFFF, 0xFFFF) means the end of initial setting. */
+	gc2155mipi_Init_Reg[i].op_code = gc2155mipi_OP_CODE_END;
+	gc2155mipi_Init_Reg[i].init_reg = 0xFF;
+	gc2155mipi_Init_Reg[i].init_val = 0xFF;
+	i++;
+	//for (j=0; j<i; j++)
+	printk("gc2155mipi %x  ==  %x\n",gc2155mipi_Init_Reg[j].init_reg, gc2155mipi_Init_Reg[j].init_val);
+	
+	printk("gc2155mipi___%s____3333333333333333\n",__func__); 
+
+	/* Start apply the initial setting to sensor. */
+#if 1
+	for (j=0; j<i; j++)
+	{
+		if (gc2155mipi_Init_Reg[j].op_code == gc2155mipi_OP_CODE_END)	/* End of the setting. */
+		{
+			printk("gc2155mipi REG OK -----------------END!\n");
+		
+			break ;
+		}
+		else if (gc2155mipi_Init_Reg[j].op_code == gc2155mipi_OP_CODE_DLY)
+		{
+			msleep(gc2155mipi_Init_Reg[j].init_val);		/* Delay */
+			printk("gc2155mipi REG OK -----------------DLY!\n");			
+		}
+		else if (gc2155mipi_Init_Reg[j].op_code == gc2155mipi_OP_CODE_REG)
+		{
+
+			GC2155MIPI_write_cmos_sensor(gc2155mipi_Init_Reg[j].init_reg, gc2155mipi_Init_Reg[j].init_val);
+			printk("gc2155mipi REG OK!-----------------REG(0x%x,0x%x)\n",gc2155mipi_Init_Reg[j].init_reg, gc2155mipi_Init_Reg[j].init_val);			
+			printk("gc2155mipi REG OK!-----------------REG(0x%x,0x%x)\n",gc2155mipi_Init_Reg[j].init_reg, gc2155mipi_Init_Reg[j].init_val);			
+			printk("gc2155mipi REG OK!-----------------REG(0x%x,0x%x)\n",gc2155mipi_Init_Reg[j].init_reg, gc2155mipi_Init_Reg[j].init_val);			
+			
+		}
+		else
+		{
+			printk("gc2155mipi REG ERROR!\n");
+		}
+	}
+#endif
+	return 1;	
+}
+
+#endif
+
+
+/*******************************************************************************
+* // Adapter for Winmo typedef 
+********************************************************************************/
+#define Sleep(ms) mdelay(ms)
+#define RETAILMSG(x,...)
+#define TEXT
+
+
+/*******************************************************************************
+* // End Adapter for Winmo typedef 
+********************************************************************************/
+/* Global Valuable */
+
+static kal_uint32 zoom_factor = 0; 
+
+static kal_bool GC2155MIPI_VEDIO_encode_mode = KAL_FALSE; //Picture(Jpeg) or Video(Mpeg4)
+static kal_bool GC2155MIPI_sensor_cap_state = KAL_FALSE; //Preview or Capture
+
+static kal_uint16 GC2155MIPI_exposure_lines=0, GC2155MIPI_extra_exposure_lines = 0;
+
+static kal_uint16 GC2155MIPI_Capture_Shutter=0;
+static kal_uint16 GC2155MIPI_Capture_Extra_Lines=0;
+
+kal_uint32 GC2155MIPI_capture_pclk_in_M=520,GC2155MIPI_preview_pclk_in_M=390,GC2155MIPI_PV_dummy_pixels=0,GC2155MIPI_PV_dummy_lines=0,GC2155MIPI_isp_master_clock=0;
+
+static kal_uint32  GC2155MIPI_sensor_pclk=390;
+
+static kal_uint32 Preview_Shutter = 0;
+static kal_uint32 Capture_Shutter = 0;
+
+MSDK_SENSOR_CONFIG_STRUCT GC2155MIPISensorConfigData;
+
+kal_uint16 GC2155MIPI_read_shutter(void)
+{
+	return  (GC2155MIPI_read_cmos_sensor(0x03) << 8)|GC2155MIPI_read_cmos_sensor(0x04) ;
+} /* GC2155MIPI read_shutter */
+
+
+
+static void GC2155MIPI_write_shutter(kal_uint32 shutter)
+{
+
+	if(shutter < 1)	
+ 	return;
+
+	GC2155MIPI_write_cmos_sensor(0x03, (shutter >> 8) & 0x1f);
+	GC2155MIPI_write_cmos_sensor(0x04, shutter & 0xff);
+}    /* GC2155MIPI_write_shutter */
+
+
+static void GC2155MIPI_set_mirror_flip(kal_uint8 image_mirror)
+{
+	kal_uint8 GC2155MIPI_HV_Mirror;
+
+	switch (image_mirror) 
+	{
+		case IMAGE_NORMAL:
+			GC2155MIPI_HV_Mirror = 0x14; 
+		    break;
+		case IMAGE_H_MIRROR:
+			GC2155MIPI_HV_Mirror = 0x15;
+		    break;
+		case IMAGE_V_MIRROR:
+			GC2155MIPI_HV_Mirror = 0x16; 
+		    break;
+		case IMAGE_HV_MIRROR:
+			GC2155MIPI_HV_Mirror = 0x17;
+		    break;
+		default:
+		    break;
+	}
+	GC2155MIPI_write_cmos_sensor(0x17, GC2155MIPI_HV_Mirror);
+}
+
+static void GC2155MIPI_set_AE_mode(kal_bool AE_enable)
+{
+	kal_uint8 temp_AE_reg = 0;
+
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+	if (AE_enable == KAL_TRUE)
+	{
+		// turn on AEC/AGC
+		GC2155MIPI_write_cmos_sensor(0xb6, 0x01);
+	}
+	else
+	{
+		// turn off AEC/AGC
+		GC2155MIPI_write_cmos_sensor(0xb6, 0x00);
+	}
+}
+
+
+static void GC2155MIPI_set_AWB_mode(kal_bool AWB_enable)
+{
+	kal_uint8 temp_AWB_reg = 0;
+
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+	temp_AWB_reg = GC2155MIPI_read_cmos_sensor(0x82);
+	if (AWB_enable == KAL_TRUE)
+	{
+		//enable Auto WB
+		temp_AWB_reg = temp_AWB_reg | 0x02;
+	}
+	else
+	{
+		//turn off AWB
+		temp_AWB_reg = temp_AWB_reg & 0xfd;
+	}
+	GC2155MIPI_write_cmos_sensor(0x82, temp_AWB_reg);
+}
+
+
+/*************************************************************************
+* FUNCTION
+*	GC2155MIPI_night_mode
+*
+* DESCRIPTION
+*	This function night mode of GC2155MIPI.
+*
+* PARAMETERS
+*	none
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+void GC2155MIPI_night_mode(kal_bool enable)
+{
+	
+		/* ==Video Preview, Auto Mode, use 39MHz PCLK, 30fps; Night Mode use 39M, 15fps */
+		if (GC2155MIPI_sensor_cap_state == KAL_FALSE) 
+		{
+			if (enable) 
+			{
+				if (GC2155MIPI_VEDIO_encode_mode == KAL_TRUE) 
+				{
+					GC2155MIPI_write_cmos_sensor(0xfe, 0x01);
+					GC2155MIPI_write_cmos_sensor(0x3c, 0x60);
+					GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+				}
+				else 
+				{
+					GC2155MIPI_write_cmos_sensor(0xfe, 0x01);
+					GC2155MIPI_write_cmos_sensor(0x3c, 0x60);
+					GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+				}
+			}
+			else 
+			{
+				/* when enter normal mode (disable night mode) without light, the AE vibrate */
+				if (GC2155MIPI_VEDIO_encode_mode == KAL_TRUE) 
+				{
+					GC2155MIPI_write_cmos_sensor(0xfe, 0x01);
+					GC2155MIPI_write_cmos_sensor(0x3c, 0x40);
+					GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+				}
+				else 
+				{
+					GC2155MIPI_write_cmos_sensor(0xfe, 0x01);
+					GC2155MIPI_write_cmos_sensor(0x3c, 0x40);
+					GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+				}
+		}
+	}
+}	/* GC2155MIPI_night_mode */
+
+
+
+/*************************************************************************
+* FUNCTION
+*	GC2155MIPI_GetSensorID
+*
+* DESCRIPTION
+*	This function get the sensor ID
+*
+* PARAMETERS
+*	None
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 GC2155MIPI_GetSensorID(kal_uint32 *sensorID)
+
+{
+	   int  retry = 3; 
+    // check if sensor ID correct
+    do {
+	
+	*sensorID=((GC2155MIPI_read_cmos_sensor(0xf0) << 8) | GC2155MIPI_read_cmos_sensor(0xf1));	
+	 if (*sensorID == GC2155MIPI_SENSOR_ID)
+            break; 
+
+	SENSORDB("GC2155MIPI_GetSensorID:%x \n",*sensorID);
+	retry--;
+
+	  } while (retry > 0);
+	
+	if (*sensorID != GC2155MIPI_SENSOR_ID) {		
+		*sensorID = 0xFFFFFFFF;		
+		return ERROR_SENSOR_CONNECT_FAIL;
+	}
+	/* camera_pdn_reverse = 1; */
+	return ERROR_NONE;
+}   /* GC2155MIPIOpen  */
+
+static void GC2155MIPI_Sensor_Init(void)
+{
+	zoom_factor = 0; 
+	SENSORDB("GC2155MIPI_Sensor_Init");
+	GC2155MIPI_write_cmos_sensor(0xfe, 0xf0);
+	GC2155MIPI_write_cmos_sensor(0xfe, 0xf0);
+	GC2155MIPI_write_cmos_sensor(0xfe, 0xf0);
+	GC2155MIPI_write_cmos_sensor(0xfc, 0x06);
+	GC2155MIPI_write_cmos_sensor(0xf6, 0x00);
+	GC2155MIPI_write_cmos_sensor(0xf7, 0x1d);
+	GC2155MIPI_write_cmos_sensor(0xf8, 0x84);
+	GC2155MIPI_write_cmos_sensor(0xfa, 0x00);
+	GC2155MIPI_write_cmos_sensor(0xf9, 0x8e);
+	GC2155MIPI_write_cmos_sensor(0xf2, 0x00);
+	/////////////////////////////////////////////////
+	//////////////////ISP reg//////////////////////
+	////////////////////////////////////////////////////
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x03 , 0x04);
+	GC2155MIPI_write_cmos_sensor(0x04 , 0xe2);
+	GC2155MIPI_write_cmos_sensor(0x09 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x0a , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x0b , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x0c , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x0d , 0x04);
+	GC2155MIPI_write_cmos_sensor(0x0e , 0xc0);
+	GC2155MIPI_write_cmos_sensor(0x0f , 0x06);
+	GC2155MIPI_write_cmos_sensor(0x10 , 0x50);
+	GC2155MIPI_write_cmos_sensor(0x12 , 0x2e);
+	GC2155MIPI_write_cmos_sensor(0x17 , 0x14); // mirror
+	GC2155MIPI_write_cmos_sensor(0x18 , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x19 , 0x0e);
+	GC2155MIPI_write_cmos_sensor(0x1a , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x1b , 0x4b);
+	GC2155MIPI_write_cmos_sensor(0x1c , 0x07);
+	GC2155MIPI_write_cmos_sensor(0x1d , 0x10);
+	GC2155MIPI_write_cmos_sensor(0x1e , 0x98);
+	GC2155MIPI_write_cmos_sensor(0x1f , 0x78);
+	GC2155MIPI_write_cmos_sensor(0x20 , 0x05);
+	GC2155MIPI_write_cmos_sensor(0x21 , 0x40);
+	GC2155MIPI_write_cmos_sensor(0x22 , 0xf0);
+	GC2155MIPI_write_cmos_sensor(0x24 , 0x16);
+	GC2155MIPI_write_cmos_sensor(0x25 , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x26 , 0x10);
+	GC2155MIPI_write_cmos_sensor(0x2d , 0x40);
+	GC2155MIPI_write_cmos_sensor(0x30 , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x31 , 0x90);
+	GC2155MIPI_write_cmos_sensor(0x33 , 0x04);
+	GC2155MIPI_write_cmos_sensor(0x34 , 0x01);
+	/////////////////////////////////////////////////
+	//////////////////ISP reg////////////////////
+	/////////////////////////////////////////////////
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x80 , 0xff);
+	GC2155MIPI_write_cmos_sensor(0x81 , 0x2c);
+	GC2155MIPI_write_cmos_sensor(0x82 , 0xfa);
+	GC2155MIPI_write_cmos_sensor(0x83 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x84 , 0x03); //01
+	GC2155MIPI_write_cmos_sensor(0x85 , 0x08);// 
+	GC2155MIPI_write_cmos_sensor(0x86 , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x89 , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x8a , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x8b , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xb0 , 0x55);
+	GC2155MIPI_write_cmos_sensor(0xc3 , 0x11); //00
+	GC2155MIPI_write_cmos_sensor(0xc4 , 0x20);
+	GC2155MIPI_write_cmos_sensor(0xc5 , 0x30);
+	GC2155MIPI_write_cmos_sensor(0xc6 , 0x38);
+	GC2155MIPI_write_cmos_sensor(0xc7 , 0x40);
+	GC2155MIPI_write_cmos_sensor(0xec , 0x02);
+	GC2155MIPI_write_cmos_sensor(0xed , 0x04);
+	GC2155MIPI_write_cmos_sensor(0xee , 0x60);
+	GC2155MIPI_write_cmos_sensor(0xef , 0x90);
+	GC2155MIPI_write_cmos_sensor(0xb6 , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x90 , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x91 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x92 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x93 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x94 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x95 , 0x04);
+	GC2155MIPI_write_cmos_sensor(0x96 , 0xb0);
+	GC2155MIPI_write_cmos_sensor(0x97 , 0x06);
+	GC2155MIPI_write_cmos_sensor(0x98 , 0x40);
+	/////////////////////////////////////////
+	/////////// , 0xBLK ////////////////////////
+	/////////////////////////////////////////
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x18 , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x40 , 0x42);
+	GC2155MIPI_write_cmos_sensor(0x41 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x43 , 0x5b);
+	GC2155MIPI_write_cmos_sensor(0x5e , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x5f , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x60 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x61 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x62 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x63 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x64 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x65 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x66 , 0x20);
+	GC2155MIPI_write_cmos_sensor(0x67 , 0x20);
+	GC2155MIPI_write_cmos_sensor(0x68 , 0x20);
+	GC2155MIPI_write_cmos_sensor(0x69 , 0x20);
+	GC2155MIPI_write_cmos_sensor(0x6a , 0x08);
+	GC2155MIPI_write_cmos_sensor(0x6b , 0x08);
+	GC2155MIPI_write_cmos_sensor(0x6c , 0x08);
+	GC2155MIPI_write_cmos_sensor(0x6d , 0x08);
+	GC2155MIPI_write_cmos_sensor(0x6e , 0x08);
+	GC2155MIPI_write_cmos_sensor(0x6f , 0x08);
+	GC2155MIPI_write_cmos_sensor(0x70 , 0x08);
+	GC2155MIPI_write_cmos_sensor(0x71 , 0x08);
+	GC2155MIPI_write_cmos_sensor(0x72 , 0xf0);
+	GC2155MIPI_write_cmos_sensor(0x7e , 0x3c);
+	GC2155MIPI_write_cmos_sensor(0x7f , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+	////////////////////////////////////////
+	/////////// AEC ////////////////////////
+	////////////////////////////////////////
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x01 , 0x08);
+	GC2155MIPI_write_cmos_sensor(0x02 , 0xc0);
+	GC2155MIPI_write_cmos_sensor(0x03 , 0x04);
+	GC2155MIPI_write_cmos_sensor(0x04 , 0x90);
+	GC2155MIPI_write_cmos_sensor(0x05 , 0x30);
+	GC2155MIPI_write_cmos_sensor(0x06 , 0x98);
+	GC2155MIPI_write_cmos_sensor(0x07 , 0x28);
+	GC2155MIPI_write_cmos_sensor(0x08 , 0x6c);
+	GC2155MIPI_write_cmos_sensor(0x09 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x0a , 0xc2);
+	GC2155MIPI_write_cmos_sensor(0x0b , 0x11);
+	GC2155MIPI_write_cmos_sensor(0x0c , 0x10);
+	GC2155MIPI_write_cmos_sensor(0x13 , 0x2d);
+	GC2155MIPI_write_cmos_sensor(0x17 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x1c , 0x11);
+	GC2155MIPI_write_cmos_sensor(0x1e , 0x61);
+	GC2155MIPI_write_cmos_sensor(0x1f , 0x30);
+	GC2155MIPI_write_cmos_sensor(0x20 , 0x40);
+	GC2155MIPI_write_cmos_sensor(0x22 , 0x80);
+	GC2155MIPI_write_cmos_sensor(0x23 , 0x20);
+
+	GC2155MIPI_write_cmos_sensor(0x12 , 0x35);
+	GC2155MIPI_write_cmos_sensor(0x15 , 0x50);
+	GC2155MIPI_write_cmos_sensor(0x10 , 0x31);
+	GC2155MIPI_write_cmos_sensor(0x3e , 0x28);
+	GC2155MIPI_write_cmos_sensor(0x3f , 0xe0);
+	GC2155MIPI_write_cmos_sensor(0x40 , 0xe0);
+	GC2155MIPI_write_cmos_sensor(0x41 , 0x08);
+
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x0f , 0x05);
+	/////////////////////////////
+	//////// INTPEE /////////////
+	/////////////////////////////
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x90 , 0x6c);
+	GC2155MIPI_write_cmos_sensor(0x91 , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x92 , 0xc4);
+	GC2155MIPI_write_cmos_sensor(0x97 , 0x64);
+	GC2155MIPI_write_cmos_sensor(0x98 , 0x88);
+	GC2155MIPI_write_cmos_sensor(0x9d , 0x08);
+	GC2155MIPI_write_cmos_sensor(0xa2 , 0x11);
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+	/////////////////////////////
+	//////// DNDD///////////////
+	/////////////////////////////
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x80 , 0xc1);
+	GC2155MIPI_write_cmos_sensor(0x81 , 0x08);
+	GC2155MIPI_write_cmos_sensor(0x82 , 0x05);
+	GC2155MIPI_write_cmos_sensor(0x83 , 0x04);
+	GC2155MIPI_write_cmos_sensor(0x84 , 0x0a);
+	GC2155MIPI_write_cmos_sensor(0x86 , 0x80);
+	GC2155MIPI_write_cmos_sensor(0x87 , 0x30);
+	GC2155MIPI_write_cmos_sensor(0x88 , 0x15);
+	GC2155MIPI_write_cmos_sensor(0x89 , 0x80);
+	GC2155MIPI_write_cmos_sensor(0x8a , 0x60);
+	GC2155MIPI_write_cmos_sensor(0x8b , 0x30);
+	/////////////////////////////////////////
+	/////////// ASDE ////////////////////////
+	/////////////////////////////////////////
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x21 , 0x14);
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x3c , 0x06);
+	GC2155MIPI_write_cmos_sensor(0x3d , 0x40);
+	GC2155MIPI_write_cmos_sensor(0x48 , 0x30);
+	GC2155MIPI_write_cmos_sensor(0x49 , 0x06);
+	GC2155MIPI_write_cmos_sensor(0x4b , 0x08);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x20);
+	GC2155MIPI_write_cmos_sensor(0xa3 , 0x50);
+	GC2155MIPI_write_cmos_sensor(0xa4 , 0x30);
+	GC2155MIPI_write_cmos_sensor(0xa5 , 0x40);
+	GC2155MIPI_write_cmos_sensor(0xa6 , 0x80);
+	GC2155MIPI_write_cmos_sensor(0xab , 0x40);
+	GC2155MIPI_write_cmos_sensor(0xae , 0x0c);
+	GC2155MIPI_write_cmos_sensor(0xb3 , 0x42);
+	GC2155MIPI_write_cmos_sensor(0xb4 , 0x24);
+	GC2155MIPI_write_cmos_sensor(0xb6 , 0x50);
+	GC2155MIPI_write_cmos_sensor(0xb7 , 0x01);
+	GC2155MIPI_write_cmos_sensor(0xb9 , 0x28); 
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);	 
+	///////////////////gamma1////////////////////
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x10 , 0x0d);
+	GC2155MIPI_write_cmos_sensor(0x11 , 0x12);
+	GC2155MIPI_write_cmos_sensor(0x12 , 0x17);
+	GC2155MIPI_write_cmos_sensor(0x13 , 0x1c);
+	GC2155MIPI_write_cmos_sensor(0x14 , 0x27);
+	GC2155MIPI_write_cmos_sensor(0x15 , 0x34);
+	GC2155MIPI_write_cmos_sensor(0x16 , 0x44);
+	GC2155MIPI_write_cmos_sensor(0x17 , 0x55);
+	GC2155MIPI_write_cmos_sensor(0x18 , 0x6e);
+	GC2155MIPI_write_cmos_sensor(0x19 , 0x81);
+	GC2155MIPI_write_cmos_sensor(0x1a , 0x91);
+	GC2155MIPI_write_cmos_sensor(0x1b , 0x9c);
+	GC2155MIPI_write_cmos_sensor(0x1c , 0xaa);
+	GC2155MIPI_write_cmos_sensor(0x1d , 0xbb);
+	GC2155MIPI_write_cmos_sensor(0x1e , 0xca);
+	GC2155MIPI_write_cmos_sensor(0x1f , 0xd5);
+	GC2155MIPI_write_cmos_sensor(0x20 , 0xe0);
+	GC2155MIPI_write_cmos_sensor(0x21 , 0xe7);
+	GC2155MIPI_write_cmos_sensor(0x22 , 0xed);
+	GC2155MIPI_write_cmos_sensor(0x23 , 0xf6);
+	GC2155MIPI_write_cmos_sensor(0x24 , 0xfb);
+	GC2155MIPI_write_cmos_sensor(0x25 , 0xff);
+	///////////////////gamma2////////////////////
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x26 , 0x0d);
+	GC2155MIPI_write_cmos_sensor(0x27 , 0x12);
+	GC2155MIPI_write_cmos_sensor(0x28 , 0x17);
+	GC2155MIPI_write_cmos_sensor(0x29 , 0x1c);
+	GC2155MIPI_write_cmos_sensor(0x2a , 0x27);
+	GC2155MIPI_write_cmos_sensor(0x2b , 0x34);
+	GC2155MIPI_write_cmos_sensor(0x2c , 0x44);
+	GC2155MIPI_write_cmos_sensor(0x2d , 0x55);
+	GC2155MIPI_write_cmos_sensor(0x2e , 0x6e);
+	GC2155MIPI_write_cmos_sensor(0x2f , 0x81);
+	GC2155MIPI_write_cmos_sensor(0x30 , 0x91);
+	GC2155MIPI_write_cmos_sensor(0x31 , 0x9c);
+	GC2155MIPI_write_cmos_sensor(0x32 , 0xaa);
+	GC2155MIPI_write_cmos_sensor(0x33 , 0xbb);
+	GC2155MIPI_write_cmos_sensor(0x34 , 0xca);
+	GC2155MIPI_write_cmos_sensor(0x35 , 0xd5);
+	GC2155MIPI_write_cmos_sensor(0x36 , 0xe0);
+	GC2155MIPI_write_cmos_sensor(0x37 , 0xe7);
+	GC2155MIPI_write_cmos_sensor(0x38 , 0xed);
+	GC2155MIPI_write_cmos_sensor(0x39 , 0xf6);
+	GC2155MIPI_write_cmos_sensor(0x3a , 0xfb);
+	GC2155MIPI_write_cmos_sensor(0x3b , 0xff);
+	/////////////////////////////////////////////// 
+	///////////YCP /////////////////////// 
+	/////////////////////////////////////////////// 
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x02);
+	GC2155MIPI_write_cmos_sensor(0xd1 , 0x28);
+	GC2155MIPI_write_cmos_sensor(0xd2 , 0x28);
+	GC2155MIPI_write_cmos_sensor(0xdd , 0x14);
+	GC2155MIPI_write_cmos_sensor(0xde , 0x88);
+	GC2155MIPI_write_cmos_sensor(0xed , 0x80);
+	/////////////////////////////////////////////
+	//////////////////////// LSC ///////////////
+	//////////////////////////////////////////
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x01);
+	GC2155MIPI_write_cmos_sensor(0xc2 , 0x1f);
+	GC2155MIPI_write_cmos_sensor(0xc3 , 0x13);
+	GC2155MIPI_write_cmos_sensor(0xc4 , 0x0e);
+	GC2155MIPI_write_cmos_sensor(0xc8 , 0x16);
+	GC2155MIPI_write_cmos_sensor(0xc9 , 0x0f);
+	GC2155MIPI_write_cmos_sensor(0xca , 0x0c);
+	GC2155MIPI_write_cmos_sensor(0xbc , 0x52);
+	GC2155MIPI_write_cmos_sensor(0xbd , 0x2c);
+	GC2155MIPI_write_cmos_sensor(0xbe , 0x27);
+	GC2155MIPI_write_cmos_sensor(0xb6 , 0x47);
+	GC2155MIPI_write_cmos_sensor(0xb7 , 0x32);
+	GC2155MIPI_write_cmos_sensor(0xb8 , 0x30);
+	GC2155MIPI_write_cmos_sensor(0xc5 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xc6 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xc7 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xcb , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xcc , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xcd , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xbf , 0x0e);
+	GC2155MIPI_write_cmos_sensor(0xc0 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xc1 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xb9 , 0x08);
+	GC2155MIPI_write_cmos_sensor(0xba , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xbb , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xaa , 0x0a);
+	GC2155MIPI_write_cmos_sensor(0xab , 0x0c);
+	GC2155MIPI_write_cmos_sensor(0xac , 0x0d);
+	GC2155MIPI_write_cmos_sensor(0xad , 0x02);
+	GC2155MIPI_write_cmos_sensor(0xae , 0x06);
+	GC2155MIPI_write_cmos_sensor(0xaf , 0x05);
+	GC2155MIPI_write_cmos_sensor(0xb0 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xb1 , 0x05);
+	GC2155MIPI_write_cmos_sensor(0xb2 , 0x02);
+	GC2155MIPI_write_cmos_sensor(0xb3 , 0x04);
+	GC2155MIPI_write_cmos_sensor(0xb4 , 0x04);
+	GC2155MIPI_write_cmos_sensor(0xb5 , 0x05);
+	GC2155MIPI_write_cmos_sensor(0xd0 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xd1 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xd2 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xd6 , 0x02);
+	GC2155MIPI_write_cmos_sensor(0xd7 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xd8 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xd9 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xda , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xdb , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xd3 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xd4 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xd5 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xa4 , 0x04);
+	GC2155MIPI_write_cmos_sensor(0xa5 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xa6 , 0x77);
+	GC2155MIPI_write_cmos_sensor(0xa7 , 0x77);
+	GC2155MIPI_write_cmos_sensor(0xa8 , 0x77);
+	GC2155MIPI_write_cmos_sensor(0xa9 , 0x77);
+	GC2155MIPI_write_cmos_sensor(0xa1 , 0x80);
+	GC2155MIPI_write_cmos_sensor(0xa2 , 0x80);
+
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x01);
+	GC2155MIPI_write_cmos_sensor(0xdc , 0x35);
+	GC2155MIPI_write_cmos_sensor(0xdd , 0x28);
+	GC2155MIPI_write_cmos_sensor(0xdf , 0x0d);
+	GC2155MIPI_write_cmos_sensor(0xe0 , 0x70);
+	GC2155MIPI_write_cmos_sensor(0xe1 , 0x78);
+	GC2155MIPI_write_cmos_sensor(0xe2 , 0x70);
+	GC2155MIPI_write_cmos_sensor(0xe3 , 0x78);
+	GC2155MIPI_write_cmos_sensor(0xe6 , 0x90);
+	GC2155MIPI_write_cmos_sensor(0xe7 , 0x70);
+	GC2155MIPI_write_cmos_sensor(0xe8 , 0x90);
+	GC2155MIPI_write_cmos_sensor(0xe9 , 0x70);
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+	///////////////////////////////////////////////
+	/////////// AWB////////////////////////
+	///////////////////////////////////////////////
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4f , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x4f , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x4b , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4f , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x71);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x91);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x50);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x70);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x90);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xb0);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xd0);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x4f);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x6f);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x8f);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xaf);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xcf);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x6e);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x8e);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xae);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xce);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x4d);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x6d);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x8d);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xad);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xcd);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x4c);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x6c);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x8c);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xac);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xcc);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xec);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x4b);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x6b);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x8b);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xab);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x8a);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x04);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xaa);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x04);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xca);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x04);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xa9);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x04);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xc9);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x04);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xcb);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x05);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xeb);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x05);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x0b);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x05);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x2b);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x05);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x4b);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x05);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xea);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x05);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x0a);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x05);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x2a);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x05);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x6a);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x06);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x29);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x06);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x49);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x06);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x69);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x06);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x89);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x06);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xa9);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x06);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xc9);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x06);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x48);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x06);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x68);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x06);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x09);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x07);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xa8);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x07);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xc8);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x07);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xe8);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x07);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x08);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x07);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x28);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x07);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x87);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x07);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xa7);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x07);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xc7);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x07);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xe7);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x07);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x07);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x07);
+	GC2155MIPI_write_cmos_sensor(0x4f , 0x01);
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x01);
+	
+	GC2155MIPI_write_cmos_sensor(0x50 , 0x80);
+	GC2155MIPI_write_cmos_sensor(0x51 , 0xa8);
+	GC2155MIPI_write_cmos_sensor(0x52 , 0x57);
+	GC2155MIPI_write_cmos_sensor(0x53 , 0x38);
+	GC2155MIPI_write_cmos_sensor(0x54 , 0xc7);
+	GC2155MIPI_write_cmos_sensor(0x56 , 0x0e);
+	GC2155MIPI_write_cmos_sensor(0x58 , 0x08);
+	GC2155MIPI_write_cmos_sensor(0x5b , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x5c , 0x74);
+	GC2155MIPI_write_cmos_sensor(0x5d , 0x8b);
+	GC2155MIPI_write_cmos_sensor(0x61 , 0xd3);
+	GC2155MIPI_write_cmos_sensor(0x62 , 0x90);
+	GC2155MIPI_write_cmos_sensor(0x63 , 0xaa);
+	GC2155MIPI_write_cmos_sensor(0x65 , 0x04);
+	GC2155MIPI_write_cmos_sensor(0x67 , 0xb2);
+	GC2155MIPI_write_cmos_sensor(0x68 , 0xac);
+	GC2155MIPI_write_cmos_sensor(0x69 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x6a , 0xb2);
+	GC2155MIPI_write_cmos_sensor(0x6b , 0xac);
+	GC2155MIPI_write_cmos_sensor(0x6c , 0xdc);
+	GC2155MIPI_write_cmos_sensor(0x6d , 0xb0);
+	GC2155MIPI_write_cmos_sensor(0x6e , 0x30);
+	GC2155MIPI_write_cmos_sensor(0x6f , 0x40);
+	GC2155MIPI_write_cmos_sensor(0x70 , 0x05);
+	GC2155MIPI_write_cmos_sensor(0x71 , 0x80);
+	GC2155MIPI_write_cmos_sensor(0x72 , 0x80);
+	GC2155MIPI_write_cmos_sensor(0x73 , 0x30);
+	GC2155MIPI_write_cmos_sensor(0x74 , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x75 , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x7f , 0x08);
+	GC2155MIPI_write_cmos_sensor(0x76 , 0x70);
+	GC2155MIPI_write_cmos_sensor(0x77 , 0x48);
+	GC2155MIPI_write_cmos_sensor(0x78 , 0xa0);
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+	//////////////////////////////////////////
+	///////////CC////////////////////////
+	//////////////////////////////////////////
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x02);
+	GC2155MIPI_write_cmos_sensor(0xc0 , 0x01);
+	GC2155MIPI_write_cmos_sensor(0xc1 , 0x4a);
+	GC2155MIPI_write_cmos_sensor(0xc2 , 0xf3);
+	GC2155MIPI_write_cmos_sensor(0xc3 , 0xfc);
+	GC2155MIPI_write_cmos_sensor(0xc4 , 0xe4);
+	GC2155MIPI_write_cmos_sensor(0xc5 , 0x48);
+	GC2155MIPI_write_cmos_sensor(0xc6 , 0xec);
+	GC2155MIPI_write_cmos_sensor(0xc7 , 0x45);
+	GC2155MIPI_write_cmos_sensor(0xc8 , 0xf8);
+	GC2155MIPI_write_cmos_sensor(0xc9 , 0x02);
+	GC2155MIPI_write_cmos_sensor(0xca , 0xfe);
+	GC2155MIPI_write_cmos_sensor(0xcb , 0x42);
+	GC2155MIPI_write_cmos_sensor(0xcc , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xcd , 0x45);
+	GC2155MIPI_write_cmos_sensor(0xce , 0xf0);
+	GC2155MIPI_write_cmos_sensor(0xcf , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xe3 , 0xf0);
+	GC2155MIPI_write_cmos_sensor(0xe4 , 0x45);
+	GC2155MIPI_write_cmos_sensor(0xe5 , 0xe8); 
+	//////////////////////////////////////////
+	///////////ABS ////////////////////
+	//////////////////////////////////////////
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x9f , 0x42);
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00); 
+	//////////////////////////////////////
+	///////////  OUTPUT   ////////////////
+	//////////////////////////////////////
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+	GC2155MIPI_write_cmos_sensor(0xf2, 0x00);
+
+	//////////////frame rate 50Hz/////////
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x05 , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x06 , 0x56);
+	GC2155MIPI_write_cmos_sensor(0x07 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x08 , 0x32);
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x25 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x26 , 0xfa); 
+	GC2155MIPI_write_cmos_sensor(0x27 , 0x04); 
+	GC2155MIPI_write_cmos_sensor(0x28 , 0xe2); //20fps 
+	GC2155MIPI_write_cmos_sensor(0x29 , 0x06); 
+	GC2155MIPI_write_cmos_sensor(0x2a , 0xd6); //14fps 
+	GC2155MIPI_write_cmos_sensor(0x2b , 0x07); 
+	GC2155MIPI_write_cmos_sensor(0x2c , 0xd0); //12fps
+	GC2155MIPI_write_cmos_sensor(0x2d , 0x0b); 
+	GC2155MIPI_write_cmos_sensor(0x2e , 0xb8); //8fps
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+
+		/////////////////////////////////////////////////////
+	//////////////////////   MIPI   /////////////////////
+	/////////////////////////////////////////////////////
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x03);
+	GC2155MIPI_write_cmos_sensor(0x02, 0x22);
+	GC2155MIPI_write_cmos_sensor(0x03, 0x10); // 0x12 20140821
+	GC2155MIPI_write_cmos_sensor(0x04, 0x10); // 0x01 
+	GC2155MIPI_write_cmos_sensor(0x05, 0x00);
+	GC2155MIPI_write_cmos_sensor(0x06, 0x88);
+	#if defined(GC2155MIPI_2Lane)
+		GC2155MIPI_write_cmos_sensor(0x01, 0x87);
+		GC2155MIPI_write_cmos_sensor(0x10, 0x95);
+	#else
+		GC2155MIPI_write_cmos_sensor(0x01, 0x83);
+		GC2155MIPI_write_cmos_sensor(0x10, 0x94);
+	#endif
+	GC2155MIPI_write_cmos_sensor(0x11, 0x1e);
+	GC2155MIPI_write_cmos_sensor(0x12, 0x80);
+	GC2155MIPI_write_cmos_sensor(0x13, 0x0c);
+	GC2155MIPI_write_cmos_sensor(0x15, 0x10);
+	GC2155MIPI_write_cmos_sensor(0x17, 0xf0);
+	
+	GC2155MIPI_write_cmos_sensor(0x21, 0x10);
+	GC2155MIPI_write_cmos_sensor(0x22, 0x04);
+	GC2155MIPI_write_cmos_sensor(0x23, 0x10);
+	GC2155MIPI_write_cmos_sensor(0x24, 0x10);
+	GC2155MIPI_write_cmos_sensor(0x25, 0x10);
+	GC2155MIPI_write_cmos_sensor(0x26, 0x05);
+	GC2155MIPI_write_cmos_sensor(0x29, 0x03);
+	GC2155MIPI_write_cmos_sensor(0x2a, 0x0a);
+	GC2155MIPI_write_cmos_sensor(0x2b, 0x06);
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+	
+}
+
+
+static void GC2155MIPI_Sensor_SVGA(void)
+{
+	SENSORDB("GC2155MIPI_Sensor_SVGA");
+	GC2155MIPI_write_cmos_sensor(0xf7, 0x1d);
+	GC2155MIPI_write_cmos_sensor(0xfd, 0x01);
+	GC2155MIPI_write_cmos_sensor(0xfa, 0x00);
+	//// crop window             
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+	GC2155MIPI_write_cmos_sensor(0x90, 0x01);
+	GC2155MIPI_write_cmos_sensor(0x91, 0x00);
+	GC2155MIPI_write_cmos_sensor(0x92, 0x00);
+	GC2155MIPI_write_cmos_sensor(0x93, 0x00);
+	GC2155MIPI_write_cmos_sensor(0x94, 0x00);
+	GC2155MIPI_write_cmos_sensor(0x95, 0x02);
+	GC2155MIPI_write_cmos_sensor(0x96, 0x58);
+	GC2155MIPI_write_cmos_sensor(0x97, 0x03);
+	GC2155MIPI_write_cmos_sensor(0x98, 0x20);
+	GC2155MIPI_write_cmos_sensor(0x99, 0x11);
+	GC2155MIPI_write_cmos_sensor(0x9a, 0x06);
+	//// AWB                     
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+	GC2155MIPI_write_cmos_sensor(0xec, 0x01);
+	GC2155MIPI_write_cmos_sensor(0xed, 0x02);
+	GC2155MIPI_write_cmos_sensor(0xee, 0x30);
+	GC2155MIPI_write_cmos_sensor(0xef, 0x48);
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x01);
+	GC2155MIPI_write_cmos_sensor(0x74, 0x00);
+	//// AEC                     
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x01);
+	GC2155MIPI_write_cmos_sensor(0x01, 0x04);
+	GC2155MIPI_write_cmos_sensor(0x02, 0x60);
+	GC2155MIPI_write_cmos_sensor(0x03, 0x02);
+	GC2155MIPI_write_cmos_sensor(0x04, 0x48);
+	GC2155MIPI_write_cmos_sensor(0x05, 0x18);
+	GC2155MIPI_write_cmos_sensor(0x06, 0x4c);
+	GC2155MIPI_write_cmos_sensor(0x07, 0x14);
+	GC2155MIPI_write_cmos_sensor(0x08, 0x36);
+	GC2155MIPI_write_cmos_sensor(0x0a, 0xc0);
+	GC2155MIPI_write_cmos_sensor(0x21, 0x14);
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+	//// gamma
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xc3 , 0x11);
+	GC2155MIPI_write_cmos_sensor(0xc4 , 0x20);
+	GC2155MIPI_write_cmos_sensor(0xc5 , 0x30);
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+	//// mipi
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x03);
+	GC2155MIPI_write_cmos_sensor(0x12, 0x40);
+	GC2155MIPI_write_cmos_sensor(0x13, 0x06);
+#if defined(GC2155MIPI_2Lane)
+	GC2155MIPI_write_cmos_sensor(0x04, 0x90);
+	GC2155MIPI_write_cmos_sensor(0x05, 0x01);
+#else
+	GC2155MIPI_write_cmos_sensor(0x04, 0x01);
+	GC2155MIPI_write_cmos_sensor(0x05, 0x00);
+#endif
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+}
+
+static void GC2155MIPI_Sensor_2M(void)
+{
+	SENSORDB("GC2155MIPI_Sensor_2M");
+	GC2155MIPI_write_cmos_sensor(0xf7, 0x1d);	
+	GC2155MIPI_write_cmos_sensor(0xfd, 0x00); 
+#ifdef GC2155MIPI_2Lane
+	GC2155MIPI_write_cmos_sensor(0xfa, 0x00); 
+#else
+	GC2155MIPI_write_cmos_sensor(0xfa, 0x11); 
+#endif
+	//// crop window           
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+	GC2155MIPI_write_cmos_sensor(0x90, 0x01); 
+	GC2155MIPI_write_cmos_sensor(0x91, 0x00);
+	GC2155MIPI_write_cmos_sensor(0x92, 0x00);
+	GC2155MIPI_write_cmos_sensor(0x93, 0x00);
+	GC2155MIPI_write_cmos_sensor(0x94, 0x00);
+	GC2155MIPI_write_cmos_sensor(0x95, 0x04);
+	GC2155MIPI_write_cmos_sensor(0x96, 0xb0);
+	GC2155MIPI_write_cmos_sensor(0x97, 0x06);
+	GC2155MIPI_write_cmos_sensor(0x98, 0x40);
+	GC2155MIPI_write_cmos_sensor(0x99, 0x11); 
+	GC2155MIPI_write_cmos_sensor(0x9a, 0x06);
+	//// AWB                   
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+	GC2155MIPI_write_cmos_sensor(0xec, 0x02); 
+	GC2155MIPI_write_cmos_sensor(0xed, 0x04);
+	GC2155MIPI_write_cmos_sensor(0xee, 0x60);
+	GC2155MIPI_write_cmos_sensor(0xef, 0x90);
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x01);
+	GC2155MIPI_write_cmos_sensor(0x74, 0x01); 
+	//// AEC                    
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x01);
+	GC2155MIPI_write_cmos_sensor(0x01, 0x08);
+	GC2155MIPI_write_cmos_sensor(0x02, 0xc0);
+	GC2155MIPI_write_cmos_sensor(0x03, 0x04);
+	GC2155MIPI_write_cmos_sensor(0x04, 0x90);
+	GC2155MIPI_write_cmos_sensor(0x05, 0x30);
+	GC2155MIPI_write_cmos_sensor(0x06, 0x98);
+	GC2155MIPI_write_cmos_sensor(0x07, 0x28);
+	GC2155MIPI_write_cmos_sensor(0x08, 0x6c);
+	GC2155MIPI_write_cmos_sensor(0x0a, 0xc2);
+#ifdef GC2155MIPI_2Lane
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x21 , 0x14);
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+	//// gamma
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xc3 , 0x11);
+	GC2155MIPI_write_cmos_sensor(0xc4 , 0x20);
+	GC2155MIPI_write_cmos_sensor(0xc5 , 0x30);
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+#else
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x21 , 0x15);
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+	//// gamma
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xc3 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xc4 , 0x90);
+	GC2155MIPI_write_cmos_sensor(0xc5 , 0x98);
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+#endif
+	//// mipi
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x03);
+	GC2155MIPI_write_cmos_sensor(0x12, 0x80);
+	GC2155MIPI_write_cmos_sensor(0x13, 0x0c);
+	GC2155MIPI_write_cmos_sensor(0x04, 0x01);
+	GC2155MIPI_write_cmos_sensor(0x05, 0x00);
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+
+}
+
+
+/*****************************************************************************/
+/* Windows Mobile Sensor Interface */
+/*****************************************************************************/
+/*************************************************************************
+* FUNCTION
+*	GC2155MIPIOpen
+*
+* DESCRIPTION
+*	This function initialize the registers of CMOS sensor
+*
+* PARAMETERS
+*	None
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+UINT32 GC2155MIPIOpen(void)
+{
+	volatile signed char i;
+	kal_uint16 sensor_id=0;
+
+	zoom_factor = 0; 
+	Sleep(10);
+
+
+	//  Read sensor ID to adjust I2C is OK?
+	for(i=0;i<3;i++)
+	{
+		sensor_id=((GC2155MIPI_read_cmos_sensor(0xf0) << 8) | GC2155MIPI_read_cmos_sensor(0xf1));   
+		SENSORDB("GC2155MIPI_Open, sensor_id:%x \n",sensor_id);
+		if (sensor_id != GC2155MIPI_SENSOR_ID)
+		return ERROR_SENSOR_CONNECT_FAIL;
+	}
+	
+		SENSORDB("GC2155MIPI Sensor Read ID OK \r\n");
+		GC2155MIPI_Sensor_Init();
+
+#ifdef DEBUG_SENSOR_GC2155MIPI  
+		struct file *fp; 
+		mm_segment_t fs; 
+		loff_t pos = 0; 
+		static char buf[60*1024] ;
+
+		printk("open 2155 debug \n");
+		printk("open 2155 debug \n");
+		printk("open 2155 debug \n");	
+
+
+		fp = filp_open("/mnt/sdcard/gc2155mipi_sd.txt", O_RDONLY , 0); 
+
+		if (IS_ERR(fp)) 
+		{ 
+
+			fromsd = 0;   
+			printk("open 2155 file error\n");
+			printk("open 2155 file error\n");
+			printk("open 2155 file error\n");		
+
+
+		} 
+		else 
+		{
+			fromsd = 1;
+			printk("open 2155 file ok\n");
+			printk("open 2155 file ok\n");
+			printk("open 2155 file ok\n");
+
+			//gc2155mipi_Initialize_from_T_Flash();
+			
+			filp_close(fp, NULL); 
+			set_fs(fs);
+		}
+
+		if(fromsd == 1)
+		{
+			printk("________________2155 from t!\n");
+			printk("________________2155 from t!\n");
+			printk("________________2155 from t!\n");		
+			GC2155MIPI_Initialize_from_T_Flash();
+			printk("______after_____2155 from t!\n");	
+		}
+		else
+		{
+			//GC2155MIPI_MPEG4_encode_mode = KAL_FALSE;
+			printk("________________2155 not from t!\n");	
+			printk("________________2155 not from t!\n");
+			printk("________________2155 not from t!\n");		
+			RETAILMSG(1, (TEXT("Sensor Read ID OK \r\n"))); 
+		}
+
+#endif
+	
+	Preview_Shutter =GC2155MIPI_read_shutter();
+	
+	return ERROR_NONE;
+}	/* GC2155MIPIOpen() */
+
+/*************************************************************************
+* FUNCTION
+*	GC2155MIPIClose
+*
+* DESCRIPTION
+*	This function is to turn off sensor module power.
+*
+* PARAMETERS
+*	None
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+UINT32 GC2155MIPIClose(void)
+{
+//	CISModulePowerOn(FALSE);
+	return ERROR_NONE;
+}	/* GC2155MIPIClose() */
+
+/*************************************************************************
+* FUNCTION
+*	GC2155MIPIPreview
+*
+* DESCRIPTION
+*	This function start the sensor preview.
+*
+* PARAMETERS
+*	*image_window : address pointer of pixel numbers in one period of HSYNC
+*  *sensor_config_data : address pointer of line numbers in one period of VSYNC
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+UINT32 GC2155MIPIPreview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	kal_uint8 iTemp, temp_AE_reg, temp_AWB_reg;
+	kal_uint16 iDummyPixels = 0, iDummyLines = 0, iStartX = 0, iStartY = 0;
+
+	SENSORDB("GC2155MIPIPrevie\n");
+
+	GC2155MIPI_sensor_cap_state = KAL_FALSE;
+
+
+	GC2155MIPI_Sensor_SVGA();
+	GC2155MIPI_write_shutter(Preview_Shutter);
+	GC2155MIPI_set_AE_mode(KAL_TRUE); 
+
+	memcpy(&GC2155MIPISensorConfigData, sensor_config_data, sizeof(MSDK_SENSOR_CONFIG_STRUCT));
+	return ERROR_NONE;
+}	/* GC2155MIPIPreview() */
+
+
+
+
+UINT32 GC2155MIPICapture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    volatile kal_uint32 shutter = GC2155MIPI_exposure_lines, temp_reg;
+    kal_uint8 temp_AE_reg, temp;
+    kal_uint16 AE_setting_delay = 0;
+
+    SENSORDB("GC2155MIPICapture\n");
+
+  if(GC2155MIPI_sensor_cap_state == KAL_FALSE)
+ 	{
+
+#if defined(GC2155MIPI_2Lane)
+
+	GC2155MIPI_Sensor_2M();
+
+#else
+	// turn off AEC/AGC
+	GC2155MIPI_set_AE_mode(KAL_FALSE);
+	
+	shutter = GC2155MIPI_read_shutter();
+	Preview_Shutter = shutter;
+	
+	GC2155MIPI_Sensor_2M();
+	
+	Capture_Shutter = shutter / 2; 
+	// set shutter
+	GC2155MIPI_write_shutter(Capture_Shutter);
+#endif
+
+	Sleep(200);
+
+      }
+
+     GC2155MIPI_sensor_cap_state = KAL_TRUE;
+
+	image_window->GrabStartX=1;
+        image_window->GrabStartY=1;
+        image_window->ExposureWindowWidth=GC2155MIPI_IMAGE_SENSOR_FULL_WIDTH - image_window->GrabStartX;
+        image_window->ExposureWindowHeight=GC2155MIPI_IMAGE_SENSOR_FULL_HEIGHT -image_window->GrabStartY;    	 
+
+    memcpy(&GC2155MIPISensorConfigData, sensor_config_data, sizeof(MSDK_SENSOR_CONFIG_STRUCT));
+	return ERROR_NONE;
+}	/* GC2155MIPICapture() */
+
+
+
+UINT32 GC2155MIPIGetResolution(MSDK_SENSOR_RESOLUTION_INFO_STRUCT *pSensorResolution)
+{
+	pSensorResolution->SensorFullWidth=GC2155MIPI_IMAGE_SENSOR_FULL_WIDTH - 2 * IMAGE_SENSOR_START_GRAB_X;
+	pSensorResolution->SensorFullHeight=GC2155MIPI_IMAGE_SENSOR_FULL_HEIGHT - 2 * IMAGE_SENSOR_START_GRAB_Y;
+	pSensorResolution->SensorPreviewWidth=GC2155MIPI_IMAGE_SENSOR_PV_WIDTH - 2 * IMAGE_SENSOR_START_GRAB_X;
+	pSensorResolution->SensorPreviewHeight=GC2155MIPI_IMAGE_SENSOR_PV_HEIGHT - 2 * IMAGE_SENSOR_START_GRAB_Y;
+	pSensorResolution->SensorVideoWidth=GC2155MIPI_IMAGE_SENSOR_PV_WIDTH - 2 * IMAGE_SENSOR_START_GRAB_X;
+	pSensorResolution->SensorVideoHeight=GC2155MIPI_IMAGE_SENSOR_PV_HEIGHT - 2 * IMAGE_SENSOR_START_GRAB_Y;
+	return ERROR_NONE;
+}	/* GC2155MIPIGetResolution() */
+
+UINT32 GC2155MIPIGetInfo(MSDK_SCENARIO_ID_ENUM ScenarioId,
+					  MSDK_SENSOR_INFO_STRUCT *pSensorInfo,
+					  MSDK_SENSOR_CONFIG_STRUCT *pSensorConfigData)
+{
+
+	pSensorInfo->SensorPreviewResolutionX=GC2155MIPI_IMAGE_SENSOR_PV_WIDTH;
+	pSensorInfo->SensorPreviewResolutionY=GC2155MIPI_IMAGE_SENSOR_PV_HEIGHT;
+	pSensorInfo->SensorFullResolutionX=GC2155MIPI_IMAGE_SENSOR_FULL_WIDTH;
+	pSensorInfo->SensorFullResolutionY=GC2155MIPI_IMAGE_SENSOR_FULL_HEIGHT;
+
+	pSensorInfo->SensorCameraPreviewFrameRate=30;
+	pSensorInfo->SensorVideoFrameRate=30;
+	pSensorInfo->SensorStillCaptureFrameRate=10;
+	pSensorInfo->SensorWebCamCaptureFrameRate=15;
+	pSensorInfo->SensorResetActiveHigh=FALSE;
+	pSensorInfo->SensorResetDelayCount=1;
+	pSensorInfo->SensorOutputDataFormat=SENSOR_OUTPUT_FORMAT_YUYV;
+	pSensorInfo->SensorClockPolarity=SENSOR_CLOCK_POLARITY_LOW;	/*??? */
+	pSensorInfo->SensorClockFallingPolarity=SENSOR_CLOCK_POLARITY_LOW;
+	pSensorInfo->SensorHsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
+	pSensorInfo->SensorVsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
+	pSensorInfo->SensorInterruptDelayLines = 1;
+	pSensorInfo->CaptureDelayFrame = 4; 
+	pSensorInfo->PreviewDelayFrame = 1; 
+	pSensorInfo->VideoDelayFrame = 0; 
+       pSensorInfo->YUVAwbDelayFrame = 2;  // add by lanking
+	pSensorInfo->YUVEffectDelayFrame = 2;  // add by lanking
+	pSensorInfo->SensorMasterClockSwitch = 0; 
+	pSensorInfo->SensorDrivingCurrent = ISP_DRIVING_6MA;
+
+
+	pSensorInfo->SensroInterfaceType = SENSOR_INTERFACE_TYPE_MIPI;
+
+	switch (ScenarioId)
+	{
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+		case MSDK_SCENARIO_ID_CAMERA_ZSD:
+		default:
+
+			pSensorInfo->SensorClockFreq=24;
+			pSensorInfo->SensorClockDividCount=3;
+			pSensorInfo->SensorClockRisingCount= 0;
+			pSensorInfo->SensorClockFallingCount= 2;
+			pSensorInfo->SensorPixelClockCount= 3;
+			pSensorInfo->SensorDataLatchCount= 2;
+                     pSensorInfo->SensorGrabStartX = 2; 
+                     pSensorInfo->SensorGrabStartY = 2;
+		#ifdef GC2155MIPI_2Lane
+			pSensorInfo->SensorMIPILaneNumber = SENSOR_MIPI_2_LANE;		
+		#else
+			pSensorInfo->SensorMIPILaneNumber = SENSOR_MIPI_1_LANE;
+		#endif
+			pSensorInfo->MIPIDataLowPwr2HighSpeedTermDelayCount = 0; 
+			pSensorInfo->MIPIDataLowPwr2HighSpeedSettleDelayCount = 14;
+			pSensorInfo->MIPICLKLowPwr2HighSpeedTermDelayCount = 0;
+			pSensorInfo->SensorWidthSampling = 0;  // 0 is default 1x
+			pSensorInfo->SensorHightSampling = 0;   // 0 is default 1x 
+			pSensorInfo->SensorPacketECCOrder = 1;
+
+	
+		break;
+	
+	}
+	memcpy(pSensorConfigData, &GC2155MIPISensorConfigData, sizeof(MSDK_SENSOR_CONFIG_STRUCT));
+	return ERROR_NONE;
+}	/* GC2155MIPIGetInfo() */
+
+
+UINT32 GC2155MIPIControl(MSDK_SCENARIO_ID_ENUM ScenarioId, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *pImageWindow,
+					  MSDK_SENSOR_CONFIG_STRUCT *pSensorConfigData)
+{
+	switch (ScenarioId)
+	{
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+			GC2155MIPIPreview(pImageWindow, pSensorConfigData);
+		break;
+		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+		case MSDK_SCENARIO_ID_CAMERA_ZSD:
+			GC2155MIPICapture(pImageWindow, pSensorConfigData);
+		break;
+		default:
+		    break; 
+	}
+	return TRUE;
+}	/* GC2155MIPIControl() */
+
+BOOL GC2155MIPI_set_param_wb(UINT16 para)
+{
+	switch (para)
+	{
+		case AWB_MODE_AUTO:
+			GC2155MIPI_set_AWB_mode(KAL_TRUE);
+		break;
+		case AWB_MODE_CLOUDY_DAYLIGHT: //cloudy
+			GC2155MIPI_set_AWB_mode(KAL_FALSE);
+			GC2155MIPI_write_cmos_sensor(0xb3, 0x58);
+			GC2155MIPI_write_cmos_sensor(0xb4, 0x40);
+			GC2155MIPI_write_cmos_sensor(0xb5, 0x50);
+		break;
+		case AWB_MODE_DAYLIGHT: //sunny
+			GC2155MIPI_set_AWB_mode(KAL_FALSE);
+			GC2155MIPI_write_cmos_sensor(0xb3, 0x70);
+			GC2155MIPI_write_cmos_sensor(0xb4, 0x40);
+			GC2155MIPI_write_cmos_sensor(0xb5, 0x50);
+		break;
+		case AWB_MODE_INCANDESCENT: //office
+			GC2155MIPI_set_AWB_mode(KAL_FALSE);
+			GC2155MIPI_write_cmos_sensor(0xb3, 0x50);
+			GC2155MIPI_write_cmos_sensor(0xb4, 0x40);
+			GC2155MIPI_write_cmos_sensor(0xb5, 0xa8);
+		break;
+		case AWB_MODE_TUNGSTEN: //home
+			GC2155MIPI_set_AWB_mode(KAL_FALSE);
+			GC2155MIPI_write_cmos_sensor(0xb3, 0xa0);
+			GC2155MIPI_write_cmos_sensor(0xb4, 0x45);
+			GC2155MIPI_write_cmos_sensor(0xb5, 0x40);
+		break;
+		case AWB_MODE_FLUORESCENT:
+			GC2155MIPI_set_AWB_mode(KAL_FALSE);
+			GC2155MIPI_write_cmos_sensor(0xb3, 0x72);
+			GC2155MIPI_write_cmos_sensor(0xb4, 0x40);
+			GC2155MIPI_write_cmos_sensor(0xb5, 0x5b);
+		break;	
+		default:
+		return FALSE;
+	}
+	return TRUE;
+} /* GC2155MIPI_set_param_wb */
+
+BOOL GC2155MIPI_set_param_effect(UINT16 para)
+{
+	kal_uint32 ret = KAL_TRUE;
+	switch (para)
+	{
+		case MEFFECT_OFF:
+			GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+			GC2155MIPI_write_cmos_sensor(0x83, 0xe0);
+		break;
+
+		case MEFFECT_SEPIA:
+			GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+			GC2155MIPI_write_cmos_sensor(0x83, 0x82);
+		break;  
+
+		case MEFFECT_NEGATIVE:		
+			GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+			GC2155MIPI_write_cmos_sensor(0x83, 0x01);
+		break; 
+
+		case MEFFECT_SEPIAGREEN:		
+			GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+			GC2155MIPI_write_cmos_sensor(0x83, 0x52);
+		break;
+
+		case MEFFECT_SEPIABLUE:	
+			GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+			GC2155MIPI_write_cmos_sensor(0x83, 0x62);
+		break;
+
+		case MEFFECT_MONO:				
+			GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+			GC2155MIPI_write_cmos_sensor(0x83, 0x12);
+		break;
+
+		default:
+		return FALSE;
+	}
+
+	return ret;
+} /* GC2155MIPI_set_param_effect */
+
+BOOL GC2155MIPI_set_param_banding(UINT16 para)
+{
+    switch (para)
+    {
+        case AE_FLICKER_MODE_50HZ:
+			
+		GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+		GC2155MIPI_write_cmos_sensor(0x05 , 0x01);
+		GC2155MIPI_write_cmos_sensor(0x06 , 0x56);
+		GC2155MIPI_write_cmos_sensor(0x07 , 0x00);
+		GC2155MIPI_write_cmos_sensor(0x08 , 0x32);
+		GC2155MIPI_write_cmos_sensor(0xfe , 0x01);
+		GC2155MIPI_write_cmos_sensor(0x25 , 0x00);
+		GC2155MIPI_write_cmos_sensor(0x26 , 0xfa); 
+		GC2155MIPI_write_cmos_sensor(0x27 , 0x04); 
+		GC2155MIPI_write_cmos_sensor(0x28 , 0xe2); //20fps 
+		GC2155MIPI_write_cmos_sensor(0x29 , 0x06); 
+		GC2155MIPI_write_cmos_sensor(0x2a , 0xd6); //14fps 
+		GC2155MIPI_write_cmos_sensor(0x2b , 0x07); 
+		GC2155MIPI_write_cmos_sensor(0x2c , 0xd0); //12fps 
+		GC2155MIPI_write_cmos_sensor(0x2d , 0x0b); 
+		GC2155MIPI_write_cmos_sensor(0x2e , 0xb8); //8fps
+		GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+            break;
+
+        case AE_FLICKER_MODE_60HZ:
+		GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+		GC2155MIPI_write_cmos_sensor(0x05 , 0x01);
+		GC2155MIPI_write_cmos_sensor(0x06 , 0x58);
+		GC2155MIPI_write_cmos_sensor(0x07 , 0x00);
+		GC2155MIPI_write_cmos_sensor(0x08 , 0x32);
+		GC2155MIPI_write_cmos_sensor(0xfe , 0x01);
+		GC2155MIPI_write_cmos_sensor(0x25 , 0x00);
+		GC2155MIPI_write_cmos_sensor(0x26 , 0xd0); 
+		GC2155MIPI_write_cmos_sensor(0x27 , 0x04); 
+		GC2155MIPI_write_cmos_sensor(0x28 , 0xe0); //20fps 
+		GC2155MIPI_write_cmos_sensor(0x29 , 0x06); 
+		GC2155MIPI_write_cmos_sensor(0x2a , 0x80); //14fps 
+		GC2155MIPI_write_cmos_sensor(0x2b , 0x08); 
+		GC2155MIPI_write_cmos_sensor(0x2c , 0x20); //12fps 
+		GC2155MIPI_write_cmos_sensor(0x2d , 0x0b); 
+		GC2155MIPI_write_cmos_sensor(0x2e , 0x60); //8fps
+		GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+            break;
+
+          default:
+              return FALSE;
+    }
+
+    return TRUE;
+} /* GC2155MIPI_set_param_banding */
+
+BOOL GC2155MIPI_set_param_exposure(UINT16 para)
+{
+	switch (para)
+	{
+		case AE_EV_COMP_n13:
+			GC2155MIPI_SET_PAGE1;
+			GC2155MIPI_write_cmos_sensor(0x13,0x10);
+			GC2155MIPI_SET_PAGE0;
+		break;
+		case AE_EV_COMP_n10:
+			GC2155MIPI_SET_PAGE1;
+			GC2155MIPI_write_cmos_sensor(0x13,0x15);
+			GC2155MIPI_SET_PAGE0;
+		break;
+		case AE_EV_COMP_n07:
+			GC2155MIPI_SET_PAGE1;
+			GC2155MIPI_write_cmos_sensor(0x13,0x20);
+			GC2155MIPI_SET_PAGE0;
+		break;
+		case AE_EV_COMP_n03:
+			GC2155MIPI_SET_PAGE1;
+			GC2155MIPI_write_cmos_sensor(0x13,0x25);
+			GC2155MIPI_SET_PAGE0;
+		break;
+		case AE_EV_COMP_00:
+			GC2155MIPI_SET_PAGE1;
+			GC2155MIPI_write_cmos_sensor(0x13,0x2d);
+			GC2155MIPI_SET_PAGE0;
+		break;
+		case AE_EV_COMP_03:
+			GC2155MIPI_SET_PAGE1;
+			GC2155MIPI_write_cmos_sensor(0x13,0x35);
+			GC2155MIPI_SET_PAGE0;
+		break;
+		case AE_EV_COMP_07:
+			GC2155MIPI_SET_PAGE1;
+			GC2155MIPI_write_cmos_sensor(0x13,0x40);
+			GC2155MIPI_SET_PAGE0;
+		break;
+		case AE_EV_COMP_10:
+			GC2155MIPI_SET_PAGE1;
+			GC2155MIPI_write_cmos_sensor(0x13,0x45);
+			GC2155MIPI_SET_PAGE0;
+		break;
+		case AE_EV_COMP_13:
+			GC2155MIPI_SET_PAGE1;
+			GC2155MIPI_write_cmos_sensor(0x13,0x50);
+			GC2155MIPI_SET_PAGE0;
+		break;
+		default:
+		return FALSE;
+	}
+	return TRUE;
+} /* GC2155MIPI_set_param_exposure */
+
+UINT32 GC2155MIPIYUVSensorSetting(FEATURE_ID iCmd, UINT32 iPara)
+{
+//   if( GC2155MIPI_sensor_cap_state == KAL_TRUE)
+//	   return TRUE;
+
+
+#ifdef DEBUG_SENSOR_GC2155MIPI
+		printk("______%s______GC2155MIPI YUV setting\n",__func__);
+		return TRUE;
+#endif
+
+	switch (iCmd) {
+	case FID_SCENE_MODE:	    
+//	    printk("Set Scene Mode:%d\n", iPara); 
+	    if (iPara == SCENE_MODE_OFF)
+	    {
+	        GC2155MIPI_night_mode(0); 
+	    }
+	    else if (iPara == SCENE_MODE_NIGHTSCENE)
+	    {
+               GC2155MIPI_night_mode(1); 
+	    }	    
+	    break; 	    
+	case FID_AWB_MODE:
+	    printk("Set AWB Mode:%d\n", iPara); 	    
+           GC2155MIPI_set_param_wb(iPara);
+	break;
+	case FID_COLOR_EFFECT:
+	    printk("Set Color Effect:%d\n", iPara); 	    	    
+           GC2155MIPI_set_param_effect(iPara);
+	break;
+	case FID_AE_EV:
+           printk("Set EV:%d\n", iPara); 	    	    
+           GC2155MIPI_set_param_exposure(iPara);
+	break;
+	case FID_AE_FLICKER:
+          printk("Set Flicker:%d\n", iPara); 	    	    	    
+           GC2155MIPI_set_param_banding(iPara);
+	break;
+        case FID_AE_SCENE_MODE: 
+            if (iPara == AE_MODE_OFF) {
+                GC2155MIPI_set_AE_mode(KAL_FALSE);
+            }
+            else {
+                GC2155MIPI_set_AE_mode(KAL_TRUE);
+	    }
+            break; 
+	case FID_ZOOM_FACTOR:
+	    zoom_factor = iPara; 
+        break; 
+	default:
+	break;
+	}
+	return TRUE;
+}   /* GC2155MIPIYUVSensorSetting */
+
+UINT32 GC2155MIPIYUVSetVideoMode(UINT16 u2FrameRate)
+{
+    kal_uint8 iTemp;
+    /* to fix VSYNC, to fix frame rate */
+    //printk("Set YUV Video Mode \n");  
+
+    if (u2FrameRate == 30)
+    {
+    }
+    else if (u2FrameRate == 15)       
+    {
+    }
+    else 
+    {
+        printk("Wrong frame rate setting \n");
+    }
+    GC2155MIPI_VEDIO_encode_mode = KAL_TRUE; 
+        
+    return TRUE;
+}
+
+/*************************************************************************
+  * FUNCTION
+  * GC2155MIPISetMaxFramerateByScenario
+  *
+  * DESCRIPTION
+  * This function is for android4.4 kk
+  * RETURNS
+  * None
+  *
+  * add by lanking
+  *
+  *************************************************************************/
+
+  UINT32 GC2155MIPISetMaxFramerateByScenario(MSDK_SCENARIO_ID_ENUM scenarioId, MUINT32 frameRate) {
+	kal_uint32 pclk;
+	kal_int16 dummyLine;
+	kal_uint16 lineLength,frameHeight;
+		
+	SENSORDB("GC2145SetMaxFramerateByScenario: scenarioId = %d, frame rate = %d\n",scenarioId,frameRate);
+	/*
+	switch (scenarioId) {
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+			pclk = 134200000;
+			lineLength = IMX111MIPI_PV_LINE_LENGTH_PIXELS;
+			frameHeight = (10 * pclk)/frameRate/lineLength;
+			dummyLine = frameHeight - IMX111MIPI_PV_FRAME_LENGTH_LINES;
+			break;
+        case MSDK_SCENARIO_ID_CAMERA_3D_CAPTURE: //added   
+			break;		
+		default:
+			break;
+	}	
+	*/
+	return ERROR_NONE;
+}
+
+/*************************************************************************
+  * FUNCTION
+  * GC2155MIPIGetDefaultFramerateByScenario
+  *
+  * DESCRIPTION
+  * This function is for android4.4 kk
+  * RETURNS
+  * None
+  *
+  * GLOBALS AFFECTED
+  *
+  *************************************************************************/
+UINT32 GC2155MIPIGetDefaultFramerateByScenario(MSDK_SCENARIO_ID_ENUM scenarioId, MUINT32 *pframeRate) 
+{
+
+	switch (scenarioId)
+	 {
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+			 *pframeRate = 300;
+			 break;
+		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+		case MSDK_SCENARIO_ID_CAMERA_ZSD:
+			 *pframeRate = 220;
+			break;		//hhl 2-28
+        case MSDK_SCENARIO_ID_CAMERA_3D_PREVIEW: //added
+        case MSDK_SCENARIO_ID_CAMERA_3D_VIDEO:
+        case MSDK_SCENARIO_ID_CAMERA_3D_CAPTURE: //added   
+			 *pframeRate = 300;
+			break;		
+		default:
+			break;
+	}
+
+ }
+ 
+ /*************************************************************************
+  * FUNCTION
+  * GC2155MIPIFeatureControl
+  *
+  * DESCRIPTION
+  * 
+  * RETURNS
+  * None
+  *
+  * GLOBALS AFFECTED
+  *
+  *************************************************************************/
+
+UINT32 GC2155MIPIFeatureControl(MSDK_SENSOR_FEATURE_ENUM FeatureId,
+							 UINT8 *pFeaturePara,UINT32 *pFeatureParaLen)
+{
+	UINT16 *pFeatureReturnPara16=(UINT16 *) pFeaturePara;
+	UINT16 *pFeatureData16=(UINT16 *) pFeaturePara;
+	UINT32 *pFeatureReturnPara32=(UINT32 *) pFeaturePara;
+	UINT32 *pFeatureData32=(UINT32 *) pFeaturePara;
+	MSDK_SENSOR_CONFIG_STRUCT *pSensorConfigData=(MSDK_SENSOR_CONFIG_STRUCT *) pFeaturePara;
+	MSDK_SENSOR_REG_INFO_STRUCT *pSensorRegData=(MSDK_SENSOR_REG_INFO_STRUCT *) pFeaturePara;
+
+	switch (FeatureId)
+	{
+		case SENSOR_FEATURE_GET_RESOLUTION:
+			*pFeatureReturnPara16++=GC2155MIPI_IMAGE_SENSOR_FULL_WIDTH;
+			*pFeatureReturnPara16=GC2155MIPI_IMAGE_SENSOR_FULL_HEIGHT;
+			*pFeatureParaLen=4;
+		break;
+		case SENSOR_FEATURE_GET_PERIOD:
+			*pFeatureReturnPara16++=GC2155MIPI_IMAGE_SENSOR_PV_WIDTH;
+			*pFeatureReturnPara16=GC2155MIPI_IMAGE_SENSOR_PV_HEIGHT;
+			*pFeatureParaLen=4;
+		break;
+		case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:
+			//*pFeatureReturnPara32 = GC2155MIPI_sensor_pclk/10;
+			*pFeatureParaLen=4;
+		break;
+		case SENSOR_FEATURE_SET_ESHUTTER:
+		break;
+		case SENSOR_FEATURE_SET_NIGHTMODE:
+			GC2155MIPI_night_mode((BOOL) *pFeatureData16);
+		break;
+		case SENSOR_FEATURE_SET_GAIN:
+		case SENSOR_FEATURE_SET_FLASHLIGHT:
+		break;
+		case SENSOR_FEATURE_SET_ISP_MASTER_CLOCK_FREQ:
+			GC2155MIPI_isp_master_clock=*pFeatureData32;
+		break;
+		case SENSOR_FEATURE_SET_REGISTER:
+			GC2155MIPI_write_cmos_sensor(pSensorRegData->RegAddr, pSensorRegData->RegData);
+		break;
+		case SENSOR_FEATURE_GET_REGISTER:
+			pSensorRegData->RegData = GC2155MIPI_read_cmos_sensor(pSensorRegData->RegAddr);
+		break;
+		case SENSOR_FEATURE_GET_CONFIG_PARA:
+			memcpy(pSensorConfigData, &GC2155MIPISensorConfigData, sizeof(MSDK_SENSOR_CONFIG_STRUCT));
+			*pFeatureParaLen=sizeof(MSDK_SENSOR_CONFIG_STRUCT);
+		break;
+		case SENSOR_FEATURE_SET_CCT_REGISTER:
+		case SENSOR_FEATURE_GET_CCT_REGISTER:
+		case SENSOR_FEATURE_SET_ENG_REGISTER:
+		case SENSOR_FEATURE_GET_ENG_REGISTER:
+		case SENSOR_FEATURE_GET_REGISTER_DEFAULT:
+
+		case SENSOR_FEATURE_CAMERA_PARA_TO_SENSOR:
+		case SENSOR_FEATURE_SENSOR_TO_CAMERA_PARA:
+		case SENSOR_FEATURE_GET_GROUP_INFO:
+		case SENSOR_FEATURE_GET_ITEM_INFO:
+		case SENSOR_FEATURE_SET_ITEM_INFO:
+		case SENSOR_FEATURE_GET_ENG_INFO:
+		break;
+		case SENSOR_FEATURE_GET_GROUP_COUNT:
+                        *pFeatureReturnPara32++=0;
+                        *pFeatureParaLen=4;	    
+		    break; 
+		case SENSOR_FEATURE_GET_LENS_DRIVER_ID:
+			// get the lens driver ID from EEPROM or just return LENS_DRIVER_ID_DO_NOT_CARE
+			// if EEPROM does not exist in camera module.
+			*pFeatureReturnPara32=LENS_DRIVER_ID_DO_NOT_CARE;
+			*pFeatureParaLen=4;
+		break;
+		case SENSOR_FEATURE_CHECK_SENSOR_ID:
+			 GC2155MIPI_GetSensorID(pFeatureData32);
+			 break;
+		case SENSOR_FEATURE_SET_YUV_CMD:
+		       //printk("GC2155MIPI YUV sensor Setting:%d, %d \n", *pFeatureData32,  *(pFeatureData32+1));
+			GC2155MIPIYUVSensorSetting((FEATURE_ID)*pFeatureData32, *(pFeatureData32+1));
+		break;
+		case SENSOR_FEATURE_SET_VIDEO_MODE:
+		       GC2155MIPIYUVSetVideoMode(*pFeatureData16);
+		       break; 
+		default:
+			break;			
+	}
+	return ERROR_NONE;
+}	/* GC2155MIPIFeatureControl() */
+
+
+SENSOR_FUNCTION_STRUCT	SensorFuncGC2155MIPI=
+{
+	GC2155MIPIOpen,
+	GC2155MIPIGetInfo,
+	GC2155MIPIGetResolution,
+	GC2155MIPIFeatureControl,
+	GC2155MIPIControl,
+	GC2155MIPIClose
+};
+
+UINT32 GC2155MIPI_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
+{
+	/* To Do : Check Sensor status here */
+	if (pfFunc!=NULL)
+		*pfFunc=&SensorFuncGC2155MIPI;
+
+	return ERROR_NONE;
+}	/* SensorInit() */
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/gc2155mipi_yuv/gc2155mipi_yuv_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735/gc2155mipi_yuv/gc2155mipi_yuv_Sensor.h
new file mode 100755
index 0000000..1f30cb6
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735/gc2155mipi_yuv/gc2155mipi_yuv_Sensor.h
@@ -0,0 +1,170 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*****************************************************************************
+*  Copyright Statement:
+*  --------------------
+*  This software is protected by Copyright and the information contained
+*  herein is confidential. The software may not be copied and the information
+*  contained herein may not be used or disclosed except with the written
+*  permission of MediaTek Inc. (C) 2008
+*
+*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
+*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
+*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
+*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
+*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
+*
+*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
+*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
+*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+*
+*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
+*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
+*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
+*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
+*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
+*
+*****************************************************************************/
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *   sensor.h
+ *
+ * Project:
+ * --------
+ *   DUMA
+ *
+ * Description:
+ * ------------
+ *   Header file of Sensor driver
+ *
+ *
+ * Author:
+ * -------
+ *   Leo Lee
+ *
+ *============================================================================
+ *             HISTORY
+ * Below this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *------------------------------------------------------------------------------
+ * $Revision:$
+ * $Modtime:$
+ * $Log:$
+ *
+ * [GC2155MIPIYUV V1.0.0]
+ * 8.17.2012 Leo.Lee
+ * .First Release
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by GalaxyCoreinc. DO NOT MODIFY!!
+ *============================================================================
+ ****************************************************************************/
+/* SENSOR FULL SIZE */
+#ifndef __SENSOR_H
+#define __SENSOR_H
+
+typedef enum _GC2155MIPI_OP_TYPE_ {
+        GC2155MIPI_MODE_NONE,
+        GC2155MIPI_MODE_PREVIEW,
+        GC2155MIPI_MODE_CAPTURE,
+        GC2155MIPI_MODE_QCIF_VIDEO,
+        GC2155MIPI_MODE_CIF_VIDEO,
+        GC2155MIPI_MODE_QVGA_VIDEO
+    } GC2155MIPI_OP_TYPE;
+
+extern GC2155MIPI_OP_TYPE GC2155MIPI_g_iGC2155MIPI_Mode;
+
+/* START GRAB PIXEL OFFSET */
+#define IMAGE_SENSOR_START_GRAB_X		        2	// 0 or 1 recommended
+#define IMAGE_SENSOR_START_GRAB_Y		        2	// 0 or 1 recommended
+
+/* SENSOR PIXEL/LINE NUMBERS IN ONE PERIOD */
+#define GC2155MIPI_FULL_PERIOD_PIXEL_NUMS  (1940)  // default pixel#(w/o dummy pixels) in UXGA mode
+#define GC2155MIPI_FULL_PERIOD_LINE_NUMS   (1238)  // default line#(w/o dummy lines) in UXGA mode
+#define GC2155MIPI_PV_PERIOD_PIXEL_NUMS    (970)  // default pixel#(w/o dummy pixels) in SVGA mode
+#define GC2155MIPI_PV_PERIOD_LINE_NUMS     (670)   // default line#(w/o dummy lines) in SVGA mode
+
+/* SENSOR EXPOSURE LINE LIMITATION */
+#define GC2155MIPI_FULL_EXPOSURE_LIMITATION    (1236)
+#define GC2155MIPI_PV_EXPOSURE_LIMITATION      (671)
+
+/* SENSOR FULL SIZE */
+#define GC2155MIPI_IMAGE_SENSOR_FULL_WIDTH	   (1600)
+#define GC2155MIPI_IMAGE_SENSOR_FULL_HEIGHT	  (1200)
+
+/* SENSOR PV SIZE */
+#define GC2155MIPI_IMAGE_SENSOR_PV_WIDTH   (800)
+#define GC2155MIPI_IMAGE_SENSOR_PV_HEIGHT  (600)
+
+#define GC2155MIPI_VIDEO_QCIF_WIDTH   (176)
+#define GC2155MIPI_VIDEO_QCIF_HEIGHT  (144)
+
+/* SENSOR READ/WRITE ID */
+#define GC2155MIPI_WRITE_ID	        0x78
+#define GC2155MIPI_READ_ID		0x79
+
+
+/* SENSOR CHIP VERSION */
+//#define GC2155MIPI_SENSOR_ID							0x2155
+
+//s_add for porting
+//s_add for porting
+//s_add for porting
+
+//export functions
+UINT32 GC2155MIPIOpen(void);
+UINT32 GC2155MIPIGetResolution(MSDK_SENSOR_RESOLUTION_INFO_STRUCT *pSensorResolution);
+UINT32 GC2155MIPIGetInfo(MSDK_SCENARIO_ID_ENUM ScenarioId, MSDK_SENSOR_INFO_STRUCT *pSensorInfo, MSDK_SENSOR_CONFIG_STRUCT *pSensorConfigData);
+UINT32 GC2155MIPIControl(MSDK_SCENARIO_ID_ENUM ScenarioId, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *pImageWindow, MSDK_SENSOR_CONFIG_STRUCT *pSensorConfigData);
+UINT32 GC2155MIPIFeatureControl(MSDK_SENSOR_FEATURE_ENUM FeatureId, UINT8 *pFeaturePara,UINT32 *pFeatureParaLen);
+UINT32 GC2155MIPIClose(void);
+
+
+//e_add for porting
+//e_add for porting
+//e_add for porting
+
+
+#endif /* __SENSOR_H */
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/gc2235_mipi_raw/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6735/gc2235_mipi_raw/Makefile
new file mode 100755
index 0000000..631ac5b
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735/gc2235_mipi_raw/Makefile
@@ -0,0 +1,4 @@
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+obj-y += gc2235mipi_Sensor.o
+
+
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/gc2235_mipi_raw/gc2235mipi_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735/gc2235_mipi_raw/gc2235mipi_Sensor.c
new file mode 100755
index 0000000..960a52b
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735/gc2235_mipi_raw/gc2235mipi_Sensor.c
@@ -0,0 +1,1587 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *	 GC2235mipi_Sensor.c
+ *
+ * Project:
+ * --------
+ *	 ALPS
+ *
+ * Description:
+ * ------------
+ *	 Source code of Sensor driver
+ *
+ *
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *============================================================================
+ ****************************************************************************/
+
+#include <linux/videodev2.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <asm/atomic.h>
+//#include <asm/system.h>
+#include <linux/xlog.h>
+
+#include "kd_camera_hw.h"
+#include "kd_imgsensor.h"
+#include "kd_imgsensor_define.h"
+#include "kd_imgsensor_errcode.h"
+
+#include "gc2235mipi_Sensor.h"
+
+#define PFX "GC2235_camera_sensor"
+//#define LOG_WRN(format, args...) xlog_printk(ANDROID_LOG_WARN ,PFX, "[%S] " format, __FUNCTION__, ##args)
+//#defineLOG_INF(format, args...) xlog_printk(ANDROID_LOG_INFO ,PFX, "[%s] " format, __FUNCTION__, ##args)
+//#define LOG_DBG(format, args...) xlog_printk(ANDROID_LOG_DEBUG ,PFX, "[%S] " format, __FUNCTION__, ##args)
+#define LOG_INF(format, args...)	xlog_printk(ANDROID_LOG_INFO   , PFX, "[%s] " format, __FUNCTION__, ##args)
+
+static DEFINE_SPINLOCK(imgsensor_drv_lock);
+
+
+static imgsensor_info_struct imgsensor_info = { 
+	.sensor_id = GC2235_SENSOR_ID,
+	
+	.checksum_value = 0xf7375923,
+	
+	.pre = {
+		.pclk = 30000000,				//record different mode's pclk
+		.linelength = 1107,				//record different mode's linelength
+		.framelength = 1387,			//record different mode's framelength
+		.startx = 0,					//record different mode's startx of grabwindow
+		.starty = 0,					//record different mode's starty of grabwindow
+		.grabwindow_width = 1600,		//record different mode's width of grabwindow
+		.grabwindow_height = 1200,		//record different mode's height of grabwindow
+		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
+		.mipi_data_lp2hs_settle_dc = 14,
+		/*	 following for GetDefaultFramerateByScenario()	*/
+		.max_framerate = 200,	
+	},
+	.cap = {
+		.pclk = 30000000,
+		.linelength = 1107,
+		.framelength = 1387,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 1600,
+		.grabwindow_height = 1200,
+		.mipi_data_lp2hs_settle_dc = 14,
+		.max_framerate = 200,
+	},
+	.cap1 = {
+		.pclk = 42000000,
+		.linelength = 1120,
+		.framelength = 1546,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 1600,
+		.grabwindow_height = 1200,
+		.mipi_data_lp2hs_settle_dc = 14,
+		.max_framerate = 300,	
+	},
+	.normal_video = {
+		.pclk = 42000000,
+		.linelength = 1120,
+		.framelength = 1246,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 1600,
+		.grabwindow_height = 1200,
+		.mipi_data_lp2hs_settle_dc = 14,
+		.max_framerate = 300,
+	},
+	.hs_video = {
+		.pclk = 176000000,
+		.linelength = 2880,
+		.framelength = 1984,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 1920,
+		.grabwindow_height = 1080,
+		.mipi_data_lp2hs_settle_dc = 14,
+		.max_framerate = 300,
+	},
+	.slim_video = {
+		.pclk = 176000000,
+		.linelength = 2688,
+		.framelength = 1984,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 1280,
+		.grabwindow_height = 720,
+		.mipi_data_lp2hs_settle_dc = 14,
+		.max_framerate = 300,
+	},
+	.margin = 0,
+	.min_shutter = 12,
+	.max_frame_length = 0xffff,
+	.ae_shut_delay_frame = 0,
+	.ae_sensor_gain_delay_frame = 0,
+	.ae_ispGain_delay_frame = 2,
+	.ihdr_support = 0,	  //1, support; 0,not support
+	.ihdr_le_firstline = 0,  //1,le first ; 0, se first
+	.sensor_mode_num = 3,	  //support sensor mode num
+	
+	.cap_delay_frame = 2, 
+	.pre_delay_frame = 2, 
+	.video_delay_frame = 2,
+	.hs_video_delay_frame = 2,
+	.slim_video_delay_frame = 2,
+	
+	.isp_driving_current = ISP_DRIVING_6MA,
+	.sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,
+	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_B,
+	.mclk = 24,
+	.mipi_lane_num = SENSOR_MIPI_2_LANE,
+	.i2c_addr_table = {0x78, 0xff},
+};
+
+
+static imgsensor_struct imgsensor = {
+	.mirror = IMAGE_NORMAL,				//mirrorflip information
+	.sensor_mode = IMGSENSOR_MODE_INIT, //IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
+	.shutter = 0x3D0,					//current shutter
+	.gain = 0x100,						//current gain
+	.dummy_pixel = 0,					//current dummypixel
+	.dummy_line = 0,					//current dummyline
+	.current_fps = 0,  //full size current fps : 24fps for PIP, 30fps for Normal or ZSD
+	.autoflicker_en = KAL_FALSE,  //auto flicker enable: KAL_FALSE for disable auto flicker, KAL_TRUE for enable auto flicker
+	.current_scenario_id = MSDK_SCENARIO_ID_CAMERA_PREVIEW,//current scenario id
+	.ihdr_en = 0, //sensor need support LE, SE with HDR feature
+	.i2c_write_id = 0x78,
+};
+
+
+/* Sensor output window information */
+static SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[5] =	 
+{
+ { 1600, 1200,	  0,	0, 1600, 1200, 1600,  1200, 0000, 0000, 1600,  1200,	  0,	0, 1600,  1200}, // Preview 
+ { 1600, 1200,	  0,	0, 1600, 1200, 1600,  1200, 0000, 0000, 1600,  1200,	  0,	0, 1600,  1200}, // capture 
+ { 1600, 1200,	  0,	0, 1600, 1200, 1600,  1200, 0000, 0000, 1600,  1200,	  0,	0, 1600,  1200}, // video 
+ { 1600, 1200,	  0,	0, 1600, 1200, 1600,  1200, 0000, 0000, 1600,  1200,	  0,	0, 1600,  1200}, //hight speed video 
+ { 1600, 1200,	  0,	0, 1600, 1200, 1600,  1200, 0000, 0000, 1600,  1200,	  0,	0, 1600,  1200}};// slim video 
+
+
+static kal_uint16 read_cmos_sensor(kal_uint32 addr)
+{
+	kal_uint16 get_byte=0;
+
+	char pu_send_cmd[1] = {(char)(addr & 0xFF) };
+	iReadRegI2C(pu_send_cmd, 1, (u8*)&get_byte, 1, imgsensor.i2c_write_id);
+
+	return get_byte;
+}
+
+static void write_cmos_sensor(kal_uint32 addr, kal_uint32 para)
+{
+#if 1
+	char pu_send_cmd[2] = {(char)(addr & 0xFF), (char)(para & 0xFF)};
+	iWriteRegI2C(pu_send_cmd, 2, imgsensor.i2c_write_id);
+#else
+	iWriteReg((u16)addr, (u32)para, 2, imgsensor.i2c_write_id);
+#endif
+}
+
+static void set_dummy()
+{
+	LOG_INF("dummyline = %d, dummypixels = %d \n", imgsensor.dummy_line, imgsensor.dummy_pixel);
+
+	write_cmos_sensor(0x0006, imgsensor.frame_length);  
+	write_cmos_sensor(0x0008, imgsensor.line_length);
+  
+}	/*	set_dummy  */
+
+
+static void set_max_framerate(UINT16 framerate)
+{
+	kal_int16 dummy_line;
+	kal_uint32 frame_length = imgsensor.frame_length;
+	unsigned long flags;
+
+	LOG_INF("framerate = %d ", framerate);
+   
+	frame_length = (10 * imgsensor.pclk) / framerate / imgsensor.line_length;
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.dummy_line = frame_length - imgsensor.frame_length;
+	if (imgsensor.dummy_line < 0) imgsensor.dummy_line = 0;
+	imgsensor.frame_length += imgsensor.dummy_line;
+	if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+		imgsensor.frame_length = imgsensor_info.max_frame_length;
+	spin_unlock(&imgsensor_drv_lock);
+	set_dummy();
+}	/*	set_max_framerate  */
+
+
+static void write_shutter(kal_uint16 shutter)
+{
+	kal_uint16 realtime_fps = 0;
+	kal_uint32 frame_length = 0;
+	   
+
+	spin_lock(&imgsensor_drv_lock);
+	if (shutter > imgsensor.min_frame_length - imgsensor_info.margin)		
+		imgsensor.frame_length = shutter + imgsensor_info.margin;
+	else
+		imgsensor.frame_length = imgsensor.min_frame_length;
+	if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+		imgsensor.frame_length = imgsensor_info.max_frame_length;
+	spin_unlock(&imgsensor_drv_lock);
+	
+	// Update Shutter
+	
+	if(shutter < 1) shutter = 1;
+	if(shutter > 8191) shutter = 8191;//2^13
+	//Update Shutter
+	write_cmos_sensor(0x04, (shutter) & 0xFF);
+	write_cmos_sensor(0x03, (shutter >> 8) & 0x1F);	
+
+	LOG_INF("shutter =%d", shutter);
+
+	
+}	/*	write_shutter  */
+
+
+
+/*************************************************************************
+* FUNCTION
+*	set_shutter
+*
+* DESCRIPTION
+*	This function set e-shutter of sensor to change exposure time.
+*
+* PARAMETERS
+*	iShutter : exposured lines
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static void set_shutter(kal_uint16 shutter)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&imgsensor_drv_lock, flags);
+	imgsensor.shutter = shutter;
+	spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
+	
+	write_shutter(shutter);
+}	/*	set_shutter */
+
+
+
+static kal_uint16 gain2reg(const kal_uint16 gain)
+{
+	kal_uint16 reg_gain = 0x0000;
+	
+	reg_gain = gain / 4 - 16;
+	
+	return (kal_uint16)reg_gain;
+}
+
+/*************************************************************************
+* FUNCTION
+*	set_gain
+*
+* DESCRIPTION
+*	This function is to set global gain to sensor.
+*
+* PARAMETERS
+*	iGain : sensor global gain(base: 0x40)
+*
+* RETURNS
+*	the actually gain set to sensor.
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint16 set_gain(kal_uint16 gain)
+{
+	kal_uint16 iReg,temp;
+
+	iReg = gain;
+	if(256> iReg)
+	{
+	//analogic gain
+	write_cmos_sensor(0xb0, 0x40); // global gain
+	write_cmos_sensor(0xb1, iReg);//only digital gain 12.13
+	}
+	else
+	{
+	//analogic gain
+	temp = 64*iReg/256;		
+	write_cmos_sensor(0xb0, temp); // global gain
+	write_cmos_sensor(0xb1, 0xff);//only digital gain 12.13
+	
+	}
+	return gain;
+}	/*	set_gain  */
+
+static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gain)
+{
+	LOG_INF("le:0x%x, se:0x%x, gain:0x%x\n",le,se,gain);
+	if (imgsensor.ihdr_en) {
+		write_cmos_sensor(0x3502, (le << 4) & 0xFF);
+		write_cmos_sensor(0x3501, (le >> 4) & 0xFF);	 
+		write_cmos_sensor(0x3500, (le >> 12) & 0x0F);
+		
+		write_cmos_sensor(0x3508, (se << 4) & 0xFF); 
+		write_cmos_sensor(0x3507, (se >> 4) & 0xFF);
+		write_cmos_sensor(0x3506, (se >> 12) & 0x0F); 
+
+		set_gain(gain);
+	}
+
+}
+
+
+
+static void set_mirror_flip(kal_uint8 image_mirror)
+{
+	LOG_INF("image_mirror = %d\n", image_mirror);
+	
+	switch (image_mirror)
+	{
+		case IMAGE_NORMAL://IMAGE_NORMAL:
+			write_cmos_sensor(0x17,0x14);//bit[1][0]
+	//		write_cmos_sensor(0x92,0x03);
+	//		write_cmos_sensor(0x94,0x0b);
+			break;
+		case IMAGE_H_MIRROR://IMAGE_H_MIRROR:
+			write_cmos_sensor(0x17,0x15);
+	//		GC2235_write_cmos_sensor(0x92,0x03);
+	//		GC2235_write_cmos_sensor(0x94,0x0b);
+			break;
+		case IMAGE_V_MIRROR://IMAGE_V_MIRROR:
+			write_cmos_sensor(0x17,0x16);
+	//		GC2235_write_cmos_sensor(0x92,0x02);
+	//		GC2235_write_cmos_sensor(0x94,0x0b);
+			break;
+		case IMAGE_HV_MIRROR://IMAGE_HV_MIRROR:
+			write_cmos_sensor(0x17,0x17);
+	//		GC2235_write_cmos_sensor(0x92,0x02);
+	//		GC2235_write_cmos_sensor(0x94,0x0b);
+			break;
+	}
+
+
+}
+
+/*************************************************************************
+* FUNCTION
+*	night_mode
+*
+* DESCRIPTION
+*	This function night mode of sensor.
+*
+* PARAMETERS
+*	bEnable: KAL_TRUE -> enable night mode, otherwise, disable night mode
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static void night_mode(kal_bool enable)
+{
+/*No Need to implement this function*/ 
+}	/*	night_mode	*/
+
+static void sensor_init(void)
+{
+	LOG_INF("E");
+	/* SYS */
+/////////////////////////////////////////////////////
+	//////////////////////	 SYS   //////////////////////
+	/////////////////////////////////////////////////////
+	write_cmos_sensor(0xfe, 0x80);
+	write_cmos_sensor(0xfe, 0x80);
+	write_cmos_sensor(0xfe, 0x80);
+	write_cmos_sensor(0xf2, 0x00);
+	write_cmos_sensor(0xf6, 0x00);
+	write_cmos_sensor(0xfc, 0x06);
+
+	write_cmos_sensor(0xf7, 0x15); //pll enable
+	write_cmos_sensor(0xf8, 0x84); //Pll mode 2
+	write_cmos_sensor(0xfa, 0x00); //div
+
+	write_cmos_sensor(0xf9, 0xfe); //[0] pll enable
+	write_cmos_sensor(0xfe, 0x00);
+	
+	/////////////////////////////////////////////////////
+	////////////////   ANALOG & CISCTL	 ////////////////
+	/////////////////////////////////////////////////////
+
+	write_cmos_sensor(0x03, 0x05);
+	write_cmos_sensor(0x04, 0x4b);
+	write_cmos_sensor(0x05, 0x01);
+	write_cmos_sensor(0x06, 0x1d);
+	write_cmos_sensor(0x07, 0x00);
+	write_cmos_sensor(0x08, 0x9b);
+
+	write_cmos_sensor(0x0a, 0x02);
+	write_cmos_sensor(0x0c, 0x00);
+	write_cmos_sensor(0x0d, 0x04);
+	write_cmos_sensor(0x0e, 0xd0);
+	write_cmos_sensor(0x0f, 0x06); 
+	write_cmos_sensor(0x10, 0x50);
+	
+	write_cmos_sensor(0x17, 0x15);//14 //[0]mirror [1]flip
+	write_cmos_sensor(0x18, 0x12); //  0x1e
+	write_cmos_sensor(0x19, 0x06);
+	write_cmos_sensor(0x1a, 0x01);
+	write_cmos_sensor(0x1b, 0x48);
+
+	write_cmos_sensor(0x1e, 0x88); 
+	write_cmos_sensor(0x1f, 0x48); 
+	write_cmos_sensor(0x20, 0x03);
+	write_cmos_sensor(0x21, 0x6f);
+	write_cmos_sensor(0x22, 0x80); 
+	write_cmos_sensor(0x23, 0xc1);
+	write_cmos_sensor(0x24, 0x2f);//PAD_drv
+	write_cmos_sensor(0x26, 0x01);
+	write_cmos_sensor(0x27, 0x30);
+	write_cmos_sensor(0x3f, 0x00);
+	
+	/////////////////////////////////////////////////////
+	//////////////////////	 ISP   //////////////////////
+	/////////////////////////////////////////////////////
+	write_cmos_sensor(0x8b, 0xa0);
+	write_cmos_sensor(0x8c, 0x02);
+	write_cmos_sensor(0x90, 0x01);
+	write_cmos_sensor(0x92, 0x03);
+	write_cmos_sensor(0x94, 0x06);
+	write_cmos_sensor(0x95, 0x04);
+	write_cmos_sensor(0x96, 0xb0);
+	write_cmos_sensor(0x97, 0x06);
+	write_cmos_sensor(0x98, 0x40);
+	
+	/////////////////////////////////////////////////////
+	//////////////////////	 BLK   //////////////////////
+	/////////////////////////////////////////////////////
+	write_cmos_sensor(0x40, 0x72); //smooth speed 
+	write_cmos_sensor(0x41, 0x04);
+	write_cmos_sensor(0x43, 0x18); //global_offset 20140124 lanking
+	write_cmos_sensor(0x5e, 0x00);
+	write_cmos_sensor(0x5f, 0x00);
+	write_cmos_sensor(0x60, 0x00);
+	write_cmos_sensor(0x61, 0x00); 
+	write_cmos_sensor(0x62, 0x00);
+	write_cmos_sensor(0x63, 0x00); 
+	write_cmos_sensor(0x64, 0x00);
+	write_cmos_sensor(0x65, 0x00);
+	write_cmos_sensor(0x66, 0x20);
+	write_cmos_sensor(0x67, 0x20); 
+	write_cmos_sensor(0x68, 0x20);
+	write_cmos_sensor(0x69, 0x20);
+	//Sleep(100);
+
+	
+	/////////////////////////////////////////////////////
+	//////////////////////	 GAIN	/////////////////////
+	/////////////////////////////////////////////////////
+	write_cmos_sensor(0xb2, 0x00);
+	write_cmos_sensor(0xb3, 0x40);
+	write_cmos_sensor(0xb4, 0x40);
+	write_cmos_sensor(0xb5, 0x40);
+	
+	/////////////////////////////////////////////////////
+	////////////////////   DARK SUN   ///////////////////
+	/////////////////////////////////////////////////////
+	write_cmos_sensor(0xb8, 0x0f);
+	write_cmos_sensor(0xb9, 0x23);
+	write_cmos_sensor(0xba, 0xff);
+	write_cmos_sensor(0xbc, 0x00);
+	write_cmos_sensor(0xbd, 0x00);
+	write_cmos_sensor(0xbe, 0xff);
+	write_cmos_sensor(0xbf, 0x09);
+
+	/////////////////////////////////////////////////////
+	//////////////////////	 OUTPUT	/////////////////////
+	/////////////////////////////////////////////////////
+	write_cmos_sensor(0xfe, 0x03);
+
+	write_cmos_sensor(0x01, 0x07);
+	write_cmos_sensor(0x02, 0x11);//mipi drv
+	write_cmos_sensor(0x03, 0x11);//mipi drv
+	write_cmos_sensor(0x06, 0x80);
+	write_cmos_sensor(0x11, 0x2b);
+	write_cmos_sensor(0x12, 0xd0);
+	write_cmos_sensor(0x13, 0x07);
+	write_cmos_sensor(0x15, 0x10);
+	write_cmos_sensor(0x04, 0x20);
+	write_cmos_sensor(0x05, 0x00);
+	write_cmos_sensor(0x17, 0x01);
+
+
+	write_cmos_sensor(0x21, 0x01);
+	write_cmos_sensor(0x22, 0x02);
+	write_cmos_sensor(0x23, 0x01);
+	write_cmos_sensor(0x29, 0x02);
+	write_cmos_sensor(0x2a, 0x01);
+
+	write_cmos_sensor(0x10, 0x81);  // 93 line_sync_mode 
+
+	write_cmos_sensor(0xfe, 0x00);
+	write_cmos_sensor(0xf2, 0x00);
+
+}	/*	sensor_init  */
+
+
+static void preview_setting(void)
+{
+	LOG_INF("E!\n");
+
+  //MIPI//
+  write_cmos_sensor(0xfe,0x03);
+  write_cmos_sensor(0x12,0xd0);
+  write_cmos_sensor(0x13,0x07);
+  write_cmos_sensor(0x10,0x91);
+  write_cmos_sensor(0xfe,0x00);	
+	
+}	/*	preview_setting  */
+
+static void capture_setting(kal_uint16 currefps)
+{
+	LOG_INF("E! currefps:%d\n",currefps);
+	if (currefps == 240) { //24fps for PIP
+		//max 24fps //
+		  // AEC&frame length//
+		  //MIPI//
+
+  write_cmos_sensor(0xfe,0x03);
+  write_cmos_sensor(0x12,0xd0);
+  write_cmos_sensor(0x13,0x07);
+  write_cmos_sensor(0x10,0x91);
+  write_cmos_sensor(0xfe,0x00);	
+	} else {   //30fps			//30fps for Normal capture & ZSD
+		// max 30fps//
+	
+		   //MI
+  write_cmos_sensor(0xfe,0x03);
+  write_cmos_sensor(0x12,0xd0);
+  write_cmos_sensor(0x13,0x07);
+  write_cmos_sensor(0x10,0x91);
+  write_cmos_sensor(0xfe,0x00);	
+	}
+		
+}
+
+static void normal_video_setting(kal_uint16 currefps)
+{
+	LOG_INF("E! currefps:%d\n",currefps);
+	
+
+	 //MIPI//
+	 write_cmos_sensor(0xfe,0x03);
+
+	 write_cmos_sensor(0x10,0x91);
+	 write_cmos_sensor(0xfe,0x00);
+		
+}
+static void hs_video_setting()
+{
+	LOG_INF("E\n");
+	//////////////////////////////////////////////////////////////////////////
+	//			Sensor			 : Hi-544
+	//		Mode			 :	
+	//		Size			 : 1920 * 1080
+	//			set file				 : v0.26
+	//			Date						 : 20140510
+	//////////////////////////////////////////////////////////////////////////
+	
+	write_cmos_sensor(0x0A00, 0x0000); //sleep On
+	
+	//--- Initial Set file ---//
+	
+	write_cmos_sensor(0x0B16, 0x4A0B);
+	write_cmos_sensor(0x004C, 0x0100); 
+	write_cmos_sensor(0x0032, 0x0101); 
+	write_cmos_sensor(0x001E, 0x0101); 
+	write_cmos_sensor(0x000C, 0x0000);
+	
+	write_cmos_sensor(0x0902, 0x4101); 
+	write_cmos_sensor(0x090A, 0x03E4); 
+	write_cmos_sensor(0x090C, 0x0020); 
+	write_cmos_sensor(0x090E, 0x0020); 
+	write_cmos_sensor(0x0910, 0x5D07); 
+	write_cmos_sensor(0x0912, 0x061e); 
+	write_cmos_sensor(0x0914, 0x0407); 
+	write_cmos_sensor(0x0916, 0x0b0a); 
+	write_cmos_sensor(0x0918, 0x0e09); 
+	
+	write_cmos_sensor(0x0012, 0x00BC); 
+	write_cmos_sensor(0x0018, 0x0ABB); 
+	
+	write_cmos_sensor(0x0026, 0x0114); 
+	write_cmos_sensor(0x002C, 0x06b3); 
+	
+	
+	//--Crop size 2560x1440 ----///
+	write_cmos_sensor(0x0128, 0x0002); // digital_crop_x_offset_l
+	write_cmos_sensor(0x012A, 0x0000); // digital_crop_y_offset_l
+	write_cmos_sensor(0x012C, 0x0A00); // digital_crop_image_width
+	write_cmos_sensor(0x012E, 0x05A0); // digital_crop_image_height
+	
+	//----< Image FMT Size >--------------------//
+	//Image size 1920x1080
+	write_cmos_sensor(0x0110, 0x0780); //X_output_size_h	 
+	write_cmos_sensor(0x0112, 0x0438); //Y_output_size_h  
+	
+	//----< Frame / Line Length >--------------//
+	write_cmos_sensor(0x0006, 0x07C0); //frame_length_h 1984 @2560x1440@30.7fps
+	write_cmos_sensor(0x0008, 0x0B40); //line_length_h 2880
+	write_cmos_sensor(0x000A, 0x0DB0); //line_length for binning 3504
+	//---------------------------------------//
+	
+	//--- ETC set ----//
+	write_cmos_sensor(0x0000, 0x0000); 
+	write_cmos_sensor(0x0700, 0x5090); 
+	
+	write_cmos_sensor(0x0032, 0x0101);	
+	write_cmos_sensor(0x001E, 0x0101);	
+	//----------------//
+	
+	//--- ISP enable Selection ---------------//
+	write_cmos_sensor(0x0A04, 0x0133); //isp_en. [9]s-gamma,[8]MIPI_en,[6]compresion10to8,[5]Scaler,[4]window,[3]DG,[2]LSC,[1]adpc,[0]tpg //TEST PATTERN
+	//----------------------------------------//
+	
+	write_cmos_sensor(0x0A00, 0x0100); //sleep Off 
+	
+	mDELAY(30);
+}
+
+static void slim_video_setting()
+{
+	LOG_INF("E\n");
+	//////////////////////////////////////////////////////////////////////////
+	//			Sensor			 : Hi-544
+	//		Mode			 :	
+	//		Size			 : 1280 * 720
+	//			set file				 : v0.26
+	//			Date						 : 20140510
+	//////////////////////////////////////////////////////////////////////////
+	
+	write_cmos_sensor(0x0A00, 0x0000); //sleep On
+	
+	//--- Initial Set file ---//
+	
+	write_cmos_sensor(0x0B16, 0x4A0B);
+	write_cmos_sensor(0x004C, 0x0100); 
+	write_cmos_sensor(0x0032, 0x0101); 
+	write_cmos_sensor(0x001E, 0x0101); 
+	write_cmos_sensor(0x000C, 0x0000);
+	
+	write_cmos_sensor(0x0902, 0x4101); 
+	write_cmos_sensor(0x090A, 0x03E4); 
+	write_cmos_sensor(0x090C, 0x0020); 
+	write_cmos_sensor(0x090E, 0x0020); 
+	write_cmos_sensor(0x0910, 0x5D07); 
+	write_cmos_sensor(0x0912, 0x061e); 
+	write_cmos_sensor(0x0914, 0x0407); 
+	write_cmos_sensor(0x0916, 0x0b0a); 
+	write_cmos_sensor(0x0918, 0x0e09); 
+	 
+	write_cmos_sensor(0x0012, 0x00BC); 
+	write_cmos_sensor(0x0018, 0x0ABB); 
+	 
+	write_cmos_sensor(0x0026, 0x0114); 
+	write_cmos_sensor(0x002C, 0x06b3); 
+	
+	
+	//--Crop size 2560x1440 ----///
+	write_cmos_sensor(0x0128, 0x0002); // digital_crop_x_offset_l
+	write_cmos_sensor(0x012A, 0x0000); // digital_crop_y_offset_l
+	write_cmos_sensor(0x012C, 0x0A00); // digital_crop_image_width
+	write_cmos_sensor(0x012E, 0x05A0); // digital_crop_image_height
+	
+	//----< Image FMT Size >--------------------//
+	//Image size 1280x720
+	write_cmos_sensor(0x0110, 0x0500); //X_output_size_h	 
+	write_cmos_sensor(0x0112, 0x02d0); //Y_output_size_h  
+	
+	//----< Frame / Line Length >--------------//
+	write_cmos_sensor(0x0006, 0x07C0); //frame_length_h 1984 @2560x1440@30.7fps
+	write_cmos_sensor(0x0008, 0x0B40); //line_length_h 2880
+	write_cmos_sensor(0x000A, 0x0DB0); //line_length for binning 3504
+	
+	//--- ETC set ----//
+	write_cmos_sensor(0x0000, 0x0000); 
+	write_cmos_sensor(0x0700, 0xA1A8); 
+	
+	write_cmos_sensor(0x0032, 0x0101);	
+	write_cmos_sensor(0x001E, 0x0101);	
+	
+	//--- ISP enable Selection ---------------//
+	write_cmos_sensor(0x0A04, 0x0133); //TEST PATTERN
+	//----------------------------------------//
+	
+	write_cmos_sensor(0x0A00, 0x0100); //sleep Off
+
+}
+
+#ifdef VIDEO_720P
+
+static void video_720p_setting(void)
+{
+	LOG_INF("E\n");
+
+	//5.1.4 Video BQ720p Full FOV 30fps 24M MCLK 2lane 864Mbps/lane
+	write_cmos_sensor(0x0100,0x00);  //software sleep
+	
+	write_cmos_sensor(0x3708,0xe6);  //sensor control
+	write_cmos_sensor(0x3709,0xc3);  //sensor control
+	write_cmos_sensor(0x3803,0xf4);  //timing Y start L
+	write_cmos_sensor(0x3806,0x06);  //timing Y end H
+	write_cmos_sensor(0x3807,0xab);  //timing Y end L
+	
+	write_cmos_sensor(0x3808,0x05);  //X output size H	1280
+	write_cmos_sensor(0x3809,0x00);  //X output size L
+	write_cmos_sensor(0x380a,0x02);  //Y output size H	720
+	write_cmos_sensor(0x380b,0xd0);  //Y output size L
+	
+	//write_cmos_sensor(0x380c,0x0d);  //HTS H	2688
+	//write_cmos_sensor(0x380d,0xb0);  //HTS L
+	//write_cmos_sensor(0x380e,0x05);  //VTS H	1984
+	//write_cmos_sensor(0x380f,0xf0);  //VTS L
+	write_cmos_sensor(0x380c, ((imgsensor_info.video2.linelength >> 8) & 0xFF)); // hts = 2688
+	write_cmos_sensor(0x380d, (imgsensor_info.video2.linelength & 0xFF));		 // hts
+	write_cmos_sensor(0x380e, ((imgsensor_info.video2.framelength >> 8) & 0xFF));  // vts = 1984
+	write_cmos_sensor(0x380f, (imgsensor_info.video2.framelength & 0xFF));		   // vts	  
+	
+	write_cmos_sensor(0x3810,0x00);  //timing ISP x win H
+	write_cmos_sensor(0x3811,0x08);  //timing ISP x win L
+	write_cmos_sensor(0x3812,0x00);  //timing ISP y win H
+	write_cmos_sensor(0x3813,0x02);  //timing ISP y win L
+	write_cmos_sensor(0x3814,0x31);  //timing X inc
+	write_cmos_sensor(0x3815,0x31);  //timing Y inc
+
+	/********************************************************
+	   *
+	   *   0x3820[2] ISP Vertical flip
+	   *   0x3820[1] Sensor Vertical flip
+	   *
+	   *   0x3821[2] ISP Horizontal mirror
+	   *   0x3821[1] Sensor Horizontal mirror
+	   *
+	   *   ISP and Sensor flip or mirror register bit should be the same!!
+	   *
+	   ********************************************************/
+	write_cmos_sensor(0x3820,0x01);  //v fast vbin of, flip off, v bin on
+	write_cmos_sensor(0x3821,0x1f);  //hsync on, h mirror on, h bin on
+	
+	write_cmos_sensor(0x3a04,0x06);
+	write_cmos_sensor(0x3a05,0x14);
+	write_cmos_sensor(0x5002,0x00);  //scale off
+	
+	write_cmos_sensor(0x0100,0x01);  //wake up
+
+	LOG_INF("Exit!\n");
+}
+
+#elif defined VIDEO_1080P
+
+static void video_1080p_setting(void)
+{
+	LOG_INF("E\n");
+	
+	//5.1.5 Video 1080p 30fps 24M MCLK 2lane 864Mbps/lane
+	write_cmos_sensor(0x0100,0x00);  //software sleep
+
+	write_cmos_sensor(0x3708,0xe2);  //sensor control
+	write_cmos_sensor(0x3709,0xc3);  //sensor control
+	write_cmos_sensor(0x3803,0xf8);  //timing Y start L
+	write_cmos_sensor(0x3806,0x06);  //timing Y end H
+	write_cmos_sensor(0x3807,0xab);  //timing Y end L
+
+	write_cmos_sensor(0x3808,0x07);  //X output size H	1920
+	write_cmos_sensor(0x3809,0x80);  //X output size L
+	write_cmos_sensor(0x380a,0x04);  //Y output size H	1080
+	write_cmos_sensor(0x380b,0x38);  //Y output size L
+
+	//write_cmos_sensor(0x380c,0x0a);  //HTS H	2688
+	//write_cmos_sensor(0x380d,0x80);  //HTS L
+	//write_cmos_sensor(0x380e,0x07);  //VTS H	1984
+	//write_cmos_sensor(0x380f,0xc0);  //VYS L
+	write_cmos_sensor(0x380c, ((imgsensor_info.video1_linelength >> 8) & 0xFF)); // hts = 2688
+	write_cmos_sensor(0x380d, (imgsensor_info.video1_linelength & 0xFF));		 // hts
+	write_cmos_sensor(0x380e, ((imgsensor_info.video1_framelength >> 8) & 0xFF));  // vts = 1984
+	write_cmos_sensor(0x380f, (imgsensor_info.video1_framelength & 0xFF));		   // vts		
+
+	write_cmos_sensor(0x3810,0x00);  //timing ISP x win H
+	write_cmos_sensor(0x3811,0x02);  //timing ISP x win L
+	write_cmos_sensor(0x3812,0x00);  //timing ISP y win H
+	write_cmos_sensor(0x3813,0x02);  //timing ISP y win L
+	write_cmos_sensor(0x3814,0x11);  //timing X inc
+	write_cmos_sensor(0x3815,0x11);  //timing Y inc
+
+	/********************************************************
+	   *
+	   *   0x3820[2] ISP Vertical flip
+	   *   0x3820[1] Sensor Vertical flip
+	   *
+	   *   0x3821[2] ISP Horizontal mirror
+	   *   0x3821[1] Sensor Horizontal mirror
+	   *
+	   *   ISP and Sensor flip or mirror register bit should be the same!!
+	   *
+	   ********************************************************/
+	write_cmos_sensor(0x3820,0x00);  //v bin off
+	write_cmos_sensor(0x3821,0x1e);  //hsync on, h mirror on, h bin off
+	
+	write_cmos_sensor(0x3a04,0x06);
+	write_cmos_sensor(0x3a05,0x14);
+	write_cmos_sensor(0x5002,0x80);  //scale on
+
+	write_cmos_sensor(0x0100,0x01);  //wake up
+
+	LOG_INF("Exit!\n");
+}
+
+#else
+
+static void video_setting(void)
+{
+	LOG_INF("ihdr_en:%d\n",imgsensor.ihdr_en);
+	
+
+	 //MIPI//
+	write_cmos_sensor(0xfe,0x03);
+	write_cmos_sensor(0x10,0x91); 
+	write_cmos_sensor(0xfe,0x00);
+
+}
+
+#endif
+
+/*************************************************************************
+* FUNCTION
+*	get_imgsensor_id
+*
+* DESCRIPTION
+*	This function get the sensor ID 
+* 
+* PARAMETERS
+*	*sensorID : return the sensor ID 
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 get_imgsensor_id(UINT32 *sensor_id) 
+{
+	kal_uint8 i = 0;
+	kal_uint8 retry = 2;
+	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
+	while (imgsensor_info.i2c_addr_table[i] != 0xff) {
+		spin_lock(&imgsensor_drv_lock);
+		imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
+		spin_unlock(&imgsensor_drv_lock);
+		do {
+			*sensor_id = ((read_cmos_sensor(0xf0) << 8) | read_cmos_sensor(0xf1));
+			if (*sensor_id == imgsensor_info.sensor_id) {				
+				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);	  
+				return ERROR_NONE;
+			}	
+			LOG_INF("Read sensor id fail, write_id: 0x%x, sensor_id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
+			retry--;
+		} while(retry > 0);
+		i++;
+		retry = 2;
+	}
+	if (*sensor_id != imgsensor_info.sensor_id) {
+		// if Sensor ID is not correct, Must set *sensor_id to 0xFFFFFFFF 
+		*sensor_id = 0xFFFFFFFF;
+		return ERROR_SENSOR_CONNECT_FAIL;
+	}
+	return ERROR_NONE;
+}
+
+
+/*************************************************************************
+* FUNCTION
+*	open
+*
+* DESCRIPTION
+*	This function initialize the registers of CMOS sensor
+*
+* PARAMETERS
+*	None
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 open(void)
+{
+	//const kal_uint8 i2c_addr[] = {IMGSENSOR_WRITE_ID_1, IMGSENSOR_WRITE_ID_2};
+	kal_uint8 i = 0;
+	kal_uint8 retry = 2;
+	kal_uint16 sensor_id = 0; 
+	LOG_INF("PLATFORM:MT6595,MIPI 2LANE\n");
+	LOG_INF("preview 1280*960@30fps,864Mbps/lane; video 1280*960@30fps,864Mbps/lane; capture 5M@30fps,864Mbps/lane\n");
+	
+	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
+	while (imgsensor_info.i2c_addr_table[i] != 0xff) {
+		spin_lock(&imgsensor_drv_lock);
+		imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
+		spin_unlock(&imgsensor_drv_lock);
+		do {
+			sensor_id = ((read_cmos_sensor(0xf0) << 8) | read_cmos_sensor(0xf1));
+			if (sensor_id == imgsensor_info.sensor_id) {				
+				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);	  
+				break;
+			}	
+			LOG_INF("Read sensor id fail, lanking___id: 0x%x\n", sensor_id);
+			retry--;
+		} while(retry > 0);
+		i++;
+		if (sensor_id == imgsensor_info.sensor_id)
+			break;
+		retry = 2;
+	}		 
+	if (imgsensor_info.sensor_id != sensor_id)
+		return ERROR_SENSOR_CONNECT_FAIL;
+	
+	/* initail sequence write in  */
+	sensor_init();
+
+	spin_lock(&imgsensor_drv_lock);
+
+	imgsensor.autoflicker_en= KAL_FALSE;
+	imgsensor.sensor_mode = IMGSENSOR_MODE_INIT;
+	imgsensor.shutter = 0x3D0;
+	imgsensor.gain = 0x100;
+	imgsensor.pclk = imgsensor_info.pre.pclk;
+	imgsensor.frame_length = imgsensor_info.pre.framelength;
+	imgsensor.line_length = imgsensor_info.pre.linelength;
+	imgsensor.min_frame_length = imgsensor_info.pre.framelength;
+	imgsensor.dummy_pixel = 0;
+	imgsensor.dummy_line = 0;
+	imgsensor.ihdr_en = 0;
+	imgsensor.current_fps = imgsensor_info.pre.max_framerate;
+	spin_unlock(&imgsensor_drv_lock);
+
+	return ERROR_NONE;
+}	/*	open  */
+
+
+
+/*************************************************************************
+* FUNCTION
+*	close
+*
+* DESCRIPTION
+*	
+*
+* PARAMETERS
+*	None
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 close(void)
+{
+	LOG_INF("E\n");
+
+	/*No Need to implement this function*/ 
+	
+	return ERROR_NONE;
+}	/*	close  */
+
+
+/*************************************************************************
+* FUNCTION
+* preview
+*
+* DESCRIPTION
+*	This function start the sensor preview.
+*
+* PARAMETERS
+*	*image_window : address pointer of pixel numbers in one period of HSYNC
+*  *sensor_config_data : address pointer of line numbers in one period of VSYNC
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("E\n");
+
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.sensor_mode = IMGSENSOR_MODE_PREVIEW;
+	imgsensor.pclk = imgsensor_info.pre.pclk;
+	//imgsensor.video_mode = KAL_FALSE;
+	imgsensor.line_length = imgsensor_info.pre.linelength;
+	imgsensor.frame_length = imgsensor_info.pre.framelength; 
+	imgsensor.min_frame_length = imgsensor_info.pre.framelength;
+	imgsensor.current_fps = imgsensor_info.pre.max_framerate;
+	imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	preview_setting();
+	return ERROR_NONE;
+}	/*	preview   */
+
+/*************************************************************************
+* FUNCTION
+*	capture
+*
+* DESCRIPTION
+*	This function setup the CMOS sensor in capture MY_OUTPUT mode
+*
+* PARAMETERS
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+						  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("E\n");
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.sensor_mode = IMGSENSOR_MODE_CAPTURE;
+	imgsensor.current_fps = 300;
+	if (imgsensor.current_fps == 240) {
+		imgsensor.pclk = imgsensor_info.cap1.pclk;
+		imgsensor.line_length = imgsensor_info.cap1.linelength;
+		imgsensor.frame_length = imgsensor_info.cap1.framelength;  
+		imgsensor.min_frame_length = imgsensor_info.cap1.framelength;
+		imgsensor.autoflicker_en = KAL_FALSE;
+	} else {
+		imgsensor.pclk = imgsensor_info.cap.pclk;
+		imgsensor.line_length = imgsensor_info.cap.linelength;
+		imgsensor.frame_length = imgsensor_info.cap.framelength;  
+		imgsensor.min_frame_length = imgsensor_info.cap.framelength;
+		imgsensor.current_fps = imgsensor_info.cap.max_framerate;
+		imgsensor.autoflicker_en = KAL_FALSE;
+	}
+	spin_unlock(&imgsensor_drv_lock);
+
+	capture_setting(imgsensor.current_fps); 
+	
+	
+	return ERROR_NONE;
+}	/* capture() */
+static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("E\n");
+	
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.sensor_mode = IMGSENSOR_MODE_VIDEO;
+	imgsensor.pclk = imgsensor_info.normal_video.pclk;
+	imgsensor.line_length = imgsensor_info.normal_video.linelength;
+	imgsensor.frame_length = imgsensor_info.normal_video.framelength;  
+	imgsensor.min_frame_length = imgsensor_info.normal_video.framelength;
+	imgsensor.current_fps = 300;
+	imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	normal_video_setting(imgsensor.current_fps);
+	
+	
+	return ERROR_NONE;
+}	/*	normal_video   */
+
+static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("E\n");
+	
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.sensor_mode = IMGSENSOR_MODE_HIGH_SPEED_VIDEO;
+	imgsensor.pclk = imgsensor_info.hs_video.pclk;
+	//imgsensor.video_mode = KAL_TRUE;
+	imgsensor.line_length = imgsensor_info.hs_video.linelength;
+	imgsensor.frame_length = imgsensor_info.hs_video.framelength; 
+	imgsensor.min_frame_length = imgsensor_info.hs_video.framelength;
+	imgsensor.dummy_line = 0;
+	imgsensor.dummy_pixel = 0;
+	imgsensor.current_fps = 300;
+	imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	hs_video_setting();
+	
+	return ERROR_NONE;
+}	/*	hs_video   */
+
+static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("E\n");
+	
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.sensor_mode = IMGSENSOR_MODE_SLIM_VIDEO;
+	imgsensor.pclk = imgsensor_info.slim_video.pclk;
+	//imgsensor.video_mode = KAL_TRUE;
+	imgsensor.line_length = imgsensor_info.slim_video.linelength;
+	imgsensor.frame_length = imgsensor_info.slim_video.framelength; 
+	imgsensor.min_frame_length = imgsensor_info.slim_video.framelength;
+	imgsensor.dummy_line = 0;
+	imgsensor.dummy_pixel = 0;
+	imgsensor.current_fps = 300;
+	imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	slim_video_setting();
+	
+	return ERROR_NONE;
+}	/*	slim_video	 */
+
+
+
+static kal_uint32 get_resolution(MSDK_SENSOR_RESOLUTION_INFO_STRUCT *sensor_resolution)
+{
+	LOG_INF("E\n");
+	sensor_resolution->SensorFullWidth = imgsensor_info.cap.grabwindow_width;
+	sensor_resolution->SensorFullHeight = imgsensor_info.cap.grabwindow_height;
+	
+	sensor_resolution->SensorPreviewWidth = imgsensor_info.pre.grabwindow_width;
+	sensor_resolution->SensorPreviewHeight = imgsensor_info.pre.grabwindow_height;
+
+	sensor_resolution->SensorVideoWidth = imgsensor_info.normal_video.grabwindow_width;
+	sensor_resolution->SensorVideoHeight = imgsensor_info.normal_video.grabwindow_height;		
+
+	
+	sensor_resolution->SensorHighSpeedVideoWidth	 = imgsensor_info.hs_video.grabwindow_width;
+	sensor_resolution->SensorHighSpeedVideoHeight	 = imgsensor_info.hs_video.grabwindow_height;
+	
+	sensor_resolution->SensorSlimVideoWidth	 = imgsensor_info.slim_video.grabwindow_width;
+	sensor_resolution->SensorSlimVideoHeight	 = imgsensor_info.slim_video.grabwindow_height;
+	return ERROR_NONE;
+}	/*	get_resolution	*/
+
+static kal_uint32 get_info(MSDK_SCENARIO_ID_ENUM scenario_id,
+					  MSDK_SENSOR_INFO_STRUCT *sensor_info,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("scenario_id = %d\n", scenario_id);
+
+	
+	//sensor_info->SensorVideoFrameRate = imgsensor_info.normal_video.max_framerate/10; /* not use */
+	//sensor_info->SensorStillCaptureFrameRate= imgsensor_info.cap.max_framerate/10; /* not use */
+	//imgsensor_info->SensorWebCamCaptureFrameRate= imgsensor_info.v.max_framerate; /* not use */
+
+	sensor_info->SensorClockPolarity = SENSOR_CLOCK_POLARITY_LOW;
+	sensor_info->SensorClockFallingPolarity = SENSOR_CLOCK_POLARITY_LOW; /* not use */
+	sensor_info->SensorHsyncPolarity = SENSOR_CLOCK_POLARITY_LOW; // inverse with datasheet
+	sensor_info->SensorVsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
+	sensor_info->SensorInterruptDelayLines = 4; /* not use */
+	sensor_info->SensorResetActiveHigh = FALSE; /* not use */
+	sensor_info->SensorResetDelayCount = 5; /* not use */
+
+	sensor_info->SensroInterfaceType = imgsensor_info.sensor_interface_type;
+
+	sensor_info->SensorOutputDataFormat = imgsensor_info.sensor_output_dataformat;
+
+	sensor_info->CaptureDelayFrame = imgsensor_info.cap_delay_frame; 
+	sensor_info->PreviewDelayFrame = imgsensor_info.pre_delay_frame; 
+	sensor_info->VideoDelayFrame = imgsensor_info.video_delay_frame; 
+	sensor_info->HighSpeedVideoDelayFrame = imgsensor_info.hs_video_delay_frame;
+	sensor_info->SlimVideoDelayFrame = imgsensor_info.slim_video_delay_frame;
+
+	sensor_info->SensorMasterClockSwitch = 0; /* not use */
+	sensor_info->SensorDrivingCurrent = imgsensor_info.isp_driving_current;
+	
+	sensor_info->AEShutDelayFrame = imgsensor_info.ae_shut_delay_frame; 		 /* The frame of setting shutter default 0 for TG int */
+	sensor_info->AESensorGainDelayFrame = imgsensor_info.ae_sensor_gain_delay_frame;	/* The frame of setting sensor gain */
+	sensor_info->AEISPGainDelayFrame = imgsensor_info.ae_ispGain_delay_frame;	
+	sensor_info->IHDR_Support = imgsensor_info.ihdr_support;
+	sensor_info->IHDR_LE_FirstLine = imgsensor_info.ihdr_le_firstline;
+	sensor_info->SensorModeNum = imgsensor_info.sensor_mode_num;
+	
+	sensor_info->SensorMIPILaneNumber = imgsensor_info.mipi_lane_num; 
+	sensor_info->SensorClockFreq = imgsensor_info.mclk;
+	sensor_info->SensorClockDividCount = 3; /* not use */
+	sensor_info->SensorClockRisingCount = 0;
+	sensor_info->SensorClockFallingCount = 2; /* not use */
+	sensor_info->SensorPixelClockCount = 3; /* not use */
+	sensor_info->SensorDataLatchCount = 2; /* not use */
+	
+	sensor_info->MIPIDataLowPwr2HighSpeedTermDelayCount = 0; 
+	sensor_info->MIPICLKLowPwr2HighSpeedTermDelayCount = 0;
+	sensor_info->SensorWidthSampling = 0;  // 0 is default 1x
+	sensor_info->SensorHightSampling = 0;	// 0 is default 1x 
+	sensor_info->SensorPacketECCOrder = 1;
+
+	switch (scenario_id) {
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+			sensor_info->SensorGrabStartX = imgsensor_info.pre.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;		
+			
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
+			
+			break;
+		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+			sensor_info->SensorGrabStartX = imgsensor_info.cap.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.cap.starty;
+				  
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.cap.mipi_data_lp2hs_settle_dc; 
+
+			break;	 
+		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+			
+			sensor_info->SensorGrabStartX = imgsensor_info.normal_video.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.normal_video.starty;
+	   
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.normal_video.mipi_data_lp2hs_settle_dc; 
+
+			break;	  
+		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:			
+			sensor_info->SensorGrabStartX = imgsensor_info.hs_video.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.hs_video.starty;
+				  
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.hs_video.mipi_data_lp2hs_settle_dc; 
+
+			break;
+		case MSDK_SCENARIO_ID_SLIM_VIDEO:
+			sensor_info->SensorGrabStartX = imgsensor_info.slim_video.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.slim_video.starty;
+				  
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.slim_video.mipi_data_lp2hs_settle_dc; 
+
+			break;
+		default:			
+			sensor_info->SensorGrabStartX = imgsensor_info.pre.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;		
+			
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
+			break;
+	}
+	
+	return ERROR_NONE;
+}	/*	get_info  */
+
+
+static kal_uint32 control(MSDK_SCENARIO_ID_ENUM scenario_id, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("scenario_id = %d\n", scenario_id);
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.current_scenario_id = scenario_id;
+	spin_unlock(&imgsensor_drv_lock);
+	switch (scenario_id) {
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+			preview(image_window, sensor_config_data);
+			break;
+		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+			capture(image_window, sensor_config_data);
+			break;	
+		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+			normal_video(image_window, sensor_config_data);
+			break;	  
+		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+			hs_video(image_window, sensor_config_data);
+			break;
+		case MSDK_SCENARIO_ID_SLIM_VIDEO:
+			slim_video(image_window, sensor_config_data);
+			break;	  
+		default:
+			LOG_INF("Error ScenarioId setting");
+			preview(image_window, sensor_config_data);
+			return ERROR_INVALID_SCENARIO_ID;
+	}
+	return ERROR_NONE;
+}	/* control() */
+
+
+
+static kal_uint32 set_video_mode(UINT16 framerate)
+{
+	LOG_INF("framerate = %d\n ", framerate);
+	// SetVideoMode Function should fix framerate
+	if (framerate == 0)
+		// Dynamic frame rate
+		return ERROR_NONE;
+	spin_lock(&imgsensor_drv_lock);
+	if ((framerate == 30) && (imgsensor.autoflicker_en == KAL_TRUE))
+		imgsensor.current_fps = 296;
+	else if ((framerate == 15) && (imgsensor.autoflicker_en == KAL_TRUE))
+		imgsensor.current_fps = 146;
+	else
+		imgsensor.current_fps = 10 * framerate;
+	spin_unlock(&imgsensor_drv_lock);
+	set_max_framerate(imgsensor.current_fps);
+
+	return ERROR_NONE;
+}
+
+static kal_uint32 set_auto_flicker_mode(kal_bool enable, UINT16 framerate)
+{
+	LOG_INF("enable = %d, framerate = %d \n", enable, framerate);
+	spin_lock(&imgsensor_drv_lock);
+	if (enable) 	  
+		imgsensor.autoflicker_en = KAL_TRUE;
+	else //Cancel Auto flick
+		imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	return ERROR_NONE;
+}
+
+
+static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 framerate) 
+{
+	kal_int16 dummyLine;
+	kal_uint32 lineLength,frameHeight;
+  
+	LOG_INF("scenario_id = %d, framerate = %d\n", scenario_id, framerate);
+
+	switch (scenario_id) {
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+			frameHeight = (10 * imgsensor_info.pre.pclk) / framerate / imgsensor_info.pre.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = frameHeight - imgsensor_info.pre.framelength;
+			if (imgsensor.dummy_line < 0)
+				imgsensor.dummy_line = 0;
+			imgsensor.frame_length += imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			set_dummy();			
+			break;			
+		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+			frameHeight = (10 * imgsensor_info.normal_video.pclk) / framerate / imgsensor_info.normal_video.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = frameHeight - imgsensor_info.normal_video.framelength;
+			if (imgsensor.dummy_line < 0)
+				imgsensor.dummy_line = 0;			
+			imgsensor.frame_length += imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			set_dummy();			
+			break;
+		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+		//case MSDK_SCENARIO_ID_CAMERA_ZSD:			
+			frameHeight = (10 * imgsensor_info.cap.pclk) / framerate / imgsensor_info.cap.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = frameHeight - imgsensor_info.cap.framelength;
+			if (imgsensor.dummy_line < 0)
+				imgsensor.dummy_line = 0;
+			imgsensor.frame_length += imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			set_dummy();			
+			break;	
+		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+			frameHeight = (10 * imgsensor_info.hs_video.pclk) / framerate / imgsensor_info.hs_video.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = frameHeight - imgsensor_info.hs_video.framelength;
+			if (imgsensor.dummy_line < 0)
+				imgsensor.dummy_line = 0;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			set_dummy();			
+			break;
+		case MSDK_SCENARIO_ID_SLIM_VIDEO:
+			frameHeight = (10 * imgsensor_info.slim_video.pclk) / framerate / imgsensor_info.slim_video.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = frameHeight - imgsensor_info.slim_video.framelength;
+			if (imgsensor.dummy_line < 0)
+				imgsensor.dummy_line = 0;			
+			imgsensor.frame_length += imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			set_dummy();			
+		default:			
+			LOG_INF("error scenario_id = %d\n", scenario_id);
+			break;
+	}	
+	return ERROR_NONE;
+}
+
+
+static kal_uint32 get_default_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 *framerate) 
+{
+	LOG_INF("scenario_id = %d\n", scenario_id);
+
+	switch (scenario_id) {
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+			*framerate = imgsensor_info.pre.max_framerate;
+			break;
+		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+			*framerate = imgsensor_info.normal_video.max_framerate;
+			break;
+		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+			*framerate = imgsensor_info.cap.max_framerate;
+			break;		
+		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+			*framerate = imgsensor_info.hs_video.max_framerate;
+			break;
+		case MSDK_SCENARIO_ID_SLIM_VIDEO: 
+			*framerate = imgsensor_info.slim_video.max_framerate;
+			break;
+		default:
+			break;
+	}
+
+	return ERROR_NONE;
+}
+
+static kal_uint32 set_test_pattern_mode(kal_bool enable)
+{
+	LOG_INF("enable: %d\n", enable);
+
+	if (enable) {
+		// 0x5E00[8]: 1 enable,  0 disable
+		// 0x5E00[1:0]; 00 Color bar, 01 Random Data, 10 Square, 11 BLACK
+		write_cmos_sensor(0x5E00, 0x80);
+	} else {
+		// 0x5E00[8]: 1 enable,  0 disable
+		// 0x5E00[1:0]; 00 Color bar, 01 Random Data, 10 Square, 11 BLACK
+		write_cmos_sensor(0x5E00, 0x00);
+	}	 
+	return ERROR_NONE;
+}
+
+static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
+							 UINT8 *feature_para,UINT32 *feature_para_len)
+{
+	UINT16 *feature_return_para_16=(UINT16 *) feature_para;
+	UINT16 *feature_data_16=(UINT16 *) feature_para;
+	UINT32 *feature_return_para_32=(UINT32 *) feature_para;
+	UINT32 *feature_data_32=(UINT32 *) feature_para;
+    unsigned long long *feature_data=(unsigned long long *) feature_para;
+    unsigned long long *feature_return_para=(unsigned long long *) feature_para;
+	
+	SENSOR_WINSIZE_INFO_STRUCT *wininfo;	
+	MSDK_SENSOR_REG_INFO_STRUCT *sensor_reg_data=(MSDK_SENSOR_REG_INFO_STRUCT *) feature_para;
+ 
+	LOG_INF("feature_id = %d\n", feature_id);
+	switch (feature_id) {
+		case SENSOR_FEATURE_GET_PERIOD:
+			*feature_return_para_16++ = imgsensor.line_length;
+			*feature_return_para_16 = imgsensor.frame_length;
+			*feature_para_len=4;
+			break;
+		case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:	 
+			*feature_return_para_32 = imgsensor.pclk;
+			*feature_para_len=4;
+			break;		   
+		case SENSOR_FEATURE_SET_ESHUTTER:
+            set_shutter(*feature_data);
+            break;
+        case SENSOR_FEATURE_SET_NIGHTMODE:
+            night_mode((BOOL) *feature_data);
+            break;
+        case SENSOR_FEATURE_SET_GAIN:
+            set_gain((UINT16) *feature_data);
+			break;
+		case SENSOR_FEATURE_SET_FLASHLIGHT:
+			break;
+		case SENSOR_FEATURE_SET_ISP_MASTER_CLOCK_FREQ:
+			break;
+		case SENSOR_FEATURE_SET_REGISTER:
+			write_cmos_sensor(sensor_reg_data->RegAddr, sensor_reg_data->RegData);
+			break;
+		case SENSOR_FEATURE_GET_REGISTER:
+			sensor_reg_data->RegData = read_cmos_sensor(sensor_reg_data->RegAddr);
+			break;
+		case SENSOR_FEATURE_GET_LENS_DRIVER_ID:
+			// get the lens driver ID from EEPROM or just return LENS_DRIVER_ID_DO_NOT_CARE
+			// if EEPROM does not exist in camera module.
+			*feature_return_para_32=LENS_DRIVER_ID_DO_NOT_CARE;
+			*feature_para_len=4;
+			break;
+		case SENSOR_FEATURE_SET_VIDEO_MODE:
+            set_video_mode(*feature_data);
+			break; 
+		case SENSOR_FEATURE_CHECK_SENSOR_ID:
+			get_imgsensor_id(feature_return_para_32); 
+			break; 
+		case SENSOR_FEATURE_SET_AUTO_FLICKER_MODE:
+			set_auto_flicker_mode((BOOL)*feature_data_16,*(feature_data_16+1));
+			break;
+		case SENSOR_FEATURE_SET_MAX_FRAME_RATE_BY_SCENARIO:
+            set_max_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data, *(feature_data+1));
+            break;
+        case SENSOR_FEATURE_GET_DEFAULT_FRAME_RATE_BY_SCENARIO:
+            get_default_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*(feature_data), (MUINT32 *)(uintptr_t)(*(feature_data+1)));
+            break;
+        case SENSOR_FEATURE_SET_TEST_PATTERN:
+            set_test_pattern_mode((BOOL)*feature_data);
+			break;
+		case SENSOR_FEATURE_GET_TEST_PATTERN_CHECKSUM_VALUE: //for factory mode auto testing			 
+			*feature_return_para_32 = imgsensor_info.checksum_value;
+			*feature_para_len=4;							 
+			break;				
+		case SENSOR_FEATURE_SET_FRAMERATE:
+            LOG_INF("current fps :%d\n", (UINT32)*feature_data);
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.current_fps = *feature_data;
+            spin_unlock(&imgsensor_drv_lock);
+            break;
+        case SENSOR_FEATURE_SET_HDR:
+            LOG_INF("ihdr enable :%d\n", (BOOL)*feature_data);
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.ihdr_en = (BOOL)*feature_data;
+            spin_unlock(&imgsensor_drv_lock);
+            break;
+        case SENSOR_FEATURE_GET_CROP_INFO:
+            LOG_INF("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n", (UINT32)*feature_data);
+
+            wininfo = (SENSOR_WINSIZE_INFO_STRUCT *)(uintptr_t)(*(feature_data+1));
+		
+			switch (*feature_data_32) {
+				case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[1],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+					break;	  
+				case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[2],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+					break;
+				case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[3],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+					break;
+				case MSDK_SCENARIO_ID_SLIM_VIDEO:
+					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[4],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+					break;
+				case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+				default:
+					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[0],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+					break;
+			}
+		case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
+			break;
+            LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",(UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
+            ihdr_write_shutter_gain((UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
+			break;
+		default:
+			break;
+	}
+  
+	return ERROR_NONE;
+}	/*	feature_control()  */
+
+static SENSOR_FUNCTION_STRUCT sensor_func = {
+	open,
+	get_info,
+	get_resolution,
+	feature_control,
+	control,
+	close
+};
+
+UINT32 GC2235_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
+{
+	/* To Do : Check Sensor status here */
+	if (pfFunc!=NULL)
+		*pfFunc=&sensor_func;
+	return ERROR_NONE;
+}	/*	GC2235_MIPI_RAW_SensorInit	*/
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/gc2235_mipi_raw/gc2235mipi_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735/gc2235_mipi_raw/gc2235mipi_Sensor.h
new file mode 100755
index 0000000..74311f8
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735/gc2235_mipi_raw/gc2235mipi_Sensor.h
@@ -0,0 +1,120 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *	 GC2235mipi_Sensor.h
+ *
+ * Project:
+ * --------
+ *	 ALPS
+ *
+ * Description: 
+ * ------------
+ *	 CMOS sensor header file
+ *
+ ****************************************************************************/
+#ifndef _GC2235MIPI_SENSOR_H
+#define _GC2235MIPI_SENSOR_H
+
+
+typedef enum{
+	IMGSENSOR_MODE_INIT,
+	IMGSENSOR_MODE_PREVIEW,
+	IMGSENSOR_MODE_CAPTURE,
+	IMGSENSOR_MODE_VIDEO,
+	IMGSENSOR_MODE_HIGH_SPEED_VIDEO,
+	IMGSENSOR_MODE_SLIM_VIDEO,
+} IMGSENSOR_MODE;
+
+typedef struct imgsensor_mode_struct {
+	kal_uint32 pclk;				//record different mode's pclk
+	kal_uint32 linelength;			//record different mode's linelength
+	kal_uint32 framelength;			//record different mode's framelength
+
+	kal_uint8 startx;				//record different mode's startx of grabwindow
+	kal_uint8 starty;				//record different mode's startx of grabwindow
+
+	kal_uint16 grabwindow_width;	//record different mode's width of grabwindow
+	kal_uint16 grabwindow_height;	//record different mode's height of grabwindow
+
+	/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
+	kal_uint8 mipi_data_lp2hs_settle_dc;
+
+	/*	 following for GetDefaultFramerateByScenario()	*/
+	kal_uint16 max_framerate;
+	
+} imgsensor_mode_struct;
+
+/* SENSOR PRIVATE STRUCT FOR VARIABLES*/
+typedef struct imgsensor_struct {
+	kal_uint8 mirror;				//mirrorflip information
+
+	kal_uint8 sensor_mode;			//record IMGSENSOR_MODE enum value
+
+	kal_uint32 shutter;				//current shutter
+	kal_uint16 gain;				//current gain
+	
+	kal_uint32 pclk;				//current pclk
+
+	kal_uint32 frame_length;		//current framelength
+	kal_uint32 line_length;			//current linelength
+
+	kal_uint32 min_frame_length;	//current min  framelength to max framerate
+	kal_uint16 dummy_pixel;			//current dummypixel
+	kal_uint16 dummy_line;			//current dummline
+	
+	kal_uint16 current_fps;			//current max fps
+	kal_bool   autoflicker_en;		//record autoflicker enable or disable
+	MSDK_SCENARIO_ID_ENUM current_scenario_id;//current scenario id
+	kal_uint8  ihdr_en;				//ihdr enable or disable
+	
+	kal_uint8 i2c_write_id;			//record current sensor's i2c write id
+} imgsensor_struct;
+
+/* SENSOR PRIVATE STRUCT FOR CONSTANT*/
+typedef struct imgsensor_info_struct { 
+	kal_uint16 sensor_id;			//record sensor id defined in Kd_imgsensor.h
+	kal_uint32 checksum_value;		//checksum value for Camera Auto Test
+	imgsensor_mode_struct pre;		//preview scenario relative information
+	imgsensor_mode_struct cap;		//capture scenario relative information
+	imgsensor_mode_struct cap1;		//capture for PIP 24fps relative information
+	imgsensor_mode_struct normal_video;//normal video  scenario relative information
+	imgsensor_mode_struct hs_video;	//high speed video scenario relative information
+	imgsensor_mode_struct slim_video;	//slim video for VT scenario relative information
+	
+	kal_uint8  ae_shut_delay_frame;	//shutter delay frame for AE cycle
+	kal_uint8  ae_sensor_gain_delay_frame;	//sensor gain delay frame for AE cycle
+	kal_uint8  ae_ispGain_delay_frame;	//isp gain delay frame for AE cycle
+	kal_uint8  ihdr_support;		//1, support; 0,not support
+	kal_uint8  ihdr_le_firstline;	//1,le first ; 0, se first
+	kal_uint8  sensor_mode_num;		//support sensor mode num
+	
+	kal_uint8  cap_delay_frame;		//enter capture delay frame num
+	kal_uint8  pre_delay_frame;		//enter preview delay frame num
+	kal_uint8  video_delay_frame;	//enter video delay frame num
+	kal_uint8  hs_video_delay_frame;	//enter high speed video  delay frame num
+	kal_uint8  slim_video_delay_frame;	//enter slim video delay frame num
+  
+	kal_uint8  margin;				//sensor framelength & shutter margin 
+	kal_uint32 min_shutter;			//min shutter
+	kal_uint32 max_frame_length;	//max framelength by sensor register's limitation
+
+	kal_uint8  isp_driving_current;	//mclk driving current
+	kal_uint8  sensor_interface_type;//sensor_interface_type
+	kal_uint8  sensor_output_dataformat;
+	kal_uint8  mclk;				//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
+	
+	kal_uint8  mipi_lane_num;		//mipi lane num
+	kal_uint8  i2c_addr_table[5];	//record sensor support all write id addr, only supprt 4must end with 0xff
+} imgsensor_info_struct;
+
+/* SENSOR READ/WRITE ID */
+//#define IMGSENSOR_WRITE_ID_1 (0x6c)
+//#define IMGSENSOR_READ_ID_1  (0x6d)
+//#define IMGSENSOR_WRITE_ID_2 (0x20)
+//#define IMGSENSOR_READ_ID_2  (0x21)
+
+extern int iReadRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u8 * a_pRecvData, u16 a_sizeRecvData, u16 i2cId);
+extern int iWriteRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u16 i2cId);
+extern int iWriteReg(u16 a_u2Addr , u32 a_u4Data , u32 a_u4Bytes , u16 i2cId); 
+#endif 
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/gc2355_mipi_raw/gc2355mipi_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735/gc2355_mipi_raw/gc2355mipi_Sensor.c
old mode 100644
new mode 100755
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/gc2755_mipi_raw/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6735/gc2755_mipi_raw/Makefile
new file mode 100755
index 0000000..ee16038
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735/gc2755_mipi_raw/Makefile
@@ -0,0 +1,4 @@
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+obj-y += gc2755mipi_Sensor.o
+
+
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/gc2755_mipi_raw/gc2755mipi_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735/gc2755_mipi_raw/gc2755mipi_Sensor.c
new file mode 100755
index 0000000..c15384b
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735/gc2755_mipi_raw/gc2755mipi_Sensor.c
@@ -0,0 +1,1406 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *     GC2755mipi_Sensor.c
+ *
+ * Project:
+ * --------
+ *     ALPS
+ *
+ * Description:
+ * ------------
+ *     Source code of Sensor driver
+ *
+ *
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *============================================================================
+ ****************************************************************************/
+
+#include <linux/videodev2.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <asm/atomic.h>
+#include <linux/xlog.h>
+
+#include "kd_camera_hw.h"
+#include "kd_imgsensor.h"
+#include "kd_imgsensor_define.h"
+#include "kd_imgsensor_errcode.h"
+
+#include "gc2755mipi_Sensor.h"
+
+/****************************Modify Following Strings for Debug****************************/
+#define PFX "GC2755_camera_sensor"
+#define LOG_1 LOG_INF("GC2755,MIPI 2LANE\n")
+#define LOG_2 LOG_INF("preview 1920*1080@30fps,864Mbps/lane; video 1920*1080@30fps,864Mbps/lane; capture 1920*1080@30fps,864Mbps/lane\n")
+/****************************   Modify end    *******************************************/
+
+#define LOG_INF(format, args...)    xlog_printk(ANDROID_LOG_INFO   , PFX, "[%s] " format, __FUNCTION__, ##args)
+
+static DEFINE_SPINLOCK(imgsensor_drv_lock);
+
+
+static imgsensor_info_struct imgsensor_info = {
+    .sensor_id = GC2755_SENSOR_ID,        //record sensor id defined in Kd_imgsensor.h
+
+    .checksum_value = 0xf7375923,        //checksum value for Camera Auto Test
+
+    .pre = {
+        .pclk = 42000000,                //record different mode's pclk
+        .linelength = 1772,                //record different mode's linelength
+        .framelength = 1185,            //record different mode's framelength
+        .startx = 2,                    //record different mode's startx of grabwindow
+        .starty = 2,                    //record different mode's starty of grabwindow
+        .grabwindow_width = 1912,        //record different mode's width of grabwindow
+        .grabwindow_height = 1074,        //record different mode's height of grabwindow
+        /*     following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario    */
+        .mipi_data_lp2hs_settle_dc = 14,//unit , ns
+        /*     following for GetDefaultFramerateByScenario()    */
+        .max_framerate = 200,
+    },
+    .cap = {
+        .pclk = 42000000,
+        .linelength = 1772,
+        .framelength = 1185,
+        .startx = 2,
+        .starty = 2,
+        .grabwindow_width = 1912,
+        .grabwindow_height = 1074,
+        .mipi_data_lp2hs_settle_dc = 14,
+        .max_framerate = 200,
+    },
+    .cap1 = {                            //capture for PIP 24fps relative information, capture1 mode must use same framelength, linelength with Capture mode for shutter calculate
+        .pclk = 42000000,
+        .linelength = 1772,
+        .framelength = 1185,
+        .startx = 2,
+        .starty = 2,
+        .grabwindow_width = 1912,
+        .grabwindow_height = 1074,
+        .mipi_data_lp2hs_settle_dc = 14,
+        .max_framerate = 200,    //less than 13M(include 13M),cap1 max framerate is 24fps,16M max framerate is 20fps, 20M max framerate is 15fps
+    },
+    .normal_video = {
+        .pclk = 42000000,
+        .linelength = 1772,
+        .framelength = 1185,
+        .startx = 2,
+        .starty = 2,
+        .grabwindow_width = 1912,
+        .grabwindow_height = 1074,
+        .mipi_data_lp2hs_settle_dc = 14,//unit , ns
+        .max_framerate = 200,
+    },
+    .hs_video = {
+        .pclk = 42000000,
+        .linelength = 1772,
+        .framelength = 1185,
+        .startx = 2,
+        .starty = 2,
+        .grabwindow_width = 1912,
+        .grabwindow_height = 1074,
+        .mipi_data_lp2hs_settle_dc = 14,//unit , ns
+        .max_framerate = 1200,
+    },
+    .slim_video = {
+        .pclk = 42000000,
+        .linelength = 1772,
+        .framelength = 1185,
+        .startx = 2,
+        .starty = 2,
+        .grabwindow_width = 1912,
+        .grabwindow_height = 1074,
+        .mipi_data_lp2hs_settle_dc = 14,//unit , ns
+        .max_framerate = 200,
+    },
+    .margin = 0,            //sensor framelength & shutter margin
+    .min_shutter = 12,        //min shutter
+    .max_frame_length = 0x3fff,//max framelength by sensor register's limitation
+    .ae_shut_delay_frame = 0,    //shutter delay frame for AE cycle, 2 frame with ispGain_delay-shut_delay=2-0=2
+    .ae_sensor_gain_delay_frame = 0,//sensor gain delay frame for AE cycle,2 frame with ispGain_delay-sensor_gain_delay=2-0=2
+    .ae_ispGain_delay_frame = 2,//isp gain delay frame for AE cycle
+    .ihdr_support = 0,      //1, support; 0,not support
+    .ihdr_le_firstline = 0,  //1,le first ; 0, se first
+    .sensor_mode_num = 3,      //support sensor mode num
+
+    .cap_delay_frame = 2,        //enter capture delay frame num
+    .pre_delay_frame = 2,         //enter preview delay frame num
+    .video_delay_frame = 2,        //enter video delay frame num
+    .hs_video_delay_frame = 2,    //enter high speed video  delay frame num
+    .slim_video_delay_frame = 2,//enter slim video delay frame num
+
+    .isp_driving_current = ISP_DRIVING_6MA, //mclk driving current
+    .sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,//sensor_interface_type
+    .mipi_sensor_type = MIPI_OPHY_NCSI2, //0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2
+    .mipi_settle_delay_mode = MIPI_SETTLEDELAY_AUTO,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
+    .sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_B,//sensor output first pixel color
+    .mclk = 24,//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
+    .mipi_lane_num = SENSOR_MIPI_2_LANE,//mipi lane num
+    .i2c_addr_table = {0x78, 0xff},//record sensor support all write id addr, only supprt 4must end with 0xff
+};
+
+
+static imgsensor_struct imgsensor = {
+    .mirror = IMAGE_NORMAL,                //mirrorflip information
+    .sensor_mode = IMGSENSOR_MODE_INIT, //IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
+    .shutter = 0x3ED,                    //current shutter
+    .gain = 0x40,                        //current gain
+    .dummy_pixel = 0,                    //current dummypixel
+    .dummy_line = 0,                    //current dummyline
+    .current_fps = 300,  //full size current fps : 24fps for PIP, 30fps for Normal or ZSD
+    .autoflicker_en = KAL_FALSE,  //auto flicker enable: KAL_FALSE for disable auto flicker, KAL_TRUE for enable auto flicker
+    .test_pattern = KAL_FALSE,        //test pattern mode or not. KAL_FALSE for in test pattern mode, KAL_TRUE for normal output
+    .current_scenario_id = MSDK_SCENARIO_ID_CAMERA_PREVIEW,//current scenario id
+    .ihdr_en = 0, //sensor need support LE, SE with HDR feature
+    .i2c_write_id = 0x78,//record current sensor's i2c write id
+};
+
+
+/* Sensor output window information */
+static SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[5] =
+{
+	{ 1920, 1080,	 0,    0, 1920, 1080, 1920,  1080, 0000, 0000, 1920,  1080, 	 0,    0, 1920,  1080}, // Preview 
+	{ 1920, 1080,	 0,    0, 1920, 1080, 1920,  1080, 0000, 0000, 1920,  1080, 	 0,    0, 1920,  1080}, // capture 
+	{ 1920, 1080,	 0,    0, 1920, 1080, 1920,  1080, 0000, 0000, 1920,  1080, 	 0,    0, 1920,  1080}, // video 
+	{ 1920, 1080,	 0,    0, 1920, 1080, 1920,  1080, 0000, 0000, 1920,  1080, 	 0,    0, 1920,  1080}, //hight speed video 
+	{ 1920, 1080,	 0,    0, 1920, 1080, 1920,  1080, 0000, 0000, 1920,  1080, 	 0,    0, 1920,  1080}};// slim video 
+
+
+
+static kal_uint16 read_cmos_sensor(kal_uint32 addr)
+{
+	kal_uint16 get_byte=0;
+
+	char pu_send_cmd[1] = {(char)(addr & 0xFF) };
+	iReadRegI2C(pu_send_cmd, 1, (u8*)&get_byte, 1, imgsensor.i2c_write_id);
+
+	return get_byte;
+
+}
+
+static void write_cmos_sensor(kal_uint32 addr, kal_uint32 para)
+{
+#if 1
+		char pu_send_cmd[2] = {(char)(addr & 0xFF), (char)(para & 0xFF)};
+		iWriteRegI2C(pu_send_cmd, 2, imgsensor.i2c_write_id);
+#else
+		iWriteReg((u16)addr, (u32)para, 2, imgsensor.i2c_write_id);
+#endif
+
+}
+
+static void set_dummy()
+{
+ 	kal_uint32 hb = 0;
+	kal_uint32 vb = 0;	
+	LOG_INF("dummyline = %d, dummypixels = %d \n", imgsensor.dummy_line, imgsensor.dummy_pixel);
+
+//  modify by yfx
+	hb = imgsensor.dummy_pixel + GC2755_DEFAULT_DUMMY_PIXEL_NUMS;
+	vb = imgsensor.dummy_line + GC2755_DEFAULT_DUMMY_LINE_NUMS;
+
+	
+	//Set HB
+	write_cmos_sensor(0x05, (hb >> 8)& 0xFF);
+	write_cmos_sensor(0x06, hb & 0xFF);
+
+	//Set VB
+	write_cmos_sensor(0x07, (vb >> 8) & 0xFF);
+	write_cmos_sensor(0x08, vb & 0xFF);
+
+//  end	
+}    /*    set_dummy  */
+
+static kal_uint32 return_sensor_id()
+{
+    return ((read_cmos_sensor(0xf0) << 8) | read_cmos_sensor(0xf1));
+}
+static void set_max_framerate(UINT16 framerate,kal_bool min_framelength_en)
+{
+    kal_int16 dummy_line;
+    kal_uint32 frame_length = imgsensor.frame_length;
+    //unsigned long flags;
+
+    LOG_INF("framerate = %d, min framelength should enable? \n", framerate,min_framelength_en);
+
+    frame_length = imgsensor.pclk / framerate * 10 / imgsensor.line_length;
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.frame_length = (frame_length > imgsensor.min_frame_length) ? frame_length : imgsensor.min_frame_length;
+    imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
+    //dummy_line = frame_length - imgsensor.min_frame_length;
+    //if (dummy_line < 0)
+        //imgsensor.dummy_line = 0;
+    //else
+        //imgsensor.dummy_line = dummy_line;
+    //imgsensor.frame_length = frame_length + imgsensor.dummy_line;
+    if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+    {
+        imgsensor.frame_length = imgsensor_info.max_frame_length;
+        imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
+    }
+    if (min_framelength_en)
+        imgsensor.min_frame_length = imgsensor.frame_length;
+    spin_unlock(&imgsensor_drv_lock);
+    set_dummy();
+}    /*    set_max_framerate  */
+
+
+
+/*************************************************************************
+* FUNCTION
+*    set_shutter
+*
+* DESCRIPTION
+*    This function set e-shutter of sensor to change exposure time.
+*
+* PARAMETERS
+*    iShutter : exposured lines
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static void set_shutter(kal_uint16 shutter)
+{
+    unsigned long flags;
+    kal_uint16 realtime_fps = 0;
+    kal_uint32 frame_length = 0;
+    spin_lock_irqsave(&imgsensor_drv_lock, flags);
+    imgsensor.shutter = shutter;
+    spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
+
+    //write_shutter(shutter);
+    /* 0x3500, 0x3501, 0x3502 will increase VBLANK to get exposure larger than frame exposure */
+    /* AE doesn't update sensor gain at capture mode, thus extra exposure lines must be updated here. */
+
+    // OV Recommend Solution
+    // if shutter bigger than frame_length, should extend frame length first
+    spin_lock(&imgsensor_drv_lock);
+    if (shutter > imgsensor.min_frame_length - imgsensor_info.margin)
+        imgsensor.frame_length = shutter + imgsensor_info.margin;
+    else
+        imgsensor.frame_length = imgsensor.min_frame_length;
+    if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+        imgsensor.frame_length = imgsensor_info.max_frame_length;
+    spin_unlock(&imgsensor_drv_lock);
+    shutter = (shutter < imgsensor_info.min_shutter) ? imgsensor_info.min_shutter : shutter;
+    shutter = (shutter > (imgsensor_info.max_frame_length - imgsensor_info.margin)) ? (imgsensor_info.max_frame_length - imgsensor_info.margin) : shutter;
+
+	// Update Shutter
+	if(shutter > 16383) shutter = 16383;
+	if(shutter < 12) shutter = 12;
+	write_cmos_sensor(0x03, (shutter>>8) & 0x3F);
+	write_cmos_sensor(0x04, shutter & 0xFF);
+
+    LOG_INF("Exit! shutter =%d, framelength =%d\n", shutter,imgsensor.frame_length);
+
+}    /*    set_shutter */
+
+
+
+static kal_uint16 gain2reg(const kal_uint16 gain)
+{
+    kal_uint16 reg_gain = 0x0000;
+
+    reg_gain = ((gain / BASEGAIN) << 4) + ((gain % BASEGAIN) * 16 / BASEGAIN);
+    reg_gain = reg_gain & 0xFFFF;
+    return (kal_uint16)reg_gain;
+}
+
+/*************************************************************************
+* FUNCTION
+*    set_gain
+*
+* DESCRIPTION
+*    This function is to set global gain to sensor.
+*
+* PARAMETERS
+*    iGain : sensor global gain(base: 0x40)
+*
+* RETURNS
+*    the actually gain set to sensor.
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint16 set_gain(kal_uint16 gain)
+{
+#define ANALOG_GAIN_1 64  // 1.00x
+#define ANALOG_GAIN_2 86  // 1.35x
+#define ANALOG_GAIN_3 117  // 1.83x
+#define ANALOG_GAIN_4 159  // 2.48x
+#define ANALOG_GAIN_5 223  // 3.49x
+#define ANALOG_GAIN_6 307  // 4.80x
+#define ANALOG_GAIN_7 428  // 6.68x
+			
+	kal_uint16 iReg,temp,temp1; 	
+
+	write_cmos_sensor(0xb1, 0x01);
+	write_cmos_sensor(0xb2, 0x00);
+	
+	iReg = gain;
+	
+	if(iReg < 0x40)
+		iReg = 0x40;
+	if(iReg > 512)
+		iReg = 512;
+		
+	if((ANALOG_GAIN_1<= iReg)&&(iReg < ANALOG_GAIN_2))
+	{
+			//analog gain
+			write_cmos_sensor(0xb6, 0x00);// 
+			temp = iReg;
+			write_cmos_sensor(0xb1, temp>>6);
+			write_cmos_sensor(0xb2, (temp<<2)&0xfc);
+			LOG_INF("GC2755 analogic gain 1x , GC2755 add pregain = %d\n",temp);
+		
+	}
+	else if((ANALOG_GAIN_2<= iReg)&&(iReg < ANALOG_GAIN_3))
+	{
+			//analog gain
+			write_cmos_sensor(0xb6, 0x01);// 
+			temp = 64*iReg/ANALOG_GAIN_2;
+			write_cmos_sensor(0xb1, temp>>6);
+			write_cmos_sensor(0xb2, (temp<<2)&0xfc);
+			LOG_INF("GC2755 analogic gain 1.45x , GC2755 add pregain = %d\n",temp);
+		
+	}
+	
+	else if((ANALOG_GAIN_3<= iReg)&&(iReg < ANALOG_GAIN_4))
+	{
+			//analog gain
+			write_cmos_sensor(0xb6, 0x02);//
+			temp = 64*iReg/ANALOG_GAIN_3;
+			write_cmos_sensor(0xb1, temp>>6);
+			write_cmos_sensor(0xb2, (temp<<2)&0xfc);
+			LOG_INF("GC2755 analogic gain 2.02x , GC2755 add pregain = %d\n",temp); 
+	}
+	
+//	else if(ANALOG_GAIN_4<= iReg)
+	else
+	{
+			//analog gain
+			write_cmos_sensor(0xb6, 0x03);//
+			temp = 64*iReg/ANALOG_GAIN_4;
+			write_cmos_sensor(0xb1, temp>>6);
+			write_cmos_sensor(0xb2, (temp<<2)&0xfc);
+			
+			LOG_INF("GC2755 analogic gain 2.8x, temp = %d\n", temp);
+	}
+
+	
+	return gain;
+
+}    /*    set_gain  */
+
+static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gain)
+{
+    LOG_INF("le:0x%x, se:0x%x, gain:0x%x\n",le,se,gain);
+#if 0
+    if (imgsensor.ihdr_en) {
+
+        spin_lock(&imgsensor_drv_lock);
+        if (le > imgsensor.min_frame_length - imgsensor_info.margin)
+            imgsensor.frame_length = le + imgsensor_info.margin;
+        else
+            imgsensor.frame_length = imgsensor.min_frame_length;
+        if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+            imgsensor.frame_length = imgsensor_info.max_frame_length;
+        spin_unlock(&imgsensor_drv_lock);
+        if (le < imgsensor_info.min_shutter) le = imgsensor_info.min_shutter;
+        if (se < imgsensor_info.min_shutter) se = imgsensor_info.min_shutter;
+
+
+        // Extend frame length first
+        write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
+        write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
+
+        write_cmos_sensor(0x3502, (le << 4) & 0xFF);
+        write_cmos_sensor(0x3501, (le >> 4) & 0xFF);
+        write_cmos_sensor(0x3500, (le >> 12) & 0x0F);
+
+        write_cmos_sensor(0x3508, (se << 4) & 0xFF);
+        write_cmos_sensor(0x3507, (se >> 4) & 0xFF);
+        write_cmos_sensor(0x3506, (se >> 12) & 0x0F);
+
+        set_gain(gain);
+    }
+#endif
+}
+
+
+
+static void set_mirror_flip(kal_uint8 image_mirror)
+{
+	LOG_INF("image_mirror = %d\n", image_mirror);
+	
+	switch (image_mirror)
+	{
+		case IMAGE_NORMAL://IMAGE_NORMAL:
+			write_cmos_sensor(0x17,0x14);//bit[1][0]
+	//		write_cmos_sensor(0x92,0x03);
+	//		write_cmos_sensor(0x94,0x0b);
+			break;
+		case IMAGE_H_MIRROR://IMAGE_H_MIRROR:
+			write_cmos_sensor(0x17,0x15);
+	//		GC2755_write_cmos_sensor(0x92,0x03);
+	//		GC2755_write_cmos_sensor(0x94,0x0b);
+			break;
+		case IMAGE_V_MIRROR://IMAGE_V_MIRROR:
+			write_cmos_sensor(0x17,0x16);
+	//		GC2755_write_cmos_sensor(0x92,0x02);
+	//		GC2755_write_cmos_sensor(0x94,0x0b);
+			break;
+		case IMAGE_HV_MIRROR://IMAGE_HV_MIRROR:
+			write_cmos_sensor(0x17,0x17);
+	//		GC2755_write_cmos_sensor(0x92,0x02);
+	//		GC2755_write_cmos_sensor(0x94,0x0b);
+			break;
+	}
+
+
+}
+
+/*************************************************************************
+* FUNCTION
+*    night_mode
+*
+* DESCRIPTION
+*    This function night mode of sensor.
+*
+* PARAMETERS
+*    bEnable: KAL_TRUE -> enable night mode, otherwise, disable night mode
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static void night_mode(kal_bool enable)
+{
+/*No Need to implement this function*/
+}    /*    night_mode    */
+
+static void sensor_init(void)
+{
+	LOG_INF("E");
+	/////////////////////////////////////////////////////
+	//////////////////////   SYS   //////////////////////
+	/////////////////////////////////////////////////////
+	write_cmos_sensor(0xfe, 0x80);
+	write_cmos_sensor(0xfe, 0x80);
+	write_cmos_sensor(0xfe, 0x80);
+	write_cmos_sensor(0xf6, 0x00);
+	write_cmos_sensor(0xf7, 0x31);
+	write_cmos_sensor(0xf8, 0x06);
+	write_cmos_sensor(0xf9, 0x2e);
+	write_cmos_sensor(0xfa, 0x00);
+	write_cmos_sensor(0xfc, 0x06);
+	write_cmos_sensor(0xfe, 0x00);
+
+	/////////////////////////////////////////////////////
+	////////////////     ANALOG & CISCTL   ////////////////
+	/////////////////////////////////////////////////////
+	write_cmos_sensor(0x03, 0x03);
+	write_cmos_sensor(0x04, 0xed); 
+	write_cmos_sensor(0x05, 0x03);
+	write_cmos_sensor(0x06, 0x12);
+	write_cmos_sensor(0x07, 0x00);
+	write_cmos_sensor(0x08, 0x49);
+	write_cmos_sensor(0x0a, 0x00);
+	write_cmos_sensor(0x0c, 0x04);
+	write_cmos_sensor(0x0d, 0x04);
+	write_cmos_sensor(0x0e, 0x48);
+	write_cmos_sensor(0x0f, 0x07);
+	write_cmos_sensor(0x10, 0x90);
+	write_cmos_sensor(0x11, 0x00);
+	write_cmos_sensor(0x12, 0x0e);
+	write_cmos_sensor(0x13, 0x11);
+	write_cmos_sensor(0x14, 0x01);
+	write_cmos_sensor(0x17, 0x15);
+	write_cmos_sensor(0x19, 0x08);
+	write_cmos_sensor(0x1b, 0x4f);
+	write_cmos_sensor(0x1c, 0x11);
+	write_cmos_sensor(0x1d, 0x10);
+	write_cmos_sensor(0x1e, 0xcc);
+	write_cmos_sensor(0x1f, 0xc9);
+	write_cmos_sensor(0x20, 0x71);
+	write_cmos_sensor(0x21, 0x20);
+	write_cmos_sensor(0x22, 0xd0);
+	write_cmos_sensor(0x23, 0x51);
+	write_cmos_sensor(0x24, 0x19);
+	write_cmos_sensor(0x27, 0x20);
+	write_cmos_sensor(0x28, 0x00);
+	write_cmos_sensor(0x2b, 0x81);
+	write_cmos_sensor(0x2c, 0x38);
+	write_cmos_sensor(0x2e, 0x1f);
+	write_cmos_sensor(0x2f, 0x14);
+	write_cmos_sensor(0x30, 0x00);
+	write_cmos_sensor(0x31, 0x01);
+	write_cmos_sensor(0x32, 0x02);
+	write_cmos_sensor(0x33, 0x03);
+	write_cmos_sensor(0x34, 0x07);
+	write_cmos_sensor(0x35, 0x0b);
+	write_cmos_sensor(0x36, 0x0f);
+
+	/////////////////////////////////////////////////////
+	//////////////////////   gain   /////////////////////
+	/////////////////////////////////////////////////////
+	write_cmos_sensor(0xb0, 0x56);
+	write_cmos_sensor(0xb1, 0x01);
+	write_cmos_sensor(0xb2, 0x00);
+	write_cmos_sensor(0xb3, 0x40);
+	write_cmos_sensor(0xb4, 0x40);
+	write_cmos_sensor(0xb5, 0x40);
+	write_cmos_sensor(0xb6, 0x00);
+
+	////////////////////////////////////////////////////
+	/////////////////////   crop   /////////////////////
+	////////////////////////////////////////////////////
+	write_cmos_sensor(0x92, 0x05);
+	write_cmos_sensor(0x94, 0x08);
+	write_cmos_sensor(0x95, 0x04);
+	write_cmos_sensor(0x96, 0x38);
+	write_cmos_sensor(0x97, 0x07);
+	write_cmos_sensor(0x98, 0x80); //out window set 1920x1080
+
+	////////////////////////////////////////////////////
+	/////////////////////  BLK   /////////////////////
+	////////////////////////////////////////////////////
+	write_cmos_sensor(0x18, 0x12);
+	write_cmos_sensor(0x1a, 0x01);
+	write_cmos_sensor(0x40, 0x42);
+	write_cmos_sensor(0x41, 0x00);
+	write_cmos_sensor(0x4e, 0x3c);
+	write_cmos_sensor(0x4f, 0x00);
+	write_cmos_sensor(0x5e, 0x00);
+	write_cmos_sensor(0x66, 0x20);
+	write_cmos_sensor(0x6a, 0x00);
+	write_cmos_sensor(0x6b, 0x00);
+	write_cmos_sensor(0x6c, 0x00);
+	write_cmos_sensor(0x6d, 0x00);
+	write_cmos_sensor(0x6e, 0x00);
+	write_cmos_sensor(0x6f, 0x00);
+	write_cmos_sensor(0x70, 0x00);
+	write_cmos_sensor(0x71, 0x00);
+
+	////////////////////////////////////////////////////
+	///////////////////// dark sun   /////////////////////
+	////////////////////////////////////////////////////
+	write_cmos_sensor(0x87, 0x03);
+	write_cmos_sensor(0xe5, 0x27);
+	write_cmos_sensor(0xe7, 0x53);
+	write_cmos_sensor(0xe8, 0xff);
+	write_cmos_sensor(0xe9, 0x3f);
+
+	////////////////////////////////////////////////////
+	/////////////////////   MIPI   /////////////////////
+	////////////////////////////////////////////////////
+	write_cmos_sensor(0xfe, 0x03);
+	write_cmos_sensor(0x01, 0x87);
+	write_cmos_sensor(0x02, 0x00);
+	write_cmos_sensor(0x03, 0x10);
+	write_cmos_sensor(0x04, 0x01);
+	write_cmos_sensor(0x05, 0x00);
+	write_cmos_sensor(0x06, 0xa2);
+	//write_cmos_sensor(0x10, 0x91);
+	write_cmos_sensor(0x11, 0x2b);
+	write_cmos_sensor(0x12, 0x60);
+	write_cmos_sensor(0x13, 0x09);
+	write_cmos_sensor(0x15, 0x62);
+	write_cmos_sensor(0x20, 0x40);
+	write_cmos_sensor(0x21, 0x10);
+	write_cmos_sensor(0x22, 0x02);
+	write_cmos_sensor(0x23, 0x20);
+	write_cmos_sensor(0x24, 0x02);
+	write_cmos_sensor(0x25, 0x10);
+	write_cmos_sensor(0x26, 0x04);
+	write_cmos_sensor(0x27, 0x06);
+	write_cmos_sensor(0x29, 0x02);
+	write_cmos_sensor(0x2a, 0x08);
+	write_cmos_sensor(0x2b, 0x04);
+	write_cmos_sensor(0xfe, 0x00);
+}    /*    sensor_init  */
+
+
+static void preview_setting(void)
+{
+	LOG_INF("E!\n");
+	//MIPI//
+	write_cmos_sensor(0xfe,0x03);
+	write_cmos_sensor(0x10,0x91);
+	write_cmos_sensor(0xfe,0x00);	
+	
+}    /*    preview_setting  */
+
+static void capture_setting(kal_uint16 currefps)
+{
+	LOG_INF("E! currefps:%d\n",currefps);
+	if (currefps == 240) { //24fps for PIP
+		//max 24fps //
+		  // AEC&frame length//
+		  write_cmos_sensor(0xfe,0x00);
+
+	} else {   //30fps			//30fps for Normal capture & ZSD
+		// max 30fps//
+		  // AEC&frame length//
+		   write_cmos_sensor(0xfe,0x00);		
+	}
+		
+}
+
+
+static void normal_video_setting(kal_uint16 currefps)
+{
+	LOG_INF("E! currefps:%d\n",currefps);
+	
+	// AEC&frame length//
+	 write_cmos_sensor(0xfe,0x00);
+		
+}
+
+static void hs_video_setting()
+{
+    LOG_INF("E\n");
+}
+
+static void slim_video_setting()
+{
+    LOG_INF("E\n");
+}
+
+static kal_uint32 set_test_pattern_mode(kal_bool enable)
+{
+    LOG_INF("enable: %d\n", enable);
+
+    if (enable) {
+        write_cmos_sensor(0xfe, 0x00);
+    } else {
+        write_cmos_sensor(0xfe, 0x00);
+    }
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.test_pattern = enable;
+    spin_unlock(&imgsensor_drv_lock);
+    return ERROR_NONE;
+}
+
+/*************************************************************************
+* FUNCTION
+*    get_imgsensor_id
+*
+* DESCRIPTION
+*    This function get the sensor ID
+*
+* PARAMETERS
+*    *sensorID : return the sensor ID
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 get_imgsensor_id(UINT32 *sensor_id)
+{
+    kal_uint8 i = 0;
+    kal_uint8 retry = 2;
+    //sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
+    while (imgsensor_info.i2c_addr_table[i] != 0xff) {
+        spin_lock(&imgsensor_drv_lock);
+        imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
+        spin_unlock(&imgsensor_drv_lock);
+        do {
+            *sensor_id = return_sensor_id();
+            if (*sensor_id == imgsensor_info.sensor_id) {
+                LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
+                return ERROR_NONE;
+            }
+            LOG_INF("Read sensor id fail, write id: 0x%x, id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
+            retry--;
+        } while(retry > 0);
+        i++;
+        retry = 2;
+    }
+    if (*sensor_id != imgsensor_info.sensor_id) {
+        // if Sensor ID is not correct, Must set *sensor_id to 0xFFFFFFFF
+        *sensor_id = 0xFFFFFFFF;
+        return ERROR_SENSOR_CONNECT_FAIL;
+    }
+    return ERROR_NONE;
+}
+
+
+/*************************************************************************
+* FUNCTION
+*    open
+*
+* DESCRIPTION
+*    This function initialize the registers of CMOS sensor
+*
+* PARAMETERS
+*    None
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 open(void)
+{
+    kal_uint8 i = 0;
+    kal_uint8 retry = 2;
+    kal_uint32 sensor_id = 0;
+    LOG_1;
+    LOG_2;
+    //sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
+    while (imgsensor_info.i2c_addr_table[i] != 0xff) {
+        spin_lock(&imgsensor_drv_lock);
+        imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
+        spin_unlock(&imgsensor_drv_lock);
+        do {
+            sensor_id = return_sensor_id();
+            if (sensor_id == imgsensor_info.sensor_id) {
+                LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
+                break;
+            }
+            LOG_INF("Read sensor id fail, write id: 0x%x, id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
+            retry--;
+        } while(retry > 0);
+        i++;
+        if (sensor_id == imgsensor_info.sensor_id)
+            break;
+        retry = 2;
+    }
+    if (imgsensor_info.sensor_id != sensor_id)
+        return ERROR_SENSOR_CONNECT_FAIL;
+
+    /* initail sequence write in  */
+    sensor_init();
+
+    spin_lock(&imgsensor_drv_lock);
+
+    imgsensor.autoflicker_en= KAL_FALSE;
+    imgsensor.sensor_mode = IMGSENSOR_MODE_INIT;
+    imgsensor.pclk = imgsensor_info.pre.pclk;
+    imgsensor.frame_length = imgsensor_info.pre.framelength;
+    imgsensor.line_length = imgsensor_info.pre.linelength;
+    imgsensor.min_frame_length = imgsensor_info.pre.framelength;
+    imgsensor.dummy_pixel = 0;
+    imgsensor.dummy_line = 0;
+    imgsensor.ihdr_en = 0;
+    imgsensor.test_pattern = KAL_FALSE;
+    imgsensor.current_fps = imgsensor_info.pre.max_framerate;
+    spin_unlock(&imgsensor_drv_lock);
+
+    return ERROR_NONE;
+}    /*    open  */
+
+
+
+/*************************************************************************
+* FUNCTION
+*    close
+*
+* DESCRIPTION
+*
+*
+* PARAMETERS
+*    None
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 close(void)
+{
+    LOG_INF("E\n");
+
+    /*No Need to implement this function*/
+
+    return ERROR_NONE;
+}    /*    close  */
+
+
+/*************************************************************************
+* FUNCTION
+* preview
+*
+* DESCRIPTION
+*    This function start the sensor preview.
+*
+* PARAMETERS
+*    *image_window : address pointer of pixel numbers in one period of HSYNC
+*  *sensor_config_data : address pointer of line numbers in one period of VSYNC
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_PREVIEW;
+    imgsensor.pclk = imgsensor_info.pre.pclk;
+    //imgsensor.video_mode = KAL_FALSE;
+    imgsensor.line_length = imgsensor_info.pre.linelength;
+    imgsensor.frame_length = imgsensor_info.pre.framelength;
+    imgsensor.min_frame_length = imgsensor_info.pre.framelength;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    preview_setting();
+	//set_mirror_flip(sensor_config_data->SensorImageMirror);
+    return ERROR_NONE;
+}    /*    preview   */
+
+/*************************************************************************
+* FUNCTION
+*    capture
+*
+* DESCRIPTION
+*    This function setup the CMOS sensor in capture MY_OUTPUT mode
+*
+* PARAMETERS
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                          MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+	
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_CAPTURE;
+    if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {//PIP capture: 24fps for less than 13M, 20fps for 16M,15fps for 20M
+        imgsensor.pclk = imgsensor_info.cap1.pclk;
+        imgsensor.line_length = imgsensor_info.cap1.linelength;
+        imgsensor.frame_length = imgsensor_info.cap1.framelength;
+        imgsensor.min_frame_length = imgsensor_info.cap1.framelength;
+        imgsensor.autoflicker_en = KAL_FALSE;
+    } else {
+        if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
+            LOG_INF("Warning: current_fps %d fps is not support, so use cap's setting: %d fps!\n",imgsensor.current_fps,imgsensor_info.cap.max_framerate/10);
+        imgsensor.pclk = imgsensor_info.cap.pclk;
+        imgsensor.line_length = imgsensor_info.cap.linelength;
+        imgsensor.frame_length = imgsensor_info.cap.framelength;
+        imgsensor.min_frame_length = imgsensor_info.cap.framelength;
+        imgsensor.autoflicker_en = KAL_FALSE;
+    }
+    spin_unlock(&imgsensor_drv_lock);
+    capture_setting(imgsensor.current_fps);
+	//set_mirror_flip(sensor_config_data->SensorImageMirror);
+    return ERROR_NONE;
+}    /* capture() */
+static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_VIDEO;
+    imgsensor.pclk = imgsensor_info.normal_video.pclk;
+    imgsensor.line_length = imgsensor_info.normal_video.linelength;
+    imgsensor.frame_length = imgsensor_info.normal_video.framelength;
+    imgsensor.min_frame_length = imgsensor_info.normal_video.framelength;
+    //imgsensor.current_fps = 300;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    normal_video_setting(imgsensor.current_fps);	
+	//set_mirror_flip(sensor_config_data->SensorImageMirror);
+    return ERROR_NONE;
+}    /*    normal_video   */
+
+static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_HIGH_SPEED_VIDEO;
+    imgsensor.pclk = imgsensor_info.hs_video.pclk;
+    //imgsensor.video_mode = KAL_TRUE;
+    imgsensor.line_length = imgsensor_info.hs_video.linelength;
+    imgsensor.frame_length = imgsensor_info.hs_video.framelength;
+    imgsensor.min_frame_length = imgsensor_info.hs_video.framelength;
+    imgsensor.dummy_line = 0;
+    imgsensor.dummy_pixel = 0;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    hs_video_setting();	
+	//set_mirror_flip(sensor_config_data->SensorImageMirror);
+    return ERROR_NONE;
+}    /*    hs_video   */
+
+static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_SLIM_VIDEO;
+    imgsensor.pclk = imgsensor_info.slim_video.pclk;
+    imgsensor.line_length = imgsensor_info.slim_video.linelength;
+    imgsensor.frame_length = imgsensor_info.slim_video.framelength;
+    imgsensor.min_frame_length = imgsensor_info.slim_video.framelength;
+    imgsensor.dummy_line = 0;
+    imgsensor.dummy_pixel = 0;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    slim_video_setting();
+	//set_mirror_flip(sensor_config_data->SensorImageMirror);
+
+    return ERROR_NONE;
+}    /*    slim_video     */
+
+
+
+static kal_uint32 get_resolution(MSDK_SENSOR_RESOLUTION_INFO_STRUCT *sensor_resolution)
+{
+    LOG_INF("E\n");
+    sensor_resolution->SensorFullWidth = imgsensor_info.cap.grabwindow_width;
+    sensor_resolution->SensorFullHeight = imgsensor_info.cap.grabwindow_height;
+
+    sensor_resolution->SensorPreviewWidth = imgsensor_info.pre.grabwindow_width;
+    sensor_resolution->SensorPreviewHeight = imgsensor_info.pre.grabwindow_height;
+
+    sensor_resolution->SensorVideoWidth = imgsensor_info.normal_video.grabwindow_width;
+    sensor_resolution->SensorVideoHeight = imgsensor_info.normal_video.grabwindow_height;
+
+
+    sensor_resolution->SensorHighSpeedVideoWidth     = imgsensor_info.hs_video.grabwindow_width;
+    sensor_resolution->SensorHighSpeedVideoHeight     = imgsensor_info.hs_video.grabwindow_height;
+
+    sensor_resolution->SensorSlimVideoWidth     = imgsensor_info.slim_video.grabwindow_width;
+    sensor_resolution->SensorSlimVideoHeight     = imgsensor_info.slim_video.grabwindow_height;
+    return ERROR_NONE;
+}    /*    get_resolution    */
+
+static kal_uint32 get_info(MSDK_SCENARIO_ID_ENUM scenario_id,
+                      MSDK_SENSOR_INFO_STRUCT *sensor_info,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("scenario_id = %d\n", scenario_id);
+
+
+    //sensor_info->SensorVideoFrameRate = imgsensor_info.normal_video.max_framerate/10; /* not use */
+    //sensor_info->SensorStillCaptureFrameRate= imgsensor_info.cap.max_framerate/10; /* not use */
+    //imgsensor_info->SensorWebCamCaptureFrameRate= imgsensor_info.v.max_framerate; /* not use */
+
+    sensor_info->SensorClockPolarity = SENSOR_CLOCK_POLARITY_LOW;
+    sensor_info->SensorClockFallingPolarity = SENSOR_CLOCK_POLARITY_LOW; /* not use */
+    sensor_info->SensorHsyncPolarity = SENSOR_CLOCK_POLARITY_LOW; // inverse with datasheet
+    sensor_info->SensorVsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
+    sensor_info->SensorInterruptDelayLines = 4; /* not use */
+    sensor_info->SensorResetActiveHigh = FALSE; /* not use */
+    sensor_info->SensorResetDelayCount = 5; /* not use */
+
+    sensor_info->SensroInterfaceType = imgsensor_info.sensor_interface_type;
+    sensor_info->MIPIsensorType = imgsensor_info.mipi_sensor_type;
+    sensor_info->SettleDelayMode = imgsensor_info.mipi_settle_delay_mode;
+    sensor_info->SensorOutputDataFormat = imgsensor_info.sensor_output_dataformat;
+
+    sensor_info->CaptureDelayFrame = imgsensor_info.cap_delay_frame;
+    sensor_info->PreviewDelayFrame = imgsensor_info.pre_delay_frame;
+    sensor_info->VideoDelayFrame = imgsensor_info.video_delay_frame;
+    sensor_info->HighSpeedVideoDelayFrame = imgsensor_info.hs_video_delay_frame;
+    sensor_info->SlimVideoDelayFrame = imgsensor_info.slim_video_delay_frame;
+
+    sensor_info->SensorMasterClockSwitch = 0; /* not use */
+    sensor_info->SensorDrivingCurrent = imgsensor_info.isp_driving_current;
+
+    sensor_info->AEShutDelayFrame = imgsensor_info.ae_shut_delay_frame;          /* The frame of setting shutter default 0 for TG int */
+    sensor_info->AESensorGainDelayFrame = imgsensor_info.ae_sensor_gain_delay_frame;    /* The frame of setting sensor gain */
+    sensor_info->AEISPGainDelayFrame = imgsensor_info.ae_ispGain_delay_frame;
+    sensor_info->IHDR_Support = imgsensor_info.ihdr_support;
+    sensor_info->IHDR_LE_FirstLine = imgsensor_info.ihdr_le_firstline;
+    sensor_info->SensorModeNum = imgsensor_info.sensor_mode_num;
+
+    sensor_info->SensorMIPILaneNumber = imgsensor_info.mipi_lane_num;
+    sensor_info->SensorClockFreq = imgsensor_info.mclk;
+    sensor_info->SensorClockDividCount = 3; /* not use */
+    sensor_info->SensorClockRisingCount = 0;
+    sensor_info->SensorClockFallingCount = 2; /* not use */
+    sensor_info->SensorPixelClockCount = 3; /* not use */
+    sensor_info->SensorDataLatchCount = 2; /* not use */
+
+    sensor_info->MIPIDataLowPwr2HighSpeedTermDelayCount = 0;
+    sensor_info->MIPICLKLowPwr2HighSpeedTermDelayCount = 0;
+    sensor_info->SensorWidthSampling = 0;  // 0 is default 1x
+    sensor_info->SensorHightSampling = 0;    // 0 is default 1x
+    sensor_info->SensorPacketECCOrder = 1;
+
+    switch (scenario_id) {
+        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+            sensor_info->SensorGrabStartX = imgsensor_info.pre.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
+
+            break;
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+            sensor_info->SensorGrabStartX = imgsensor_info.cap.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.cap.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.cap.mipi_data_lp2hs_settle_dc;
+
+            break;
+        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+
+            sensor_info->SensorGrabStartX = imgsensor_info.normal_video.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.normal_video.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.normal_video.mipi_data_lp2hs_settle_dc;
+
+            break;
+        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+            sensor_info->SensorGrabStartX = imgsensor_info.hs_video.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.hs_video.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.hs_video.mipi_data_lp2hs_settle_dc;
+
+            break;
+        case MSDK_SCENARIO_ID_SLIM_VIDEO:
+            sensor_info->SensorGrabStartX = imgsensor_info.slim_video.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.slim_video.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.slim_video.mipi_data_lp2hs_settle_dc;
+
+            break;
+        default:
+            sensor_info->SensorGrabStartX = imgsensor_info.pre.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
+            break;
+    }
+
+    return ERROR_NONE;
+}    /*    get_info  */
+
+
+static kal_uint32 control(MSDK_SCENARIO_ID_ENUM scenario_id, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("scenario_id = %d\n", scenario_id);
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.current_scenario_id = scenario_id;
+    spin_unlock(&imgsensor_drv_lock);
+    switch (scenario_id) {
+        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+            preview(image_window, sensor_config_data);
+            break;
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+            capture(image_window, sensor_config_data);
+            break;
+        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+            normal_video(image_window, sensor_config_data);
+            break;
+        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+            hs_video(image_window, sensor_config_data);
+            break;
+        case MSDK_SCENARIO_ID_SLIM_VIDEO:
+            slim_video(image_window, sensor_config_data);
+            break;
+        default:
+            LOG_INF("Error ScenarioId setting");
+            preview(image_window, sensor_config_data);
+            return ERROR_INVALID_SCENARIO_ID;
+    }
+    return ERROR_NONE;
+}    /* control() */
+
+
+
+static kal_uint32 set_video_mode(UINT16 framerate)
+{//This Function not used after ROME
+    LOG_INF("framerate = %d\n ", framerate);
+    // SetVideoMode Function should fix framerate
+    if (framerate == 0)
+        // Dynamic frame rate
+        return ERROR_NONE;
+    spin_lock(&imgsensor_drv_lock);
+    if ((framerate == 300) && (imgsensor.autoflicker_en == KAL_TRUE))
+        imgsensor.current_fps = 296;
+    else if ((framerate == 150) && (imgsensor.autoflicker_en == KAL_TRUE))
+        imgsensor.current_fps = 146;
+    else
+        imgsensor.current_fps = framerate;
+    spin_unlock(&imgsensor_drv_lock);
+    set_max_framerate(imgsensor.current_fps,1);
+
+    return ERROR_NONE;
+}
+
+static kal_uint32 set_auto_flicker_mode(kal_bool enable, UINT16 framerate)
+{
+    LOG_INF("enable = %d, framerate = %d \n", enable, framerate);
+    spin_lock(&imgsensor_drv_lock);
+    if (enable) //enable auto flicker
+        imgsensor.autoflicker_en = KAL_TRUE;
+    else //Cancel Auto flick
+        imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    return ERROR_NONE;
+}
+
+
+static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 framerate)
+{
+    kal_uint32 frame_length;
+
+    LOG_INF("scenario_id = %d, framerate = %d\n", scenario_id, framerate);
+
+    switch (scenario_id) {
+        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+            frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            set_dummy();
+            break;
+        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+            if(framerate == 0)
+                return ERROR_NONE;
+            frame_length = imgsensor_info.normal_video.pclk / framerate * 10 / imgsensor_info.normal_video.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.normal_video.framelength) ? (frame_length - imgsensor_info.normal_video.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.normal_video.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            set_dummy();
+            break;
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+        	  if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {
+                frame_length = imgsensor_info.cap1.pclk / framerate * 10 / imgsensor_info.cap1.linelength;
+                spin_lock(&imgsensor_drv_lock);
+		            imgsensor.dummy_line = (frame_length > imgsensor_info.cap1.framelength) ? (frame_length - imgsensor_info.cap1.framelength) : 0;
+		            imgsensor.frame_length = imgsensor_info.cap1.framelength + imgsensor.dummy_line;
+		            imgsensor.min_frame_length = imgsensor.frame_length;
+		            spin_unlock(&imgsensor_drv_lock);
+            } else {
+        		    if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
+                    LOG_INF("Warning: current_fps %d fps is not support, so use cap's setting: %d fps!\n",framerate,imgsensor_info.cap.max_framerate/10);
+                frame_length = imgsensor_info.cap.pclk / framerate * 10 / imgsensor_info.cap.linelength;
+                spin_lock(&imgsensor_drv_lock);
+		            imgsensor.dummy_line = (frame_length > imgsensor_info.cap.framelength) ? (frame_length - imgsensor_info.cap.framelength) : 0;
+		            imgsensor.frame_length = imgsensor_info.cap.framelength + imgsensor.dummy_line;
+		            imgsensor.min_frame_length = imgsensor.frame_length;
+		            spin_unlock(&imgsensor_drv_lock);
+            }
+            set_dummy();
+            break;
+        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+            frame_length = imgsensor_info.hs_video.pclk / framerate * 10 / imgsensor_info.hs_video.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.hs_video.framelength) ? (frame_length - imgsensor_info.hs_video.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.hs_video.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            set_dummy();
+            break;
+        case MSDK_SCENARIO_ID_SLIM_VIDEO:
+            frame_length = imgsensor_info.slim_video.pclk / framerate * 10 / imgsensor_info.slim_video.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.slim_video.framelength) ? (frame_length - imgsensor_info.slim_video.framelength): 0;
+            imgsensor.frame_length = imgsensor_info.slim_video.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            set_dummy();
+            break;
+        default:  //coding with  preview scenario by default
+            frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            set_dummy();
+            LOG_INF("error scenario_id = %d, we use preview scenario \n", scenario_id);
+            break;
+    }
+    return ERROR_NONE;
+}
+
+
+static kal_uint32 get_default_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 *framerate)
+{
+    LOG_INF("scenario_id = %d\n", scenario_id);
+
+    switch (scenario_id) {
+        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+            *framerate = imgsensor_info.pre.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+            *framerate = imgsensor_info.normal_video.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+            *framerate = imgsensor_info.cap.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+            *framerate = imgsensor_info.hs_video.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_SLIM_VIDEO:
+            *framerate = imgsensor_info.slim_video.max_framerate;
+            break;
+        default:
+            break;
+    }
+
+    return ERROR_NONE;
+}
+
+
+
+static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
+                             UINT8 *feature_para,UINT32 *feature_para_len)
+{
+    UINT16 *feature_return_para_16=(UINT16 *) feature_para;
+    UINT16 *feature_data_16=(UINT16 *) feature_para;
+    UINT32 *feature_return_para_32=(UINT32 *) feature_para;
+    UINT32 *feature_data_32=(UINT32 *) feature_para;
+    unsigned long long *feature_data=(unsigned long long *) feature_para;
+
+    SENSOR_WINSIZE_INFO_STRUCT *wininfo;
+    MSDK_SENSOR_REG_INFO_STRUCT *sensor_reg_data=(MSDK_SENSOR_REG_INFO_STRUCT *) feature_para;
+
+    LOG_INF("feature_id = %d\n", feature_id);
+    switch (feature_id) {
+        case SENSOR_FEATURE_GET_PERIOD:
+            *feature_return_para_16++ = imgsensor.line_length;
+            *feature_return_para_16 = imgsensor.frame_length;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:
+            *feature_return_para_32 = imgsensor.pclk;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_SET_ESHUTTER:
+            set_shutter(*feature_data_16);
+            break;
+        case SENSOR_FEATURE_SET_NIGHTMODE:
+            night_mode((BOOL) *feature_data_16);
+            break;
+        case SENSOR_FEATURE_SET_GAIN:
+            set_gain((UINT16) *feature_data_16);
+            break;
+        case SENSOR_FEATURE_SET_FLASHLIGHT:
+            break;
+        case SENSOR_FEATURE_SET_ISP_MASTER_CLOCK_FREQ:
+            break;
+        case SENSOR_FEATURE_SET_REGISTER:
+            write_cmos_sensor(sensor_reg_data->RegAddr, sensor_reg_data->RegData);
+            break;
+        case SENSOR_FEATURE_GET_REGISTER:
+            sensor_reg_data->RegData = read_cmos_sensor(sensor_reg_data->RegAddr);
+            break;
+        case SENSOR_FEATURE_GET_LENS_DRIVER_ID:
+            // get the lens driver ID from EEPROM or just return LENS_DRIVER_ID_DO_NOT_CARE
+            // if EEPROM does not exist in camera module.
+            *feature_return_para_32=LENS_DRIVER_ID_DO_NOT_CARE;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_SET_VIDEO_MODE:
+            set_video_mode(*feature_data_16);
+            break;
+        case SENSOR_FEATURE_CHECK_SENSOR_ID:
+            get_imgsensor_id(feature_return_para_32);
+            break;
+        case SENSOR_FEATURE_SET_AUTO_FLICKER_MODE:
+            set_auto_flicker_mode((BOOL)*feature_data_16,*(feature_data_16+1));
+            break;
+        case SENSOR_FEATURE_SET_MAX_FRAME_RATE_BY_SCENARIO:
+            set_max_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data, *(feature_data+1));
+            break;
+        case SENSOR_FEATURE_GET_DEFAULT_FRAME_RATE_BY_SCENARIO:
+            get_default_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data_32, (MUINT32 *)(*(feature_data+1)));
+            break;
+        case SENSOR_FEATURE_SET_TEST_PATTERN:
+            set_test_pattern_mode((BOOL)*feature_data_16);
+            break;
+        case SENSOR_FEATURE_GET_TEST_PATTERN_CHECKSUM_VALUE: //for factory mode auto testing
+            *feature_return_para_32 = imgsensor_info.checksum_value;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_SET_FRAMERATE:
+            LOG_INF("current fps :%d\n", *feature_data_16);
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.current_fps = *feature_data_16;
+            spin_unlock(&imgsensor_drv_lock);
+            break;
+        case SENSOR_FEATURE_SET_HDR:
+            LOG_INF("ihdr enable :%d\n", *feature_data_16);
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.ihdr_en = *feature_data_16;
+            spin_unlock(&imgsensor_drv_lock);
+            break;
+        case SENSOR_FEATURE_GET_CROP_INFO:
+            LOG_INF("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n", *feature_data_32);
+            wininfo = (SENSOR_WINSIZE_INFO_STRUCT *)(*(feature_data+1));
+
+            switch (*feature_data_32) {
+                case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[1],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[2],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[3],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_SLIM_VIDEO:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[4],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+                default:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[0],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+            }
+        case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
+            LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",*feature_data_32,*(feature_data_32+1),*(feature_data_32+2));
+            ihdr_write_shutter_gain(*feature_data_32,*(feature_data_32+1),*(feature_data_32+2));
+            break;
+        default:
+            break;
+    }
+
+    return ERROR_NONE;
+}    /*    feature_control()  */
+
+static SENSOR_FUNCTION_STRUCT sensor_func = {
+    open,
+    get_info,
+    get_resolution,
+    feature_control,
+    control,
+    close
+};
+
+UINT32 GC2755_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
+{
+    /* To Do : Check Sensor status here */
+    if (pfFunc!=NULL)
+        *pfFunc=&sensor_func;
+    return ERROR_NONE;
+}    /*    GC2755_MIPI_RAW_SensorInit    */
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/gc2755_mipi_raw/gc2755mipi_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735/gc2755_mipi_raw/gc2755mipi_Sensor.h
new file mode 100755
index 0000000..ab50666
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735/gc2755_mipi_raw/gc2755mipi_Sensor.h
@@ -0,0 +1,144 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *     GC2755mipi_Sensor.h
+ *
+ * Project:
+ * --------
+ *     ALPS
+ *
+ * Description:
+ * ------------
+ *     CMOS sensor header file
+ *
+ ****************************************************************************/
+#ifndef _GC2755MIPI_SENSOR_H
+#define _GC2755MIPI_SENSOR_H
+
+
+typedef enum{
+    IMGSENSOR_MODE_INIT,
+    IMGSENSOR_MODE_PREVIEW,
+    IMGSENSOR_MODE_CAPTURE,
+    IMGSENSOR_MODE_VIDEO,
+    IMGSENSOR_MODE_HIGH_SPEED_VIDEO,
+    IMGSENSOR_MODE_SLIM_VIDEO,
+} IMGSENSOR_MODE;
+
+typedef struct imgsensor_mode_struct {
+    kal_uint32 pclk;                //record different mode's pclk
+    kal_uint32 linelength;            //record different mode's linelength
+    kal_uint32 framelength;            //record different mode's framelength
+
+    kal_uint8 startx;                //record different mode's startx of grabwindow
+    kal_uint8 starty;                //record different mode's startx of grabwindow
+
+    kal_uint16 grabwindow_width;    //record different mode's width of grabwindow
+    kal_uint16 grabwindow_height;    //record different mode's height of grabwindow
+
+    /*     following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario    */
+    kal_uint8 mipi_data_lp2hs_settle_dc;
+
+    /*     following for GetDefaultFramerateByScenario()    */
+    kal_uint16 max_framerate;
+
+} imgsensor_mode_struct;
+
+/* SENSOR PRIVATE STRUCT FOR VARIABLES*/
+typedef struct imgsensor_struct {
+    kal_uint8 mirror;                //mirrorflip information
+
+    kal_uint8 sensor_mode;            //record IMGSENSOR_MODE enum value
+
+    kal_uint32 shutter;                //current shutter
+    kal_uint16 gain;                //current gain
+
+    kal_uint32 pclk;                //current pclk
+
+    kal_uint32 frame_length;        //current framelength
+    kal_uint32 line_length;            //current linelength
+
+    kal_uint32 min_frame_length;    //current min  framelength to max framerate
+    kal_uint16 dummy_pixel;            //current dummypixel
+    kal_uint16 dummy_line;            //current dummline
+
+    kal_uint16 current_fps;            //current max fps
+    kal_bool   autoflicker_en;        //record autoflicker enable or disable
+    kal_bool test_pattern;            //record test pattern mode or not
+    MSDK_SCENARIO_ID_ENUM current_scenario_id;//current scenario id
+    kal_uint8  ihdr_en;                //ihdr enable or disable
+
+    kal_uint8 i2c_write_id;            //record current sensor's i2c write id
+} imgsensor_struct;
+
+/* SENSOR PRIVATE STRUCT FOR CONSTANT*/
+typedef struct imgsensor_info_struct {
+    kal_uint32 sensor_id;            //record sensor id defined in Kd_imgsensor.h
+    kal_uint32 checksum_value;        //checksum value for Camera Auto Test
+    imgsensor_mode_struct pre;        //preview scenario relative information
+    imgsensor_mode_struct cap;        //capture scenario relative information
+    imgsensor_mode_struct cap1;        //capture for PIP 24fps relative information, capture1 mode must use same framelength, linelength with Capture mode for shutter calculate
+    imgsensor_mode_struct normal_video;//normal video  scenario relative information
+    imgsensor_mode_struct hs_video;    //high speed video scenario relative information
+    imgsensor_mode_struct slim_video;    //slim video for VT scenario relative information
+
+    kal_uint8  ae_shut_delay_frame;    //shutter delay frame for AE cycle
+    kal_uint8  ae_sensor_gain_delay_frame;    //sensor gain delay frame for AE cycle
+    kal_uint8  ae_ispGain_delay_frame;    //isp gain delay frame for AE cycle
+    kal_uint8  ihdr_support;        //1, support; 0,not support
+    kal_uint8  ihdr_le_firstline;    //1,le first ; 0, se first
+    kal_uint8  sensor_mode_num;        //support sensor mode num
+
+    kal_uint8  cap_delay_frame;        //enter capture delay frame num
+    kal_uint8  pre_delay_frame;        //enter preview delay frame num
+    kal_uint8  video_delay_frame;    //enter video delay frame num
+    kal_uint8  hs_video_delay_frame;    //enter high speed video  delay frame num
+    kal_uint8  slim_video_delay_frame;    //enter slim video delay frame num
+
+    kal_uint8  margin;                //sensor framelength & shutter margin
+    kal_uint32 min_shutter;            //min shutter
+    kal_uint32 max_frame_length;    //max framelength by sensor register's limitation
+
+    kal_uint8  isp_driving_current;    //mclk driving current
+    kal_uint8  sensor_interface_type;//sensor_interface_type
+    kal_uint8  mipi_sensor_type; //0,MIPI_OPHY_NCSI2; 1,MIPI_OPHY_CSI2, default is NCSI2, don't modify this para
+    kal_uint8  mipi_settle_delay_mode; //0, high speed signal auto detect; 1, use settle delay,unit is ns, default is auto detect, don't modify this para
+    kal_uint8  sensor_output_dataformat;//sensor output first pixel color
+    kal_uint8  mclk;                //mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
+
+    kal_uint8  mipi_lane_num;        //mipi lane num
+    kal_uint8  i2c_addr_table[5];    //record sensor support all write id addr, only supprt 4must end with 0xff
+} imgsensor_info_struct;
+
+/* SENSOR READ/WRITE ID */
+//#define IMGSENSOR_WRITE_ID_1 (0x6c)
+//#define IMGSENSOR_READ_ID_1  (0x6d)
+//#define IMGSENSOR_WRITE_ID_2 (0x20)
+//#define IMGSENSOR_READ_ID_2  (0x21)
+
+// add by yfx
+#define GC2755_VALID_IXEL_NUMS            1920
+#define GC2755_VALID_LINE_NUMS            1080
+#define GC2755_DEFAULT_DUMMY_PIXEL_NUMS   0x312 
+#define GC2755_DEFAULT_DUMMY_LINE_NUMS    0x49
+
+#define GC2755_INTERNAL_DUMMY_PIXEL_NUMS  0
+#define GC2755_INTERNAL_DUMMY_LINE_NUMS   0
+
+#define GC2755_VIDEO_PERIOD_PIXEL_NUMS          (1772)
+#define GC2755_VIDEO_PERIOD_LINE_NUMS           (1185)
+#define GC2755_PV_PERIOD_PIXEL_NUMS            (1772)
+#define GC2755_PV_PERIOD_LINE_NUMS             (1185)
+
+#define GC2755_FULL_PERIOD_PIXEL_NUMS          (1772)
+#define GC2755_FULL_PERIOD_LINE_NUMS           (1185)
+
+
+// end
+
+extern int iReadRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u8 * a_pRecvData, u16 a_sizeRecvData, u16 i2cId);
+extern int iWriteRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u16 i2cId);
+extern int iWriteReg(u16 a_u2Addr , u32 a_u4Data , u32 a_u4Bytes , u16 i2cId); 
+
+#endif
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/imx219_mipi_raw/imx219mipiraw_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735/imx219_mipi_raw/imx219mipiraw_Sensor.c
index da54525..4d9d3cb 100644
--- a/drivers/misc/mediatek/imgsensor/src/mt6735/imx219_mipi_raw/imx219mipiraw_Sensor.c
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735/imx219_mipi_raw/imx219mipiraw_Sensor.c
@@ -61,7 +61,7 @@ static imgsensor_info_struct imgsensor_info = {
 		.grabwindow_width = 1632,		//record different mode's width of grabwindow
 		.grabwindow_height = 1224,		//record different mode's height of grabwindow
 		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
-		.mipi_data_lp2hs_settle_dc = 65,//unit , ns
+		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
 		/*	 following for GetDefaultFramerateByScenario()	*/
 		.max_framerate = 300,
 	},
@@ -73,7 +73,7 @@ static imgsensor_info_struct imgsensor_info = {
 		.starty = 4,
 		.grabwindow_width = 3264,
 		.grabwindow_height = 2448,
-		.mipi_data_lp2hs_settle_dc = 65,//unit , ns
+		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
 		.max_framerate = 300,
 	},
 	.cap1 = {							//capture for PIP 24fps relative information, capture1 mode must use same framelength, linelength with Capture mode for shutter calculate
@@ -84,7 +84,7 @@ static imgsensor_info_struct imgsensor_info = {
 		.starty = 4,
 		.grabwindow_width = 3264,
 		.grabwindow_height = 2448,
-		.mipi_data_lp2hs_settle_dc = 65,//unit , ns
+		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
 		.max_framerate = 240,	//less than 13M(include 13M),cap1 max framerate is 24fps,16M max framerate is 20fps, 20M max framerate is 15fps
 	},
 	.normal_video = {
@@ -95,7 +95,7 @@ static imgsensor_info_struct imgsensor_info = {
 		.starty = 4,
 		.grabwindow_width = 3264,
 		.grabwindow_height = 2448,
-		.mipi_data_lp2hs_settle_dc = 65,//unit , ns
+		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
 		.max_framerate = 300,
 	},
 	.hs_video = {
@@ -106,7 +106,7 @@ static imgsensor_info_struct imgsensor_info = {
 		.starty = 0,
 		.grabwindow_width = 1920,
 		.grabwindow_height = 1080,
-		.mipi_data_lp2hs_settle_dc = 65,//unit , ns
+		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
 		.max_framerate = 600,
 	},
 	.slim_video = {
@@ -117,7 +117,7 @@ static imgsensor_info_struct imgsensor_info = {
 		.starty = 4,
 		.grabwindow_width = 1280,
 		.grabwindow_height = 720,
-		.mipi_data_lp2hs_settle_dc = 65,//unit , ns
+		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
 		.max_framerate = 300,
 
 	},
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/kd_sensorlist.h b/drivers/misc/mediatek/imgsensor/src/mt6735/kd_sensorlist.h
index 0b6aeb5..86230b9 100644
--- a/drivers/misc/mediatek/imgsensor/src/mt6735/kd_sensorlist.h
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735/kd_sensorlist.h
@@ -81,6 +81,8 @@ UINT32 MT9V114_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 MT9D115MIPISensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 MT9V115_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 /*GC*/
+UINT32 GC2235_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
+UINT32 GC2755_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 GC2355_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 GC2235_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 GC2145MIPI_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
@@ -89,6 +91,7 @@ UINT32 GC0330_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 GC0329_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 GC0313MIPI_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 GC0310_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
+UINT32 GC2155MIPI_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 /*SP*/
 UINT32 SP0A19_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 /*A*/
@@ -353,12 +356,18 @@ ACDK_KD_SENSOR_INIT_FUNCTION_STRUCT kdSensorList[MAX_NUM_OF_SUPPORT_SENSOR+1] =
   {MT9V115_SENSOR_ID,SENSOR_DRVNAME_MT9V115_YUV,MT9V115_YUV_SensorInit},
 #endif
 /*GC*/
+#if defined(GC2755_MIPI_RAW)
+    {GC2755_SENSOR_ID,SENSOR_DRVNAME_GC2755_MIPI_RAW, GC2755_MIPI_RAW_SensorInit},
+#endif
 #if defined(GC2355_MIPI_RAW)
     {GC2355_SENSOR_ID, SENSOR_DRVNAME_GC2355_MIPI_RAW,GC2355_MIPI_RAW_SensorInit},
 #endif
 #if defined(GC2235_RAW)
     {GC2235_SENSOR_ID, SENSOR_DRVNAME_GC2235_RAW, GC2235_RAW_SensorInit},
 #endif
+#if defined(GC2235_MIPI_RAW)
+    {GC2235MIPI_SENSOR_ID, SENSOR_DRVNAME_GC2235_MIPI_RAW, GC2235_MIPI_RAW_SensorInit},
+#endif
 #if defined(GC2145_MIPI_YUV)
     {GC2145_SENSOR_ID, SENSOR_DRVNAME_GC2145_MIPI_YUV, GC2145MIPI_YUV_SensorInit},
 #endif
@@ -380,6 +389,9 @@ ACDK_KD_SENSOR_INIT_FUNCTION_STRUCT kdSensorList[MAX_NUM_OF_SUPPORT_SENSOR+1] =
 #if defined(GC0310_YUV)
     {GC0310_SENSOR_ID, SENSOR_DRVNAME_GC0310_YUV,GC0310_YUV_SensorInit},
 #endif
+#if defined(GC2155MIPI_YUV)
+    {GC2155MIPI_SENSOR_ID,SENSOR_DRVNAME_GC2155_MIPI_YUV,GC2155MIPI_YUV_SensorInit},
+#endif
 /*SP*/
 #if defined(SP0A19_YUV)
     {SP0A19_YUV_SENSOR_ID, SENSOR_DRVNAME_SP0A19_YUV, SP0A19_YUV_SensorInit},
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/ov13850_mipi_raw/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6735/ov13850_mipi_raw/Makefile
new file mode 100755
index 0000000..50b8b5a
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735/ov13850_mipi_raw/Makefile
@@ -0,0 +1,4 @@
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+
+obj-y += ov13850mipiraw_Sensor.o
+
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/ov13850_mipi_raw/ov13850_otp.h b/drivers/misc/mediatek/imgsensor/src/mt6735/ov13850_mipi_raw/ov13850_otp.h
new file mode 100755
index 0000000..79d8d7f
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735/ov13850_mipi_raw/ov13850_otp.h
@@ -0,0 +1,44 @@
+/*file discription : otp*/
+#define OTP_DRV_LSC_SIZE 186
+
+struct otp_struct {
+int flag;//bit[7]:info,bit[6]:wb,bit[5]:vcm,bit[4]:lenc
+int module_integrator_id;
+int lens_id;
+int production_year;
+int production_month;
+int production_day;
+int rg_ratio;
+int bg_ratio;
+//int light_rg;
+//int light_bg;
+//int typical_rg_ratio;
+//int typical_bg_ratio;
+unsigned char lenc[OTP_DRV_LSC_SIZE];
+int checksumLSC;
+int checksumOTP;
+int checksumTotal;
+int VCM_start;
+int VCM_end;
+int VCM_dir;
+};
+
+#define RG_Ratio_Typical 0x125
+#define BG_Ratio_Typical 0x131
+
+int read_otp(struct otp_struct *otp_ptr);
+int apply_otp(struct otp_struct *otp_ptr);
+int Decode_13850R2A(unsigned char*pInBuf, unsigned char* pOutBuf);
+void otp_cali(unsigned char writeid);
+void LumaDecoder(uint8_t *pData, uint8_t *pPara);
+void ColorDecoder(uint8_t *pData, uint8_t *pPara);
+//extern int read_otp_info(int index, struct otp_struct *otp_ptr);
+//extern int update_otp_wb(void);
+//extern int update_otp_lenc(void);
+
+
+
+
+
+
+
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/ov13850_mipi_raw/ov13850_otp_cal.c b/drivers/misc/mediatek/imgsensor/src/mt6735/ov13850_mipi_raw/ov13850_otp_cal.c
new file mode 100755
index 0000000..4ac47f3
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735/ov13850_mipi_raw/ov13850_otp_cal.c
@@ -0,0 +1,529 @@
+#include <linux/videodev2.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <asm/atomic.h>
+#include <linux/xlog.h>
+#include <asm/system.h>
+
+#include <linux/proc_fs.h> 
+
+
+#include <linux/dma-mapping.h>
+
+#include "kd_camera_hw.h"
+#include "kd_imgsensor.h"
+#include "kd_imgsensor_define.h"
+#include "kd_imgsensor_errcode.h"
+
+
+#include "ov13850mipiraw_Sensor.h"
+#include "ov13850_otp.h"
+
+#if 1
+extern int iReadReg(u16 a_u2Addr , u8 * a_puBuff , u16 i2cId);
+extern int iWriteReg(u16 a_u2Addr , u32 a_u4Data , u32 a_u4Bytes , u16 i2cId);
+
+//#define OV13850_R2A_write_i2c(addr, para) iWriteReg((u16) addr , (u32) para , 1, OV13850MIPI_WRITE_ID)
+#define PFX "OV13850_R2A_OTP"
+#define LOG_INF(format, args...)	//xlog_printk(ANDROID_LOG_INFO   , PFX, "[%s] " format, __FUNCTION__, ##args)
+
+
+#define Delay(ms)  mdelay(ms)
+static unsigned char OV13850MIPI_WRITE_ID = 0X00;
+
+kal_uint16 OV13850_R2A_read_i2c(kal_uint32 addr)
+{
+    kal_uint16 get_byte=0;
+    iReadReg((u16) addr ,(u8*)&get_byte,OV13850MIPI_WRITE_ID);
+    return get_byte;
+}
+
+kal_uint16 OV13850_R2A_write_i2c(addr, para)
+{
+		iWriteReg((u16) addr , (u32) para , 1, OV13850MIPI_WRITE_ID);
+		return 1;
+}
+#endif
+
+void otp_cali(unsigned char writeid)
+{
+	struct otp_struct current_otp;
+	OV13850MIPI_WRITE_ID = writeid;
+	memset(&current_otp, 0, sizeof(struct otp_struct));
+	read_otp(&current_otp);
+	apply_otp(&current_otp);
+}
+
+int Decode_13850R2A(unsigned char*pInBuf, unsigned char* pOutBuf)
+{
+	if(pInBuf != NULL)
+	{
+		LumaDecoder(pInBuf, pOutBuf);
+		ColorDecoder((pInBuf+86), (pOutBuf+120));
+		ColorDecoder((pInBuf+136), (pOutBuf+240));
+		LOG_INF(" OTP OK \n");
+		return 1;
+	}
+	{
+		LOG_INF(" OTP FAIL \n");
+		return 0;	
+	}
+
+}
+// return value:
+// bit[7]: 0 no otp info, 1 valid otp info
+// bit[6]: 0 no otp wb, 1 valib otp wb
+// bit[5]: 0 no otp vcm, 1 valid otp vcm
+// bit[4]: 0 no otp lenc, 1 valid otp lenc
+int read_otp(struct otp_struct *otp_ptr)
+{
+	
+	int otp_flag=0;
+	int addr=0;
+	int temp=0;
+	int i=0;
+	int checksumLSC = 0;
+	int checksumOTP = 0;
+	int checksumTotal = 0;
+	//int 360
+	unsigned char lenc_out[360];
+	//set 0x5002[1] to "0"
+	int temp1=0;
+	temp1 = OV13850_R2A_read_i2c(0x5002);
+	OV13850_R2A_write_i2c(0x5002, (0x00 & 0x02) | (temp1 & (~0x02)));
+	// read OTP into buffer
+	OV13850_R2A_write_i2c(0x3d84, 0xC0);
+	OV13850_R2A_write_i2c(0x3d88, 0x72); // OTP start address
+	OV13850_R2A_write_i2c(0x3d89, 0x20);
+	OV13850_R2A_write_i2c(0x3d8A, 0x73); // OTP end address
+	OV13850_R2A_write_i2c(0x3d8B, 0xBE);
+	OV13850_R2A_write_i2c(0x3d81, 0x01); // load otp into buffer
+	Delay(10);
+	// OTP base information and WB calibration data
+	otp_flag = OV13850_R2A_read_i2c(0x7220);
+	LOG_INF(" WB calibration data : %x \n", otp_flag);
+	addr = 0;
+	if((otp_flag & 0xc0) == 0x40) {
+		addr = 0x7221; // base address of info group 1
+	}
+	else if((otp_flag & 0x30) == 0x10) {
+		addr = 0x7229; // base address of info group 2
+	}
+	if(addr != 0) {
+		(*otp_ptr).flag = 0xC0; // valid info and AWB in OTP
+		(*otp_ptr).module_integrator_id = OV13850_R2A_read_i2c(addr);
+		(*otp_ptr).lens_id = OV13850_R2A_read_i2c( addr + 1);
+		(*otp_ptr).production_year = OV13850_R2A_read_i2c( addr + 2);
+		(*otp_ptr).production_month = OV13850_R2A_read_i2c( addr + 3);
+		(*otp_ptr).production_day = OV13850_R2A_read_i2c(addr + 4);
+		temp = OV13850_R2A_read_i2c(addr + 7);
+		(*otp_ptr).rg_ratio = (OV13850_R2A_read_i2c(addr + 5)<<2) + ((temp>>6) & 0x03);
+		(*otp_ptr).bg_ratio = (OV13850_R2A_read_i2c(addr + 6)<<2) + ((temp>>4) & 0x03);	
+	}
+	else {
+		(*otp_ptr).flag = 0x00; // not info in OTP
+		(*otp_ptr).module_integrator_id = 0;
+		(*otp_ptr).lens_id = 0;
+		(*otp_ptr).production_year = 0;
+		(*otp_ptr).production_month = 0;
+		(*otp_ptr).production_day = 0;
+	}
+	// OTP VCM Calibration
+	otp_flag = OV13850_R2A_read_i2c(0x73ac);
+	LOG_INF(" VCM calibration data : %x \n", otp_flag);
+	addr = 0;
+	if((otp_flag & 0xc0) == 0x40) {
+		addr = 0x73ad; // base address of VCM Calibration group 1
+	}
+	else if((otp_flag & 0x30) == 0x10) {
+		addr = 0x73b0; // base address of VCM Calibration group 2
+	}
+	if(addr != 0) {
+		(*otp_ptr).flag |= 0x20;
+		temp = OV13850_R2A_read_i2c(addr + 2);
+		(* otp_ptr).VCM_start = (OV13850_R2A_read_i2c(addr)<<2) | ((temp>>6) & 0x03);
+		(* otp_ptr).VCM_end = (OV13850_R2A_read_i2c(addr + 1) << 2) | ((temp>>4) & 0x03);
+		(* otp_ptr).VCM_dir = (temp>>2) & 0x03;
+	}
+	else {
+		(* otp_ptr).VCM_start = 0;
+		(* otp_ptr).VCM_end = 0;
+		(* otp_ptr).VCM_dir = 0;
+	}
+	// OTP Lenc Calibration
+	otp_flag = OV13850_R2A_read_i2c(0x7231);
+	LOG_INF(" Lenc calibration data : %x \n", otp_flag);
+	addr = 0;
+	//int checksumLSC = 0, checksumOTP = 0, checksumTotal = 0;
+	if((otp_flag & 0xc0) == 0x40) {
+		addr = 0x7232; // base address of Lenc Calibration group 1
+	}
+	else if((otp_flag & 0x30) == 0x10) {
+		addr = 0x72ef; // base address of Lenc Calibration group 2
+	}
+	//
+	LOG_INF(" Lenc calibration addr : %x \n", addr);
+if(addr != 0) {
+		for(i=0;i<186;i++) {
+			(* otp_ptr).lenc[i]= OV13850_R2A_read_i2c(addr + i);
+			checksumLSC += (* otp_ptr).lenc[i];
+			LOG_INF(" Lenc (* otp_ptr).lenc[%d] : %x \n", i, (* otp_ptr).lenc[i]);
+		}
+		//Decode the lenc buffer from OTP , from 186 bytes to 360 bytes
+		//int lenc_out[360];
+		
+		for(i=0;i<360;i++)
+		{
+			lenc_out[i] = 0;
+		}
+		if(Decode_13850R2A((*otp_ptr).lenc,  lenc_out))
+		{
+			for(i=0;i<360;i++) 
+			{
+				LOG_INF(" from OTP lenc_out[%d]:%x \n", i, lenc_out[i]);
+				checksumOTP = checksumOTP + lenc_out[i]; 
+			}
+		}
+
+		checksumLSC = (checksumLSC)%255 +1;	
+		checksumOTP = (checksumOTP)%255 +1;
+		checksumTotal = (checksumLSC) ^ (checksumOTP);
+		(* otp_ptr).checksumLSC=OV13850_R2A_read_i2c(addr + 186);
+		(* otp_ptr).checksumOTP=OV13850_R2A_read_i2c(addr + 187);
+		(* otp_ptr).checksumTotal=OV13850_R2A_read_i2c(addr + 188);
+		LOG_INF(" checksumLSC-OTP-Total:%x-%x-%x;read checksumLSC-OTP-Total:%x-%x-%x\n", checksumLSC, checksumOTP,checksumTotal,(* otp_ptr).checksumLSC,(* otp_ptr).checksumOTP,(* otp_ptr).checksumTotal);
+		if((* otp_ptr).checksumLSC == checksumLSC && (* otp_ptr).checksumOTP == checksumOTP){
+			(*otp_ptr).flag |= 0x10;
+		}
+		else if((* otp_ptr).checksumTotal == checksumTotal){
+			(*otp_ptr).flag |= 0x10;
+		}
+	}
+	else {
+		for(i=0;i<186;i++) {
+			(* otp_ptr).lenc[i]=0;
+		}
+	}
+	for(i=0x7220;i<=0x73be;i++) 
+	{
+		OV13850_R2A_write_i2c(i,0); // clear OTP buffer, recommended use continuous write to accelarate
+	}
+
+	//set 0x5002[1] to "1"
+	temp1 = OV13850_R2A_read_i2c(0x5002);
+	OV13850_R2A_write_i2c(0x5002, (0x02 & 0x02) | (temp1 & (~0x02)));
+
+	return (*otp_ptr).flag;
+}
+
+
+// return value:
+// bit[7]: 0 no otp info, 1 valid otp info
+// bit[6]: 0 no otp wb, 1 valib otp wb
+// bit[5]: 0 no otp vcm, 1 valid otp vcm
+// bit[4]: 0 no otp lenc, 1 valid otp lenc
+int apply_otp(struct otp_struct *otp_ptr)
+{
+	int rg=0;
+	int bg=0;
+	int R_gain=0;
+	int G_gain=0;
+	int B_gain=0;
+	int Base_gain=0;
+	int temp=0;
+	int i=0;
+	unsigned char lenc_out[360];
+	LOG_INF(" apply_otp (*otp_ptr).flag : %x \n", (*otp_ptr).flag);
+	// apply OTP WB Calibration
+	if ((*otp_ptr).flag & 0x40) {
+		LOG_INF(" apply OTP WB Calibration : %x \n", (*otp_ptr).flag);
+		rg = (*otp_ptr).rg_ratio;
+		bg = (*otp_ptr).bg_ratio;
+
+		//calculate G gain
+		R_gain = (RG_Ratio_Typical*1000) / rg;
+		B_gain = (BG_Ratio_Typical*1000) / bg;
+		G_gain = 1000;
+
+		if (R_gain < 1000 || B_gain < 1000)
+		{
+			if (R_gain < B_gain)
+				Base_gain = R_gain;
+			else
+				Base_gain = B_gain;
+		}
+		else
+		{
+			Base_gain = G_gain;
+		}
+
+		R_gain = 0x400 * R_gain / (Base_gain);
+		B_gain = 0x400 * B_gain / (Base_gain);
+		G_gain = 0x400 * G_gain / (Base_gain);
+
+		// update sensor WB gain
+		if (R_gain>0x400) {
+			OV13850_R2A_write_i2c(0x5056, R_gain>>8);
+			OV13850_R2A_write_i2c(0x5057, R_gain & 0x00ff);
+		}
+
+		if (G_gain>0x400) {
+			OV13850_R2A_write_i2c(0x5058, G_gain>>8);
+			OV13850_R2A_write_i2c(0x5059, G_gain & 0x00ff);
+		}
+
+		if (B_gain>0x400) {
+			OV13850_R2A_write_i2c(0x505A, B_gain>>8);
+			OV13850_R2A_write_i2c(0x505B, B_gain & 0x00ff);
+		}
+	}
+
+	// apply OTP Lenc Calibration
+	if ((*otp_ptr).flag & 0x10) {
+		
+		LOG_INF(" apply OTP Lenc Calibration : %x \n", (*otp_ptr).flag);
+		temp = OV13850_R2A_read_i2c(0x5000);
+		temp = 0x01 | temp;
+		OV13850_R2A_write_i2c(0x5000, temp);
+
+		//Decode the lenc buffer from OTP , from 186 bytes to 360 bytes
+		
+		for(i=0;i<360;i++)
+		{
+			lenc_out[i] = 0;
+		}
+		/***For function Decode_13850R2A(unsigned char*pInBuf, unsigned char* pOutBuf),please refer to lc42.h***/
+		if(Decode_13850R2A((*otp_ptr).lenc,  lenc_out))
+		{
+			for(i=0;i<360 ;i++) {
+				LOG_INF(" apply OTP lenc_out[%d]:%x \n", i, lenc_out[i]);
+				OV13850_R2A_write_i2c(0x5200 + i, lenc_out[i]);
+			}
+		}
+	}
+}
+
+/***********Decode LENC Para Process Start*********************/
+void LumaDecoder(uint8_t *pData, uint8_t *pPara)
+{
+	
+	uint32_t Offset, Bit, Option;
+	uint32_t i, k;
+	uint8_t pCenter[16], pMiddle[32], pCorner[72];
+	Offset = pData[0];
+	Bit = pData[1]>>4;
+	Option = pData[1]&0xf;
+	LOG_INF("Offset:%x, Bit:%x, Option:%x \n",Offset, Bit, Option);
+	for (i=0; i<180; i++)
+	{
+		LOG_INF("data-pData[%d]:%x \n", i, pData[i]);
+	}
+	if(Bit <= 5)
+	{
+		for(i=0,k=2; i<120; i+=8,k+=5)
+		{
+			//LOG_INF("pData[%d]:%x \n", i, pData[i]);
+			pPara[i] = pData[k]>>3; // 7~3 (byte0)
+			pPara[i+1] = ((pData[k]&0x7)<<2)|(pData[k+1]>>6); // 2~0 (byte0) and 7~6(byte1)
+			pPara[i+2] = (pData[k+1]&0x3e)>>1; // 5~1 (byte1)
+			pPara[i+3] = ((pData[k+1]&0x1)<<4)|(pData[k+2]>>4); // 0 (byte1) and 7~4(byte2)
+			pPara[i+4] = ((pData[k+2]&0xf)<<1)|(pData[k+3]>>7); // 3~0 (byte2) and 7(byte3)
+			pPara[i+5] = (pData[k+3]&0x7c)>>2; // 6~2 (byte3)
+			pPara[i+6] = ((pData[k+3]&0x3)<<3)|(pData[k+4]>>5); // 1~0 (byte3) and 7~5(byte4)
+			pPara[i+7] = pData[k+4]&0x1f; // 4~0 (byte4)
+
+			LOG_INF("bit-pData[%d]:%x \n", k, pData[k]);
+			LOG_INF("bit-pData[%d]:%x \n", k+1, pData[k+1]);
+			LOG_INF("bit-pData[%d]:%x \n", k+2, pData[k+2]);
+			LOG_INF("bit-pData[%d]:%x \n", k+3, pData[k+3]);
+			LOG_INF("bit-pData[%d]:%x \n", k+4, pData[k+4]);
+
+			
+			LOG_INF("bit-pData[%d]:%x \n", i, pPara[i]);
+			LOG_INF("bit-pData[%d]:%x \n", i+1, pPara[i+1]);
+			LOG_INF("bit-pData[%d]:%x \n", i+2, pPara[i+2]);
+			LOG_INF("bit-pData[%d]:%x \n", i+3, pPara[i+3]);
+			LOG_INF("bit-pData[%d]:%x \n", i+4, pPara[i+4]);
+			LOG_INF("bit-pData[%d]:%x \n", i+5, pPara[i+5]);
+			LOG_INF("bit-pData[%d]:%x \n", i+6, pPara[i+6]);
+			LOG_INF("bit-pData[%d]:%x \n", i+7, pPara[i+7]);
+		}
+	}
+	else
+	{
+		for(i=0,k=2; i<48; i+=8,k+=5)
+		{
+			//LOG_INF(" apData[%d]:%x \n", i, pData[i]);
+			pPara[i] = pData[k]>>3; // 7~3 (byte0)
+			pPara[i+1] = ((pData[k]&0x7)<<2)|(pData[k+1]>>6); // 2~0 (byte0) and 7~6(byte1)
+			pPara[i+2] = (pData[k+1]&0x3e)>>1; // 5~1 (byte1)
+			pPara[i+3] = ((pData[k+1]&0x1)<<4)|(pData[k+2]>>4); // 0 (byte1) and 7~4(byte2)
+			pPara[i+4] = ((pData[k+2]&0xf)<<1)|(pData[k+3]>>7); // 3~0 (byte2) and 7(byte3)
+			pPara[i+5] = (pData[k+3]&0x7c)>>2; // 6~2 (byte3)
+			pPara[i+6] = ((pData[k+3]&0x3)<<3)|(pData[k+4]>>5); // 1~0 (byte3) and 7~5(byte4)
+			pPara[i+7] = pData[k+4]&0x1f; // 4~0 (byte4)
+
+			LOG_INF("else -pData[%d]:%x \n", i, pData[i]);
+			LOG_INF("else -pData[%d]:%x \n", i+1, pData[i+1]);
+			LOG_INF("else -pData[%d]:%x \n", i+2, pData[i+2]);
+			LOG_INF("else -pData[%d]:%x \n", i+3, pData[i+3]);
+			LOG_INF("else -pData[%d]:%x \n", i+4, pData[i+4]);
+			LOG_INF("else -pData[%d]:%x \n", i+5, pData[i+5]);
+			LOG_INF("else -pData[%d]:%x \n", i+6, pData[i+6]);
+			LOG_INF("else -pData[%d]:%x \n", i+7, pData[i+7]);
+		}
+		for(i=48,k=32; i<120; i+=4,k+=3)
+		{
+			//LOG_INF(" 48--pData[%d]:%x \n", i, pData[i]);
+			pPara[i] = pData[k]>>2; // 7~2 (byte0)
+			pPara[i+1] = ((pData[k]&0x3)<<4)|(pData[k+1]>>4); //1~0 (byte0) and7~4(byte1)
+			pPara[i+2] = ((pData[k+1]&0xf)<<2)|(pData[k+2]>>6); //3~0 (byte1) and7~6(byte2)
+			pPara[i+3] = pData[k+2]&0x3f; // 5~0 (byte2)
+
+			LOG_INF("48--pData[%d]:%x \n", i, pData[i]);
+			LOG_INF("48--pData[%d]:%x \n", i+1, pData[i+1]);
+			LOG_INF("48--pData[%d]:%x \n", i+2, pData[i+2]);
+			LOG_INF("48--pData[%d]:%x \n", i+3, pData[i+3]);
+		}
+		memcpy(pCenter, pPara, 16);
+		memcpy(pMiddle, pPara+16, 32);
+		memcpy(pCorner, pPara+48, 72);
+		for(i=0; i<32; i++)
+		{
+			pMiddle[i] <<= (Bit-6);
+		}
+		for(i=0; i<72; i++)
+		{
+			pCorner[i] <<= (Bit-6);
+		}
+	if(Option == 0)
+	{ // 10x12
+		memcpy(pPara, pCorner, 26);
+		memcpy(pPara+26, pMiddle, 8);
+		memcpy(pPara+34, pCorner+26, 4);
+		memcpy(pPara+38, pMiddle+8, 2);
+		memcpy(pPara+40, pCenter, 4);
+		memcpy(pPara+44, pMiddle+10, 2);
+		memcpy(pPara+46, pCorner+30, 4);
+		memcpy(pPara+50, pMiddle+12, 2);
+		memcpy(pPara+52, pCenter+4, 4);
+		memcpy(pPara+56, pMiddle+14, 2);
+		memcpy(pPara+58, pCorner+34, 4);
+		memcpy(pPara+62, pMiddle+16, 2);
+		memcpy(pPara+64, pCenter+8, 4);
+		memcpy(pPara+68, pMiddle+18, 2);
+		memcpy(pPara+70, pCorner+38, 4);
+		memcpy(pPara+74, pMiddle+20, 2);
+		memcpy(pPara+76, pCenter+12, 4);
+		memcpy(pPara+80, pMiddle+22, 2);
+		memcpy(pPara+82, pCorner+42, 4);
+		memcpy(pPara+86, pMiddle+24, 8);
+		memcpy(pPara+94, pCorner+46, 26);
+	}
+	else
+	{ // 12x10
+		memcpy(pPara, pCorner, 22);
+		memcpy(pPara+22, pMiddle, 6);
+		memcpy(pPara+28, pCorner+22, 4);
+		memcpy(pPara+32, pMiddle+6, 6);
+		memcpy(pPara+38, pCorner+26, 4);
+		memcpy(pPara+42, pMiddle+12, 1);
+		memcpy(pPara+43, pCenter, 4);
+		memcpy(pPara+47, pMiddle+13, 1);
+		memcpy(pPara+48, pCorner+30, 4);
+		memcpy(pPara+52, pMiddle+14, 1);
+		memcpy(pPara+53, pCenter+4, 4);
+		memcpy(pPara+57, pMiddle+15, 1);
+		memcpy(pPara+58, pCorner+34, 4);
+		memcpy(pPara+62, pMiddle+16, 1);
+		memcpy(pPara+63, pCenter+8, 4);
+		memcpy(pPara+67, pMiddle+17, 1);
+		memcpy(pPara+68, pCorner+38, 4);
+		memcpy(pPara+72, pMiddle+18, 1);
+		memcpy(pPara+73, pCenter+12, 4);
+		memcpy(pPara+77, pMiddle+19, 1);
+		memcpy(pPara+78, pCorner+42, 4);
+		memcpy(pPara+82, pMiddle+20, 6);
+		memcpy(pPara+88, pCorner+46, 4);
+		memcpy(pPara+92, pMiddle+26, 6);
+		memcpy(pPara+98, pCorner+50, 22);
+	}
+ }
+	for(i=0; i<120; i++)
+	{
+		LOG_INF(" pPara[%d]:%x \n", i, pPara[i]);
+		pPara[i] += Offset;
+	}
+
+}
+//
+void ColorDecoder(uint8_t *pData, uint8_t *pPara)
+{
+	
+	uint32_t Offset, Bit, Option;
+	uint32_t i, k;
+	uint8_t pBase[30];
+	Offset = pData[0];
+	Bit = pData[1]>>7;
+	Option = (pData[1]&0x40)>>6;
+	pPara[0] = (pData[1]&0x3e)>>1; // 5~1 (byte1)
+	pPara[1] = ((pData[1]&0x1)<<4)|(pData[2]>>4); // 0 (byte1) and 7~4 (byte2)
+	pPara[2] = ((pData[2]&0xf)<<1)|(pData[3]>>7); // 3~0 (byte2) and 7 (byte3)
+	pPara[3] = (pData[3]&0x7c)>>2; // 6~2 (byte3)
+	pPara[4] = ((pData[3]&0x3)<<3)|(pData[4]>>5); // 1~0 (byte3) and 7~5 (byte4)
+	pPara[5] = pData[4]&0x1f; // 4~0 (byte4)
+	for(i=6,k=5; i<30; i+=8,k+=5)
+	{
+		pPara[i] = pData[k]>>3; // 7~3 (byte0)
+		pPara[i+1] = ((pData[k]&0x7)<<2)|(pData[k+1]>>6); // 2~0 (byte0) and 7~6 (byte1)
+		pPara[i+2] = (pData[k+1]&0x3e)>>1; // 5~1 (byte1)
+		pPara[i+3] = ((pData[k+1]&0x1)<<4)|(pData[k+2]>>4); // 0 (byte1) and 7~4 (byte2)
+		pPara[i+4] = ((pData[k+2]&0xf)<<1)|(pData[k+3]>>7); // 3~0 (byte2) and 7 (byte3)
+		pPara[i+5] = (pData[k+3]&0x7c)>>2; // 6~2 (byte3)
+		pPara[i+6] = ((pData[k+3]&0x3)<<3)|(pData[k+4]>>5); // 1~0 (byte3) and 7~5 (byte4)
+		pPara[i+7] = pData[k+4]&0x1f; // 4~0 (byte4)
+	}
+	memcpy(pBase, pPara, 30);
+	for(i=0,k=20; i<120; i+=4,k++)
+	{
+		pPara[i] = pData[k]>>6;
+		pPara[i+1] = (pData[k]&0x30)>>4;
+		pPara[i+2] = (pData[k]&0xc)>>2;
+		pPara[i+3] = pData[k]&0x3;
+	}
+	if(Option == 0)
+	{ // 10x12
+		for(i=0; i<5; i++)
+		{
+			for(k=0; k<6; k++)
+			{
+				pPara[i*24+k*2] += pBase[i*6+k];
+				pPara[i*24+k*2+1] += pBase[i*6+k];
+				pPara[i*24+k*2+12] += pBase[i*6+k];
+				pPara[i*24+k*2+13] += pBase[i*6+k];
+			}
+		}
+	}else
+	{ // 12x10
+		for(i=0; i<6; i++)
+		{
+			for(k=0; k<5; k++)
+			{
+				pPara[i*20+k*2] += pBase[i*5+k];
+				pPara[i*20+k*2+1] += pBase[i*5+k];
+				pPara[i*20+k*2+10] += pBase[i*5+k];
+				pPara[i*20+k*2+11] += pBase[i*5+k];
+			}
+		}
+	}
+	for(i=0; i<120; i++)
+	{
+		pPara[i] = (pPara[i]<<Bit) + Offset;
+	}
+	
+}
+//
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/ov13850_mipi_raw/ov13850mipiraw_CameraCustomized.h b/drivers/misc/mediatek/imgsensor/src/mt6735/ov13850_mipi_raw/ov13850mipiraw_CameraCustomized.h
new file mode 100644
index 0000000..224f236
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735/ov13850_mipi_raw/ov13850mipiraw_CameraCustomized.h
@@ -0,0 +1,65 @@
+/*******************************************************************************************/
+
+
+/*******************************************************************************************/
+
+
+#ifndef __CAMERA_CUSTOMIZED_H
+#define __CAMERA_CUSTOMIZED_H
+
+// the angle between handset and sensor placement in clockwise, should be one of 0, 90, 270
+#define MAIN_SENSOR_ORIENTATION_ANGLE    90
+#define SUB_SENSOR_ORIENTATION_ANGLE      0                  // do not care if the sub sensor does not exist
+
+
+// First, we think you hold the cell phone vertical.
+// Second, we suppose the direction of upward is 0  
+// Third, it is 90, 180, 270 in clockwise
+// here we define the main sensor and sub sensor angles to deal with the jpeg orientation
+#define MAIN_SENSOR_TO_PHONE_ANGLE        90
+#define SUB_SENSOR_TO_PHONE_ANGLE           0
+
+
+#define CAM_SIZE_QVGA_WIDTH         320
+#define CAM_SIZE_QVGA_HEIGHT        240
+#define CAM_SIZE_VGA_WIDTH            640
+#define CAM_SIZE_VGA_HEIGHT           480
+#define CAM_SIZE_05M_WIDTH            800
+#define CAM_SIZE_05M_HEIGHT           600
+#define CAM_SIZE_1M_WIDTH              1280
+#define CAM_SIZE_1M_HEIGHT             960
+#define CAM_SIZE_2M_WIDTH              1600
+#define CAM_SIZE_2M_HEIGHT             1200
+#define CAM_SIZE_3M_WIDTH              2048
+#define CAM_SIZE_3M_HEIGHT             1536
+#define CAM_SIZE_5M_WIDTH              2592
+#define CAM_SIZE_5M_HEIGHT             1944
+
+// for main sensor
+#define MAIN_NUM_OF_PREVIEW_RESOLUTION 3
+#define MAIN_NUM_OF_VIDEO_RESOLUTION 4
+#define MAIN_NUM_OF_STILL_RESOLUTION 7
+#define MAIN_VIDEO_RESOLUTION_PROFILE           {{176,144},{320,240},{640,480},{720,480}}
+#define MAIN_PREVIEW_RESOLUTION_PROFILE      {{232,174},{320,240},{240,320}}
+#define MAIN_STILL_RESOLUTION_PROFILE            {{CAM_SIZE_QVGA_WIDTH,CAM_SIZE_QVGA_HEIGHT}, \
+                                                                         {CAM_SIZE_VGA_WIDTH,CAM_SIZE_VGA_HEIGHT}, \
+                                                                         {CAM_SIZE_05M_WIDTH,CAM_SIZE_05M_HEIGHT}, \
+                                                                         {CAM_SIZE_1M_WIDTH,CAM_SIZE_1M_HEIGHT}, \
+                                                                         {CAM_SIZE_2M_WIDTH,CAM_SIZE_2M_HEIGHT}, \
+                                                                         {CAM_SIZE_3M_WIDTH,CAM_SIZE_3M_HEIGHT}, \
+                                                                         {CAM_SIZE_5M_WIDTH,CAM_SIZE_5M_HEIGHT}}
+
+// if sub sensor does not exist, set all the parameters as 0
+#define SUB_NUM_OF_PREVIEW_RESOLUTION           0
+#define SUB_NUM_OF_VIDEO_RESOLUTION                0
+#define SUB_NUM_OF_STILL_RESOLUTION                 0
+#define SUB_VIDEO_RESOLUTION_PROFILE                {{0,0}}
+#define SUB_PREVIEW_RESOLUTION_PROFILE           {{0,0}}
+#define SUB_STILL_RESOLUTION_PROFILE                 {{0,0}}
+
+//#define NUM_OF_PREVIEW_RESOLUTION 	max(MAIN_NUM_OF_PREVIEW_RESOLUTION,SUB_NUM_OF_PREVIEW_RESOLUTION)
+//#define NUM_OF_VIDEO_RESOLUTION 	max(MAIN_NUM_OF_VIDEO_RESOLUTION,SUB_NUM_OF_VIDEO_RESOLUTION)
+//#define NUM_OF_STILL_RESOLUTION 	max(MAIN_NUM_OF_STILL_RESOLUTION,SUB_NUM_OF_STILL_RESOLUTION)
+
+#define NUM_OF_VIDEO_STREAM_BUFF            8           // Maximun is 8
+#endif
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/ov13850_mipi_raw/ov13850mipiraw_Camera_Sensor_para.h b/drivers/misc/mediatek/imgsensor/src/mt6735/ov13850_mipi_raw/ov13850mipiraw_Camera_Sensor_para.h
new file mode 100644
index 0000000..5bbdb9c
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735/ov13850_mipi_raw/ov13850mipiraw_Camera_Sensor_para.h
@@ -0,0 +1,60 @@
+/*******************************************************************************************/
+
+
+/*******************************************************************************************/
+
+/* SENSOR FULL SIZE */
+#ifndef __CAMERA_SENSOR_PARA_H
+#define __CAMERA_SENSOR_PARA_H
+
+#define CAMERA_SENSOR_REG_DEFAULT_VALUE  \
+    /* ARRAY: SENSOR.reg[11] */\
+    {\
+        /* STRUCT: SENSOR.reg[0] */\
+        {\ 
+            /* SENSOR.reg[0].addr */ 0x00000304, /* SENSOR.reg[0].para */ 0x00000000\
+        },\
+        /* STRUCT: SENSOR.reg[1] */\
+        {\
+            /* SENSOR.reg[1].addr */ 0x00000305, /* SENSOR.reg[1].para */ 0x0000000D\
+        },\
+        /* STRUCT: SENSOR.reg[2] */\
+        {\
+            /* SENSOR.reg[2].addr */ 0x00000306, /* SENSOR.reg[2].para */ 0x00000000\
+        },\
+        /* STRUCT: SENSOR.reg[3] */\
+        {\
+            /* SENSOR.reg[3].addr */ 0x00000307, /* SENSOR.reg[3].para */ 0x000000C0\
+        },\
+        /* STRUCT: SENSOR.reg[4] */\
+        {\
+            /* SENSOR.reg[4].addr */ 0x00000300, /* SENSOR.reg[4].para */ 0x00000000\
+        },\
+        /* STRUCT: SENSOR.reg[5] */\
+        {\
+            /* SENSOR.reg[5].addr */ 0x00000301, /* SENSOR.reg[5].para */ 0x00000004\
+        },\
+        /* STRUCT: SENSOR.reg[6] */\
+        {\
+            /* SENSOR.reg[6].addr */ 0x0000030A, /* SENSOR.reg[6].para */ 0x00000000\
+        },\
+        /* STRUCT: SENSOR.reg[7] */\
+        {\
+            /* SENSOR.reg[7].addr */ 0x0000030B, /* SENSOR.reg[7].para */ 0x00000002\
+        },\
+        /* STRUCT: SENSOR.reg[8] */\
+        {\
+            /* SENSOR.reg[8].addr */ 0x00000308, /* SENSOR.reg[8].para */ 0x00000000\
+        },\
+        /* STRUCT: SENSOR.reg[9] */\
+        {\
+            /* SENSOR.reg[9].addr */ 0x00000309, /* SENSOR.reg[9].para */ 0x00000008\
+        },\
+        /* STRUCT: SENSOR.reg[10] */\
+        {\
+            /* SENSOR.reg[10].addr */ 0xFFFFFFFF, /* SENSOR.reg[10].para */ 0x00000001\
+        }\
+}
+
+#define CAMERA_SENSOR_CCT_DEFAULT_VALUE {{ 0xFFFFFFFF, 0x08 } ,{ 0x0205, 0x20 } ,{ 0x020e, 0x01 } ,{ 0x0210, 0x01 } ,{ 0x0212, 0x01 }}
+#endif /* __CAMERA_SENSOR_PARA_H */
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/ov13850_mipi_raw/ov13850mipiraw_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735/ov13850_mipi_raw/ov13850mipiraw_Sensor.c
new file mode 100755
index 0000000..cb82916
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735/ov13850_mipi_raw/ov13850mipiraw_Sensor.c
@@ -0,0 +1,2081 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *     OV13850mipi_Sensor.c
+ *
+ * Project:
+ * --------
+ *     ALPS
+ *
+ * Description:
+ * ------------
+ *     Source code of Sensor driver
+ *
+ *
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *============================================================================
+ ****************************************************************************/
+
+#include <linux/videodev2.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <asm/atomic.h>
+//#include <asm/system.h>
+#include <linux/xlog.h>
+
+#include "kd_camera_hw.h"
+#include "kd_imgsensor.h"
+#include "kd_imgsensor_define.h"
+#include "kd_imgsensor_errcode.h"
+
+#include "ov13850mipiraw_Sensor.h"
+
+/****************************Modify Following Strings for Debug****************************/
+#define PFX "OV13850_camera_sensor"
+#define LOG_1 LOG_INF("OV13850,MIPI 4LANE\n")
+#define LOG_2 LOG_INF("preview 2096*1552@30fps,640Mbps/lane; video 4192*3104@30fps,1.2Gbps/lane; capture 13M@30fps,1.2Gbps/lane\n")
+/****************************   Modify end    *******************************************/
+
+#define LOG_INF(format, args...)    xlog_printk(ANDROID_LOG_INFO   , PFX, "[%s] " format, __FUNCTION__, ##args)
+
+static DEFINE_SPINLOCK(imgsensor_drv_lock);
+#define MIPI_SETTLEDELAY_AUTO     0
+#define MIPI_SETTLEDELAY_MANNUAL  1
+
+int ov13850_chip_ver = OV13850_R2A;
+//sensor otp
+extern void otp_cali(unsigned char writeid);
+
+static imgsensor_info_struct imgsensor_info = {
+    .sensor_id = OV13850_SENSOR_ID,        //record sensor id defined in Kd_imgsensor.h
+
+    .checksum_value = 0xbde6b5f8,//0xf86cfdf4,        //checksum value for Camera Auto Test
+
+    .pre = {
+        .pclk = 240000000,                //record different mode's pclk
+        .linelength = 2400,                //record different mode's linelength
+        .framelength = 3328,            //record different mode's framelength
+        .startx = 0,                    //record different mode's startx of grabwindow
+        .starty = 0,                    //record different mode's starty of grabwindow
+        .grabwindow_width = 2096,        //record different mode's width of grabwindow
+        .grabwindow_height = 1552,        //record different mode's height of grabwindow
+        /*     following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario    */
+        .mipi_data_lp2hs_settle_dc = 100,//unit , ns
+        /*     following for GetDefaultFramerateByScenario()    */
+        .max_framerate = 300,
+    },
+    .cap = {
+        .pclk = 480000000,
+        .linelength = 4800,
+        .framelength = 3328,
+        .startx = 0,
+        .starty = 0,
+        .grabwindow_width = 4192, //4192,
+        .grabwindow_height = 3104,//3104,
+        .mipi_data_lp2hs_settle_dc = 100,//unit , ns
+        .max_framerate = 300,
+    },
+    .cap1 = {                            //capture for PIP 24fps relative information, capture1 mode must use same framelength, linelength with Capture mode for shutter calculate
+        .pclk = 384000000,
+        .linelength = 4800,
+        .framelength = 3328,
+        .startx = 0,
+        .starty = 0,
+        .grabwindow_width = 4192,
+        .grabwindow_height = 3104,
+        .mipi_data_lp2hs_settle_dc = 100,//unit , ns
+        .max_framerate = 150,    //less than 13M(include 13M),cap1 max framerate is 24fps,16M max framerate is 20fps, 20M max framerate is 15fps
+    },
+    .normal_video = {
+        .pclk = 480000000,
+        .linelength = 4800,
+        .framelength = 3328,
+        .startx = 0,
+        .starty = 0,
+        .grabwindow_width = 4192,
+        .grabwindow_height = 3104,
+        .mipi_data_lp2hs_settle_dc = 100,//unit , ns
+        .max_framerate = 300,
+    },
+    .hs_video = {
+        .pclk = 240000000,
+        .linelength = 2968,
+        .framelength = 674,
+        .startx = 0,
+        .starty = 0,
+        .grabwindow_width = 640,
+        .grabwindow_height = 480,
+        .mipi_data_lp2hs_settle_dc = 100,//unit , ns
+        .max_framerate = 1200,
+    },
+    .slim_video = {
+        .pclk = 240000000,
+        .linelength = 9600,//2400,
+        .framelength = 834,//3328,
+        .startx = 0,
+        .starty = 0,
+        .grabwindow_width = 1280,
+        .grabwindow_height = 720,
+        .mipi_data_lp2hs_settle_dc = 100,//unit , ns
+        .max_framerate = 300,
+
+    },
+    .margin = 8,            //sensor framelength & shutter margin
+    .min_shutter = 0x3,        //min shutter
+    .max_frame_length = 0x7fff,//max framelength by sensor register's limitation
+    .ae_shut_delay_frame = 0,    //shutter delay frame for AE cycle, 2 frame with ispGain_delay-shut_delay=2-0=2
+    .ae_sensor_gain_delay_frame = 0,//sensor gain delay frame for AE cycle,2 frame with ispGain_delay-sensor_gain_delay=2-0=2
+    .ae_ispGain_delay_frame = 2,//isp gain delay frame for AE cycle
+    .ihdr_support = 0,      //1, support; 0,not support
+    .ihdr_le_firstline = 0,  //1,le first ; 0, se first
+    .sensor_mode_num = 5,      //support sensor mode num
+
+    .cap_delay_frame = 3,        //enter capture delay frame num
+    .pre_delay_frame = 2,         //enter preview delay frame num
+    .video_delay_frame = 2,        //enter video delay frame num
+    .hs_video_delay_frame = 2,    //enter high speed video  delay frame num
+    .slim_video_delay_frame = 2,//enter slim video delay frame num
+
+    .isp_driving_current = ISP_DRIVING_8MA, //mclk driving current
+    .sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,//sensor_interface_type
+    .mipi_sensor_type = MIPI_OPHY_NCSI2, //0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2
+    .mipi_settle_delay_mode = MIPI_SETTLEDELAY_AUTO,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
+    .sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_B,//sensor output first pixel color
+    .mclk = 24,//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
+    .mipi_lane_num = SENSOR_MIPI_4_LANE,//mipi lane num
+    .i2c_addr_table = {0x6c, 0x20, 0xff},//record sensor support all write id addr, only supprt 4must end with 0xff
+};
+
+
+static imgsensor_struct imgsensor = {
+    .mirror = IMAGE_H_MIRROR,                //mirrorflip information
+    .sensor_mode = IMGSENSOR_MODE_INIT, //IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
+    .shutter = 0x3D0,                    //current shutter
+    .gain = 0x100,                        //current gain
+    .dummy_pixel = 0,                    //current dummypixel
+    .dummy_line = 0,                    //current dummyline
+    .current_fps = 0,  //full size current fps : 24fps for PIP, 30fps for Normal or ZSD
+    .autoflicker_en = KAL_FALSE,  //auto flicker enable: KAL_FALSE for disable auto flicker, KAL_TRUE for enable auto flicker
+    .test_pattern = KAL_FALSE,        //test pattern mode or not. KAL_FALSE for in test pattern mode, KAL_TRUE for normal output
+    .current_scenario_id = MSDK_SCENARIO_ID_CAMERA_PREVIEW,//current scenario id
+    .ihdr_en = 0, //sensor need support LE, SE with HDR feature
+    .i2c_write_id = 0x00,//record current sensor's i2c write id
+};
+
+
+/* Sensor output window information */
+#if 0
+static SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[5] =
+{{ 4208, 3120, 0, 0, 4208, 3120, 2104, 1560, 0, 0, 2104, 1560, 0, 0, 2096, 1552}, // Preview 
+ { 4208, 3120, 0, 0, 4208, 3120, 4208, 3120, 0, 0, 4208, 3120, 0, 0, 4192, 3104}, // capture 
+  { 4208, 3120, 0, 0, 4208, 3120, 4208, 3120, 0, 0, 4208, 3120, 0, 0, 4192, 3104}, // video 
+{ 4208, 3120, 0, 0, 4208, 3120, 2104, 1560, 0, 0, 1056, 594, 0, 0, 640, 480}, //hight speed video 
+	{ 4208, 3120, 0, 0, 4208, 3120, 1296, 730, 0, 0, 1296, 730, 0, 0, 1280, 720}, 
+
+};
+#else
+static SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[5] =
+{{ 4256, 3152, 0, 4, 4256, 3152, 2128, 1572, 8, 2, 2112, 1568, 0, 0, 2096, 1552}, // Preview 
+ { 4256, 3152, 12, 4, 4232, 3144, 4232, 3144, 4, 4, 4224, 3136, 0, 0, 4192, 3104}, // capture 
+ {  4256, 3152, 20, 12,  4216, 3128, 4216, 3128, 4, 4, 4208, 3120, 0, 0, 4192, 3104}, // video 
+ { 4256, 3152, 0, 376, 4256, 2392, 1064, 598, 8, 2, 1056, 594, 208, 56, 640, 480}, //hight speed video 
+ { 4256, 3152, 824, 842, 2608, 1468, 1304, 734, 4, 2, 1296, 730, 0, 0, 1280, 720}};// slim video 
+
+#endif
+
+static kal_uint16 read_cmos_sensor(kal_uint32 addr)
+{
+    kal_uint16 get_byte=0;
+
+    char pu_send_cmd[2] = {(char)(addr >> 8), (char)(addr & 0xFF) };
+    iReadRegI2C(pu_send_cmd, 2, (u8*)&get_byte, 1, imgsensor.i2c_write_id);
+
+    return get_byte;
+}
+
+static void write_cmos_sensor(kal_uint32 addr, kal_uint32 para)
+{
+    char pu_send_cmd[3] = {(char)(addr >> 8), (char)(addr & 0xFF), (char)(para & 0xFF)};
+    iWriteRegI2C(pu_send_cmd, 3, imgsensor.i2c_write_id);
+}
+
+static void set_dummy()
+{
+    LOG_INF("dummyline = %d, dummypixels = %d \n", imgsensor.dummy_line, imgsensor.dummy_pixel);
+    /* you can set dummy by imgsensor.dummy_line and imgsensor.dummy_pixel, or you can set dummy by imgsensor.frame_length and imgsensor.line_length */
+    write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
+    write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
+    write_cmos_sensor(0x380c, imgsensor.line_length >> 8);
+    write_cmos_sensor(0x380d, imgsensor.line_length & 0xFF);
+
+}    /*    set_dummy  */
+
+static kal_uint32 return_sensor_id()
+{
+    return ((read_cmos_sensor(0x300A) << 8) | read_cmos_sensor(0x300B));
+}
+static void set_max_framerate(UINT16 framerate,kal_bool min_framelength_en)
+{
+    kal_int16 dummy_line;
+    kal_uint32 frame_length = imgsensor.frame_length;
+    //unsigned long flags;
+
+    LOG_INF("framerate = %d, min framelength should enable = %d \n", framerate,min_framelength_en);
+
+    frame_length = imgsensor.pclk / framerate * 10 / imgsensor.line_length;
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.frame_length = (frame_length > imgsensor.min_frame_length) ? frame_length : imgsensor.min_frame_length;
+    imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
+    //dummy_line = frame_length - imgsensor.min_frame_length;
+    //if (dummy_line < 0)
+        //imgsensor.dummy_line = 0;
+    //else
+        //imgsensor.dummy_line = dummy_line;
+    //imgsensor.frame_length = frame_length + imgsensor.dummy_line;
+    if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+    {
+        imgsensor.frame_length = imgsensor_info.max_frame_length;
+        imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
+    }
+    if (min_framelength_en)
+        imgsensor.min_frame_length = imgsensor.frame_length;
+    spin_unlock(&imgsensor_drv_lock);
+    set_dummy();
+}    /*    set_max_framerate  */
+
+
+
+/*************************************************************************
+* FUNCTION
+*    set_shutter
+*
+* DESCRIPTION
+*    This function set e-shutter of sensor to change exposure time.
+*
+* PARAMETERS
+*    iShutter : exposured lines
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static void set_shutter(kal_uint16 shutter)
+{
+    unsigned long flags;
+    kal_uint16 realtime_fps = 0;
+    kal_uint32 frame_length = 0;
+    spin_lock_irqsave(&imgsensor_drv_lock, flags);
+    imgsensor.shutter = shutter;
+    spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
+	LOG_INF("Enter! shutter =%d \n", shutter);
+
+    //write_shutter(shutter);
+    /* 0x3500, 0x3501, 0x3502 will increase VBLANK to get exposure larger than frame exposure */
+    /* AE doesn't update sensor gain at capture mode, thus extra exposure lines must be updated here. */
+
+    // OV Recommend Solution
+    // if shutter bigger than frame_length, should extend frame length first
+    spin_lock(&imgsensor_drv_lock);
+    if (shutter > imgsensor.min_frame_length - imgsensor_info.margin)
+        imgsensor.frame_length = shutter + imgsensor_info.margin;
+    else
+        imgsensor.frame_length = imgsensor.min_frame_length;
+    if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+        imgsensor.frame_length = imgsensor_info.max_frame_length;
+    spin_unlock(&imgsensor_drv_lock);
+    shutter = (shutter < imgsensor_info.min_shutter) ? imgsensor_info.min_shutter : shutter;
+    shutter = (shutter > (imgsensor_info.max_frame_length - imgsensor_info.margin)) ? (imgsensor_info.max_frame_length - imgsensor_info.margin) : shutter;
+
+    if (imgsensor.autoflicker_en) {
+        realtime_fps = imgsensor.pclk / imgsensor.line_length * 10 / imgsensor.frame_length;
+        if(realtime_fps >= 297 && realtime_fps <= 305)
+            set_max_framerate(296,0);
+        else if(realtime_fps >= 147 && realtime_fps <= 150)
+            set_max_framerate(146,0);
+        else {
+        // Extend frame length
+        write_cmos_sensor(0x380e, (imgsensor.frame_length >> 8)&0x7f);
+        write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
+        }
+    } else {
+        // Extend frame length
+        //write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
+        //write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
+         write_cmos_sensor(0x380e, (imgsensor.frame_length >> 8)&0x7f);
+        write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
+    }
+
+    // Update Shutter
+   // write_cmos_sensor(0x3502, (shutter << 4) & 0xFF);
+   // write_cmos_sensor(0x3501, (shutter >> 4) & 0xFF);
+   // write_cmos_sensor(0x3500, (shutter >> 12) & 0x0F);
+		write_cmos_sensor(0x3500, (shutter>>12) & 0x0F);
+		write_cmos_sensor(0x3501, (shutter>>4) & 0xFF);
+		write_cmos_sensor(0x3502, (shutter<<4) & 0xF0);	
+    LOG_INF("Exit! shutter =%d, framelength =%d\n", shutter,imgsensor.frame_length);
+
+}    /*    set_shutter */
+
+
+
+static kal_uint16 gain2reg(const kal_uint16 gain)
+{
+	kal_uint16 iReg = 0x0000;
+	kal_uint16 iGain=gain;
+
+	if (ov13850_chip_ver == OV13850_R1A)
+	{
+		iReg = gain*32/BASEGAIN;
+		if(iReg < 0x20)
+		{
+			iReg = 0x20;
+		}
+		if(iReg > 0xfc)
+		{
+			iReg = 0xfc;
+		}
+		//SENSORDB("[OV13850Gain2Reg]: isp gain:%d,sensor gain:0x%x\n",iGain,iReg);
+	}
+	else if(ov13850_chip_ver == OV13850_R2A)
+	{
+		iReg = gain*16/BASEGAIN;
+		if(iReg < 0x10)
+		{
+			iReg = 0x10;
+		}
+		if(iReg > 0xf8)
+		{
+			iReg = 0xf8;
+		}
+	}
+	return iReg;//ov13850. sensorGlobalGain
+}
+
+/*************************************************************************
+* FUNCTION
+*    set_gain
+*
+* DESCRIPTION
+*    This function is to set global gain to sensor.
+*
+* PARAMETERS
+*    iGain : sensor global gain(base: 0x40)
+*
+* RETURNS
+*    the actually gain set to sensor.
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint16 set_gain(kal_uint16 gain)
+{
+    kal_uint16 reg_gain;
+ 
+		reg_gain = gain2reg(gain);
+		spin_lock(&imgsensor_drv_lock);
+		imgsensor.gain = reg_gain; 
+		spin_unlock(&imgsensor_drv_lock);
+		LOG_INF("gain = %d , reg_gain = 0x%x\n ", gain, reg_gain);
+	
+		write_cmos_sensor(0x350a, reg_gain >> 8);
+		write_cmos_sensor(0x350b, reg_gain & 0xFF);    
+		
+		return gain;
+}    /*    set_gain  */
+
+static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gain)
+{
+    LOG_INF("le:0x%x, se:0x%x, gain:0x%x\n",le,se,gain);
+    if (imgsensor.ihdr_en) {
+
+        spin_lock(&imgsensor_drv_lock);
+        if (le > imgsensor.min_frame_length - imgsensor_info.margin)
+            imgsensor.frame_length = le + imgsensor_info.margin;
+        else
+            imgsensor.frame_length = imgsensor.min_frame_length;
+        if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+            imgsensor.frame_length = imgsensor_info.max_frame_length;
+        spin_unlock(&imgsensor_drv_lock);
+        if (le < imgsensor_info.min_shutter) le = imgsensor_info.min_shutter;
+        if (se < imgsensor_info.min_shutter) se = imgsensor_info.min_shutter;
+
+
+        // Extend frame length first
+        write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
+        write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
+
+        write_cmos_sensor(0x3502, (le << 4) & 0xFF);
+        write_cmos_sensor(0x3501, (le >> 4) & 0xFF);
+        write_cmos_sensor(0x3500, (le >> 12) & 0x0F);
+
+        write_cmos_sensor(0x3508, (se << 4) & 0xFF);
+        write_cmos_sensor(0x3507, (se >> 4) & 0xFF);
+        write_cmos_sensor(0x3506, (se >> 12) & 0x0F);
+
+        set_gain(gain);
+    }
+
+}
+
+
+
+static void set_mirror_flip(kal_uint8 image_mirror)
+{
+    LOG_INF("image_mirror = %d\n", image_mirror);
+
+    /********************************************************
+       *
+       *   0x3820[2] ISP Vertical flip
+       *   0x3820[1] Sensor Vertical flip
+       *
+       *   0x3821[2] ISP Horizontal mirror
+       *   0x3821[1] Sensor Horizontal mirror
+       *
+       *   ISP and Sensor flip or mirror register bit should be the same!!
+       *
+       ********************************************************/
+
+    switch (image_mirror) {
+				case IMAGE_NORMAL:
+					write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xFB) | 0x00));
+					write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xFB) | 0x00));
+					break;
+				case IMAGE_H_MIRROR:
+					write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xFB) | 0x00));
+					write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xFF) | 0x04));
+					break;
+				case IMAGE_V_MIRROR:
+					write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xFF) | 0x04));
+					write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xFB) | 0x00));		
+					break;
+				case IMAGE_HV_MIRROR:
+					write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xFF) | 0x04));
+					write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xFF) | 0x04));
+					break;
+				default:
+					LOG_INF("Error image_mirror setting\n");
+    }
+
+}
+
+/*************************************************************************
+* FUNCTION
+*    night_mode
+*
+* DESCRIPTION
+*    This function night mode of sensor.
+*
+* PARAMETERS
+*    bEnable: KAL_TRUE -> enable night mode, otherwise, disable night mode
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static void night_mode(kal_bool enable)
+{
+/*No Need to implement this function*/
+}    /*    night_mode    */
+
+static void sensor_init(void)
+{
+    LOG_INF("E\n");
+
+   /*****************************************************************************
+    0x3098[0:1] pll3_prediv
+    pll3_prediv_map[] = {2, 3, 4, 6}
+
+    0x3099[0:4] pll3_multiplier
+    pll3_multiplier
+
+    0x309C[0] pll3_rdiv
+    pll3_rdiv + 1
+
+    0x309A[0:3] pll3_sys_div
+    pll3_sys_div + 1
+
+    0x309B[0:1] pll3_div
+    pll3_div[] = {2, 2, 4, 5}
+
+    VCO = XVCLK * 2 / pll3_prediv * pll3_multiplier * pll3_rdiv
+    sysclk = VCO * 2 * 2 / pll3_sys_div / pll3_div
+
+    XVCLK = 24 MHZ
+    0x3098, 0x03
+    0x3099, 0x1e
+    0x309a, 0x02
+    0x309b, 0x01
+    0x309c, 0x00
+
+
+    VCO = 24 * 2 / 6 * 31 * 1
+    sysclk = VCO * 2  * 2 / 3 / 2
+    sysclk = 160 MHZ
+    */
+/*
+   //write_cmos_sensor(0x0103, 0x01);//,
+	  write_cmos_sensor(0x351b, 0x00);
+		write_cmos_sensor(0x351d, 0x00);
+		write_cmos_sensor(0x351f, 0x00);
+		write_cmos_sensor(0x3521, 0x00);
+		write_cmos_sensor(0x3600, 0x40);
+		write_cmos_sensor(0x3603, 0x48);
+		write_cmos_sensor(0x3604, 0xa5);
+		write_cmos_sensor(0x3605, 0x9f);
+		write_cmos_sensor(0x3606, 0x03);
+		write_cmos_sensor(0x3607, 0x00);
+		write_cmos_sensor(0x3609, 0x00);
+		write_cmos_sensor(0x360a, 0x40);
+		write_cmos_sensor(0x360f, 0x8a);
+		write_cmos_sensor(0x3615, 0x08);
+		write_cmos_sensor(0x3616, 0x00);
+		write_cmos_sensor(0x366a, 0x00);
+		write_cmos_sensor(0x3705, 0x24);
+		write_cmos_sensor(0x3706, 0x50);
+		write_cmos_sensor(0x3720, 0x66);
+		write_cmos_sensor(0x3761, 0x34);
+		write_cmos_sensor(0x376f, 0x00);
+		write_cmos_sensor(0x3773, 0x00);
+		write_cmos_sensor(0x3827, 0x00);
+		write_cmos_sensor(0x510f, 0x00);
+		write_cmos_sensor(0x5110, 0x00);
+		write_cmos_sensor(0x5111, 0x00);
+		write_cmos_sensor(0x5243, 0xb8);
+		write_cmos_sensor(0x5245, 0xf9);
+		write_cmos_sensor(0x5247, 0xf6);
+		write_cmos_sensor(0x5249, 0xa6);
+		write_cmos_sensor(0x5300, 0xfc);
+		write_cmos_sensor(0x5301, 0xdf);
+		write_cmos_sensor(0x5302, 0x3f);
+		write_cmos_sensor(0x5303, 0x08);
+		write_cmos_sensor(0x5304, 0x0c);
+		write_cmos_sensor(0x5305, 0x10);
+		write_cmos_sensor(0x5306, 0x20);
+		write_cmos_sensor(0x5307, 0x40);
+		write_cmos_sensor(0x5308, 0x08);
+		write_cmos_sensor(0x5309, 0x08);
+		write_cmos_sensor(0x530a, 0x02);
+		write_cmos_sensor(0x530b, 0x01);
+		write_cmos_sensor(0x530c, 0x01);
+		write_cmos_sensor(0x530d, 0x0c);
+		write_cmos_sensor(0x530e, 0x02);
+		write_cmos_sensor(0x530f, 0x01);
+		write_cmos_sensor(0x5310, 0x01);
+		write_cmos_sensor(0x536d, 0x00);
+		write_cmos_sensor(0x536e, 0x00);
+		write_cmos_sensor(0x536f, 0x00);
+		write_cmos_sensor(0x5370, 0x00);
+		*/
+		//////////////////////////////////
+		write_cmos_sensor(0x0103, 0x01);
+		write_cmos_sensor(0x0102, 0x01);//for debug xb.pang color line
+		write_cmos_sensor(0x0300, 0x01);
+		write_cmos_sensor(0x0301, 0x00);
+		write_cmos_sensor(0x0302, 0x28);
+		write_cmos_sensor(0x0303, 0x00);
+		write_cmos_sensor(0x030a, 0x00);
+		write_cmos_sensor(0x300f, 0x11);
+		write_cmos_sensor(0x3010, 0x01);
+		write_cmos_sensor(0x3011, 0x76);
+		write_cmos_sensor(0x3012, 0x41);
+		write_cmos_sensor(0x3013, 0x12);
+		write_cmos_sensor(0x3014, 0x11);
+		write_cmos_sensor(0x301f, 0x03);
+		write_cmos_sensor(0x3106, 0x00);
+		write_cmos_sensor(0x3210, 0x47);
+		write_cmos_sensor(0x3500, 0x00);
+		write_cmos_sensor(0x3501, 0x60);
+		write_cmos_sensor(0x3502, 0x00);
+		write_cmos_sensor(0x3506, 0x00);
+		write_cmos_sensor(0x3507, 0x02);
+		write_cmos_sensor(0x3508, 0x00);
+		write_cmos_sensor(0x350a, 0x00);
+		write_cmos_sensor(0x350b, 0x80);
+		write_cmos_sensor(0x350e, 0x00);
+		write_cmos_sensor(0x350f, 0x10);
+		write_cmos_sensor(0x351a, 0x00);
+		write_cmos_sensor(0x351b, 0x10);
+		write_cmos_sensor(0x351c, 0x00);
+		write_cmos_sensor(0x351d, 0x20);
+		write_cmos_sensor(0x351e, 0x00);
+		write_cmos_sensor(0x351f, 0x40);
+		write_cmos_sensor(0x3520, 0x00);
+		write_cmos_sensor(0x3521, 0x80);
+		write_cmos_sensor(0x3600, 0xc0);
+		write_cmos_sensor(0x3601, 0xfc);
+		write_cmos_sensor(0x3602, 0x02);
+		write_cmos_sensor(0x3603, 0x78);
+		write_cmos_sensor(0x3604, 0xb1);
+		write_cmos_sensor(0x3605, 0xb5);
+		write_cmos_sensor(0x3606, 0x73);
+		write_cmos_sensor(0x3607, 0x07);
+		write_cmos_sensor(0x3609, 0x40);
+		write_cmos_sensor(0x360a, 0x30);
+		write_cmos_sensor(0x360b, 0x91);
+		write_cmos_sensor(0x360c, 0x49);
+		write_cmos_sensor(0x360f, 0x02);
+		write_cmos_sensor(0x3611, 0x10);
+		write_cmos_sensor(0x3612, 0x27);
+		write_cmos_sensor(0x3613, 0x33);
+		write_cmos_sensor(0x3615, 0x0c);
+		write_cmos_sensor(0x3616, 0x0e);
+		write_cmos_sensor(0x3641, 0x02);
+		write_cmos_sensor(0x3660, 0x82);
+		write_cmos_sensor(0x3668, 0x54);
+		write_cmos_sensor(0x3669, 0x00);
+		write_cmos_sensor(0x366a, 0x3f);
+		write_cmos_sensor(0x3667, 0xa0);
+		write_cmos_sensor(0x3702, 0x40);
+		write_cmos_sensor(0x3703, 0x44);
+		write_cmos_sensor(0x3704, 0x2c);
+		write_cmos_sensor(0x3705, 0x01);
+		write_cmos_sensor(0x3706, 0x15);
+		write_cmos_sensor(0x3707, 0x44);
+		write_cmos_sensor(0x3708, 0x3c);
+		write_cmos_sensor(0x3709, 0x1f);
+		write_cmos_sensor(0x370a, 0x27);
+		write_cmos_sensor(0x370b, 0x3c);
+		write_cmos_sensor(0x3720, 0x55);
+		write_cmos_sensor(0x3722, 0x84);
+		write_cmos_sensor(0x3728, 0x40);
+		write_cmos_sensor(0x372a, 0x00);
+		write_cmos_sensor(0x372b, 0x02);
+		write_cmos_sensor(0x372e, 0x22);
+		write_cmos_sensor(0x372f, 0x90);
+		write_cmos_sensor(0x3730, 0x00);
+		write_cmos_sensor(0x3731, 0x00);
+		write_cmos_sensor(0x3732, 0x00);
+		write_cmos_sensor(0x3733, 0x00);
+		write_cmos_sensor(0x3710, 0x28);
+		write_cmos_sensor(0x3716, 0x03);
+		write_cmos_sensor(0x3718, 0x10);
+		write_cmos_sensor(0x3719, 0x08);
+		write_cmos_sensor(0x371a, 0x08);
+		write_cmos_sensor(0x371c, 0xfc);
+		write_cmos_sensor(0x3748, 0x00);
+		write_cmos_sensor(0x3760, 0x13);
+		write_cmos_sensor(0x3761, 0x33);
+		write_cmos_sensor(0x3762, 0x86);
+		write_cmos_sensor(0x3763, 0x16);
+		write_cmos_sensor(0x3767, 0x24);
+		write_cmos_sensor(0x3768, 0x06);
+		write_cmos_sensor(0x3769, 0x45);
+		write_cmos_sensor(0x376c, 0x23);
+		write_cmos_sensor(0x376f, 0x80);
+		write_cmos_sensor(0x3773, 0x06);
+		write_cmos_sensor(0x3d84, 0x00);
+		write_cmos_sensor(0x3d85, 0x17);
+		write_cmos_sensor(0x3d8c, 0x73);
+		write_cmos_sensor(0x3d8d, 0xbf);
+		write_cmos_sensor(0x3800, 0x00);
+		write_cmos_sensor(0x3801, 0x08);
+		write_cmos_sensor(0x3802, 0x00);
+		write_cmos_sensor(0x3803, 0x04);
+		write_cmos_sensor(0x3804, 0x10);
+		write_cmos_sensor(0x3805, 0x97);
+		write_cmos_sensor(0x3806, 0x0c);
+		write_cmos_sensor(0x3807, 0x4b);
+		write_cmos_sensor(0x3808, 0x08);
+		write_cmos_sensor(0x3809, 0x40);
+		write_cmos_sensor(0x380a, 0x06);
+		write_cmos_sensor(0x380b, 0x20);
+		write_cmos_sensor(0x380c, 0x09);
+		write_cmos_sensor(0x380d, 0x60);
+		write_cmos_sensor(0x380e, 0x06);
+		write_cmos_sensor(0x380f, 0x80);
+		write_cmos_sensor(0x3810, 0x00);
+		write_cmos_sensor(0x3811, 0x04);
+		write_cmos_sensor(0x3812, 0x00);
+		write_cmos_sensor(0x3813, 0x02);
+		write_cmos_sensor(0x3814, 0x31);
+		write_cmos_sensor(0x3815, 0x31);
+		write_cmos_sensor(0x3820, 0x02);
+		write_cmos_sensor(0x3821, 0x06);
+		write_cmos_sensor(0x3823, 0x00);
+		write_cmos_sensor(0x3826, 0x00);
+		write_cmos_sensor(0x3827, 0x02);
+		write_cmos_sensor(0x3834, 0x00);
+		write_cmos_sensor(0x3835, 0x1c);
+		write_cmos_sensor(0x3836, 0x08);
+		write_cmos_sensor(0x3837, 0x02);
+		write_cmos_sensor(0x4000, 0xf1);
+		write_cmos_sensor(0x4001, 0x00);
+		write_cmos_sensor(0x400b, 0x0c);
+		write_cmos_sensor(0x4011, 0x00);
+		write_cmos_sensor(0x401a, 0x00);
+		write_cmos_sensor(0x401b, 0x00);
+		write_cmos_sensor(0x401c, 0x00);
+		write_cmos_sensor(0x401d, 0x00);
+		write_cmos_sensor(0x4020, 0x00);
+		write_cmos_sensor(0x4021, 0xe4);
+		write_cmos_sensor(0x4022, 0x04);
+		write_cmos_sensor(0x4023, 0xd7);
+		write_cmos_sensor(0x4024, 0x05);
+		write_cmos_sensor(0x4025, 0xbc);
+		write_cmos_sensor(0x4026, 0x05);
+		write_cmos_sensor(0x4027, 0xbf);
+		write_cmos_sensor(0x4028, 0x00);
+		write_cmos_sensor(0x4029, 0x02);
+		write_cmos_sensor(0x402a, 0x04);
+		write_cmos_sensor(0x402b, 0x08);
+		write_cmos_sensor(0x402c, 0x02);
+		write_cmos_sensor(0x402d, 0x02);
+		write_cmos_sensor(0x402e, 0x0c);
+		write_cmos_sensor(0x402f, 0x08);
+		write_cmos_sensor(0x403d, 0x2c);
+		write_cmos_sensor(0x403f, 0x7f);
+		write_cmos_sensor(0x4041, 0x07);
+		write_cmos_sensor(0x4500, 0x82);
+		write_cmos_sensor(0x4501, 0x3c);
+		write_cmos_sensor(0x458b, 0x00);
+		write_cmos_sensor(0x459c, 0x00);
+		write_cmos_sensor(0x459d, 0x00);
+		write_cmos_sensor(0x459e, 0x00);
+		write_cmos_sensor(0x4601, 0x83);
+		write_cmos_sensor(0x4602, 0x22);
+		write_cmos_sensor(0x4603, 0x01);
+		write_cmos_sensor(0x4837, 0x19);
+		write_cmos_sensor(0x4d00, 0x04);
+		write_cmos_sensor(0x4d01, 0x42);
+		write_cmos_sensor(0x4d02, 0xd1);
+		write_cmos_sensor(0x4d03, 0x90);
+		write_cmos_sensor(0x4d04, 0x66);
+		write_cmos_sensor(0x4d05, 0x65);
+		write_cmos_sensor(0x4d0b, 0x00);
+		write_cmos_sensor(0x5000, 0x0e);//0e
+		write_cmos_sensor(0x5001, 0x03);//0x01-->0x03 for manual wb gain
+		write_cmos_sensor(0x5002, 0x07);
+		write_cmos_sensor(0x5013, 0x40);
+		write_cmos_sensor(0x501c, 0x00);
+		write_cmos_sensor(0x501d, 0x10);
+		write_cmos_sensor(0x510f, 0xfc);
+		write_cmos_sensor(0x5110, 0xf0);
+		write_cmos_sensor(0x5111, 0x10);
+		write_cmos_sensor(0x536d, 0x02);
+		write_cmos_sensor(0x536e, 0x67);
+		write_cmos_sensor(0x536f, 0x01);
+		write_cmos_sensor(0x5370, 0x4c);
+		write_cmos_sensor(0x5400, 0x00);
+		write_cmos_sensor(0x5400, 0x00);
+		write_cmos_sensor(0x5401, 0x61);
+		write_cmos_sensor(0x5402, 0x00);
+		write_cmos_sensor(0x5403, 0x00);
+		write_cmos_sensor(0x5404, 0x00);
+		write_cmos_sensor(0x5405, 0x40);
+		write_cmos_sensor(0x540c, 0x05);
+		write_cmos_sensor(0x5501, 0x00);
+		write_cmos_sensor(0x5b00, 0x00);
+		write_cmos_sensor(0x5b01, 0x00);
+		write_cmos_sensor(0x5b02, 0x01);
+		write_cmos_sensor(0x5b03, 0xff);
+		write_cmos_sensor(0x5b04, 0x02);
+		write_cmos_sensor(0x5b05, 0x6c);
+		write_cmos_sensor(0x5b09, 0x02);
+		write_cmos_sensor(0x5e00, 0x00);
+		write_cmos_sensor(0x5e10, 0x1c);		
+		if (ov13850_chip_ver == OV13850_R1A)
+		{
+			write_cmos_sensor(0x351b, 0x00);
+			write_cmos_sensor(0x351d, 0x00);
+			write_cmos_sensor(0x351f, 0x00);
+			write_cmos_sensor(0x3521, 0x00);
+			write_cmos_sensor(0x3600, 0x40);
+			write_cmos_sensor(0x3603, 0x48);
+			write_cmos_sensor(0x3604, 0xa5);
+			write_cmos_sensor(0x3605, 0x9f);
+			write_cmos_sensor(0x3606, 0x03);
+			write_cmos_sensor(0x3607, 0x00);
+			write_cmos_sensor(0x3609, 0x00);
+			write_cmos_sensor(0x360a, 0x40);
+			write_cmos_sensor(0x360f, 0x8a);
+			write_cmos_sensor(0x3615, 0x08);
+			write_cmos_sensor(0x3616, 0x00);
+			write_cmos_sensor(0x366a, 0x00);
+			write_cmos_sensor(0x3705, 0x24);
+			write_cmos_sensor(0x3706, 0x50);
+			write_cmos_sensor(0x3720, 0x66);
+			write_cmos_sensor(0x3761, 0x34);
+			write_cmos_sensor(0x376f, 0x00);
+			write_cmos_sensor(0x3773, 0x00);
+			write_cmos_sensor(0x3827, 0x00);
+			write_cmos_sensor(0x510f, 0x00);
+			write_cmos_sensor(0x5110, 0x00);
+			write_cmos_sensor(0x5111, 0x00);
+			write_cmos_sensor(0x5243, 0xb8);
+			write_cmos_sensor(0x5245, 0xf9);
+			write_cmos_sensor(0x5247, 0xf6);
+			write_cmos_sensor(0x5249, 0xa6);
+			write_cmos_sensor(0x5300, 0xfc);
+			write_cmos_sensor(0x5301, 0xdf);
+			write_cmos_sensor(0x5302, 0x3f);
+			write_cmos_sensor(0x5303, 0x08);
+			write_cmos_sensor(0x5304, 0x0c);
+			write_cmos_sensor(0x5305, 0x10);
+			write_cmos_sensor(0x5306, 0x20);
+			write_cmos_sensor(0x5307, 0x40);
+			write_cmos_sensor(0x5308, 0x08);
+			write_cmos_sensor(0x5309, 0x08);
+			write_cmos_sensor(0x530a, 0x02);
+			write_cmos_sensor(0x530b, 0x01);
+			write_cmos_sensor(0x530c, 0x01);
+			write_cmos_sensor(0x530d, 0x0c);
+			write_cmos_sensor(0x530e, 0x02);
+			write_cmos_sensor(0x530f, 0x01);
+			write_cmos_sensor(0x5310, 0x01);
+			write_cmos_sensor(0x536d, 0x00);
+			write_cmos_sensor(0x536e, 0x00);
+			write_cmos_sensor(0x536f, 0x00);
+			write_cmos_sensor(0x5370, 0x00);
+		}
+		write_cmos_sensor(0x0100, 0x01);//
+}    /*    sensor_init  */
+
+
+static void preview_setting(void)
+{
+    write_cmos_sensor(0x0100, 0x00);//
+		write_cmos_sensor(0x0300, 0x01);
+		write_cmos_sensor(0x0302, 0x28);
+		write_cmos_sensor(0x0303, 0x00);
+		write_cmos_sensor(0x3612, 0x27);
+		write_cmos_sensor(0x3501, 0x60);
+		write_cmos_sensor(0x3702, 0x40);
+		write_cmos_sensor(0x370a, 0x27);
+		write_cmos_sensor(0x3718, 0x1c);//add new20140801
+		write_cmos_sensor(0x372a, 0x00);
+		write_cmos_sensor(0x372f, 0xa0);//0x90
+		write_cmos_sensor(0x3800, 0x0);
+		write_cmos_sensor(0x3801, 0x00);//0x08
+		write_cmos_sensor(0x3802, 0x00);
+		write_cmos_sensor(0x3803, 0x04);
+		write_cmos_sensor(0x3804, 0x10);
+		write_cmos_sensor(0x3805, 0x9f);//0x97
+		write_cmos_sensor(0x3806, 0x0c);
+		write_cmos_sensor(0x3807, 0x4b);
+		write_cmos_sensor(0x3808, 0x08);
+		write_cmos_sensor(0x3809, 0x40);
+		write_cmos_sensor(0x380a, 0x06);
+		write_cmos_sensor(0x380b, 0x20);
+		write_cmos_sensor(0x380c, ((imgsensor_info.pre.linelength >> 8) & 0xFF)); // hts = 2688
+    write_cmos_sensor(0x380d, (imgsensor_info.pre.linelength & 0xFF));        // hts
+    write_cmos_sensor(0x380e, ((imgsensor_info.pre.framelength >> 8) & 0xFF));  // vts = 1984
+    write_cmos_sensor(0x380f, (imgsensor_info.pre.framelength & 0xFF));         // vts
+		write_cmos_sensor(0x3811, 0x08);//0x04
+		write_cmos_sensor(0x3813, 0x02);
+		write_cmos_sensor(0x3814, 0x31);
+		write_cmos_sensor(0x3815, 0x31);
+		write_cmos_sensor(0x3820, 0x01);//0x02
+		write_cmos_sensor(0x3821, 0x06);
+		write_cmos_sensor(0x3834, 0x00);
+		write_cmos_sensor(0x3836, 0x08);
+		write_cmos_sensor(0x3837, 0x02);
+		write_cmos_sensor(0x4020, 0x00);
+		write_cmos_sensor(0x4021, 0xe4);
+		write_cmos_sensor(0x4022, 0x04);
+		write_cmos_sensor(0x4023, 0xd7);
+		write_cmos_sensor(0x4024, 0x05);
+		write_cmos_sensor(0x4025, 0xbc);
+		write_cmos_sensor(0x4026, 0x05);
+		write_cmos_sensor(0x4027, 0xbf);
+		write_cmos_sensor(0x402a, 0x04);
+		write_cmos_sensor(0x402b, 0x08);
+		write_cmos_sensor(0x402c, 0x02);
+		write_cmos_sensor(0x402e, 0x0c);
+		write_cmos_sensor(0x402f, 0x08);
+		write_cmos_sensor(0x4501, 0x3c);
+		write_cmos_sensor(0x4601, 0x83);
+		write_cmos_sensor(0x4603, 0x01);
+		write_cmos_sensor(0x4837, 0x19);
+		write_cmos_sensor(0x5401, 0x61);
+		write_cmos_sensor(0x5405, 0x40);
+		write_cmos_sensor(0x0100, 0x01);//
+		mdelay(10);	
+}    /*    preview_setting  */
+
+/*capture_first_flag & pre_currefps for resolve ov13850r2a 
+* low light zsd capture color-line issue
+*/
+int capture_first_flag = 0;
+int pre_currefps = 0;
+static void capture_setting(kal_uint16 currefps)
+{
+    LOG_INF("E! currefps:%d\n",currefps);
+
+if (pre_currefps != currefps)
+{
+	capture_first_flag = 0;
+	pre_currefps = currefps;
+}
+else
+{
+	capture_first_flag = 1;
+}
+if (capture_first_flag == 0)
+{
+
+    if (currefps == 150) { //15fps for PIP
+        //@@full_132PCLK_24.75
+			write_cmos_sensor(0x0300, 0x01);//
+			write_cmos_sensor(0x0302, 0x28);//
+			write_cmos_sensor(0x0303, 0x00);//
+			write_cmos_sensor(0x3612, 0x27);//
+			write_cmos_sensor(0x3501, 0xc0);//   
+			write_cmos_sensor(0x3702, 0x40);// ;add for VGA differences
+			write_cmos_sensor(0x370a, 0x24);//
+			//write_cmos_sensor(0x3718, 0x10);//
+			write_cmos_sensor(0x372a, 0x04);//
+			write_cmos_sensor(0x372f, 0xa0);//
+			write_cmos_sensor(0x3800, 0x0);
+			write_cmos_sensor(0x3801, 0x0C);// 
+			write_cmos_sensor(0x3802, 0x00);// ;add for VGA differences
+			write_cmos_sensor(0x3803, 0x04);// 
+			write_cmos_sensor(0x3804, 0x10);
+			write_cmos_sensor(0x3805, 0x93);// 
+			write_cmos_sensor(0x3806, 0x0c);// ;add for VGA differences
+			write_cmos_sensor(0x3807, 0x4B);// 
+			write_cmos_sensor(0x3808, 0x10);//
+			write_cmos_sensor(0x3809, 0x80);// 
+			write_cmos_sensor(0x380a, 0x0c);//
+			write_cmos_sensor(0x380b, 0x40);// 
+			write_cmos_sensor(0x380c, ((imgsensor_info.cap1.linelength >> 8) & 0xFF)); // hts = 2688
+      		write_cmos_sensor(0x380d, (imgsensor_info.cap1.linelength & 0xFF));        // hts
+      		write_cmos_sensor(0x380e, ((imgsensor_info.cap1.framelength >> 8) & 0xFF));  // vts = 1984
+      		write_cmos_sensor(0x380f, (imgsensor_info.cap1.framelength & 0xFF));         // vts
+			write_cmos_sensor(0x3811, 0x04);// ;add for VGA differences
+			write_cmos_sensor(0x3813, 0x04);//
+			write_cmos_sensor(0x3814, 0x11);//
+			write_cmos_sensor(0x3815, 0x11);//
+			write_cmos_sensor(0x3820, 0x00);//
+			write_cmos_sensor(0x3821, 0x04);//
+			write_cmos_sensor(0x3834, 0x00);// ;add for VGA differences
+			write_cmos_sensor(0x3836, 0x04);//
+			write_cmos_sensor(0x3837, 0x01);//
+			write_cmos_sensor(0x4020, 0x02);//
+			write_cmos_sensor(0x4021, 0x4C);// 
+			write_cmos_sensor(0x4022, 0x0E);//
+			write_cmos_sensor(0x4023, 0x37);//
+			write_cmos_sensor(0x4024, 0x0F);//
+			write_cmos_sensor(0x4025, 0x1C);//
+			write_cmos_sensor(0x4026, 0x0F);//
+			write_cmos_sensor(0x4027, 0x1F);//
+			write_cmos_sensor(0x402a, 0x04);//;add for VGA differences
+			write_cmos_sensor(0x402b, 0x08);//;add for VGA differences
+			write_cmos_sensor(0x402c, 0x02);//;add for VGA differences
+			write_cmos_sensor(0x402e, 0x0c);//;add for VGA differences
+			write_cmos_sensor(0x402f, 0x08);//;add for VGA differences
+			write_cmos_sensor(0x4501, 0x38);//
+			write_cmos_sensor(0x4601, 0x04);//
+			write_cmos_sensor(0x4603, 0x00);//
+			write_cmos_sensor(0x4837, 0x19);//
+			write_cmos_sensor(0x5401, 0x71);//
+			write_cmos_sensor(0x5405, 0x80);//
+			write_cmos_sensor(0x0100, 0x01);//
+			
+
+    } else {   //30fps            //30fps for Normal capture & ZSD
+ 
+      		write_cmos_sensor(0x0300, 0x00);//
+			write_cmos_sensor(0x0302, 0x32);//
+			write_cmos_sensor(0x0303, 0x00);//
+			write_cmos_sensor(0x3612, 0x07);//
+			write_cmos_sensor(0x3501, 0xc0);//   
+			write_cmos_sensor(0x3702, 0x40);// ;add for VGA differences
+			write_cmos_sensor(0x370a, 0x24);//
+			//write_cmos_sensor(0x3718, 0x10);//
+			write_cmos_sensor(0x372a, 0x04);//
+			write_cmos_sensor(0x372f, 0xa0);//
+			write_cmos_sensor(0x3800, 0x0);
+			write_cmos_sensor(0x3801, 0x0C);// 
+			write_cmos_sensor(0x3802, 0x00);// ;add for VGA differences
+			write_cmos_sensor(0x3803, 0x04);// 
+			write_cmos_sensor(0x3804, 0x10);
+			write_cmos_sensor(0x3805, 0x93);// 
+			write_cmos_sensor(0x3806, 0x0c);// ;add for VGA differences
+			write_cmos_sensor(0x3807, 0x4B);// 
+			write_cmos_sensor(0x3808, 0x10);//
+			write_cmos_sensor(0x3809, 0x80);// 
+			write_cmos_sensor(0x380a, 0x0c);//
+			write_cmos_sensor(0x380b, 0x40);// 
+			write_cmos_sensor(0x380c, ((imgsensor_info.cap.linelength >> 8) & 0xFF)); // hts = 2688
+      		write_cmos_sensor(0x380d, (imgsensor_info.cap.linelength & 0xFF));        // hts
+      		write_cmos_sensor(0x380e, ((imgsensor_info.cap.framelength >> 8) & 0xFF));  // vts = 1984
+      		write_cmos_sensor(0x380f, (imgsensor_info.cap.framelength & 0xFF));         // vts
+			write_cmos_sensor(0x3811, 0x04);// ;add for VGA differences
+			write_cmos_sensor(0x3813, 0x04);//
+			write_cmos_sensor(0x3814, 0x11);//
+			write_cmos_sensor(0x3815, 0x11);//
+			write_cmos_sensor(0x3820, 0x00);//
+			write_cmos_sensor(0x3821, 0x04);//
+			write_cmos_sensor(0x3834, 0x00);// ;add for VGA differences
+			write_cmos_sensor(0x3836, 0x04);//
+			write_cmos_sensor(0x3837, 0x01);//
+			write_cmos_sensor(0x4020, 0x02);//
+			write_cmos_sensor(0x4021, 0x4C);// 
+			write_cmos_sensor(0x4022, 0x0E);//
+			write_cmos_sensor(0x4023, 0x37);//
+			write_cmos_sensor(0x4024, 0x0F);//
+			write_cmos_sensor(0x4025, 0x1C);//
+			write_cmos_sensor(0x4026, 0x0F);//
+			write_cmos_sensor(0x4027, 0x1F);//
+			write_cmos_sensor(0x402a, 0x04);//;add for VGA differences
+			write_cmos_sensor(0x402b, 0x08);//;add for VGA differences
+			write_cmos_sensor(0x402c, 0x02);//;add for VGA differences
+			write_cmos_sensor(0x402e, 0x0c);//;add for VGA differences
+			write_cmos_sensor(0x402f, 0x08);//;add for VGA differences
+			write_cmos_sensor(0x4501, 0x38);//
+			write_cmos_sensor(0x4601, 0x04);//
+			write_cmos_sensor(0x4603, 0x00);//
+			write_cmos_sensor(0x4837, 0x0d);//
+			write_cmos_sensor(0x5401, 0x71);//
+			write_cmos_sensor(0x5405, 0x80);//
+			write_cmos_sensor(0x0100, 0x01);//
+
+
+
+        if (imgsensor.ihdr_en) {
+
+    } else {
+
+    }
+
+    }
+	mdelay(20);	
+	capture_first_flag = 1;
+}
+
+}
+
+static void normal_video_setting(kal_uint16 currefps)
+{
+    LOG_INF("E! currefps:%d\n",currefps);
+		write_cmos_sensor(0x0100, 0x00);//
+		write_cmos_sensor(0x0300, 0x00);
+		write_cmos_sensor(0x0302, 0x32);
+		write_cmos_sensor(0x0303, 0x00);
+		write_cmos_sensor(0x3612, 0x07);
+		write_cmos_sensor(0x3501, 0xc0);
+		write_cmos_sensor(0x3702, 0x40);
+		write_cmos_sensor(0x370a, 0x24);
+		write_cmos_sensor(0x372a, 0x04);
+		write_cmos_sensor(0x372f, 0xa0);
+		write_cmos_sensor(0x3800, 0x0);
+		write_cmos_sensor(0x3801, 0x14);
+		write_cmos_sensor(0x3802, 0x00);
+		write_cmos_sensor(0x3803, 0x0c);
+		write_cmos_sensor(0x3804, 0x10);
+		write_cmos_sensor(0x3805, 0x8b);
+		write_cmos_sensor(0x3806, 0x0c);
+		write_cmos_sensor(0x3807, 0x43);
+		write_cmos_sensor(0x3808, 0x10);
+		write_cmos_sensor(0x3809, 0x70);
+		write_cmos_sensor(0x380a, 0x0c);
+		write_cmos_sensor(0x380b, 0x30);
+		write_cmos_sensor(0x380c, ((imgsensor_info.normal_video.linelength >> 8) & 0xFF)); // hts = 2688
+        write_cmos_sensor(0x380d, (imgsensor_info.normal_video.linelength & 0xFF));        // hts
+        write_cmos_sensor(0x380e, ((imgsensor_info.normal_video.framelength >> 8) & 0xFF));  // vts = 1984
+    	write_cmos_sensor(0x380f, (imgsensor_info.normal_video.framelength & 0xFF));         // vts
+		write_cmos_sensor(0x3811, 0x04);
+		write_cmos_sensor(0x3813, 0x04);
+		write_cmos_sensor(0x3814, 0x11);
+		write_cmos_sensor(0x3815, 0x11);
+		write_cmos_sensor(0x3820, 0x00);
+		write_cmos_sensor(0x3821, 0x04);
+		write_cmos_sensor(0x3834, 0x00);
+		write_cmos_sensor(0x3836, 0x04);
+		write_cmos_sensor(0x3837, 0x01);
+		write_cmos_sensor(0x4020, 0x02);
+		write_cmos_sensor(0x4021, 0x3C);
+		write_cmos_sensor(0x4022, 0x0E);
+		write_cmos_sensor(0x4023, 0x37);
+		write_cmos_sensor(0x4024, 0x0F);
+		write_cmos_sensor(0x4025, 0x1C);
+		write_cmos_sensor(0x4026, 0x0F);
+		write_cmos_sensor(0x4027, 0x1F);
+		write_cmos_sensor(0x402a, 0x04);
+		write_cmos_sensor(0x402b, 0x08);
+		write_cmos_sensor(0x402c, 0x02);
+		write_cmos_sensor(0x402e, 0x0c);
+		write_cmos_sensor(0x402f, 0x08);
+		write_cmos_sensor(0x4501, 0x38);
+		write_cmos_sensor(0x4601, 0x04);
+		write_cmos_sensor(0x4603, 0x00);
+		write_cmos_sensor(0x4837, 0x0d);
+		write_cmos_sensor(0x5401, 0x71);
+		write_cmos_sensor(0x5405, 0x80);
+		write_cmos_sensor(0x0100, 0x01);//
+
+		mdelay(20);
+    if (imgsensor.ihdr_en) {
+    } else {
+    }
+
+}
+static void hs_video_setting()
+{
+    LOG_INF("E\n");
+
+    write_cmos_sensor(0x0100, 0x00);//
+		write_cmos_sensor(0x0300, 0x01);
+		write_cmos_sensor(0x0302, 0x28);
+		write_cmos_sensor(0x0303, 0x00);
+		write_cmos_sensor(0x3612, 0x27);
+		write_cmos_sensor(0x3501, 0x20);
+		write_cmos_sensor(0x3702, 0x5a);
+		write_cmos_sensor(0x370a, 0xa9);
+		write_cmos_sensor(0x372a, 0x00);
+		write_cmos_sensor(0x372f, 0x88);
+		write_cmos_sensor(0x3800, 0x0);
+		write_cmos_sensor(0x3801, 0x00);
+		write_cmos_sensor(0x3802, 0x01);
+		write_cmos_sensor(0x3803, 0x78);
+		write_cmos_sensor(0x3804, 0x10);
+		write_cmos_sensor(0x3805, 0x9f);
+		write_cmos_sensor(0x3806, 0x0a);
+		write_cmos_sensor(0x3807, 0xcf);
+		write_cmos_sensor(0x3808, 0x04);
+		write_cmos_sensor(0x3809, 0x20);
+		write_cmos_sensor(0x380a, 0x02);
+		write_cmos_sensor(0x380b, 0x52);
+		write_cmos_sensor(0x380c, ((imgsensor_info.hs_video.linelength >> 8) & 0xFF)); // hts = 2688
+    write_cmos_sensor(0x380d, (imgsensor_info.hs_video.linelength & 0xFF));        // hts
+    write_cmos_sensor(0x380e, ((imgsensor_info.hs_video.framelength >> 8) & 0xFF));  // vts = 1984
+    write_cmos_sensor(0x380f, (imgsensor_info.hs_video.framelength & 0xFF));         // vts
+		write_cmos_sensor(0x3811, 0x08);
+		write_cmos_sensor(0x3813, 0x02);
+		write_cmos_sensor(0x3814, 0x31);
+		write_cmos_sensor(0x3815, 0x35);
+		write_cmos_sensor(0x3820, 0x02);
+		write_cmos_sensor(0x3821, 0x06);
+		write_cmos_sensor(0x3834, 0x02);
+		write_cmos_sensor(0x3836, 0x08);
+		write_cmos_sensor(0x3837, 0x04);
+		write_cmos_sensor(0x4020, 0x00);
+		write_cmos_sensor(0x4021, 0xe4);
+		write_cmos_sensor(0x4022, 0x03);
+		write_cmos_sensor(0x4023, 0x3f);
+		write_cmos_sensor(0x4024, 0x04);
+		write_cmos_sensor(0x4025, 0x20);
+		write_cmos_sensor(0x4026, 0x04);
+		write_cmos_sensor(0x4027, 0x25);
+		write_cmos_sensor(0x402a, 0x02);
+		write_cmos_sensor(0x402b, 0x04);
+		write_cmos_sensor(0x402c, 0x06);
+		write_cmos_sensor(0x402e, 0x08);
+		write_cmos_sensor(0x402f, 0x04);
+		write_cmos_sensor(0x4501, 0x3c);
+		write_cmos_sensor(0x4601, 0x40);
+		write_cmos_sensor(0x4603, 0x01);
+		write_cmos_sensor(0x4837, 0x19);
+		write_cmos_sensor(0x5401, 0x51);
+		write_cmos_sensor(0x5405, 0x20);
+	
+		
+    if (imgsensor.ihdr_en) {
+    } else {
+    }
+    write_cmos_sensor(0x0100, 0x01);//
+    mdelay(10);	  
+}
+
+static void slim_video_setting()
+{
+
+	#if 0 //preview
+    LOG_INF("E\n");
+    write_cmos_sensor(0x0100, 0x00);//
+		write_cmos_sensor(0x0300, 0x01);
+		write_cmos_sensor(0x0302, 0x28);
+		write_cmos_sensor(0x0303, 0x00);
+		write_cmos_sensor(0x3612, 0x27);
+		write_cmos_sensor(0x3501, 0x60);
+		write_cmos_sensor(0x3702, 0x40);
+		write_cmos_sensor(0x370a, 0x27);
+		write_cmos_sensor(0x372a, 0x00);
+		write_cmos_sensor(0x372f, 0x90);
+		write_cmos_sensor(0x3800, 0x00);
+		write_cmos_sensor(0x3801, 0x08);
+		write_cmos_sensor(0x3802, 0x00);
+		write_cmos_sensor(0x3803, 0x04);
+		write_cmos_sensor(0x3804, 0x10);
+		write_cmos_sensor(0x3805, 0x97);
+		write_cmos_sensor(0x3806, 0x0c);
+		write_cmos_sensor(0x3807, 0x4b);
+		write_cmos_sensor(0x3808, 0x08);
+		write_cmos_sensor(0x3809, 0x40);
+		write_cmos_sensor(0x380a, 0x06);
+		write_cmos_sensor(0x380b, 0x20);
+    write_cmos_sensor(0x380c, ((imgsensor_info.slim_video.linelength >> 8) & 0xFF)); // hts = 2688
+    write_cmos_sensor(0x380d, (imgsensor_info.slim_video.linelength & 0xFF));        // hts
+    write_cmos_sensor(0x380e, ((imgsensor_info.slim_video.framelength >> 8) & 0xFF));  // vts = 1984
+    write_cmos_sensor(0x380f, (imgsensor_info.slim_video.framelength & 0xFF));         // vts
+		write_cmos_sensor(0x3811, 0x04);//
+		write_cmos_sensor(0x3813, 0x02);
+		write_cmos_sensor(0x3814, 0x31);
+		write_cmos_sensor(0x3815, 0x31);
+		write_cmos_sensor(0x3820, 0x02);
+		write_cmos_sensor(0x3821, 0x06);
+		write_cmos_sensor(0x3834, 0x00);
+		write_cmos_sensor(0x3836, 0x08);
+		write_cmos_sensor(0x3837, 0x02);
+		write_cmos_sensor(0x4020, 0x00);
+		write_cmos_sensor(0x4021, 0xe4);
+		write_cmos_sensor(0x4022, 0x04);
+		write_cmos_sensor(0x4023, 0xd7);
+		write_cmos_sensor(0x4024, 0x05);
+		write_cmos_sensor(0x4025, 0xbc);
+		write_cmos_sensor(0x4026, 0x05);
+		write_cmos_sensor(0x4027, 0xbf);
+		write_cmos_sensor(0x402a, 0x04);
+		write_cmos_sensor(0x402b, 0x08);
+		write_cmos_sensor(0x402c, 0x02);
+		write_cmos_sensor(0x402e, 0x0c);
+		write_cmos_sensor(0x402f, 0x08);
+		write_cmos_sensor(0x4501, 0x3c);
+		write_cmos_sensor(0x4601, 0x83);
+		write_cmos_sensor(0x4603, 0x01);
+		write_cmos_sensor(0x4837, 0x19);
+		write_cmos_sensor(0x5401, 0x61);
+		write_cmos_sensor(0x5405, 0x40);
+#else
+//720P
+    write_cmos_sensor(0x0100, 0x00);//
+		write_cmos_sensor(0x0300, 0x01);
+		write_cmos_sensor(0x0301, 0x00);
+		write_cmos_sensor(0x0302, 0x28);
+		write_cmos_sensor(0x0303, 0x00);
+		write_cmos_sensor(0x3612, 0x27);
+		write_cmos_sensor(0x3612, 0x27);
+		write_cmos_sensor(0x3614, 0x28);
+		write_cmos_sensor(0x370a, 0x27);
+		write_cmos_sensor(0x372a, 0x00);
+		write_cmos_sensor(0x372f, 0x90);
+		write_cmos_sensor(0x3718, 0x10);
+		write_cmos_sensor(0x3767, 0x24);
+		write_cmos_sensor(0x3800, 0x03);
+		write_cmos_sensor(0x3801, 0x38);
+		write_cmos_sensor(0x3802, 0x03);
+		write_cmos_sensor(0x3803, 0x4a);
+		write_cmos_sensor(0x3804, 0x0d);
+		write_cmos_sensor(0x3805, 0x67);
+		write_cmos_sensor(0x3806, 0x09);
+		write_cmos_sensor(0x3807, 0x05);
+		write_cmos_sensor(0x3808, 0x05);
+    write_cmos_sensor(0x3809, 0x10);//               
+    write_cmos_sensor(0x380A, 0x02);//               
+    write_cmos_sensor(0x380B, 0xda);//               
+    write_cmos_sensor(0x380C, ((imgsensor_info.slim_video.linelength >> 8) & 0xFF)); // hts = 9600                      
+		write_cmos_sensor(0x380D,     (imgsensor_info.slim_video.linelength & 0xFF));        // hts          
+		write_cmos_sensor(0x380E,   ((imgsensor_info.slim_video.framelength >> 8) & 0xFF));  // vts = 834    
+		write_cmos_sensor(0x380F,   (imgsensor_info.slim_video.framelength & 0xFF));         // vts          
+		write_cmos_sensor(0x3811, 0x04);
+		write_cmos_sensor(0x3813, 0x02);
+		write_cmos_sensor(0x3814, 0x31);
+		write_cmos_sensor(0x3815, 0x31);
+		write_cmos_sensor(0x3820, 0x02);
+		write_cmos_sensor(0x3821, 0x05);
+		write_cmos_sensor(0x3836, 0x08);
+		write_cmos_sensor(0x3837, 0x02);
+		write_cmos_sensor(0x4001, 0x00);
+		write_cmos_sensor(0x4020, 0x1 );
+		write_cmos_sensor(0x4021, 0xD4);
+		write_cmos_sensor(0x4022, 0x3 );
+		write_cmos_sensor(0x4023, 0x43);
+		write_cmos_sensor(0x4024, 0x05);
+		write_cmos_sensor(0x4025, 0x14);
+		write_cmos_sensor(0x4026, 0x05);
+		write_cmos_sensor(0x4027, 0x17);
+		write_cmos_sensor(0x402a, 0x04);
+		write_cmos_sensor(0x402b, 0x08);
+		write_cmos_sensor(0x402c, 0x02);
+		write_cmos_sensor(0x402e, 0x0c);
+		write_cmos_sensor(0x402f, 0x08);
+		write_cmos_sensor(0x4501, 0x3c);
+		write_cmos_sensor(0x4600, 0x00);
+		write_cmos_sensor(0x4601, 0x50);
+    write_cmos_sensor(0x4837, 0x19);
+    write_cmos_sensor(0x5401, 0x61);
+    write_cmos_sensor(0x5405, 0x40);
+    write_cmos_sensor(0x350b, 0x40);
+    write_cmos_sensor(0x3500, 0x00);
+    write_cmos_sensor(0x3501, 0x33);
+    write_cmos_sensor(0x3502, 0x90);                            
+#endif 
+    if (imgsensor.ihdr_en) {
+    } else {
+    }
+		write_cmos_sensor(0x0100, 0x01);//
+		mdelay(10);	
+		
+}
+
+static kal_uint32 set_test_pattern_mode(kal_bool enable)
+{
+    LOG_INF("enable: %d\n", enable);
+
+    if (enable) {
+        // 0x5E00[8]: 1 enable,  0 disable
+        // 0x5E00[1:0]; 00 Color bar, 01 Random Data, 10 Square, 11 BLACK
+        write_cmos_sensor(0x5E00, 0x80);
+    } else {
+        // 0x5E00[8]: 1 enable,  0 disable
+        // 0x5E00[1:0]; 00 Color bar, 01 Random Data, 10 Square, 11 BLACK
+        write_cmos_sensor(0x5E00, 0x00);
+    }
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.test_pattern = enable;
+    spin_unlock(&imgsensor_drv_lock);
+    return ERROR_NONE;
+}
+
+/*************************************************************************
+* FUNCTION
+*    get_imgsensor_id
+*
+* DESCRIPTION
+*    This function get the sensor ID
+*
+* PARAMETERS
+*    *sensorID : return the sensor ID
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 get_imgsensor_id(UINT32 *sensor_id)
+{
+    kal_uint8 i = 0;
+    kal_uint8 retry = 2;
+    //sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
+    while (imgsensor_info.i2c_addr_table[i] != 0xff) {
+        spin_lock(&imgsensor_drv_lock);
+        imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
+        spin_unlock(&imgsensor_drv_lock);
+        do {
+            *sensor_id = return_sensor_id();
+            if (*sensor_id == imgsensor_info.sensor_id) {
+                LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
+                return ERROR_NONE;
+            }
+            LOG_INF("Read sensor id fail, write id: 0x%x, id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
+            retry--;
+        } while(retry > 0);
+        i++;
+        retry = 2;
+    }
+    if (*sensor_id != imgsensor_info.sensor_id) {
+        // if Sensor ID is not correct, Must set *sensor_id to 0xFFFFFFFF
+        *sensor_id = 0xFFFFFFFF;
+        return ERROR_SENSOR_CONNECT_FAIL;
+    }
+    return ERROR_NONE;
+}
+
+
+/*************************************************************************
+* FUNCTION
+*    open
+*
+* DESCRIPTION
+*    This function initialize the registers of CMOS sensor
+*
+* PARAMETERS
+*    None
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 open(void)
+{
+    kal_uint8 i = 0;
+    kal_uint8 retry = 2;
+    kal_uint32 sensor_id = 0;
+    LOG_1;
+    LOG_2;
+    //sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
+    while (imgsensor_info.i2c_addr_table[i] != 0xff) {
+        spin_lock(&imgsensor_drv_lock);
+        imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
+        spin_unlock(&imgsensor_drv_lock);
+        do {
+            sensor_id = return_sensor_id();
+            if (sensor_id == imgsensor_info.sensor_id) {
+                LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
+                break;
+            }
+            LOG_INF("Read sensor id fail, write id: 0x%x, id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
+            retry--;
+        } while(retry > 0);
+        i++;
+        if (sensor_id == imgsensor_info.sensor_id)
+            break;
+        retry = 2;
+    }
+    if (imgsensor_info.sensor_id != sensor_id)
+        return ERROR_SENSOR_CONNECT_FAIL;
+        
+		if ((read_cmos_sensor(0x302a))==0xb1)
+		{
+				LOG_INF("----R1A---- \n");
+				ov13850_chip_ver = OV13850_R1A;
+		}else if((read_cmos_sensor(0x302a))==0xb2)
+		{
+				LOG_INF("----R2A---- \n");
+				ov13850_chip_ver = OV13850_R2A;
+		}
+    /* initail sequence write in  */
+    sensor_init();
+	  //for OTP
+	  //otp_cali(imgsensor.i2c_write_id);
+	  write_cmos_sensor(0x0100, 0x00);
+	  
+    spin_lock(&imgsensor_drv_lock);
+
+    imgsensor.autoflicker_en= KAL_FALSE;
+    imgsensor.sensor_mode = IMGSENSOR_MODE_INIT;
+    imgsensor.pclk = imgsensor_info.pre.pclk;
+    imgsensor.frame_length = imgsensor_info.pre.framelength;
+    imgsensor.line_length = imgsensor_info.pre.linelength;
+    imgsensor.min_frame_length = imgsensor_info.pre.framelength;
+    imgsensor.dummy_pixel = 0;
+    imgsensor.dummy_line = 0;
+    imgsensor.ihdr_en = 0;
+    imgsensor.test_pattern = KAL_FALSE;
+    imgsensor.current_fps = imgsensor_info.pre.max_framerate;
+    //for zsd multi capture setting
+	capture_first_flag = 0;
+	pre_currefps = 0;
+    spin_unlock(&imgsensor_drv_lock);
+
+    return ERROR_NONE;
+}    /*    open  */
+
+
+
+/*************************************************************************
+* FUNCTION
+*    close
+*
+* DESCRIPTION
+*
+*
+* PARAMETERS
+*    None
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 close(void)
+{
+    LOG_INF("E\n");
+
+    /*No Need to implement this function*/
+
+    return ERROR_NONE;
+}    /*    close  */
+
+
+/*************************************************************************
+* FUNCTION
+* preview
+*
+* DESCRIPTION
+*    This function start the sensor preview.
+*
+* PARAMETERS
+*    *image_window : address pointer of pixel numbers in one period of HSYNC
+*  *sensor_config_data : address pointer of line numbers in one period of VSYNC
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_PREVIEW;
+    imgsensor.pclk = imgsensor_info.pre.pclk;
+    //imgsensor.video_mode = KAL_FALSE;
+    imgsensor.line_length = imgsensor_info.pre.linelength;
+    imgsensor.frame_length = imgsensor_info.pre.framelength;
+    imgsensor.min_frame_length = imgsensor_info.pre.framelength;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    preview_setting();
+    set_mirror_flip(imgsensor.mirror);
+	//set_mirror_flip(sensor_config_data->SensorImageMirror);
+    return ERROR_NONE;
+}    /*    preview   */
+
+/*************************************************************************
+* FUNCTION
+*    capture
+*
+* DESCRIPTION
+*    This function setup the CMOS sensor in capture MY_OUTPUT mode
+*
+* PARAMETERS
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                          MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+	
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_CAPTURE;
+    if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {//PIP capture: 24fps for less than 13M, 20fps for 16M,15fps for 20M
+        imgsensor.pclk = imgsensor_info.cap1.pclk;
+        imgsensor.line_length = imgsensor_info.cap1.linelength;
+        imgsensor.frame_length = imgsensor_info.cap1.framelength;
+        imgsensor.min_frame_length = imgsensor_info.cap1.framelength;
+        imgsensor.autoflicker_en = KAL_FALSE;
+    } else {
+        if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
+            LOG_INF("Warning: current_fps %d fps is not support, so use cap's setting: %d fps!\n",imgsensor.current_fps,imgsensor_info.cap.max_framerate/10);
+        imgsensor.pclk = imgsensor_info.cap.pclk;
+        imgsensor.line_length = imgsensor_info.cap.linelength;
+        imgsensor.frame_length = imgsensor_info.cap.framelength;
+        imgsensor.min_frame_length = imgsensor_info.cap.framelength;
+        imgsensor.autoflicker_en = KAL_FALSE;
+    }
+    spin_unlock(&imgsensor_drv_lock);
+    capture_setting(imgsensor.current_fps);
+	  set_mirror_flip(imgsensor.mirror);
+    return ERROR_NONE;
+}    /* capture() */
+static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_VIDEO;
+    imgsensor.pclk = imgsensor_info.normal_video.pclk;
+    imgsensor.line_length = imgsensor_info.normal_video.linelength;
+    imgsensor.frame_length = imgsensor_info.normal_video.framelength;
+    imgsensor.min_frame_length = imgsensor_info.normal_video.framelength;
+    //imgsensor.current_fps = 300;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    normal_video_setting(imgsensor.current_fps);	
+	//set_mirror_flip(sensor_config_data->SensorImageMirror);
+		set_mirror_flip(imgsensor.mirror);
+    return ERROR_NONE;
+}    /*    normal_video   */
+
+static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_HIGH_SPEED_VIDEO;
+    imgsensor.pclk = imgsensor_info.hs_video.pclk;
+    //imgsensor.video_mode = KAL_TRUE;
+    imgsensor.line_length = imgsensor_info.hs_video.linelength;
+    imgsensor.frame_length = imgsensor_info.hs_video.framelength;
+    imgsensor.min_frame_length = imgsensor_info.hs_video.framelength;
+    imgsensor.dummy_line = 0;
+    imgsensor.dummy_pixel = 0;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    hs_video_setting();	
+	//set_mirror_flip(sensor_config_data->SensorImageMirror);
+		set_mirror_flip(imgsensor.mirror);
+    return ERROR_NONE;
+}    /*    hs_video   */
+
+static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_SLIM_VIDEO;
+    imgsensor.pclk = imgsensor_info.slim_video.pclk;
+    imgsensor.line_length = imgsensor_info.slim_video.linelength;
+    imgsensor.frame_length = imgsensor_info.slim_video.framelength;
+    imgsensor.min_frame_length = imgsensor_info.slim_video.framelength;
+    imgsensor.dummy_line = 0;
+    imgsensor.dummy_pixel = 0;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    slim_video_setting();
+	//set_mirror_flip(sensor_config_data->SensorImageMirror);
+		set_mirror_flip(imgsensor.mirror);
+    return ERROR_NONE;
+}    /*    slim_video     */
+
+
+
+static kal_uint32 get_resolution(MSDK_SENSOR_RESOLUTION_INFO_STRUCT *sensor_resolution)
+{
+    LOG_INF("E\n");
+    sensor_resolution->SensorFullWidth = imgsensor_info.cap.grabwindow_width;
+    sensor_resolution->SensorFullHeight = imgsensor_info.cap.grabwindow_height;
+
+    sensor_resolution->SensorPreviewWidth = imgsensor_info.pre.grabwindow_width;
+    sensor_resolution->SensorPreviewHeight = imgsensor_info.pre.grabwindow_height;
+
+    sensor_resolution->SensorVideoWidth = imgsensor_info.normal_video.grabwindow_width;
+    sensor_resolution->SensorVideoHeight = imgsensor_info.normal_video.grabwindow_height;
+
+
+    sensor_resolution->SensorHighSpeedVideoWidth     = imgsensor_info.hs_video.grabwindow_width;
+    sensor_resolution->SensorHighSpeedVideoHeight     = imgsensor_info.hs_video.grabwindow_height;
+
+    sensor_resolution->SensorSlimVideoWidth     = imgsensor_info.slim_video.grabwindow_width;
+    sensor_resolution->SensorSlimVideoHeight     = imgsensor_info.slim_video.grabwindow_height;
+    return ERROR_NONE;
+}    /*    get_resolution    */
+
+static kal_uint32 get_info(MSDK_SCENARIO_ID_ENUM scenario_id,
+                      MSDK_SENSOR_INFO_STRUCT *sensor_info,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("scenario_id = %d\n", scenario_id);
+
+
+    //sensor_info->SensorVideoFrameRate = imgsensor_info.normal_video.max_framerate/10; /* not use */
+    //sensor_info->SensorStillCaptureFrameRate= imgsensor_info.cap.max_framerate/10; /* not use */
+    //imgsensor_info->SensorWebCamCaptureFrameRate= imgsensor_info.v.max_framerate; /* not use */
+
+    sensor_info->SensorClockPolarity = SENSOR_CLOCK_POLARITY_LOW;
+    sensor_info->SensorClockFallingPolarity = SENSOR_CLOCK_POLARITY_LOW; /* not use */
+    sensor_info->SensorHsyncPolarity = SENSOR_CLOCK_POLARITY_LOW; // inverse with datasheet
+    sensor_info->SensorVsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
+    sensor_info->SensorInterruptDelayLines = 4; /* not use */
+    sensor_info->SensorResetActiveHigh = FALSE; /* not use */
+    sensor_info->SensorResetDelayCount = 5; /* not use */
+
+    sensor_info->SensroInterfaceType = imgsensor_info.sensor_interface_type;
+    sensor_info->MIPIsensorType = imgsensor_info.mipi_sensor_type;
+    sensor_info->SettleDelayMode = imgsensor_info.mipi_settle_delay_mode;
+    sensor_info->SensorOutputDataFormat = imgsensor_info.sensor_output_dataformat;
+
+    sensor_info->CaptureDelayFrame = imgsensor_info.cap_delay_frame;
+    sensor_info->PreviewDelayFrame = imgsensor_info.pre_delay_frame;
+    sensor_info->VideoDelayFrame = imgsensor_info.video_delay_frame;
+    sensor_info->HighSpeedVideoDelayFrame = imgsensor_info.hs_video_delay_frame;
+    sensor_info->SlimVideoDelayFrame = imgsensor_info.slim_video_delay_frame;
+
+    sensor_info->SensorMasterClockSwitch = 0; /* not use */
+    sensor_info->SensorDrivingCurrent = imgsensor_info.isp_driving_current;
+
+    sensor_info->AEShutDelayFrame = imgsensor_info.ae_shut_delay_frame;          /* The frame of setting shutter default 0 for TG int */
+    sensor_info->AESensorGainDelayFrame = imgsensor_info.ae_sensor_gain_delay_frame;    /* The frame of setting sensor gain */
+    sensor_info->AEISPGainDelayFrame = imgsensor_info.ae_ispGain_delay_frame;
+    sensor_info->IHDR_Support = imgsensor_info.ihdr_support;
+    sensor_info->IHDR_LE_FirstLine = imgsensor_info.ihdr_le_firstline;
+    sensor_info->SensorModeNum = imgsensor_info.sensor_mode_num;
+
+    sensor_info->SensorMIPILaneNumber = imgsensor_info.mipi_lane_num;
+    sensor_info->SensorClockFreq = imgsensor_info.mclk;
+    sensor_info->SensorClockDividCount = 3; /* not use */
+    sensor_info->SensorClockRisingCount = 0;
+    sensor_info->SensorClockFallingCount = 2; /* not use */
+    sensor_info->SensorPixelClockCount = 3; /* not use */
+    sensor_info->SensorDataLatchCount = 2; /* not use */
+
+    sensor_info->MIPIDataLowPwr2HighSpeedTermDelayCount = 0;
+    sensor_info->MIPICLKLowPwr2HighSpeedTermDelayCount = 0;
+    sensor_info->SensorWidthSampling = 0;  // 0 is default 1x
+    sensor_info->SensorHightSampling = 0;    // 0 is default 1x
+    sensor_info->SensorPacketECCOrder = 1;
+
+    switch (scenario_id) {
+        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+            sensor_info->SensorGrabStartX = imgsensor_info.pre.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
+
+            break;
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+            sensor_info->SensorGrabStartX = imgsensor_info.cap.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.cap.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.cap.mipi_data_lp2hs_settle_dc;
+
+            break;
+        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+
+            sensor_info->SensorGrabStartX = imgsensor_info.normal_video.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.normal_video.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.normal_video.mipi_data_lp2hs_settle_dc;
+
+            break;
+        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+            sensor_info->SensorGrabStartX = imgsensor_info.hs_video.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.hs_video.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.hs_video.mipi_data_lp2hs_settle_dc;
+
+            break;
+        case MSDK_SCENARIO_ID_SLIM_VIDEO:
+            sensor_info->SensorGrabStartX = imgsensor_info.slim_video.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.slim_video.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.slim_video.mipi_data_lp2hs_settle_dc;
+
+            break;
+        default:
+            sensor_info->SensorGrabStartX = imgsensor_info.pre.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
+            break;
+    }
+
+    return ERROR_NONE;
+}    /*    get_info  */
+
+
+static kal_uint32 control(MSDK_SCENARIO_ID_ENUM scenario_id, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("scenario_id = %d\n", scenario_id);
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.current_scenario_id = scenario_id;
+    spin_unlock(&imgsensor_drv_lock);
+    switch (scenario_id) {
+        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+			capture_first_flag = 0;
+			pre_currefps = 0;
+            preview(image_window, sensor_config_data);
+            break;
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+            capture(image_window, sensor_config_data);
+            break;
+        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+			capture_first_flag = 0;
+			pre_currefps = 0;
+            normal_video(image_window, sensor_config_data);
+            break;
+        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+			capture_first_flag = 0;
+			pre_currefps = 0;
+            hs_video(image_window, sensor_config_data);
+            break;
+        case MSDK_SCENARIO_ID_SLIM_VIDEO:
+			capture_first_flag = 0;
+			pre_currefps = 0;
+            slim_video(image_window, sensor_config_data);
+            break;
+        default:
+            LOG_INF("Error ScenarioId setting");
+			capture_first_flag = 0;
+			pre_currefps = 0;
+            preview(image_window, sensor_config_data);
+            return ERROR_INVALID_SCENARIO_ID;
+    }
+    return ERROR_NONE;
+}    /* control() */
+
+
+
+static kal_uint32 set_video_mode(UINT16 framerate)
+{//This Function not used after ROME
+    LOG_INF("framerate = %d\n ", framerate);
+    // SetVideoMode Function should fix framerate
+    if (framerate == 0)
+        // Dynamic frame rate
+        return ERROR_NONE;
+    spin_lock(&imgsensor_drv_lock);
+    if ((framerate == 300) && (imgsensor.autoflicker_en == KAL_TRUE))
+        imgsensor.current_fps = 296;
+    else if ((framerate == 150) && (imgsensor.autoflicker_en == KAL_TRUE))
+        imgsensor.current_fps = 146;
+    else
+        imgsensor.current_fps = framerate;
+    spin_unlock(&imgsensor_drv_lock);
+    set_max_framerate(imgsensor.current_fps,1);
+
+    return ERROR_NONE;
+}
+
+static kal_uint32 set_auto_flicker_mode(kal_bool enable, UINT16 framerate)
+{
+    LOG_INF("enable = %d, framerate = %d \n", enable, framerate);
+    spin_lock(&imgsensor_drv_lock);
+    if (enable) //enable auto flicker
+        imgsensor.autoflicker_en = KAL_TRUE;
+    else //Cancel Auto flick
+        imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    return ERROR_NONE;
+}
+
+
+static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 framerate)
+{
+    kal_uint32 frame_length;
+
+    LOG_INF("scenario_id = %d, framerate = %d\n", scenario_id, framerate);
+
+    switch (scenario_id) {
+        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+            frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            //set_dummy();
+            break;
+        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+            if(framerate == 0)
+                return ERROR_NONE;
+            frame_length = imgsensor_info.normal_video.pclk / framerate * 10 / imgsensor_info.normal_video.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.normal_video.framelength) ? (frame_length - imgsensor_info.normal_video.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.normal_video.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            //set_dummy();
+            break;
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+        	  if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {
+                frame_length = imgsensor_info.cap1.pclk / framerate * 10 / imgsensor_info.cap1.linelength;
+                spin_lock(&imgsensor_drv_lock);
+		            imgsensor.dummy_line = (frame_length > imgsensor_info.cap1.framelength) ? (frame_length - imgsensor_info.cap1.framelength) : 0;
+		            imgsensor.frame_length = imgsensor_info.cap1.framelength + imgsensor.dummy_line;
+		            imgsensor.min_frame_length = imgsensor.frame_length;
+		            spin_unlock(&imgsensor_drv_lock);
+            } else {
+        		    if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
+                    LOG_INF("Warning: current_fps %d fps is not support, so use cap's setting: %d fps!\n",framerate,imgsensor_info.cap.max_framerate/10);
+                frame_length = imgsensor_info.cap.pclk / framerate * 10 / imgsensor_info.cap.linelength;
+                spin_lock(&imgsensor_drv_lock);
+		            imgsensor.dummy_line = (frame_length > imgsensor_info.cap.framelength) ? (frame_length - imgsensor_info.cap.framelength) : 0;
+		            imgsensor.frame_length = imgsensor_info.cap.framelength + imgsensor.dummy_line;
+		            imgsensor.min_frame_length = imgsensor.frame_length;
+		            spin_unlock(&imgsensor_drv_lock);
+            }
+            //set_dummy();
+            break;
+        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+            frame_length = imgsensor_info.hs_video.pclk / framerate * 10 / imgsensor_info.hs_video.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.hs_video.framelength) ? (frame_length - imgsensor_info.hs_video.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.hs_video.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            //set_dummy();
+            break;
+        case MSDK_SCENARIO_ID_SLIM_VIDEO:
+            frame_length = imgsensor_info.slim_video.pclk / framerate * 10 / imgsensor_info.slim_video.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.slim_video.framelength) ? (frame_length - imgsensor_info.slim_video.framelength): 0;
+            imgsensor.frame_length = imgsensor_info.slim_video.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            //set_dummy();
+            break;
+        default:  //coding with  preview scenario by default
+            frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            //set_dummy();
+            LOG_INF("error scenario_id = %d, we use preview scenario \n", scenario_id);
+            break;
+    }
+    return ERROR_NONE;
+}
+
+
+static kal_uint32 get_default_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 *framerate)
+{
+    LOG_INF("scenario_id = %d\n", scenario_id);
+
+    switch (scenario_id) {
+        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+            *framerate = imgsensor_info.pre.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+            *framerate = imgsensor_info.normal_video.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+            *framerate = imgsensor_info.cap.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+            *framerate = imgsensor_info.hs_video.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_SLIM_VIDEO:
+            *framerate = imgsensor_info.slim_video.max_framerate;
+            break;
+        default:
+            break;
+    }
+
+    return ERROR_NONE;
+}
+
+
+
+static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
+                             UINT8 *feature_para,UINT32 *feature_para_len)
+{
+    UINT16 *feature_return_para_16=(UINT16 *) feature_para;
+    UINT16 *feature_data_16=(UINT16 *) feature_para;
+    UINT32 *feature_return_para_32=(UINT32 *) feature_para;
+    UINT32 *feature_data_32=(UINT32 *) feature_para;
+    unsigned long long *feature_data=(unsigned long long *) feature_para;
+    unsigned long long *feature_return_para=(unsigned long long *) feature_para;
+
+    SENSOR_WINSIZE_INFO_STRUCT *wininfo;
+    MSDK_SENSOR_REG_INFO_STRUCT *sensor_reg_data=(MSDK_SENSOR_REG_INFO_STRUCT *) feature_para;
+
+    LOG_INF("feature_id = %d\n", feature_id);
+    switch (feature_id) {
+        case SENSOR_FEATURE_GET_PERIOD:
+            *feature_return_para_16++ = imgsensor.line_length;
+            *feature_return_para_16 = imgsensor.frame_length;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:
+            LOG_INF("feature_Control imgsensor.pclk = %d,imgsensor.current_fps = %d\n", imgsensor.pclk,imgsensor.current_fps);
+            *feature_return_para_32 = imgsensor.pclk;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_SET_ESHUTTER:
+            set_shutter(*feature_data);
+            break;
+        case SENSOR_FEATURE_SET_NIGHTMODE:
+            night_mode((BOOL) *feature_data);
+            break;
+        case SENSOR_FEATURE_SET_GAIN:
+            set_gain((UINT16) *feature_data);
+            break;
+        case SENSOR_FEATURE_SET_FLASHLIGHT:
+            break;
+        case SENSOR_FEATURE_SET_ISP_MASTER_CLOCK_FREQ:
+            break;
+        case SENSOR_FEATURE_SET_REGISTER:
+            write_cmos_sensor(sensor_reg_data->RegAddr, sensor_reg_data->RegData);
+            break;
+        case SENSOR_FEATURE_GET_REGISTER:
+            sensor_reg_data->RegData = read_cmos_sensor(sensor_reg_data->RegAddr);
+            break;
+        case SENSOR_FEATURE_GET_LENS_DRIVER_ID:
+            // get the lens driver ID from EEPROM or just return LENS_DRIVER_ID_DO_NOT_CARE
+            // if EEPROM does not exist in camera module.
+            *feature_return_para_32=LENS_DRIVER_ID_DO_NOT_CARE;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_SET_VIDEO_MODE:
+            set_video_mode(*feature_data);
+            break;
+        case SENSOR_FEATURE_CHECK_SENSOR_ID:
+            get_imgsensor_id(feature_return_para_32);
+            break;
+        case SENSOR_FEATURE_SET_AUTO_FLICKER_MODE:
+            set_auto_flicker_mode((BOOL)*feature_data_16,*(feature_data_16+1));
+            break;
+        case SENSOR_FEATURE_SET_MAX_FRAME_RATE_BY_SCENARIO:
+            set_max_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data, *(feature_data+1));
+            break;
+        case SENSOR_FEATURE_GET_DEFAULT_FRAME_RATE_BY_SCENARIO:
+            get_default_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*(feature_data), (MUINT32 *)(uintptr_t)(*(feature_data+1)));
+            break;
+        case SENSOR_FEATURE_SET_TEST_PATTERN:
+            set_test_pattern_mode((BOOL)*feature_data);
+            break;
+        case SENSOR_FEATURE_GET_TEST_PATTERN_CHECKSUM_VALUE: //for factory mode auto testing
+            *feature_return_para_32 = imgsensor_info.checksum_value;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_SET_FRAMERATE:
+            LOG_INF("current fps :%d\n", *feature_data);
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.current_fps = *feature_data;
+            spin_unlock(&imgsensor_drv_lock);
+            break;
+        case SENSOR_FEATURE_SET_HDR:
+            LOG_INF("ihdr enable :%d\n", (BOOL)*feature_data);
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.ihdr_en = (BOOL)*feature_data;
+            spin_unlock(&imgsensor_drv_lock);
+            break;
+        case SENSOR_FEATURE_GET_CROP_INFO:
+            LOG_INF("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n", *feature_data);
+
+            wininfo = (SENSOR_WINSIZE_INFO_STRUCT *)(uintptr_t)(*(feature_data+1));
+
+            switch (*feature_data_32) {
+                case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[1],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[2],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[3],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_SLIM_VIDEO:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[4],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+                default:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[0],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+            }
+        case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
+            LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",(UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
+            ihdr_write_shutter_gain((UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
+            break;
+        default:
+            break;
+    }
+
+    return ERROR_NONE;
+}    /*    feature_control()  */
+
+static SENSOR_FUNCTION_STRUCT sensor_func = {
+    open,
+    get_info,
+    get_resolution,
+    feature_control,
+    control,
+    close
+};
+
+UINT32 OV13850_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
+{
+    /* To Do : Check Sensor status here */
+    if (pfFunc!=NULL)
+        *pfFunc=&sensor_func;
+    return ERROR_NONE;
+}    /*    OV13850_MIPI_RAW_SensorInit    */
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/ov13850_mipi_raw/ov13850mipiraw_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735/ov13850_mipi_raw/ov13850mipiraw_Sensor.h
new file mode 100755
index 0000000..5c70215
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735/ov13850_mipi_raw/ov13850mipiraw_Sensor.h
@@ -0,0 +1,123 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *     OV13850mipiraw_Sensor.h
+ *
+ * Project:
+ * --------
+ *     ALPS
+ *
+ * Description:
+ * ------------
+ *     CMOS sensor header file
+ *
+ ****************************************************************************/
+#ifndef _OV13850MIPIRAW_SENSOR_H
+#define _OV13850MIPIRAW_SENSOR_H
+
+
+typedef enum{
+    IMGSENSOR_MODE_INIT,
+    IMGSENSOR_MODE_PREVIEW,
+    IMGSENSOR_MODE_CAPTURE,
+    IMGSENSOR_MODE_VIDEO,
+    IMGSENSOR_MODE_HIGH_SPEED_VIDEO,
+    IMGSENSOR_MODE_SLIM_VIDEO,
+} IMGSENSOR_MODE;
+
+typedef struct imgsensor_mode_struct {
+    kal_uint32 pclk;                //record different mode's pclk
+    kal_uint32 linelength;            //record different mode's linelength
+    kal_uint32 framelength;            //record different mode's framelength
+
+    kal_uint8 startx;                //record different mode's startx of grabwindow
+    kal_uint8 starty;                //record different mode's startx of grabwindow
+
+    kal_uint16 grabwindow_width;    //record different mode's width of grabwindow
+    kal_uint16 grabwindow_height;    //record different mode's height of grabwindow
+
+    /*     following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario    */
+    kal_uint8 mipi_data_lp2hs_settle_dc;
+
+    /*     following for GetDefaultFramerateByScenario()    */
+    kal_uint16 max_framerate;
+
+} imgsensor_mode_struct;
+
+/* SENSOR PRIVATE STRUCT FOR VARIABLES*/
+typedef struct imgsensor_struct {
+    kal_uint8 mirror;                //mirrorflip information
+
+    kal_uint8 sensor_mode;            //record IMGSENSOR_MODE enum value
+
+    kal_uint32 shutter;                //current shutter
+    kal_uint16 gain;                //current gain
+
+    kal_uint32 pclk;                //current pclk
+
+    kal_uint32 frame_length;        //current framelength
+    kal_uint32 line_length;            //current linelength
+
+    kal_uint32 min_frame_length;    //current min  framelength to max framerate
+    kal_uint16 dummy_pixel;            //current dummypixel
+    kal_uint16 dummy_line;            //current dummline
+
+    kal_uint16 current_fps;            //current max fps
+    kal_bool   autoflicker_en;        //record autoflicker enable or disable
+    kal_bool test_pattern;            //record test pattern mode or not
+    MSDK_SCENARIO_ID_ENUM current_scenario_id;//current scenario id
+    kal_uint8  ihdr_en;                //ihdr enable or disable
+
+    kal_uint8 i2c_write_id;            //record current sensor's i2c write id
+} imgsensor_struct;
+
+/* SENSOR PRIVATE STRUCT FOR CONSTANT*/
+typedef struct imgsensor_info_struct {
+    kal_uint32 sensor_id;            //record sensor id defined in Kd_imgsensor.h
+    kal_uint32 checksum_value;        //checksum value for Camera Auto Test
+    imgsensor_mode_struct pre;        //preview scenario relative information
+    imgsensor_mode_struct cap;        //capture scenario relative information
+    imgsensor_mode_struct cap1;        //capture for PIP 24fps relative information, capture1 mode must use same framelength, linelength with Capture mode for shutter calculate
+    imgsensor_mode_struct normal_video;//normal video  scenario relative information
+    imgsensor_mode_struct hs_video;    //high speed video scenario relative information
+    imgsensor_mode_struct slim_video;    //slim video for VT scenario relative information
+
+    kal_uint8  ae_shut_delay_frame;    //shutter delay frame for AE cycle
+    kal_uint8  ae_sensor_gain_delay_frame;    //sensor gain delay frame for AE cycle
+    kal_uint8  ae_ispGain_delay_frame;    //isp gain delay frame for AE cycle
+    kal_uint8  ihdr_support;        //1, support; 0,not support
+    kal_uint8  ihdr_le_firstline;    //1,le first ; 0, se first
+    kal_uint8  sensor_mode_num;        //support sensor mode num
+
+    kal_uint8  cap_delay_frame;        //enter capture delay frame num
+    kal_uint8  pre_delay_frame;        //enter preview delay frame num
+    kal_uint8  video_delay_frame;    //enter video delay frame num
+    kal_uint8  hs_video_delay_frame;    //enter high speed video  delay frame num
+    kal_uint8  slim_video_delay_frame;    //enter slim video delay frame num
+
+    kal_uint8  margin;                //sensor framelength & shutter margin
+    kal_uint32 min_shutter;            //min shutter
+    kal_uint32 max_frame_length;    //max framelength by sensor register's limitation
+
+    kal_uint8  isp_driving_current;    //mclk driving current
+    kal_uint8  sensor_interface_type;//sensor_interface_type
+    kal_uint8  mipi_sensor_type; //0,MIPI_OPHY_NCSI2; 1,MIPI_OPHY_CSI2, default is NCSI2, don't modify this para
+    kal_uint8  mipi_settle_delay_mode; //0, high speed signal auto detect; 1, use settle delay,unit is ns, default is auto detect, don't modify this para
+    kal_uint8  sensor_output_dataformat;//sensor output first pixel color
+    kal_uint8  mclk;                //mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
+
+    kal_uint8  mipi_lane_num;        //mipi lane num
+    kal_uint8  i2c_addr_table[5];    //record sensor support all write id addr, only supprt 4must end with 0xff
+} imgsensor_info_struct;
+
+typedef enum{
+ OV13850_R1A = 0,
+ OV13850_R2A,
+ OV13850_MAX,
+}OV13850_CHIP_VER_ENUM;
+
+extern int iReadRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u8 * a_pRecvData, u16 a_sizeRecvData, u16 i2cId);
+extern int iWriteRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u16 i2cId);
+
+#endif
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/ov2680_mipi_raw/ov2680mipi_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735/ov2680_mipi_raw/ov2680mipi_Sensor.c
index 2fa3dc1..5b62546 100644
--- a/drivers/misc/mediatek/imgsensor/src/mt6735/ov2680_mipi_raw/ov2680mipi_Sensor.c
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735/ov2680_mipi_raw/ov2680mipi_Sensor.c
@@ -143,7 +143,7 @@ static imgsensor_info_struct imgsensor_info = {
 	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_B,//sensor output first pixel color
 	.mclk = 24,//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
 	.mipi_lane_num = SENSOR_MIPI_1_LANE,//mipi lane num
-	.i2c_addr_table = {0x6c, 0xff},//record sensor support all write id addr, only supprt 4must end with 0xff
+	.i2c_addr_table = {0x6c, 0x20, 0xff},//record sensor support all write id addr, only supprt 4must end with 0xff
 };
 
 
@@ -695,8 +695,7 @@ static void slim_video_setting()
 static kal_uint32 get_imgsensor_id(UINT32 *sensor_id) 
 {
 	kal_uint8 i = 0;
-	kal_uint8 retry_total = 1;
-	kal_uint8 retry_cnt = retry_total;
+	kal_uint8 retry = 2;
 	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
 	while (imgsensor_info.i2c_addr_table[i] != 0xff) {
 		spin_lock(&imgsensor_drv_lock);
@@ -709,10 +708,10 @@ static kal_uint32 get_imgsensor_id(UINT32 *sensor_id)
 				return ERROR_NONE;
 			}	
             LOG_INF("Read sensor id fail, write id: 0x%x, id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
-			retry_cnt--;
-		} while(retry_cnt > 0);
+			retry--;
+		} while(retry > 0);
 		i++;
-		retry_cnt = retry_total;
+		retry = 2;
 	}
 	if (*sensor_id != imgsensor_info.sensor_id) {
 		// if Sensor ID is not correct, Must set *sensor_id to 0xFFFFFFFF 
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/ov5648_mipi_raw/ov5648mipi_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735/ov5648_mipi_raw/ov5648mipi_Sensor.c
index cd202af..a0ad24d 100644
--- a/drivers/misc/mediatek/imgsensor/src/mt6735/ov5648_mipi_raw/ov5648mipi_Sensor.c
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735/ov5648_mipi_raw/ov5648mipi_Sensor.c
@@ -42,7 +42,7 @@
 #define LOG_2 LOG_INF("preview 1280*960@30fps,420Mbps/lane; video 1280*960@30fps,420Mbps/lane; capture 5M@15fps,420Mbps/lane\n")
 /****************************   Modify end    *******************************************/
 
-#define LOG_INF(format, args...)    pr_debug(PFX "[%s] " format, __FUNCTION__, ##args)
+#define LOG_INF(format, args...)    xlog_printk(ANDROID_LOG_INFO   , PFX, "[%s] " format, __FUNCTION__, ##args)
 
 static DEFINE_SPINLOCK(imgsensor_drv_lock);
 
@@ -213,7 +213,7 @@ static void set_max_framerate(UINT16 framerate,kal_bool min_framelength_en)
 {
     kal_uint32 frame_length = imgsensor.frame_length;
 
-    LOG_INF("framerate = %d, min framelength should enable = %d\n", framerate,min_framelength_en);
+    LOG_INF("framerate = %d, min framelength should enable? \n", framerate,min_framelength_en);
 
     frame_length = imgsensor.pclk / framerate * 10 / imgsensor.line_length;
 
@@ -378,7 +378,6 @@ static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gai
     //LOG_INF("le:0x%x, se:0x%x, gain:0x%x\n",le,se,gain);
 }
 
-#if 0
 static void set_mirror_flip(kal_uint8 image_mirror)
 {
     LOG_INF("image_mirror = %d\n", image_mirror);
@@ -394,7 +393,14 @@ static void set_mirror_flip(kal_uint8 image_mirror)
        *   ISP and Sensor flip or mirror register bit should be the same!!
        *
        ********************************************************/
-
+/* Vanzo:zhangqingzhan on: Fri, 17 Oct 2014 10:16:30 +0800
+ * TODO: replace this line with your comment
+ */
+    if(0 == strncmp(VANZO_SUB_CAM_ROTATION, "180", 3))
+    {
+      image_mirror = IMAGE_HV_MIRROR;
+    }
+// End of Vanzo: zhangqingzhan
     switch (image_mirror) {
         case IMAGE_NORMAL:
             write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x00));
@@ -417,7 +423,6 @@ static void set_mirror_flip(kal_uint8 image_mirror)
     }
 
 }
-#endif
 
 /*************************************************************************
 * FUNCTION
@@ -1125,7 +1130,7 @@ static kal_uint32 get_imgsensor_id(UINT32 *sensor_id)
                 LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
                 return ERROR_NONE;
             }
-            LOG_INF("Read sensor id fail, write id:0x%x id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
+            LOG_INF("Read sensor id fail, id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
             retry--;
         } while(retry > 0);
         i++;
@@ -1163,7 +1168,7 @@ static kal_uint32 open(void)
     kal_uint32 sensor_id = 0;
     LOG_1;
     LOG_2;
-
+    
     //sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
     while (imgsensor_info.i2c_addr_table[i] != 0xff) {
         spin_lock(&imgsensor_drv_lock);
@@ -1175,7 +1180,7 @@ static kal_uint32 open(void)
                 LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
                 break;
             }
-            LOG_INF("Read sensor id fail, write id:0x%x id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
+            LOG_INF("Read sensor id fail, id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
             retry--;
         } while(retry > 0);
         i++;
@@ -1267,7 +1272,7 @@ static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
     imgsensor.autoflicker_en = KAL_FALSE;
     spin_unlock(&imgsensor_drv_lock);
     preview_setting();
-    //set_mirror_flip(sensor_config_data->SensorImageMirror);
+    set_mirror_flip(sensor_config_data->SensorImageMirror);
     return ERROR_NONE;
 }    /*    preview   */
 
@@ -1301,7 +1306,7 @@ static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
         imgsensor.autoflicker_en = KAL_FALSE;
     } else {
         if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
-            LOG_INF("Warning: current_fps %d fps is not support, so use cap1's setting: %d fps!\n",imgsensor.current_fps,imgsensor_info.cap1.max_framerate/10);
+            LOG_INF("Warning: current_fps %d fps is not support, so use cap1's setting: %d fps!\n",imgsensor_info.cap1.max_framerate/10);
         imgsensor.pclk = imgsensor_info.cap.pclk;
         imgsensor.line_length = imgsensor_info.cap.linelength;
         imgsensor.frame_length = imgsensor_info.cap.framelength;
@@ -1310,7 +1315,7 @@ static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
     }
     spin_unlock(&imgsensor_drv_lock);
     capture_setting(imgsensor.current_fps);
-    //set_mirror_flip(sensor_config_data->SensorImageMirror);
+    set_mirror_flip(sensor_config_data->SensorImageMirror);
     return ERROR_NONE;
 }    /* capture() */
 static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
@@ -1328,7 +1333,7 @@ static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
     imgsensor.autoflicker_en = KAL_FALSE;
     spin_unlock(&imgsensor_drv_lock);
     normal_video_setting(imgsensor.current_fps);
-    //set_mirror_flip(sensor_config_data->SensorImageMirror);
+    set_mirror_flip(sensor_config_data->SensorImageMirror);
     return ERROR_NONE;
 }    /*    normal_video   */
 
@@ -1349,7 +1354,7 @@ static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
     imgsensor.autoflicker_en = KAL_FALSE;
     spin_unlock(&imgsensor_drv_lock);
     hs_video_setting();
-    //set_mirror_flip(sensor_config_data->SensorImageMirror);
+    set_mirror_flip(sensor_config_data->SensorImageMirror);
     return ERROR_NONE;
 }    /*    hs_video   */
 
@@ -1369,7 +1374,7 @@ static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
     imgsensor.autoflicker_en = KAL_FALSE;
     spin_unlock(&imgsensor_drv_lock);
     slim_video_setting();
-    //set_mirror_flip(sensor_config_data->SensorImageMirror);
+    set_mirror_flip(sensor_config_data->SensorImageMirror);
 
     return ERROR_NONE;
 }    /*    slim_video     */
@@ -1534,7 +1539,7 @@ static kal_uint32 control(MSDK_SCENARIO_ID_ENUM scenario_id, MSDK_SENSOR_EXPOSUR
 
 
 static kal_uint32 set_video_mode(UINT16 framerate)
-{//
+{
     LOG_INF("framerate = %d\n ", framerate);
     // SetVideoMode Function should fix framerate
     if (framerate == 0)
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/ov5670_mipi_raw/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6735/ov5670_mipi_raw/Makefile
new file mode 100755
index 0000000..3967d53
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735/ov5670_mipi_raw/Makefile
@@ -0,0 +1,4 @@
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+obj-y += ov5670mipi_Sensor.o
+
+
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/ov5670_mipi_raw/ov5670mipi_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735/ov5670_mipi_raw/ov5670mipi_Sensor.c
new file mode 100644
index 0000000..5f42fab
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735/ov5670_mipi_raw/ov5670mipi_Sensor.c
@@ -0,0 +1,1863 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *	 OV5670mipi_Sensor.c
+ *
+ * Project:
+ * --------
+ *	 ALPS
+ *
+ * Description:
+ * ------------
+ *	 Source code of Sensor driver
+ *
+ *
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *============================================================================
+ ****************************************************************************/
+
+#include <linux/videodev2.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <asm/atomic.h>
+//#include <asm/system.h>
+#include <linux/xlog.h>
+
+#include "kd_camera_hw.h"
+#include "kd_imgsensor.h"
+#include "kd_imgsensor_define.h"
+#include "kd_imgsensor_errcode.h"
+
+#include "ov5670mipi_Sensor.h"
+
+#ifdef CONFIG_COMPAT
+#include <linux/compat.h>
+#endif
+#define PFX "ov5670_camera_sensor"
+//#define LOG_WRN(format, args...) xlog_printk(ANDROID_LOG_WARN ,PFX, "[%S] " format, __FUNCTION__, ##args)
+//#defineLOG_INF(format, args...) xlog_printk(ANDROID_LOG_INFO ,PFX, "[%s] " format, __FUNCTION__, ##args)
+//#define LOG_DBG(format, args...) xlog_printk(ANDROID_LOG_DEBUG ,PFX, "[%S] " format, __FUNCTION__, ##args)
+#define LOG_INF(format, args...)	xlog_printk(ANDROID_LOG_INFO   , PFX, "[%s] " format, __FUNCTION__, ##args)
+
+static DEFINE_SPINLOCK(imgsensor_drv_lock);
+
+
+static imgsensor_info_struct imgsensor_info = { 
+	.sensor_id = OV5670MIPI_SENSOR_ID,		//record sensor id defined in Kd_imgsensor.h
+	
+	.checksum_value = 0x5785ca55,		//checksum value for Camera Auto Test
+	
+	.pre = {
+		.pclk = 102850000,				//record different mode's pclk
+		.linelength = 1676,				//record different mode's linelength
+		.framelength = 2045,			//record different mode's framelength
+		.startx = 0,					//record different mode's startx of grabwindow
+		.starty = 0,					//record different mode's starty of grabwindow
+		.grabwindow_width = 1296,		//record different mode's width of grabwindow
+		.grabwindow_height = 972,		//record different mode's height of grabwindow
+		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
+		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
+		/*	 following for GetDefaultFramerateByScenario()	*/
+		.max_framerate = 300,	
+	},
+	.cap = {
+		.pclk = 102850000,
+		.linelength = 1676,
+		.framelength = 2045,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 2592,
+		.grabwindow_height = 1944,
+		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
+		.max_framerate = 300,
+	},
+	.cap1 = {							//capture for PIP 24fps relative information, capture1 mode must use same framelength, linelength with Capture mode for shutter calculate
+		.pclk = 102850000,
+		.linelength = 2012,
+		.framelength = 2045,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 2592,
+		.grabwindow_height = 1944,
+		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
+		.max_framerate = 250,	//less than 13M(include 13M),cap1 max framerate is 24fps,16M max framerate is 20fps, 20M max framerate is 15fps  
+	},
+	.normal_video = {
+		.pclk = 102850000,
+		.linelength = 1676,
+		.framelength = 2045,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 1296,
+		.grabwindow_height = 972,
+		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
+		.max_framerate = 300,
+	},
+	.hs_video = {
+		.pclk = 102850000,
+		.linelength = 1676,
+		.framelength = 511,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 640,
+		.grabwindow_height = 480,
+		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
+		.max_framerate = 1200,
+	},
+	.slim_video = {
+		.pclk = 102850000,
+		.linelength = 1676,
+		.framelength = 2045,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 1296,
+		.grabwindow_height = 972,
+		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
+		.max_framerate = 300,
+	},
+	.margin = 4,			//sensor framelength & shutter margin
+	.min_shutter = 4,		//min shutter
+	.max_frame_length = 0x7fff,//max framelength by sensor register's limitation
+	.ae_shut_delay_frame = 0,	//shutter delay frame for AE cycle, 2 frame with ispGain_delay-shut_delay=2-0=2
+	.ae_sensor_gain_delay_frame = 0,//sensor gain delay frame for AE cycle,2 frame with ispGain_delay-sensor_gain_delay=2-0=2
+	.ae_ispGain_delay_frame = 2,//isp gain delay frame for AE cycle
+	.ihdr_support = 0,	  //1, support; 0,not support
+	.ihdr_le_firstline = 0,  //1,le first ; 0, se first
+	.sensor_mode_num = 5,	  //support sensor mode num
+	
+	.cap_delay_frame = 2,		//enter capture delay frame num
+	.pre_delay_frame = 2, 		//enter preview delay frame num
+	.video_delay_frame = 2,		//enter video delay frame num
+	.hs_video_delay_frame = 2,	//enter high speed video  delay frame num
+	.slim_video_delay_frame = 2,//enter slim video delay frame num
+	
+	.isp_driving_current = ISP_DRIVING_2MA, //mclk driving current
+    .sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,//sensor_interface_type
+    .mipi_sensor_type = MIPI_OPHY_NCSI2, //0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2
+    .mipi_settle_delay_mode = MIPI_SETTLEDELAY_AUTO,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
+	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_B,//sensor output first pixel color
+	.mclk = 24,//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
+	.mipi_lane_num = SENSOR_MIPI_2_LANE,//mipi lane num
+	.i2c_addr_table = {0x6c, 0x20, 0xff},//record sensor support all write id addr, only supprt 4must end with 0xff
+};
+
+
+static imgsensor_struct imgsensor = {
+	.mirror = IMAGE_HV_MIRROR,				//mirrorflip information
+	.sensor_mode = IMGSENSOR_MODE_INIT, //IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
+	.shutter = 0x4C00,					//current shutter
+	.gain = 0x0200,						//current gain
+	.dummy_pixel = 0,					//current dummypixel
+	.dummy_line = 0,					//current dummyline
+	.current_fps = 0,  //full size current fps : 24fps for PIP, 30fps for Normal or ZSD
+	.autoflicker_en = KAL_FALSE,  //auto flicker enable: KAL_FALSE for disable auto flicker, KAL_TRUE for enable auto flicker
+	.test_pattern = KAL_FALSE,		//test pattern mode or not. KAL_FALSE for in test pattern mode, KAL_TRUE for normal output
+	.current_scenario_id = MSDK_SCENARIO_ID_CAMERA_PREVIEW,//current scenario id
+	.ihdr_en = 0, //sensor need support LE, SE with HDR feature
+	.i2c_write_id = 0x6c,//record current sensor's i2c write id
+};
+
+
+/* Sensor output window information */
+static SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[5] =	 
+{{ 2592, 1944,	  0,	0, 2592, 1944, 1296,  972, 0000, 0000, 1296,  972,	  0,	0, 1296,  972}, // Preview 
+ { 2592, 1944,	  0,	0, 2592, 1944, 2592,  1944, 0000, 0000, 2592,  1944,	  0,	0, 2592,  1944}, // capture 
+ { 2592, 1944,	  0,	0, 2592, 1944, 1296,  972, 0000, 0000, 1296,  972,	  0,	0, 1296,  972}, // video 
+ { 2592, 1944,	  0,	0, 2592, 1944, 640,   480, 0000, 0000, 640,  480,	  0,	0, 640,  480}, //hight speed video 
+ { 2592, 1944,	  0,	0, 2592, 1944, 1296,  972, 0000, 0000, 1296,  972,	  0,	0, 1296,  972}};// slim video 
+
+
+static kal_uint16 read_cmos_sensor(kal_uint32 addr)
+{
+	kal_uint16 get_byte=0;
+
+	char pu_send_cmd[2] = {(char)(addr >> 8), (char)(addr & 0xFF) };
+	iReadRegI2C(pu_send_cmd, 2, (u8*)&get_byte, 1, imgsensor.i2c_write_id);
+
+	return get_byte;
+}
+
+static void write_cmos_sensor(kal_uint32 addr, kal_uint32 para)
+{
+	char pu_send_cmd[3] = {(char)(addr >> 8), (char)(addr & 0xFF), (char)(para & 0xFF)};
+	iWriteRegI2C(pu_send_cmd, 3, imgsensor.i2c_write_id);
+}
+
+static void set_dummy()
+{
+	LOG_INF("dummyline = %d, dummypixels = %d \n", imgsensor.dummy_line, imgsensor.dummy_pixel);
+	/* you can set dummy by imgsensor.dummy_line and imgsensor.dummy_pixel, or you can set dummy by imgsensor.frame_length and imgsensor.line_length */
+	write_cmos_sensor(0x380e, (imgsensor.frame_length >> 8) & 0xFF);
+	write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);	  
+	write_cmos_sensor(0x380c, (imgsensor.line_length >> 8) & 0xFF);
+	write_cmos_sensor(0x380d, imgsensor.line_length & 0xFF);
+  
+}	/*	set_dummy  */
+
+
+static void set_max_framerate(UINT16 framerate,kal_bool min_framelength_en)
+{
+	kal_int16 dummy_line;
+	kal_uint32 frame_length = imgsensor.frame_length;
+	//unsigned long flags;
+
+	LOG_INF("framerate = %d, min framelength should enable? \n", framerate,min_framelength_en);
+   
+	frame_length = imgsensor.pclk / framerate * 10 / imgsensor.line_length;
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.frame_length = (frame_length > imgsensor.min_frame_length) ? frame_length : imgsensor.min_frame_length; 
+	imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
+	//dummy_line = frame_length - imgsensor.min_frame_length;
+	//if (dummy_line < 0)
+		//imgsensor.dummy_line = 0;
+	//else
+		//imgsensor.dummy_line = dummy_line;
+	//imgsensor.frame_length = frame_length + imgsensor.dummy_line;
+	if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+	{
+		imgsensor.frame_length = imgsensor_info.max_frame_length;
+		imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
+	}
+	if (min_framelength_en)
+		imgsensor.min_frame_length = imgsensor.frame_length;
+	spin_unlock(&imgsensor_drv_lock);
+	set_dummy();
+}	/*	set_max_framerate  */
+
+
+static void write_shutter(kal_uint16 shutter)
+{
+    unsigned long flags;
+	kal_uint16 realtime_fps = 0;
+	kal_uint32 frame_length = 0;
+    spin_lock_irqsave(&imgsensor_drv_lock, flags);
+    imgsensor.shutter = shutter;
+    spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
+
+	/* 0x3500, 0x3501, 0x3502 will increase VBLANK to get exposure larger than frame exposure */
+	/* AE doesn't update sensor gain at capture mode, thus extra exposure lines must be updated here. */
+	
+	// OV Recommend Solution
+	// if shutter bigger than frame_length, should extend frame length first
+	spin_lock(&imgsensor_drv_lock);
+	if (shutter > imgsensor.min_frame_length - imgsensor_info.margin)		
+		imgsensor.frame_length = shutter + imgsensor_info.margin;
+	else
+		imgsensor.frame_length = imgsensor.min_frame_length;
+	if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+		imgsensor.frame_length = imgsensor_info.max_frame_length;
+	spin_unlock(&imgsensor_drv_lock);
+	shutter = (shutter < imgsensor_info.min_shutter) ? imgsensor_info.min_shutter : shutter;
+	shutter = (shutter > (imgsensor_info.max_frame_length - imgsensor_info.margin)) ? (imgsensor_info.max_frame_length - imgsensor_info.margin) : shutter;
+
+    // Framelength should be an even number
+    shutter = (shutter >> 1) << 1;
+    imgsensor.frame_length = (imgsensor.frame_length >> 1) << 1;
+	
+	if (imgsensor.autoflicker_en) { 
+		realtime_fps = imgsensor.pclk / imgsensor.line_length * 10 / imgsensor.frame_length;
+		if(realtime_fps >= 297 && realtime_fps <= 305)
+			set_max_framerate(296,0);
+		else if(realtime_fps >= 147 && realtime_fps <= 150)
+			set_max_framerate(146,0);	
+        else {
+        // Extend frame length
+        write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
+        write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
+        }
+	} else {
+		// Extend frame length
+		write_cmos_sensor(0x380e, (imgsensor.frame_length >> 8)& 0xFF);
+		write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
+	}
+
+	// Update Shutter
+	write_cmos_sensor(0x3502, (shutter << 4) & 0xF0);
+	write_cmos_sensor(0x3501, (shutter >> 4) & 0xFF);	  
+	write_cmos_sensor(0x3500, (shutter >> 12) & 0x0F);	
+	LOG_INF("Exit! shutter =%d, framelength =%d\n", shutter,imgsensor.frame_length);
+
+	//LOG_INF("frame_length = %d ", frame_length);
+	
+}	/*	write_shutter  */
+
+
+
+/*************************************************************************
+* FUNCTION
+*	set_shutter
+*
+* DESCRIPTION
+*	This function set e-shutter of sensor to change exposure time.
+*
+* PARAMETERS
+*	iShutter : exposured lines
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static void set_shutter(kal_uint16 shutter)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&imgsensor_drv_lock, flags);
+	imgsensor.shutter = shutter;
+	spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
+	
+	write_shutter(shutter);
+}	/*	set_shutter */
+
+
+
+static kal_uint16 gain2reg(const kal_uint16 gain)
+{
+	kal_uint16 reg_gain = 0x0000;
+	
+	reg_gain = ((gain * 128)/BASEGAIN);
+	//reg_gain = ((gain /BASEGAIN)<<7)+((gain % BASEGAIN)<<7/BASEGAIN);
+	reg_gain = reg_gain & 0xFFFF;
+	return (kal_uint16)reg_gain;
+}
+
+/*************************************************************************
+* FUNCTION
+*	set_gain
+*
+* DESCRIPTION
+*	This function is to set global gain to sensor.
+*
+* PARAMETERS
+*	iGain : sensor global gain(base: 0x40)
+*
+* RETURNS
+*	the actually gain set to sensor.
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint16 set_gain(kal_uint16 gain)
+{
+	kal_uint16 reg_gain;
+	kal_uint16 iGain =1;
+	kal_uint8 ChangeFlag=0x07;
+
+	/* 0x350A[0:1], 0x350B[0:7] AGC real gain */
+	/* [0:3] = N meams N /16 X	*/
+	/* [4:9] = M meams M X		 */
+	/* Total gain = M + N /16 X   */
+
+	//
+	if (gain < BASEGAIN || gain > 8 * BASEGAIN) {
+		LOG_INF("Error gain setting");
+
+		if (gain < BASEGAIN)
+			gain = BASEGAIN;
+		else if (gain > 8 * BASEGAIN)
+			gain = 8 * BASEGAIN;		 
+		}
+
+		iGain = gain/BASEGAIN;
+		
+		if(iGain<2){
+			ChangeFlag= 0x00;
+		}
+		else if(iGain<4){
+			ChangeFlag= 0x01;
+		}
+		else if(iGain<8){
+			ChangeFlag= 0x03;
+		}
+		else{
+			ChangeFlag= 0x07;
+		}
+ 
+	reg_gain = gain2reg(gain);
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.gain = reg_gain; 
+	spin_unlock(&imgsensor_drv_lock);
+	LOG_INF("gain = %d ,reg[0x366a]= %d, reg_gain = 0x%x\n ", gain, ChangeFlag, reg_gain);
+
+	write_cmos_sensor(0x301d, 0xf0);
+	write_cmos_sensor(0x3209, 0x00);
+	write_cmos_sensor(0x320a, 0x01);
+	
+	//group write  hold
+	//group 0:delay 0x366a for one frame
+	write_cmos_sensor(0x3208, 0x00);
+	write_cmos_sensor(0x366a, ChangeFlag);
+	write_cmos_sensor(0x3208, 0x10);
+
+	//group 1:all other registers( gain)
+	write_cmos_sensor(0x3208, 0x01);
+	write_cmos_sensor(0x3508, reg_gain >> 8);
+	write_cmos_sensor(0x3509, reg_gain & 0xFF);    
+
+	write_cmos_sensor(0x3208, 0x11);
+
+	//group lanch
+	write_cmos_sensor(0x320B, 0x15);
+	write_cmos_sensor(0x3208, 0xA1);
+	
+	return gain;
+}	/*	set_gain  */
+
+static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gain)
+{
+	LOG_INF("le:0x%x, se:0x%x, gain:0x%x\n",le,se,gain);
+	if (imgsensor.ihdr_en) {
+		
+		spin_lock(&imgsensor_drv_lock);
+			if (le > imgsensor.min_frame_length - imgsensor_info.margin)		
+				imgsensor.frame_length = le + imgsensor_info.margin;
+			else
+				imgsensor.frame_length = imgsensor.min_frame_length;
+			if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+				imgsensor.frame_length = imgsensor_info.max_frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			if (le < imgsensor_info.min_shutter) le = imgsensor_info.min_shutter;
+			if (se < imgsensor_info.min_shutter) se = imgsensor_info.min_shutter;
+			
+			
+				// Extend frame length first
+				write_cmos_sensor(0x380e, (imgsensor.frame_length >> 8)& 0xFF);
+				write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
+
+		write_cmos_sensor(0x3502, (le << 4) & 0xFF);
+		write_cmos_sensor(0x3501, (le >> 4) & 0xFF);	 
+		write_cmos_sensor(0x3500, (le >> 12) & 0x0F);
+		
+		write_cmos_sensor(0x3508, (se << 4) & 0xFF); 
+		write_cmos_sensor(0x3507, (se >> 4) & 0xFF);
+		write_cmos_sensor(0x3506, (se >> 12) & 0x0F); 
+
+		set_gain(gain);
+	}
+
+}
+
+
+
+static void set_mirror_flip(kal_uint8 image_mirror)
+{
+	LOG_INF("image_mirror = %d\n", image_mirror);
+
+	/********************************************************
+	   *
+	   *   0x3820[2] ISP Vertical flip
+	   *   0x3820[1] Sensor Vertical flip
+	   *
+	   *   0x3821[2] ISP Horizontal mirror
+	   *   0x3821[1] Sensor Horizontal mirror
+	   *
+	   *   ISP and Sensor flip or mirror register bit should be the same!!
+	   *
+	   ********************************************************/
+	
+	switch (image_mirror) {
+		case IMAGE_NORMAL:
+			write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x00));
+			write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x06));
+			break;
+		case IMAGE_H_MIRROR:
+			write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x00));
+			write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x00));
+			break;
+		case IMAGE_V_MIRROR:
+			write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x06));
+			write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x06));		
+			break;
+		case IMAGE_HV_MIRROR:
+			write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x06));
+			write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x00));
+			break;
+		default:
+			LOG_INF("Error image_mirror setting\n");
+	}
+
+}
+
+/*************************************************************************
+* FUNCTION
+*	night_mode
+*
+* DESCRIPTION
+*	This function night mode of sensor.
+*
+* PARAMETERS
+*	bEnable: KAL_TRUE -> enable night mode, otherwise, disable night mode
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static void night_mode(kal_bool enable)
+{
+/*No Need to implement this function*/ 
+}	/*	night_mode	*/
+
+static void sensor_init(void)
+{
+	LOG_INF("OV5670_Sensor_Init_2lane E\n");
+	
+	write_cmos_sensor(0x0103,0x01);// ; software reset
+	mDELAY(10);
+	write_cmos_sensor(0x0100, 0x00);// ; software standby
+	write_cmos_sensor(0x0300, 0x04); 
+	write_cmos_sensor(0x0301, 0x00); 
+	write_cmos_sensor(0x0302, 0x78); //;78
+	write_cmos_sensor(0x0303, 0x00); 
+	write_cmos_sensor(0x0304, 0x03); 
+	write_cmos_sensor(0x0305, 0x01); 
+	write_cmos_sensor(0x0306, 0x01); 
+	write_cmos_sensor(0x030a, 0x00); 
+	write_cmos_sensor(0x030b, 0x00); 
+	write_cmos_sensor(0x030c, 0x00); 
+	write_cmos_sensor(0x030d, 0x1e); 
+	write_cmos_sensor(0x030e, 0x00); 
+	write_cmos_sensor(0x030f, 0x06); 
+	write_cmos_sensor(0x0312, 0x01); 
+	write_cmos_sensor(0x3000, 0x00); 
+	write_cmos_sensor(0x3002, 0x21); 
+	write_cmos_sensor(0x3005, 0xf0); 
+	write_cmos_sensor(0x3007, 0x00); 
+	write_cmos_sensor(0x3015, 0x0f); 
+	write_cmos_sensor(0x3018, 0x32); 
+	write_cmos_sensor(0x301a, 0xf0); 
+	write_cmos_sensor(0x301b, 0xf0); 
+	write_cmos_sensor(0x301c, 0xf0); 
+	write_cmos_sensor(0x301d, 0xf0); 
+	write_cmos_sensor(0x301e, 0xf0); 
+	write_cmos_sensor(0x3030, 0x00); 
+	write_cmos_sensor(0x3031, 0x0a); 
+	write_cmos_sensor(0x303c, 0xff); 
+	write_cmos_sensor(0x303e, 0xff); 
+	write_cmos_sensor(0x3040, 0xf0); 
+	write_cmos_sensor(0x3041, 0x00); 
+	write_cmos_sensor(0x3042, 0xf0); 
+	write_cmos_sensor(0x3106, 0x11); 
+	write_cmos_sensor(0x3500, 0x00); 
+	write_cmos_sensor(0x3501, 0x7b); 
+	write_cmos_sensor(0x3502, 0x00); 
+	write_cmos_sensor(0x3503, 0x04); 
+	write_cmos_sensor(0x3504, 0x03); 
+	write_cmos_sensor(0x3505, 0x83); 
+	write_cmos_sensor(0x3508, 0x07); 
+	write_cmos_sensor(0x3509, 0x80); 
+	write_cmos_sensor(0x350e, 0x04); 
+	write_cmos_sensor(0x350f, 0x00); 
+	write_cmos_sensor(0x3510, 0x00); 
+	write_cmos_sensor(0x3511, 0x02); 
+	write_cmos_sensor(0x3512, 0x00); 
+	write_cmos_sensor(0x3601, 0xc8); 
+	write_cmos_sensor(0x3610, 0x88); 
+	write_cmos_sensor(0x3612, 0x48); 
+	write_cmos_sensor(0x3614, 0x5b); 
+	write_cmos_sensor(0x3615, 0x96); 
+	write_cmos_sensor(0x3621, 0xd0); 
+	write_cmos_sensor(0x3622, 0x00); 
+	write_cmos_sensor(0x3623, 0x00); 
+	write_cmos_sensor(0x3633, 0x13); 
+	write_cmos_sensor(0x3634, 0x13); 
+	write_cmos_sensor(0x3635, 0x13); 
+	write_cmos_sensor(0x3636, 0x13); 
+	write_cmos_sensor(0x3645, 0x13); 
+	write_cmos_sensor(0x3646, 0x82); 
+	write_cmos_sensor(0x3650, 0x00); 
+	write_cmos_sensor(0x3652, 0xff); 
+	write_cmos_sensor(0x3655, 0x20); 
+	write_cmos_sensor(0x3656, 0xff); 
+	write_cmos_sensor(0x365a, 0xff); 
+	write_cmos_sensor(0x365e, 0xff); 
+	write_cmos_sensor(0x3668, 0x00); 
+	write_cmos_sensor(0x366a, 0x07); 
+	write_cmos_sensor(0x366e, 0x10); 
+	write_cmos_sensor(0x366d, 0x00); 
+	write_cmos_sensor(0x366f, 0x80); 
+	write_cmos_sensor(0x3700, 0x28); 
+	write_cmos_sensor(0x3701, 0x10); 
+	write_cmos_sensor(0x3702, 0x3a); 
+	write_cmos_sensor(0x3703, 0x19); 
+	write_cmos_sensor(0x3704, 0x10); 
+	write_cmos_sensor(0x3705, 0x00); 
+	write_cmos_sensor(0x3706, 0x66); 
+	write_cmos_sensor(0x3707, 0x08); 
+	write_cmos_sensor(0x3708, 0x34); 
+	write_cmos_sensor(0x3709, 0x40); 
+	write_cmos_sensor(0x370a, 0x01); 
+	write_cmos_sensor(0x370b, 0x1b); 
+	write_cmos_sensor(0x3714, 0x24); 
+	write_cmos_sensor(0x371a, 0x3e); 
+	write_cmos_sensor(0x3733, 0x00); 
+	write_cmos_sensor(0x3734, 0x00); 
+	write_cmos_sensor(0x373a, 0x05); 
+	write_cmos_sensor(0x373b, 0x06); 
+	write_cmos_sensor(0x373c, 0x0a); 
+	write_cmos_sensor(0x373f, 0xa0); 
+	write_cmos_sensor(0x3755, 0x00); 
+	write_cmos_sensor(0x3758, 0x00); 
+	write_cmos_sensor(0x375b, 0x0e);
+	write_cmos_sensor(0x3766, 0x5f); 
+	write_cmos_sensor(0x3768, 0x00); 
+	write_cmos_sensor(0x3769, 0x22); 
+	write_cmos_sensor(0x3773, 0x08); 
+	write_cmos_sensor(0x3774, 0x1f); 
+	write_cmos_sensor(0x3776, 0x06); 
+	write_cmos_sensor(0x37a0, 0x88); 
+	write_cmos_sensor(0x37a1, 0x5c); 
+	write_cmos_sensor(0x37a7, 0x88); 
+	write_cmos_sensor(0x37a8, 0x70); 
+	write_cmos_sensor(0x37aa, 0x88); 
+	write_cmos_sensor(0x37ab, 0x48); 
+	write_cmos_sensor(0x37b3, 0x66); 
+	write_cmos_sensor(0x37c2, 0x04); 
+	write_cmos_sensor(0x37c5, 0x00); 
+	write_cmos_sensor(0x37c8, 0x00); 
+	write_cmos_sensor(0x3800, 0x00); 
+	write_cmos_sensor(0x3801, 0x0c); 
+	write_cmos_sensor(0x3802, 0x00); 
+	write_cmos_sensor(0x3803, 0x04); 
+	write_cmos_sensor(0x3804, 0x0a); 
+	write_cmos_sensor(0x3805, 0x33); 
+	write_cmos_sensor(0x3806, 0x07); 
+	write_cmos_sensor(0x3807, 0xa3); 
+	write_cmos_sensor(0x3808, 0x0a); 
+	write_cmos_sensor(0x3809, 0x20); 
+	write_cmos_sensor(0x380a, 0x07); 
+	write_cmos_sensor(0x380b, 0x98); 
+	write_cmos_sensor(0x380c, 0x06); // ;06
+	write_cmos_sensor(0x380d, 0x8c); // ;8c
+	write_cmos_sensor(0x380e, 0x07); 
+	write_cmos_sensor(0x380f, 0xb8); 
+	write_cmos_sensor(0x3811, 0x04); 
+	write_cmos_sensor(0x3813, 0x02); 
+	write_cmos_sensor(0x3814, 0x01); 
+	write_cmos_sensor(0x3815, 0x01); 
+	write_cmos_sensor(0x3816, 0x00); 
+	write_cmos_sensor(0x3817, 0x00); 
+	write_cmos_sensor(0x3818, 0x00); 
+	write_cmos_sensor(0x3819, 0x00); 
+	write_cmos_sensor(0x3820, 0x80); 
+	write_cmos_sensor(0x3821, 0x46); 
+	write_cmos_sensor(0x3822, 0x48); 
+	write_cmos_sensor(0x3826, 0x00); 
+	write_cmos_sensor(0x3827, 0x08); 
+	write_cmos_sensor(0x382a, 0x01); 
+	write_cmos_sensor(0x382b, 0x01); 
+	write_cmos_sensor(0x3830, 0x08); 
+	write_cmos_sensor(0x3836, 0x02); 
+	write_cmos_sensor(0x3837, 0x00); 
+	write_cmos_sensor(0x3838, 0x10); 
+	write_cmos_sensor(0x3841, 0xff); 
+	write_cmos_sensor(0x3846, 0x48); 
+	write_cmos_sensor(0x3861, 0x00); 
+	write_cmos_sensor(0x3862, 0x04); 
+	write_cmos_sensor(0x3863, 0x06); 
+	write_cmos_sensor(0x3a11, 0x01); 
+	write_cmos_sensor(0x3a12, 0x78); 
+	write_cmos_sensor(0x3b00, 0x00); 
+	write_cmos_sensor(0x3b02, 0x00); 
+	write_cmos_sensor(0x3b03, 0x00); 
+	write_cmos_sensor(0x3b04, 0x00); 
+	write_cmos_sensor(0x3b05, 0x00); 
+	write_cmos_sensor(0x3c00, 0x89); 
+	write_cmos_sensor(0x3c01, 0xab); 
+	write_cmos_sensor(0x3c02, 0x01); 
+	write_cmos_sensor(0x3c03, 0x00); 
+	write_cmos_sensor(0x3c04, 0x00); 
+	write_cmos_sensor(0x3c05, 0x03); 
+	write_cmos_sensor(0x3c06, 0x00); 
+	write_cmos_sensor(0x3c07, 0x05); 
+	write_cmos_sensor(0x3c0c, 0x00); 
+	write_cmos_sensor(0x3c0d, 0x00); 
+	write_cmos_sensor(0x3c0e, 0x00); 
+	write_cmos_sensor(0x3c0f, 0x00); 
+	write_cmos_sensor(0x3c40, 0x00); 
+	write_cmos_sensor(0x3c41, 0xa3); 
+	write_cmos_sensor(0x3c43, 0x7d); 
+	write_cmos_sensor(0x3c45, 0xd7); 
+	write_cmos_sensor(0x3c47, 0xfc); 
+	write_cmos_sensor(0x3c50, 0x05); 
+	write_cmos_sensor(0x3c52, 0xaa); 
+	write_cmos_sensor(0x3c54, 0x71); 
+	write_cmos_sensor(0x3c56, 0x80); 
+	write_cmos_sensor(0x3d85, 0x17); 
+	write_cmos_sensor(0x3f03, 0x00); 
+	write_cmos_sensor(0x3f0a, 0x00); 
+	write_cmos_sensor(0x3f0b, 0x00); 
+	write_cmos_sensor(0x4001, 0x60); 
+	write_cmos_sensor(0x4009, 0x0d); 
+	write_cmos_sensor(0x4020, 0x00); 
+	write_cmos_sensor(0x4021, 0x00); 
+	write_cmos_sensor(0x4022, 0x00); 
+	write_cmos_sensor(0x4023, 0x00); 
+	write_cmos_sensor(0x4024, 0x00); 
+	write_cmos_sensor(0x4025, 0x00); 
+	write_cmos_sensor(0x4026, 0x00); 
+	write_cmos_sensor(0x4027, 0x00); 
+	write_cmos_sensor(0x4028, 0x00); 
+	write_cmos_sensor(0x4029, 0x00); 
+	write_cmos_sensor(0x402a, 0x00); 
+	write_cmos_sensor(0x402b, 0x00); 
+	write_cmos_sensor(0x402c, 0x00); 
+	write_cmos_sensor(0x402d, 0x00); 
+	write_cmos_sensor(0x402e, 0x00); 
+	write_cmos_sensor(0x402f, 0x00); 
+	write_cmos_sensor(0x4040, 0x00); 
+	write_cmos_sensor(0x4041, 0x00); 
+	write_cmos_sensor(0x4042, 0x00); 
+	write_cmos_sensor(0x4043, 0x7a); 
+	write_cmos_sensor(0x4044, 0x00); 
+	write_cmos_sensor(0x4045, 0x7a); 
+	write_cmos_sensor(0x4046, 0x00); 
+	write_cmos_sensor(0x4047, 0x7a); 
+	write_cmos_sensor(0x4048, 0x00); 
+	write_cmos_sensor(0x4049, 0x7a); 
+	write_cmos_sensor(0x4303, 0x00); 
+	write_cmos_sensor(0x4307, 0x30); 
+	write_cmos_sensor(0x4500, 0x58); 
+	write_cmos_sensor(0x4501, 0x04); 
+	write_cmos_sensor(0x4502, 0x40); 
+	write_cmos_sensor(0x4503, 0x10); 
+	write_cmos_sensor(0x4508, 0xaa); 
+	write_cmos_sensor(0x4509, 0xaa); 
+	write_cmos_sensor(0x450a, 0x00); 
+	write_cmos_sensor(0x450b, 0x00); 
+	write_cmos_sensor(0x4600, 0x01); 
+	write_cmos_sensor(0x4601, 0x03); 
+	write_cmos_sensor(0x4700, 0xa4); 
+	write_cmos_sensor(0x4800, 0x6c); 
+	write_cmos_sensor(0x4816, 0x53); 
+	write_cmos_sensor(0x481f, 0x40); 
+	write_cmos_sensor(0x4837, 0x11); // ;11
+	write_cmos_sensor(0x5000, 0x56); 
+	write_cmos_sensor(0x5001, 0x01); 
+	write_cmos_sensor(0x5002, 0x28); 
+	write_cmos_sensor(0x5004, 0x0c); 
+	write_cmos_sensor(0x5006, 0x0c); 
+	write_cmos_sensor(0x5007, 0xe0); 
+	write_cmos_sensor(0x5008, 0x01); 
+	write_cmos_sensor(0x5009, 0xb0); 
+	write_cmos_sensor(0x5901, 0x00); 
+	write_cmos_sensor(0x5a01, 0x00); 
+	write_cmos_sensor(0x5a03, 0x00); 
+	write_cmos_sensor(0x5a04, 0x0c); 
+	write_cmos_sensor(0x5a05, 0xe0); 
+	write_cmos_sensor(0x5a06, 0x09); 
+	write_cmos_sensor(0x5a07, 0xb0); 
+	write_cmos_sensor(0x5a08, 0x06); 
+	write_cmos_sensor(0x5e00, 0x00); 
+	write_cmos_sensor(0x3618, 0x2a); 
+								   
+	//;Ally031414					  
+	write_cmos_sensor(0x3734, 0x40); //	;; Improve HFPN
+	write_cmos_sensor(0x5b00, 0x01);  // ;; [2:0] otp start addr[10:8]
+	write_cmos_sensor(0x5b01, 0x10);  // ;; [7:0] otp start addr[7:0]
+	write_cmos_sensor(0x5b02, 0x01);  // ;; [2:0] otp end addr[10:8]
+	write_cmos_sensor(0x5b03, 0xDB);  // ;; [7:0] otp end addr[7:0]
+	write_cmos_sensor(0x3d8c, 0x71); //; Header address high byte
+	write_cmos_sensor(0x3d8d, 0xEA); //; Header address low byte
+	write_cmos_sensor(0x4017, 0x08); // ; threshold= 2LSB for full size
+								  
+	//;Strong DPC1.53				 
+	write_cmos_sensor(0x5780, 0x3e); 
+	write_cmos_sensor(0x5781, 0x0f); 
+	write_cmos_sensor(0x5782, 0x44); 
+	write_cmos_sensor(0x5783, 0x02); 
+	write_cmos_sensor(0x5784, 0x01); 
+	write_cmos_sensor(0x5785, 0x00); 
+	write_cmos_sensor(0x5786, 0x00); 
+	write_cmos_sensor(0x5787, 0x04); 
+	write_cmos_sensor(0x5788, 0x02); 
+	write_cmos_sensor(0x5789, 0x0f); 
+	write_cmos_sensor(0x578a, 0xfd); 
+	write_cmos_sensor(0x578b, 0xf5); 
+	write_cmos_sensor(0x578c, 0xf5); 
+	write_cmos_sensor(0x578d, 0x03); 
+	write_cmos_sensor(0x578e, 0x08); 
+	write_cmos_sensor(0x578f, 0x0c); 
+	write_cmos_sensor(0x5790, 0x08); 
+	write_cmos_sensor(0x5791, 0x04); 
+	write_cmos_sensor(0x5792, 0x00); 
+	write_cmos_sensor(0x5793, 0x52); 
+	write_cmos_sensor(0x5794, 0xa3); 
+	//;Ping 					  
+	write_cmos_sensor(0x380e, 0x07); //; fps fine adjustment
+	write_cmos_sensor(0x380f, 0xfd); //; fps fine adjustment
+	write_cmos_sensor(0x3503, 0x00); //; real gain [2]   gain no delay, shutter no delay
+	//;added					 
+//	write_cmos_sensor(0x3d85, 0x17); 
+//	write_cmos_sensor(0x3655, 0x20); 
+								   
+	write_cmos_sensor(0x0100, 0x00); //;01
+
+
+}	/*	sensor_init  */
+
+
+static void preview_setting(void)
+{
+	LOG_INF(" OV5670PreviewSetting_2lane enter\n");
+
+	//@@PV_Quarter_size_30fps_800Mbps/lane_1296x972							  
+	//99 1296 972 															  
+	//;;102 3601	157c														  
+	//;;PCLK=HTS*VTS*fps=0x68c*0x7fd*30=1676*2045*30=102.85M					  
+																			  
+	write_cmos_sensor(0x0100, 0x00);  // 	
+	
+	write_cmos_sensor(0x3501, 0x73);  // 							  
+	write_cmos_sensor(0x3502, 0x00);  // 							  
+	write_cmos_sensor(0x3508, 0x01);  // 							  
+	write_cmos_sensor(0x3509, 0x80);  // 	
+//	write_cmos_sensor(0x3623, 0x00);  // 	
+	write_cmos_sensor(0x366e, 0x08);  // 							  
+	write_cmos_sensor(0x370b, 0x1b);  // 							  
+	write_cmos_sensor(0x3808, 0x05);  // 							  
+	write_cmos_sensor(0x3809, 0x10);  // 							  
+	write_cmos_sensor(0x380a, 0x03);  // 							  
+	write_cmos_sensor(0x380b, 0xcc);  //;c0							  
+	write_cmos_sensor(0x380c, 0x06);  // 							  
+	write_cmos_sensor(0x380d, 0x8c);  // 							  
+	write_cmos_sensor(0x380e, 0x07);  //;03							  
+	write_cmos_sensor(0x380f, 0xfd);  //;e0	
+
+
+	
+	write_cmos_sensor(0x3814, 0x03);  // 							  
+	write_cmos_sensor(0x3820, 0x90);  // 							  
+	write_cmos_sensor(0x3821, 0x47);  // 							  
+	write_cmos_sensor(0x382a, 0x03);  // 	
+	
+
+	write_cmos_sensor(0x3845, 0x02);  // 							  
+	write_cmos_sensor(0x4009, 0x05);  // 							  
+	write_cmos_sensor(0x4502, 0x44);  // 							  
+	write_cmos_sensor(0x4508, 0x55);  // 							  
+	write_cmos_sensor(0x4509, 0x55);  // 	
+//	write_cmos_sensor(0x450a, 0x00);  // 	
+	write_cmos_sensor(0x4600, 0x00);  // 							  
+	write_cmos_sensor(0x4601, 0x81);  // 							  
+	write_cmos_sensor(0x4017, 0x10);  //; threshold = 4LSB for Binning 
+	write_cmos_sensor(0x400a, 0x02);  //;							  
+	write_cmos_sensor(0x400b, 0x00);  //;	
+	
+	write_cmos_sensor(0x0100, 0x01);  // 
+
+	
+}	/*	preview_setting  */
+
+static void capture_setting(kal_uint16 currefps)
+{
+	LOG_INF("OV5670CaptureSetting_2lane enter! currefps:%d\n",currefps);
+	if (currefps == 240) { //24fps for PIP
+		write_cmos_sensor(0x0100, 0x00); 
+		
+		write_cmos_sensor(0x3501, 0x5f); //long exposure
+		write_cmos_sensor(0x3502, 0xd0);  //long exposure
+		
+		write_cmos_sensor(0x3508, 0x03);  //gain
+		write_cmos_sensor(0x3509, 0x00);  //gain
+		
+		write_cmos_sensor(0x366e, 0x10); 
+//		write_cmos_sensor(0x3623, 0x00);  // 
+		write_cmos_sensor(0x370b, 0x1b); 
+		write_cmos_sensor(0x3808, 0x0a); 
+		write_cmos_sensor(0x3809, 0x20); 
+		write_cmos_sensor(0x380a, 0x07); 
+		write_cmos_sensor(0x380b, 0x98); 
+		write_cmos_sensor(0x380c, ((imgsensor_info.cap1.linelength >> 8) & 0xFF)); // hts 
+		write_cmos_sensor(0x380d, (imgsensor_info.cap1.linelength & 0xFF)); 	   // hts
+		write_cmos_sensor(0x380e, ((imgsensor_info.cap1.framelength >> 8) & 0xFF));  // vts 
+		write_cmos_sensor(0x380f, (imgsensor_info.cap1.framelength & 0xFF));		 // vts 
+
+		
+		write_cmos_sensor(0x3814, 0x01); 
+		write_cmos_sensor(0x3820, 0x80); 
+		write_cmos_sensor(0x3821, 0x46); 
+		write_cmos_sensor(0x382a, 0x01);
+		
+		write_cmos_sensor(0x4009, 0x0d); 
+		write_cmos_sensor(0x4502, 0x40); 
+		write_cmos_sensor(0x4508, 0xaa); 
+		write_cmos_sensor(0x4509, 0xaa); 
+//		write_cmos_sensor(0x450a, 0x00);  // 
+		write_cmos_sensor(0x4600, 0x01); 
+		write_cmos_sensor(0x4601, 0x03); 
+		write_cmos_sensor(0x4017, 0x08); //threshold= 2LSB for full size
+		write_cmos_sensor(0x400a, 0x02); //
+		write_cmos_sensor(0x400b, 0x00); //
+		
+		write_cmos_sensor(0x0100, 0x01);
+		
+	} else{ // for 30fps need ti update
+		write_cmos_sensor(0x0100, 0x00); 
+		
+		write_cmos_sensor(0x3501, 0x5f); //long exposure
+		write_cmos_sensor(0x3502, 0xd0);  //long exposure
+		
+		write_cmos_sensor(0x3508, 0x03);  //gain
+		write_cmos_sensor(0x3509, 0x00);  //gain
+
+//		write_cmos_sensor(0x3623, 0x00);  //gain
+		write_cmos_sensor(0x366e, 0x10); 
+		write_cmos_sensor(0x370b, 0x1b); 
+		write_cmos_sensor(0x3808, 0x0a); 
+		write_cmos_sensor(0x3809, 0x20); 
+		write_cmos_sensor(0x380a, 0x07); 
+		write_cmos_sensor(0x380b, 0x98); 
+		write_cmos_sensor(0x380c, 0x06); // hts 
+		write_cmos_sensor(0x380d, 0x8c); 	   // hts
+		write_cmos_sensor(0x380e, 0x07);  // vts 
+		write_cmos_sensor(0x380f, 0xfd);		 // vts 
+
+		
+		write_cmos_sensor(0x3814, 0x01); 
+		write_cmos_sensor(0x3820, 0x80); 
+		write_cmos_sensor(0x3821, 0x46); 
+		write_cmos_sensor(0x382a, 0x01);
+		
+		write_cmos_sensor(0x3845, 0x00);  //v_offset for auto size mode
+		
+		write_cmos_sensor(0x4009, 0x0d); 
+		write_cmos_sensor(0x4502, 0x40); 
+		write_cmos_sensor(0x4508, 0xaa); 
+		write_cmos_sensor(0x4509, 0xaa); 
+//		write_cmos_sensor(0x450a, 0x00);  // 
+		write_cmos_sensor(0x4600, 0x01); 
+		write_cmos_sensor(0x4601, 0x03); 
+		write_cmos_sensor(0x4017, 0x08); //threshold= 2LSB for full size
+		write_cmos_sensor(0x400a, 0x02); //
+		write_cmos_sensor(0x400b, 0x00); //
+		
+		write_cmos_sensor(0x0100, 0x01);
+		
+	} 
+	
+		
+}
+
+static void normal_video_setting(kal_uint16 currefps)
+{
+	LOG_INF("normal_video_setting Enter! currefps:%d\n",currefps);
+	
+		//@@PV_Quarter_size_30fps_800Mbps/lane_1296x972							  
+	//99 1296 972 															  
+	//;;102 3601	157c														  
+	//;;PCLK=HTS*VTS*fps=0x68c*0x7fd*30=1676*2045*30=102.85M					  
+																			  
+	write_cmos_sensor(0x0100, 0x00);  // 	
+	
+	write_cmos_sensor(0x3501, 0x73);  // 							  
+	write_cmos_sensor(0x3502, 0x00);  // 							  
+	write_cmos_sensor(0x3508, 0x01);  // 							  
+	write_cmos_sensor(0x3509, 0x80);  // 
+	write_cmos_sensor(0x3623, 0x00);  //gain
+	write_cmos_sensor(0x366e, 0x08);  // 							  
+	write_cmos_sensor(0x370b, 0x1b);  // 							  
+	write_cmos_sensor(0x3808, 0x05);  // 							  
+	write_cmos_sensor(0x3809, 0x10);  // 							  
+	write_cmos_sensor(0x380a, 0x03);  // 							  
+	write_cmos_sensor(0x380b, 0xcc);  //;c0							  
+	write_cmos_sensor(0x380c, ((imgsensor_info.normal_video.linelength >> 8) & 0xFF)); // hts
+	write_cmos_sensor(0x380d, (imgsensor_info.normal_video.linelength & 0xFF)); 	   // hts
+	write_cmos_sensor(0x380e, ((imgsensor_info.normal_video.framelength >> 8) & 0xFF));  // vts 
+	write_cmos_sensor(0x380f, (imgsensor_info.normal_video.framelength & 0xFF));		 // vts 						  
+	write_cmos_sensor(0x3814, 0x03);  // 							  
+	write_cmos_sensor(0x3820, 0x90);  // 							  
+	write_cmos_sensor(0x3821, 0x47);  // 							  
+	write_cmos_sensor(0x382a, 0x03);  // 							  
+	write_cmos_sensor(0x3845, 0x02);  // 							  
+	write_cmos_sensor(0x4009, 0x05);  // 							  
+	write_cmos_sensor(0x4502, 0x44);  // 							  
+	write_cmos_sensor(0x4508, 0x55);  // 							  
+	write_cmos_sensor(0x4509, 0x55);  // 
+	write_cmos_sensor(0x450a, 0x00);  // 
+	write_cmos_sensor(0x4600, 0x00);  // 							  
+	write_cmos_sensor(0x4601, 0x81);  // 							  
+	write_cmos_sensor(0x4017, 0x10);  //; threshold = 4LSB for Binning 
+	write_cmos_sensor(0x400a, 0x02);  //;							  
+	write_cmos_sensor(0x400b, 0x00);  //;	
+	
+	write_cmos_sensor(0x0100, 0x01);  // 	
+}
+static void hs_video_setting()
+{ 
+	LOG_INF("hs_video_setting enter!\n");
+
+//VGA 120fps
+	write_cmos_sensor(0x0100,0x00);
+	write_cmos_sensor(0x3501,0x1f);
+	write_cmos_sensor(0x3502,0x00);
+	write_cmos_sensor(0x3508,0x07);
+	write_cmos_sensor(0x3509,0x80);
+	write_cmos_sensor(0x3623,0x04);
+	write_cmos_sensor(0x366e,0x08);
+	write_cmos_sensor(0x370b,0x1b);
+	write_cmos_sensor(0x3808,0x02);
+	write_cmos_sensor(0x3809,0x80);
+	write_cmos_sensor(0x380a,0x01);
+	write_cmos_sensor(0x380b,0xe0);
+	write_cmos_sensor(0x380c,0x06);
+	write_cmos_sensor(0x380d,0x8c);
+	write_cmos_sensor(0x380e,0x01);
+	write_cmos_sensor(0x380f,0xff);
+	write_cmos_sensor(0x3814,0x07);
+	write_cmos_sensor(0x3820,0x90);
+	write_cmos_sensor(0x3821,0xc6);
+	write_cmos_sensor(0x382a,0x07);
+	write_cmos_sensor(0x3845,0x00);
+	write_cmos_sensor(0x4009,0x05);
+	write_cmos_sensor(0x4502,0x40);
+	write_cmos_sensor(0x4508,0x55);
+	write_cmos_sensor(0x4509,0x55);
+	write_cmos_sensor(0x450a,0x02);
+	write_cmos_sensor(0x4600,0x00);
+	write_cmos_sensor(0x4601,0x40);
+	write_cmos_sensor(0x4017,0x10);
+	write_cmos_sensor(0x400a,0x02);
+	write_cmos_sensor(0x400b,0x00);
+	write_cmos_sensor(0x0100,0x01);
+
+	
+				//@@1080_60fps_800Mbps/lane
+/*
+		//;;99 1920 1080
+		//;;102 3601  1770
+		//;;PCLK=HTS*VTS*fps=0x574*0x4cb*60=1396*1227*60=102.85M
+		write_cmos_sensor(0x0100, 0x00); //
+		write_cmos_sensor(0x3501, 0x45); //
+		write_cmos_sensor(0x3502, 0x00); //
+		write_cmos_sensor(0x3508, 0x02); //
+		write_cmos_sensor(0x3509, 0x80); //
+		write_cmos_sensor(0x366e, 0x10); //
+		write_cmos_sensor(0x370b, 0x05); //; reduce code for 1080p format only
+		write_cmos_sensor(0x3808, 0x07); // H output size : 0x780= 1920
+		write_cmos_sensor(0x3809, 0x80); //
+		write_cmos_sensor(0x380a, 0x04); //  V output size: 0x438 =1080
+		write_cmos_sensor(0x380b, 0x38); //
+		write_cmos_sensor(0x380c, ((imgsensor_info.hs_video.linelength >> 8) & 0xFF)); // hts
+		write_cmos_sensor(0x380d, (imgsensor_info.hs_video.linelength & 0xFF)); 	   // hts
+		write_cmos_sensor(0x380e, ((imgsensor_info.hs_video.framelength >> 8) & 0xFF));  // vts 
+		write_cmos_sensor(0x380f, (imgsensor_info.hs_video.framelength & 0xFF));		 // vts 
+		write_cmos_sensor(0x3814, 0x01); //
+		write_cmos_sensor(0x3820, 0x80); //
+		write_cmos_sensor(0x3821, 0x46); //
+		write_cmos_sensor(0x382a, 0x01); //
+		write_cmos_sensor(0x3845, 0x00); //
+		write_cmos_sensor(0x4009, 0x0d); //
+		write_cmos_sensor(0x4502, 0x40); //
+		write_cmos_sensor(0x4508, 0xaa); //
+		write_cmos_sensor(0x4509, 0xaa); //
+		write_cmos_sensor(0x4600, 0x00); //
+		write_cmos_sensor(0x4601, 0xc0); //
+		write_cmos_sensor(0x4017, 0x08); // ; threshold= 2LSB for full size
+		write_cmos_sensor(0x400a, 0x01); //; blc dark limit to 354 code
+		write_cmos_sensor(0x400b, 0x62); //; blc dark limit to 354 code
+		write_cmos_sensor(0x0100, 0x01); //
+*/
+}
+
+
+static void slim_video_setting()
+{
+	LOG_INF("slim_video_setting enter!\n");
+	
+		//@@PV_Quarter_size_30fps_800Mbps/lane_1296x972 						  
+	//99 1296 972															  
+	//;;102 3601	157c														  
+	//;;PCLK=HTS*VTS*fps=0x68c*0x7fd*30=1676*2045*30=102.85M					  
+																			  
+	write_cmos_sensor(0x0100, 0x00);  //	
+	
+	write_cmos_sensor(0x3501, 0x73);  //							  
+	write_cmos_sensor(0x3502, 0x00);  //							  
+	write_cmos_sensor(0x3508, 0x01);  //							  
+	write_cmos_sensor(0x3509, 0x80);  //							  
+	write_cmos_sensor(0x366e, 0x08);  //	
+	write_cmos_sensor(0x3623, 0x00);  //gain
+	write_cmos_sensor(0x370b, 0x1b);  //							  
+	write_cmos_sensor(0x3808, 0x05);  //							  
+	write_cmos_sensor(0x3809, 0x10);  //							  
+	write_cmos_sensor(0x380a, 0x03);  //							  
+	write_cmos_sensor(0x380b, 0xcc);  //;c0 						  
+	write_cmos_sensor(0x380c, ((imgsensor_info.slim_video.linelength >> 8) & 0xFF)); // hts
+	write_cmos_sensor(0x380d, (imgsensor_info.slim_video.linelength & 0xFF)); 	   // hts
+	write_cmos_sensor(0x380e, ((imgsensor_info.slim_video.framelength >> 8) & 0xFF));  // vts 
+	write_cmos_sensor(0x380f, (imgsensor_info.slim_video.framelength & 0xFF));		 // vts 						  
+	write_cmos_sensor(0x3814, 0x03);  //							  
+	write_cmos_sensor(0x3820, 0x90);  //							  
+	write_cmos_sensor(0x3821, 0x47);  //							  
+	write_cmos_sensor(0x382a, 0x03);  //							  
+	write_cmos_sensor(0x3845, 0x02);  //							  
+	write_cmos_sensor(0x4009, 0x05);  //							  
+	write_cmos_sensor(0x4502, 0x44);  //							  
+	write_cmos_sensor(0x4508, 0x55);  //							  
+	write_cmos_sensor(0x4509, 0x55);  //	
+	write_cmos_sensor(0x450a, 0x00);  // 
+	write_cmos_sensor(0x4600, 0x00);  //							  
+	write_cmos_sensor(0x4601, 0x81);  //							  
+	write_cmos_sensor(0x4017, 0x10);  //; threshold = 4LSB for Binning 
+	write_cmos_sensor(0x400a, 0x02);  //;							  
+	write_cmos_sensor(0x400b, 0x00);  //;	
+	
+	write_cmos_sensor(0x0100, 0x01);  //	
+
+}
+
+
+
+/*************************************************************************
+* FUNCTION
+*	get_imgsensor_id
+*
+* DESCRIPTION
+*	This function get the sensor ID 
+*
+* PARAMETERS
+*	*sensorID : return the sensor ID 
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 get_imgsensor_id(UINT32 *sensor_id) 
+{
+	kal_uint8 i = 0;
+	kal_uint8 retry = 2;
+	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
+	while (imgsensor_info.i2c_addr_table[i] != 0xff) {
+		spin_lock(&imgsensor_drv_lock);
+		imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
+		spin_unlock(&imgsensor_drv_lock);
+		do {
+			*sensor_id = ((read_cmos_sensor(0x300B) << 8) | read_cmos_sensor(0x300C));
+			if (*sensor_id == imgsensor_info.sensor_id) {				
+				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);	  
+				return ERROR_NONE;
+			}	
+			LOG_INF("Read sensor id fail, id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
+			retry--;
+		} while(retry > 0);
+		i++;
+		retry = 2;
+	}
+	if (*sensor_id != imgsensor_info.sensor_id) {
+		// if Sensor ID is not correct, Must set *sensor_id to 0xFFFFFFFF 
+		*sensor_id = 0xFFFFFFFF;
+		return ERROR_SENSOR_CONNECT_FAIL;
+	}
+	return ERROR_NONE;
+}
+
+
+/*************************************************************************
+* FUNCTION
+*	open
+*
+* DESCRIPTION
+*	This function initialize the registers of CMOS sensor
+*
+* PARAMETERS
+*	None
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 open(void)
+{
+	//const kal_uint8 i2c_addr[] = {IMGSENSOR_WRITE_ID_1, IMGSENSOR_WRITE_ID_2};
+	kal_uint8 i = 0;
+	kal_uint8 retry = 2;
+	kal_uint16 sensor_id = 0; 
+	LOG_INF("MIPI 2LANE\n");
+	LOG_INF("preview 1280*960@30fps,864Mbps/lane; video 1280*960@30fps,864Mbps/lane; capture 5M@30fps,864Mbps/lane\n");
+	
+	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
+	while (imgsensor_info.i2c_addr_table[i] != 0xff) {
+		spin_lock(&imgsensor_drv_lock);
+		imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
+		spin_unlock(&imgsensor_drv_lock);
+		do {
+			sensor_id = ((read_cmos_sensor(0x300B) << 8) | read_cmos_sensor(0x300C));
+			if (sensor_id == imgsensor_info.sensor_id) {				
+				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);	  
+				break;
+			}	
+			LOG_INF("Read sensor id fail, id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
+			retry--;
+		} while(retry > 0);
+		i++;
+		if (sensor_id == imgsensor_info.sensor_id)
+			break;
+		retry = 2;
+	}		 
+	if (imgsensor_info.sensor_id != sensor_id)
+		return ERROR_SENSOR_CONNECT_FAIL;
+	
+	/* initail sequence write in  */
+	sensor_init();
+
+	spin_lock(&imgsensor_drv_lock);
+
+	imgsensor.autoflicker_en= KAL_FALSE;
+	imgsensor.sensor_mode = IMGSENSOR_MODE_INIT;
+	imgsensor.shutter = 0x4C00;
+	imgsensor.gain = 0x0200;
+	imgsensor.pclk = imgsensor_info.pre.pclk;
+	imgsensor.frame_length = imgsensor_info.pre.framelength;
+	imgsensor.line_length = imgsensor_info.pre.linelength;
+	imgsensor.min_frame_length = imgsensor_info.pre.framelength;
+	imgsensor.dummy_pixel = 0;
+	imgsensor.dummy_line = 0;
+	imgsensor.ihdr_en = 0;
+	imgsensor.test_pattern = KAL_FALSE;
+	imgsensor.current_fps = imgsensor_info.pre.max_framerate;
+	spin_unlock(&imgsensor_drv_lock);
+
+	return ERROR_NONE;
+}	/*	open  */
+
+
+
+/*************************************************************************
+* FUNCTION
+*	close
+*
+* DESCRIPTION
+*	
+*
+* PARAMETERS
+*	None
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 close(void)
+{
+	LOG_INF("E\n");
+
+	/*No Need to implement this function*/ 
+	
+	return ERROR_NONE;
+}	/*	close  */
+
+
+/*************************************************************************
+* FUNCTION
+* preview
+*
+* DESCRIPTION
+*	This function start the sensor preview.
+*
+* PARAMETERS
+*	*image_window : address pointer of pixel numbers in one period of HSYNC
+*  *sensor_config_data : address pointer of line numbers in one period of VSYNC
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("E\n");
+
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.sensor_mode = IMGSENSOR_MODE_PREVIEW;
+	imgsensor.pclk = imgsensor_info.pre.pclk;
+	//imgsensor.video_mode = KAL_FALSE;
+	imgsensor.line_length = imgsensor_info.pre.linelength;
+	imgsensor.frame_length = imgsensor_info.pre.framelength; 
+	imgsensor.min_frame_length = imgsensor_info.pre.framelength;
+	imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	preview_setting();
+//Vanzo:wujie on 2015.4.16
+    set_mirror_flip(imgsensor.mirror);
+// End of Vanzo:wujie 
+	return ERROR_NONE;
+}	/*	preview   */
+
+/*************************************************************************
+* FUNCTION
+*	capture
+*
+* DESCRIPTION
+*	This function setup the CMOS sensor in capture MY_OUTPUT mode
+*
+* PARAMETERS
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+						  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("E\n");
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.sensor_mode = IMGSENSOR_MODE_CAPTURE;
+	if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {//PIP capture: 24fps for less than 13M, 20fps for 16M,15fps for 20M
+		imgsensor.pclk = imgsensor_info.cap1.pclk;
+		imgsensor.line_length = imgsensor_info.cap1.linelength;
+		imgsensor.frame_length = imgsensor_info.cap1.framelength;  
+		imgsensor.min_frame_length = imgsensor_info.cap1.framelength;
+		imgsensor.autoflicker_en = KAL_FALSE;
+	} else {
+		if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
+            LOG_INF("Warning: current_fps %d fps is not support, so use cap's setting: %d fps!\n",imgsensor.current_fps,imgsensor_info.cap.max_framerate/10);
+		imgsensor.pclk = imgsensor_info.cap.pclk;
+		imgsensor.line_length = imgsensor_info.cap.linelength;
+		imgsensor.frame_length = imgsensor_info.cap.framelength;  
+		imgsensor.min_frame_length = imgsensor_info.cap.framelength;
+		imgsensor.autoflicker_en = KAL_FALSE;
+	}
+
+	spin_unlock(&imgsensor_drv_lock);
+
+	capture_setting(imgsensor.current_fps); 
+//Vanzo:wujie on 2015.4.16
+    set_mirror_flip(imgsensor.mirror);
+// End of Vanzo:wujie 	
+	return ERROR_NONE;
+}	/* capture() */
+static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("E\n");
+	
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.sensor_mode = IMGSENSOR_MODE_VIDEO;
+	imgsensor.pclk = imgsensor_info.normal_video.pclk;
+	imgsensor.line_length = imgsensor_info.normal_video.linelength;
+	imgsensor.frame_length = imgsensor_info.normal_video.framelength;  
+	imgsensor.min_frame_length = imgsensor_info.normal_video.framelength;
+	//imgsensor.current_fps = 300;
+	imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	normal_video_setting(imgsensor.current_fps);
+//Vanzo:wujie on 2015.4.16
+    set_mirror_flip(imgsensor.mirror);
+// End of Vanzo:wujie 	
+	return ERROR_NONE;
+}	/*	normal_video   */
+
+static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("E\n");
+	
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.sensor_mode = IMGSENSOR_MODE_HIGH_SPEED_VIDEO;
+	imgsensor.pclk = imgsensor_info.hs_video.pclk;
+	//imgsensor.video_mode = KAL_TRUE;
+	imgsensor.line_length = imgsensor_info.hs_video.linelength;
+	imgsensor.frame_length = imgsensor_info.hs_video.framelength; 
+	imgsensor.min_frame_length = imgsensor_info.hs_video.framelength;
+	imgsensor.dummy_line = 0;
+	imgsensor.dummy_pixel = 0;
+	imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	hs_video_setting();
+//Vanzo:wujie on 2015.4.16
+    set_mirror_flip(imgsensor.mirror);
+// End of Vanzo:wujie 
+	return ERROR_NONE;
+}	/*	hs_video   */
+
+static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("E\n");
+	
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.sensor_mode = IMGSENSOR_MODE_SLIM_VIDEO;
+	imgsensor.pclk = imgsensor_info.slim_video.pclk;
+	imgsensor.line_length = imgsensor_info.slim_video.linelength;
+	imgsensor.frame_length = imgsensor_info.slim_video.framelength; 
+	imgsensor.min_frame_length = imgsensor_info.slim_video.framelength;
+	imgsensor.dummy_line = 0;
+	imgsensor.dummy_pixel = 0;
+	imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	slim_video_setting();
+//Vanzo:wujie on 2015.4.16
+    set_mirror_flip(imgsensor.mirror);
+// End of Vanzo:wujie 
+	return ERROR_NONE;
+}	/*	slim_video	 */
+
+
+
+static kal_uint32 get_resolution(MSDK_SENSOR_RESOLUTION_INFO_STRUCT *sensor_resolution)
+{
+	LOG_INF("E\n");
+	sensor_resolution->SensorFullWidth = imgsensor_info.cap.grabwindow_width;
+	sensor_resolution->SensorFullHeight = imgsensor_info.cap.grabwindow_height;
+	
+	sensor_resolution->SensorPreviewWidth = imgsensor_info.pre.grabwindow_width;
+	sensor_resolution->SensorPreviewHeight = imgsensor_info.pre.grabwindow_height;
+
+	sensor_resolution->SensorVideoWidth = imgsensor_info.normal_video.grabwindow_width;
+	sensor_resolution->SensorVideoHeight = imgsensor_info.normal_video.grabwindow_height;		
+
+	
+	sensor_resolution->SensorHighSpeedVideoWidth	 = imgsensor_info.hs_video.grabwindow_width;
+	sensor_resolution->SensorHighSpeedVideoHeight	 = imgsensor_info.hs_video.grabwindow_height;
+	
+	sensor_resolution->SensorSlimVideoWidth	 = imgsensor_info.slim_video.grabwindow_width;
+	sensor_resolution->SensorSlimVideoHeight	 = imgsensor_info.slim_video.grabwindow_height;
+	return ERROR_NONE;
+}	/*	get_resolution	*/
+
+static kal_uint32 get_info(MSDK_SCENARIO_ID_ENUM scenario_id,
+					  MSDK_SENSOR_INFO_STRUCT *sensor_info,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("scenario_id = %d\n", scenario_id);
+
+	
+	//sensor_info->SensorVideoFrameRate = imgsensor_info.normal_video.max_framerate/10; /* not use */
+	//sensor_info->SensorStillCaptureFrameRate= imgsensor_info.cap.max_framerate/10; /* not use */
+    //imgsensor_info->SensorWebCamCaptureFrameRate= imgsensor_info.v.max_framerate; /* not use */
+
+    sensor_info->SensorClockPolarity = SENSOR_CLOCK_POLARITY_LOW;
+    sensor_info->SensorClockFallingPolarity = SENSOR_CLOCK_POLARITY_LOW; /* not use */
+    sensor_info->SensorHsyncPolarity = SENSOR_CLOCK_POLARITY_LOW; // inverse with datasheet
+    sensor_info->SensorVsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
+    sensor_info->SensorInterruptDelayLines = 4; /* not use */
+    sensor_info->SensorResetActiveHigh = FALSE; /* not use */
+    sensor_info->SensorResetDelayCount = 5; /* not use */
+
+    sensor_info->SensroInterfaceType = imgsensor_info.sensor_interface_type;
+    sensor_info->MIPIsensorType = imgsensor_info.mipi_sensor_type;
+    sensor_info->SettleDelayMode = imgsensor_info.mipi_settle_delay_mode;
+
+	sensor_info->SensorOutputDataFormat = imgsensor_info.sensor_output_dataformat;
+	sensor_info->CaptureDelayFrame = imgsensor_info.cap_delay_frame; 
+	sensor_info->PreviewDelayFrame = imgsensor_info.pre_delay_frame; 
+	sensor_info->VideoDelayFrame = imgsensor_info.video_delay_frame;
+	sensor_info->HighSpeedVideoDelayFrame = imgsensor_info.hs_video_delay_frame;
+	sensor_info->SlimVideoDelayFrame = imgsensor_info.slim_video_delay_frame;
+
+	sensor_info->SensorMasterClockSwitch = 0; /* not use */
+	sensor_info->SensorDrivingCurrent = imgsensor_info.isp_driving_current;
+	
+	sensor_info->AEShutDelayFrame = imgsensor_info.ae_shut_delay_frame; 		 /* The frame of setting shutter default 0 for TG int */
+	sensor_info->AESensorGainDelayFrame = imgsensor_info.ae_sensor_gain_delay_frame;	/* The frame of setting sensor gain */
+	sensor_info->AEISPGainDelayFrame = imgsensor_info.ae_ispGain_delay_frame;	
+	sensor_info->IHDR_Support = imgsensor_info.ihdr_support;
+	sensor_info->IHDR_LE_FirstLine = imgsensor_info.ihdr_le_firstline;
+	sensor_info->SensorModeNum = imgsensor_info.sensor_mode_num;
+	
+	sensor_info->SensorMIPILaneNumber = imgsensor_info.mipi_lane_num; 
+	sensor_info->SensorClockFreq = imgsensor_info.mclk;
+	sensor_info->SensorClockDividCount = 3; /* not use */
+	sensor_info->SensorClockRisingCount = 0;
+	sensor_info->SensorClockFallingCount = 2; /* not use */
+	sensor_info->SensorPixelClockCount = 3; /* not use */
+	sensor_info->SensorDataLatchCount = 2; /* not use */
+	
+	sensor_info->MIPIDataLowPwr2HighSpeedTermDelayCount = 0; 
+	sensor_info->MIPICLKLowPwr2HighSpeedTermDelayCount = 0;
+	sensor_info->SensorWidthSampling = 0;  // 0 is default 1x
+	sensor_info->SensorHightSampling = 0;	// 0 is default 1x 
+	sensor_info->SensorPacketECCOrder = 1;
+
+	switch (scenario_id) {
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+			sensor_info->SensorGrabStartX = imgsensor_info.pre.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;		
+			
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
+			
+			break;
+		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+			sensor_info->SensorGrabStartX = imgsensor_info.cap.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.cap.starty;
+				  
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.cap.mipi_data_lp2hs_settle_dc; 
+
+			break;	 
+		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+			
+			sensor_info->SensorGrabStartX = imgsensor_info.normal_video.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.normal_video.starty;
+	   
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.normal_video.mipi_data_lp2hs_settle_dc; 
+
+			break;	  
+		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:			
+			sensor_info->SensorGrabStartX = imgsensor_info.hs_video.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.hs_video.starty;
+				  
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.hs_video.mipi_data_lp2hs_settle_dc; 
+
+			break;
+		case MSDK_SCENARIO_ID_SLIM_VIDEO:
+			sensor_info->SensorGrabStartX = imgsensor_info.slim_video.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.slim_video.starty;
+				  
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.slim_video.mipi_data_lp2hs_settle_dc; 
+
+			break;
+		default:			
+			sensor_info->SensorGrabStartX = imgsensor_info.pre.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;		
+			
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
+			break;
+	}
+	
+	return ERROR_NONE;
+}	/*	get_info  */
+
+
+static kal_uint32 control(MSDK_SCENARIO_ID_ENUM scenario_id, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("scenario_id = %d\n", scenario_id);
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.current_scenario_id = scenario_id;
+	spin_unlock(&imgsensor_drv_lock);
+	switch (scenario_id) {
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+			preview(image_window, sensor_config_data);
+			break;
+		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+			capture(image_window, sensor_config_data);
+			break;	
+		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+			normal_video(image_window, sensor_config_data);
+			break;	  
+		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+			hs_video(image_window, sensor_config_data);
+			break;
+		case MSDK_SCENARIO_ID_SLIM_VIDEO:
+			slim_video(image_window, sensor_config_data);
+			break;	  
+		default:
+			LOG_INF("Error ScenarioId setting");
+			preview(image_window, sensor_config_data);
+			return ERROR_INVALID_SCENARIO_ID;
+	}
+	return ERROR_NONE;
+}	/* control() */
+
+
+
+static kal_uint32 set_video_mode(UINT16 framerate)
+{
+	LOG_INF("framerate = %d\n ", framerate);
+	// SetVideoMode Function should fix framerate
+	if (framerate == 0)
+		// Dynamic frame rate
+		return ERROR_NONE;
+	spin_lock(&imgsensor_drv_lock);
+	if ((framerate == 300) && (imgsensor.autoflicker_en == KAL_TRUE))
+		imgsensor.current_fps = 296;
+	else if ((framerate == 150) && (imgsensor.autoflicker_en == KAL_TRUE))
+		imgsensor.current_fps = 146;
+	else
+		imgsensor.current_fps = framerate;
+	spin_unlock(&imgsensor_drv_lock);
+	set_max_framerate(imgsensor.current_fps,1);
+
+	return ERROR_NONE;
+}
+
+static kal_uint32 set_auto_flicker_mode(kal_bool enable, UINT16 framerate)
+{
+	LOG_INF("enable = %d, framerate = %d \n", enable, framerate);
+	spin_lock(&imgsensor_drv_lock);
+	if (enable) //enable auto flicker	  
+		imgsensor.autoflicker_en = KAL_TRUE;
+	else //Cancel Auto flick
+		imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	return ERROR_NONE;
+}
+
+
+static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 framerate) 
+{
+	kal_uint32 frame_length;
+  
+	LOG_INF("scenario_id = %d, framerate = %d\n", scenario_id, framerate);
+
+	switch (scenario_id) {
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+			frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
+			imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			//set_dummy();			
+			break;			
+		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+			if(framerate == 0)
+				return ERROR_NONE;
+			frame_length = imgsensor_info.normal_video.pclk / framerate * 10 / imgsensor_info.normal_video.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = (frame_length > imgsensor_info.normal_video.framelength) ? (frame_length - imgsensor_info.normal_video.framelength) : 0;			
+			imgsensor.frame_length = imgsensor_info.normal_video.framelength + imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			//set_dummy();			
+			break;
+		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:		
+        	  if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {
+                frame_length = imgsensor_info.cap1.pclk / framerate * 10 / imgsensor_info.cap1.linelength;
+                spin_lock(&imgsensor_drv_lock);
+		            imgsensor.dummy_line = (frame_length > imgsensor_info.cap1.framelength) ? (frame_length - imgsensor_info.cap1.framelength) : 0;
+		            imgsensor.frame_length = imgsensor_info.cap1.framelength + imgsensor.dummy_line;
+		            imgsensor.min_frame_length = imgsensor.frame_length;
+		            spin_unlock(&imgsensor_drv_lock);
+            } else {
+        		    if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
+                    LOG_INF("Warning: current_fps %d fps is not support, so use cap's setting: %d fps!\n",framerate,imgsensor_info.cap.max_framerate/10);
+                frame_length = imgsensor_info.cap.pclk / framerate * 10 / imgsensor_info.cap.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = (frame_length > imgsensor_info.cap.framelength) ? (frame_length - imgsensor_info.cap.framelength) : 0;
+			imgsensor.frame_length = imgsensor_info.cap.framelength + imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+            }
+			//set_dummy();			
+			break;	
+		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+			frame_length = imgsensor_info.hs_video.pclk / framerate * 10 / imgsensor_info.hs_video.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = (frame_length > imgsensor_info.hs_video.framelength) ? (frame_length - imgsensor_info.hs_video.framelength) : 0;
+			imgsensor.frame_length = imgsensor_info.hs_video.framelength + imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			//set_dummy();			
+			break;
+		case MSDK_SCENARIO_ID_SLIM_VIDEO:
+			frame_length = imgsensor_info.slim_video.pclk / framerate * 10 / imgsensor_info.slim_video.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = (frame_length > imgsensor_info.slim_video.framelength) ? (frame_length - imgsensor_info.slim_video.framelength): 0;	
+			imgsensor.frame_length = imgsensor_info.slim_video.framelength + imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			//set_dummy();	
+			break;		
+		default:  //coding with  preview scenario by default
+			frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
+			imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			//set_dummy();	
+			LOG_INF("error scenario_id = %d, we use preview scenario \n", scenario_id);
+			break;
+	}	
+	return ERROR_NONE;
+}
+
+
+static kal_uint32 get_default_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 *framerate) 
+{
+	LOG_INF("scenario_id = %d\n", scenario_id);
+
+	switch (scenario_id) {
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+			*framerate = imgsensor_info.pre.max_framerate;
+			break;
+		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+			*framerate = imgsensor_info.normal_video.max_framerate;
+			break;
+		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+			*framerate = imgsensor_info.cap.max_framerate;
+			break;		
+		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+			*framerate = imgsensor_info.hs_video.max_framerate;
+			break;
+		case MSDK_SCENARIO_ID_SLIM_VIDEO: 
+			*framerate = imgsensor_info.slim_video.max_framerate;
+			break;
+		default:
+			break;
+	}
+
+	return ERROR_NONE;
+}
+
+static kal_uint32 set_test_pattern_mode(kal_bool enable)
+{
+	LOG_INF("enable: %d\n", enable);
+
+	if (enable) {
+		// 0x4303[3]: 1 enable,  0 disable
+		// only supports a special color bar test pattern
+		write_cmos_sensor(0x4303,0x08);
+	} else {
+		// 0x4303[3]: 1 enable,  0 disable
+		// only supports a special color bar test pattern
+		write_cmos_sensor(0x4303,0x00);
+	}	 
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.test_pattern = enable;
+	spin_unlock(&imgsensor_drv_lock);
+	return ERROR_NONE;
+}
+
+static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
+							 UINT8 *feature_para,UINT32 *feature_para_len)
+{
+	UINT16 *feature_return_para_16=(UINT16 *) feature_para;
+	UINT16 *feature_data_16=(UINT16 *) feature_para;
+	UINT32 *feature_return_para_32=(UINT32 *) feature_para;
+	UINT32 *feature_data_32=(UINT32 *) feature_para;
+    unsigned long long *feature_data=(unsigned long long *) feature_para;
+    unsigned long long *feature_return_para=(unsigned long long *) feature_para;
+	
+	SENSOR_WINSIZE_INFO_STRUCT *wininfo;	
+	MSDK_SENSOR_REG_INFO_STRUCT *sensor_reg_data=(MSDK_SENSOR_REG_INFO_STRUCT *) feature_para;
+ 
+	LOG_INF("feature_id = %d\n", feature_id);
+	switch (feature_id) {
+		case SENSOR_FEATURE_GET_PERIOD:
+			*feature_return_para_16++ = imgsensor.line_length;
+			*feature_return_para_16 = imgsensor.frame_length;
+			*feature_para_len=4;
+			break;
+		case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:	 
+            LOG_INF("feature_Control imgsensor.pclk = %d,imgsensor.current_fps = %d\n", imgsensor.pclk,imgsensor.current_fps);
+			*feature_return_para_32 = imgsensor.pclk;
+			*feature_para_len=4;
+			break;		   
+		case SENSOR_FEATURE_SET_ESHUTTER:
+            set_shutter(*feature_data);
+			break;
+		case SENSOR_FEATURE_SET_NIGHTMODE:
+            night_mode((BOOL) *feature_data);
+			break;
+		case SENSOR_FEATURE_SET_GAIN:		
+            set_gain((UINT16) *feature_data);
+			break;
+		case SENSOR_FEATURE_SET_FLASHLIGHT:
+			break;
+		case SENSOR_FEATURE_SET_ISP_MASTER_CLOCK_FREQ:
+			break;
+		case SENSOR_FEATURE_SET_REGISTER:
+			write_cmos_sensor(sensor_reg_data->RegAddr, sensor_reg_data->RegData);
+			break;
+		case SENSOR_FEATURE_GET_REGISTER:
+			sensor_reg_data->RegData = read_cmos_sensor(sensor_reg_data->RegAddr);
+			break;
+		case SENSOR_FEATURE_GET_LENS_DRIVER_ID:
+			// get the lens driver ID from EEPROM or just return LENS_DRIVER_ID_DO_NOT_CARE
+			// if EEPROM does not exist in camera module.
+			*feature_return_para_32=LENS_DRIVER_ID_DO_NOT_CARE;
+			*feature_para_len=4;
+			break;
+		case SENSOR_FEATURE_SET_VIDEO_MODE:
+            set_video_mode(*feature_data);
+			break; 
+		case SENSOR_FEATURE_CHECK_SENSOR_ID:
+			get_imgsensor_id(feature_return_para_32); 
+			break; 
+		case SENSOR_FEATURE_SET_AUTO_FLICKER_MODE:
+			set_auto_flicker_mode((BOOL)*feature_data_16,*(feature_data_16+1));
+			break;
+		case SENSOR_FEATURE_SET_MAX_FRAME_RATE_BY_SCENARIO:
+            set_max_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data, *(feature_data+1));
+			break;
+		case SENSOR_FEATURE_GET_DEFAULT_FRAME_RATE_BY_SCENARIO:
+            get_default_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*(feature_data), (MUINT32 *)(uintptr_t)(*(feature_data+1)));
+			break;
+		case SENSOR_FEATURE_SET_TEST_PATTERN:
+            set_test_pattern_mode((BOOL)*feature_data);
+			break;
+		case SENSOR_FEATURE_GET_TEST_PATTERN_CHECKSUM_VALUE: //for factory mode auto testing			 
+			*feature_return_para_32 = imgsensor_info.checksum_value;
+			*feature_para_len=4;							 
+			break;				
+		case SENSOR_FEATURE_SET_FRAMERATE:
+            LOG_INF("current fps :%d\n", *feature_data);
+			spin_lock(&imgsensor_drv_lock);
+            imgsensor.current_fps = *feature_data;
+			spin_unlock(&imgsensor_drv_lock);		
+			break;
+		case SENSOR_FEATURE_SET_HDR:
+            LOG_INF("ihdr enable :%d\n", (BOOL)*feature_data);
+			spin_lock(&imgsensor_drv_lock);
+            imgsensor.ihdr_en = (BOOL)*feature_data;
+			spin_unlock(&imgsensor_drv_lock);		
+			break;
+		case SENSOR_FEATURE_GET_CROP_INFO:
+            LOG_INF("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n", *feature_data);
+
+            wininfo = (SENSOR_WINSIZE_INFO_STRUCT *)(uintptr_t)(*(feature_data+1));
+
+			switch (*feature_data_32) {
+				case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[1],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+					break;	  
+				case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[2],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+					break;
+				case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[3],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+					break;
+				case MSDK_SCENARIO_ID_SLIM_VIDEO:
+					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[4],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+					break;
+				case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+				default:
+					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[0],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+					break;
+			}
+		case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
+            LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",(UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2)); 
+            ihdr_write_shutter_gain((UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));    
+			break;
+		default:
+			break;
+	}
+  
+	return ERROR_NONE;
+}	/*	feature_control()  */
+
+static SENSOR_FUNCTION_STRUCT sensor_func = {
+	open,
+	get_info,
+	get_resolution,
+	feature_control,
+	control,
+	close
+};
+
+UINT32 OV5670_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
+{
+	/* To Do : Check Sensor status here */
+	if (pfFunc!=NULL)
+		*pfFunc=&sensor_func;
+	return ERROR_NONE;
+}	/*	OV5670_MIPI_RAW_SensorInit	*/
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/ov5670_mipi_raw/ov5670mipi_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735/ov5670_mipi_raw/ov5670mipi_Sensor.h
new file mode 100644
index 0000000..7c81d3e
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735/ov5670_mipi_raw/ov5670mipi_Sensor.h
@@ -0,0 +1,124 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *	 OV5670mipi_Sensor.h
+ *
+ * Project:
+ * --------
+ *	 ALPS
+ *
+ * Description:
+ * ------------
+ *	 CMOS sensor header file
+ *
+ ****************************************************************************/
+#ifndef _OV5670MIPI_SENSOR_H
+#define _OV5670MIPI_SENSOR_H
+
+
+typedef enum{
+	IMGSENSOR_MODE_INIT,
+	IMGSENSOR_MODE_PREVIEW,
+	IMGSENSOR_MODE_CAPTURE,
+	IMGSENSOR_MODE_VIDEO,
+	IMGSENSOR_MODE_HIGH_SPEED_VIDEO,
+	IMGSENSOR_MODE_SLIM_VIDEO,
+} IMGSENSOR_MODE;
+
+typedef struct imgsensor_mode_struct {
+	kal_uint32 pclk;				//record different mode's pclk
+	kal_uint32 linelength;			//record different mode's linelength
+	kal_uint32 framelength;			//record different mode's framelength
+
+	kal_uint8 startx;				//record different mode's startx of grabwindow
+	kal_uint8 starty;				//record different mode's startx of grabwindow
+
+	kal_uint16 grabwindow_width;	//record different mode's width of grabwindow
+	kal_uint16 grabwindow_height;	//record different mode's height of grabwindow
+
+	/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
+	kal_uint8 mipi_data_lp2hs_settle_dc;
+
+	/*	 following for GetDefaultFramerateByScenario()	*/
+	kal_uint16 max_framerate;
+	
+} imgsensor_mode_struct;
+
+/* SENSOR PRIVATE STRUCT FOR VARIABLES*/
+typedef struct imgsensor_struct {
+	kal_uint8 mirror;				//mirrorflip information
+
+	kal_uint8 sensor_mode;			//record IMGSENSOR_MODE enum value
+
+	kal_uint32 shutter;				//current shutter
+	kal_uint16 gain;				//current gain
+	
+	kal_uint32 pclk;				//current pclk
+
+	kal_uint32 frame_length;		//current framelength
+	kal_uint32 line_length;			//current linelength
+
+	kal_uint32 min_frame_length;	//current min  framelength to max framerate
+	kal_uint16 dummy_pixel;			//current dummypixel
+	kal_uint16 dummy_line;			//current dummline
+	
+	kal_uint16 current_fps;			//current max fps
+	kal_bool   autoflicker_en;		//record autoflicker enable or disable
+	kal_bool test_pattern;			//record test pattern mode or not
+	MSDK_SCENARIO_ID_ENUM current_scenario_id;//current scenario id
+	kal_uint8  ihdr_en;				//ihdr enable or disable
+	
+	kal_uint8 i2c_write_id;			//record current sensor's i2c write id
+} imgsensor_struct;
+
+/* SENSOR PRIVATE STRUCT FOR CONSTANT*/
+typedef struct imgsensor_info_struct { 
+	kal_uint16 sensor_id;			//record sensor id defined in Kd_imgsensor.h
+	kal_uint32 checksum_value;		//checksum value for Camera Auto Test
+	imgsensor_mode_struct pre;		//preview scenario relative information
+	imgsensor_mode_struct cap;		//capture scenario relative information
+	imgsensor_mode_struct cap1;		//capture for PIP 24fps relative information, capture1 mode must use same framelength, linelength with Capture mode for shutter calculate
+	imgsensor_mode_struct normal_video;//normal video  scenario relative information
+	imgsensor_mode_struct hs_video;	//high speed video scenario relative information
+	imgsensor_mode_struct slim_video;	//slim video for VT scenario relative information
+	
+	kal_uint8  ae_shut_delay_frame;	//shutter delay frame for AE cycle
+	kal_uint8  ae_sensor_gain_delay_frame;	//sensor gain delay frame for AE cycle
+	kal_uint8  ae_ispGain_delay_frame;	//isp gain delay frame for AE cycle
+	kal_uint8  ihdr_support;		//1, support; 0,not support
+	kal_uint8  ihdr_le_firstline;	//1,le first ; 0, se first
+	kal_uint8  sensor_mode_num;		//support sensor mode num
+	
+	kal_uint8  cap_delay_frame;		//enter capture delay frame num
+	kal_uint8  pre_delay_frame;		//enter preview delay frame num
+	kal_uint8  video_delay_frame;	//enter video delay frame num
+	kal_uint8  hs_video_delay_frame;	//enter high speed video  delay frame num
+	kal_uint8  slim_video_delay_frame;	//enter slim video delay frame num
+  
+	kal_uint8  margin;				//sensor framelength & shutter margin 
+	kal_uint32 min_shutter;			//min shutter
+	kal_uint32 max_frame_length;	//max framelength by sensor register's limitation
+
+	kal_uint8  isp_driving_current;	//mclk driving current
+	kal_uint8  sensor_interface_type;//sensor_interface_type
+	kal_uint8  mipi_sensor_type; //0,MIPI_OPHY_NCSI2; 1,MIPI_OPHY_CSI2, default is NCSI2, don't modify this para
+	kal_uint8  mipi_settle_delay_mode; //0, high speed signal auto detect; 1, use settle delay,unit is ns, default is auto detect, don't modify this para
+	kal_uint8  sensor_output_dataformat;//sensor output first pixel color
+	kal_uint8  mclk;				//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
+	
+	kal_uint8  mipi_lane_num;		//mipi lane num
+	kal_uint8  i2c_addr_table[5];	//record sensor support all write id addr, only supprt 4must end with 0xff
+} imgsensor_info_struct;
+
+/* SENSOR READ/WRITE ID */
+//#define IMGSENSOR_WRITE_ID_1 (0x6c)
+//#define IMGSENSOR_READ_ID_1  (0x6d)
+//#define IMGSENSOR_WRITE_ID_2 (0x20)
+//#define IMGSENSOR_READ_ID_2  (0x21)
+
+extern int iReadRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u8 * a_pRecvData, u16 a_sizeRecvData, u16 i2cId);
+extern int iWriteRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u16 i2cId);
+
+#endif 
+
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/ov8858_mipi_raw/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6735/ov8858_mipi_raw/Makefile
index fd08df8..9a408c2 100755
--- a/drivers/misc/mediatek/imgsensor/src/mt6735/ov8858_mipi_raw/Makefile
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735/ov8858_mipi_raw/Makefile
@@ -1,4 +1,4 @@
 include $(srctree)/drivers/misc/mediatek/Makefile.custom
-
 obj-y += ov8858mipiraw_Sensor.o
 
+
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/ov8858_mipi_raw/ov8858mipiraw_CameraCustomized.h b/drivers/misc/mediatek/imgsensor/src/mt6735/ov8858_mipi_raw/ov8858mipiraw_CameraCustomized.h
new file mode 100644
index 0000000..aee2543
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735/ov8858_mipi_raw/ov8858mipiraw_CameraCustomized.h
@@ -0,0 +1,82 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *   sensor.h
+ *
+ * Project:
+ * --------
+ *   DUMA
+ *
+ * Description:
+ * ------------
+ *   Header file of camera customized parameters.
+ *
+ *
+ * Author:
+ * -------
+ *
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *============================================================================
+ ****************************************************************************/
+
+#ifndef __CAMERA_CUSTOMIZED_H
+#define __CAMERA_CUSTOMIZED_H
+
+// the angle between handset and sensor placement in clockwise, should be one of 0, 90, 270
+#define MAIN_SENSOR_ORIENTATION_ANGLE    90
+#define SUB_SENSOR_ORIENTATION_ANGLE      0                  // do not care if the sub sensor does not exist
+
+
+// First, we think you hold the cell phone vertical.
+// Second, we suppose the direction of upward is 0
+// Third, it is 90, 180, 270 in clockwise
+// here we define the main sensor and sub sensor angles to deal with the jpeg orientation
+#define MAIN_SENSOR_TO_PHONE_ANGLE        90
+#define SUB_SENSOR_TO_PHONE_ANGLE           0
+
+
+#define CAM_SIZE_QVGA_WIDTH         320
+#define CAM_SIZE_QVGA_HEIGHT        240
+#define CAM_SIZE_VGA_WIDTH            640
+#define CAM_SIZE_VGA_HEIGHT           480
+#define CAM_SIZE_05M_WIDTH            800
+#define CAM_SIZE_05M_HEIGHT           600
+#define CAM_SIZE_1M_WIDTH              1280
+#define CAM_SIZE_1M_HEIGHT             960
+#define CAM_SIZE_2M_WIDTH              1600
+#define CAM_SIZE_2M_HEIGHT             1200
+#define CAM_SIZE_3M_WIDTH              2048
+#define CAM_SIZE_3M_HEIGHT             1536
+#define CAM_SIZE_5M_WIDTH              2592
+#define CAM_SIZE_5M_HEIGHT             1944
+
+// for main sensor
+#define MAIN_NUM_OF_PREVIEW_RESOLUTION 3
+#define MAIN_NUM_OF_VIDEO_RESOLUTION 4
+#define MAIN_NUM_OF_STILL_RESOLUTION 7
+#define MAIN_VIDEO_RESOLUTION_PROFILE           {{176,144},{320,240},{640,480},{720,480}}
+#define MAIN_PREVIEW_RESOLUTION_PROFILE      {{232,174},{320,240},{240,320}}
+#define MAIN_STILL_RESOLUTION_PROFILE            {{CAM_SIZE_QVGA_WIDTH,CAM_SIZE_QVGA_HEIGHT}, \
+                                                                         {CAM_SIZE_VGA_WIDTH,CAM_SIZE_VGA_HEIGHT}, \
+                                                                         {CAM_SIZE_05M_WIDTH,CAM_SIZE_05M_HEIGHT}, \
+                                                                         {CAM_SIZE_1M_WIDTH,CAM_SIZE_1M_HEIGHT}, \
+                                                                         {CAM_SIZE_2M_WIDTH,CAM_SIZE_2M_HEIGHT}, \
+                                                                         {CAM_SIZE_3M_WIDTH,CAM_SIZE_3M_HEIGHT}, \
+                                                                         {CAM_SIZE_5M_WIDTH,CAM_SIZE_5M_HEIGHT}}
+
+// if sub sensor does not exist, set all the parameters as 0
+#define SUB_NUM_OF_PREVIEW_RESOLUTION           0
+#define SUB_NUM_OF_VIDEO_RESOLUTION                0
+#define SUB_NUM_OF_STILL_RESOLUTION                 0
+#define SUB_VIDEO_RESOLUTION_PROFILE                {{0,0}}
+#define SUB_PREVIEW_RESOLUTION_PROFILE           {{0,0}}
+#define SUB_STILL_RESOLUTION_PROFILE                 {{0,0}}
+
+//#define NUM_OF_PREVIEW_RESOLUTION 	max(MAIN_NUM_OF_PREVIEW_RESOLUTION,SUB_NUM_OF_PREVIEW_RESOLUTION)
+//#define NUM_OF_VIDEO_RESOLUTION 	max(MAIN_NUM_OF_VIDEO_RESOLUTION,SUB_NUM_OF_VIDEO_RESOLUTION)
+//#define NUM_OF_STILL_RESOLUTION 	max(MAIN_NUM_OF_STILL_RESOLUTION,SUB_NUM_OF_STILL_RESOLUTION)
+
+#define NUM_OF_VIDEO_STREAM_BUFF            8           // Maximun is 8
+#endif
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/ov8858_mipi_raw/ov8858mipiraw_Camera_Sensor_para.h b/drivers/misc/mediatek/imgsensor/src/mt6735/ov8858_mipi_raw/ov8858mipiraw_Camera_Sensor_para.h
new file mode 100644
index 0000000..fd59653
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735/ov8858_mipi_raw/ov8858mipiraw_Camera_Sensor_para.h
@@ -0,0 +1,75 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *   camera_sensor_para.h
+ *
+ * Project:
+ * --------
+ *   DUMA
+ *
+ * Description:
+ * ------------
+ *   Header file of Sensor tuning parameters that should be generated by CCT
+ *
+ *
+ * Author:
+ * -------
+
+ ****************************************************************************/
+/* SENSOR FULL SIZE */
+#ifndef __CAMERA_SENSOR_PARA_H
+#define __CAMERA_SENSOR_PARA_H
+
+#define CAMERA_SENSOR_REG_DEFAULT_VALUE  \
+    /* ARRAY: SENSOR.reg[11] */\
+    {\
+        /* STRUCT: SENSOR.reg[0] */\
+        {\
+            /* SENSOR.reg[0].addr */ 0xFFFFFFFF, /* SENSOR.reg[0].para */ 0x00000000\
+        },\
+        /* STRUCT: SENSOR.reg[1] */\
+        {\
+            /* SENSOR.reg[1].addr */ 0xFFFFFFFF, /* SENSOR.reg[1].para */ 0x0000000D\
+        },\
+        /* STRUCT: SENSOR.reg[2] */\
+        {\
+            /* SENSOR.reg[2].addr */ 0xFFFFFFFF, /* SENSOR.reg[2].para */ 0x00000000\
+        },\
+        /* STRUCT: SENSOR.reg[3] */\
+        {\
+            /* SENSOR.reg[3].addr */ 0xFFFFFFFF, /* SENSOR.reg[3].para */ 0x000000C0\
+        },\
+        /* STRUCT: SENSOR.reg[4] */\
+        {\
+            /* SENSOR.reg[4].addr */ 0xFFFFFFFF, /* SENSOR.reg[4].para */ 0x00000000\
+        },\
+        /* STRUCT: SENSOR.reg[5] */\
+        {\
+            /* SENSOR.reg[5].addr */ 0xFFFFFFFF, /* SENSOR.reg[5].para */ 0x00000004\
+        },\
+        /* STRUCT: SENSOR.reg[6] */\
+        {\
+            /* SENSOR.reg[6].addr */ 0xFFFFFFFF, /* SENSOR.reg[6].para */ 0x00000000\
+        },\
+        /* STRUCT: SENSOR.reg[7] */\
+        {\
+            /* SENSOR.reg[7].addr */ 0xFFFFFFFF, /* SENSOR.reg[7].para */ 0x00000002\
+        },\
+        /* STRUCT: SENSOR.reg[8] */\
+        {\
+            /* SENSOR.reg[8].addr */ 0xFFFFFFFF, /* SENSOR.reg[8].para */ 0x00000000\
+        },\
+        /* STRUCT: SENSOR.reg[9] */\
+        {\
+            /* SENSOR.reg[9].addr */ 0xFFFFFFFF, /* SENSOR.reg[9].para */ 0x00000008\
+        },\
+        /* STRUCT: SENSOR.reg[10] */\
+        {\
+            /* SENSOR.reg[10].addr */ 0xFFFFFFFF, /* SENSOR.reg[10].para */ 0x00000001\
+        }\
+}
+                                         //BASEGAIN,  Digital R gain,  Digital Gr gain,   Digital Gb gain,    Digital B gain
+#define CAMERA_SENSOR_CCT_DEFAULT_VALUE {{ 0x0205, 0x00 } ,{ 0x0211, 0x00 } ,{ 0x020F, 0x00 } ,{ 0x0215, 0x00 } ,{ 0x0213, 0x00 }}
+#endif /* __CAMERA_SENSOR_PARA_H */
+
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/ov8858_mipi_raw/ov8858mipiraw_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735/ov8858_mipi_raw/ov8858mipiraw_Sensor.c
index 729b6cb..55bc183 100755
--- a/drivers/misc/mediatek/imgsensor/src/mt6735/ov8858_mipi_raw/ov8858mipiraw_Sensor.c
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735/ov8858_mipi_raw/ov8858mipiraw_Sensor.c
@@ -152,7 +152,7 @@ static imgsensor_info_struct imgsensor_info = {
 	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_B,//sensor output first pixel color
 	.mclk = 24,//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
 	.mipi_lane_num = SENSOR_MIPI_4_LANE,//mipi lane num
-	.i2c_addr_table = {0x42, 0x20,0x6C,0xff},//record sensor support all write id addr, only supprt 4must end with 0xff
+	.i2c_addr_table = {0x42, 0xff},//record sensor support all write id addr, only supprt 4must end with 0xff
 };
 
 
@@ -1522,7 +1522,7 @@ otp_ptr = &otp_struct_obj;
 int read_otp(struct otp_struct *otp_ptr)
 {
 	int otp_flag, addr, temp, i;
-	//set 0x5002[3] to \A1\B00\A1\B1
+	//set 0x5002[3] to 0
 	int temp1;
 	temp1 = read_cmos_sensor(0x5002);
 	write_cmos_sensor(0x5002, (0x00 & 0x08) | (temp1 & (~0x08)));
@@ -1614,7 +1614,7 @@ int read_otp(struct otp_struct *otp_ptr)
 	for(i=0x7010;i<=0x720a;i++) {
 		write_cmos_sensor(i,0); // clear OTP buffer, recommended use continuous write to accelarate
 	}
-	//set 0x5002[3] to \A1\B01\A1\B1
+	//set 0x5002[3] to 1
 	temp1 = read_cmos_sensor(0x5002);
 	write_cmos_sensor(0x5002, (0x08 & 0x08) | (temp1 & (~0x08)));
 	return (*otp_ptr).flag;
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/ov8858_mipi_raw/ov8858mipiraw_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735/ov8858_mipi_raw/ov8858mipiraw_Sensor.h
old mode 100755
new mode 100644
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/ov8865_mipi_raw/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6735/ov8865_mipi_raw/Makefile
new file mode 100755
index 0000000..a3e08ee
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735/ov8865_mipi_raw/Makefile
@@ -0,0 +1,4 @@
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+obj-y += ov8865mipiraw_Sensor.o
+
+
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/ov8865_mipi_raw/ov8865mipiraw_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735/ov8865_mipi_raw/ov8865mipiraw_Sensor.c
new file mode 100755
index 0000000..1c5b1c1
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735/ov8865_mipi_raw/ov8865mipiraw_Sensor.c
@@ -0,0 +1,2327 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *	 OV8865mipi_Sensor.c
+ *
+ * Project:
+ * --------
+ *	 ALPS
+ *
+ * Description:
+ * ------------
+ *	 Source code of Sensor driver
+ 
+ *nick <<PengtaoFan>>.modify at: 2015-02-02   19:12:15
+ *    nick :R8865 driver full size  R3767 need modifyto R3767=0x1e 
+ *
+ *	PengtaoFan
+ * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *============================================================================
+ ****************************************************************************/
+
+#include <linux/videodev2.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <asm/atomic.h>
+//#include <asm/system.h>
+#include <linux/xlog.h>
+
+#include "kd_camera_hw.h"
+#include "kd_imgsensor.h"
+#include "kd_imgsensor_define.h" 
+#include "kd_imgsensor_errcode.h"
+
+#include "ov8865mipiraw_Sensor.h"
+
+#define PFX "OV8865"
+//#define LOG_WRN(format, args...) xlog_printk(ANDROID_LOG_WARN ,PFX, "[%S] " format, __FUNCTION__, ##args)
+//#defineLOG_INF(format, args...) xlog_printk(ANDROID_LOG_INFO ,PFX, "[%s] " format, __FUNCTION__, ##args)
+//#define LOG_DBG(format, args...) xlog_printk(ANDROID_LOG_DEBUG ,PFX, "[%S] " format, __FUNCTION__, ##args)
+#define LOG_INF(format, args...)	xlog_printk(ANDROID_LOG_INFO   , PFX, "[%s] " format, __FUNCTION__, ##args)
+
+static DEFINE_SPINLOCK(imgsensor_drv_lock);
+
+static imgsensor_info_struct imgsensor_info = { 
+	.sensor_id = OV8865_SENSOR_ID,
+	
+	.checksum_value = 0xfdd9c02a,
+	
+	.pre = {
+		.pclk = 74400000,									//record different mode's pclk
+		.linelength = 1923,  /*[actually 1923*2]	*/			//record different mode's linelength
+		.framelength = 1280, //1248 =>1280 ,increase vblank time	//record different mode's framelength
+		.startx = 0,										//record different mode's startx of grabwindow
+		.starty = 0,										//record different mode's starty of grabwindow
+		.grabwindow_width = 1632,							//record different mode's width of grabwindow
+		.grabwindow_height = 1224,							//record different mode's height of grabwindow
+		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
+		.mipi_data_lp2hs_settle_dc = 23,
+		/*	 following for GetDefaultFramerateByScenario()	*/
+		.max_framerate = 300,	
+	},
+	.cap = {//30fps 74.4M bps/lane
+		.pclk = 148800000,//this value just for calculate shutter
+		.linelength = 1944,  /*[actually 2008*2]	*/	
+	    .framelength = 2550,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 3264,
+		.grabwindow_height = 2448,
+		.mipi_data_lp2hs_settle_dc = 23,
+		.max_framerate = 300,
+	},
+	.cap1 = {//24fps 600M bps/lane
+		.pclk = 120000000,//this value just for calculate shutter
+		.linelength = 1944,  /*[actually 2008*2]	*/	
+		.framelength = 4080,//modify for 15fps at mt6735 //2550,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 3264,
+		.grabwindow_height = 2448,
+		.mipi_data_lp2hs_settle_dc = 23,
+		.max_framerate = 150,	//less than 13M(include 13M),cap1 max framerate is 24fps,16M max framerate is 20fps, 20M max framerate is 15fps  
+	},
+	.normal_video = {
+		.pclk = 148800000,
+		.linelength = 2582,       /*[actually 2582*2]	*/	
+		.framelength = 1908,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 3264,
+		.grabwindow_height = 1836,
+		.mipi_data_lp2hs_settle_dc = 23,
+		.max_framerate = 300,
+	},
+	.hs_video = {
+		.pclk = 74400000,
+		.linelength = 1153, /*[actually 1153*2]	*/	
+		.framelength = 537,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 640,
+		.grabwindow_height = 480,
+		.mipi_data_lp2hs_settle_dc = 23,
+		.max_framerate = 1200,
+	},
+	.slim_video = { //equal preview setting
+		.pclk = 74400000,
+		.linelength = 1923,  /*[actually 1923*2]	*/			//record different mode's linelength
+		.framelength = 1280,								//record different mode's framelength
+		.startx = 0,										//record different mode's startx of grabwindow
+		.starty = 0,										//record different mode's starty of grabwindow
+		.grabwindow_width = 1632,							//record different mode's width of grabwindow
+		.grabwindow_height = 1224,							//record different mode's height of grabwindow
+		.mipi_data_lp2hs_settle_dc = 23,
+		.max_framerate = 300,
+	},
+	
+	.margin = 6,
+	.min_shutter = 1,
+	.max_frame_length = 0xffff,
+	.ae_shut_delay_frame = 0,
+	.ae_sensor_gain_delay_frame = 0,
+	.ae_ispGain_delay_frame = 2,
+	.ihdr_support = 0,	  //1, support; 0,not support
+	.ihdr_le_firstline = 0,  //1,le first ; 0, se first
+	.sensor_mode_num = 5,	  
+	
+	.cap_delay_frame = 2, 
+	.pre_delay_frame = 2, 
+	.video_delay_frame = 2,
+	.hs_video_delay_frame = 2,
+	.slim_video_delay_frame = 2,
+	
+	.isp_driving_current = ISP_DRIVING_6MA,
+	.sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,
+	.mipi_sensor_type = MIPI_OPHY_NCSI2,//0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2
+	.mipi_settle_delay_mode = MIPI_SETTLEDELAY_AUTO,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
+	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_B,
+	.mclk = 24,
+	.mipi_lane_num = SENSOR_MIPI_4_LANE,
+	.i2c_addr_table = {0x20,0x6c,0xff},
+};
+
+
+
+
+static imgsensor_struct imgsensor = {
+	.mirror = IMAGE_NORMAL,//IMAGE_HV_MIRROR,				//mirrorflip information
+	.sensor_mode = IMGSENSOR_MODE_INIT, //IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
+	.shutter = 0x3D0,					//current shutter
+	.gain = 0x100,						//current gain
+	.dummy_pixel = 0,					//current dummypixel
+	.dummy_line = 0,					//current dummyline
+	.current_fps = 0,  //full size current fps : 24fps for PIP, 30fps for Normal or ZSD
+	.autoflicker_en = KAL_FALSE,  //auto flicker enable: KAL_FALSE for disable auto flicker, KAL_TRUE for enable auto flicker
+	.test_pattern = KAL_FALSE,		//test pattern mode or not. 
+	.current_scenario_id = MSDK_SCENARIO_ID_CAMERA_PREVIEW,//current scenario id
+	.ihdr_en = 0, //sensor need support LE, SE with HDR feature
+	.i2c_write_id = 0x20,
+};
+
+
+/* Sensor output window information */
+static SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[5] =	 
+{{ 3264, 2448, 0, 0, 3264, 2448,    1632,1224,0,0,  1632,1224,	  0,0,1632,1224}, // Preview 
+ { 3264, 2448, 0, 0, 3264, 2448, 	3264,2448,0,0,  3264,2448,	  0,0,3264,2448}, // capture
+ { 3264, 2448, 0, 0, 3264, 2448, 	3264,2448,0,306,3264,1836,	  0,0,3264,1836},// video 
+ { 3264, 2448, 0, 0, 3264, 2448, 	3264,2448,0,0,  640, 480,	  0,0,640 ,480},//hight speed video  
+ { 3264, 2448, 0, 0, 3264, 2448, 	1632,1224,0,0,  1632,1224,	  0,0,1632,1224}};// slim video 
+
+
+static kal_uint16 read_cmos_sensor(kal_uint32 addr)
+{
+	kal_uint16 get_byte=0;
+
+	char pu_send_cmd[2] = {(char)(addr >> 8), (char)(addr & 0xFF) };
+	iReadRegI2C(pu_send_cmd, 2, (u8*)&get_byte, 1, imgsensor.i2c_write_id);
+
+	return get_byte;
+}
+
+static void write_cmos_sensor(kal_uint32 addr, kal_uint32 para)
+{
+	char pu_send_cmd[3] = {(char)(addr >> 8), (char)(addr & 0xFF), (char)(para & 0xFF)};
+	iWriteRegI2C(pu_send_cmd, 3, imgsensor.i2c_write_id);
+}
+
+static void set_dummy()
+{
+	LOG_INF("dummyline = %d, dummypixels = %d \n", imgsensor.dummy_line, imgsensor.dummy_pixel);
+
+	write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
+	write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);	  
+	write_cmos_sensor(0x380c, imgsensor.line_length >> 8);
+	write_cmos_sensor(0x380d, imgsensor.line_length & 0xFF);
+	
+}	/*	set_dummy  */
+
+
+static void set_max_framerate(UINT16 framerate,kal_bool min_framelength_en)
+{
+	kal_int16 dummy_line;
+	kal_uint32 frame_length = imgsensor.frame_length;
+
+	LOG_INF("framerate = %d, min framelength should enable? \n", framerate,min_framelength_en);
+   
+   frame_length = imgsensor.pclk / framerate * 10 / imgsensor.line_length;
+   
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.frame_length = (frame_length > imgsensor.min_frame_length) ? frame_length : imgsensor.min_frame_length; 
+	imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
+	//dummy_line = frame_length - imgsensor.min_frame_length;
+	//if (dummy_line < 0)
+		//imgsensor.dummy_line = 0;
+	//else
+		//imgsensor.dummy_line = dummy_line;
+	//imgsensor.frame_length = frame_length + imgsensor.dummy_line;
+	
+	if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+	{
+		imgsensor.frame_length = imgsensor_info.max_frame_length;
+		imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
+	}
+	if (min_framelength_en)
+		imgsensor.min_frame_length = imgsensor.frame_length;
+	spin_unlock(&imgsensor_drv_lock);
+	set_dummy();
+}	/*	set_max_framerate  */
+
+
+static void set_shutter(kal_uint16 shutter)
+{
+    unsigned long flags;
+    kal_uint16 realtime_fps = 0;
+    kal_uint32 frame_length = 0;
+    spin_lock_irqsave(&imgsensor_drv_lock, flags);
+    imgsensor.shutter = shutter;
+    spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
+
+
+    spin_lock(&imgsensor_drv_lock);
+    if (shutter > imgsensor.min_frame_length - imgsensor_info.margin)
+        imgsensor.frame_length = shutter + imgsensor_info.margin;
+    else
+        imgsensor.frame_length = imgsensor.min_frame_length;
+    if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+		imgsensor.frame_length = imgsensor_info.max_frame_length;
+	spin_unlock(&imgsensor_drv_lock);
+
+	
+	shutter = (shutter < imgsensor_info.min_shutter) ? imgsensor_info.min_shutter : shutter;
+	shutter = (shutter > (imgsensor_info.max_frame_length - imgsensor_info.margin)) ? (imgsensor_info.max_frame_length - imgsensor_info.margin) : shutter;
+	
+	if (imgsensor.autoflicker_en){ 
+		realtime_fps = imgsensor.pclk / imgsensor.line_length * 10 / imgsensor.frame_length;
+		if(realtime_fps >= 297 && realtime_fps <= 305)
+			set_max_framerate(296,0);
+		else if(realtime_fps >= 147 && realtime_fps <= 150)
+            set_max_framerate(146,0);
+        else {
+        // Extend frame length
+        write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
+        write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
+        }
+    } else {
+        // Extend frame length
+        write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
+        write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
+    }
+
+    // Update Shutter
+    write_cmos_sensor(0x3502, (shutter << 4) & 0xFF);
+    write_cmos_sensor(0x3501, (shutter >> 4) & 0xFF);
+    write_cmos_sensor(0x3500, (shutter >> 12) & 0x0F);
+    LOG_INF("Exit! shutter =%d, framelength =%d\n", shutter,imgsensor.frame_length);
+
+}
+
+
+static kal_uint16 gain2reg(const kal_uint16 gain)
+{
+
+	kal_uint16 reg_gain = 0x0000;
+	kal_uint16 OV8865_GAIN_BASE = 128;
+
+
+	reg_gain = gain*OV8865_GAIN_BASE/BASEGAIN;
+	return (kal_uint16)reg_gain;
+
+	
+}
+
+
+
+/*************************************************************************
+* FUNCTION
+*	set_gain
+*
+* DESCRIPTION
+*	This function is to set global gain to sensor.
+*
+* PARAMETERS
+*	iGain : sensor global gain(base: 0x40)
+*
+* RETURNS
+*	the actually gain set to sensor.
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint16 set_gain(kal_uint16 gain)
+{
+	kal_uint16 reg_gain;
+
+
+	if (gain < BASEGAIN || gain > 32 * BASEGAIN) {
+		LOG_INF("Error gain setting");
+
+		if (gain < BASEGAIN)
+			gain = BASEGAIN;
+		else if (gain > 32 * BASEGAIN)
+			gain = 32 * BASEGAIN;		 
+	}
+ 
+	reg_gain = gain2reg(gain);
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.gain = reg_gain; 
+	spin_unlock(&imgsensor_drv_lock);
+	LOG_INF("gain = %d , reg_gain = 0x%x\n ", gain, reg_gain);
+
+	write_cmos_sensor(0x3508,(reg_gain>>8));
+	write_cmos_sensor(0x3509,(reg_gain&0xff));
+	
+	return gain;
+}	/*	set_gain  */
+
+
+static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gain)
+{
+  //ov8865  Don't support
+
+#if 0 //control demo
+  LOG_INF("le:0x%x, se:0x%x, gain:0x%x\n",le,se,gain);
+  if (imgsensor.ihdr_en) {
+	  
+	  spin_lock(&imgsensor_drv_lock);
+	  if (le > imgsensor.min_frame_length - imgsensor_info.margin)		  
+		  imgsensor.frame_length = le + imgsensor_info.margin;
+	  else
+		  imgsensor.frame_length = imgsensor.min_frame_length;
+	  
+	  if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+		  imgsensor.frame_length = imgsensor_info.max_frame_length;
+	  spin_unlock(&imgsensor_drv_lock);
+	  
+	  if (le < imgsensor_info.min_shutter) le = imgsensor_info.min_shutter;
+	  if (se < imgsensor_info.min_shutter) se = imgsensor_info.min_shutter;
+	  
+	  // Extend frame length first
+	  write_cmos_sensor(xxxx, imgsensor.frame_length >> 8);
+	  write_cmos_sensor(xxxx, imgsensor.frame_length & 0xFF);
+  
+	//write le & se
+	  write_cmos_sensor(xxxx, (le >> 8); 
+	  write_cmos_sensor(xxxx, (le & 0xFF);
+  
+	  write_cmos_sensor(xxxx, (se >> 8); 
+	  write_cmos_sensor(xxxx, (se & 0xFF);
+  
+	  set_gain(gain);
+#endif
+}
+
+
+#if 1
+static void set_mirror_flip(kal_uint8 image_mirror)
+{
+
+	kal_int16 mirror=0,flip=0;
+
+	LOG_INF("image_mirror = %d\n", image_mirror);
+	
+	mirror= OV8865_read_cmos_sensor(0x3820);
+	flip  = OV8865_read_cmos_sensor(0x3821);
+
+    switch (image_mirror)
+    {
+        case IMAGE_H_MIRROR://IMAGE_NORMAL:
+            write_cmos_sensor(0x3820, (mirror & (0xF9)));//Set normal
+            write_cmos_sensor(0x3821, (flip & (0xF9)));	//Set normal
+            break;
+        case IMAGE_NORMAL://IMAGE_V_MIRROR:
+            write_cmos_sensor(0x3820, (mirror & (0xF9)));//Set flip
+            write_cmos_sensor(0x3821, (flip | (0x06)));	//Set flip
+            break;
+        case IMAGE_HV_MIRROR://IMAGE_H_MIRROR:
+            write_cmos_sensor(0x3820, (mirror |(0x06)));	//Set mirror
+            write_cmos_sensor(0x3821, (flip & (0xF9)));	//Set mirror
+            break;
+        case IMAGE_V_MIRROR://IMAGE_HV_MIRROR:
+            write_cmos_sensor(0x3820, (mirror |(0x06)));	//Set mirror & flip
+            write_cmos_sensor(0x3821, (flip |(0x06)));	//Set mirror & flip
+            break;
+    }
+
+}
+#endif
+
+/*************************************************************************
+* FUNCTION
+*	night_mode
+*
+* DESCRIPTION
+*	This function night mode of sensor.
+*
+* PARAMETERS
+*	bEnable: KAL_TRUE -> enable night mode, otherwise, disable night mode
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static void night_mode(kal_bool enable)
+{
+/*No Need to implement this function*/ 
+}	/*	night_mode	*/
+
+
+static void sensor_init(void)
+{
+	LOG_INF("E\n");
+
+	write_cmos_sensor(0x0103,0x01);// ; software reset
+	mdelay(10);
+	write_cmos_sensor(0x0100,0x00);// ; software standby
+	write_cmos_sensor(0x0100,0x00);//
+	write_cmos_sensor(0x0100,0x00);//
+	write_cmos_sensor(0x0100,0x00);//
+	write_cmos_sensor(0x3638,0xff);// ; analog control
+
+	write_cmos_sensor(0x0302,0x1f);// ; PLL
+
+	write_cmos_sensor(0x0303,0x00);// ; PLL
+	write_cmos_sensor(0x0304,0x03);// ; PLL
+	write_cmos_sensor(0x030d,0x1f);// ; PLL	  ;1e
+	write_cmos_sensor(0x030e,0x00);// ; PLL
+	write_cmos_sensor(0x030f,0x09);// ; PLL
+	write_cmos_sensor(0x0312,0x01);// ; PLL
+	write_cmos_sensor(0x031e,0x0c);// ; PLL
+	write_cmos_sensor(0x3015,0x01);// ; clock Div
+	write_cmos_sensor(0x3018,0x72);// ; MIPI 4 lane
+	write_cmos_sensor(0x3020,0x93);// ; clock normal, pclk/1
+	write_cmos_sensor(0x3022,0x01);// ; pd_mini enable when rst_sync
+	write_cmos_sensor(0x3031,0x0a);// ; 10-bit
+	write_cmos_sensor(0x3106,0x01);// ; PLL
+	write_cmos_sensor(0x3305,0xf1);//
+	write_cmos_sensor(0x3308,0x00);//
+	write_cmos_sensor(0x3309,0x28);//
+	write_cmos_sensor(0x330a,0x00);//
+	write_cmos_sensor(0x330b,0x20);//
+	write_cmos_sensor(0x330c,0x00);//
+	write_cmos_sensor(0x330d,0x00);//
+	write_cmos_sensor(0x330e,0x00);//
+	write_cmos_sensor(0x330f,0x40);//
+	write_cmos_sensor(0x3307,0x04);//
+	write_cmos_sensor(0x3604,0x04);// ; analog control
+	write_cmos_sensor(0x3602,0x30);//
+	write_cmos_sensor(0x3605,0x00);//
+	write_cmos_sensor(0x3607,0x20);//
+	write_cmos_sensor(0x3608,0x11);//
+	write_cmos_sensor(0x3609,0x68);//
+	write_cmos_sensor(0x360a,0x40);//
+	write_cmos_sensor(0x360c,0xdd);//
+	write_cmos_sensor(0x360e,0x0c);//
+	write_cmos_sensor(0x3610,0x07);//
+
+	write_cmos_sensor(0x3612,0x86);//AM24  power save ov_Revise
+	write_cmos_sensor(0x3613,0x58);//AM24
+	write_cmos_sensor(0x3614,0x28);//
+	write_cmos_sensor(0x3617,0x40);//
+	write_cmos_sensor(0x3618,0x5a);//
+	write_cmos_sensor(0x3619,0x9b);//
+	write_cmos_sensor(0x361c,0x00);//
+	write_cmos_sensor(0x361d,0x60);//
+	write_cmos_sensor(0x3631,0x60);//
+	write_cmos_sensor(0x3633,0x10);//
+	write_cmos_sensor(0x3634,0x10);//
+	write_cmos_sensor(0x3635,0x10);//
+	write_cmos_sensor(0x3636,0x10);//AM24
+	write_cmos_sensor(0x3641,0x55);// ; MIPI settings
+	write_cmos_sensor(0x3646,0x86);// ; MIPI settings
+	write_cmos_sensor(0x3647,0x27);// ; MIPI settings
+	write_cmos_sensor(0x364a,0x1b);// ; MIPI settings
+
+
+	//write_cmos_sensor(0x3500,0x00);// ; exposurre HH
+	//write_cmos_sensor(0x3501,0x4c);// ; expouere H
+	//write_cmos_sensor(0x3502,0x00);// ; exposure L
+
+
+	write_cmos_sensor(0x3503,0x00);// ; gain no delay, exposure no delay
+
+	write_cmos_sensor(0x3508,0x02);// ; gain H
+	write_cmos_sensor(0x3509,0x00);// ; gain L
+
+	write_cmos_sensor(0x3700,0x24);// ; sensor control AM24
+	write_cmos_sensor(0x3701,0x0c);//
+	write_cmos_sensor(0x3702,0x28);//
+	write_cmos_sensor(0x3703,0x19);//
+	write_cmos_sensor(0x3704,0x14);//
+	write_cmos_sensor(0x3705,0x00);//
+	write_cmos_sensor(0x3706,0x38);//AM24
+	write_cmos_sensor(0x3707,0x04);//
+	write_cmos_sensor(0x3708,0x24);//
+	write_cmos_sensor(0x3709,0x40);//
+	write_cmos_sensor(0x370a,0x00);//
+	write_cmos_sensor(0x370b,0xb8);//AM24
+	write_cmos_sensor(0x370c,0x04);//
+	write_cmos_sensor(0x3718,0x12);//
+	write_cmos_sensor(0x3719,0x31);//
+	write_cmos_sensor(0x3712,0x42);//
+	write_cmos_sensor(0x3714,0x12);//
+	write_cmos_sensor(0x371e,0x19);//
+	write_cmos_sensor(0x371f,0x40);//
+	write_cmos_sensor(0x3720,0x05);//
+	write_cmos_sensor(0x3721,0x05);//
+	write_cmos_sensor(0x3724,0x02);//
+	write_cmos_sensor(0x3725,0x02);//
+	write_cmos_sensor(0x3726,0x06);//
+	write_cmos_sensor(0x3728,0x05);//
+	write_cmos_sensor(0x3729,0x02);//
+	write_cmos_sensor(0x372a,0x03);//
+	write_cmos_sensor(0x372b,0x53);//
+	write_cmos_sensor(0x372c,0xa3);//
+	write_cmos_sensor(0x372d,0x53);//
+	write_cmos_sensor(0x372e,0x06);//
+	write_cmos_sensor(0x372f,0x10);//
+	write_cmos_sensor(0x3730,0x01);//
+	write_cmos_sensor(0x3731,0x06);//
+	write_cmos_sensor(0x3732,0x14);//
+	write_cmos_sensor(0x3733,0x10);//
+	write_cmos_sensor(0x3734,0x40);//
+	write_cmos_sensor(0x3736,0x20);//
+	write_cmos_sensor(0x373a,0x02);//
+	write_cmos_sensor(0x373b,0x0c);//
+	write_cmos_sensor(0x373c,0x0a);//
+	write_cmos_sensor(0x373e,0x03);//
+	write_cmos_sensor(0x3755,0x40);//
+	write_cmos_sensor(0x3758,0x00);//
+	write_cmos_sensor(0x3759,0x4c);//
+	write_cmos_sensor(0x375a,0x06);//
+	write_cmos_sensor(0x375b,0x13);//
+	write_cmos_sensor(0x375c,0x40);//am26
+	write_cmos_sensor(0x375d,0x02);//
+	write_cmos_sensor(0x375e,0x00);//
+	write_cmos_sensor(0x375f,0x14);//
+	write_cmos_sensor(0x3767,0x1c);//am26
+	write_cmos_sensor(0x3768,0x04);//
+	write_cmos_sensor(0x3769,0x20);//
+	write_cmos_sensor(0x376c,0xc0);//am26
+	write_cmos_sensor(0x376d,0xc0);//am26
+	write_cmos_sensor(0x376a,0x08);//
+	write_cmos_sensor(0x3761,0x00);//
+	write_cmos_sensor(0x3762,0x00);//
+	write_cmos_sensor(0x3763,0x00);//
+	write_cmos_sensor(0x3766,0xff);//
+	write_cmos_sensor(0x376b,0x42);//
+	write_cmos_sensor(0x3772,0x23);//
+	write_cmos_sensor(0x3773,0x02);//
+	write_cmos_sensor(0x3774,0x16);//
+	write_cmos_sensor(0x3775,0x12);//
+	write_cmos_sensor(0x3776,0x08);//
+	write_cmos_sensor(0x37a0,0x44);//
+	write_cmos_sensor(0x37a1,0x3d);//
+	write_cmos_sensor(0x37a2,0x3d);//
+	write_cmos_sensor(0x37a3,0x01);//
+	write_cmos_sensor(0x37a4,0x00);//
+	write_cmos_sensor(0x37a5,0x08);//
+	write_cmos_sensor(0x37a6,0x00);//
+	write_cmos_sensor(0x37a7,0x44);//
+	write_cmos_sensor(0x37a8,0x58);//AM24
+	write_cmos_sensor(0x37a9,0x58);//AM24
+	write_cmos_sensor(0x3760,0x00);//
+	write_cmos_sensor(0x376f,0x01);//
+	write_cmos_sensor(0x37aa,0x44);//
+	write_cmos_sensor(0x37ab,0x2e);//
+	write_cmos_sensor(0x37ac,0x2e);//
+	write_cmos_sensor(0x37ad,0x33);//
+	write_cmos_sensor(0x37ae,0x0d);//
+	write_cmos_sensor(0x37af,0x0d);//
+	write_cmos_sensor(0x37b0,0x00);//
+	write_cmos_sensor(0x37b1,0x00);//
+	write_cmos_sensor(0x37b2,0x00);//
+	write_cmos_sensor(0x37b3,0x42);//
+	write_cmos_sensor(0x37b4,0x42);//
+	write_cmos_sensor(0x37b5,0x33);//
+	write_cmos_sensor(0x37b6,0x00);//
+	write_cmos_sensor(0x37b7,0x00);//
+	write_cmos_sensor(0x37b8,0x00);//
+	write_cmos_sensor(0x37b9,0xff);// ; sensor control
+
+	write_cmos_sensor(0x3800,0x00);// ; X start H
+	write_cmos_sensor(0x3801,0x0c);// ; X start L
+
+	write_cmos_sensor(0x3802,0x00);// ; Y start H
+	write_cmos_sensor(0x3803,0x0c);// ; Y start L
+
+	write_cmos_sensor(0x3804,0x0c);// ; X end H
+	write_cmos_sensor(0x3805,0xd3);// ; X end L
+	write_cmos_sensor(0x3806,0x09);// ; Y end H
+	write_cmos_sensor(0x3807,0xa3);// ; Y end L
+
+	write_cmos_sensor(0x3808,0x06);// ; X output size H
+	write_cmos_sensor(0x3809,0x60);// ; X output size L
+	write_cmos_sensor(0x380a,0x04);// ; Y output size H
+	write_cmos_sensor(0x380b,0xc8);// ; Y output size L
+
+	write_cmos_sensor(0x380c,0x07);// ; HTS H
+	write_cmos_sensor(0x380d,0x83);// ; HTS L
+	write_cmos_sensor(0x380e,0x04);// ; VTS H
+	write_cmos_sensor(0x380f,0xe0);// ; VTS L
+
+	write_cmos_sensor(0x3810,0x00);// ; ISP X win H
+	write_cmos_sensor(0x3811,0x04);// ; ISP X win L
+	write_cmos_sensor(0x3813,0x04);// ; ISP Y win L
+	write_cmos_sensor(0x3814,0x03);// ; X inc odd
+	write_cmos_sensor(0x3815,0x01);// ; X inc even
+	write_cmos_sensor(0x3820,0x00);// ; flip off
+	write_cmos_sensor(0x3821,0x67);// ; hsync_en_o, fst_vbin, mirror on
+	write_cmos_sensor(0x382a,0x03);// ; Y inc odd
+	write_cmos_sensor(0x382b,0x01);// ; Y inc even
+	write_cmos_sensor(0x3830,0x08);// ; ablc_use_num[5:1]
+	write_cmos_sensor(0x3836,0x02);// ; zline_use_num[5:1]
+	write_cmos_sensor(0x3837,0x18);// ; vts_add_dis, cexp_gt_vts_offs=8
+	write_cmos_sensor(0x3841,0xff);// ; auto size
+	write_cmos_sensor(0x3846,0x88);// ; Y/X boundary pixel numbber for auto size mode
+
+
+	//3d85/3d8c/3d8d  for otp auto load at power on
+	write_cmos_sensor(0x3d85,0x06);//AM24a
+	write_cmos_sensor(0x3d8c,0x75);//AM24a
+	write_cmos_sensor(0x3d8d,0xef);//AM24a
+
+
+	write_cmos_sensor(0x3f08,0x0b);//
+
+	write_cmos_sensor(0x4000,0xf1);// ; our range trig en, format chg en, gan chg en, exp chg en, median en
+	write_cmos_sensor(0x4001,0x14);// ; left 32 column, final BLC offset limitation enable
+	write_cmos_sensor(0x4005,0x10);// ; BLC target
+
+	write_cmos_sensor(0x4006,0x04);// ;revise for ZSD ON/OFF unstable,MTK
+	write_cmos_sensor(0x4007,0x04);// ; 
+
+	write_cmos_sensor(0x400b,0x0c);// ; start line =0, offset limitation en, cut range function en
+	write_cmos_sensor(0x400d,0x10);// ; offset trigger threshold
+	write_cmos_sensor(0x401b,0x00);//
+	write_cmos_sensor(0x401d,0x00);//
+	write_cmos_sensor(0x4020,0x01);// ; anchor left start H
+	write_cmos_sensor(0x4021,0x20);// ; anchor left start L
+	write_cmos_sensor(0x4022,0x01);// ; anchor left end H
+	write_cmos_sensor(0x4023,0x9f);// ; anchor left end L
+	write_cmos_sensor(0x4024,0x03);// ; anchor right start H
+	write_cmos_sensor(0x4025,0xe0);// ; anchor right start L
+	write_cmos_sensor(0x4026,0x04);// ; anchor right end H
+	write_cmos_sensor(0x4027,0x5f);// ; anchor right end L
+	write_cmos_sensor(0x4028,0x00);// ; top zero line start
+	write_cmos_sensor(0x4029,0x02);// ; top zero line number
+	write_cmos_sensor(0x402a,0x04);// ; top black line start
+	write_cmos_sensor(0x402b,0x04);// ; top black line number
+	write_cmos_sensor(0x402c,0x02);// ; bottom zero line start
+	write_cmos_sensor(0x402d,0x02);// ; bottom zero line number
+	write_cmos_sensor(0x402e,0x08);// ; bottom black line start
+	write_cmos_sensor(0x402f,0x02);// ; bottom black line number
+	write_cmos_sensor(0x401f,0x00);// ; anchor one disable
+	write_cmos_sensor(0x4034,0x3f);// ; limitation BLC offset
+	write_cmos_sensor(0x4300,0xff);// ; clip max H
+	write_cmos_sensor(0x4301,0x00);// ; clip min H
+	write_cmos_sensor(0x4302,0x0f);// ; clip min L/clip max L
+	write_cmos_sensor(0x4500,0x40);// ; ADC sync control
+	write_cmos_sensor(0x4503,0x10);//
+	write_cmos_sensor(0x4601,0x74);// ; V FIFO control
+	write_cmos_sensor(0x481f,0x32);// ; clk_prepare_min
+
+	write_cmos_sensor(0x4837,0x16);// ; clock period
+
+
+	write_cmos_sensor(0x4850,0x10);// ; lane select
+	write_cmos_sensor(0x4851,0x32);// ; lane select
+	write_cmos_sensor(0x4b00,0x2a);// ; LVDS settings
+	write_cmos_sensor(0x4b0d,0x00);// ; LVDS settings
+	write_cmos_sensor(0x4d00,0x04);// ; temperature sensor
+	write_cmos_sensor(0x4d01,0x18);// ; temperature sensor
+	write_cmos_sensor(0x4d02,0xc3);// ; temperature sensor
+	write_cmos_sensor(0x4d03,0xff);// ; temperature sensor
+	write_cmos_sensor(0x4d04,0xff);// ; temperature sensor
+	write_cmos_sensor(0x4d05,0xff);// ; temperature sensor
+
+	write_cmos_sensor(0x5000,0x96);// ; LENC on, MWB on, BPC on, WPC on
+	write_cmos_sensor(0x5001,0x01);// ; BLC on
+
+	write_cmos_sensor(0x5002,0x08);// ; vario pixel off
+	write_cmos_sensor(0x5901,0x00);//
+	write_cmos_sensor(0x5e00,0x00);// ; test pattern off
+	write_cmos_sensor(0x5e01,0x41);// ; window cut enable
+	write_cmos_sensor(0x0100,0x01);// ; wake up, streaming
+	write_cmos_sensor(0x5800,0x1d);// ; lens correction
+	write_cmos_sensor(0x5801,0x0e);//
+	write_cmos_sensor(0x5802,0x0c);//
+	write_cmos_sensor(0x5803,0x0c);//
+	write_cmos_sensor(0x5804,0x0f);//
+	write_cmos_sensor(0x5805,0x22);//
+	write_cmos_sensor(0x5806,0x0a);//
+	write_cmos_sensor(0x5807,0x06);//
+	write_cmos_sensor(0x5808,0x05);//
+	write_cmos_sensor(0x5809,0x05);//
+	write_cmos_sensor(0x580a,0x07);//
+	write_cmos_sensor(0x580b,0x0a);//
+	write_cmos_sensor(0x580c,0x06);//
+	write_cmos_sensor(0x580d,0x02);//
+	write_cmos_sensor(0x580e,0x00);//
+	write_cmos_sensor(0x580f,0x00);//
+	write_cmos_sensor(0x5810,0x03);//
+	write_cmos_sensor(0x5811,0x07);//
+	write_cmos_sensor(0x5812,0x06);//
+	write_cmos_sensor(0x5813,0x02);//
+	write_cmos_sensor(0x5814,0x00);//
+	write_cmos_sensor(0x5815,0x00);//
+	write_cmos_sensor(0x5816,0x03);//
+	write_cmos_sensor(0x5817,0x07);//
+	write_cmos_sensor(0x5818,0x09);//
+	write_cmos_sensor(0x5819,0x06);//
+	write_cmos_sensor(0x581a,0x04);//
+	write_cmos_sensor(0x581b,0x04);//
+	write_cmos_sensor(0x581c,0x06);//
+	write_cmos_sensor(0x581d,0x0a);//
+	write_cmos_sensor(0x581e,0x19);//
+	write_cmos_sensor(0x581f,0x0d);//
+	write_cmos_sensor(0x5820,0x0b);//
+	write_cmos_sensor(0x5821,0x0b);//
+	write_cmos_sensor(0x5822,0x0e);//
+	write_cmos_sensor(0x5823,0x22);//
+	write_cmos_sensor(0x5824,0x23);//
+	write_cmos_sensor(0x5825,0x28);//
+	write_cmos_sensor(0x5826,0x29);//
+	write_cmos_sensor(0x5827,0x27);//
+	write_cmos_sensor(0x5828,0x13);//
+	write_cmos_sensor(0x5829,0x26);//
+	write_cmos_sensor(0x582a,0x33);//
+	write_cmos_sensor(0x582b,0x32);//
+	write_cmos_sensor(0x582c,0x33);//
+	write_cmos_sensor(0x582d,0x16);//
+	write_cmos_sensor(0x582e,0x14);//
+	write_cmos_sensor(0x582f,0x30);//
+	write_cmos_sensor(0x5830,0x31);//
+	write_cmos_sensor(0x5831,0x30);//
+	write_cmos_sensor(0x5832,0x15);//
+	write_cmos_sensor(0x5833,0x26);//
+	write_cmos_sensor(0x5834,0x23);//
+	write_cmos_sensor(0x5835,0x21);//
+	write_cmos_sensor(0x5836,0x23);//
+	write_cmos_sensor(0x5837,0x05);//
+	write_cmos_sensor(0x5838,0x36);//
+	write_cmos_sensor(0x5839,0x27);//
+	write_cmos_sensor(0x583a,0x28);//
+	write_cmos_sensor(0x583b,0x26);//
+	write_cmos_sensor(0x583c,0x24);//
+	write_cmos_sensor(0x583d,0xdf);// ; lens correction
+
+	//add 5b00~5b05 for OTP DPC control registers update-ov
+	write_cmos_sensor(0x5b00,0x02);//
+	write_cmos_sensor(0x5b01,0xd0);// 
+	write_cmos_sensor(0x5b02,0x03);// 
+	write_cmos_sensor(0x5b03,0xff);// 
+	write_cmos_sensor(0x5b05,0x6c);// 
+	//write_cmos_sensor(0x4800,0x5c);// ; mipi gate:lens start/end
+
+}
+
+	/*	sensor_init  */
+
+
+static void preview_setting(void)
+{
+	LOG_INF("Enter\n");
+
+	write_cmos_sensor(0x0100,0x00);//; software standby
+	
+	write_cmos_sensor(0x0302,0x1f);// ; PLL
+	write_cmos_sensor(0x030d,0x1f);// ; PLL	  ;1e
+	write_cmos_sensor(0x030f,0x09);//; PLL
+	write_cmos_sensor(0x3018,0x72);//
+	write_cmos_sensor(0x3106,0x01);//
+	
+	//write_cmos_sensor(0x3501,0x28);//; expouere H
+	//write_cmos_sensor(0x3502,0x90);//; exposure L
+	
+	write_cmos_sensor(0x3700,0x24);//; sensor control  AM24
+	write_cmos_sensor(0x3701,0x0c);//
+	write_cmos_sensor(0x3702,0x28);//
+	write_cmos_sensor(0x3703,0x19);//
+	write_cmos_sensor(0x3704,0x14);//
+	write_cmos_sensor(0x3706,0x38);//AM24
+	write_cmos_sensor(0x3707,0x04);//
+	write_cmos_sensor(0x3708,0x24);//
+	write_cmos_sensor(0x3709,0x40);//
+	write_cmos_sensor(0x370a,0x00);//
+	write_cmos_sensor(0x370b,0xb8);//AM24
+	write_cmos_sensor(0x370c,0x04);//
+	write_cmos_sensor(0x3718,0x12);//
+	write_cmos_sensor(0x3712,0x42);//
+	write_cmos_sensor(0x371e,0x19);//
+	write_cmos_sensor(0x371f,0x40);//
+	write_cmos_sensor(0x3720,0x05);//
+	write_cmos_sensor(0x3721,0x05);//
+	write_cmos_sensor(0x3724,0x02);//
+	write_cmos_sensor(0x3725,0x02);//
+	write_cmos_sensor(0x3726,0x06);//
+	write_cmos_sensor(0x3728,0x05);//
+	write_cmos_sensor(0x3729,0x02);//
+	write_cmos_sensor(0x372a,0x03);//
+	write_cmos_sensor(0x372b,0x53);//
+	write_cmos_sensor(0x372c,0xa3);//
+	write_cmos_sensor(0x372d,0x53);//
+	write_cmos_sensor(0x372e,0x06);//
+	write_cmos_sensor(0x372f,0x10);//
+	write_cmos_sensor(0x3730,0x01);//
+	write_cmos_sensor(0x3731,0x06);//
+	write_cmos_sensor(0x3732,0x14);//
+	write_cmos_sensor(0x3736,0x20);//
+	write_cmos_sensor(0x373a,0x02);//
+	write_cmos_sensor(0x373b,0x0c);//
+	write_cmos_sensor(0x373c,0x0a);//
+	write_cmos_sensor(0x373e,0x03);//
+	write_cmos_sensor(0x375a,0x06);//
+	write_cmos_sensor(0x375b,0x13);//
+	write_cmos_sensor(0x375c,0x40);// am26
+	write_cmos_sensor(0x375d,0x02);//
+	write_cmos_sensor(0x375f,0x14);//
+	write_cmos_sensor(0x3767,0x1c);//am26
+	write_cmos_sensor(0x3769,0x20);//
+	write_cmos_sensor(0x376c,0xc0);//am26
+	write_cmos_sensor(0x376d,0xc0);//am26
+	write_cmos_sensor(0x3772,0x23);//
+	write_cmos_sensor(0x3773,0x02);//
+	write_cmos_sensor(0x3774,0x16);//
+	write_cmos_sensor(0x3775,0x12);//
+	write_cmos_sensor(0x3776,0x08);//
+	write_cmos_sensor(0x37a0,0x44);//
+	write_cmos_sensor(0x37a1,0x3d);//
+	write_cmos_sensor(0x37a2,0x3d);//
+	write_cmos_sensor(0x37a3,0x01);//
+	write_cmos_sensor(0x37a5,0x08);//
+	write_cmos_sensor(0x37a7,0x44);//
+	write_cmos_sensor(0x37a8,0x58);//AM24
+	write_cmos_sensor(0x37a9,0x58);//AM24
+	write_cmos_sensor(0x37aa,0x44);//
+	write_cmos_sensor(0x37ab,0x2e);//
+	write_cmos_sensor(0x37ac,0x2e);//
+	write_cmos_sensor(0x37ad,0x33);//
+	write_cmos_sensor(0x37ae,0x0d);//
+	write_cmos_sensor(0x37af,0x0d);//
+	write_cmos_sensor(0x37b3,0x42);//
+	write_cmos_sensor(0x37b4,0x42);//
+	write_cmos_sensor(0x37b5,0x33);//
+
+	write_cmos_sensor(0x3808,0x06);//; X output size H	active 
+	write_cmos_sensor(0x3809,0x60);//; X output size L  (0x3809,0x60)
+	write_cmos_sensor(0x380a,0x04);//; Y output size H	active 
+	write_cmos_sensor(0x380b,0xc8);//; Y output size L (0x380b,0xc8)
+
+	write_cmos_sensor(0x380c,((imgsensor_info.pre.linelength >> 8) & 0xFF));//; HTS H
+	write_cmos_sensor(0x380d,(imgsensor_info.pre.linelength & 0xFF));//; HTS L
+	write_cmos_sensor(0x380e,((imgsensor_info.pre.framelength >> 8) & 0xFF));//; VTS H
+	write_cmos_sensor(0x380f,(imgsensor_info.pre.framelength & 0xFF));//; VTS L
+	
+	write_cmos_sensor(0x3813,0x04);//; ISP Y win L
+	write_cmos_sensor(0x3814,0x03);//; X inc odd
+	write_cmos_sensor(0x3821,0x67);//; hsync_en_o, fst_vbin, mirror on
+	write_cmos_sensor(0x382a,0x03);//; Y inc odd
+	write_cmos_sensor(0x382b,0x01);//; Y inc even
+	write_cmos_sensor(0x3830,0x08);//; ablc_use_num[5:1]
+	write_cmos_sensor(0x3836,0x02);//; zline_use_num[5:1]
+	write_cmos_sensor(0x3846,0x88);//; Y/X boundary pixel numbber for auto size mode
+	write_cmos_sensor(0x3f08,0x0b);//
+	
+	write_cmos_sensor(0x4000,0xf1);//; our range trig en, format chg en, gan chg en, exp chg en, median en
+	
+	write_cmos_sensor(0x4001,0x14);//; left 32 column, final BLC offset limitation enable
+	write_cmos_sensor(0x4020,0x01);//; anchor left start H
+	write_cmos_sensor(0x4021,0x20);//; anchor left start L
+	write_cmos_sensor(0x4022,0x01);//; anchor left end H
+	write_cmos_sensor(0x4023,0x9f);//; anchor left end L
+	write_cmos_sensor(0x4024,0x03);//; anchor right start H
+	write_cmos_sensor(0x4025,0xe0);//; anchor right start L
+	write_cmos_sensor(0x4026,0x04);//; anchor right end H
+	write_cmos_sensor(0x4027,0x5f);//; anchor right end L
+	write_cmos_sensor(0x402a,0x04);//; top black line start
+	write_cmos_sensor(0x402b,0x04);//am26
+	write_cmos_sensor(0x402c,0x02);//; bottom zero line start
+	write_cmos_sensor(0x402d,0x02);//; bottom zero line number
+	write_cmos_sensor(0x402e,0x08);//; bottom black line start
+	write_cmos_sensor(0x4500,0x40);//; ADC sync control
+	write_cmos_sensor(0x4601,0x74);//; V FIFO control
+	
+	write_cmos_sensor(0x4837,0x16);// ; clock period 
+	
+	write_cmos_sensor(0x5002,0x08);//; vario pixel off
+	write_cmos_sensor(0x5901,0x00);//
+
+	//mdelay(100);
+	write_cmos_sensor(0x0100,0x01);//; wake up, streaming
+}	/*	preview_setting  */
+
+static void capture_setting(kal_uint16 currefps)
+{
+	LOG_INF("Enter! currefps:%d\n",currefps);
+
+	if(currefps == 150)
+	{
+		write_cmos_sensor(0x0100,0x00);
+
+		write_cmos_sensor(0x0302,0x19);// 
+		write_cmos_sensor(0x030d,0x1e);// 
+		write_cmos_sensor(0x030f,0x05);// ; PLL
+		
+		write_cmos_sensor(0x3018,0x72);//
+		write_cmos_sensor(0x3106,0x01);//
+		
+		//write_cmos_sensor(0x3501,0x8f);// ; expouere H
+		//write_cmos_sensor(0x3502,0xa0);// ; exposure L
+		
+		write_cmos_sensor(0x3700,0x48);// ; sensor control	AM24
+		write_cmos_sensor(0x3701,0x18);//
+		write_cmos_sensor(0x3702,0x50);//
+		write_cmos_sensor(0x3703,0x32);//
+		write_cmos_sensor(0x3704,0x28);//
+		write_cmos_sensor(0x3706,0x70);//AM24
+		write_cmos_sensor(0x3707,0x08);//
+		write_cmos_sensor(0x3708,0x48);//
+		write_cmos_sensor(0x3709,0x80);//
+		write_cmos_sensor(0x370a,0x01);//
+		write_cmos_sensor(0x370b,0x70);//AM24
+		write_cmos_sensor(0x370c,0x07);//
+		write_cmos_sensor(0x3718,0x14);//
+		write_cmos_sensor(0x3712,0x44);//
+		write_cmos_sensor(0x371e,0x31);//
+		write_cmos_sensor(0x371f,0x7f);//
+		write_cmos_sensor(0x3720,0x0a);//
+		write_cmos_sensor(0x3721,0x0a);//
+		write_cmos_sensor(0x3724,0x04);//
+		write_cmos_sensor(0x3725,0x04);//
+		write_cmos_sensor(0x3726,0x0c);//
+		write_cmos_sensor(0x3728,0x0a);//
+		write_cmos_sensor(0x3729,0x03);//
+		write_cmos_sensor(0x372a,0x06);//
+		write_cmos_sensor(0x372b,0xa6);//
+		write_cmos_sensor(0x372c,0xa6);//
+		write_cmos_sensor(0x372d,0xa6);//
+		write_cmos_sensor(0x372e,0x0c);//
+		write_cmos_sensor(0x372f,0x20);//
+		write_cmos_sensor(0x3730,0x02);//
+		write_cmos_sensor(0x3731,0x0c);//
+		write_cmos_sensor(0x3732,0x28);//
+		write_cmos_sensor(0x3736,0x30);//
+		write_cmos_sensor(0x373a,0x04);//
+		write_cmos_sensor(0x373b,0x18);//
+		write_cmos_sensor(0x373c,0x14);//
+		write_cmos_sensor(0x373e,0x06);//
+		write_cmos_sensor(0x375a,0x0c);//
+		write_cmos_sensor(0x375b,0x26);//
+		write_cmos_sensor(0x375c,0x40);//am26
+		write_cmos_sensor(0x375d,0x04);//
+		write_cmos_sensor(0x375f,0x28);//
+		write_cmos_sensor(0x3767,0x1e);//0x04
+		write_cmos_sensor(0x3769,0x20);//
+		write_cmos_sensor(0x376c,0xc0);//am26
+		write_cmos_sensor(0x376d,0xc0);//am26
+		write_cmos_sensor(0x3772,0x46);//
+		write_cmos_sensor(0x3773,0x04);//
+		write_cmos_sensor(0x3774,0x2c);//
+		write_cmos_sensor(0x3775,0x13);//
+		write_cmos_sensor(0x3776,0x10);//
+		write_cmos_sensor(0x37a0,0x88);//
+		write_cmos_sensor(0x37a1,0x7a);//
+		write_cmos_sensor(0x37a2,0x7a);//
+		write_cmos_sensor(0x37a3,0x02);//
+		write_cmos_sensor(0x37a5,0x09);//
+		write_cmos_sensor(0x37a7,0x88);//
+		write_cmos_sensor(0x37a8,0xb0);//AM24
+		write_cmos_sensor(0x37a9,0xb0);//AM24
+		write_cmos_sensor(0x37aa,0x88);//
+		write_cmos_sensor(0x37ab,0x5c);//
+		write_cmos_sensor(0x37ac,0x5c);//
+		write_cmos_sensor(0x37ad,0x55);//
+		write_cmos_sensor(0x37ae,0x19);//
+		write_cmos_sensor(0x37af,0x19);//
+		write_cmos_sensor(0x37b3,0x84);//
+		write_cmos_sensor(0x37b4,0x84);//
+		write_cmos_sensor(0x37b5,0x66);//
+
+		write_cmos_sensor(0x3808,0x0c);// ; X output size H
+		write_cmos_sensor(0x3809,0xc0);// ; X output size L (0x3809,0xc0)
+		write_cmos_sensor(0x380a,0x09);// ; Y output size H
+		write_cmos_sensor(0x380b,0x90);// ; Y output size L (0x380b,0x90)
+		
+		write_cmos_sensor(0x380c,((imgsensor_info.cap1.linelength >> 8) & 0xFF));// ; HTS H //30fps
+		write_cmos_sensor(0x380d,(imgsensor_info.cap1.linelength & 0xFF));// ; HTS L 
+		write_cmos_sensor(0x380e,((imgsensor_info.cap1.framelength >> 8) & 0xFF));//; VTS H
+		write_cmos_sensor(0x380f,(imgsensor_info.cap1.framelength & 0xFF));//; VTS L
+		
+		write_cmos_sensor(0x3813,0x02);// ; ISP Y win L
+		write_cmos_sensor(0x3814,0x01);// ; X inc odd
+		write_cmos_sensor(0x3821,0x46);// ; hsync_en_o, fst_vbin, mirror on
+		write_cmos_sensor(0x382a,0x01);// ; Y inc odd
+		write_cmos_sensor(0x382b,0x01);// ; Y inc even
+		write_cmos_sensor(0x3830,0x04);// ; ablc_use_num[5:1]
+		write_cmos_sensor(0x3836,0x01);// ; zline_use_num[5:1]
+		write_cmos_sensor(0x3846,0x48);// ; Y/X boundary pixel numbber for auto size mode
+		write_cmos_sensor(0x3f08,0x16);//
+		
+		write_cmos_sensor(0x4000,0xf1);//; our range trig en, format chg en, gan chg en, exp chg en, median en
+		
+		write_cmos_sensor(0x4001,0x04);// ; left 32 column, final BLC offset limitation enable
+		write_cmos_sensor(0x4020,0x02);// ; anchor left start H
+		write_cmos_sensor(0x4021,0x40);// ; anchor left start L
+		write_cmos_sensor(0x4022,0x03);// ; anchor left end H
+		write_cmos_sensor(0x4023,0x3f);// ; anchor left end L
+		write_cmos_sensor(0x4024,0x07);// ; anchor right start H
+		write_cmos_sensor(0x4025,0xc0);// ; anchor right start L
+		write_cmos_sensor(0x4026,0x08);// ; anchor right end H
+		write_cmos_sensor(0x4027,0xbf);// ; anchor right end L
+		write_cmos_sensor(0x402a,0x04);// ; top black line start
+		write_cmos_sensor(0x402b,0x04);//am26
+		write_cmos_sensor(0x402c,0x02);// ; bottom zero line start	
+		write_cmos_sensor(0x402d,0x02);// ; bottom zero line number
+		write_cmos_sensor(0x402e,0x08);// ; bottom black line start
+		write_cmos_sensor(0x4500,0x68);// ; ADC sync control
+		write_cmos_sensor(0x4601,0x10);// ; V FIFO control
+		write_cmos_sensor(0x4837,0x1a);// ; clock period
+		write_cmos_sensor(0x5002,0x08);// ; vario pixel off
+		write_cmos_sensor(0x5901,0x00);//
+		
+		write_cmos_sensor(0x0100,0x01);//; wake up, streaming
+	}
+	else//normal capture
+	{
+		write_cmos_sensor(0x0100,0x00);
+		
+		write_cmos_sensor(0x0302,0x1f);// ; PLL
+		write_cmos_sensor(0x030d,0x1f);// ; PLL	  ;1e
+		write_cmos_sensor(0x030f,0x04);// ; PLL
+		write_cmos_sensor(0x3018,0x72);//
+		write_cmos_sensor(0x3106,0x01);//
+		
+		//write_cmos_sensor(0x3501,0x8f);// ; expouere H
+		//write_cmos_sensor(0x3502,0xa0);// ; exposure L
+		
+		write_cmos_sensor(0x3700,0x48);// ; sensor control  AM24
+		write_cmos_sensor(0x3701,0x18);//
+		write_cmos_sensor(0x3702,0x50);//
+		write_cmos_sensor(0x3703,0x32);//
+		write_cmos_sensor(0x3704,0x28);//
+		write_cmos_sensor(0x3706,0x70);//AM24
+		write_cmos_sensor(0x3707,0x08);//
+		write_cmos_sensor(0x3708,0x48);//
+		write_cmos_sensor(0x3709,0x80);//
+		write_cmos_sensor(0x370a,0x01);//
+		write_cmos_sensor(0x370b,0x70);//AM24
+		write_cmos_sensor(0x370c,0x07);//
+		write_cmos_sensor(0x3718,0x14);//
+		write_cmos_sensor(0x3712,0x44);//
+		write_cmos_sensor(0x371e,0x31);//
+		write_cmos_sensor(0x371f,0x7f);//
+		write_cmos_sensor(0x3720,0x0a);//
+		write_cmos_sensor(0x3721,0x0a);//
+		write_cmos_sensor(0x3724,0x04);//
+		write_cmos_sensor(0x3725,0x04);//
+		write_cmos_sensor(0x3726,0x0c);//
+		write_cmos_sensor(0x3728,0x0a);//
+		write_cmos_sensor(0x3729,0x03);//
+		write_cmos_sensor(0x372a,0x06);//
+		write_cmos_sensor(0x372b,0xa6);//
+		write_cmos_sensor(0x372c,0xa6);//
+		write_cmos_sensor(0x372d,0xa6);//
+		write_cmos_sensor(0x372e,0x0c);//
+		write_cmos_sensor(0x372f,0x20);//
+		write_cmos_sensor(0x3730,0x02);//
+		write_cmos_sensor(0x3731,0x0c);//
+		write_cmos_sensor(0x3732,0x28);//
+		write_cmos_sensor(0x3736,0x30);//
+		write_cmos_sensor(0x373a,0x04);//
+		write_cmos_sensor(0x373b,0x18);//
+		write_cmos_sensor(0x373c,0x14);//
+		write_cmos_sensor(0x373e,0x06);//
+		write_cmos_sensor(0x375a,0x0c);//
+		write_cmos_sensor(0x375b,0x26);//
+		write_cmos_sensor(0x375c,0x40);//am26
+		write_cmos_sensor(0x375d,0x04);//
+		write_cmos_sensor(0x375f,0x28);//
+		write_cmos_sensor(0x3767,0x1e);//0x04
+		write_cmos_sensor(0x3769,0x20);//
+		write_cmos_sensor(0x376c,0xc0);//am26
+		write_cmos_sensor(0x376d,0xc0);//am26
+		write_cmos_sensor(0x3772,0x46);//
+		write_cmos_sensor(0x3773,0x04);//
+		write_cmos_sensor(0x3774,0x2c);//
+		write_cmos_sensor(0x3775,0x13);//
+		write_cmos_sensor(0x3776,0x10);//
+		write_cmos_sensor(0x37a0,0x88);//
+		write_cmos_sensor(0x37a1,0x7a);//
+		write_cmos_sensor(0x37a2,0x7a);//
+		write_cmos_sensor(0x37a3,0x02);//
+		write_cmos_sensor(0x37a5,0x09);//
+		write_cmos_sensor(0x37a7,0x88);//
+		write_cmos_sensor(0x37a8,0xb0);//AM24
+		write_cmos_sensor(0x37a9,0xb0);//AM24
+		write_cmos_sensor(0x37aa,0x88);//
+		write_cmos_sensor(0x37ab,0x5c);//
+		write_cmos_sensor(0x37ac,0x5c);//
+		write_cmos_sensor(0x37ad,0x55);//
+		write_cmos_sensor(0x37ae,0x19);//
+		write_cmos_sensor(0x37af,0x19);//
+		write_cmos_sensor(0x37b3,0x84);//
+		write_cmos_sensor(0x37b4,0x84);//
+		write_cmos_sensor(0x37b5,0x66);//
+
+		write_cmos_sensor(0x3808,0x0c);// ; X output size H
+		write_cmos_sensor(0x3809,0xc0);// ; X output size L (0x3809,0xc0)
+		write_cmos_sensor(0x380a,0x09);// ; Y output size H
+		write_cmos_sensor(0x380b,0x90);// ; Y output size L (0x380b,0x90)
+		
+		write_cmos_sensor(0x380c,((imgsensor_info.cap.linelength >> 8) & 0xFF));// ; HTS H //30fps
+		write_cmos_sensor(0x380d,(imgsensor_info.cap.linelength & 0xFF));// ; HTS L 
+		write_cmos_sensor(0x380e,((imgsensor_info.cap.framelength >> 8) & 0xFF));//; VTS H
+		write_cmos_sensor(0x380f,(imgsensor_info.cap.framelength & 0xFF));//; VTS L
+		
+		write_cmos_sensor(0x3813,0x02);// ; ISP Y win L
+		write_cmos_sensor(0x3814,0x01);// ; X inc odd
+		write_cmos_sensor(0x3821,0x46);// ; hsync_en_o, fst_vbin, mirror on
+		write_cmos_sensor(0x382a,0x01);// ; Y inc odd
+		write_cmos_sensor(0x382b,0x01);// ; Y inc even
+		write_cmos_sensor(0x3830,0x04);// ; ablc_use_num[5:1]
+		write_cmos_sensor(0x3836,0x01);// ; zline_use_num[5:1]
+		write_cmos_sensor(0x3846,0x48);// ; Y/X boundary pixel numbber for auto size mode
+		write_cmos_sensor(0x3f08,0x16);//
+		
+		write_cmos_sensor(0x4000,0xf1);//; our range trig en, format chg en, gan chg en, exp chg en, median en
+		
+		write_cmos_sensor(0x4001,0x04);// ; left 32 column, final BLC offset limitation enable
+		write_cmos_sensor(0x4020,0x02);// ; anchor left start H
+		write_cmos_sensor(0x4021,0x40);// ; anchor left start L
+		write_cmos_sensor(0x4022,0x03);// ; anchor left end H
+		write_cmos_sensor(0x4023,0x3f);// ; anchor left end L
+		write_cmos_sensor(0x4024,0x07);// ; anchor right start H
+		write_cmos_sensor(0x4025,0xc0);// ; anchor right start L
+		write_cmos_sensor(0x4026,0x08);// ; anchor right end H
+		write_cmos_sensor(0x4027,0xbf);// ; anchor right end L
+		write_cmos_sensor(0x402a,0x04);// ; top black line start
+		write_cmos_sensor(0x402b,0x04);//am26
+		write_cmos_sensor(0x402c,0x02);// ; bottom zero line start  
+		write_cmos_sensor(0x402d,0x02);// ; bottom zero line number
+		write_cmos_sensor(0x402e,0x08);// ; bottom black line start
+		write_cmos_sensor(0x4500,0x68);// ; ADC sync control
+		write_cmos_sensor(0x4601,0x10);// ; V FIFO control
+		write_cmos_sensor(0x4837,0x16);// ; clock period
+		write_cmos_sensor(0x5002,0x08);// ; vario pixel off
+		write_cmos_sensor(0x5901,0x00);//
+		
+		write_cmos_sensor(0x0100,0x01);//; wake up, streaming
+	    }
+}	
+	
+		
+static void normal_video_setting(kal_uint16 currefps)
+{
+	LOG_INF("Enter! currefps:%d\n",currefps);
+
+	write_cmos_sensor(0x0100,0x00);
+
+	write_cmos_sensor(0x0302,0x1f);// ; PLL
+	write_cmos_sensor(0x030d,0x1f);// ; PLL	  ;1e
+	write_cmos_sensor(0x030f,0x04);// ; PLL
+	write_cmos_sensor(0x3018,0x72);//
+	write_cmos_sensor(0x3106,0x01);//
+
+	//write_cmos_sensor(0x3501,0x8f);//; expouere H
+	//write_cmos_sensor(0x3502,0xa0);// ; exposure L
+
+	write_cmos_sensor(0x3700,0x48);// ; sensor control AM24
+	write_cmos_sensor(0x3701,0x18);//
+	write_cmos_sensor(0x3702,0x50);//
+	write_cmos_sensor(0x3703,0x32);//
+	write_cmos_sensor(0x3704,0x28);//
+	write_cmos_sensor(0x3706,0x70);//AM24
+	write_cmos_sensor(0x3707,0x08);//
+	write_cmos_sensor(0x3708,0x48);//
+	write_cmos_sensor(0x3709,0x80);//
+	write_cmos_sensor(0x370a,0x01);//
+	write_cmos_sensor(0x370b,0x70);//AM24
+	write_cmos_sensor(0x370c,0x07);//
+	write_cmos_sensor(0x3718,0x14);//
+	write_cmos_sensor(0x3712,0x44);//
+	write_cmos_sensor(0x371e,0x31);//
+	write_cmos_sensor(0x371f,0x7f);//
+	write_cmos_sensor(0x3720,0x0a);//
+	write_cmos_sensor(0x3721,0x0a);//
+	write_cmos_sensor(0x3724,0x04);//
+	write_cmos_sensor(0x3725,0x04);//
+	write_cmos_sensor(0x3726,0x0c);//
+	write_cmos_sensor(0x3728,0x0a);//
+	write_cmos_sensor(0x3729,0x03);//
+	write_cmos_sensor(0x372a,0x06);//
+	write_cmos_sensor(0x372b,0xa6);//
+	write_cmos_sensor(0x372c,0xa6);//
+	write_cmos_sensor(0x372d,0xa6);//
+	write_cmos_sensor(0x372e,0x0c);//
+	write_cmos_sensor(0x372f,0x20);//
+	write_cmos_sensor(0x3730,0x02);//
+	write_cmos_sensor(0x3731,0x0c);//
+	write_cmos_sensor(0x3732,0x28);//
+	write_cmos_sensor(0x3736,0x30);//
+	write_cmos_sensor(0x373a,0x04);//
+	write_cmos_sensor(0x373b,0x18);//
+	write_cmos_sensor(0x373c,0x14);//
+	write_cmos_sensor(0x373e,0x06);//
+	write_cmos_sensor(0x375a,0x0c);//
+	write_cmos_sensor(0x375b,0x26);//
+	write_cmos_sensor(0x375c,0x40);// am26
+	write_cmos_sensor(0x375d,0x04);//
+	write_cmos_sensor(0x375f,0x28);//
+	write_cmos_sensor(0x3767,0x1e);//
+	write_cmos_sensor(0x3769,0x20);//
+	write_cmos_sensor(0x376c,0xc0);// am26
+	write_cmos_sensor(0x376d,0xc0);// am26
+	write_cmos_sensor(0x3772,0x46);//
+	write_cmos_sensor(0x3773,0x04);//
+	write_cmos_sensor(0x3774,0x2c);//
+	write_cmos_sensor(0x3775,0x13);//
+	write_cmos_sensor(0x3776,0x10);//
+	write_cmos_sensor(0x37a0,0x88);//
+	write_cmos_sensor(0x37a1,0x7a);//
+	write_cmos_sensor(0x37a2,0x7a);//
+	write_cmos_sensor(0x37a3,0x02);//
+	write_cmos_sensor(0x37a5,0x09);//
+	write_cmos_sensor(0x37a7,0x88);//
+	write_cmos_sensor(0x37a8,0xb0);//AM24
+	write_cmos_sensor(0x37a9,0xb0);//AM24
+	write_cmos_sensor(0x37aa,0x88);//
+	write_cmos_sensor(0x37ab,0x5c);//
+	write_cmos_sensor(0x37ac,0x5c);//
+	write_cmos_sensor(0x37ad,0x55);//
+	write_cmos_sensor(0x37ae,0x19);//
+	write_cmos_sensor(0x37af,0x19);//
+	write_cmos_sensor(0x37b3,0x84);//
+	write_cmos_sensor(0x37b4,0x84);//
+	write_cmos_sensor(0x37b5,0x66);//
+
+	write_cmos_sensor(0x3808,0x0c);// ; X output size H
+	write_cmos_sensor(0x3809,0xc0);// ; X output size L	(0x3809,0xc0)
+	write_cmos_sensor(0x380a,0x07);// ; Y output size H
+	//write_cmos_sensor(0x380b,0x30);// ; Y output size L  (0x380b,0x2c)
+	write_cmos_sensor(0x380b,0x2c);// ; Y output size L	(0x380b,0x2c)
+
+	write_cmos_sensor(0x380c,((imgsensor_info.normal_video.linelength >> 8) & 0xFF));// ; HTS H
+	write_cmos_sensor(0x380d,(imgsensor_info.normal_video.linelength & 0xFF));// ; HTS L
+	write_cmos_sensor(0x380e,((imgsensor_info.normal_video.framelength >> 8) & 0xFF));// ; VTS H
+	write_cmos_sensor(0x380f,(imgsensor_info.normal_video.framelength & 0xFF));// ; VTS L
+
+	write_cmos_sensor(0x3813,0x02);// ; ISP Y win L
+	write_cmos_sensor(0x3814,0x01);// ; X inc odd
+	write_cmos_sensor(0x3821,0x46);// ; hsync_en_o, fst_vbin, mirror on
+	write_cmos_sensor(0x382a,0x01);// ; Y inc odd
+	write_cmos_sensor(0x382b,0x01);// ; Y inc even
+	write_cmos_sensor(0x3830,0x04);// ; ablc_use_num[5:1]
+	write_cmos_sensor(0x3836,0x01);// ; zline_use_num[5:1]
+	write_cmos_sensor(0x3846,0x48);// ; Y/X boundary pixel numbber for auto size mode
+	write_cmos_sensor(0x3f08,0x16);//
+
+	write_cmos_sensor(0x4000,0xf1);//; our range trig en, format chg en, gan chg en, exp chg en, median en
+
+	write_cmos_sensor(0x4001,0x04);// ; left 32 column, final BLC offset limitation enable
+	write_cmos_sensor(0x4020,0x02);// ; anchor left start H
+	write_cmos_sensor(0x4021,0x40);// ; anchor left start L
+	write_cmos_sensor(0x4022,0x03);// ; anchor left end H
+	write_cmos_sensor(0x4023,0x3f);// ; anchor left end L
+	write_cmos_sensor(0x4024,0x07);// ; anchor right start H
+	write_cmos_sensor(0x4025,0xc0);// ; anchor right start L
+	write_cmos_sensor(0x4026,0x08);// ; anchor right end H
+	write_cmos_sensor(0x4027,0xbf);// ; anchor right end L
+	write_cmos_sensor(0x402a,0x04);// ; top black line start
+	write_cmos_sensor(0x402b,0x04);//am26
+	write_cmos_sensor(0x402c,0x02);// ; bottom zero line start
+	write_cmos_sensor(0x402d,0x02);// ; bottom zero line number
+	write_cmos_sensor(0x402e,0x08);// ; bottom black line start
+	write_cmos_sensor(0x4500,0x68);// ; ADC sync control
+	write_cmos_sensor(0x4601,0x10);// ; V FIFO control
+	
+	write_cmos_sensor(0x4837,0x16);// ; clock period
+	write_cmos_sensor(0x5002,0x08);// ; vario pixel off
+	write_cmos_sensor(0x5901,0x00);//
+
+	write_cmos_sensor(0x0100,0x01);//; wake up, streaming
+}
+
+
+
+static void hs_video_setting()
+{
+	LOG_INF("Enter!\n");
+
+	write_cmos_sensor(0x0100,0x00);// ; software standby
+	
+	write_cmos_sensor(0x0302,0x1f);//;
+	write_cmos_sensor(0x030d,0x1f);//;
+	write_cmos_sensor(0x030f,0x09);//
+	write_cmos_sensor(0x3018,0x72);//
+	write_cmos_sensor(0x3106,0x01);//
+	
+	//write_cmos_sensor(0x3501,0x1e);//
+	//write_cmos_sensor(0x3502,0x70);//
+	
+	write_cmos_sensor(0x3700,0x24);//
+	write_cmos_sensor(0x3701,0x0c);//
+	write_cmos_sensor(0x3702,0x28);//
+	write_cmos_sensor(0x3703,0x19);//
+	write_cmos_sensor(0x3704,0x14);//
+	write_cmos_sensor(0x3706,0x38);//
+	write_cmos_sensor(0x3707,0x04);//
+	write_cmos_sensor(0x3708,0x24);//
+	write_cmos_sensor(0x3709,0x40);//
+	write_cmos_sensor(0x370a,0x00);//
+	write_cmos_sensor(0x370b,0xb8);//
+	write_cmos_sensor(0x370c,0x04);//
+	write_cmos_sensor(0x3718,0x12);//
+	write_cmos_sensor(0x3712,0x42);//
+	write_cmos_sensor(0x371e,0x19);//
+	write_cmos_sensor(0x371f,0x40);//
+	write_cmos_sensor(0x3720,0x05);//
+	write_cmos_sensor(0x3721,0x05);//
+	write_cmos_sensor(0x3724,0x02);//
+	write_cmos_sensor(0x3725,0x02);//
+	write_cmos_sensor(0x3726,0x06);//
+	write_cmos_sensor(0x3728,0x05);//
+	write_cmos_sensor(0x3729,0x02);//
+	write_cmos_sensor(0x372a,0x03);//
+	write_cmos_sensor(0x372b,0x53);//
+	write_cmos_sensor(0x372c,0xa3);//
+	write_cmos_sensor(0x372d,0x53);//
+	write_cmos_sensor(0x372e,0x06);//
+	write_cmos_sensor(0x372f,0x10);//
+	write_cmos_sensor(0x3730,0x01);//
+	write_cmos_sensor(0x3731,0x06);//
+	write_cmos_sensor(0x3732,0x14);//
+	write_cmos_sensor(0x3736,0x20);//
+	write_cmos_sensor(0x373a,0x02);//
+	write_cmos_sensor(0x373b,0x0c);//
+	write_cmos_sensor(0x373c,0x0a);//
+	write_cmos_sensor(0x373e,0x03);//
+	write_cmos_sensor(0x375a,0x06);//
+	write_cmos_sensor(0x375b,0x13);//
+	write_cmos_sensor(0x375d,0x02);//
+	write_cmos_sensor(0x375f,0x14);//
+	write_cmos_sensor(0x3767,0x18);//
+	write_cmos_sensor(0x3769,0x20);//
+	write_cmos_sensor(0x3772,0x23);//
+	write_cmos_sensor(0x3773,0x02);//
+	write_cmos_sensor(0x3774,0x16);//
+	write_cmos_sensor(0x3775,0x12);//
+	write_cmos_sensor(0x3776,0x08);//
+	write_cmos_sensor(0x37a0,0x44);//
+	write_cmos_sensor(0x37a1,0x3d);//
+	write_cmos_sensor(0x37a2,0x3d);//
+	write_cmos_sensor(0x37a3,0x01);//
+	write_cmos_sensor(0x37a5,0x08);//
+	write_cmos_sensor(0x37a7,0x44);//
+	write_cmos_sensor(0x37a8,0x58);//
+	write_cmos_sensor(0x37a9,0x58);//
+	write_cmos_sensor(0x37aa,0x44);//
+	write_cmos_sensor(0x37ab,0x2e);//
+	write_cmos_sensor(0x37ac,0x2e);//
+	write_cmos_sensor(0x37ad,0x33);//
+	write_cmos_sensor(0x37ae,0x0d);//
+	write_cmos_sensor(0x37af,0x0d);//
+	write_cmos_sensor(0x37b3,0x42);//
+	write_cmos_sensor(0x37b4,0x42);//
+	write_cmos_sensor(0x37b5,0x33);//
+	
+	write_cmos_sensor(0x3808,0x02);////640
+	write_cmos_sensor(0x3809,0x80);//
+	write_cmos_sensor(0x380a,0x01);//480
+	write_cmos_sensor(0x380b,0xe0);//
+	
+	write_cmos_sensor(0x380c,((imgsensor_info.hs_video.linelength >> 8) & 0xFF));// ; HTS H
+	write_cmos_sensor(0x380d,(imgsensor_info.hs_video.linelength & 0xFF));// ; HTS L
+	write_cmos_sensor(0x380e,((imgsensor_info.hs_video.framelength >> 8) & 0xFF));// ; VTS H
+	write_cmos_sensor(0x380f,(imgsensor_info.hs_video.framelength & 0xFF));// ; VTS L
+	
+	write_cmos_sensor(0x3813,0x04);//
+	write_cmos_sensor(0x3814,0x03);//
+	write_cmos_sensor(0x3821,0x6f);//
+	write_cmos_sensor(0x382a,0x05);//
+	write_cmos_sensor(0x382b,0x03);//
+	write_cmos_sensor(0x3830,0x08);//
+	write_cmos_sensor(0x3836,0x02);//
+	write_cmos_sensor(0x3846,0x88);//
+	write_cmos_sensor(0x3f08,0x0b);//
+	write_cmos_sensor(0x4000,0xf1);// 
+	write_cmos_sensor(0x4001,0x14);//
+	write_cmos_sensor(0x4020,0x01);//
+	write_cmos_sensor(0x4021,0x20);//
+	write_cmos_sensor(0x4022,0x01);//
+	write_cmos_sensor(0x4023,0x9f);//
+	write_cmos_sensor(0x4024,0x03);//
+	write_cmos_sensor(0x4025,0xe0);//
+	write_cmos_sensor(0x4026,0x04);//
+	write_cmos_sensor(0x4027,0x5f);//
+	write_cmos_sensor(0x402a,0x02);//
+	write_cmos_sensor(0x402b,0x02);//
+	write_cmos_sensor(0x402c,0x00);//
+	write_cmos_sensor(0x402d,0x00);//
+	write_cmos_sensor(0x402e,0x04);//
+	write_cmos_sensor(0x4500,0x40);//
+	write_cmos_sensor(0x4601,0x50);//
+	write_cmos_sensor(0x4837,0x15);//
+	write_cmos_sensor(0x5002,0x0c);//
+	write_cmos_sensor(0x5901,0x04);//
+	
+	write_cmos_sensor(0x0100,0x01);// ; wake up, streaming
+}
+
+
+
+static void slim_video_setting()
+{
+	LOG_INF("Enter!\n");
+
+	write_cmos_sensor(0x0100,0x00);//; software standby
+	
+	write_cmos_sensor(0x0302,0x1f);// ; PLL
+	write_cmos_sensor(0x030d,0x1f);// ; PLL   ;1e
+	write_cmos_sensor(0x030f,0x09);//; PLL
+	write_cmos_sensor(0x3018,0x72);//
+	write_cmos_sensor(0x3106,0x01);//
+	
+	//write_cmos_sensor(0x3501,0x28);//; expouere H
+	//write_cmos_sensor(0x3502,0x90);//; exposure L
+	
+	write_cmos_sensor(0x3700,0x24);//; sensor control  AM24
+	write_cmos_sensor(0x3701,0x0c);//
+	write_cmos_sensor(0x3702,0x28);//
+	write_cmos_sensor(0x3703,0x19);//
+	write_cmos_sensor(0x3704,0x14);//
+	write_cmos_sensor(0x3706,0x38);//AM24
+	write_cmos_sensor(0x3707,0x04);//
+	write_cmos_sensor(0x3708,0x24);//
+	write_cmos_sensor(0x3709,0x40);//
+	write_cmos_sensor(0x370a,0x00);//
+	write_cmos_sensor(0x370b,0xb8);//AM24
+	write_cmos_sensor(0x370c,0x04);//
+	write_cmos_sensor(0x3718,0x12);//
+	write_cmos_sensor(0x3712,0x42);//
+	write_cmos_sensor(0x371e,0x19);//
+	write_cmos_sensor(0x371f,0x40);//
+	write_cmos_sensor(0x3720,0x05);//
+	write_cmos_sensor(0x3721,0x05);//
+	write_cmos_sensor(0x3724,0x02);//
+	write_cmos_sensor(0x3725,0x02);//
+	write_cmos_sensor(0x3726,0x06);//
+	write_cmos_sensor(0x3728,0x05);//
+	write_cmos_sensor(0x3729,0x02);//
+	write_cmos_sensor(0x372a,0x03);//
+	write_cmos_sensor(0x372b,0x53);//
+	write_cmos_sensor(0x372c,0xa3);//
+	write_cmos_sensor(0x372d,0x53);//
+	write_cmos_sensor(0x372e,0x06);//
+	write_cmos_sensor(0x372f,0x10);//
+	write_cmos_sensor(0x3730,0x01);//
+	write_cmos_sensor(0x3731,0x06);//
+	write_cmos_sensor(0x3732,0x14);//
+	write_cmos_sensor(0x3736,0x20);//
+	write_cmos_sensor(0x373a,0x02);//
+	write_cmos_sensor(0x373b,0x0c);//
+	write_cmos_sensor(0x373c,0x0a);//
+	write_cmos_sensor(0x373e,0x03);//
+	write_cmos_sensor(0x375a,0x06);//
+	write_cmos_sensor(0x375b,0x13);//
+	write_cmos_sensor(0x375c,0x40);// am26
+	write_cmos_sensor(0x375d,0x02);//
+	write_cmos_sensor(0x375f,0x14);//
+	write_cmos_sensor(0x3767,0x1c);//am26
+	write_cmos_sensor(0x3769,0x20);//
+	write_cmos_sensor(0x376c,0xc0);//am26
+	write_cmos_sensor(0x376d,0xc0);//am26
+	write_cmos_sensor(0x3772,0x23);//
+	write_cmos_sensor(0x3773,0x02);//
+	write_cmos_sensor(0x3774,0x16);//
+	write_cmos_sensor(0x3775,0x12);//
+	write_cmos_sensor(0x3776,0x08);//
+	write_cmos_sensor(0x37a0,0x44);//
+	write_cmos_sensor(0x37a1,0x3d);//
+	write_cmos_sensor(0x37a2,0x3d);//
+	write_cmos_sensor(0x37a3,0x01);//
+	write_cmos_sensor(0x37a5,0x08);//
+	write_cmos_sensor(0x37a7,0x44);//
+	write_cmos_sensor(0x37a8,0x58);//AM24
+	write_cmos_sensor(0x37a9,0x58);//AM24
+	write_cmos_sensor(0x37aa,0x44);//
+	write_cmos_sensor(0x37ab,0x2e);//
+	write_cmos_sensor(0x37ac,0x2e);//
+	write_cmos_sensor(0x37ad,0x33);//
+	write_cmos_sensor(0x37ae,0x0d);//
+	write_cmos_sensor(0x37af,0x0d);//
+	write_cmos_sensor(0x37b3,0x42);//
+	write_cmos_sensor(0x37b4,0x42);//
+	write_cmos_sensor(0x37b5,0x33);//
+
+	write_cmos_sensor(0x3808,0x06);//; X output size H	active 
+	write_cmos_sensor(0x3809,0x60);//; X output size L	(0x3809,0x60)
+	write_cmos_sensor(0x380a,0x04);//; Y output size H	active 
+	write_cmos_sensor(0x380b,0xc8);//; Y output size L (0x380b,0xc8)
+
+	write_cmos_sensor(0x380c,((imgsensor_info.slim_video.linelength >> 8) & 0xFF));// ; HTS H
+	write_cmos_sensor(0x380d,(imgsensor_info.slim_video.linelength & 0xFF));// ; HTS L
+	write_cmos_sensor(0x380e,((imgsensor_info.slim_video.framelength >> 8) & 0xFF));// ; VTS H
+	write_cmos_sensor(0x380f,(imgsensor_info.slim_video.framelength & 0xFF));// ; VTS L
+
+	write_cmos_sensor(0x3813,0x04);//; ISP Y win L
+	write_cmos_sensor(0x3814,0x03);//; X inc odd
+	write_cmos_sensor(0x3821,0x67);//; hsync_en_o, fst_vbin, mirror on
+	write_cmos_sensor(0x382a,0x03);//; Y inc odd
+	write_cmos_sensor(0x382b,0x01);//; Y inc even
+	write_cmos_sensor(0x3830,0x08);//; ablc_use_num[5:1]
+	write_cmos_sensor(0x3836,0x02);//; zline_use_num[5:1]
+	write_cmos_sensor(0x3846,0x88);//; Y/X boundary pixel numbber for auto size mode
+	write_cmos_sensor(0x3f08,0x0b);//
+	
+	write_cmos_sensor(0x4000,0xf1);//; our range trig en, format chg en, gan chg en, exp chg en, median en
+	
+	write_cmos_sensor(0x4001,0x14);//; left 32 column, final BLC offset limitation enable
+	write_cmos_sensor(0x4020,0x01);//; anchor left start H
+	write_cmos_sensor(0x4021,0x20);//; anchor left start L
+	write_cmos_sensor(0x4022,0x01);//; anchor left end H
+	write_cmos_sensor(0x4023,0x9f);//; anchor left end L
+	write_cmos_sensor(0x4024,0x03);//; anchor right start H
+	write_cmos_sensor(0x4025,0xe0);//; anchor right start L
+	write_cmos_sensor(0x4026,0x04);//; anchor right end H
+	write_cmos_sensor(0x4027,0x5f);//; anchor right end L
+	write_cmos_sensor(0x402a,0x04);//; top black line start
+	write_cmos_sensor(0x402b,0x04);//am26
+	write_cmos_sensor(0x402c,0x02);//; bottom zero line start
+	write_cmos_sensor(0x402d,0x02);//; bottom zero line number
+	write_cmos_sensor(0x402e,0x08);//; bottom black line start
+	write_cmos_sensor(0x4500,0x40);//; ADC sync control
+	write_cmos_sensor(0x4601,0x74);//; V FIFO control
+	
+	write_cmos_sensor(0x4837,0x16);// ; clock period
+	
+	write_cmos_sensor(0x5002,0x08);//; vario pixel off
+	write_cmos_sensor(0x5901,0x00);//
+
+	write_cmos_sensor(0x0100,0x01);//; wake up, streaming
+
+}
+
+/*************************************************************************
+* FUNCTION
+*	get_imgsensor_id
+*
+* DESCRIPTION
+*	This function get the sensor ID 
+*
+* PARAMETERS
+*	*sensorID : return the sensor ID 
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 get_imgsensor_id(UINT32 *sensor_id) 
+{
+	kal_uint8 i = 0;
+	kal_uint8 retry = 2;
+
+	write_cmos_sensor(0x0103,0x01);// Reset sensor
+    mdelay(2);
+	
+	//module have defferent  i2c address;
+	while (imgsensor_info.i2c_addr_table[i] != 0xff) {
+		spin_lock(&imgsensor_drv_lock);
+		imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
+		spin_unlock(&imgsensor_drv_lock);
+		do {
+			*sensor_id = ((read_cmos_sensor(0x300B) << 8) | read_cmos_sensor(0x300C));
+			if (*sensor_id == imgsensor_info.sensor_id) {				
+				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);	  
+				return ERROR_NONE;
+			}	
+			LOG_INF("Read sensor id fail, write id: 0x%x, id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
+			retry--;
+		} while(retry > 0);
+		
+		i++;
+		retry = 2;
+	}
+	if (*sensor_id != imgsensor_info.sensor_id) {
+		// if Sensor ID is not correct, Must set *sensor_id to 0xFFFFFFFF 
+		*sensor_id = 0xFFFFFFFF;
+		return ERROR_SENSOR_CONNECT_FAIL;
+	}
+	return ERROR_NONE;
+}
+
+
+/*************************************************************************
+* FUNCTION
+*	open
+*
+* DESCRIPTION
+*	This function initialize the registers of CMOS sensor
+*
+* PARAMETERS
+*	None
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 open(void)
+{
+	kal_uint8 i = 0;
+	kal_uint8 retry = 2;
+	kal_uint16 sensor_id = 0; 
+	LOG_INF("PLATFORM:MT6595,MIPI 4LANE\n");
+	LOG_INF("preview/normal video/capture 30fps\n");
+	LOG_INF("...\n");
+
+	
+	write_cmos_sensor(0x0103,0x01);// Reset sensor
+	mdelay(2);
+	
+	while (imgsensor_info.i2c_addr_table[i] != 0xff) {
+		spin_lock(&imgsensor_drv_lock);
+		imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
+		spin_unlock(&imgsensor_drv_lock);
+		do {
+			sensor_id = ((read_cmos_sensor(0x300B) << 8) | read_cmos_sensor(0x300C));
+			if (sensor_id == imgsensor_info.sensor_id) {				
+				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);	  
+				break;
+			}	
+			LOG_INF("Read sensor id fail, write id: 0x%x, id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
+			retry--;
+		} while(retry > 0);
+		
+		i++;
+		if (sensor_id == imgsensor_info.sensor_id)
+			break;
+		retry = 2;
+	}		 
+	if (imgsensor_info.sensor_id != sensor_id)
+		return ERROR_SENSOR_CONNECT_FAIL;
+	
+	/* initail sequence write in  */
+	sensor_init();
+
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.autoflicker_en= KAL_FALSE;
+	imgsensor.sensor_mode = IMGSENSOR_MODE_INIT;
+	imgsensor.shutter = 0x3D0;
+	imgsensor.gain = 0x100;
+	imgsensor.pclk = imgsensor_info.pre.pclk;
+	imgsensor.frame_length = imgsensor_info.pre.framelength;
+	imgsensor.line_length = imgsensor_info.pre.linelength;
+	imgsensor.min_frame_length = imgsensor_info.pre.framelength;
+	imgsensor.dummy_pixel = 0;
+	imgsensor.dummy_line = 0;
+	imgsensor.ihdr_en = 0;
+	imgsensor.current_fps = imgsensor_info.pre.max_framerate;
+	imgsensor.test_pattern = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+
+	return ERROR_NONE;
+}	/*	open  */
+
+
+
+/*************************************************************************
+* FUNCTION
+*	close
+*
+* DESCRIPTION
+*	
+*
+* PARAMETERS
+*	None
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 close(void)
+{
+	LOG_INF("E\n");
+
+	/*No Need to implement this function*/ 
+	
+	return ERROR_NONE;
+}	/*	close  */
+
+
+/*************************************************************************
+* FUNCTION
+* preview
+*
+* DESCRIPTION
+*	This function start the sensor preview.
+*
+* PARAMETERS
+*	*image_window : address pointer of pixel numbers in one period of HSYNC
+*  *sensor_config_data : address pointer of line numbers in one period of VSYNC
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("E\n");
+
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.sensor_mode = IMGSENSOR_MODE_PREVIEW;
+	imgsensor.pclk = imgsensor_info.pre.pclk;
+	//imgsensor.video_mode = KAL_FALSE;
+	imgsensor.line_length = imgsensor_info.pre.linelength;
+	imgsensor.frame_length = imgsensor_info.pre.framelength; 
+	imgsensor.min_frame_length = imgsensor_info.pre.framelength;
+	imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	preview_setting();
+   // set_mirror_flip(imgsensor.mirror);
+	return ERROR_NONE;
+}	/*	preview   */
+
+/*************************************************************************
+* FUNCTION
+*	capture
+*
+* DESCRIPTION
+*	This function setup the CMOS sensor in capture MY_OUTPUT mode
+*
+* PARAMETERS
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+						  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("E\n");
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.sensor_mode = IMGSENSOR_MODE_CAPTURE;
+	if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {//PIP capture: 24fps for less than 13M, 20fps for 16M,15fps for 20M
+		imgsensor.pclk = imgsensor_info.cap1.pclk;
+		imgsensor.line_length = imgsensor_info.cap1.linelength;
+		imgsensor.frame_length = imgsensor_info.cap1.framelength;  
+		imgsensor.min_frame_length = imgsensor_info.cap1.framelength;
+		imgsensor.autoflicker_en = KAL_FALSE;
+	} else {
+		if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
+			LOG_INF("Warning: current_fps %d fps is not support, so use cap's setting: %d fps!\n",imgsensor.current_fps,imgsensor_info.cap.max_framerate/10);
+		
+		imgsensor.pclk = imgsensor_info.cap.pclk;
+		imgsensor.line_length = imgsensor_info.cap.linelength;
+		imgsensor.frame_length = imgsensor_info.cap.framelength;  
+		imgsensor.min_frame_length = imgsensor_info.cap.framelength;
+		imgsensor.autoflicker_en = KAL_FALSE;
+	}
+	spin_unlock(&imgsensor_drv_lock);
+
+	capture_setting(imgsensor.current_fps); 
+	
+	if(imgsensor.test_pattern == KAL_TRUE)
+	{
+		write_cmos_sensor(0x5E00,0x80);
+		mdelay(40);
+		
+	}
+    //set_mirror_flip(imgsensor.mirror);
+	return ERROR_NONE;
+}	/* capture() */
+static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("E\n");
+	
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.sensor_mode = IMGSENSOR_MODE_VIDEO;
+	imgsensor.pclk = imgsensor_info.normal_video.pclk;
+	imgsensor.line_length = imgsensor_info.normal_video.linelength;
+	imgsensor.frame_length = imgsensor_info.normal_video.framelength;  
+	imgsensor.min_frame_length = imgsensor_info.normal_video.framelength;
+	//imgsensor.current_fps = imgsensor_info.normal_video.max_framerate;
+	imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	normal_video_setting(imgsensor.current_fps);
+	//set_mirror_flip(imgsensor.mirror);
+	return ERROR_NONE;
+}	/*	normal_video   */
+
+static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("E\n");
+	
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.sensor_mode = IMGSENSOR_MODE_HIGH_SPEED_VIDEO;
+	imgsensor.pclk = imgsensor_info.hs_video.pclk;
+	//imgsensor.video_mode = KAL_TRUE;
+	imgsensor.line_length = imgsensor_info.hs_video.linelength;
+	imgsensor.frame_length = imgsensor_info.hs_video.framelength; 
+	imgsensor.min_frame_length = imgsensor_info.hs_video.framelength;
+	imgsensor.dummy_line = 0;
+	imgsensor.dummy_pixel = 0;
+	//imgsensor.current_fps = imgsensor_info.hs_video.max_framerate;;
+	imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	hs_video_setting();
+	//set_mirror_flip(imgsensor.mirror);
+	return ERROR_NONE;
+}	/*	hs_video   */
+
+static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("E \n");
+	
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.sensor_mode = IMGSENSOR_MODE_SLIM_VIDEO;
+	imgsensor.pclk = imgsensor_info.slim_video.pclk;
+	imgsensor.line_length = imgsensor_info.slim_video.linelength;
+	imgsensor.frame_length = imgsensor_info.slim_video.framelength; 
+	imgsensor.min_frame_length = imgsensor_info.slim_video.framelength;
+	imgsensor.dummy_line = 0;
+	imgsensor.dummy_pixel = 0;
+	//imgsensor.current_fps = imgsensor_info.slim_video.max_framerate;;
+	imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	slim_video_setting();
+	//set_mirror_flip(imgsensor.mirror);
+	return ERROR_NONE;
+}	/*	slim_video	 */
+
+
+
+static kal_uint32 get_resolution(MSDK_SENSOR_RESOLUTION_INFO_STRUCT *sensor_resolution)
+{
+	LOG_INF("E\n");
+	sensor_resolution->SensorFullWidth = imgsensor_info.cap.grabwindow_width;
+	sensor_resolution->SensorFullHeight = imgsensor_info.cap.grabwindow_height;
+	
+	sensor_resolution->SensorPreviewWidth = imgsensor_info.pre.grabwindow_width;
+	sensor_resolution->SensorPreviewHeight = imgsensor_info.pre.grabwindow_height;
+
+	sensor_resolution->SensorVideoWidth = imgsensor_info.normal_video.grabwindow_width;
+	sensor_resolution->SensorVideoHeight = imgsensor_info.normal_video.grabwindow_height;		
+
+	
+	sensor_resolution->SensorHighSpeedVideoWidth	 = imgsensor_info.hs_video.grabwindow_width;
+	sensor_resolution->SensorHighSpeedVideoHeight	 = imgsensor_info.hs_video.grabwindow_height;
+	
+	sensor_resolution->SensorSlimVideoWidth	 = imgsensor_info.slim_video.grabwindow_width;
+	sensor_resolution->SensorSlimVideoHeight	 = imgsensor_info.slim_video.grabwindow_height;
+	return ERROR_NONE;
+}	/*	get_resolution	*/
+
+static kal_uint32 get_info(MSDK_SCENARIO_ID_ENUM scenario_id,
+					  MSDK_SENSOR_INFO_STRUCT *sensor_info,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("scenario_id = %d\n", scenario_id);
+
+
+	sensor_info->SensorClockPolarity = SENSOR_CLOCK_POLARITY_LOW;
+	sensor_info->SensorClockFallingPolarity = SENSOR_CLOCK_POLARITY_LOW; /* not use */
+	sensor_info->SensorHsyncPolarity = SENSOR_CLOCK_POLARITY_LOW; // inverse with datasheet
+	sensor_info->SensorVsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
+	sensor_info->SensorInterruptDelayLines = 4; /* not use */
+	sensor_info->SensorResetActiveHigh = FALSE; /* not use */
+	sensor_info->SensorResetDelayCount = 5; /* not use */
+
+	sensor_info->SensroInterfaceType = imgsensor_info.sensor_interface_type;
+	//sensor_info->MIPIsensorType = imgsensor_info.mipi_sensor_type;
+	//sensor_info->SettleDelayMode = imgsensor_info.mipi_settle_delay_mode;
+	sensor_info->SensorOutputDataFormat = imgsensor_info.sensor_output_dataformat;
+
+	sensor_info->CaptureDelayFrame = imgsensor_info.cap_delay_frame; 
+	sensor_info->PreviewDelayFrame = imgsensor_info.pre_delay_frame; 
+	sensor_info->VideoDelayFrame = imgsensor_info.video_delay_frame;
+	sensor_info->HighSpeedVideoDelayFrame = imgsensor_info.hs_video_delay_frame;
+	sensor_info->SlimVideoDelayFrame = imgsensor_info.slim_video_delay_frame;
+
+	sensor_info->SensorMasterClockSwitch = 0; /* not use */
+	sensor_info->SensorDrivingCurrent = imgsensor_info.isp_driving_current;
+	
+	sensor_info->AEShutDelayFrame = imgsensor_info.ae_shut_delay_frame; 		 /* The frame of setting shutter default 0 for TG int */
+	sensor_info->AESensorGainDelayFrame = imgsensor_info.ae_sensor_gain_delay_frame;	/* The frame of setting sensor gain */
+	sensor_info->AEISPGainDelayFrame = imgsensor_info.ae_ispGain_delay_frame;	
+	sensor_info->IHDR_Support = imgsensor_info.ihdr_support;
+	sensor_info->IHDR_LE_FirstLine = imgsensor_info.ihdr_le_firstline;
+	sensor_info->SensorModeNum = imgsensor_info.sensor_mode_num;
+	
+	sensor_info->SensorMIPILaneNumber = imgsensor_info.mipi_lane_num; 
+	sensor_info->SensorClockFreq = imgsensor_info.mclk;
+	sensor_info->SensorClockDividCount = 3; /* not use */
+	sensor_info->SensorClockRisingCount = 0;
+	sensor_info->SensorClockFallingCount = 2; /* not use */
+	sensor_info->SensorPixelClockCount = 3; /* not use */
+	sensor_info->SensorDataLatchCount = 2; /* not use */
+	
+	sensor_info->MIPIDataLowPwr2HighSpeedTermDelayCount = 0; 
+	sensor_info->MIPICLKLowPwr2HighSpeedTermDelayCount = 0;
+	sensor_info->SensorWidthSampling = 0;  // 0 is default 1x
+	sensor_info->SensorHightSampling = 0;	// 0 is default 1x 
+	sensor_info->SensorPacketECCOrder = 1;
+
+	switch (scenario_id) {
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+			sensor_info->SensorGrabStartX = imgsensor_info.pre.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;		
+			
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
+			
+			break;
+		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+			sensor_info->SensorGrabStartX = imgsensor_info.cap.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.cap.starty;
+				  
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.cap.mipi_data_lp2hs_settle_dc; 
+
+			break;	 
+		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+			
+			sensor_info->SensorGrabStartX = imgsensor_info.normal_video.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.normal_video.starty;
+	   
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.normal_video.mipi_data_lp2hs_settle_dc; 
+
+			break;	  
+		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:			
+			sensor_info->SensorGrabStartX = imgsensor_info.hs_video.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.hs_video.starty;
+				  
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.hs_video.mipi_data_lp2hs_settle_dc; 
+
+			break;
+		case MSDK_SCENARIO_ID_SLIM_VIDEO:
+			sensor_info->SensorGrabStartX = imgsensor_info.slim_video.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.slim_video.starty;
+				  
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.slim_video.mipi_data_lp2hs_settle_dc; 
+
+			break;
+		default:			
+			sensor_info->SensorGrabStartX = imgsensor_info.pre.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;		
+			
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
+			break;
+	}
+	
+	return ERROR_NONE;
+}	/*	get_info  */
+
+
+static kal_uint32 control(MSDK_SCENARIO_ID_ENUM scenario_id, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("scenario_id = %d\n", scenario_id);
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.current_scenario_id = scenario_id;
+	spin_unlock(&imgsensor_drv_lock);
+	switch (scenario_id) {
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+			preview(image_window, sensor_config_data);
+			break;
+		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+			capture(image_window, sensor_config_data);
+			break;	
+		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:// 2
+			normal_video(image_window, sensor_config_data);
+			break;	  
+		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:// 3
+			hs_video(image_window, sensor_config_data);
+			break;
+		case MSDK_SCENARIO_ID_SLIM_VIDEO: //9
+			slim_video(image_window, sensor_config_data);
+			break;	  
+		default:
+			LOG_INF("Error ScenarioId setting");
+			preview(image_window, sensor_config_data);
+			return ERROR_INVALID_SCENARIO_ID;
+	}
+	return ERROR_NONE;
+}	/* control() */
+
+
+
+static kal_uint32 set_video_mode(UINT16 framerate)
+{
+	LOG_INF("framerate = %d\n ", framerate);
+	// SetVideoMode Function should fix framerate
+	if (framerate == 0)
+		// Dynamic frame rate
+		return ERROR_NONE;
+	
+	spin_lock(&imgsensor_drv_lock);
+	if ((framerate == 300) && (imgsensor.autoflicker_en == KAL_TRUE))
+		imgsensor.current_fps = 296;
+	else if ((framerate == 150) && (imgsensor.autoflicker_en == KAL_TRUE))
+		imgsensor.current_fps = 146;
+	else
+		imgsensor.current_fps = framerate;
+	spin_unlock(&imgsensor_drv_lock);
+	set_max_framerate(imgsensor.current_fps,1);
+
+	return ERROR_NONE;
+}
+
+static kal_uint32 set_auto_flicker_mode(kal_bool enable, UINT16 framerate)
+{
+	LOG_INF("enable = %d, framerate = %d \n", enable, framerate);
+	spin_lock(&imgsensor_drv_lock);
+	if (enable) 	  
+		imgsensor.autoflicker_en = KAL_TRUE;
+	else //Cancel Auto flick
+		imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	return ERROR_NONE;
+}
+
+
+static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 framerate) 
+{
+	kal_uint32 frame_length;
+  
+	LOG_INF("scenario_id = %d, framerate = %d\n", scenario_id, framerate);
+
+	switch (scenario_id) {
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+			frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
+			imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			//set_dummy();			
+			break;			
+		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+			if(framerate == 0)
+				return ERROR_NONE;
+			frame_length = imgsensor_info.normal_video.pclk / framerate * 10 / imgsensor_info.normal_video.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = (frame_length > imgsensor_info.normal_video.framelength) ? (frame_length - imgsensor_info.normal_video.framelength) : 0; 		
+			imgsensor.frame_length = imgsensor_info.normal_video.framelength + imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			//set_dummy();			
+			break;
+		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:		
+        	  if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {
+                frame_length = imgsensor_info.cap1.pclk / framerate * 10 / imgsensor_info.cap1.linelength;
+                spin_lock(&imgsensor_drv_lock);
+		            imgsensor.dummy_line = (frame_length > imgsensor_info.cap1.framelength) ? (frame_length - imgsensor_info.cap1.framelength) : 0;
+		            imgsensor.frame_length = imgsensor_info.cap1.framelength + imgsensor.dummy_line;
+		            imgsensor.min_frame_length = imgsensor.frame_length;
+		            spin_unlock(&imgsensor_drv_lock);
+            } else {
+        		    if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
+                    LOG_INF("Warning: current_fps %d fps is not support, so use cap's setting: %d fps!\n",framerate,imgsensor_info.cap.max_framerate/10);
+                frame_length = imgsensor_info.cap.pclk / framerate * 10 / imgsensor_info.cap.linelength;
+                spin_lock(&imgsensor_drv_lock);
+		            imgsensor.dummy_line = (frame_length > imgsensor_info.cap.framelength) ? (frame_length - imgsensor_info.cap.framelength) : 0;
+		            imgsensor.frame_length = imgsensor_info.cap.framelength + imgsensor.dummy_line;
+		            imgsensor.min_frame_length = imgsensor.frame_length;
+		            spin_unlock(&imgsensor_drv_lock);
+            }
+			//set_dummy();			
+			break;	
+		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+			frame_length = imgsensor_info.hs_video.pclk / framerate * 10 / imgsensor_info.hs_video.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = (frame_length > imgsensor_info.hs_video.framelength) ? (frame_length - imgsensor_info.hs_video.framelength) : 0;
+			imgsensor.frame_length = imgsensor_info.hs_video.framelength + imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			//set_dummy();			
+			break;
+		case MSDK_SCENARIO_ID_SLIM_VIDEO:
+			frame_length = imgsensor_info.slim_video.pclk / framerate * 10 / imgsensor_info.slim_video.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = (frame_length > imgsensor_info.slim_video.framelength) ? (frame_length - imgsensor_info.slim_video.framelength): 0;	
+			imgsensor.frame_length = imgsensor_info.slim_video.framelength + imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			//set_dummy();	
+			break;		
+		default:  //coding with  preview scenario by default
+			frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
+			imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			//set_dummy();	
+			LOG_INF("error scenario_id = %d, we use preview scenario \n", scenario_id);
+			break;
+	}	
+	return ERROR_NONE;
+}
+
+
+
+static kal_uint32 get_default_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 *framerate) 
+{
+	LOG_INF("scenario_id = %d\n", scenario_id);
+
+	switch (scenario_id) {
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+			*framerate = imgsensor_info.pre.max_framerate;
+			break;
+		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+			*framerate = imgsensor_info.normal_video.max_framerate;
+			break;
+		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+			*framerate = imgsensor_info.cap.max_framerate;
+			break;		
+		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+			*framerate = imgsensor_info.hs_video.max_framerate;
+			break;
+		case MSDK_SCENARIO_ID_SLIM_VIDEO: 
+			*framerate = imgsensor_info.slim_video.max_framerate;
+			break;
+		default:
+			break;
+	}
+
+	return ERROR_NONE;
+}
+
+static kal_uint32 set_test_pattern_mode(kal_bool enable)
+{
+	LOG_INF("enable: %d\n", enable);
+	
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.test_pattern = enable;
+	spin_unlock(&imgsensor_drv_lock);
+	
+    if(enable)
+    {
+		write_cmos_sensor(0x5000,0x16);// ; LENC off, MWB on, BPC on, WPC on
+		write_cmos_sensor(0x5E00,0x80);
+		mdelay(40);
+		
+    }
+	else
+	{
+		write_cmos_sensor(0x5000,0x96);// ; LENC on, MWB on, BPC on, WPC on
+		write_cmos_sensor(0x5E00,0x00);
+		mdelay(40);
+	}
+
+	return ERROR_NONE;
+}
+
+static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
+                             UINT8 *feature_para,UINT32 *feature_para_len)
+{
+    UINT16 *feature_return_para_16=(UINT16 *) feature_para;
+    UINT16 *feature_data_16=(UINT16 *) feature_para;
+    UINT32 *feature_return_para_32=(UINT32 *) feature_para;
+    UINT32 *feature_data_32=(UINT32 *) feature_para;
+    unsigned long long *feature_data=(unsigned long long *) feature_para;
+    unsigned long long *feature_return_para=(unsigned long long *) feature_para;
+
+    SENSOR_WINSIZE_INFO_STRUCT *wininfo;
+    MSDK_SENSOR_REG_INFO_STRUCT *sensor_reg_data=(MSDK_SENSOR_REG_INFO_STRUCT *) feature_para;
+
+    LOG_INF("feature_id = %d\n", feature_id);
+    switch (feature_id) {
+        case SENSOR_FEATURE_GET_PERIOD:
+            *feature_return_para_16++ = imgsensor.line_length;
+            *feature_return_para_16 = imgsensor.frame_length;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:
+            *feature_return_para_32 = imgsensor.pclk;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_SET_ESHUTTER:
+            set_shutter(*feature_data);
+            break;
+        case SENSOR_FEATURE_SET_NIGHTMODE:
+            night_mode((BOOL) *feature_data);
+            break;
+        case SENSOR_FEATURE_SET_GAIN:
+            set_gain((UINT16) *feature_data);
+            break;
+        case SENSOR_FEATURE_SET_FLASHLIGHT:
+            break;
+        case SENSOR_FEATURE_SET_ISP_MASTER_CLOCK_FREQ:
+            break;
+        case SENSOR_FEATURE_SET_REGISTER:
+            write_cmos_sensor(sensor_reg_data->RegAddr, sensor_reg_data->RegData);
+            break;
+        case SENSOR_FEATURE_GET_REGISTER:
+            sensor_reg_data->RegData = read_cmos_sensor(sensor_reg_data->RegAddr);
+            break;
+        case SENSOR_FEATURE_GET_LENS_DRIVER_ID:
+            // get the lens driver ID from EEPROM or just return LENS_DRIVER_ID_DO_NOT_CARE
+            // if EEPROM does not exist in camera module.
+            *feature_return_para_32=LENS_DRIVER_ID_DO_NOT_CARE;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_SET_VIDEO_MODE:
+            set_video_mode(*feature_data);
+            break;
+        case SENSOR_FEATURE_CHECK_SENSOR_ID:
+            get_imgsensor_id(feature_return_para_32);
+            break;
+        case SENSOR_FEATURE_SET_AUTO_FLICKER_MODE:
+            set_auto_flicker_mode((BOOL)*feature_data_16,*(feature_data_16+1));
+            break;
+        case SENSOR_FEATURE_SET_MAX_FRAME_RATE_BY_SCENARIO:
+            set_max_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data, *(feature_data+1));
+            break;
+        case SENSOR_FEATURE_GET_DEFAULT_FRAME_RATE_BY_SCENARIO:
+            get_default_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*(feature_data), (MUINT32 *)(uintptr_t)(*(feature_data+1)));
+            break;
+        case SENSOR_FEATURE_SET_TEST_PATTERN:
+            set_test_pattern_mode((BOOL)*feature_data);
+            break;
+        case SENSOR_FEATURE_GET_TEST_PATTERN_CHECKSUM_VALUE: //for factory mode auto testing
+            *feature_return_para_32 = imgsensor_info.checksum_value;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_SET_FRAMERATE:
+            LOG_INF("current fps :%d\n", (UINT32)*feature_data);
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.current_fps = *feature_data;
+            spin_unlock(&imgsensor_drv_lock);
+            break;
+        case SENSOR_FEATURE_SET_HDR:
+            LOG_INF("ihdr enable :%d\n", (BOOL)*feature_data);
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.ihdr_en = (BOOL)*feature_data;
+            spin_unlock(&imgsensor_drv_lock);
+            break;
+        case SENSOR_FEATURE_GET_CROP_INFO:
+            LOG_INF("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n", (UINT32)*feature_data);
+
+            wininfo = (SENSOR_WINSIZE_INFO_STRUCT *)(uintptr_t)(*(feature_data+1));
+
+            switch (*feature_data_32) {
+                case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[1],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[2],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[3],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_SLIM_VIDEO:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[4],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+                default:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[0],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+            }
+        case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
+            LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",(UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
+            ihdr_write_shutter_gain((UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
+            break;
+        default:
+            break;
+    }
+
+    return ERROR_NONE;
+}    /*    feature_control()  */
+
+
+static SENSOR_FUNCTION_STRUCT sensor_func = {
+	open,
+	get_info,
+	get_resolution,
+	feature_control,
+	control,
+	close
+};
+
+UINT32 OV8865_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
+{
+	/* To Do : Check Sensor status here */
+	if (pfFunc!=NULL)
+		*pfFunc=&sensor_func;
+	return ERROR_NONE;
+}	/*	OV8865_MIPI_RAW_SensorInit	*/
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/ov8865_mipi_raw/ov8865mipiraw_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735/ov8865_mipi_raw/ov8865mipiraw_Sensor.h
new file mode 100644
index 0000000..57aac7a
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735/ov8865_mipi_raw/ov8865mipiraw_Sensor.h
@@ -0,0 +1,119 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *	 ov8865mipi_Sensor.h
+ *
+ * Project:
+ * --------
+ *	 ALPS
+ *
+ * Description:
+ * ------------
+ *	 CMOS sensor header file
+ *
+ ****************************************************************************/
+#ifndef _OV8865MIPI_SENSOR_H
+#define _OV8865MIPI_SENSOR_H
+
+
+typedef enum{
+	IMGSENSOR_MODE_INIT,
+	IMGSENSOR_MODE_PREVIEW,
+	IMGSENSOR_MODE_CAPTURE,
+	IMGSENSOR_MODE_VIDEO,
+	IMGSENSOR_MODE_HIGH_SPEED_VIDEO,
+	IMGSENSOR_MODE_SLIM_VIDEO,
+} IMGSENSOR_MODE;
+
+typedef struct imgsensor_mode_struct {
+	kal_uint32 pclk;				//record different mode's pclk
+	kal_uint32 linelength;			//record different mode's linelength
+	kal_uint32 framelength;			//record different mode's framelength
+
+	kal_uint8 startx;				//record different mode's startx of grabwindow
+	kal_uint8 starty;				//record different mode's startx of grabwindow
+
+	kal_uint16 grabwindow_width;	//record different mode's width of grabwindow
+	kal_uint16 grabwindow_height;	//record different mode's height of grabwindow
+
+	/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
+	kal_uint8 mipi_data_lp2hs_settle_dc;
+
+	/*	 following for GetDefaultFramerateByScenario()	*/
+	kal_uint16 max_framerate;
+	
+} imgsensor_mode_struct;
+
+/* SENSOR PRIVATE STRUCT FOR VARIABLES*/
+typedef struct imgsensor_struct {
+	kal_uint8 mirror;				//mirrorflip information
+
+	kal_uint8 sensor_mode;			//record IMGSENSOR_MODE enum value
+
+	kal_uint32 shutter;				//current shutter
+	kal_uint16 gain;				//current gain
+	
+	kal_uint32 pclk;				//current pclk
+
+	kal_uint32 frame_length;		//current framelength
+	kal_uint32 line_length;			//current linelength
+
+	kal_uint32 min_frame_length;	//current min  framelength to max framerate
+	kal_uint16 dummy_pixel;			//current dummypixel
+	kal_uint16 dummy_line;			//current dummline
+	
+	kal_uint16 current_fps;			//current max fps
+	kal_bool   autoflicker_en;		//record autoflicker enable or disable
+	kal_bool test_pattern;			//record test pattern mode or not
+	MSDK_SCENARIO_ID_ENUM current_scenario_id;//current scenario id
+	kal_uint8  ihdr_en;				//ihdr enable or disable
+	
+	kal_uint8 i2c_write_id;			//record current sensor's i2c write id
+} imgsensor_struct;
+
+/* SENSOR PRIVATE STRUCT FOR CONSTANT*/
+typedef struct imgsensor_info_struct { 
+	kal_uint16 sensor_id;			//record sensor id defined in Kd_imgsensor.h
+	kal_uint32 checksum_value;		//checksum value for Camera Auto Test
+	imgsensor_mode_struct pre;		//preview scenario relative information
+	imgsensor_mode_struct cap;		//capture scenario relative information
+	imgsensor_mode_struct cap1;		//capture for PIP 24fps relative information
+	imgsensor_mode_struct normal_video;//normal video  scenario relative information
+	imgsensor_mode_struct hs_video;	//high speed video scenario relative information
+	imgsensor_mode_struct slim_video;	//slim video for VT scenario relative information
+	
+	kal_uint8  ae_shut_delay_frame;	//shutter delay frame for AE cycle
+	kal_uint8  ae_sensor_gain_delay_frame;	//sensor gain delay frame for AE cycle
+	kal_uint8  ae_ispGain_delay_frame;	//isp gain delay frame for AE cycle
+	kal_uint8  ihdr_support;		//1, support; 0,not support
+	kal_uint8  ihdr_le_firstline;	//1,le first ; 0, se first
+	kal_uint8  sensor_mode_num;		//support sensor mode num
+	
+	kal_uint8  cap_delay_frame;		//enter capture delay frame num
+	kal_uint8  pre_delay_frame;		//enter preview delay frame num
+	kal_uint8  video_delay_frame;	//enter video delay frame num
+	kal_uint8  hs_video_delay_frame;	//enter high speed video  delay frame num
+	kal_uint8  slim_video_delay_frame;	//enter slim video delay frame num
+  
+	kal_uint8  margin;				//sensor framelength & shutter margin 
+	kal_uint32 min_shutter;			//min shutter
+	kal_uint32 max_frame_length;	//max framelength by sensor register's limitation
+
+	kal_uint8  isp_driving_current;	//mclk driving current
+	kal_uint8  sensor_interface_type;//sensor_interface_type
+	kal_uint8  mipi_sensor_type; //0,MIPI_OPHY_NCSI2; 1,MIPI_OPHY_CSI2, default is NCSI2, don't modify this para
+	kal_uint8  mipi_settle_delay_mode; //0, high speed signal auto detect; 1, use settle delay,unit is ns, default is auto detect, don't modify this para
+	kal_uint8  sensor_output_dataformat;
+	kal_uint8  mclk;				//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
+	
+	kal_uint8  mipi_lane_num;		//mipi lane num
+	kal_uint8  i2c_addr_table[5];	//record sensor support all write id addr, only supprt 4must end with 0xff
+} imgsensor_info_struct;
+
+
+extern int iReadRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u8 * a_pRecvData, u16 a_sizeRecvData, u16 i2cId);
+extern int iWriteRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u16 i2cId);
+
+#endif 
+
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/-sp2508_mipi_raw/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6735m/-sp2508_mipi_raw/Makefile
new file mode 100755
index 0000000..27db1df
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/-sp2508_mipi_raw/Makefile
@@ -0,0 +1,4 @@
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+obj-y += sp2508mipi_Sensor.o
+
+
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/-sp2508_mipi_raw/sp2508mipi_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/-sp2508_mipi_raw/sp2508mipi_Sensor.c
new file mode 100644
index 0000000..40610e0
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/-sp2508_mipi_raw/sp2508mipi_Sensor.c
@@ -0,0 +1,1300 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *     sp2508mipi_Sensor.c
+ *
+ * Project:
+ * --------
+ *     ALPS
+ *
+ * Description:
+ * ------------
+ *     Source code of Sensor driver
+ *
+ *
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *============================================================================
+ ****************************************************************************/
+
+#include <linux/videodev2.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <asm/atomic.h>
+//#include <asm/system.h>
+#include <linux/xlog.h>
+
+#include "kd_camera_hw.h"
+#include "kd_imgsensor.h"
+#include "kd_imgsensor_define.h"
+#include "kd_imgsensor_errcode.h"
+
+#include "sp2508mipi_Sensor.h"
+
+/****************************Modify Following Strings for Debug****************************/
+#define PFX "SP2508_camera_sensor"
+#define LOG_1 LOG_INF("SP2508,MIPI 2LANE\n")
+#define LOG_2 LOG_INF("preview 1280*960@30fps,420Mbps/lane; video 1280*960@30fps,420Mbps/lane; capture 5M@15fps,420Mbps/lane\n")
+/****************************   Modify end    *******************************************/
+
+#define LOG_INF(format, args...)    xlog_printk(ANDROID_LOG_INFO   , PFX, "[%s] " format, __FUNCTION__, ##args)
+
+static DEFINE_SPINLOCK(imgsensor_drv_lock);
+
+
+static imgsensor_info_struct imgsensor_info = {
+    .sensor_id = SP2508MIPI_SENSOR_ID,
+    
+    .checksum_value = 0xf7375923,        //checksum value for Camera Auto Test
+    
+    .pre = {
+        .pclk = 42000000,              //record different mode's pclk
+        .linelength = 1772,             //record different mode's linelength
+        .framelength = 1970,            //record different mode's framelength
+        .startx = 2,                    //record different mode's startx of grabwindow
+        .starty = 2,                    //record different mode's starty of grabwindow
+        .grabwindow_width = 2592,//2096,		//record different mode's width of grabwindow
+        .grabwindow_height = 1944,//1552,		//record different mode's height of grabwindow
+        /*     following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario    */
+        .mipi_data_lp2hs_settle_dc = 85,//unit , ns
+        /*     following for GetDefaultFramerateByScenario()    */
+        .max_framerate = 300,
+    },
+    .cap = {
+        .pclk = 42000000,
+        .linelength = 1772,
+        .framelength = 1970,
+        .startx = 4,
+        .starty = 4,
+        .grabwindow_width = 2592,//4192,
+        .grabwindow_height = 1944,//3104,
+        .mipi_data_lp2hs_settle_dc = 85,//unit , ns
+        .max_framerate = 300,
+    },
+    .cap1 = {
+        .pclk = 42000000,
+        .linelength = 1772,
+        .framelength = 1970,
+        .startx = 2,
+        .starty = 2,
+        .grabwindow_width = 2592,//4192,
+        .grabwindow_height = 1944,//3104,
+        .mipi_data_lp2hs_settle_dc = 85,//unit , ns
+        .max_framerate = 300,
+    },
+    .normal_video = {
+        .pclk = 42000000,
+        .linelength = 1772,
+        .framelength = 1970,
+        .startx = 2,
+        .starty = 2,
+        .grabwindow_width = 2592,//4192,
+        .grabwindow_height = 1944,//3104,
+        .mipi_data_lp2hs_settle_dc = 85,//unit , ns
+        .max_framerate = 300,
+    },
+    .hs_video = {
+        .pclk = 42000000,
+        .linelength = 1772,
+        .framelength = 1970,
+        .startx = 2,
+        .starty = 2,
+        .grabwindow_width = 1280,
+        .grabwindow_height = 720,
+        .mipi_data_lp2hs_settle_dc = 85,//unit , ns
+        .max_framerate = 300,
+    },
+    .slim_video = {
+        .pclk = 42000000,
+        .linelength = 1772,
+        .framelength = 1970,
+        .startx = 2,
+        .starty = 2,
+        .grabwindow_width = 2592,
+        .grabwindow_height = 1944,
+        .mipi_data_lp2hs_settle_dc = 85,//unit , ns
+        .max_framerate = 300,
+    },
+    .margin = 0,
+    .min_shutter = 1,        //min shutter
+    .max_frame_length = 0x7fff,//max framelength by sensor register's limitation
+    .ae_shut_delay_frame = 0,    //shutter delay frame for AE cycle, 2 frame with ispGain_delay-shut_delay=2-0=2
+    .ae_sensor_gain_delay_frame = 0,//sensor gain delay frame for AE cycle,2 frame with ispGain_delay-sensor_gain_delay=2-0=2
+    .ae_ispGain_delay_frame = 2,//isp gain delay frame for AE cycle
+    .ihdr_support = 0, //     //1, support; 0,not support
+    .ihdr_le_firstline = 0,//  //1,le first ; 0, se first
+    .sensor_mode_num = 5,      //support sensor mode num
+    
+    .cap_delay_frame = 2,
+    .pre_delay_frame = 2,
+    .video_delay_frame = 2,
+    .hs_video_delay_frame = 2,
+    .slim_video_delay_frame = 2,
+    
+    .isp_driving_current = ISP_DRIVING_2MA, //mclk driving current
+    .sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,//sensor_interface_type
+    .mipi_sensor_type = MIPI_OPHY_NCSI2, //0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2
+    .mipi_settle_delay_mode = MIPI_SETTLEDELAY_AUTO,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
+    .sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_B,//sensor output first pixel color
+    .mclk = 24,//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
+    .mipi_lane_num = SENSOR_MIPI_2_LANE,//mipi lane num
+    .i2c_addr_table = {0x78, 0xff},
+    .i2c_speed = 200,
+};
+
+
+static imgsensor_struct imgsensor = {
+    .mirror = IMAGE_NORMAL,                //mirrorflip information
+    .sensor_mode = IMGSENSOR_MODE_INIT, //IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
+    .shutter = 0x3D0,                    //current shutter
+    .gain = 0x100,                        //current gain
+    .dummy_pixel = 0,                    //current dummypixel
+    .dummy_line = 0,                    //current dummyline
+    .current_fps = 300,  //full size current fps : 24fps for PIP, 30fps for Normal or ZSD
+    .autoflicker_en = KAL_FALSE,  //auto flicker enable: KAL_FALSE for disable auto flicker, KAL_TRUE for enable auto flicker
+    .test_pattern = KAL_FALSE,        //test pattern mode or not. KAL_FALSE for in test pattern mode, KAL_TRUE for normal output
+    .current_scenario_id = MSDK_SCENARIO_ID_CAMERA_PREVIEW,//current scenario id
+    .ihdr_en = 0, //sensor need support LE, SE with HDR feature
+    .i2c_write_id = 0x78,//record current sensor's i2c write id
+};
+
+
+/* Sensor output window information */
+static SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[5]=
+{{ 1616, 1216, 1000, 1000, 2592, 1944, 2592, 1944, 0000, 0000, 2592, 1944, 0000, 0000, 2592, 1944}, // Preview 2112*1558
+    { 1616, 1216, 1000, 1000, 2592, 1944, 2592, 1944, 0000, 0000, 2592, 1944, 0000, 0000, 2592, 1944}, // capture 4206*3128
+    { 1616, 1216, 1000, 1000, 2592, 1944, 2592, 1944, 0000, 0000, 2592, 1944, 0000, 0000, 2592, 1944}, // video
+    { 1616, 1216, 1000, 1000, 2592, 1944, 2592, 1944, 0000, 0000, 2592, 1944, 0000, 0000, 1280, 720}, //hight speed video
+    { 1616, 1216, 1000, 1000, 2592, 1944, 2592, 1944, 0000, 0000, 2592, 1944, 0000, 0000, 2592, 1944},// slim video
+}; // slim video
+
+
+static kal_uint16 read_cmos_sensor(kal_uint32 addr)
+{
+    kal_uint16 get_byte=0;
+    char pu_send_cmd[1] = {(char)(addr & 0xFF) };
+    
+    kdSetI2CSpeed(imgsensor_info.i2c_speed); // Add this func to set i2c speed by each sensor
+    
+    iReadRegI2C(pu_send_cmd, 1, (u8*)&get_byte, 1, imgsensor.i2c_write_id);
+    
+    return get_byte;
+}
+
+static void write_cmos_sensor(kal_uint32 addr, kal_uint32 para)
+{
+    char pu_send_cmd[2] = {(char)(addr & 0xFF), (char)(para & 0xFF)};
+    
+    kdSetI2CSpeed(imgsensor_info.i2c_speed); // Add this func to set i2c speed by each sensor
+    
+    iWriteRegI2C(pu_send_cmd, 2, imgsensor.i2c_write_id);
+}
+
+static void set_dummy(void)
+{
+    LOG_INF("dummyline = %d, dummypixels = %d \n", imgsensor.dummy_line, imgsensor.dummy_pixel);
+    /* you can set dummy by imgsensor.dummy_line and imgsensor.dummy_pixel, or you can set dummy by imgsensor.frame_length and imgsensor.line_length */
+#if 0
+    write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
+    write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
+    write_cmos_sensor(0x380c, imgsensor.line_length >> 8);
+    write_cmos_sensor(0x380d, imgsensor.line_length & 0xFF);
+#endif
+    
+}    /*    set_dummy  */
+
+static kal_uint32 return_sensor_id(void)
+{
+    write_cmos_sensor(0xfd, 0x00);
+    return ((read_cmos_sensor(0x02) << 8) | read_cmos_sensor(0x03));
+}
+static void set_max_framerate(UINT16 framerate,kal_bool min_framelength_en)
+{
+    kal_uint32 frame_length = imgsensor.frame_length;
+    
+    LOG_INF("framerate = %d, min framelength should enable? \n", framerate,min_framelength_en);
+    
+    frame_length = imgsensor.pclk / framerate * 10 / imgsensor.line_length;
+    
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.frame_length = (frame_length > imgsensor.min_frame_length) ? frame_length : imgsensor.min_frame_length;
+    imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
+    //dummy_line = frame_length - imgsensor.min_frame_length;
+    //if (dummy_line < 0)
+    //imgsensor.dummy_line = 0;
+    //else
+    //imgsensor.dummy_line = dummy_line;
+    //imgsensor.frame_length = frame_length + imgsensor.dummy_line;
+    if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+    {
+        imgsensor.frame_length = imgsensor_info.max_frame_length;
+        imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
+    }
+    if (min_framelength_en)
+        imgsensor.min_frame_length = imgsensor.frame_length;
+    spin_unlock(&imgsensor_drv_lock);
+    
+    set_dummy();
+}    /*    set_max_framerate  */
+
+static void write_shutter(kal_uint16 shutter)
+{
+#if 0
+    kal_uint16 realtime_fps = 0;
+    
+    /* 0x3500, 0x3501, 0x3502 will increase VBLANK to get exposure larger than frame exposure */
+    /* AE doesn't update sensor gain at capture mode, thus extra exposure lines must be updated here. */
+    
+    // OV Recommend Solution
+    // if shutter bigger than frame_length, should extend frame length first
+    spin_lock(&imgsensor_drv_lock);
+    if (shutter > imgsensor.min_frame_length - imgsensor_info.margin)
+        imgsensor.frame_length = shutter + imgsensor_info.margin;
+    else
+        imgsensor.frame_length = imgsensor.min_frame_length;
+    if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+        imgsensor.frame_length = imgsensor_info.max_frame_length;
+    spin_unlock(&imgsensor_drv_lock);
+    shutter = (shutter < imgsensor_info.min_shutter) ? imgsensor_info.min_shutter : shutter;
+    shutter = (shutter > (imgsensor_info.max_frame_length - imgsensor_info.margin)) ? (imgsensor_info.max_frame_length - imgsensor_info.margin) : shutter;
+    
+    // Framelength should be an even number
+    shutter = (shutter >> 1) << 1;
+    imgsensor.frame_length = (imgsensor.frame_length >> 1) << 1;
+    
+    if (imgsensor.autoflicker_en) {
+        realtime_fps = imgsensor.pclk / imgsensor.line_length * 10 / imgsensor.frame_length;
+        
+        if(realtime_fps >= 297 && realtime_fps <= 305)
+            set_max_framerate(296,0);
+        else if(realtime_fps >= 147 && realtime_fps <= 150)
+            set_max_framerate(146,0);
+        else {
+            // Extend frame length
+        }
+    } else {
+        // Extend frame length
+    }
+#endif
+    write_cmos_sensor(0xfd, 0x01);
+    write_cmos_sensor(0x03, (shutter >> 8) & 0xFF);
+    write_cmos_sensor(0x04, shutter  & 0xFF);
+    write_cmos_sensor(0x01, 0x01);
+    LOG_INF("shutter =%d, framelength =%d\n", shutter, imgsensor.frame_length);
+}
+
+
+/*************************************************************************
+* FUNCTION
+*    set_shutter
+*
+* DESCRIPTION
+*    This function set e-shutter of sensor to change exposure time.
+*
+* PARAMETERS
+*    iShutter : exposured lines
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static void set_shutter(kal_uint16 shutter)
+{
+    unsigned long flags;
+    spin_lock_irqsave(&imgsensor_drv_lock, flags);
+    imgsensor.shutter = shutter;
+    spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
+
+    write_shutter(shutter);
+}
+
+static kal_uint16 gain2reg(const kal_uint16 gain)
+{
+#if 0
+    kal_uint16 reg_gain = 0x0000;
+    
+    reg_gain = ((gain / BASEGAIN) << 4) + ((gain % BASEGAIN) * 16 / BASEGAIN);
+    reg_gain = reg_gain & 0xFFFF;
+    
+    return (kal_uint16)reg_gain;
+#endif
+}
+
+/*************************************************************************
+* FUNCTION
+*    set_gain
+*
+* DESCRIPTION
+*    This function is to set global gain to sensor.
+*
+* PARAMETERS
+*    iGain : sensor global gain(base: 0x40)
+*
+* RETURNS
+*    the actually gain set to sensor.
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint16 set_gain(kal_uint16 gain)
+{
+    kal_uint16 reg_gain;
+    
+    /* 0x350A[0:1], 0x350B[0:7] AGC real gain */
+    /* [0:3] = N meams N /16 X    */
+    /* [4:9] = M meams M X         */
+    /* Total gain = M + N /16 X   */
+    
+    //
+    if(gain >= BASEGAIN && gain <= 15*BASEGAIN)
+    {
+        reg_gain = 0x10 * gain/BASEGAIN ;        //change mtk gain base to aptina gain base
+        
+        if(reg_gain<=0x10)
+        {
+            write_cmos_sensor(0xfd, 0x01);
+            write_cmos_sensor(0x24, 0x10);//0x23
+            write_cmos_sensor(0x01, 0x01);
+            LOG_INF("SP2508 reg_gain =%d, SP2508MIPI Gain = %d", reg_gain, gain);
+        }
+        else if(reg_gain>= 0x70)
+        {
+            write_cmos_sensor(0xfd, 0x01);
+            write_cmos_sensor(0x24,0x70);
+            write_cmos_sensor(0x01, 0x01);
+            LOG_INF("SP2508MIPI reg_gain =%d, SP2508MIPI Gain = %d",  reg_gain, gain);
+        }
+        else
+        {
+            write_cmos_sensor(0xfd, 0x01);
+            write_cmos_sensor(0x24, (kal_uint8)reg_gain);
+            write_cmos_sensor(0x01, 0x01);
+	       }
+    }
+    else
+        LOG_INF("error gain setting");
+    
+    return gain;
+}    /*    set_gain  */
+
+static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gain)
+{
+    //not support HDR
+    //LOG_INF("le:0x%x, se:0x%x, gain:0x%x\n",le,se,gain);
+}
+/*************************************************************************
+* FUNCTION
+*    night_mode
+*
+* DESCRIPTION
+*    This function night mode of sensor.
+*
+* PARAMETERS
+*    bEnable: KAL_TRUE -> enable night mode, otherwise, disable night mode
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static void night_mode(kal_bool enable)
+{
+/*No Need to implement this function*/
+}    /*    night_mode    */
+
+static void sensor_init(void)
+{
+    {
+        LOG_INF("E\n");
+        //@@ global setting
+        //updated by xingdy,20141204
+        //soft reset, 0x51=0x10,0x52=3a;0x53=0x10
+        //hblank=0x110,0x72=0x54,rst_num=0x30
+        //T_horizontal=1079,1base=h'129, 15fps
+        //adc_range reduce to 515mv
+        //shutdown pcp rowsel,pcp clk 24M
+        write_cmos_sensor(0xfd,0x00);
+        write_cmos_sensor(0x1b,0x00);
+        write_cmos_sensor(0x2f,0x10);
+        write_cmos_sensor(0x30,0x15);
+        write_cmos_sensor(0x33,0x05);
+        write_cmos_sensor(0x34,0x00);
+        write_cmos_sensor(0xfd,0x01);//vblank
+        write_cmos_sensor(0x06,0x01);
+        write_cmos_sensor(0x03,0x00);
+        write_cmos_sensor(0x04,0xed);
+        write_cmos_sensor(0x09,0x01);
+        write_cmos_sensor(0x0a,0xb5);
+        write_cmos_sensor(0x24,0x70);
+        write_cmos_sensor(0x01,0x01);
+        write_cmos_sensor(0x20,0x3d);
+        write_cmos_sensor(0x21,0x37);
+        write_cmos_sensor(0x25,0xf4);
+        write_cmos_sensor(0x26,0x0c);
+        write_cmos_sensor(0x2a,0x12);
+        write_cmos_sensor(0x2c,0xa0);
+        write_cmos_sensor(0x8a,0x55);
+        write_cmos_sensor(0x8b,0x55);
+        write_cmos_sensor(0x58,0x3a);
+        write_cmos_sensor(0x75,0x58);
+        write_cmos_sensor(0x77,0x6f);
+        write_cmos_sensor(0x78,0xef);
+        write_cmos_sensor(0x84,0x0f);
+        write_cmos_sensor(0x85,0x02);
+        write_cmos_sensor(0xd0,0x01);
+        write_cmos_sensor(0xd1,0x02);
+        write_cmos_sensor(0xd2,0x00);
+        write_cmos_sensor(0xd3,0x02);
+        write_cmos_sensor(0xd4,0x80);
+        write_cmos_sensor(0x11,0x40);
+        write_cmos_sensor(0x51,0x15);
+        write_cmos_sensor(0x52,0x3a);
+        write_cmos_sensor(0x53,0x15);
+        write_cmos_sensor(0x5d,0x00);
+        write_cmos_sensor(0x5e,0x00);
+        write_cmos_sensor(0x66,0x5c); //blacklevel enable
+        write_cmos_sensor(0x68,0x62);
+        write_cmos_sensor(0x72,0x74);
+        write_cmos_sensor(0x7b,0x01);
+        write_cmos_sensor(0x7c,0x10);
+        write_cmos_sensor(0xfb,0x35);
+        write_cmos_sensor(0xfa,0x10);
+        write_cmos_sensor(0xfe,0x10);
+        write_cmos_sensor(0x87,0x08);
+        write_cmos_sensor(0x89,0x10);
+        write_cmos_sensor(0xf0,0x00);
+        write_cmos_sensor(0xf1,0x00);
+        write_cmos_sensor(0xf2,0x00);
+        write_cmos_sensor(0xf3,0x00);
+        write_cmos_sensor(0xfd,0x02);//0x25
+        write_cmos_sensor(0x00,0x8c);
+        write_cmos_sensor(0x01,0x8c);
+        write_cmos_sensor(0x02,0x8c);
+        write_cmos_sensor(0x03,0x8c);
+        write_cmos_sensor(0xfd,0x01);
+        write_cmos_sensor(0xb3,0x00);
+        write_cmos_sensor(0xb1,0x01);
+        write_cmos_sensor(0xa4,0x6d);
+        write_cmos_sensor(0xb6,0xc0);  
+        write_cmos_sensor(0x9d,0x65);
+        write_cmos_sensor(0x97,0x08);
+        write_cmos_sensor(0xc4,0x28); 
+        write_cmos_sensor(0xc1,0x09);   
+    }              
+    
+}    /*    MIPI_sensor_Init  */
+
+
+static void preview_setting(void)
+{
+    /********************************************************
+     *
+     *   1296x972 30fps 2 lane MIPI 420Mbps/lane
+     *
+     ********************************************************/
+    
+    
+}    /*    preview_setting  */
+
+
+static void capture_setting(kal_uint16 currefps)
+{
+    LOG_INF("E! currefps:%d\n", currefps);
+    
+    /********************************************************
+     *
+     *   2592x1944 15fps 2 lane MIPI 420Mbps/lane
+     *
+     ********************************************************/
+    
+    
+}    /*    capture_setting  */
+
+static void normal_video_setting(kal_uint16 currefps)
+{
+    LOG_INF("E! currefps:%d\n", currefps);
+    
+    /********************************************************
+     *
+     *   1296x972 30fps 2 lane MIPI 420Mbps/lane
+     *
+     ********************************************************/
+    
+    
+}    /*    preview_setting  */
+
+
+static void video_1080p_setting(void)
+{
+    
+    /********************************************************
+     *
+     *   1080p 30fps 2 lane MIPI 420Mbps/lane
+     *    @@1080p
+     *    ;;pclk=84M,HTS=2500,VTS=1120
+     ********************************************************/
+    
+    
+    
+}    /*    preview_setting  */
+
+static void video_720p_setting(void)
+{
+    /********************************************************
+     *
+     *   720p 30fps 2 lane MIPI 420Mbps/lane
+     *    @@720p_30fps
+     *     ;;pclk=84M,HTS=3728,VTS=748
+     ********************************************************/
+    
+    
+    
+    LOG_INF("Exit!");
+}    /*    preview_setting  */
+
+
+static void hs_video_setting(void)
+{
+    LOG_INF("E\n");
+
+    video_1080p_setting();
+}
+
+static void slim_video_setting(void)
+{
+    LOG_INF("E\n");
+
+    video_720p_setting();
+}
+
+/*************************************************************************
+* FUNCTION
+*    get_imgsensor_id
+*
+* DESCRIPTION
+*    This function get the sensor ID
+*
+* PARAMETERS
+*    *sensorID : return the sensor ID
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 get_imgsensor_id(UINT32 *sensor_id)
+{
+    kal_uint8 i = 0;
+    kal_uint8 retry = 2;
+    //sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
+    while (imgsensor_info.i2c_addr_table[i] != 0xff) {
+        spin_lock(&imgsensor_drv_lock);
+        imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
+        spin_unlock(&imgsensor_drv_lock);
+        do {
+            *sensor_id = return_sensor_id();
+            if (*sensor_id == imgsensor_info.sensor_id) {
+                LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
+                return ERROR_NONE;
+            }
+            LOG_INF("Read sensor id fail, id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
+            retry--;
+        } while(retry > 0);
+        i++;
+        retry = 2;
+    }
+    if (*sensor_id != imgsensor_info.sensor_id) {
+        // if Sensor ID is not correct, Must set *sensor_id to 0xFFFFFFFF
+        *sensor_id = 0xFFFFFFFF;
+        return ERROR_SENSOR_CONNECT_FAIL;
+    }
+    return ERROR_NONE;
+}
+
+
+/*************************************************************************
+* FUNCTION
+*    open
+*
+* DESCRIPTION
+*    This function initialize the registers of CMOS sensor
+*
+* PARAMETERS
+*    None
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 open(void)
+{
+    kal_uint8 i = 0;
+    kal_uint8 retry = 2;
+    kal_uint32 sensor_id = 0;
+    LOG_1;
+    LOG_2;
+
+    //sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
+    while (imgsensor_info.i2c_addr_table[i] != 0xff) {
+        spin_lock(&imgsensor_drv_lock);
+        imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
+        spin_unlock(&imgsensor_drv_lock);
+        do {
+            sensor_id = return_sensor_id();
+            if (sensor_id == imgsensor_info.sensor_id) {
+                LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
+                break;
+            }
+            LOG_INF("Read sensor id fail, id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
+            retry--;
+        } while(retry > 0);
+        i++;
+        if (sensor_id == imgsensor_info.sensor_id)
+            break;
+        retry = 2;
+    }
+    if (imgsensor_info.sensor_id != sensor_id)
+        return ERROR_SENSOR_CONNECT_FAIL;
+
+    /* initail sequence write in  */
+    sensor_init();
+
+    spin_lock(&imgsensor_drv_lock);
+
+    imgsensor.autoflicker_en= KAL_FALSE;
+    imgsensor.sensor_mode = IMGSENSOR_MODE_INIT;
+    imgsensor.pclk = imgsensor_info.pre.pclk;
+    imgsensor.frame_length = imgsensor_info.pre.framelength;
+    imgsensor.line_length = imgsensor_info.pre.linelength;
+    imgsensor.min_frame_length = imgsensor_info.pre.framelength;
+    imgsensor.dummy_pixel = 0;
+    imgsensor.dummy_line = 0;
+    imgsensor.ihdr_en = 0;
+    imgsensor.test_pattern = KAL_FALSE;
+    imgsensor.current_fps = imgsensor_info.pre.max_framerate;
+    spin_unlock(&imgsensor_drv_lock);
+
+    return ERROR_NONE;
+}    /*    open  */
+
+
+
+/*************************************************************************
+* FUNCTION
+*    close
+*
+* DESCRIPTION
+*
+*
+* PARAMETERS
+*    None
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 close(void)
+{
+    LOG_INF("E\n");
+
+    /*No Need to implement this function*/
+
+    return ERROR_NONE;
+}    /*    close  */
+
+
+/*************************************************************************
+* FUNCTION
+* preview
+*
+* DESCRIPTION
+*    This function start the sensor preview.
+*
+* PARAMETERS
+*    *image_window : address pointer of pixel numbers in one period of HSYNC
+*  *sensor_config_data : address pointer of line numbers in one period of VSYNC
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_PREVIEW;
+    imgsensor.pclk = imgsensor_info.pre.pclk;
+    //imgsensor.video_mode = KAL_FALSE;
+    imgsensor.line_length = imgsensor_info.pre.linelength;
+    imgsensor.frame_length = imgsensor_info.pre.framelength;
+    imgsensor.min_frame_length = imgsensor_info.pre.framelength;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    preview_setting();
+    //set_mirror_flip(sensor_config_data->SensorImageMirror);
+    return ERROR_NONE;
+}    /*    preview   */
+
+/*************************************************************************
+* FUNCTION
+*    capture
+*
+* DESCRIPTION
+*    This function setup the CMOS sensor in capture MY_OUTPUT mode
+*
+* PARAMETERS
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                          MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_CAPTURE;
+    if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {//PIP capture: 24fps for less than 13M, 20fps for 16M,15fps for 20M
+        imgsensor.pclk = imgsensor_info.cap1.pclk;
+        imgsensor.line_length = imgsensor_info.cap1.linelength;
+        imgsensor.frame_length = imgsensor_info.cap1.framelength;
+        imgsensor.min_frame_length = imgsensor_info.cap1.framelength;
+        imgsensor.autoflicker_en = KAL_FALSE;
+    } else {
+        if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
+            LOG_INF("Warning: current_fps %d fps is not support, so use cap1's setting: %d fps!\n",imgsensor_info.cap1.max_framerate/10);
+        imgsensor.pclk = imgsensor_info.cap.pclk;
+        imgsensor.line_length = imgsensor_info.cap.linelength;
+        imgsensor.frame_length = imgsensor_info.cap.framelength;
+        imgsensor.min_frame_length = imgsensor_info.cap.framelength;
+        imgsensor.autoflicker_en = KAL_FALSE;
+    }
+    spin_unlock(&imgsensor_drv_lock);
+    capture_setting(imgsensor.current_fps);
+    //set_mirror_flip(sensor_config_data->SensorImageMirror);
+    return ERROR_NONE;
+}    /* capture() */
+static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_VIDEO;
+    imgsensor.pclk = imgsensor_info.normal_video.pclk;
+    imgsensor.line_length = imgsensor_info.normal_video.linelength;
+    imgsensor.frame_length = imgsensor_info.normal_video.framelength;
+    imgsensor.min_frame_length = imgsensor_info.normal_video.framelength;
+    //imgsensor.current_fps = 300;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    normal_video_setting(imgsensor.current_fps);
+    //set_mirror_flip(sensor_config_data->SensorImageMirror);
+    return ERROR_NONE;
+}    /*    normal_video   */
+
+static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+    
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_HIGH_SPEED_VIDEO;
+    imgsensor.pclk = imgsensor_info.hs_video.pclk;
+    //imgsensor.video_mode = KAL_TRUE;
+    imgsensor.line_length = imgsensor_info.hs_video.linelength;
+    imgsensor.frame_length = imgsensor_info.hs_video.framelength;
+    imgsensor.min_frame_length = imgsensor_info.hs_video.framelength;
+    imgsensor.dummy_line = 0;
+    imgsensor.dummy_pixel = 0;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    hs_video_setting();
+    //set_mirror_flip(sensor_config_data->SensorImageMirror);
+    return ERROR_NONE;
+}    /*    hs_video   */
+
+static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+    
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_SLIM_VIDEO;
+    imgsensor.pclk = imgsensor_info.slim_video.pclk;
+    imgsensor.line_length = imgsensor_info.slim_video.linelength;
+    imgsensor.frame_length = imgsensor_info.slim_video.framelength;
+    imgsensor.min_frame_length = imgsensor_info.slim_video.framelength;
+    imgsensor.dummy_line = 0;
+    imgsensor.dummy_pixel = 0;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    slim_video_setting();
+    //set_mirror_flip(sensor_config_data->SensorImageMirror);
+    
+    return ERROR_NONE;
+}    /*    slim_video     */
+
+
+
+static kal_uint32 get_resolution(MSDK_SENSOR_RESOLUTION_INFO_STRUCT *sensor_resolution)
+{
+    LOG_INF("E\n");
+    sensor_resolution->SensorFullWidth = imgsensor_info.cap.grabwindow_width;
+    sensor_resolution->SensorFullHeight = imgsensor_info.cap.grabwindow_height;
+
+    sensor_resolution->SensorPreviewWidth = imgsensor_info.pre.grabwindow_width;
+    sensor_resolution->SensorPreviewHeight = imgsensor_info.pre.grabwindow_height;
+
+    sensor_resolution->SensorVideoWidth = imgsensor_info.normal_video.grabwindow_width;
+    sensor_resolution->SensorVideoHeight = imgsensor_info.normal_video.grabwindow_height;
+
+
+    sensor_resolution->SensorHighSpeedVideoWidth     = imgsensor_info.hs_video.grabwindow_width;
+    sensor_resolution->SensorHighSpeedVideoHeight     = imgsensor_info.hs_video.grabwindow_height;
+
+    sensor_resolution->SensorSlimVideoWidth     = imgsensor_info.slim_video.grabwindow_width;
+    sensor_resolution->SensorSlimVideoHeight     = imgsensor_info.slim_video.grabwindow_height;
+    return ERROR_NONE;
+}    /*    get_resolution    */
+
+static kal_uint32 get_info(MSDK_SCENARIO_ID_ENUM scenario_id,
+                      MSDK_SENSOR_INFO_STRUCT *sensor_info,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("scenario_id = %d\n", scenario_id);
+
+
+    //sensor_info->SensorVideoFrameRate = imgsensor_info.normal_video.max_framerate/10; /* not use */
+    //sensor_info->SensorStillCaptureFrameRate= imgsensor_info.cap.max_framerate/10; /* not use */
+    //imgsensor_info->SensorWebCamCaptureFrameRate= imgsensor_info.v.max_framerate; /* not use */
+
+    sensor_info->SensorClockPolarity = SENSOR_CLOCK_POLARITY_LOW;
+    sensor_info->SensorClockFallingPolarity = SENSOR_CLOCK_POLARITY_LOW; /* not use */
+    sensor_info->SensorHsyncPolarity = SENSOR_CLOCK_POLARITY_LOW; // inverse with datasheet
+    sensor_info->SensorVsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
+    sensor_info->SensorInterruptDelayLines = 4; /* not use */
+    sensor_info->SensorResetActiveHigh = FALSE; /* not use */
+    sensor_info->SensorResetDelayCount = 5; /* not use */
+
+    sensor_info->SensroInterfaceType = imgsensor_info.sensor_interface_type;
+    sensor_info->MIPIsensorType = imgsensor_info.mipi_sensor_type;
+    sensor_info->SettleDelayMode = imgsensor_info.mipi_settle_delay_mode;
+    sensor_info->SensorOutputDataFormat = imgsensor_info.sensor_output_dataformat;
+
+    sensor_info->CaptureDelayFrame = imgsensor_info.cap_delay_frame;
+    sensor_info->PreviewDelayFrame = imgsensor_info.pre_delay_frame;
+    sensor_info->VideoDelayFrame = imgsensor_info.video_delay_frame;
+    sensor_info->HighSpeedVideoDelayFrame = imgsensor_info.hs_video_delay_frame;
+    sensor_info->SlimVideoDelayFrame = imgsensor_info.slim_video_delay_frame;
+
+    sensor_info->SensorMasterClockSwitch = 0; /* not use */
+    sensor_info->SensorDrivingCurrent = imgsensor_info.isp_driving_current;
+
+    sensor_info->AEShutDelayFrame = imgsensor_info.ae_shut_delay_frame;          /* The frame of setting shutter default 0 for TG int */
+    sensor_info->AESensorGainDelayFrame = imgsensor_info.ae_sensor_gain_delay_frame;    /* The frame of setting sensor gain */
+    sensor_info->AEISPGainDelayFrame = imgsensor_info.ae_ispGain_delay_frame;
+    sensor_info->IHDR_Support = imgsensor_info.ihdr_support;
+    sensor_info->IHDR_LE_FirstLine = imgsensor_info.ihdr_le_firstline;
+    sensor_info->SensorModeNum = imgsensor_info.sensor_mode_num;
+
+    sensor_info->SensorMIPILaneNumber = imgsensor_info.mipi_lane_num;
+    sensor_info->SensorClockFreq = imgsensor_info.mclk;
+    sensor_info->SensorClockDividCount = 3; /* not use */
+    sensor_info->SensorClockRisingCount = 0;
+    sensor_info->SensorClockFallingCount = 2; /* not use */
+    sensor_info->SensorPixelClockCount = 3; /* not use */
+    sensor_info->SensorDataLatchCount = 2; /* not use */
+
+    sensor_info->MIPIDataLowPwr2HighSpeedTermDelayCount = 0;
+    sensor_info->MIPICLKLowPwr2HighSpeedTermDelayCount = 0;
+    sensor_info->SensorWidthSampling = 0;  // 0 is default 1x
+    sensor_info->SensorHightSampling = 0;    // 0 is default 1x
+    sensor_info->SensorPacketECCOrder = 1;
+
+    switch (scenario_id) {
+        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+            sensor_info->SensorGrabStartX = imgsensor_info.pre.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
+
+            break;
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+            sensor_info->SensorGrabStartX = imgsensor_info.cap.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.cap.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.cap.mipi_data_lp2hs_settle_dc;
+
+            break;
+        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+
+            sensor_info->SensorGrabStartX = imgsensor_info.normal_video.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.normal_video.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.normal_video.mipi_data_lp2hs_settle_dc;
+
+            break;
+        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+            sensor_info->SensorGrabStartX = imgsensor_info.hs_video.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.hs_video.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.hs_video.mipi_data_lp2hs_settle_dc;
+
+            break;
+        case MSDK_SCENARIO_ID_SLIM_VIDEO:
+            sensor_info->SensorGrabStartX = imgsensor_info.slim_video.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.slim_video.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.slim_video.mipi_data_lp2hs_settle_dc;
+
+            break;
+        default:
+            sensor_info->SensorGrabStartX = imgsensor_info.pre.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
+            break;
+    }
+
+    return ERROR_NONE;
+}    /*    get_info  */
+
+
+static kal_uint32 control(MSDK_SCENARIO_ID_ENUM scenario_id, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("scenario_id = %d\n", scenario_id);
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.current_scenario_id = scenario_id;
+    spin_unlock(&imgsensor_drv_lock);
+    switch (scenario_id) {
+        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+            preview(image_window, sensor_config_data);
+            break;
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+            capture(image_window, sensor_config_data);
+            break;
+        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+            normal_video(image_window, sensor_config_data);
+            break;
+        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+            hs_video(image_window, sensor_config_data);
+            break;
+        case MSDK_SCENARIO_ID_SLIM_VIDEO:
+            slim_video(image_window, sensor_config_data);
+            break;
+        default:
+            LOG_INF("Error ScenarioId setting");
+            preview(image_window, sensor_config_data);
+            return ERROR_INVALID_SCENARIO_ID;
+    }
+    return ERROR_NONE;
+}    /* control() */
+
+
+
+static kal_uint32 set_video_mode(UINT16 framerate)
+{
+    LOG_INF("framerate = %d\n ", framerate);
+    // SetVideoMode Function should fix framerate
+    if (framerate == 0)
+        // Dynamic frame rate
+        return ERROR_NONE;
+    spin_lock(&imgsensor_drv_lock);
+    if ((framerate == 300) && (imgsensor.autoflicker_en == KAL_TRUE))
+        imgsensor.current_fps = 296;
+    else if ((framerate == 150) && (imgsensor.autoflicker_en == KAL_TRUE))
+        imgsensor.current_fps = 146;
+    else
+        imgsensor.current_fps = framerate;
+    spin_unlock(&imgsensor_drv_lock);
+    set_max_framerate(imgsensor.current_fps,1);
+
+    return ERROR_NONE;
+}
+
+static kal_uint32 set_auto_flicker_mode(kal_bool enable, UINT16 framerate)
+{
+    LOG_INF("enable = %d, framerate = %d \n", enable, framerate);
+    spin_lock(&imgsensor_drv_lock);
+    if (enable) //enable auto flicker
+        imgsensor.autoflicker_en = KAL_TRUE;
+    else //Cancel Auto flick
+        imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    return ERROR_NONE;
+}
+
+
+static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 framerate)
+{
+    kal_uint32 frame_length;
+
+    LOG_INF("scenario_id = %d, framerate = %d\n", scenario_id, framerate);
+
+    switch (scenario_id) {
+        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+            frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            //set_dummy();
+            break;
+        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+            if(framerate == 0)
+                return ERROR_NONE;
+            frame_length = imgsensor_info.normal_video.pclk / framerate * 10 / imgsensor_info.normal_video.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.normal_video.framelength) ? (frame_length - imgsensor_info.normal_video.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.normal_video.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            //set_dummy();
+            break;
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+            frame_length = imgsensor_info.cap.pclk / framerate * 10 / imgsensor_info.cap.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.cap.framelength) ? (frame_length - imgsensor_info.cap.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.cap.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            //set_dummy();
+            break;
+        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+            frame_length = imgsensor_info.hs_video.pclk / framerate * 10 / imgsensor_info.hs_video.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.hs_video.framelength) ? (frame_length - imgsensor_info.hs_video.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.hs_video.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            //set_dummy();
+            break;
+        case MSDK_SCENARIO_ID_SLIM_VIDEO:
+            frame_length = imgsensor_info.slim_video.pclk / framerate * 10 / imgsensor_info.slim_video.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.slim_video.framelength) ? (frame_length - imgsensor_info.slim_video.framelength): 0;
+            imgsensor.frame_length = imgsensor_info.slim_video.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            //set_dummy();
+            break;
+        default:  //coding with  preview scenario by default
+            frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            //set_dummy();
+            LOG_INF("error scenario_id = %d, we use preview scenario \n", scenario_id);
+            break;
+    }
+    return ERROR_NONE;
+}
+
+
+static kal_uint32 get_default_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 *framerate)
+{
+    LOG_INF("scenario_id = %d\n", scenario_id);
+
+    switch (scenario_id) {
+        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+            *framerate = imgsensor_info.pre.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+            *framerate = imgsensor_info.normal_video.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+            *framerate = imgsensor_info.cap.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+            *framerate = imgsensor_info.hs_video.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_SLIM_VIDEO:
+            *framerate = imgsensor_info.slim_video.max_framerate;
+            break;
+        default:
+            break;
+    }
+
+    return ERROR_NONE;
+}
+
+
+
+static kal_uint32 set_test_pattern_mode(kal_bool enable)
+{
+    LOG_INF("enable: %d\n", enable);
+#if 0
+    // 0x503D[8]: 1 enable,  0 disable
+    // 0x503D[1:0]; 00 Color bar, 01 Random Data, 10 Square
+    if(enable)
+        write_cmos_sensor(0x503D, 0x80);
+    else
+        write_cmos_sensor(0x503D, 0x00);
+    
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.test_pattern = enable;
+    spin_unlock(&imgsensor_drv_lock);
+#endif
+    return ERROR_NONE;
+}
+
+
+static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
+                             UINT8 *feature_para,UINT32 *feature_para_len)
+{
+ UINT16 *feature_return_para_16=(UINT16 *) feature_para;
+    UINT16 *feature_data_16=(UINT16 *) feature_para;
+    UINT32 *feature_return_para_32=(UINT32 *) feature_para;
+    UINT32 *feature_data_32=(UINT32 *) feature_para;
+    unsigned long long *feature_data=(unsigned long long *) feature_para;
+    //unsigned long long *feature_return_para=(unsigned long long *) feature_para;
+
+    SENSOR_WINSIZE_INFO_STRUCT *wininfo;
+    MSDK_SENSOR_REG_INFO_STRUCT *sensor_reg_data=(MSDK_SENSOR_REG_INFO_STRUCT *) feature_para;
+
+    LOG_INF("feature_id = %d\n", feature_id);
+    switch (feature_id) {
+        case SENSOR_FEATURE_GET_PERIOD:
+            *feature_return_para_16++ = imgsensor.line_length;
+            *feature_return_para_16 = imgsensor.frame_length;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:
+            *feature_return_para_32 = imgsensor.pclk;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_SET_ESHUTTER:
+            set_shutter(*feature_data);
+            break;
+        case SENSOR_FEATURE_SET_NIGHTMODE:
+            night_mode((BOOL) *feature_data);
+            break;
+        case SENSOR_FEATURE_SET_GAIN:
+            set_gain((UINT16) *feature_data);
+            break;
+        case SENSOR_FEATURE_SET_FLASHLIGHT:
+            break;
+        case SENSOR_FEATURE_SET_ISP_MASTER_CLOCK_FREQ:
+            break;
+        case SENSOR_FEATURE_SET_REGISTER:
+            write_cmos_sensor(sensor_reg_data->RegAddr, sensor_reg_data->RegData);
+            break;
+        case SENSOR_FEATURE_GET_REGISTER:
+            sensor_reg_data->RegData = read_cmos_sensor(sensor_reg_data->RegAddr);
+            break;
+        case SENSOR_FEATURE_GET_LENS_DRIVER_ID:
+            // get the lens driver ID from EEPROM or just return LENS_DRIVER_ID_DO_NOT_CARE
+            // if EEPROM does not exist in camera module.
+            *feature_return_para_32=LENS_DRIVER_ID_DO_NOT_CARE;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_SET_VIDEO_MODE:
+            set_video_mode(*feature_data);
+            break;
+        case SENSOR_FEATURE_CHECK_SENSOR_ID:
+            get_imgsensor_id(feature_return_para_32);
+            break;
+        case SENSOR_FEATURE_SET_AUTO_FLICKER_MODE:
+            set_auto_flicker_mode((BOOL)*feature_data_16,*(feature_data_16+1));
+            break;
+        case SENSOR_FEATURE_SET_MAX_FRAME_RATE_BY_SCENARIO:
+            set_max_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data, *(feature_data+1));
+            break;
+        case SENSOR_FEATURE_GET_DEFAULT_FRAME_RATE_BY_SCENARIO:
+            get_default_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*(feature_data), (MUINT32 *)(uintptr_t)(*(feature_data+1)));
+            break;
+        case SENSOR_FEATURE_SET_TEST_PATTERN:
+            set_test_pattern_mode((BOOL)*feature_data);
+            break;
+        case SENSOR_FEATURE_GET_TEST_PATTERN_CHECKSUM_VALUE: //for factory mode auto testing
+            *feature_return_para_32 = imgsensor_info.checksum_value;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_SET_FRAMERATE:
+            LOG_INF("current fps :%d\n", (UINT32)*feature_data);
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.current_fps = *feature_data;
+            spin_unlock(&imgsensor_drv_lock);
+            break;
+        case SENSOR_FEATURE_SET_HDR:
+            LOG_INF("ihdr enable :%d\n", (BOOL)*feature_data);
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.ihdr_en = (BOOL)*feature_data;
+            spin_unlock(&imgsensor_drv_lock);
+            break;
+        case SENSOR_FEATURE_GET_CROP_INFO:
+            LOG_INF("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n", (UINT32)*feature_data);
+
+            wininfo = (SENSOR_WINSIZE_INFO_STRUCT *)(uintptr_t)(*(feature_data+1));
+
+            switch (*feature_data_32) {
+                case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[1],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[2],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[3],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_SLIM_VIDEO:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[4],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+                default:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[0],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+            }
+        case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
+            LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",(UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
+            ihdr_write_shutter_gain((UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
+            break;
+        default:
+            break;
+    }
+
+    
+    return ERROR_NONE;
+}    /*    feature_control()  */
+
+static SENSOR_FUNCTION_STRUCT sensor_func = {
+    open,
+    get_info,
+    get_resolution,
+    feature_control,
+    control,
+    close
+};
+
+UINT32 SP2508_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
+{
+    /* To Do : Check Sensor status here */
+    if (pfFunc!=NULL)
+        *pfFunc=&sensor_func;
+    return ERROR_NONE;
+}    /*    sp2508MIPISensorInit    */
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/-sp2508_mipi_raw/sp2508mipi_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/-sp2508_mipi_raw/sp2508mipi_Sensor.h
new file mode 100644
index 0000000..de50b9e
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/-sp2508_mipi_raw/sp2508mipi_Sensor.h
@@ -0,0 +1,119 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *     sp2508mipi_Sensor.h
+ *
+ * Project:
+ * --------
+ *     ALPS
+ *
+ * Description:
+ * ------------
+ *     CMOS sensor header file
+ *
+ ****************************************************************************/
+#ifndef _SP2508MIPI_SENSOR_H
+#define _SP2508MIPI_SENSOR_H
+
+
+typedef enum{
+    IMGSENSOR_MODE_INIT,
+    IMGSENSOR_MODE_PREVIEW,
+    IMGSENSOR_MODE_CAPTURE,
+    IMGSENSOR_MODE_VIDEO,
+    IMGSENSOR_MODE_HIGH_SPEED_VIDEO,
+    IMGSENSOR_MODE_SLIM_VIDEO,
+} IMGSENSOR_MODE;
+
+typedef struct imgsensor_mode_struct {
+    kal_uint32 pclk;                //record different mode's pclk
+    kal_uint32 linelength;            //record different mode's linelength
+    kal_uint32 framelength;            //record different mode's framelength
+
+    kal_uint8 startx;                //record different mode's startx of grabwindow
+    kal_uint8 starty;                //record different mode's startx of grabwindow
+
+    kal_uint16 grabwindow_width;    //record different mode's width of grabwindow
+    kal_uint16 grabwindow_height;    //record different mode's height of grabwindow
+
+    /*     following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario    */
+    kal_uint8 mipi_data_lp2hs_settle_dc;
+
+    /*     following for GetDefaultFramerateByScenario()    */
+    kal_uint16 max_framerate;
+
+} imgsensor_mode_struct;
+
+/* SENSOR PRIVATE STRUCT FOR VARIABLES*/
+typedef struct imgsensor_struct {
+    kal_uint8 mirror;                //mirrorflip information
+
+    kal_uint8 sensor_mode;            //record IMGSENSOR_MODE enum value
+
+    kal_uint32 shutter;                //current shutter
+    kal_uint16 gain;                //current gain
+
+    kal_uint32 pclk;                //current pclk
+
+    kal_uint32 frame_length;        //current framelength
+    kal_uint32 line_length;            //current linelength
+
+    kal_uint32 min_frame_length;    //current min  framelength to max framerate
+    kal_uint16 dummy_pixel;            //current dummypixel
+    kal_uint16 dummy_line;            //current dummline
+
+    kal_uint16 current_fps;            //current max fps
+    kal_bool   autoflicker_en;        //record autoflicker enable or disable
+    kal_bool test_pattern;            //record test pattern mode or not
+    MSDK_SCENARIO_ID_ENUM current_scenario_id;//current scenario id
+    kal_uint8  ihdr_en;                //ihdr enable or disable
+
+    kal_uint8 i2c_write_id;            //record current sensor's i2c write id
+} imgsensor_struct;
+
+/* SENSOR PRIVATE STRUCT FOR CONSTANT*/
+typedef struct imgsensor_info_struct {
+    kal_uint32 sensor_id;            //record sensor id defined in Kd_imgsensor.h
+    kal_uint32 checksum_value;        //checksum value for Camera Auto Test
+    imgsensor_mode_struct pre;        //preview scenario relative information
+    imgsensor_mode_struct cap;        //capture scenario relative information
+    imgsensor_mode_struct cap1;        //capture for PIP 24fps relative information, capture1 mode must use same framelength, linelength with Capture mode for shutter calculate
+    imgsensor_mode_struct normal_video;//normal video  scenario relative information
+    imgsensor_mode_struct hs_video;    //high speed video scenario relative information
+    imgsensor_mode_struct slim_video;    //slim video for VT scenario relative information
+
+    kal_uint8  ae_shut_delay_frame;    //shutter delay frame for AE cycle
+    kal_uint8  ae_sensor_gain_delay_frame;    //sensor gain delay frame for AE cycle
+    kal_uint8  ae_ispGain_delay_frame;    //isp gain delay frame for AE cycle
+    kal_uint8  ihdr_support;        //1, support; 0,not support
+    kal_uint8  ihdr_le_firstline;    //1,le first ; 0, se first
+    kal_uint8  sensor_mode_num;        //support sensor mode num
+
+    kal_uint8  cap_delay_frame;        //enter capture delay frame num
+    kal_uint8  pre_delay_frame;        //enter preview delay frame num
+    kal_uint8  video_delay_frame;    //enter video delay frame num
+    kal_uint8  hs_video_delay_frame;    //enter high speed video  delay frame num
+    kal_uint8  slim_video_delay_frame;    //enter slim video delay frame num
+
+    kal_uint8  margin;                //sensor framelength & shutter margin
+    kal_uint32 min_shutter;            //min shutter
+    kal_uint32 max_frame_length;    //max framelength by sensor register's limitation
+
+    kal_uint8  isp_driving_current;    //mclk driving current
+    kal_uint8  sensor_interface_type;//sensor_interface_type
+    kal_uint8  mipi_sensor_type; //0,MIPI_OPHY_NCSI2; 1,MIPI_OPHY_CSI2, default is NCSI2, don't modify this para
+    kal_uint8  mipi_settle_delay_mode; //0, high speed signal auto detect; 1, use settle delay,unit is ns, default is auto detect, don't modify this para
+    kal_uint8  sensor_output_dataformat;//sensor output first pixel color
+    kal_uint8  mclk;                //mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
+
+    kal_uint8  mipi_lane_num;        //mipi lane num
+    kal_uint8  i2c_addr_table[5];    //record sensor support all write id addr, only supprt 4must end with 0xff
+    kal_uint32  i2c_speed;     //i2c speed
+} imgsensor_info_struct;
+
+extern int iReadRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u8 * a_pRecvData, u16 a_sizeRecvData, u16 i2cId);
+extern int iWriteRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u16 i2cId);
+extern void kdSetI2CSpeed(u16 i2cSpeed);
+
+#endif
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6735m/Makefile
index cfa71bf..8587597 100755
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/Makefile
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/Makefile
@@ -11,7 +11,18 @@ endef
 
 obj-y				+= kd_sensorlist.o
 
+# Vanzo:wangfei on: Wed, 12 Nov 2014 21:06:42 +0800
+# for compatible the old style ,so use CUSTOM_KERNEL_IMGSENSOR
+custom_kernel_imgsensor := $(addsuffix /, $(shell echo $(CUSTOM_KERNEL_IMGSENSOR)))
+ifeq ($(custom_kernel_imgsensor),)
+# End of Vanzo:wangfei
 $(foreach drv,$(subst $\",,$(CONFIG_CUSTOM_KERNEL_IMGSENSOR)),$(eval $(call FILTER_PROJECT_DRV,$(drv))))
 custom_kernel_imgsensor := $(addsuffix /, $(shell echo $(platform_drv)))
+# Vanzo:wangfei on: Thu, 13 Nov 2014 16:15:59 +0800
+# added for project config prio the defconfig
+endif
+# End of Vanzo:wangfei
+
+$(info "the custom_kernel_imgsensor:$(custom_kernel_imgsensor)")
 obj-y += $(custom_kernel_imgsensor)
 $(info imgsensor drv by platform $(platform_drv))
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc0310_mipi_yuv/gc0310mipi_yuv_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc0310_mipi_yuv/gc0310mipi_yuv_Sensor.c
index 16c8235..af363c6 100644
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc0310_mipi_yuv/gc0310mipi_yuv_Sensor.c
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc0310_mipi_yuv/gc0310mipi_yuv_Sensor.c
@@ -231,20 +231,20 @@ void GC0310_set_contrast(UINT16 para)
 			GC0310_write_cmos_sensor(0xfe, 0x00);	 
 			GC0310_write_cmos_sensor(0xd3, 0x30);
 			GC0310_write_cmos_sensor(0xfe, 0x00); 
-			Sleep(200);
+			Sleep(50);
 			break;
         case ISP_CONTRAST_HIGH:			 
 			GC0310_write_cmos_sensor(0xfe, 0x00); 	
 			GC0310_write_cmos_sensor(0xd3, 0x60);
 			GC0310_write_cmos_sensor(0xfe, 0x00);
-			Sleep(200);			
+			Sleep(50);			
 			break;
         case ISP_CONTRAST_MIDDLE: 
         default:
 			GC0310_write_cmos_sensor(0xfe, 0x00);	 
-			GC0310_write_cmos_sensor(0xd3, 0x40);
+			GC0310_write_cmos_sensor(0xd3, 0x44);
 			GC0310_write_cmos_sensor(0xfe, 0x00);
-			Sleep(200);			
+			Sleep(50);			
 			break;
         //default:
 		//	break;
@@ -326,14 +326,14 @@ void GC0310_set_brightness(UINT16 para)
 {
 
 	SENSORDB("[GC0310]CONTROLFLOW enter GC0310_set_brightness function:\n ");
-#if 0
+#if 1
 	//return;
     switch (para)
     {
         case ISP_BRIGHT_LOW:
 		//case AE_EV_COMP_n13:
-			GC0310_write_cmos_sensor(0xd5, 0xc0);
-			Sleep(200);
+			GC0310_write_cmos_sensor(0xd5, 0xe0);
+			Sleep(50);
 			
 		//	GC0310_SET_PAGE1;
 		//	GC0310_write_cmos_sensor(0x13, 0x30);
@@ -341,8 +341,8 @@ void GC0310_set_brightness(UINT16 para)
 		break;
         case ISP_BRIGHT_HIGH:
 		//case AE_EV_COMP_13:
-			GC0310_write_cmos_sensor(0xd5, 0x70);
-			Sleep(200);
+			GC0310_write_cmos_sensor(0xd5, 0x20);
+			Sleep(50);
 		//	GC0310_SET_PAGE1;
 		//	GC0310_write_cmos_sensor(0x13, 0x90);
 		//	GC0310_SET_PAGE0;
@@ -350,8 +350,8 @@ void GC0310_set_brightness(UINT16 para)
         case ISP_BRIGHT_MIDDLE:
         default:
 		//case AE_EV_COMP_00:
-			GC0310_write_cmos_sensor(0xd5, 0x40);
-			Sleep(200);
+			GC0310_write_cmos_sensor(0xd5, 0xf0);
+			Sleep(50);
 		//	GC0310_SET_PAGE1;
 		//	GC0310_write_cmos_sensor(0x13, 0x60);
 		//	GC0310_SET_PAGE0;
@@ -377,15 +377,15 @@ void GC0310_set_saturation(UINT16 para)
 			break;
         case ISP_SAT_LOW:
 			GC0310_write_cmos_sensor(0xfe, 0x00); 	
-			GC0310_write_cmos_sensor(0xd1, 0x28);
-			GC0310_write_cmos_sensor(0xd2, 0x28);	
+			GC0310_write_cmos_sensor(0xd1, 0x24);
+			GC0310_write_cmos_sensor(0xd2, 0x24);	
 			GC0310_write_cmos_sensor(0xfe, 0x00);
 			break;
         case ISP_SAT_MIDDLE:
         default:
 			GC0310_write_cmos_sensor(0xfe, 0x00); 	
-			GC0310_write_cmos_sensor(0xd1, 0x34);
-			GC0310_write_cmos_sensor(0xd2, 0x34);	
+			GC0310_write_cmos_sensor(0xd1, 0x2a);
+			GC0310_write_cmos_sensor(0xd2, 0x2a);	
 			GC0310_write_cmos_sensor(0xfe, 0x00);
 			break;
 		//	return KAL_FALSE;
@@ -415,7 +415,7 @@ void GC0310_set_edge(UINT16 para)
         case ISP_SAT_MIDDLE:
         default:
 			GC0310_write_cmos_sensor(0xfe, 0x00); 	
-			GC0310_write_cmos_sensor(0x95, 0x45);
+			GC0310_write_cmos_sensor(0x95, 0x54);
 			GC0310_write_cmos_sensor(0xfe, 0x00);
 			break;
 		//	return KAL_FALSE;
@@ -807,7 +807,7 @@ void GC0310GammaSelect(kal_uint32 GammaLvl)
 			GC0310_write_cmos_sensor(0xcF, 0xFF);
 			break;
 		default:
-			//GC0310_RGB_Gamma_m1
+			//GC0310_RGB_Gamma_m3
 			GC0310_write_cmos_sensor(0xfe, 0x00);
 			GC0310_write_cmos_sensor(0xbf , 0x0b);
 			GC0310_write_cmos_sensor(0xc0 , 0x17);
@@ -982,7 +982,7 @@ void GC0310_Sensor_Init(void)
 	GC0310_write_cmos_sensor(0x10,0x84);
                                         
 	GC0310_write_cmos_sensor(0x01,0x03);             
-	GC0310_write_cmos_sensor(0x02,0x11);  ///00           
+	GC0310_write_cmos_sensor(0x02,0x11);  //flower sreen switching to front camera
 	GC0310_write_cmos_sensor(0x03,0x94);             
 	GC0310_write_cmos_sensor(0x04,0x01);            
 	GC0310_write_cmos_sensor(0x05,0x40);  // 40      20     
@@ -1007,8 +1007,8 @@ void GC0310_Sensor_Init(void)
     GC0310_write_cmos_sensor(0x00,0x2f);
     GC0310_write_cmos_sensor(0x01,0x0f);
     GC0310_write_cmos_sensor(0x02,0x04);
-    GC0310_write_cmos_sensor(0x03,0x04);
-    GC0310_write_cmos_sensor(0x04,0xd0);
+    GC0310_write_cmos_sensor(0x03,0x03);  
+    GC0310_write_cmos_sensor(0x04,0x50);
     GC0310_write_cmos_sensor(0x09,0x00);
     GC0310_write_cmos_sensor(0x0a,0x00);
     GC0310_write_cmos_sensor(0x0b,0x00);
@@ -1022,11 +1022,12 @@ void GC0310_Sensor_Init(void)
     GC0310_write_cmos_sensor(0x18,0x1a);
     GC0310_write_cmos_sensor(0x19,0x14);
     GC0310_write_cmos_sensor(0x1b,0x48);
+	GC0310_write_cmos_sensor(0x1c,0x6c);
     GC0310_write_cmos_sensor(0x1e,0x6b);
     GC0310_write_cmos_sensor(0x1f,0x28);
     GC0310_write_cmos_sensor(0x20,0x8b);  // from 89 to 8b
     GC0310_write_cmos_sensor(0x21,0x49);
-    GC0310_write_cmos_sensor(0x22,0xb0);
+    GC0310_write_cmos_sensor(0x22,0xd0); //b0
     GC0310_write_cmos_sensor(0x23,0x04);
     GC0310_write_cmos_sensor(0x24,0x16);
     GC0310_write_cmos_sensor(0x34,0x20);
@@ -1079,7 +1080,7 @@ void GC0310_Sensor_Init(void)
         ///////////////////////////////////////////////// 
         ///////////////////   DNDD  /////////////////////
         ///////////////////////////////////////////////// 
-    GC0310_write_cmos_sensor(0x82,0x1f); 
+    GC0310_write_cmos_sensor(0x82,0x08);   //  1f
     GC0310_write_cmos_sensor(0x83,0x0b);
         
         
@@ -1092,7 +1093,7 @@ void GC0310_Sensor_Init(void)
     GC0310_write_cmos_sensor(0x92,0x03); 
     GC0310_write_cmos_sensor(0x93,0x03); 
     GC0310_write_cmos_sensor(0x94,0x05);
-    GC0310_write_cmos_sensor(0x95,0x65); 
+    GC0310_write_cmos_sensor(0x95,0x54); 
     GC0310_write_cmos_sensor(0x96,0xf0); 
         
         ///////////////////////////////////////////////// 
@@ -1105,10 +1106,10 @@ void GC0310_Sensor_Init(void)
     GC0310_write_cmos_sensor(0x9d,0x80);
     GC0310_write_cmos_sensor(0xa1,0x30);
     GC0310_write_cmos_sensor(0xa2,0x32);
-    GC0310_write_cmos_sensor(0xa4,0x30);
-    GC0310_write_cmos_sensor(0xa5,0x30);
+    GC0310_write_cmos_sensor(0xa4,0x35);//30
+    GC0310_write_cmos_sensor(0xa5,0x40);//30 bob
     GC0310_write_cmos_sensor(0xaa,0x50);
-    GC0310_write_cmos_sensor(0xac,0x22);
+    GC0310_write_cmos_sensor(0xac,0xff);
         
         /////////////////////////////////////////////////
         ///////////////////   GAMMA   ///////////////////
@@ -1135,9 +1136,10 @@ void GC0310_Sensor_Init(void)
         ///////////////////   YCP  //////////////////////
         /////////////////////////////////////////////////
     GC0310_write_cmos_sensor(0xd0,0x40); 
-    GC0310_write_cmos_sensor(0xd1,0x34); 
-    GC0310_write_cmos_sensor(0xd2,0x34); 
-    GC0310_write_cmos_sensor(0xd3,0x3c); 
+    GC0310_write_cmos_sensor(0xd1,0x2a); 
+    GC0310_write_cmos_sensor(0xd2,0x2a); 
+    GC0310_write_cmos_sensor(0xd3,0x44); 
+    GC0310_write_cmos_sensor(0xd5,0xf0); 
     GC0310_write_cmos_sensor(0xd6,0xf2); 
     GC0310_write_cmos_sensor(0xd7,0x1b); 
     GC0310_write_cmos_sensor(0xd8,0x18); 
@@ -1154,11 +1156,11 @@ void GC0310_Sensor_Init(void)
     GC0310_write_cmos_sensor(0x0b,0x11);
     GC0310_write_cmos_sensor(0x0c,0x00); 
     GC0310_write_cmos_sensor(0x12,0x52);
-    GC0310_write_cmos_sensor(0x13,0x38); 
+    GC0310_write_cmos_sensor(0x13,0x42);   //38
     GC0310_write_cmos_sensor(0x18,0x95);
     GC0310_write_cmos_sensor(0x19,0x96);
-    GC0310_write_cmos_sensor(0x1f,0x20);
-    GC0310_write_cmos_sensor(0x20,0xc0); 
+    GC0310_write_cmos_sensor(0x1f,0x10);
+    GC0310_write_cmos_sensor(0x20,0xd0); 
     GC0310_write_cmos_sensor(0x3e,0x40); 
     GC0310_write_cmos_sensor(0x3f,0x57); 
     GC0310_write_cmos_sensor(0x40,0x7d); 
@@ -1167,56 +1169,31 @@ void GC0310_Sensor_Init(void)
     /////////////////////////////////////////////////
     ////////////////////   AWB   ////////////////////
     /////////////////////////////////////////////////
-    GC0310_write_cmos_sensor(0x1c,0x91); 
-    GC0310_write_cmos_sensor(0x21,0x15); 
-    GC0310_write_cmos_sensor(0x50,0x80);
-    GC0310_write_cmos_sensor(0x56,0x04);
-    GC0310_write_cmos_sensor(0x58,0x08);    
-    GC0310_write_cmos_sensor(0x59,0x08); 
-    GC0310_write_cmos_sensor(0x5b,0x82);  // 02 to 82 to 02
-    GC0310_write_cmos_sensor(0x61,0x8d); 
-    GC0310_write_cmos_sensor(0x62,0xa7); 
-    GC0310_write_cmos_sensor(0x63,0x00);   // d0 to  00
-    GC0310_write_cmos_sensor(0x65,0x06);
-    GC0310_write_cmos_sensor(0x66,0x06);   // 06 to 03
-    GC0310_write_cmos_sensor(0x67,0x84); 
-    GC0310_write_cmos_sensor(0x69,0x08);   // 08 to 20
-    GC0310_write_cmos_sensor(0x6a,0x25); 
-    GC0310_write_cmos_sensor(0x6b,0x01); 
-    GC0310_write_cmos_sensor(0x6c,0x00);   // 00 to 0c
-    GC0310_write_cmos_sensor(0x6d,0x02); 
-    GC0310_write_cmos_sensor(0x6e,0x00);  // f0 to 00
-    GC0310_write_cmos_sensor(0x6f,0x80); 
-    GC0310_write_cmos_sensor(0x76,0x80); 
-    GC0310_write_cmos_sensor(0x78,0xaf); 
-    GC0310_write_cmos_sensor(0x79,0x75);
-    GC0310_write_cmos_sensor(0x7a,0x40);
-    GC0310_write_cmos_sensor(0x7b,0x50);
-    GC0310_write_cmos_sensor(0x7c,0x08); //0c to 08 8.11
-         
-    GC0310_write_cmos_sensor(0xa4,0xb9); 
+    GC0310_write_cmos_sensor(0xfe,0x01);
+    GC0310_write_cmos_sensor(0x6e,0x30);
+    GC0310_write_cmos_sensor(0xa4,0xb9);
     GC0310_write_cmos_sensor(0xa5,0xa0);
     GC0310_write_cmos_sensor(0x90,0xc9); 
     GC0310_write_cmos_sensor(0x91,0xbe);
     GC0310_write_cmos_sensor(0xa6,0xb8); 
-    GC0310_write_cmos_sensor(0xa7,0x95); 
+    GC0310_write_cmos_sensor(0xa7,0x80); 
     GC0310_write_cmos_sensor(0x92,0xe6); 
     GC0310_write_cmos_sensor(0x93,0xca); 
-    GC0310_write_cmos_sensor(0xa9,0xb6); 
-    GC0310_write_cmos_sensor(0xaa,0x89); 
+    GC0310_write_cmos_sensor(0xa9,0xbc); 
+    GC0310_write_cmos_sensor(0xaa,0x80); 
     GC0310_write_cmos_sensor(0x95,0x23); 
     GC0310_write_cmos_sensor(0x96,0xe7); 
     GC0310_write_cmos_sensor(0xab,0x9d); 
     GC0310_write_cmos_sensor(0xac,0x80);
     GC0310_write_cmos_sensor(0x97,0x43); 
     GC0310_write_cmos_sensor(0x98,0x24); 
-    GC0310_write_cmos_sensor(0xae,0xd0);   // b7 to d0
+    GC0310_write_cmos_sensor(0xae,0xb7);   // b7 to d0
     GC0310_write_cmos_sensor(0xaf,0x9e); 
     GC0310_write_cmos_sensor(0x9a,0x43);
     GC0310_write_cmos_sensor(0x9b,0x24); 
         
-    GC0310_write_cmos_sensor(0xb0,0xc0);  // c8 to c0
-    GC0310_write_cmos_sensor(0xb1,0xa8);   // 97 to a8
+    GC0310_write_cmos_sensor(0xb0,0xc8);  // c8 to c0
+    GC0310_write_cmos_sensor(0xb1,0x97);   // 97 to a8
     GC0310_write_cmos_sensor(0x9c,0xc4); 
     GC0310_write_cmos_sensor(0x9d,0x44); 
     GC0310_write_cmos_sensor(0xb3,0xb7); 
@@ -1245,19 +1222,45 @@ void GC0310_Sensor_Init(void)
     GC0310_write_cmos_sensor(0xb2,0x55);
     GC0310_write_cmos_sensor(0xb7,0x05);
     GC0310_write_cmos_sensor(0x8f,0x05);
-    GC0310_write_cmos_sensor(0xb8,0xcc);
-    GC0310_write_cmos_sensor(0xb9,0x9a);
+    GC0310_write_cmos_sensor(0xb8,0xcb);
+    GC0310_write_cmos_sensor(0xb9,0x9b);
+    GC0310_write_cmos_sensor(0x1c,0x91);
+    GC0310_write_cmos_sensor(0x21,0x15);
+    GC0310_write_cmos_sensor(0x50,0x80);
+    GC0310_write_cmos_sensor(0x56,0x04);
+    GC0310_write_cmos_sensor(0x59,0x08);
+    GC0310_write_cmos_sensor(0x5b,0x02);
+    GC0310_write_cmos_sensor(0x61,0x8d);
+    GC0310_write_cmos_sensor(0x62,0xa7);
+    GC0310_write_cmos_sensor(0x63,0xd0);
+    GC0310_write_cmos_sensor(0x65,0x0a);
+    GC0310_write_cmos_sensor(0x66,0x06);
+    GC0310_write_cmos_sensor(0x67,0x84);
+    GC0310_write_cmos_sensor(0x69,0x08);
+    GC0310_write_cmos_sensor(0x6a,0x25);
+    GC0310_write_cmos_sensor(0x6b,0x01);
+    GC0310_write_cmos_sensor(0x6c,0x00);
+    GC0310_write_cmos_sensor(0x6d,0x02);
+    GC0310_write_cmos_sensor(0x6e,0x30);
+    GC0310_write_cmos_sensor(0x6f,0xa0);
+    GC0310_write_cmos_sensor(0x76,0x80);
+    GC0310_write_cmos_sensor(0x78,0xaf);
+    GC0310_write_cmos_sensor(0x79,0x75);
+    GC0310_write_cmos_sensor(0x7a,0x40);
+    GC0310_write_cmos_sensor(0x7b,0x50);
+    GC0310_write_cmos_sensor(0x7c,0x0c);
+
         
         /////////////////////////////////////
         ////////////////////  CC ////////////
         /////////////////////////////////////
     GC0310_write_cmos_sensor(0xfe,0x01);
-    GC0310_write_cmos_sensor(0xd0,0x38);
-    GC0310_write_cmos_sensor(0xd1,0xfd);
+    GC0310_write_cmos_sensor(0xd0,0x34);//32//3a
+    GC0310_write_cmos_sensor(0xd1,0x02);//fd
     GC0310_write_cmos_sensor(0xd2,0x06);
-    GC0310_write_cmos_sensor(0xd3,0xf0);
-    GC0310_write_cmos_sensor(0xd4,0x40);
-    GC0310_write_cmos_sensor(0xd5,0x08);
+    GC0310_write_cmos_sensor(0xd3,0xff);//f0//fa
+    GC0310_write_cmos_sensor(0xd4,0x36);//40//3a
+    GC0310_write_cmos_sensor(0xd5,0xed);//08
     GC0310_write_cmos_sensor(0xd6,0x30);
     GC0310_write_cmos_sensor(0xd7,0x00);
     GC0310_write_cmos_sensor(0xd8,0x0a);
@@ -1317,26 +1320,21 @@ void GC0310_Sensor_Init(void)
         ///////////////////  banding  ///////////////////
         /////////////////////////////////////////////////
     GC0310_write_cmos_sensor(0xfe,0x00);
-    GC0310_write_cmos_sensor(0x05,0x01);
-    GC0310_write_cmos_sensor(0x06,0x18); //HB
-#if 1    
+    GC0310_write_cmos_sensor(0x05,0x02);
+    GC0310_write_cmos_sensor(0x06,0xd1); //HB
     GC0310_write_cmos_sensor(0x07,0x00);
-    GC0310_write_cmos_sensor(0x08,0x10); //VB  from 10 to 50
-#else
-	GC0310_write_cmos_sensor(0x07,0x01);
-	GC0310_write_cmos_sensor(0x08,0xe0); //VB
-#endif
+    GC0310_write_cmos_sensor(0x08,0x22); //VB  from 10 to 50
     GC0310_write_cmos_sensor(0xfe,0x01);
     GC0310_write_cmos_sensor(0x25,0x00); //step 
-    GC0310_write_cmos_sensor(0x26,0x9a); 
-    GC0310_write_cmos_sensor(0x27,0x01); //30fps
-    GC0310_write_cmos_sensor(0x28,0xce);  
-    GC0310_write_cmos_sensor(0x29,0x04); //12.5fps
-	GC0310_write_cmos_sensor(0x2a,0x36); 
+    GC0310_write_cmos_sensor(0x26,0x6a); 
+    GC0310_write_cmos_sensor(0x27,0x04); //30fps
+    GC0310_write_cmos_sensor(0x28,0xf8);  
+    GC0310_write_cmos_sensor(0x29,0x05); //12.5fps
+	GC0310_write_cmos_sensor(0x2a,0x62); 
 	GC0310_write_cmos_sensor(0x2b,0x06); //10fps
-	GC0310_write_cmos_sensor(0x2c,0x04); 
-	GC0310_write_cmos_sensor(0x2d,0x0c); //5fps
-	GC0310_write_cmos_sensor(0x2e,0x08);
+	GC0310_write_cmos_sensor(0x2c,0x36); 
+	GC0310_write_cmos_sensor(0x2d,0x07); //5fps
+	GC0310_write_cmos_sensor(0x2e,0xde);
     GC0310_write_cmos_sensor(0x3c,0x20);
         
         /////////////////////////////////////////////////
@@ -1497,8 +1495,11 @@ UINT32 GC0310Preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
     image_window->ExposureWindowWidth = IMAGE_SENSOR_PV_WIDTH;
     image_window->ExposureWindowHeight =IMAGE_SENSOR_PV_HEIGHT;
 
-    GC0310_Set_Mirrorflip(IMAGE_NORMAL);
-    
+	if(0 == strncmp(VANZO_SUB_CAM_ROTATION, "180", 3)){
+		GC0310_Set_Mirrorflip(IMAGE_HV_MIRROR);
+    }else{
+		GC0310_Set_Mirrorflip(IMAGE_NORMAL);
+	}
 
     // copy sensor_config_data
     memcpy(&GC0310SensorConfigData, sensor_config_data, sizeof(MSDK_SENSOR_CONFIG_STRUCT));
@@ -1678,37 +1679,37 @@ BOOL GC0310_set_param_wb(UINT16 para)
 		
 		case AWB_MODE_CLOUDY_DAYLIGHT: //cloudy
 			GC0310_awb_enable(KAL_FALSE);
-			GC0310_write_cmos_sensor(0x77, 0x40);
-			GC0310_write_cmos_sensor(0x78, 0x54);
-			GC0310_write_cmos_sensor(0x79, 0x70);
+			GC0310_write_cmos_sensor(0x77, 0xb0);
+			GC0310_write_cmos_sensor(0x78, 0x40);
+			GC0310_write_cmos_sensor(0x79, 0x40);
 		break;
 		
 		case AWB_MODE_DAYLIGHT: //sunny
 			GC0310_awb_enable(KAL_FALSE);
-			GC0310_write_cmos_sensor(0x77, 0x74); 
-			GC0310_write_cmos_sensor(0x78, 0x52);
-			GC0310_write_cmos_sensor(0x79, 0x40);			
+			GC0310_write_cmos_sensor(0x77, 0x80); 
+			GC0310_write_cmos_sensor(0x78, 0x40);
+			GC0310_write_cmos_sensor(0x79, 0x48);			
 		break;
 		
 		case AWB_MODE_INCANDESCENT: //office
 			GC0310_awb_enable(KAL_FALSE);
-			GC0310_write_cmos_sensor(0x77, 0x48);
+			GC0310_write_cmos_sensor(0x77, 0x40);
 			GC0310_write_cmos_sensor(0x78, 0x40);
-			GC0310_write_cmos_sensor(0x79, 0x5c);
+			GC0310_write_cmos_sensor(0x79, 0x80);
 		break;
 		
 		case AWB_MODE_TUNGSTEN: //home		
 			GC0310_awb_enable(KAL_FALSE);
-			GC0310_write_cmos_sensor(0x77, 0x8c); //WB_manual_gain 
-			GC0310_write_cmos_sensor(0x78, 0x50);
-			GC0310_write_cmos_sensor(0x79, 0x40);
+			GC0310_write_cmos_sensor(0x77, 0x40); //WB_manual_gain 
+			GC0310_write_cmos_sensor(0x78, 0x40);
+			GC0310_write_cmos_sensor(0x79, 0xb0);
 		break;
 		
 		case AWB_MODE_FLUORESCENT:
 			GC0310_awb_enable(KAL_FALSE);
-			GC0310_write_cmos_sensor(0x77, 0x40);
-			GC0310_write_cmos_sensor(0x78, 0x42);
-			GC0310_write_cmos_sensor(0x79, 0x50);
+			GC0310_write_cmos_sensor(0x77, 0x60);
+			GC0310_write_cmos_sensor(0x78, 0x48);
+			GC0310_write_cmos_sensor(0x79, 0x88);
 		break;
 		
 		default:
@@ -1776,23 +1777,23 @@ BOOL GC0310_set_param_banding(UINT16 para)
 		case AE_FLICKER_MODE_OFF:
 		case AE_FLICKER_MODE_50HZ:
 			GC0310_write_cmos_sensor(0xfe, 0x00); 
-			GC0310_write_cmos_sensor(0x05, 0x01); 	
-			GC0310_write_cmos_sensor(0x06, 0x18); 
+			GC0310_write_cmos_sensor(0x05, 0x02); 	
+			GC0310_write_cmos_sensor(0x06, 0xd1); 
 			GC0310_write_cmos_sensor(0x07, 0x00);
-			GC0310_write_cmos_sensor(0x08, 0x10);
+			GC0310_write_cmos_sensor(0x08, 0x22);
 			
 			GC0310_write_cmos_sensor(0xfe, 0x01);
 			GC0310_write_cmos_sensor(0x25,0x00); //step 
-			GC0310_write_cmos_sensor(0x26,0x9a); 
+			GC0310_write_cmos_sensor(0x26,0x6a); 
 		
-			GC0310_write_cmos_sensor(0x27,0x01); //30fps
-			GC0310_write_cmos_sensor(0x28,0xce);  
-			GC0310_write_cmos_sensor(0x29,0x04); //15fps
-			GC0310_write_cmos_sensor(0x2a,0x36); 
+			GC0310_write_cmos_sensor(0x27,0x04); //30fps
+			GC0310_write_cmos_sensor(0x28,0xf8);  
+			GC0310_write_cmos_sensor(0x29,0x05); //15fps
+			GC0310_write_cmos_sensor(0x2a,0x62); 
 			GC0310_write_cmos_sensor(0x2b,0x06); //10fps
-			GC0310_write_cmos_sensor(0x2c,0x04); 
-			GC0310_write_cmos_sensor(0x2d,0x09); //8fps  
-			GC0310_write_cmos_sensor(0x2e,0xa0);  // 
+			GC0310_write_cmos_sensor(0x2c,0x36); 
+			GC0310_write_cmos_sensor(0x2d,0x07); //8fps  
+			GC0310_write_cmos_sensor(0x2e,0xde);  // 
 			//GC0310_write_cmos_sensor(0x3c,0x20);
 			GC0310_write_cmos_sensor(0xfe, 0x00); 			
 			break;
@@ -1847,7 +1848,7 @@ BOOL GC0310_set_param_exposure(UINT16 para)
 		
 		case AE_EV_COMP_00:	
 			GC0310_write_cmos_sensor(0xfe, 0x01);
-			GC0310_write_cmos_sensor(0x13, 0x38);//35
+			GC0310_write_cmos_sensor(0x13, 0x42);//35
 			GC0310_write_cmos_sensor(0xfe, 0x00);
 		break;
 
@@ -1856,7 +1857,7 @@ BOOL GC0310_set_param_exposure(UINT16 para)
 			GC0310_write_cmos_sensor(0xfe, 0x01);
 			GC0310_write_cmos_sensor(0x13, 0x48);  // 48 to 60
 			GC0310_write_cmos_sensor(0xfe, 0x00);
-			Sleep(200);
+			Sleep(50);
 		break;
 		
 		case AE_EV_COMP_20:
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc0310main_mipi_yuv/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc0310main_mipi_yuv/Makefile
new file mode 100755
index 0000000..9b0eaf0
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc0310main_mipi_yuv/Makefile
@@ -0,0 +1,4 @@
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+
+obj-y += gc0310mainmipi_yuv_Sensor.o
+
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc0310main_mipi_yuv/gc0310mainmipi_yuv_CameraCustomized.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc0310main_mipi_yuv/gc0310mainmipi_yuv_CameraCustomized.h
new file mode 100755
index 0000000..0072fee
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc0310main_mipi_yuv/gc0310mainmipi_yuv_CameraCustomized.h
@@ -0,0 +1,135 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *   sensor.h
+ *
+ * Project:
+ * --------
+ *   DUMA
+ *
+ * Description:
+ * ------------
+ *   Header file of camera customized parameters.
+ *
+ *
+ * Author:
+ * -------
+ *   PC Huang (MTK02204)
+ *
+ *============================================================================
+ *             HISTORY
+ * Below this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *------------------------------------------------------------------------------
+ * $Revision:$
+ * $Modtime:$
+ * $Log:$
+ *
+ * Feb 9 2010 mtk80461
+ * [DUMA00154355] JPeg Orientation feature check in
+ *
+ *
+ * Oct 27 2009 mtk02204
+ * [DUMA00015869] [Camera Driver] Modifiy camera related drivers for dual/backup sensor/lens drivers.
+ *
+ *
+ * Sep 24 2009 mtk02204
+ * [DUMA00134387] [LTK][GW616][Camera]4040 Camera:Camera Quality Test failed.
+ *
+ *
+ * Jul 8 2009 mtk02204
+ * [DUMA00008051] [Camera Driver] Add drivers for camera high ISO binning mode.
+ *
+ *
+ * Jul 8 2009 mtk02204
+ * [DUMA00008051] [Camera Driver] Add drivers for camera high ISO binning mode.
+ *
+ *
+ * Jul 7 2009 mtk02204
+ * [DUMA00008051] [Camera Driver] Add drivers for camera high ISO binning mode.
+ *
+ *
+ * Jun 6 2009 mtk02204
+ * [DUMA00119628] MTK camera_recorded video only contain audio but no video with Jean effect
+ *
+ *
+ * Apr 10 2009 mtk02204
+ * [DUMA00004178] [Camera] Check in for MTK camera integration
+ *
+ *
+ * Mar 13 2009 mtk02204
+ * [DUMA00001084] First Check in of MT6516 multimedia drivers
+ *
+ *
+ * Mar 2 2009 mtk02204
+ * [DUMA00001084] First Check in of MT6516 multimedia drivers
+ *
+ *
+ * Feb 6 2009 mtk02204
+ * [DUMA00001084] First Check in of MT6516 multimedia drivers
+ *
+ *
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *============================================================================
+ ****************************************************************************/
+
+#ifndef __CAMERA_CUSTOMIZED_H
+#define __CAMERA_CUSTOMIZED_H
+
+// the angle between handset and sensor placement in clockwise, should be one of 0, 90, 270
+#define MAIN_SENSOR_ORIENTATION_ANGLE	90	// 90
+#define SUB_SENSOR_ORIENTATION_ANGLE	0		// do not care if the sub sensor does not exist
+
+
+// First, we think you hold the cell phone vertical.
+// Second, we suppose the direction of upward is 0
+// Third, it is 90, 180, 270 in clockwise
+// here we define the main sensor and sub sensor angles to deal with the jpeg orientation
+#define MAIN_SENSOR_TO_PHONE_ANGLE	0
+#define SUB_SENSOR_TO_PHONE_ANGLE	0
+
+
+#define CAM_SIZE_QVGA_WIDTH 	320
+#define CAM_SIZE_QVGA_HEIGHT 	240
+#define CAM_SIZE_VGA_WIDTH 		640
+#define CAM_SIZE_VGA_HEIGHT 	480
+#define CAM_SIZE_05M_WIDTH 		800
+#define CAM_SIZE_05M_HEIGHT 	600
+#define CAM_SIZE_1M_WIDTH 		1280
+#define CAM_SIZE_1M_HEIGHT 		960
+#define CAM_SIZE_2M_WIDTH 		1600
+#define CAM_SIZE_2M_HEIGHT 		1200
+#define CAM_SIZE_3M_WIDTH 		2048
+#define CAM_SIZE_3M_HEIGHT 		1536
+#define CAM_SIZE_5M_WIDTH 		2592
+#define CAM_SIZE_5M_HEIGHT 		1944
+
+// for main sensor
+#define MAIN_NUM_OF_PREVIEW_RESOLUTION 3
+#define MAIN_NUM_OF_VIDEO_RESOLUTION 4
+#define MAIN_NUM_OF_STILL_RESOLUTION 7
+#define MAIN_VIDEO_RESOLUTION_PROFILE		{{176,144},{320,240},{640,480},{720,480}}
+#define MAIN_PREVIEW_RESOLUTION_PROFILE	{{232,174},{320,240},{240,320}}
+#define MAIN_STILL_RESOLUTION_PROFILE		{{CAM_SIZE_QVGA_WIDTH,CAM_SIZE_QVGA_HEIGHT}, \
+									 {CAM_SIZE_VGA_WIDTH,CAM_SIZE_VGA_HEIGHT}, \
+							//		 {CAM_SIZE_05M_WIDTH,CAM_SIZE_05M_HEIGHT}, \
+							//		 {CAM_SIZE_1M_WIDTH,CAM_SIZE_1M_HEIGHT}, \
+							//		 {CAM_SIZE_2M_WIDTH,CAM_SIZE_2M_HEIGHT}, \
+							//		 {CAM_SIZE_3M_WIDTH,CAM_SIZE_3M_HEIGHT}, \
+							//		 {CAM_SIZE_5M_WIDTH,CAM_SIZE_5M_HEIGHT}}
+
+// if sub sensor does not exist, set all the parameters as 0
+#define SUB_NUM_OF_PREVIEW_RESOLUTION 0
+#define SUB_NUM_OF_VIDEO_RESOLUTION 0
+#define SUB_NUM_OF_STILL_RESOLUTION 0
+#define SUB_VIDEO_RESOLUTION_PROFILE		{{0,0}}
+#define SUB_PREVIEW_RESOLUTION_PROFILE		{{0,0}}
+#define SUB_STILL_RESOLUTION_PROFILE		{{0,0}}
+
+//#define NUM_OF_PREVIEW_RESOLUTION 	max(MAIN_NUM_OF_PREVIEW_RESOLUTION,SUB_NUM_OF_PREVIEW_RESOLUTION)
+//#define NUM_OF_VIDEO_RESOLUTION 	max(MAIN_NUM_OF_VIDEO_RESOLUTION,SUB_NUM_OF_VIDEO_RESOLUTION)
+//#define NUM_OF_STILL_RESOLUTION 	max(MAIN_NUM_OF_STILL_RESOLUTION,SUB_NUM_OF_STILL_RESOLUTION)
+
+#define NUM_OF_VIDEO_STREAM_BUFF	8	// Maximun is 8
+#endif
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc0310main_mipi_yuv/gc0310mainmipi_yuv_Camera_Sensor_para.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc0310main_mipi_yuv/gc0310mainmipi_yuv_Camera_Sensor_para.h
new file mode 100755
index 0000000..20f6e83
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc0310main_mipi_yuv/gc0310mainmipi_yuv_Camera_Sensor_para.h
@@ -0,0 +1,101 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *   camera_sensor_para.h
+ *
+ * Project:
+ * --------
+ *   DUMA
+ *
+ * Description:
+ * ------------
+ *   Header file of Sensor tuning parameters that should be generated by CCT
+ *
+ *
+ * Author:
+ * -------
+ *
+ *============================================================================
+ *             HISTORY
+ * Below this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *------------------------------------------------------------------------------
+ * $Revision:$
+ * $Modtime:$
+ * $Log:$
+ *
+ * Mar 4 2010 mtk70508
+ * [DUMA00154792] Sensor driver
+ * 
+ *
+ * Feb 24 2010 mtk01118
+ * [DUMA00025869] [Camera][YUV I/F & Query feature] check in camera code
+ * 
+ *
+ * Apr 7 2009 mtk02204
+ * [DUMA00004012] [Camera] Restructure and rename camera related custom folders and folder name of came
+ * 
+ *
+ * Feb 24 2009 mtk02204
+ * [DUMA00001084] First Check in of MT6516 multimedia drivers
+ * 
+ *
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *============================================================================
+ ****************************************************************************/
+/* SENSOR FULL SIZE */
+#ifndef __CAMERA_SENSOR_PARA_H
+#define __CAMERA_SENSOR_PARA_H
+
+#define CAMERA_SENSOR_REG_DEFAULT_VALUE  \
+		/* ARRAY: SENSOR.reg[11] */\
+		{\
+			/* STRUCT: SENSOR.reg[0] */\
+			{\
+				/* SENSOR.reg[0].addr */ 0x00000304, /* SENSOR.reg[0].para */ 0x00000000\
+			},\
+			/* STRUCT: SENSOR.reg[1] */\
+			{\
+				/* SENSOR.reg[1].addr */ 0x00000305, /* SENSOR.reg[1].para */ 0x0000000D\
+			},\
+			/* STRUCT: SENSOR.reg[2] */\
+			{\
+				/* SENSOR.reg[2].addr */ 0x00000306, /* SENSOR.reg[2].para */ 0x00000000\
+			},\
+			/* STRUCT: SENSOR.reg[3] */\
+			{\
+				/* SENSOR.reg[3].addr */ 0x00000307, /* SENSOR.reg[3].para */ 0x000000C0\
+			},\
+			/* STRUCT: SENSOR.reg[4] */\
+			{\
+				/* SENSOR.reg[4].addr */ 0x00000300, /* SENSOR.reg[4].para */ 0x00000000\
+			},\
+			/* STRUCT: SENSOR.reg[5] */\
+			{\
+				/* SENSOR.reg[5].addr */ 0x00000301, /* SENSOR.reg[5].para */ 0x00000004\
+			},\
+			/* STRUCT: SENSOR.reg[6] */\
+			{\
+				/* SENSOR.reg[6].addr */ 0x0000030A, /* SENSOR.reg[6].para */ 0x00000000\
+			},\
+			/* STRUCT: SENSOR.reg[7] */\
+			{\
+				/* SENSOR.reg[7].addr */ 0x0000030B, /* SENSOR.reg[7].para */ 0x00000002\
+			},\
+			/* STRUCT: SENSOR.reg[8] */\
+			{\
+				/* SENSOR.reg[8].addr */ 0x00000308, /* SENSOR.reg[8].para */ 0x00000000\
+			},\
+			/* STRUCT: SENSOR.reg[9] */\
+			{\
+				/* SENSOR.reg[9].addr */ 0x00000309, /* SENSOR.reg[9].para */ 0x00000008\
+			},\
+			/* STRUCT: SENSOR.reg[10] */\
+			{\
+				/* SENSOR.reg[10].addr */ 0xFFFFFFFF, /* SENSOR.reg[10].para */ 0x00000001\
+			}\
+		}
+
+#define CAMERA_SENSOR_CCT_DEFAULT_VALUE {{ 0xFFFFFFFF, 0x08 } ,{ 0x0209, 0x0008 } ,{ 0x0207, 0x0008 } ,{ 0x020D, 0x0008 } ,{ 0x020B, 0x0008 }}
+#endif /* __CAMERA_SENSOR_PARA_H */
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc0310main_mipi_yuv/gc0310mainmipi_yuv_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc0310main_mipi_yuv/gc0310mainmipi_yuv_Sensor.c
new file mode 100755
index 0000000..6e23d04
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc0310main_mipi_yuv/gc0310mainmipi_yuv_Sensor.c
@@ -0,0 +1,2123 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *   gc0310mainyuv_Sensor.c
+ *
+ * Project:
+ * --------
+ *   MAUI
+ *
+ * Description:
+ * ------------
+ *   Image sensor driver function
+ *   V1.2.3
+ *
+ * Author:
+ * -------
+ *   Leo
+ *
+ *=============================================================
+ *             HISTORY
+ * Below this line, this part is controlled by GCoreinc. DO NOT MODIFY!!
+ *------------------------------------------------------------------------------
+ * $Log$
+ * 2012.02.29  kill bugs
+ *   
+ *
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by GCoreinc. DO NOT MODIFY!!
+ *=============================================================
+ ******************************************************************************/
+#include <linux/videodev2.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <asm/atomic.h>
+
+#include "kd_camera_hw.h"
+#include "kd_imgsensor.h"
+#include "kd_imgsensor_define.h"
+#include "kd_imgsensor_errcode.h"
+#include "kd_camera_feature.h"
+
+#include "gc0310mainmipi_yuv_Sensor.h"
+#include "gc0310mainmipi_yuv_Camera_Sensor_para.h"
+#include "gc0310mainmipi_yuv_CameraCustomized.h"
+
+static DEFINE_SPINLOCK(GC0310MAIN_drv_lock);
+
+
+#define GC0310MAINYUV_DEBUG
+
+#ifdef GC0310MAINYUV_DEBUG
+#define SENSORDB printk
+#else
+#define SENSORDB(x,...)
+#endif
+
+#define GC0310MAIN_TEST_PATTERN_CHECKSUM (0x9db2de6e)
+
+kal_bool GC0310MAIN_night_mode_enable = KAL_FALSE;
+kal_uint16 GC0310MAIN_CurStatus_AWB = 0;
+
+
+static void GC0310MAIN_awb_enable(kal_bool enalbe);
+
+extern int iReadRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u8 * a_pRecvData, u16 a_sizeRecvData, u16 i2cId);
+extern int iWriteRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u16 i2cId);
+
+kal_uint16 GC0310MAIN_write_cmos_sensor(kal_uint8 addr, kal_uint8 para)
+{
+    char puSendCmd[2] = {(char)(addr & 0xFF) , (char)(para & 0xFF)};
+	
+	iWriteRegI2C(puSendCmd , 2, GC0310MAIN_WRITE_ID);
+
+}
+kal_uint16 GC0310MAIN_read_cmos_sensor(kal_uint8 addr)
+{
+	kal_uint16 get_byte=0;
+    char puSendCmd = { (char)(addr & 0xFF) };
+	iReadRegI2C(&puSendCmd , 1, (u8*)&get_byte, 1, GC0310MAIN_READ_ID);
+	
+    return get_byte;
+}
+
+
+/*******************************************************************************
+ * // Adapter for Winmo typedef
+ ********************************************************************************/
+#define WINMO_USE 0
+
+#define Sleep(ms) mdelay(ms)
+#define RETAILMSG(x,...)
+#define TEXT
+
+kal_bool   GC0310MAIN_MPEG4_encode_mode = KAL_FALSE;
+kal_uint16 GC0310MAIN_dummy_pixels = 0, GC0310MAIN_dummy_lines = 0;
+kal_bool   GC0310MAIN_MODE_CAPTURE = KAL_FALSE;
+kal_bool   GC0310MAIN_NIGHT_MODE = KAL_FALSE;
+
+kal_uint32 MINFramerate_main = 0;
+kal_uint32 MAXFramerate_main = 0;
+
+kal_uint32 GC0310MAIN_isp_master_clock;
+static kal_uint32 GC0310MAIN_g_fPV_PCLK = 30 * 1000000;
+
+kal_uint8 GC0310MAIN_sensor_write_I2C_address = GC0310MAIN_WRITE_ID;
+kal_uint8 GC0310MAIN_sensor_read_I2C_address = GC0310MAIN_READ_ID;
+
+UINT8 GC0310MAINPixelClockDivider=0;
+
+MSDK_SENSOR_CONFIG_STRUCT GC0310MAINSensorConfigData;
+
+#define GC0310MAIN_SET_PAGE0 	GC0310MAIN_write_cmos_sensor(0xfe, 0x00)
+#define GC0310MAIN_SET_PAGE1 	GC0310MAIN_write_cmos_sensor(0xfe, 0x01)
+#define GC0310MAIN_SET_PAGE2 	GC0310MAIN_write_cmos_sensor(0xfe, 0x02)
+#define GC0310MAIN_SET_PAGE3 	GC0310MAIN_write_cmos_sensor(0xfe, 0x03)
+
+/*************************************************************************
+ * FUNCTION
+ *	GC0310MAIN_SetShutter
+ *
+ * DESCRIPTION
+ *	This function set e-shutter of GC0310MAIN to change exposure time.
+ *
+ * PARAMETERS
+ *   iShutter : exposured lines
+ *
+ * RETURNS
+ *	None
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+void GC0310MAIN_Set_Shutter(kal_uint16 iShutter)
+{
+} /* Set_GC0310MAIN_Shutter */
+
+
+/*************************************************************************
+ * FUNCTION
+ *	GC0310MAIN_read_Shutter
+ *
+ * DESCRIPTION
+ *	This function read e-shutter of GC0310MAIN .
+ *
+ * PARAMETERS
+ *  None
+ *
+ * RETURNS
+ *	None
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+kal_uint16 GC0310MAIN_Read_Shutter(void)
+{
+    	kal_uint8 temp_reg1, temp_reg2;
+	kal_uint16 shutter;
+
+	temp_reg1 = GC0310MAIN_read_cmos_sensor(0x04);
+	temp_reg2 = GC0310MAIN_read_cmos_sensor(0x03);
+
+	shutter = (temp_reg1 & 0xFF) | (temp_reg2 << 8);
+
+	return shutter;
+} /* GC0310MAIN_read_shutter */
+
+static void GC0310MAIN_Set_Mirrorflip(kal_uint8 image_mirror)
+{
+	SENSORDB("image_mirror = %d\n", image_mirror);
+
+	switch (image_mirror)
+	{
+		case IMAGE_NORMAL://IMAGE_NORMAL:
+			GC0310MAIN_write_cmos_sensor(0x17,0x14);//bit[1][0]
+	//		write_cmos_sensor(0x92,0x03);
+	//		write_cmos_sensor(0x94,0x0b);
+			break;
+		case IMAGE_H_MIRROR://IMAGE_H_MIRROR:
+			GC0310MAIN_write_cmos_sensor(0x17,0x15);
+	//		GC2355_write_cmos_sensor(0x92,0x03);
+	//		GC2355_write_cmos_sensor(0x94,0x0b);
+			break;
+		case IMAGE_V_MIRROR://IMAGE_V_MIRROR:
+			GC0310MAIN_write_cmos_sensor(0x17,0x16);
+	//		GC2355_write_cmos_sensor(0x92,0x02);
+	//		GC2355_write_cmos_sensor(0x94,0x0b);
+			break;
+		case IMAGE_HV_MIRROR://IMAGE_HV_MIRROR:
+			GC0310MAIN_write_cmos_sensor(0x17,0x17);
+	//		GC2355_write_cmos_sensor(0x92,0x02);
+	//		GC2355_write_cmos_sensor(0x94,0x0b);
+			break;
+	}
+
+
+}
+
+static void GC0310MAIN_set_AE_mode(kal_bool AE_enable)
+{
+
+	SENSORDB("[GC0310MAIN]enter GC0310MAIN_set_AE_mode function, AE_enable = %d\n ", AE_enable);
+    if (AE_enable == KAL_TRUE)
+    {
+        // turn on AEC/AGC
+			SENSORDB("[GC0310MAIN]enter GC0310MAIN_set_AE_mode function 1\n ");
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00);
+			GC0310MAIN_write_cmos_sensor(0x4f, 0x01);
+    }
+    else
+    {
+        // turn off AEC/AGC
+			SENSORDB("[GC0310MAIN]enter GC0310MAIN_set_AE_mode function 2\n ");        
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00);
+			GC0310MAIN_write_cmos_sensor(0x4f, 0x00);
+    }   
+}
+
+
+void GC0310MAIN_set_contrast(UINT16 para)
+{   
+    SENSORDB("[GC0310MAIN]CONTROLFLOW enter GC0310MAIN_set_contrast function:\n ");
+#if 1
+    switch (para)
+    {
+        case ISP_CONTRAST_LOW:			 
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00);	 
+			GC0310MAIN_write_cmos_sensor(0xd3, 0x30);
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00); 
+			Sleep(200);
+			break;
+        case ISP_CONTRAST_HIGH:			 
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00); 	
+			GC0310MAIN_write_cmos_sensor(0xd3, 0x60);
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00);
+			Sleep(200);			
+			break;
+        case ISP_CONTRAST_MIDDLE: 
+        default:
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00);	 
+			GC0310MAIN_write_cmos_sensor(0xd3, 0x40);
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00);
+			Sleep(200);			
+			break;
+        //default:
+		//	break;
+    }
+    SENSORDB("[GC0310MAIN]exit GC0310MAIN_set_contrast function:\n ");
+    return;
+#endif    
+}
+
+UINT32 GC0310MAIN_MIPI_SetMaxFramerateByScenario(
+  MSDK_SCENARIO_ID_ENUM scenarioId, MUINT32 frameRate)
+{
+	SENSORDB("scenarioId = %d\n", scenarioId);
+}
+
+
+UINT32 GC0310MAINSetTestPatternMode(kal_bool bEnable)
+{
+	SENSORDB("[GC0310MAINSetTestPatternMode]test pattern bEnable:=%d\n",bEnable);
+
+	if(bEnable)
+	{
+		GC0310MAIN_write_cmos_sensor(0xfe,0x00);
+		GC0310MAIN_write_cmos_sensor(0x40,0x08); 
+		GC0310MAIN_write_cmos_sensor(0x41,0x00); 
+		GC0310MAIN_write_cmos_sensor(0x42,0x00); 
+		GC0310MAIN_write_cmos_sensor(0x4f,0x00); 
+		GC0310MAIN_write_cmos_sensor(0xfe,0x00); 
+		GC0310MAIN_write_cmos_sensor(0x03,0x03);
+		GC0310MAIN_write_cmos_sensor(0x04,0x9c); 
+		GC0310MAIN_write_cmos_sensor(0x71,0x20); 
+		GC0310MAIN_write_cmos_sensor(0x72,0x40); 
+		GC0310MAIN_write_cmos_sensor(0x73,0x80); 
+		GC0310MAIN_write_cmos_sensor(0x74,0x80); 
+		GC0310MAIN_write_cmos_sensor(0x75,0x80);
+		GC0310MAIN_write_cmos_sensor(0x76,0x80); 
+		GC0310MAIN_write_cmos_sensor(0x7a,0x80);
+		GC0310MAIN_write_cmos_sensor(0x7b,0x80);
+		GC0310MAIN_write_cmos_sensor(0x7c,0x80); 
+		GC0310MAIN_write_cmos_sensor(0x77,0x40); 
+		GC0310MAIN_write_cmos_sensor(0x78,0x40); 
+		GC0310MAIN_write_cmos_sensor(0x79,0x40); 
+		GC0310MAIN_write_cmos_sensor(0xfe,0x00); 
+		GC0310MAIN_write_cmos_sensor(0xfe,0x01); 
+		GC0310MAIN_write_cmos_sensor(0x12,0x00); 
+		GC0310MAIN_write_cmos_sensor(0x13,0x30); 
+		GC0310MAIN_write_cmos_sensor(0x44,0x00); 
+		GC0310MAIN_write_cmos_sensor(0x45,0x00); 
+		GC0310MAIN_write_cmos_sensor(0xfe,0x00); 
+		GC0310MAIN_write_cmos_sensor(0xd0,0x40); 
+		GC0310MAIN_write_cmos_sensor(0xd1,0x20); 
+		GC0310MAIN_write_cmos_sensor(0xd2,0x20);
+		GC0310MAIN_write_cmos_sensor(0xd3,0x40); 
+		GC0310MAIN_write_cmos_sensor(0xd5,0x00); 
+		GC0310MAIN_write_cmos_sensor(0xd8,0x00); 
+		GC0310MAIN_write_cmos_sensor(0xdd,0x00); 
+		GC0310MAIN_write_cmos_sensor(0xde,0x00);
+		GC0310MAIN_write_cmos_sensor(0xe4,0x00); 
+		GC0310MAIN_write_cmos_sensor(0xeb,0x00); 
+		GC0310MAIN_write_cmos_sensor(0xa4,0x00); 
+		GC0310MAIN_write_cmos_sensor(0x4c,0x21); 
+		
+		GC0310MAIN_write_cmos_sensor(0xfe,0x00);
+ 
+
+	}
+	else
+	{
+		GC0310MAIN_write_cmos_sensor(0xfe, 0x00);	
+		GC0310MAIN_write_cmos_sensor(0x4c, 0x20);
+		GC0310MAIN_write_cmos_sensor(0xfe, 0x00);
+	}
+	
+	return ERROR_NONE;
+}
+
+
+void GC0310MAIN_set_brightness(UINT16 para)
+{
+
+	SENSORDB("[GC0310MAIN]CONTROLFLOW enter GC0310MAIN_set_brightness function:\n ");
+#if 1
+	//return;
+    switch (para)
+    {
+        case ISP_BRIGHT_LOW:
+		//case AE_EV_COMP_n13:
+			GC0310MAIN_write_cmos_sensor(0xd5, 0xc0);
+			Sleep(200);
+			
+		//	GC0310MAIN_SET_PAGE1;
+		//	GC0310MAIN_write_cmos_sensor(0x13, 0x30);
+			GC0310MAIN_SET_PAGE0;
+		break;
+        case ISP_BRIGHT_HIGH:
+		//case AE_EV_COMP_13:
+			GC0310MAIN_write_cmos_sensor(0xd5, 0x70);
+			Sleep(200);
+		//	GC0310MAIN_SET_PAGE1;
+		//	GC0310MAIN_write_cmos_sensor(0x13, 0x90);
+		//	GC0310MAIN_SET_PAGE0;
+			break;
+        case ISP_BRIGHT_MIDDLE:
+        default:
+		//case AE_EV_COMP_00:
+			GC0310MAIN_write_cmos_sensor(0xd5, 0x40);
+			Sleep(200);
+		//	GC0310MAIN_SET_PAGE1;
+		//	GC0310MAIN_write_cmos_sensor(0x13, 0x60);
+		//	GC0310MAIN_SET_PAGE0;
+		break;
+		//	return KAL_FALSE;
+		//	break;
+    }
+    SENSORDB("[GC0310MAIN]exit GC0310MAIN_set_brightness function:\n ");
+    return;
+#endif    
+}
+void GC0310MAIN_set_saturation(UINT16 para)
+{
+	SENSORDB("[GC0310MAIN]CONTROLFLOW enter GC0310MAIN_set_saturation function:\n ");
+
+    switch (para)
+    {
+        case ISP_SAT_HIGH:
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00); 	
+			GC0310MAIN_write_cmos_sensor(0xd1, 0x45);
+			GC0310MAIN_write_cmos_sensor(0xd2, 0x45);			
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00);
+			break;
+        case ISP_SAT_LOW:
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00); 	
+			GC0310MAIN_write_cmos_sensor(0xd1, 0x28);
+			GC0310MAIN_write_cmos_sensor(0xd2, 0x28);	
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00);
+			break;
+        case ISP_SAT_MIDDLE:
+        default:
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00); 	
+			GC0310MAIN_write_cmos_sensor(0xd1, 0x34);
+			GC0310MAIN_write_cmos_sensor(0xd2, 0x34);	
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00);
+			break;
+		//	return KAL_FALSE;
+		//	break;
+    }
+	SENSORDB("[GC0310MAIN]exit GC0310MAIN_set_saturation function:\n ");
+     return;
+    
+}
+
+void GC0310MAIN_set_edge(UINT16 para)
+{
+	SENSORDB("[GC3010]CONTROLFLOW enter GC3010_set_saturation function:\n ");
+
+    switch (para)
+    {
+        case ISP_SAT_HIGH:
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00); 	
+			GC0310MAIN_write_cmos_sensor(0x95, 0x65);		
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00);
+			break;
+        case ISP_SAT_LOW:
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00); 	
+			GC0310MAIN_write_cmos_sensor(0x95, 0x25);
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00);
+			break;
+        case ISP_SAT_MIDDLE:
+        default:
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00); 	
+			GC0310MAIN_write_cmos_sensor(0x95, 0x45);
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00);
+			break;
+		//	return KAL_FALSE;
+		//	break;
+    }
+	SENSORDB("[GC0310MAIN]exit GC0310MAINMIPI_set_saturation function:\n ");
+     return;
+    
+}
+
+
+void GC0310MAIN_set_iso(UINT16 para)
+{
+
+	SENSORDB("[GC0310MAIN]CONTROLFLOW GC0310MAIN_set_iso:\n ");
+    switch (para)
+	{
+        case AE_ISO_100:
+             //ISO 100
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x01); 	
+			GC0310MAIN_write_cmos_sensor(0x44, 0x00);
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00);
+			break;
+        case AE_ISO_200:
+             //ISO 200
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x01); 	
+			GC0310MAIN_write_cmos_sensor(0x44, 0x01);
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00);
+			break;
+        case AE_ISO_400:
+             //ISO 400
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x01); 	
+			GC0310MAIN_write_cmos_sensor(0x44, 0x02);
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00);
+			break;
+		case AE_ISO_AUTO:
+		default:
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x01); 	
+			GC0310MAIN_write_cmos_sensor(0x44, 0x02);
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00);
+			break;
+	}
+    return;  
+}
+
+
+
+void GC0310MAINStreamOn(void)
+{
+	//Sleep(150);
+    GC0310MAIN_write_cmos_sensor(0xfe,0x03);
+    GC0310MAIN_write_cmos_sensor(0x10,0x94); 
+    GC0310MAIN_write_cmos_sensor(0xfe,0x00);    
+    Sleep(50);	
+}
+
+void GC0310MAIN_MIPI_GetDelayInfo(uintptr_t delayAddr)
+{
+    SENSOR_DELAY_INFO_STRUCT* pDelayInfo = (SENSOR_DELAY_INFO_STRUCT*)delayAddr;
+    pDelayInfo->InitDelay = 2;
+    pDelayInfo->EffectDelay = 2;
+    pDelayInfo->AwbDelay = 2;
+    pDelayInfo->AFSwitchDelayFrame = 50;
+}
+
+UINT32 GC0310MAIN_MIPI_GetDefaultFramerateByScenario(
+  MSDK_SCENARIO_ID_ENUM scenarioId, MUINT32 *pframeRate)
+{
+    switch (scenarioId)
+    {
+        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+             *pframeRate = 300;
+             break;
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+        case MSDK_SCENARIO_ID_CAMERA_ZSD:
+             *pframeRate = 300;
+             break;
+        case MSDK_SCENARIO_ID_CAMERA_3D_PREVIEW: //added
+        case MSDK_SCENARIO_ID_CAMERA_3D_VIDEO:
+        case MSDK_SCENARIO_ID_CAMERA_3D_CAPTURE: //added
+             *pframeRate = 300;
+             break;
+        default:
+             *pframeRate = 300;
+          break;
+    }
+
+  return ERROR_NONE;
+}
+
+void GC0310MAIN_MIPI_SetMaxMinFps(UINT32 u2MinFrameRate, UINT32 u2MaxFrameRate)
+{
+	SENSORDB("GC0310MAIN_MIPI_SetMaxMinFps+ :FrameRate= %d %d\n",u2MinFrameRate,u2MaxFrameRate);
+	spin_lock(&GC0310MAIN_drv_lock);
+	MINFramerate_main = u2MinFrameRate;
+	MAXFramerate_main = u2MaxFrameRate;
+	spin_unlock(&GC0310MAIN_drv_lock);
+	return;
+}
+
+void GC0310MAIN_3ACtrl(ACDK_SENSOR_3A_LOCK_ENUM action)
+{
+	SENSORDB("[GC0329]enter ACDK_SENSOR_3A_LOCK_ENUM function:action=%d\n",action);
+   switch (action)
+   {
+      case SENSOR_3A_AE_LOCK:
+          GC0310MAIN_set_AE_mode(KAL_FALSE);
+      break;
+      case SENSOR_3A_AE_UNLOCK:
+          GC0310MAIN_set_AE_mode(KAL_TRUE);
+      break;
+
+      case SENSOR_3A_AWB_LOCK:
+          GC0310MAIN_awb_enable(KAL_FALSE);       
+      break;
+
+      case SENSOR_3A_AWB_UNLOCK:
+		   if (((AWB_MODE_OFF == GC0310MAIN_CurStatus_AWB) ||
+        		(AWB_MODE_AUTO == GC0310MAIN_CurStatus_AWB)))
+        	{	
+         			 GC0310MAIN_awb_enable(KAL_TRUE);
+         	}
+      break;
+      default:
+      	break;
+   }
+   SENSORDB("[GC0329]exit ACDK_SENSOR_3A_LOCK_ENUM function:action=%d\n",action);
+   return;
+}
+
+
+void GC0310MAIN_MIPI_GetExifInfo(uintptr_t exifAddr)
+{
+    SENSOR_EXIF_INFO_STRUCT* pExifInfo = (SENSOR_EXIF_INFO_STRUCT*)exifAddr;
+    pExifInfo->FNumber = 28;
+//    pExifInfo->AEISOSpeed = GC0310MAIN_Driver.isoSpeed;
+//    pExifInfo->AWBMode = S5K4ECGX_Driver.awbMode;
+//    pExifInfo->CapExposureTime = S5K4ECGX_Driver.capExposureTime;
+//    pExifInfo->FlashLightTimeus = 0;
+//   pExifInfo->RealISOValue = (S5K4ECGX_MIPI_ReadGain()*57) >> 8;
+        //S5K4ECGX_Driver.isoSpeed;
+}
+
+#if 0
+void GC0310MAIN_MIPI_get_AEAWB_lock(uintptr_t pAElockRet32, uintptr_t pAWBlockRet32)
+{
+    *pAElockRet32 = 1;
+    *pAWBlockRet32 = 1;
+    SENSORDB("[GC0310MAIN]GetAEAWBLock,AE=%d ,AWB=%d\n,",(int)*pAElockRet32, (int)*pAWBlockRet32);
+}
+#endif
+
+/*************************************************************************
+ * FUNCTION
+ *	GC0310MAIN_write_reg
+ *
+ * DESCRIPTION
+ *	This function set the register of GC0310MAIN.
+ *
+ * PARAMETERS
+ *	addr : the register index of GC0310MAIN
+ *  para : setting parameter of the specified register of GC0310MAIN
+ *
+ * RETURNS
+ *	None
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+void GC0310MAIN_write_reg(kal_uint32 addr, kal_uint32 para)
+{
+	GC0310MAIN_write_cmos_sensor(addr, para);
+} /* GC0310MAIN_write_reg() */
+
+
+/*************************************************************************
+ * FUNCTION
+ *	GC0310MAIN_read_cmos_sensor
+ *
+ * DESCRIPTION
+ *	This function read parameter of specified register from GC0310MAIN.
+ *
+ * PARAMETERS
+ *	addr : the register index of GC0310MAIN
+ *
+ * RETURNS
+ *	the data that read from GC0310MAIN
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+kal_uint32 GC0310MAIN_read_reg(kal_uint32 addr)
+{
+	return GC0310MAIN_read_cmos_sensor(addr);
+} /* OV7670_read_reg() */
+
+
+/*************************************************************************
+* FUNCTION
+*	GC0310MAIN_awb_enable
+*
+* DESCRIPTION
+*	This function enable or disable the awb (Auto White Balance).
+*
+* PARAMETERS
+*	1. kal_bool : KAL_TRUE - enable awb, KAL_FALSE - disable awb.
+*
+* RETURNS
+*	kal_bool : It means set awb right or not.
+*
+*************************************************************************/
+static void GC0310MAIN_awb_enable(kal_bool enalbe)
+{	 
+	kal_uint16 temp_AWB_reg = 0;
+	
+	GC0310MAIN_write_cmos_sensor(0xfe, 0x00); 	
+	temp_AWB_reg = GC0310MAIN_read_cmos_sensor(0x42);
+	
+	if (enalbe)
+	{
+		GC0310MAIN_write_cmos_sensor(0x42, (temp_AWB_reg |0x02));
+	}
+	else
+	{
+		GC0310MAIN_write_cmos_sensor(0x42, (temp_AWB_reg & (~0x02)));
+	}
+	GC0310MAIN_write_cmos_sensor(0xfe, 0x00); 	
+
+}
+
+
+/*************************************************************************
+* FUNCTION
+*	GC0310MAIN_GAMMA_Select
+*
+* DESCRIPTION
+*	This function is served for FAE to select the appropriate GAMMA curve.
+*
+* PARAMETERS
+*	None
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+void GC0310MAINGammaSelect(kal_uint32 GammaLvl)
+{
+	switch(GammaLvl)
+	{
+		case GC0310MAIN_RGB_Gamma_m1:						//smallest gamma curve
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00);
+			GC0310MAIN_write_cmos_sensor(0xbf, 0x06);
+			GC0310MAIN_write_cmos_sensor(0xc0, 0x12);
+			GC0310MAIN_write_cmos_sensor(0xc1, 0x22);
+			GC0310MAIN_write_cmos_sensor(0xc2, 0x35);
+			GC0310MAIN_write_cmos_sensor(0xc3, 0x4b);
+			GC0310MAIN_write_cmos_sensor(0xc4, 0x5f);
+			GC0310MAIN_write_cmos_sensor(0xc5, 0x72);
+			GC0310MAIN_write_cmos_sensor(0xc6, 0x8d);
+			GC0310MAIN_write_cmos_sensor(0xc7, 0xa4);
+			GC0310MAIN_write_cmos_sensor(0xc8, 0xb8);
+			GC0310MAIN_write_cmos_sensor(0xc9, 0xc8);
+			GC0310MAIN_write_cmos_sensor(0xca, 0xd4);
+			GC0310MAIN_write_cmos_sensor(0xcb, 0xde);
+			GC0310MAIN_write_cmos_sensor(0xcc, 0xe6);
+			GC0310MAIN_write_cmos_sensor(0xcd, 0xf1);
+			GC0310MAIN_write_cmos_sensor(0xce, 0xf8);
+			GC0310MAIN_write_cmos_sensor(0xcf, 0xfd);
+			break;
+		case GC0310MAIN_RGB_Gamma_m2:
+			GC0310MAIN_write_cmos_sensor(0xBF, 0x08);
+			GC0310MAIN_write_cmos_sensor(0xc0, 0x0F);
+			GC0310MAIN_write_cmos_sensor(0xc1, 0x21);
+			GC0310MAIN_write_cmos_sensor(0xc2, 0x32);
+			GC0310MAIN_write_cmos_sensor(0xc3, 0x43);
+			GC0310MAIN_write_cmos_sensor(0xc4, 0x50);
+			GC0310MAIN_write_cmos_sensor(0xc5, 0x5E);
+			GC0310MAIN_write_cmos_sensor(0xc6, 0x78);
+			GC0310MAIN_write_cmos_sensor(0xc7, 0x90);
+			GC0310MAIN_write_cmos_sensor(0xc8, 0xA6);
+			GC0310MAIN_write_cmos_sensor(0xc9, 0xB9);
+			GC0310MAIN_write_cmos_sensor(0xcA, 0xC9);
+			GC0310MAIN_write_cmos_sensor(0xcB, 0xD6);
+			GC0310MAIN_write_cmos_sensor(0xcC, 0xE0);
+			GC0310MAIN_write_cmos_sensor(0xcD, 0xEE);
+			GC0310MAIN_write_cmos_sensor(0xcE, 0xF8);
+			GC0310MAIN_write_cmos_sensor(0xcF, 0xFF);
+			break;
+			
+		case GC0310MAIN_RGB_Gamma_m3:			
+			GC0310MAIN_write_cmos_sensor(0xbf , 0x0b);
+			GC0310MAIN_write_cmos_sensor(0xc0 , 0x17);
+			GC0310MAIN_write_cmos_sensor(0xc1 , 0x2a);
+			GC0310MAIN_write_cmos_sensor(0xc2 , 0x41);
+			GC0310MAIN_write_cmos_sensor(0xc3 , 0x54);
+			GC0310MAIN_write_cmos_sensor(0xc4 , 0x66);
+			GC0310MAIN_write_cmos_sensor(0xc5 , 0x74);
+			GC0310MAIN_write_cmos_sensor(0xc6 , 0x8c);
+			GC0310MAIN_write_cmos_sensor(0xc7 , 0xa3);
+			GC0310MAIN_write_cmos_sensor(0xc8 , 0xb5);
+			GC0310MAIN_write_cmos_sensor(0xc9 , 0xc4);
+			GC0310MAIN_write_cmos_sensor(0xca , 0xd0);
+			GC0310MAIN_write_cmos_sensor(0xcb , 0xdb);
+			GC0310MAIN_write_cmos_sensor(0xcc , 0xe5);
+			GC0310MAIN_write_cmos_sensor(0xcd , 0xf0);
+			GC0310MAIN_write_cmos_sensor(0xce , 0xf7);
+			GC0310MAIN_write_cmos_sensor(0xcf , 0xff);
+			break;
+			
+		case GC0310MAIN_RGB_Gamma_m4:
+			GC0310MAIN_write_cmos_sensor(0xBF, 0x0E);
+			GC0310MAIN_write_cmos_sensor(0xc0, 0x1C);
+			GC0310MAIN_write_cmos_sensor(0xc1, 0x34);
+			GC0310MAIN_write_cmos_sensor(0xc2, 0x48);
+			GC0310MAIN_write_cmos_sensor(0xc3, 0x5A);
+			GC0310MAIN_write_cmos_sensor(0xc4, 0x6B);
+			GC0310MAIN_write_cmos_sensor(0xc5, 0x7B);
+			GC0310MAIN_write_cmos_sensor(0xc6, 0x95);
+			GC0310MAIN_write_cmos_sensor(0xc7, 0xAB);
+			GC0310MAIN_write_cmos_sensor(0xc8, 0xBF);
+			GC0310MAIN_write_cmos_sensor(0xc9, 0xCE);
+			GC0310MAIN_write_cmos_sensor(0xcA, 0xD9);
+			GC0310MAIN_write_cmos_sensor(0xcB, 0xE4);
+			GC0310MAIN_write_cmos_sensor(0xcC, 0xEC);
+			GC0310MAIN_write_cmos_sensor(0xcD, 0xF7);
+			GC0310MAIN_write_cmos_sensor(0xcE, 0xFD);
+			GC0310MAIN_write_cmos_sensor(0xcF, 0xFF);
+			break;
+			
+		case GC0310MAIN_RGB_Gamma_m5:
+			GC0310MAIN_write_cmos_sensor(0xBF, 0x10);
+			GC0310MAIN_write_cmos_sensor(0xc0, 0x20);
+			GC0310MAIN_write_cmos_sensor(0xc1, 0x38);
+			GC0310MAIN_write_cmos_sensor(0xc2, 0x4E);
+			GC0310MAIN_write_cmos_sensor(0xc3, 0x63);
+			GC0310MAIN_write_cmos_sensor(0xc4, 0x76);
+			GC0310MAIN_write_cmos_sensor(0xc5, 0x87);
+			GC0310MAIN_write_cmos_sensor(0xc6, 0xA2);
+			GC0310MAIN_write_cmos_sensor(0xc7, 0xB8);
+			GC0310MAIN_write_cmos_sensor(0xc8, 0xCA);
+			GC0310MAIN_write_cmos_sensor(0xc9, 0xD8);
+			GC0310MAIN_write_cmos_sensor(0xcA, 0xE3);
+			GC0310MAIN_write_cmos_sensor(0xcB, 0xEB);
+			GC0310MAIN_write_cmos_sensor(0xcC, 0xF0);
+			GC0310MAIN_write_cmos_sensor(0xcD, 0xF8);
+			GC0310MAIN_write_cmos_sensor(0xcE, 0xFD);
+			GC0310MAIN_write_cmos_sensor(0xcF, 0xFF);
+			break;
+			
+		case GC0310MAIN_RGB_Gamma_m6:										// largest gamma curve
+			GC0310MAIN_write_cmos_sensor(0xBF, 0x14);
+			GC0310MAIN_write_cmos_sensor(0xc0, 0x28);
+			GC0310MAIN_write_cmos_sensor(0xc1, 0x44);
+			GC0310MAIN_write_cmos_sensor(0xc2, 0x5D);
+			GC0310MAIN_write_cmos_sensor(0xc3, 0x72);
+			GC0310MAIN_write_cmos_sensor(0xc4, 0x86);
+			GC0310MAIN_write_cmos_sensor(0xc5, 0x95);
+			GC0310MAIN_write_cmos_sensor(0xc6, 0xB1);
+			GC0310MAIN_write_cmos_sensor(0xc7, 0xC6);
+			GC0310MAIN_write_cmos_sensor(0xc8, 0xD5);
+			GC0310MAIN_write_cmos_sensor(0xc9, 0xE1);
+			GC0310MAIN_write_cmos_sensor(0xcA, 0xEA);
+			GC0310MAIN_write_cmos_sensor(0xcB, 0xF1);
+			GC0310MAIN_write_cmos_sensor(0xcC, 0xF5);
+			GC0310MAIN_write_cmos_sensor(0xcD, 0xFB);
+			GC0310MAIN_write_cmos_sensor(0xcE, 0xFE);
+			GC0310MAIN_write_cmos_sensor(0xcF, 0xFF);
+			break;
+		case GC0310MAIN_RGB_Gamma_night:									//Gamma for night mode
+			GC0310MAIN_write_cmos_sensor(0xBF, 0x0B);
+			GC0310MAIN_write_cmos_sensor(0xc0, 0x16);
+			GC0310MAIN_write_cmos_sensor(0xc1, 0x29);
+			GC0310MAIN_write_cmos_sensor(0xc2, 0x3C);
+			GC0310MAIN_write_cmos_sensor(0xc3, 0x4F);
+			GC0310MAIN_write_cmos_sensor(0xc4, 0x5F);
+			GC0310MAIN_write_cmos_sensor(0xc5, 0x6F);
+			GC0310MAIN_write_cmos_sensor(0xc6, 0x8A);
+			GC0310MAIN_write_cmos_sensor(0xc7, 0x9F);
+			GC0310MAIN_write_cmos_sensor(0xc8, 0xB4);
+			GC0310MAIN_write_cmos_sensor(0xc9, 0xC6);
+			GC0310MAIN_write_cmos_sensor(0xcA, 0xD3);
+			GC0310MAIN_write_cmos_sensor(0xcB, 0xDD);
+			GC0310MAIN_write_cmos_sensor(0xcC, 0xE5);
+			GC0310MAIN_write_cmos_sensor(0xcD, 0xF1);
+			GC0310MAIN_write_cmos_sensor(0xcE, 0xFA);
+			GC0310MAIN_write_cmos_sensor(0xcF, 0xFF);
+			break;
+		default:
+			//GC0310MAIN_RGB_Gamma_m1
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00);
+			GC0310MAIN_write_cmos_sensor(0xbf , 0x0b);
+			GC0310MAIN_write_cmos_sensor(0xc0 , 0x17);
+			GC0310MAIN_write_cmos_sensor(0xc1 , 0x2a);
+			GC0310MAIN_write_cmos_sensor(0xc2 , 0x41);
+			GC0310MAIN_write_cmos_sensor(0xc3 , 0x54);
+			GC0310MAIN_write_cmos_sensor(0xc4 , 0x66);
+			GC0310MAIN_write_cmos_sensor(0xc5 , 0x74);
+			GC0310MAIN_write_cmos_sensor(0xc6 , 0x8c);
+			GC0310MAIN_write_cmos_sensor(0xc7 , 0xa3);
+			GC0310MAIN_write_cmos_sensor(0xc8 , 0xb5);
+			GC0310MAIN_write_cmos_sensor(0xc9 , 0xc4);
+			GC0310MAIN_write_cmos_sensor(0xca , 0xd0);
+			GC0310MAIN_write_cmos_sensor(0xcb , 0xdb);
+			GC0310MAIN_write_cmos_sensor(0xcc , 0xe5);
+			GC0310MAIN_write_cmos_sensor(0xcd , 0xf0);
+			GC0310MAIN_write_cmos_sensor(0xce , 0xf7);
+			GC0310MAIN_write_cmos_sensor(0xcf , 0xff);
+			break;
+	}
+}
+
+
+/*************************************************************************
+ * FUNCTION
+ *	GC0310MAIN_config_window
+ *
+ * DESCRIPTION
+ *	This function config the hardware window of GC0310MAIN for getting specified
+ *  data of that window.
+ *
+ * PARAMETERS
+ *	start_x : start column of the interested window
+ *  start_y : start row of the interested window
+ *  width  : column widht of the itnerested window
+ *  height : row depth of the itnerested window
+ *
+ * RETURNS
+ *	the data that read from GC0310MAIN
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+void GC0310MAIN_config_window(kal_uint16 startx, kal_uint16 starty, kal_uint16 width, kal_uint16 height)
+{
+} /* GC0310MAIN_config_window */
+
+
+/*************************************************************************
+ * FUNCTION
+ *	GC0310MAIN_SetGain
+ *
+ * DESCRIPTION
+ *	This function is to set global gain to sensor.
+ *
+ * PARAMETERS
+ *   iGain : sensor global gain(base: 0x40)
+ *
+ * RETURNS
+ *	the actually gain set to sensor.
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+kal_uint16 GC0310MAIN_SetGain(kal_uint16 iGain)
+{
+	return iGain;
+}
+
+
+/*************************************************************************
+ * FUNCTION
+ *	GC0310MAIN_NightMode
+ *
+ * DESCRIPTION
+ *	This function night mode of GC0310MAIN.
+ *
+ * PARAMETERS
+ *	bEnable: KAL_TRUE -> enable night mode, otherwise, disable night mode
+ *
+ * RETURNS
+ *	None
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+void GC0310MAINNightMode(kal_bool bEnable)
+{
+	SENSORDB("Enter GC0310MAINNightMode!, bEnable = %d, GC0310MAIN_MPEG4_encode_mode = %d\n", bEnable, GC0310MAIN_MPEG4_encode_mode);
+
+	spin_lock(&GC0310MAIN_drv_lock);
+	GC0310MAIN_night_mode_enable = bEnable;
+	spin_unlock(&GC0310MAIN_drv_lock);	
+	
+	if (GC0310MAIN_night_mode_enable)	// night mode
+	{	
+		GC0310MAIN_write_cmos_sensor(0xfe, 0x00);
+		if(MAXFramerate_main == 15)	// video
+		{
+			GC0310MAIN_write_cmos_sensor(0xf7, 0x33);		
+			GC0310MAIN_write_cmos_sensor(0xfa, 0x32);
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x01);
+			GC0310MAIN_write_cmos_sensor(0x3c, 0x00);
+		}	
+		else
+		{	
+			GC0310MAIN_write_cmos_sensor(0xf7, 0x1b);				
+			GC0310MAIN_write_cmos_sensor(0xfa, 0x11);
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x01);
+			GC0310MAIN_write_cmos_sensor(0x3c, 0x30);
+//			Sleep(50);	
+		}	
+		GC0310MAIN_write_cmos_sensor(0xfe, 0x00);	
+	}
+	else 
+	{
+		GC0310MAIN_write_cmos_sensor(0xfe, 0x00);
+		if(MINFramerate_main == 15)  // video
+		{
+			GC0310MAIN_write_cmos_sensor(0xf7, 0x1b);
+			GC0310MAIN_write_cmos_sensor(0xfa, 0x11);			
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x01);
+			GC0310MAIN_write_cmos_sensor(0x3c, 0x00);
+		}	
+		else
+		{
+			GC0310MAIN_write_cmos_sensor(0xf7, 0x1b);
+			GC0310MAIN_write_cmos_sensor(0xfa, 0x11);			
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x01);
+			GC0310MAIN_write_cmos_sensor(0x3c, 0x20);
+		}
+		GC0310MAIN_write_cmos_sensor(0xfe, 0x00);	
+	}
+	
+} /* GC0310MAIN_NightMode */
+
+/*************************************************************************
+* FUNCTION
+*	GC0310MAIN_Sensor_Init
+*
+* DESCRIPTION
+*	This function apply all of the initial setting to sensor.
+*
+* PARAMETERS
+*	None
+*
+* RETURNS
+*	None
+*
+*************************************************************************/
+void GC0310MAIN_Sensor_Init(void)
+{
+    GC0310MAIN_write_cmos_sensor(0xfe,0xf0);
+    GC0310MAIN_write_cmos_sensor(0xfe,0xf0);
+    GC0310MAIN_write_cmos_sensor(0xfe,0x00);
+    GC0310MAIN_write_cmos_sensor(0xfc,0x0e);
+    GC0310MAIN_write_cmos_sensor(0xfc,0x0e);
+    GC0310MAIN_write_cmos_sensor(0xf2,0x80);
+    GC0310MAIN_write_cmos_sensor(0xf3,0x00);
+    GC0310MAIN_write_cmos_sensor(0xf7,0x1b);
+    GC0310MAIN_write_cmos_sensor(0xf8,0x04);  // from 03 to 04
+    GC0310MAIN_write_cmos_sensor(0xf9,0x8e);
+    GC0310MAIN_write_cmos_sensor(0xfa,0x11);
+     /////////////////////////////////////////////////      
+	///////////////////   MIPI   ////////////////////      
+	/////////////////////////////////////////////////      
+	GC0310MAIN_write_cmos_sensor(0xfe,0x03);
+	GC0310MAIN_write_cmos_sensor(0x40,0x08);
+	GC0310MAIN_write_cmos_sensor(0x42,0x00);
+	GC0310MAIN_write_cmos_sensor(0x43,0x00);
+	GC0310MAIN_write_cmos_sensor(0x01,0x03);
+	GC0310MAIN_write_cmos_sensor(0x10,0x84);
+                                        
+	GC0310MAIN_write_cmos_sensor(0x01,0x03);             
+	GC0310MAIN_write_cmos_sensor(0x02,0x00);             
+	GC0310MAIN_write_cmos_sensor(0x03,0x94);             
+	GC0310MAIN_write_cmos_sensor(0x04,0x01);            
+	GC0310MAIN_write_cmos_sensor(0x05,0x40);  // 40      20     
+	GC0310MAIN_write_cmos_sensor(0x06,0x80);             
+	GC0310MAIN_write_cmos_sensor(0x11,0x1e);             
+	GC0310MAIN_write_cmos_sensor(0x12,0x00);      
+	GC0310MAIN_write_cmos_sensor(0x13,0x05);             
+	GC0310MAIN_write_cmos_sensor(0x15,0x10);                                                                    
+	GC0310MAIN_write_cmos_sensor(0x21,0x10);             
+	GC0310MAIN_write_cmos_sensor(0x22,0x01);             
+	GC0310MAIN_write_cmos_sensor(0x23,0x10);                                             
+	GC0310MAIN_write_cmos_sensor(0x24,0x02);                                             
+	GC0310MAIN_write_cmos_sensor(0x25,0x10);                                             
+	GC0310MAIN_write_cmos_sensor(0x26,0x03);                                             
+	GC0310MAIN_write_cmos_sensor(0x29,0x02); //02                                            
+	GC0310MAIN_write_cmos_sensor(0x2a,0x0a);   //0a                                          
+	GC0310MAIN_write_cmos_sensor(0x2b,0x04);                                             
+	GC0310MAIN_write_cmos_sensor(0xfe,0x00);
+        /////////////////////////////////////////////////
+        /////////////////   CISCTL reg  /////////////////
+        /////////////////////////////////////////////////
+    GC0310MAIN_write_cmos_sensor(0x00,0x2f);
+    GC0310MAIN_write_cmos_sensor(0x01,0x0f);
+    GC0310MAIN_write_cmos_sensor(0x02,0x04);
+    GC0310MAIN_write_cmos_sensor(0x03,0x04);
+    GC0310MAIN_write_cmos_sensor(0x04,0xd0);
+    GC0310MAIN_write_cmos_sensor(0x09,0x00);
+    GC0310MAIN_write_cmos_sensor(0x0a,0x00);
+    GC0310MAIN_write_cmos_sensor(0x0b,0x00);
+    GC0310MAIN_write_cmos_sensor(0x0c,0x06);
+    GC0310MAIN_write_cmos_sensor(0x0d,0x01);
+    GC0310MAIN_write_cmos_sensor(0x0e,0xe8);
+    GC0310MAIN_write_cmos_sensor(0x0f,0x02);
+    GC0310MAIN_write_cmos_sensor(0x10,0x88);
+    GC0310MAIN_write_cmos_sensor(0x16,0x00);
+    GC0310MAIN_write_cmos_sensor(0x17,0x17); //0x14
+    GC0310MAIN_write_cmos_sensor(0x18,0x1a);
+    GC0310MAIN_write_cmos_sensor(0x19,0x14);
+    GC0310MAIN_write_cmos_sensor(0x1b,0x48);
+    GC0310MAIN_write_cmos_sensor(0x1e,0x6b);
+    GC0310MAIN_write_cmos_sensor(0x1f,0x28);
+    GC0310MAIN_write_cmos_sensor(0x20,0x8b);  // from 89 to 8b
+    GC0310MAIN_write_cmos_sensor(0x21,0x49);
+    GC0310MAIN_write_cmos_sensor(0x22,0xb0);
+    GC0310MAIN_write_cmos_sensor(0x23,0x04);
+    GC0310MAIN_write_cmos_sensor(0x24,0x16);
+    GC0310MAIN_write_cmos_sensor(0x34,0x20);
+        
+        /////////////////////////////////////////////////
+        ////////////////////   BLK   ////////////////////
+        /////////////////////////////////////////////////
+    GC0310MAIN_write_cmos_sensor(0x26,0x23); 
+    GC0310MAIN_write_cmos_sensor(0x28,0xff); 
+    GC0310MAIN_write_cmos_sensor(0x29,0x00); 
+    GC0310MAIN_write_cmos_sensor(0x33,0x10); 
+    GC0310MAIN_write_cmos_sensor(0x37,0x20); 
+	GC0310MAIN_write_cmos_sensor(0x38,0x10); 
+    GC0310MAIN_write_cmos_sensor(0x47,0x80); 
+    GC0310MAIN_write_cmos_sensor(0x4e,0x66); 
+    GC0310MAIN_write_cmos_sensor(0xa8,0x02); 
+    GC0310MAIN_write_cmos_sensor(0xa9,0x80);
+        
+        /////////////////////////////////////////////////
+        //////////////////   ISP reg  ///////////////////
+        /////////////////////////////////////////////////
+    GC0310MAIN_write_cmos_sensor(0x40,0xff); 
+    GC0310MAIN_write_cmos_sensor(0x41,0x21); 
+    GC0310MAIN_write_cmos_sensor(0x42,0xcf); 
+    GC0310MAIN_write_cmos_sensor(0x44,0x01); // 02 yuv 
+    GC0310MAIN_write_cmos_sensor(0x45,0xa0); // from a8 - a4 a4-a0
+    GC0310MAIN_write_cmos_sensor(0x46,0x03); 
+    GC0310MAIN_write_cmos_sensor(0x4a,0x11);
+    GC0310MAIN_write_cmos_sensor(0x4b,0x01);
+    GC0310MAIN_write_cmos_sensor(0x4c,0x20); 
+    GC0310MAIN_write_cmos_sensor(0x4d,0x05); 
+    GC0310MAIN_write_cmos_sensor(0x4f,0x01);
+    GC0310MAIN_write_cmos_sensor(0x50,0x01); 
+    GC0310MAIN_write_cmos_sensor(0x55,0x01); 
+    GC0310MAIN_write_cmos_sensor(0x56,0xe0);
+    GC0310MAIN_write_cmos_sensor(0x57,0x02); 
+    GC0310MAIN_write_cmos_sensor(0x58,0x80);
+        
+        /////////////////////////////////////////////////  
+        ///////////////////   GAIN   ////////////////////
+        /////////////////////////////////////////////////
+    GC0310MAIN_write_cmos_sensor(0x70,0x70); 
+    GC0310MAIN_write_cmos_sensor(0x5a,0x84); 
+    GC0310MAIN_write_cmos_sensor(0x5b,0xc9); 
+    GC0310MAIN_write_cmos_sensor(0x5c,0xed); 
+    GC0310MAIN_write_cmos_sensor(0x77,0x74); 
+    GC0310MAIN_write_cmos_sensor(0x78,0x40); 
+    GC0310MAIN_write_cmos_sensor(0x79,0x5f); 
+        
+        ///////////////////////////////////////////////// 
+        ///////////////////   DNDD  /////////////////////
+        ///////////////////////////////////////////////// 
+    GC0310MAIN_write_cmos_sensor(0x82,0x1f); 
+    GC0310MAIN_write_cmos_sensor(0x83,0x0b);
+        
+        
+        ///////////////////////////////////////////////// 
+        //////////////////   EEINTP  ////////////////////
+        ///////////////////////////////////////////////// 
+    GC0310MAIN_write_cmos_sensor(0x8f,0xff); 
+    GC0310MAIN_write_cmos_sensor(0x90,0x9f); 
+    GC0310MAIN_write_cmos_sensor(0x91,0x90); 
+    GC0310MAIN_write_cmos_sensor(0x92,0x03); 
+    GC0310MAIN_write_cmos_sensor(0x93,0x03); 
+    GC0310MAIN_write_cmos_sensor(0x94,0x05);
+    GC0310MAIN_write_cmos_sensor(0x95,0x65); 
+    GC0310MAIN_write_cmos_sensor(0x96,0xf0); 
+        
+        ///////////////////////////////////////////////// 
+        /////////////////////  ASDE  ////////////////////
+        ///////////////////////////////////////////////// 
+    GC0310MAIN_write_cmos_sensor(0xfe,0x00);
+    GC0310MAIN_write_cmos_sensor(0x9a,0x20);
+    GC0310MAIN_write_cmos_sensor(0x9b,0x80);
+    GC0310MAIN_write_cmos_sensor(0x9c,0x40);
+    GC0310MAIN_write_cmos_sensor(0x9d,0x80);
+    GC0310MAIN_write_cmos_sensor(0xa1,0x30);
+    GC0310MAIN_write_cmos_sensor(0xa2,0x32);
+    GC0310MAIN_write_cmos_sensor(0xa4,0x30);
+    GC0310MAIN_write_cmos_sensor(0xa5,0x30);
+    GC0310MAIN_write_cmos_sensor(0xaa,0x50);
+    GC0310MAIN_write_cmos_sensor(0xac,0x22);
+        
+        /////////////////////////////////////////////////
+        ///////////////////   GAMMA   ///////////////////
+        /////////////////////////////////////////////////
+    GC0310MAIN_write_cmos_sensor(0xbf,0x08); 
+    GC0310MAIN_write_cmos_sensor(0xc0,0x16); 
+    GC0310MAIN_write_cmos_sensor(0xc1,0x28); 
+    GC0310MAIN_write_cmos_sensor(0xc2,0x41); 
+    GC0310MAIN_write_cmos_sensor(0xc3,0x5a); 
+    GC0310MAIN_write_cmos_sensor(0xc4,0x6c); 
+    GC0310MAIN_write_cmos_sensor(0xc5,0x7a); 
+    GC0310MAIN_write_cmos_sensor(0xc6,0x96); 
+    GC0310MAIN_write_cmos_sensor(0xc7,0xac); 
+    GC0310MAIN_write_cmos_sensor(0xc8,0xbc); 
+    GC0310MAIN_write_cmos_sensor(0xc9,0xc9); 
+    GC0310MAIN_write_cmos_sensor(0xca,0xd3); 
+    GC0310MAIN_write_cmos_sensor(0xcb,0xdd); 
+    GC0310MAIN_write_cmos_sensor(0xcc,0xe5); 
+    GC0310MAIN_write_cmos_sensor(0xcd,0xf1); 
+    GC0310MAIN_write_cmos_sensor(0xce,0xfa); 
+    GC0310MAIN_write_cmos_sensor(0xcf,0xff);
+        
+        /////////////////////////////////////////////////
+        ///////////////////   YCP  //////////////////////
+        /////////////////////////////////////////////////
+    GC0310MAIN_write_cmos_sensor(0xd0,0x40); 
+    GC0310MAIN_write_cmos_sensor(0xd1,0x34); 
+    GC0310MAIN_write_cmos_sensor(0xd2,0x34); 
+    GC0310MAIN_write_cmos_sensor(0xd3,0x3c); 
+    GC0310MAIN_write_cmos_sensor(0xd6,0xf2); 
+    GC0310MAIN_write_cmos_sensor(0xd7,0x1b); 
+    GC0310MAIN_write_cmos_sensor(0xd8,0x18); 
+    GC0310MAIN_write_cmos_sensor(0xdd,0x03); 
+        /////////////////////////////////////////////////
+        ////////////////////   AEC   ////////////////////
+        /////////////////////////////////////////////////
+    GC0310MAIN_write_cmos_sensor(0xfe,0x01);
+    GC0310MAIN_write_cmos_sensor(0x05,0x30); 
+    GC0310MAIN_write_cmos_sensor(0x06,0x75); 
+    GC0310MAIN_write_cmos_sensor(0x07,0x40); 
+    GC0310MAIN_write_cmos_sensor(0x08,0xb0); 
+    GC0310MAIN_write_cmos_sensor(0x0a,0xc5); 
+    GC0310MAIN_write_cmos_sensor(0x0b,0x11);
+    GC0310MAIN_write_cmos_sensor(0x0c,0x00); 
+    GC0310MAIN_write_cmos_sensor(0x12,0x52);
+    GC0310MAIN_write_cmos_sensor(0x13,0x38); 
+    GC0310MAIN_write_cmos_sensor(0x18,0x95);
+    GC0310MAIN_write_cmos_sensor(0x19,0x96);
+    GC0310MAIN_write_cmos_sensor(0x1f,0x20);
+    GC0310MAIN_write_cmos_sensor(0x20,0xc0); 
+    GC0310MAIN_write_cmos_sensor(0x3e,0x40); 
+    GC0310MAIN_write_cmos_sensor(0x3f,0x57); 
+    GC0310MAIN_write_cmos_sensor(0x40,0x7d); 
+    GC0310MAIN_write_cmos_sensor(0x03,0x60); 
+    GC0310MAIN_write_cmos_sensor(0x44,0x02); 
+    /////////////////////////////////////////////////
+    ////////////////////   AWB   ////////////////////
+    /////////////////////////////////////////////////
+    GC0310MAIN_write_cmos_sensor(0x1c,0x91); 
+    GC0310MAIN_write_cmos_sensor(0x21,0x15); 
+    GC0310MAIN_write_cmos_sensor(0x50,0x80);
+    GC0310MAIN_write_cmos_sensor(0x56,0x04);
+    GC0310MAIN_write_cmos_sensor(0x58,0x08);    
+    GC0310MAIN_write_cmos_sensor(0x59,0x08); 
+    GC0310MAIN_write_cmos_sensor(0x5b,0x82);  // 02 to 82 to 02
+    GC0310MAIN_write_cmos_sensor(0x61,0x8d); 
+    GC0310MAIN_write_cmos_sensor(0x62,0xa7); 
+    GC0310MAIN_write_cmos_sensor(0x63,0x00);   // d0 to  00
+    GC0310MAIN_write_cmos_sensor(0x65,0x06);
+    GC0310MAIN_write_cmos_sensor(0x66,0x06);   // 06 to 03
+    GC0310MAIN_write_cmos_sensor(0x67,0x84); 
+    GC0310MAIN_write_cmos_sensor(0x69,0x08);   // 08 to 20
+    GC0310MAIN_write_cmos_sensor(0x6a,0x25); 
+    GC0310MAIN_write_cmos_sensor(0x6b,0x01); 
+    GC0310MAIN_write_cmos_sensor(0x6c,0x00);   // 00 to 0c
+    GC0310MAIN_write_cmos_sensor(0x6d,0x02); 
+    GC0310MAIN_write_cmos_sensor(0x6e,0x00);  // f0 to 00
+    GC0310MAIN_write_cmos_sensor(0x6f,0x80); 
+    GC0310MAIN_write_cmos_sensor(0x76,0x80); 
+    GC0310MAIN_write_cmos_sensor(0x78,0xaf); 
+    GC0310MAIN_write_cmos_sensor(0x79,0x75);
+    GC0310MAIN_write_cmos_sensor(0x7a,0x40);
+    GC0310MAIN_write_cmos_sensor(0x7b,0x50);
+    GC0310MAIN_write_cmos_sensor(0x7c,0x08); //0c to 08 8.11
+         
+    GC0310MAIN_write_cmos_sensor(0xa4,0xb9); 
+    GC0310MAIN_write_cmos_sensor(0xa5,0xa0);
+    GC0310MAIN_write_cmos_sensor(0x90,0xc9); 
+    GC0310MAIN_write_cmos_sensor(0x91,0xbe);
+    GC0310MAIN_write_cmos_sensor(0xa6,0xb8); 
+    GC0310MAIN_write_cmos_sensor(0xa7,0x95); 
+    GC0310MAIN_write_cmos_sensor(0x92,0xe6); 
+    GC0310MAIN_write_cmos_sensor(0x93,0xca); 
+    GC0310MAIN_write_cmos_sensor(0xa9,0xb6); 
+    GC0310MAIN_write_cmos_sensor(0xaa,0x89); 
+    GC0310MAIN_write_cmos_sensor(0x95,0x23); 
+    GC0310MAIN_write_cmos_sensor(0x96,0xe7); 
+    GC0310MAIN_write_cmos_sensor(0xab,0x9d); 
+    GC0310MAIN_write_cmos_sensor(0xac,0x80);
+    GC0310MAIN_write_cmos_sensor(0x97,0x43); 
+    GC0310MAIN_write_cmos_sensor(0x98,0x24); 
+    GC0310MAIN_write_cmos_sensor(0xae,0xd0);   // b7 to d0
+    GC0310MAIN_write_cmos_sensor(0xaf,0x9e); 
+    GC0310MAIN_write_cmos_sensor(0x9a,0x43);
+    GC0310MAIN_write_cmos_sensor(0x9b,0x24); 
+        
+    GC0310MAIN_write_cmos_sensor(0xb0,0xc0);  // c8 to c0
+    GC0310MAIN_write_cmos_sensor(0xb1,0xa8);   // 97 to a8
+    GC0310MAIN_write_cmos_sensor(0x9c,0xc4); 
+    GC0310MAIN_write_cmos_sensor(0x9d,0x44); 
+    GC0310MAIN_write_cmos_sensor(0xb3,0xb7); 
+    GC0310MAIN_write_cmos_sensor(0xb4,0x7f);
+    GC0310MAIN_write_cmos_sensor(0x9f,0xc7);
+    GC0310MAIN_write_cmos_sensor(0xa0,0xc8); 
+    GC0310MAIN_write_cmos_sensor(0xb5,0x00); 
+    GC0310MAIN_write_cmos_sensor(0xb6,0x00);
+    GC0310MAIN_write_cmos_sensor(0xa1,0x00);
+    GC0310MAIN_write_cmos_sensor(0xa2,0x00);
+    GC0310MAIN_write_cmos_sensor(0x86,0x60);
+    GC0310MAIN_write_cmos_sensor(0x87,0x08);
+    GC0310MAIN_write_cmos_sensor(0x88,0x00);
+    GC0310MAIN_write_cmos_sensor(0x89,0x00);
+    GC0310MAIN_write_cmos_sensor(0x8b,0xde);
+    GC0310MAIN_write_cmos_sensor(0x8c,0x80);
+    GC0310MAIN_write_cmos_sensor(0x8d,0x00);
+    GC0310MAIN_write_cmos_sensor(0x8e,0x00);
+    GC0310MAIN_write_cmos_sensor(0x94,0x55);
+    GC0310MAIN_write_cmos_sensor(0x99,0xa6);
+    GC0310MAIN_write_cmos_sensor(0x9e,0xaa);
+    GC0310MAIN_write_cmos_sensor(0xa3,0x0a);
+    GC0310MAIN_write_cmos_sensor(0x8a,0x0a);
+    GC0310MAIN_write_cmos_sensor(0xa8,0x55);
+    GC0310MAIN_write_cmos_sensor(0xad,0x55);
+    GC0310MAIN_write_cmos_sensor(0xb2,0x55);
+    GC0310MAIN_write_cmos_sensor(0xb7,0x05);
+    GC0310MAIN_write_cmos_sensor(0x8f,0x05);
+    GC0310MAIN_write_cmos_sensor(0xb8,0xcc);
+    GC0310MAIN_write_cmos_sensor(0xb9,0x9a);
+        
+        /////////////////////////////////////
+        ////////////////////  CC ////////////
+        /////////////////////////////////////
+    GC0310MAIN_write_cmos_sensor(0xfe,0x01);
+    GC0310MAIN_write_cmos_sensor(0xd0,0x38);
+    GC0310MAIN_write_cmos_sensor(0xd1,0xfd);
+    GC0310MAIN_write_cmos_sensor(0xd2,0x06);
+    GC0310MAIN_write_cmos_sensor(0xd3,0xf0);
+    GC0310MAIN_write_cmos_sensor(0xd4,0x40);
+    GC0310MAIN_write_cmos_sensor(0xd5,0x08);
+    GC0310MAIN_write_cmos_sensor(0xd6,0x30);
+    GC0310MAIN_write_cmos_sensor(0xd7,0x00);
+    GC0310MAIN_write_cmos_sensor(0xd8,0x0a);
+    GC0310MAIN_write_cmos_sensor(0xd9,0x16);
+    GC0310MAIN_write_cmos_sensor(0xda,0x39);
+    GC0310MAIN_write_cmos_sensor(0xdb,0xf8);
+        
+        /////////////////////////////////////////////////
+        ////////////////////   LSC   ////////////////////
+        /////////////////////////////////////////////////
+    GC0310MAIN_write_cmos_sensor(0xfe,0x01); 
+    GC0310MAIN_write_cmos_sensor(0xc1,0x3c); 
+    GC0310MAIN_write_cmos_sensor(0xc2,0x50); 
+    GC0310MAIN_write_cmos_sensor(0xc3,0x00); 
+    GC0310MAIN_write_cmos_sensor(0xc4,0x40); 
+    GC0310MAIN_write_cmos_sensor(0xc5,0x30); 
+    GC0310MAIN_write_cmos_sensor(0xc6,0x30); 
+    GC0310MAIN_write_cmos_sensor(0xc7,0x10); 
+    GC0310MAIN_write_cmos_sensor(0xc8,0x00); 
+    GC0310MAIN_write_cmos_sensor(0xc9,0x00); 
+    GC0310MAIN_write_cmos_sensor(0xdc,0x20); 
+    GC0310MAIN_write_cmos_sensor(0xdd,0x10); 
+    GC0310MAIN_write_cmos_sensor(0xdf,0x00); 
+    GC0310MAIN_write_cmos_sensor(0xde,0x00); 
+        
+        /////////////////////////////////////////////////
+        ///////////////////  Histogram  /////////////////
+        /////////////////////////////////////////////////
+    GC0310MAIN_write_cmos_sensor(0x01,0x10); 
+    GC0310MAIN_write_cmos_sensor(0x0b,0x31); 
+    GC0310MAIN_write_cmos_sensor(0x0e,0x50); 
+    GC0310MAIN_write_cmos_sensor(0x0f,0x0f); 
+    GC0310MAIN_write_cmos_sensor(0x10,0x6e); 
+    GC0310MAIN_write_cmos_sensor(0x12,0xa0); 
+    GC0310MAIN_write_cmos_sensor(0x15,0x60); 
+    GC0310MAIN_write_cmos_sensor(0x16,0x60); 
+    GC0310MAIN_write_cmos_sensor(0x17,0xe0); 
+        
+        /////////////////////////////////////////////////
+        //////////////   Measure Window   ///////////////
+        /////////////////////////////////////////////////
+    GC0310MAIN_write_cmos_sensor(0xcc,0x0c);  
+    GC0310MAIN_write_cmos_sensor(0xcd,0x10); 
+    GC0310MAIN_write_cmos_sensor(0xce,0xa0); 
+    GC0310MAIN_write_cmos_sensor(0xcf,0xe6); 
+        
+        /////////////////////////////////////////////////
+        /////////////////   dark sun   //////////////////
+        /////////////////////////////////////////////////
+    GC0310MAIN_write_cmos_sensor(0x45,0xf7);
+    GC0310MAIN_write_cmos_sensor(0x46,0xff); 
+    GC0310MAIN_write_cmos_sensor(0x47,0x15);
+    GC0310MAIN_write_cmos_sensor(0x48,0x03); 
+    GC0310MAIN_write_cmos_sensor(0x4f,0x60); 
+        
+        /////////////////////////////////////////////////
+        ///////////////////  banding  ///////////////////
+        /////////////////////////////////////////////////
+    GC0310MAIN_write_cmos_sensor(0xfe,0x00);
+    GC0310MAIN_write_cmos_sensor(0x05,0x01);
+    GC0310MAIN_write_cmos_sensor(0x06,0x18); //HB
+#if 1    
+    GC0310MAIN_write_cmos_sensor(0x07,0x00);
+    GC0310MAIN_write_cmos_sensor(0x08,0x10); //VB  from 10 to 50
+#else
+	GC0310MAIN_write_cmos_sensor(0x07,0x01);
+	GC0310MAIN_write_cmos_sensor(0x08,0xe0); //VB
+#endif
+    GC0310MAIN_write_cmos_sensor(0xfe,0x01);
+    GC0310MAIN_write_cmos_sensor(0x25,0x00); //step 
+    GC0310MAIN_write_cmos_sensor(0x26,0x9a); 
+    GC0310MAIN_write_cmos_sensor(0x27,0x01); //30fps
+    GC0310MAIN_write_cmos_sensor(0x28,0xce);  
+    GC0310MAIN_write_cmos_sensor(0x29,0x04); //12.5fps
+	GC0310MAIN_write_cmos_sensor(0x2a,0x36); 
+	GC0310MAIN_write_cmos_sensor(0x2b,0x06); //10fps
+	GC0310MAIN_write_cmos_sensor(0x2c,0x04); 
+	GC0310MAIN_write_cmos_sensor(0x2d,0x0c); //5fps
+	GC0310MAIN_write_cmos_sensor(0x2e,0x08);
+    GC0310MAIN_write_cmos_sensor(0x3c,0x20);
+        
+        /////////////////////////////////////////////////
+        ///////////////////   MIPI   ////////////////////
+        /////////////////////////////////////////////////
+   GC0310MAIN_write_cmos_sensor(0xfe,0x03);
+   GC0310MAIN_write_cmos_sensor(0x10,0x94);  
+   GC0310MAIN_write_cmos_sensor(0xfe,0x00); 
+}
+
+
+UINT32 GC0310MAINGetSensorID(UINT32 *sensorID)
+{
+    int  retry = 3; 
+    // check if sensor ID correct
+    do {
+        *sensorID=((GC0310MAIN_read_cmos_sensor(0xf0)<< 8)|GC0310MAIN_read_cmos_sensor(0xf1))+1;
+        if (*sensorID == GC0310MAIN_SENSOR_ID)
+            break; 
+        SENSORDB("Read Sensor ID Fail = 0x%04x\n", *sensorID); 
+        retry--; 
+    } while (retry > 0);
+
+    if (*sensorID != GC0310MAIN_SENSOR_ID) {
+        *sensorID = 0xFFFFFFFF; 
+        return ERROR_SENSOR_CONNECT_FAIL;
+    }
+    return ERROR_NONE;    
+}
+
+
+
+
+/*************************************************************************
+* FUNCTION
+*	GC0310MAIN_Write_More_Registers
+*
+* DESCRIPTION
+*	This function is served for FAE to modify the necessary Init Regs. Do not modify the regs
+*     in init_GC0310MAIN() directly.
+*
+* PARAMETERS
+*	None
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+void GC0310MAIN_Write_More_Registers(void)
+{
+
+}
+
+
+/*************************************************************************
+ * FUNCTION
+ *	GC0310MAINOpen
+ *
+ * DESCRIPTION
+ *	This function initialize the registers of CMOS sensor
+ *
+ * PARAMETERS
+ *	None
+ *
+ * RETURNS
+ *	None
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+UINT32 GC0310MAINOpen(void)
+{
+	volatile signed char i;
+	kal_uint16 sensor_id=0;
+
+	SENSORDB("<Jet> Entry GC0310MAINOpen!!!\r\n");
+
+	Sleep(10);
+
+
+	//  Read sensor ID to adjust I2C is OK?
+	for(i=0;i<3;i++)
+	{
+		sensor_id = ((GC0310MAIN_read_cmos_sensor(0xf0) << 8) | GC0310MAIN_read_cmos_sensor(0xf1))+1;
+		if(sensor_id != GC0310MAIN_SENSOR_ID)  
+		{
+			SENSORDB("GC0310MAINmipi Read Sensor ID Fail[open] = 0x%x\n", sensor_id); 
+			return ERROR_SENSOR_CONNECT_FAIL;
+		}
+	}
+	
+	SENSORDB("GC0310MAINmipi_ Sensor Read ID OK \r\n");
+	GC0310MAIN_Sensor_Init();
+
+	if(0 == strncmp(VANZO_SUB_CAM_ROTATION, "180", 3)){
+	  GC0310MAIN_Set_Mirrorflip(0);
+	}
+
+	GC0310MAIN_Write_More_Registers();
+
+	spin_lock(&GC0310MAIN_drv_lock);
+	GC0310MAIN_night_mode_enable = KAL_FALSE;
+	GC0310MAIN_MPEG4_encode_mode = KAL_FALSE;
+	spin_unlock(&GC0310MAIN_drv_lock);	
+
+	return ERROR_NONE;
+} /* GC0310MAINOpen */
+
+
+/*************************************************************************
+ * FUNCTION
+ *	GC0310MAINClose
+ *
+ * DESCRIPTION
+ *	This function is to turn off sensor module power.
+ *
+ * PARAMETERS
+ *	None
+ *
+ * RETURNS
+ *	None
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+UINT32 GC0310MAINClose(void)
+{
+    return ERROR_NONE;
+} /* GC0310MAINClose */
+
+
+/*************************************************************************
+ * FUNCTION
+ * GC0310MAINPreview
+ *
+ * DESCRIPTION
+ *	This function start the sensor preview.
+ *
+ * PARAMETERS
+ *	*image_window : address pointer of pixel numbers in one period of HSYNC
+ *  *sensor_config_data : address pointer of line numbers in one period of VSYNC
+ *
+ * RETURNS
+ *	None
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+UINT32 GC0310MAINPreview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+        MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+
+{
+    kal_uint32 iTemp;
+    kal_uint16 iStartX = 0, iStartY = 1;
+
+	SENSORDB("Enter GC0310MAINPreview function!!!\r\n");
+//	GC0310MAINStreamOn();
+
+    image_window->GrabStartX= IMAGE_SENSOR_VGA_GRAB_PIXELS;
+    image_window->GrabStartY= IMAGE_SENSOR_VGA_GRAB_LINES;
+    image_window->ExposureWindowWidth = IMAGE_SENSOR_PV_WIDTH;
+    image_window->ExposureWindowHeight =IMAGE_SENSOR_PV_HEIGHT;
+
+    //GC0310MAIN_Set_Mirrorflip(IMAGE_NORMAL);
+    if(0 == strncmp(VANZO_SUB_CAM_ROTATION, "180", 3)){
+               GC0310MAIN_Set_Mirrorflip(IMAGE_HV_MIRROR);
+             }else{
+    GC0310MAIN_Set_Mirrorflip(IMAGE_NORMAL);
+             }
+       
+    
+
+    // copy sensor_config_data
+    memcpy(&GC0310MAINSensorConfigData, sensor_config_data, sizeof(MSDK_SENSOR_CONFIG_STRUCT));
+//    GC0310MAINNightMode(GC0310MAIN_night_mode_enable);
+    return ERROR_NONE;
+} /* GC0310MAINPreview */
+
+
+/*************************************************************************
+ * FUNCTION
+ *	GC0310MAINCapture
+ *
+ * DESCRIPTION
+ *	This function setup the CMOS sensor in capture MY_OUTPUT mode
+ *
+ * PARAMETERS
+ *
+ * RETURNS
+ *	None
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+UINT32 GC0310MAINCapture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+        MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+
+{
+	spin_lock(&GC0310MAIN_drv_lock);
+    GC0310MAIN_MODE_CAPTURE=KAL_TRUE;
+	spin_unlock(&GC0310MAIN_drv_lock);
+
+
+    image_window->GrabStartX = IMAGE_SENSOR_VGA_GRAB_PIXELS;
+    image_window->GrabStartY = IMAGE_SENSOR_VGA_GRAB_LINES;
+    image_window->ExposureWindowWidth= IMAGE_SENSOR_FULL_WIDTH;
+    image_window->ExposureWindowHeight = IMAGE_SENSOR_FULL_HEIGHT;
+
+    // copy sensor_config_data
+    memcpy(&GC0310MAINSensorConfigData, sensor_config_data, sizeof(MSDK_SENSOR_CONFIG_STRUCT));
+    return ERROR_NONE;
+} /* GC0310MAIN_Capture() */
+
+
+
+UINT32 GC0310MAINGetResolution(MSDK_SENSOR_RESOLUTION_INFO_STRUCT *pSensorResolution)
+{
+    pSensorResolution->SensorFullWidth=IMAGE_SENSOR_FULL_WIDTH;
+    pSensorResolution->SensorFullHeight=IMAGE_SENSOR_FULL_HEIGHT;
+    pSensorResolution->SensorPreviewWidth=IMAGE_SENSOR_PV_WIDTH;
+    pSensorResolution->SensorPreviewHeight=IMAGE_SENSOR_PV_HEIGHT;
+    pSensorResolution->SensorVideoWidth=IMAGE_SENSOR_PV_WIDTH;
+    pSensorResolution->SensorVideoHeight=IMAGE_SENSOR_PV_HEIGHT;
+    
+    pSensorResolution->SensorHighSpeedVideoWidth=IMAGE_SENSOR_PV_WIDTH;
+    pSensorResolution->SensorHighSpeedVideoHeight=IMAGE_SENSOR_PV_HEIGHT;
+    
+    pSensorResolution->SensorSlimVideoWidth=IMAGE_SENSOR_PV_WIDTH;
+    pSensorResolution->SensorSlimVideoHeight=IMAGE_SENSOR_PV_HEIGHT;    
+    return ERROR_NONE;
+} /* GC0310MAINGetResolution() */
+
+
+UINT32 GC0310MAINGetInfo(MSDK_SCENARIO_ID_ENUM ScenarioId,
+        MSDK_SENSOR_INFO_STRUCT *pSensorInfo,
+        MSDK_SENSOR_CONFIG_STRUCT *pSensorConfigData)
+{
+    pSensorInfo->SensorPreviewResolutionX=IMAGE_SENSOR_PV_WIDTH;
+    pSensorInfo->SensorPreviewResolutionY=IMAGE_SENSOR_PV_HEIGHT;
+    pSensorInfo->SensorFullResolutionX=IMAGE_SENSOR_FULL_WIDTH;
+    pSensorInfo->SensorFullResolutionY=IMAGE_SENSOR_FULL_HEIGHT;
+
+    pSensorInfo->SensorCameraPreviewFrameRate=30;
+    pSensorInfo->SensorVideoFrameRate=30;
+    pSensorInfo->SensorStillCaptureFrameRate=10;
+    pSensorInfo->SensorWebCamCaptureFrameRate=15;
+    pSensorInfo->SensorResetActiveHigh=FALSE;
+    pSensorInfo->SensorResetDelayCount=1;
+    pSensorInfo->SensorOutputDataFormat=SENSOR_OUTPUT_FORMAT_VYUY;
+    pSensorInfo->SensorClockPolarity=SENSOR_CLOCK_POLARITY_LOW;
+    pSensorInfo->SensorClockFallingPolarity=SENSOR_CLOCK_POLARITY_LOW;
+    pSensorInfo->SensorHsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
+    pSensorInfo->SensorVsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
+    pSensorInfo->SensorInterruptDelayLines = 1;
+    pSensorInfo->SensroInterfaceType=SENSOR_INTERFACE_TYPE_MIPI;//MIPI setting
+    pSensorInfo->CaptureDelayFrame = 2;
+    pSensorInfo->PreviewDelayFrame = 2;
+    pSensorInfo->VideoDelayFrame = 4;
+
+    pSensorInfo->SensorMasterClockSwitch = 0;
+    pSensorInfo->SensorDrivingCurrent = ISP_DRIVING_6MA;
+
+    pSensorInfo->HighSpeedVideoDelayFrame = 4;
+    pSensorInfo->SlimVideoDelayFrame = 4;
+    pSensorInfo->SensorModeNum = 5;
+
+    switch (ScenarioId)
+    {
+    case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+    case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+    case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+    default:
+        pSensorInfo->SensorClockFreq=24;
+        pSensorInfo->SensorClockDividCount= 3;
+        pSensorInfo->SensorClockRisingCount=0;
+        pSensorInfo->SensorClockFallingCount=2;
+        pSensorInfo->SensorPixelClockCount=3;
+        pSensorInfo->SensorDataLatchCount=2;
+        pSensorInfo->SensorGrabStartX = IMAGE_SENSOR_VGA_GRAB_PIXELS;
+        pSensorInfo->SensorGrabStartY = IMAGE_SENSOR_VGA_GRAB_LINES;
+	//MIPI setting
+	pSensorInfo->SensorMIPILaneNumber = SENSOR_MIPI_1_LANE; 	
+	pSensorInfo->MIPIDataLowPwr2HighSpeedTermDelayCount = 0; 
+	pSensorInfo->MIPIDataLowPwr2HighSpeedSettleDelayCount = 14;   
+	pSensorInfo->MIPICLKLowPwr2HighSpeedTermDelayCount = 0;
+	pSensorInfo->SensorWidthSampling = 0;  // 0 is default 1x
+	pSensorInfo->SensorHightSampling = 0;	// 0 is default 1x 
+	pSensorInfo->SensorPacketECCOrder = 1;
+
+        break;
+    }
+    GC0310MAINPixelClockDivider=pSensorInfo->SensorPixelClockCount;
+    memcpy(pSensorConfigData, &GC0310MAINSensorConfigData, sizeof(MSDK_SENSOR_CONFIG_STRUCT));
+    return ERROR_NONE;
+} /* GC0310MAINGetInfo() */
+
+
+UINT32 GC0310MAINControl(MSDK_SCENARIO_ID_ENUM ScenarioId, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *pImageWindow,
+        MSDK_SENSOR_CONFIG_STRUCT *pSensorConfigData)
+{
+
+	SENSORDB("Entry GC0310MAINControl, ScenarioId = %d!!!\r\n", ScenarioId);
+    switch (ScenarioId)
+    {
+    case MSDK_SCENARIO_ID_VIDEO_PREVIEW:   
+    	SENSORDB("GC0310MAIN Camera Video Preview!\n");
+		spin_lock(&GC0310MAIN_drv_lock);         
+        GC0310MAIN_MPEG4_encode_mode = KAL_TRUE;
+        spin_unlock(&GC0310MAIN_drv_lock); 
+		GC0310MAINPreview(pImageWindow, pSensorConfigData);        
+        break;
+	case MSDK_SCENARIO_ID_CAMERA_PREVIEW:       
+    case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+    default:
+        spin_lock(&GC0310MAIN_drv_lock);  
+        GC0310MAIN_MPEG4_encode_mode = KAL_FALSE;
+        spin_unlock(&GC0310MAIN_drv_lock);
+		GC0310MAINPreview(pImageWindow, pSensorConfigData);        
+        break;
+    }
+    
+    return ERROR_NONE;
+}	/* GC0310MAINControl() */
+
+BOOL GC0310MAIN_set_param_wb(UINT16 para)
+{
+	SENSORDB("GC0310MAIN_set_param_wb para = %d\n", para);
+    spin_lock(&GC0310MAIN_drv_lock);
+    GC0310MAIN_CurStatus_AWB = para;
+    spin_unlock(&GC0310MAIN_drv_lock);
+
+	GC0310MAIN_write_cmos_sensor(0xfe, 0x00); 	
+	switch (para)
+	{
+		case AWB_MODE_OFF:
+			GC0310MAIN_awb_enable(KAL_FALSE);
+		    GC0310MAIN_write_cmos_sensor(0x77,0x74); 
+		    GC0310MAIN_write_cmos_sensor(0x78,0x40); 
+		    GC0310MAIN_write_cmos_sensor(0x79,0x5f); 			
+		break;
+		
+		case AWB_MODE_AUTO:
+		    GC0310MAIN_write_cmos_sensor(0x77,0x74); 
+		    GC0310MAIN_write_cmos_sensor(0x78,0x40); 
+		    GC0310MAIN_write_cmos_sensor(0x79,0x5f); 		
+			GC0310MAIN_awb_enable(KAL_TRUE);
+		break;
+		
+		case AWB_MODE_CLOUDY_DAYLIGHT: //cloudy
+			GC0310MAIN_awb_enable(KAL_FALSE);
+			GC0310MAIN_write_cmos_sensor(0x77, 0x40);
+			GC0310MAIN_write_cmos_sensor(0x78, 0x54);
+			GC0310MAIN_write_cmos_sensor(0x79, 0x70);
+		break;
+		
+		case AWB_MODE_DAYLIGHT: //sunny
+			GC0310MAIN_awb_enable(KAL_FALSE);
+			GC0310MAIN_write_cmos_sensor(0x77, 0x74); 
+			GC0310MAIN_write_cmos_sensor(0x78, 0x52);
+			GC0310MAIN_write_cmos_sensor(0x79, 0x40);			
+		break;
+		
+		case AWB_MODE_INCANDESCENT: //office
+			GC0310MAIN_awb_enable(KAL_FALSE);
+			GC0310MAIN_write_cmos_sensor(0x77, 0x48);
+			GC0310MAIN_write_cmos_sensor(0x78, 0x40);
+			GC0310MAIN_write_cmos_sensor(0x79, 0x5c);
+		break;
+		
+		case AWB_MODE_TUNGSTEN: //home		
+			GC0310MAIN_awb_enable(KAL_FALSE);
+			GC0310MAIN_write_cmos_sensor(0x77, 0x8c); //WB_manual_gain 
+			GC0310MAIN_write_cmos_sensor(0x78, 0x50);
+			GC0310MAIN_write_cmos_sensor(0x79, 0x40);
+		break;
+		
+		case AWB_MODE_FLUORESCENT:
+			GC0310MAIN_awb_enable(KAL_FALSE);
+			GC0310MAIN_write_cmos_sensor(0x77, 0x40);
+			GC0310MAIN_write_cmos_sensor(0x78, 0x42);
+			GC0310MAIN_write_cmos_sensor(0x79, 0x50);
+		break;
+		
+		default:
+		return FALSE;
+	}
+	GC0310MAIN_write_cmos_sensor(0xfe, 0x00); 
+
+	return TRUE;
+} /* GC0310MAIN_set_param_wb */
+
+
+BOOL GC0310MAIN_set_param_effect(UINT16 para)
+{
+	kal_uint32  ret = KAL_TRUE;
+
+	switch (para)
+	{
+		case MEFFECT_OFF:
+			GC0310MAIN_write_cmos_sensor(0x43 , 0x00);
+		break;
+		
+		case MEFFECT_SEPIA:
+			GC0310MAIN_write_cmos_sensor(0x43 , 0x02);
+			GC0310MAIN_write_cmos_sensor(0xda , 0xd0);
+			GC0310MAIN_write_cmos_sensor(0xdb , 0x28);
+		break;
+		
+		case MEFFECT_NEGATIVE:
+			GC0310MAIN_write_cmos_sensor(0x43 , 0x01);
+		break;
+		
+		case MEFFECT_SEPIAGREEN:
+			GC0310MAIN_write_cmos_sensor(0x43 , 0x02);
+			GC0310MAIN_write_cmos_sensor(0xda , 0xc0);
+			GC0310MAIN_write_cmos_sensor(0xdb , 0xc0);
+		break;
+		
+		case MEFFECT_SEPIABLUE:
+			GC0310MAIN_write_cmos_sensor(0x43 , 0x02);
+			GC0310MAIN_write_cmos_sensor(0xda , 0x50);
+			GC0310MAIN_write_cmos_sensor(0xdb , 0xe0);
+		break;
+
+		case MEFFECT_MONO:
+			GC0310MAIN_write_cmos_sensor(0x43 , 0x02);
+			GC0310MAIN_write_cmos_sensor(0xda , 0x00);
+			GC0310MAIN_write_cmos_sensor(0xdb , 0x00);
+		break;
+		default:
+			ret = FALSE;
+	}
+
+	return ret;
+
+} /* GC0310MAIN_set_param_effect */
+
+
+BOOL GC0310MAIN_set_param_banding(UINT16 para)
+{
+
+	SENSORDB("Enter GC0310MAIN_set_param_banding!, para = %d\r\n", para);	
+	switch (para)
+	{
+		case AE_FLICKER_MODE_AUTO:
+		case AE_FLICKER_MODE_OFF:
+		case AE_FLICKER_MODE_50HZ:
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00); 
+			GC0310MAIN_write_cmos_sensor(0x05, 0x01); 	
+			GC0310MAIN_write_cmos_sensor(0x06, 0x18); 
+			GC0310MAIN_write_cmos_sensor(0x07, 0x00);
+			GC0310MAIN_write_cmos_sensor(0x08, 0x10);
+			
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x01);
+			GC0310MAIN_write_cmos_sensor(0x25,0x00); //step 
+			GC0310MAIN_write_cmos_sensor(0x26,0x9a); 
+		
+			GC0310MAIN_write_cmos_sensor(0x27,0x01); //30fps
+			GC0310MAIN_write_cmos_sensor(0x28,0xce);  
+			GC0310MAIN_write_cmos_sensor(0x29,0x04); //15fps
+			GC0310MAIN_write_cmos_sensor(0x2a,0x36); 
+			GC0310MAIN_write_cmos_sensor(0x2b,0x06); //10fps
+			GC0310MAIN_write_cmos_sensor(0x2c,0x04); 
+			GC0310MAIN_write_cmos_sensor(0x2d,0x09); //8fps  
+			GC0310MAIN_write_cmos_sensor(0x2e,0xa0);  // 
+			//GC0310MAIN_write_cmos_sensor(0x3c,0x20);
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00); 			
+			break;
+
+		case AE_FLICKER_MODE_60HZ:
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00); 
+			GC0310MAIN_write_cmos_sensor(0x05, 0x01); 	
+			GC0310MAIN_write_cmos_sensor(0x06, 0x13); 
+			GC0310MAIN_write_cmos_sensor(0x07, 0x00);
+			GC0310MAIN_write_cmos_sensor(0x08, 0x10);
+			
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x01);
+			GC0310MAIN_write_cmos_sensor(0x25, 0x00);   //anti-flicker step [11:8]
+			GC0310MAIN_write_cmos_sensor(0x26, 0x81);	//anti-flicker step [7:0]
+			
+			GC0310MAIN_write_cmos_sensor(0x27, 0x01);	//exp level 0  30fps
+			GC0310MAIN_write_cmos_sensor(0x28, 0x83); 
+			GC0310MAIN_write_cmos_sensor(0x29, 0x04);	//exp level 1  15fps
+			GC0310MAIN_write_cmos_sensor(0x2a, 0x08); 
+			GC0310MAIN_write_cmos_sensor(0x2b, 0x06);	//exp level 2  10fps
+			GC0310MAIN_write_cmos_sensor(0x2c, 0x0c); 
+			GC0310MAIN_write_cmos_sensor(0x2d, 0x09);	//exp level 3 8fps
+			GC0310MAIN_write_cmos_sensor(0x2e, 0x93);	
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00);
+
+		break;
+		default:
+		return FALSE;
+	}
+	GC0310MAIN_write_cmos_sensor(0xfe, 0x00); 
+
+	return TRUE;
+} /* GC0310MAIN_set_param_banding */
+
+BOOL GC0310MAIN_set_param_exposure(UINT16 para)
+{
+
+	switch (para)
+	{
+	
+		case AE_EV_COMP_n20:
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x01);
+			GC0310MAIN_write_cmos_sensor(0x13, 0x20);
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00);
+		break;
+
+		case AE_EV_COMP_n10:
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x01);
+			GC0310MAIN_write_cmos_sensor(0x13, 0x28);  // 28 to 10
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00);
+		break;			
+		
+		case AE_EV_COMP_00:	
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x01);
+			GC0310MAIN_write_cmos_sensor(0x13, 0x38);//35
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00);
+		break;
+
+		case AE_EV_COMP_15:    	
+		case AE_EV_COMP_10:
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x01);
+			GC0310MAIN_write_cmos_sensor(0x13, 0x48);  // 48 to 60
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00);
+			Sleep(200);
+		break;
+		
+		case AE_EV_COMP_20:
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x01);
+			GC0310MAIN_write_cmos_sensor(0x13, 0x50);
+			GC0310MAIN_write_cmos_sensor(0xfe, 0x00);
+		break;
+		default:
+		return FALSE;
+	}
+
+	return TRUE;
+} /* GC0310MAIN_set_param_exposure */
+
+
+UINT32 GC0310MAINYUVSetVideoMode(UINT16 u2FrameRate)    // lanking add
+{
+
+	SENSORDB("Enter GC0310MAINYUVSetVideoMode, u2FrameRate = %d\n", u2FrameRate);
+//	spin_lock(&GC0310MAIN_drv_lock);  
+//    GC0310MAIN_MPEG4_encode_mode = KAL_TRUE;
+//	spin_unlock(&GC0310MAIN_drv_lock);
+
+    
+     if (u2FrameRate == 30)
+   	{
+   	
+   	    /*********video frame ************/
+		
+   	}
+    else if (u2FrameRate == 15)       
+    	{
+    	
+   	    /*********video frame ************/
+		
+    	}
+    else
+   	{
+   	
+            SENSORDB("Wrong Frame Rate"); 
+			
+   	}
+   	
+	GC0310MAINNightMode(GC0310MAIN_night_mode_enable);
+
+    return TRUE;
+
+}
+
+
+UINT32 GC0310MAINYUVSensorSetting(FEATURE_ID iCmd, UINT16 iPara)
+{
+    switch (iCmd) {
+    case FID_AWB_MODE:
+        GC0310MAIN_set_param_wb(iPara);
+        break;
+    case FID_COLOR_EFFECT:
+        GC0310MAIN_set_param_effect(iPara);
+        break;
+    case FID_AE_EV:
+        GC0310MAIN_set_param_exposure(iPara);
+        break;
+    case FID_AE_FLICKER:
+        GC0310MAIN_set_param_banding(iPara);
+		break;
+    case FID_SCENE_MODE:
+	 	GC0310MAINNightMode(iPara);
+        break;
+        
+	case FID_ISP_CONTRAST:
+		GC0310MAIN_set_contrast(iPara);
+		break;
+	case FID_ISP_BRIGHT:
+		GC0310MAIN_set_brightness(iPara);
+		break;
+	case FID_ISP_SAT:
+		GC0310MAIN_set_saturation(iPara);
+		break; 
+	case FID_ISP_EDGE:
+		GC0310MAIN_set_edge(iPara);
+		break; 
+	case FID_AE_ISO:
+		GC0310MAIN_set_iso(iPara);
+		break;	
+	case FID_AE_SCENE_MODE: 
+		GC0310MAIN_set_AE_mode(iPara);
+		break; 
+		
+    default:
+        break;
+    }
+    return TRUE;
+} /* GC0310MAINYUVSensorSetting */
+
+
+UINT32 GC0310MAINFeatureControl(MSDK_SENSOR_FEATURE_ENUM FeatureId,
+        UINT8 *pFeaturePara,UINT32 *pFeatureParaLen)
+{
+    UINT16 *pFeatureReturnPara16=(UINT16 *) pFeaturePara;
+    UINT16 *pFeatureData16=(UINT16 *) pFeaturePara;
+    UINT32 *pFeatureReturnPara32=(UINT32 *) pFeaturePara;
+    UINT32 *pFeatureData32=(UINT32 *) pFeaturePara;
+    UINT32 **ppFeatureData=(UINT32 **) pFeaturePara;
+    unsigned long long *feature_data=(unsigned long long *) pFeaturePara;
+    unsigned long long *feature_return_para=(unsigned long long *) pFeaturePara;
+	
+    UINT32 GC0310MAINSensorRegNumber;
+    UINT32 i;
+    MSDK_SENSOR_CONFIG_STRUCT *pSensorConfigData=(MSDK_SENSOR_CONFIG_STRUCT *) pFeaturePara;
+    MSDK_SENSOR_REG_INFO_STRUCT *pSensorRegData=(MSDK_SENSOR_REG_INFO_STRUCT *) pFeaturePara;
+
+    switch (FeatureId)
+    {
+    case SENSOR_FEATURE_GET_RESOLUTION:
+        *pFeatureReturnPara16++=IMAGE_SENSOR_FULL_WIDTH;
+        *pFeatureReturnPara16=IMAGE_SENSOR_FULL_HEIGHT;
+        *pFeatureParaLen=4;
+        break;
+    case SENSOR_FEATURE_GET_PERIOD:
+        *pFeatureReturnPara16++=(VGA_PERIOD_PIXEL_NUMS)+GC0310MAIN_dummy_pixels;
+        *pFeatureReturnPara16=(VGA_PERIOD_LINE_NUMS)+GC0310MAIN_dummy_lines;
+        *pFeatureParaLen=4;
+        break;
+    case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:
+        *pFeatureReturnPara32 = GC0310MAIN_g_fPV_PCLK;
+        *pFeatureParaLen=4;
+        break;
+    case SENSOR_FEATURE_SET_ESHUTTER:
+        break;
+    case SENSOR_FEATURE_SET_NIGHTMODE:
+        GC0310MAINNightMode((BOOL) *feature_data);
+        break;
+    case SENSOR_FEATURE_SET_GAIN:
+    case SENSOR_FEATURE_SET_FLASHLIGHT:
+        break;
+    case SENSOR_FEATURE_SET_ISP_MASTER_CLOCK_FREQ:
+        GC0310MAIN_isp_master_clock=*pFeatureData32;
+        break;
+    case SENSOR_FEATURE_SET_REGISTER:
+        GC0310MAIN_write_cmos_sensor(pSensorRegData->RegAddr, pSensorRegData->RegData);
+        break;
+    case SENSOR_FEATURE_GET_REGISTER:
+        pSensorRegData->RegData = GC0310MAIN_read_cmos_sensor(pSensorRegData->RegAddr);
+        break;
+    case SENSOR_FEATURE_GET_CONFIG_PARA:
+        memcpy(pSensorConfigData, &GC0310MAINSensorConfigData, sizeof(MSDK_SENSOR_CONFIG_STRUCT));
+        *pFeatureParaLen=sizeof(MSDK_SENSOR_CONFIG_STRUCT);
+        break;
+    case SENSOR_FEATURE_SET_CCT_REGISTER:
+    case SENSOR_FEATURE_GET_CCT_REGISTER:
+    case SENSOR_FEATURE_SET_ENG_REGISTER:
+    case SENSOR_FEATURE_GET_ENG_REGISTER:
+    case SENSOR_FEATURE_GET_REGISTER_DEFAULT:
+    case SENSOR_FEATURE_CAMERA_PARA_TO_SENSOR:
+    case SENSOR_FEATURE_SENSOR_TO_CAMERA_PARA:
+    case SENSOR_FEATURE_GET_GROUP_COUNT:
+    case SENSOR_FEATURE_GET_GROUP_INFO:
+    case SENSOR_FEATURE_GET_ITEM_INFO:
+    case SENSOR_FEATURE_SET_ITEM_INFO:
+    case SENSOR_FEATURE_GET_ENG_INFO:
+        break;
+    case SENSOR_FEATURE_GET_LENS_DRIVER_ID:
+        // get the lens driver ID from EEPROM or just return LENS_DRIVER_ID_DO_NOT_CARE
+        // if EEPROM does not exist in camera module.
+        *pFeatureReturnPara32=LENS_DRIVER_ID_DO_NOT_CARE;
+        *pFeatureParaLen=4;
+        break;
+    case SENSOR_FEATURE_SET_YUV_CMD:
+        GC0310MAINYUVSensorSetting((FEATURE_ID)*feature_data, *(feature_data+1));
+        
+        break;
+    case SENSOR_FEATURE_SET_VIDEO_MODE:    //  lanking
+	 GC0310MAINYUVSetVideoMode(*feature_data);
+	 break;
+    case SENSOR_FEATURE_CHECK_SENSOR_ID:
+	GC0310MAINGetSensorID(pFeatureData32);
+	break;
+	case SENSOR_FEATURE_GET_TEST_PATTERN_CHECKSUM_VALUE:
+		*pFeatureReturnPara32=GC0310MAIN_TEST_PATTERN_CHECKSUM;
+		*pFeatureParaLen=4;
+		break;
+
+	case SENSOR_FEATURE_SET_MAX_FRAME_RATE_BY_SCENARIO:
+		 SENSORDB("[GC0310MAIN] F_SET_MAX_FRAME_RATE_BY_SCENARIO.\n");
+		 GC0310MAIN_MIPI_SetMaxFramerateByScenario((MSDK_SCENARIO_ID_ENUM)*feature_data, *(feature_data+1));
+		 break;
+
+//	case SENSOR_CMD_SET_VIDEO_FRAME_RATE:
+//		SENSORDB("[GC0310MAIN] Enter SENSOR_CMD_SET_VIDEO_FRAME_RATE\n");
+//		//GC0310MAIN_MIPI_SetVideoFrameRate(*pFeatureData32);
+//		break;
+
+	case SENSOR_FEATURE_SET_TEST_PATTERN:			 
+		GC0310MAINSetTestPatternMode((BOOL)*feature_data);			
+		break;
+
+    case SENSOR_FEATURE_GET_DELAY_INFO:
+        SENSORDB("[GC0310MAIN] F_GET_DELAY_INFO\n");
+        GC0310MAIN_MIPI_GetDelayInfo((uintptr_t)*feature_data);
+    break;
+
+    case SENSOR_FEATURE_GET_DEFAULT_FRAME_RATE_BY_SCENARIO:
+         SENSORDB("[GC0310MAIN] F_GET_DEFAULT_FRAME_RATE_BY_SCENARIO\n");
+         GC0310MAIN_MIPI_GetDefaultFramerateByScenario((MSDK_SCENARIO_ID_ENUM)*feature_data, (MUINT32 *)(uintptr_t)(*(feature_data+1)));
+    break;   
+    
+	case SENSOR_FEATURE_SET_YUV_3A_CMD:
+		 SENSORDB("[GC0310MAIN] SENSOR_FEATURE_SET_YUV_3A_CMD ID:%d\n", *pFeatureData32);
+		 GC0310MAIN_3ACtrl((ACDK_SENSOR_3A_LOCK_ENUM)*feature_data);
+		 break;
+
+
+	case SENSOR_FEATURE_GET_EXIF_INFO:
+		 //SENSORDB("[4EC] F_GET_EXIF_INFO\n");
+		 GC0310MAIN_MIPI_GetExifInfo((uintptr_t)*feature_data);
+		 break;
+
+
+	case SENSOR_FEATURE_GET_AE_AWB_LOCK_INFO:
+		 SENSORDB("[GC0310MAIN] F_GET_AE_AWB_LOCK_INFO\n");
+		 //GC0310MAIN_MIPI_get_AEAWB_lock((uintptr_t)(*feature_data), (uintptr_t)*(feature_data+1));
+	break;    
+
+	case SENSOR_FEATURE_SET_MIN_MAX_FPS:
+		SENSORDB("SENSOR_FEATURE_SET_MIN_MAX_FPS:[%d,%d]\n",*pFeatureData32,*(pFeatureData32+1)); 
+		GC0310MAIN_MIPI_SetMaxMinFps((UINT32)*feature_data, (UINT32)*(feature_data+1));
+	break; 
+	
+    default:
+        break;
+	}
+return ERROR_NONE;
+}	/* GC0310MAINFeatureControl() */
+
+
+SENSOR_FUNCTION_STRUCT	SensorFuncGC0310MAINYUV=
+{
+	GC0310MAINOpen,
+	GC0310MAINGetInfo,
+	GC0310MAINGetResolution,
+	GC0310MAINFeatureControl,
+	GC0310MAINControl,
+	GC0310MAINClose
+};
+
+
+UINT32 GC0310MAIN_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
+{
+	/* To Do : Check Sensor status here */
+	if (pfFunc!=NULL)
+		*pfFunc=&SensorFuncGC0310MAINYUV;
+	return ERROR_NONE;
+} /* SensorInit() */
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc0310main_mipi_yuv/gc0310mainmipi_yuv_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc0310main_mipi_yuv/gc0310mainmipi_yuv_Sensor.h
new file mode 100755
index 0000000..55d058b
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc0310main_mipi_yuv/gc0310mainmipi_yuv_Sensor.h
@@ -0,0 +1,77 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *   gc0310main_yuv_Sensor.h
+ *
+ * Project:
+ * --------
+ *   MAUI
+ *
+ * Description:
+ * ------------
+ *   Image sensor driver declare and macro define in the header file.
+ *
+ * Author:
+ * -------
+ *   Mormo
+ *
+ *=============================================================
+ *             HISTORY
+ * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
+ *------------------------------------------------------------------------------
+ * $Log$
+ * 2011/10/25 Firsty Released By Mormo;
+ *
+ *
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
+ *=============================================================
+ ******************************************************************************/
+ 
+#ifndef __GC0310MAIN_SENSOR_H
+#define __GC0310MAIN_SENSOR_H
+
+
+#define VGA_PERIOD_PIXEL_NUMS						694
+#define VGA_PERIOD_LINE_NUMS						488
+
+#define IMAGE_SENSOR_VGA_GRAB_PIXELS			0
+#define IMAGE_SENSOR_VGA_GRAB_LINES			0
+
+#define IMAGE_SENSOR_VGA_WIDTH					(640)
+#define IMAGE_SENSOR_VGA_HEIGHT					(480)
+
+#define IMAGE_SENSOR_PV_WIDTH					(IMAGE_SENSOR_VGA_WIDTH)
+#define IMAGE_SENSOR_PV_HEIGHT					(IMAGE_SENSOR_VGA_HEIGHT)
+
+#define IMAGE_SENSOR_FULL_WIDTH					(IMAGE_SENSOR_VGA_WIDTH)
+#define IMAGE_SENSOR_FULL_HEIGHT					(IMAGE_SENSOR_VGA_HEIGHT)
+
+#define GC0310MAIN_WRITE_ID							        0x42
+#define GC0310MAIN_READ_ID								0x43
+
+// GC0310MAIN SENSOR Chip ID: 0xd0
+
+typedef enum
+{
+	GC0310MAIN_RGB_Gamma_m1 = 0,
+	GC0310MAIN_RGB_Gamma_m2,
+	GC0310MAIN_RGB_Gamma_m3,
+	GC0310MAIN_RGB_Gamma_m4,
+	GC0310MAIN_RGB_Gamma_m5,
+	GC0310MAIN_RGB_Gamma_m6,
+	GC0310MAIN_RGB_Gamma_night
+}GC0310MAIN_GAMMA_TAG;
+
+
+
+UINT32 GC0310MAINOpen(void);
+UINT32 GC0310MAINControl(MSDK_SCENARIO_ID_ENUM ScenarioId, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *pImageWindow, MSDK_SENSOR_CONFIG_STRUCT *pSensorConfigData);
+UINT32 GC0310MAINFeatureControl(MSDK_SENSOR_FEATURE_ENUM FeatureId, UINT8 *pFeaturePara,UINT32 *pFeatureParaLen);
+UINT32 GC0310MAINGetInfo(MSDK_SCENARIO_ID_ENUM ScenarioId, MSDK_SENSOR_INFO_STRUCT *pSensorInfo, MSDK_SENSOR_CONFIG_STRUCT *pSensorConfigData);
+UINT32 GC0310MAINGetResolution(MSDK_SENSOR_RESOLUTION_INFO_STRUCT *pSensorResolution);
+UINT32 GC0310MAINClose(void);
+
+#endif /* __SENSOR_H */
+
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc0409_mipi_raw/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc0409_mipi_raw/Makefile
new file mode 100755
index 0000000..fa20ff5
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc0409_mipi_raw/Makefile
@@ -0,0 +1,4 @@
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+
+obj-y += gc0409mipi_Sensor.o
+
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc0409_mipi_raw/gc0409mipi_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc0409_mipi_raw/gc0409mipi_Sensor.c
new file mode 100755
index 0000000..73f0c0d
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc0409_mipi_raw/gc0409mipi_Sensor.c
@@ -0,0 +1,1406 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *     GC0409mipi_Sensor.c
+ *
+ * Project:
+ * --------
+ *     ALPS
+ *
+ * Description:
+ * ------------
+ *     Source code of Sensor driver
+ *
+ * 	 20150402    Beta1.0    Travis	
+ * 	 20150428    Beta2.1    Travis	
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *============================================================================
+ ****************************************************************************/
+
+#include <linux/videodev2.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <asm/atomic.h>
+//#include <asm/system.h>
+#include <linux/xlog.h>
+
+#include "kd_camera_hw.h"
+#include "kd_imgsensor.h"
+#include "kd_imgsensor_define.h"
+#include "kd_imgsensor_errcode.h"
+
+#include "gc0409mipi_Sensor.h"
+
+#define PFX "GC0409_camera_sensor"
+//#define LOG_1 LOG_INF("GC0409,MIPI 1LANE\n")
+//#define LOG_2 LOG_INF("preview 1280*960@30fps,864Mbps/lane; video 1280*960@30fps,864Mbps/lane; capture 5M@30fps,864Mbps/lane\n")
+//#define LOG_INF(format, args...)    xlog_printk(ANDROID_LOG_INFO   , PFX, "[%s] " format, __FUNCTION__, ##args)
+#define LOG_INF(format, args...)    pr_debug(PFX "[%s] " format, __FUNCTION__, ##args)
+
+#define IMAGE_NO_MIRROR 
+//#define IMAGE_H_MIRROR 
+//#define IMAGE_V_MIRROR 
+//#define IMAGE_HV_MIRROR 
+
+#ifdef IMAGE_NO_MIRROR
+#define MIRROR 0x54
+#define BLK_VAL 0x3c
+#define STARTX 0x01
+#define STARTY 0x01
+#endif
+
+#ifdef IMAGE_H_MIRROR
+#define MIRROR 0x55
+#define BLK_VAL 0x3c
+#define STARTX 0x01
+#define STARTY 0x02
+#endif
+
+#ifdef IMAGE_V_MIRROR
+#define MIRROR 0x56
+#define BLK_VAL 0xc3
+#define STARTX 0x02
+#define STARTY 0x01
+#endif
+
+#ifdef IMAGE_HV_MIRROR
+#define MIRROR 0x57
+#define BLK_VAL 0xc3
+#define STARTX 0x02
+#define STARTY 0x02
+#endif
+
+static DEFINE_SPINLOCK(imgsensor_drv_lock);
+
+static imgsensor_info_struct imgsensor_info = {
+    .sensor_id = GC0409_SENSOR_ID,        //record sensor id defined in Kd_imgsensor.h
+
+    .checksum_value = 0xf7375923,        //checksum value for Camera Auto Test
+
+    .pre = {
+        .pclk = 24000000,                //record different mode's pclk
+        .linelength = 2400,                //record different mode's linelength
+        .framelength = 500,            //record different mode's framelength
+        .startx = 0,                    //record different mode's startx of grabwindow
+        .starty = 0,                    //record different mode's starty of grabwindow
+        .grabwindow_width = 800,        //record different mode's width of grabwindow
+        .grabwindow_height = 480,        //record different mode's height of grabwindow
+        /*     following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario    */
+        .mipi_data_lp2hs_settle_dc = 14,//unit , ns
+        /*     following for GetDefaultFramerateByScenario()    */
+        .max_framerate = 100,
+    },
+    .cap = {
+        .pclk = 24000000,
+        .linelength = 2400,
+        .framelength = 500,
+        .startx = 0,
+        .starty = 0,
+        .grabwindow_width = 800,
+        .grabwindow_height = 480,
+        .mipi_data_lp2hs_settle_dc = 14,
+        .max_framerate = 100,
+    },
+    .cap1 = {                            //capture for PIP 24fps relative information, capture1 mode must use same framelength, linelength with Capture mode for shutter calculate
+        .pclk = 24000000,
+        .linelength = 2400,
+        .framelength = 500,
+        .startx = 0,
+        .starty = 0,
+        .grabwindow_width = 800,
+        .grabwindow_height = 480,
+        .mipi_data_lp2hs_settle_dc = 14,
+        .max_framerate = 100,
+    },
+    .normal_video = {
+          .pclk = 24000000,
+        .linelength = 2400,
+        .framelength = 500,
+        .startx = 0,
+        .starty = 0,
+        .grabwindow_width = 800,
+        .grabwindow_height = 480,
+        .mipi_data_lp2hs_settle_dc = 14,
+        .max_framerate = 100,
+    },
+    .hs_video = {
+          .pclk = 24000000,
+        .linelength = 2400,
+        .framelength = 500,
+        .startx = 0,
+        .starty = 0,
+        .grabwindow_width = 800,
+        .grabwindow_height = 480,
+        .mipi_data_lp2hs_settle_dc = 14,
+        .max_framerate = 100,
+    },
+    .slim_video = {
+        .pclk = 24000000,
+        .linelength = 2400,
+        .framelength = 500,
+        .startx = 0,
+        .starty = 0,
+        .grabwindow_width = 800,
+        .grabwindow_height = 480,
+        .mipi_data_lp2hs_settle_dc = 14,
+        .max_framerate = 100,
+    },
+    .margin = 0,            //sensor framelength & shutter margin
+    .min_shutter = 6,        //min shutter
+    .max_frame_length = 0xfff,//max framelength by sensor register's limitation
+    .ae_shut_delay_frame = 0,    //shutter delay frame for AE cycle, 2 frame with ispGain_delay-shut_delay=2-0=2
+    .ae_sensor_gain_delay_frame = 0,//sensor gain delay frame for AE cycle,2 frame with ispGain_delay-sensor_gain_delay=2-0=2
+    .ae_ispGain_delay_frame = 2,//isp gain delay frame for AE cycle
+    .ihdr_support = 0,      //1, support; 0,not support
+    .ihdr_le_firstline = 0,  //1,le first ; 0, se first
+    .sensor_mode_num = 3,      //support sensor mode num
+
+    .cap_delay_frame = 2,        //enter capture delay frame num
+    .pre_delay_frame = 2,         //enter preview delay frame num
+    .video_delay_frame = 2,        //enter video delay frame num
+    .hs_video_delay_frame = 2,    //enter high speed video  delay frame num
+    .slim_video_delay_frame = 2,//enter slim video delay frame num
+
+    .isp_driving_current = ISP_DRIVING_6MA, //mclk driving current
+    .sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,//sensor_interface_type
+    .mipi_sensor_type = MIPI_OPHY_NCSI2, //0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2
+    .mipi_settle_delay_mode = MIPI_SETTLEDELAY_AUTO,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
+    .sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_B,//sensor output first pixel color
+    .mclk = 24,//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
+    .mipi_lane_num = SENSOR_MIPI_1_LANE,//mipi lane num
+    .i2c_addr_table = {0x42, 0xff},//record sensor support all write id addr, only supprt 4must end with 0xff
+};
+
+
+static imgsensor_struct imgsensor = {
+    .mirror = IMAGE_NORMAL,                //mirrorflip information
+    .sensor_mode = IMGSENSOR_MODE_INIT, //IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
+    .shutter = 0x3ED,                    //current shutter
+    .gain = 0x40,                        //current gain
+    .dummy_pixel = 0,                    //current dummypixel
+    .dummy_line = 0,                    //current dummyline
+    .current_fps = 300,  //full size current fps : 24fps for PIP, 30fps for Normal or ZSD
+    .autoflicker_en = KAL_FALSE,  //auto flicker enable: KAL_FALSE for disable auto flicker, KAL_TRUE for enable auto flicker
+    .test_pattern = KAL_FALSE,        //test pattern mode or not. KAL_FALSE for in test pattern mode, KAL_TRUE for normal output
+    .current_scenario_id = MSDK_SCENARIO_ID_CAMERA_PREVIEW,//current scenario id
+    .ihdr_en = 0, //sensor need support LE, SE with HDR feature
+    .i2c_write_id = 0x42,//record current sensor's i2c write id
+};
+
+
+/* Sensor output window information */
+static SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[5] =
+{
+	{ 800, 480,	 0,    0, 800, 480, 800,  480, 0000, 0000, 800,  480, 	 0,    0, 800,  480}, // Preview 
+	{ 800, 480,	 0,    0, 800, 480, 800,  480, 0000, 0000, 800,  480, 	 0,    0, 800,  480}, // capture 
+	{ 800, 480,	 0,    0, 800, 480, 800,  480, 0000, 0000, 800,  480, 	 0,    0, 800,  480}, // video 
+	{ 800, 480,	 0,    0, 800, 480, 800,  480, 0000, 0000, 800,  480, 	 0,    0, 800,  480}, //hight speed video 
+	{ 800, 480,	 0,    0, 800, 480, 800,  480, 0000, 0000, 800,  480, 	 0,    0, 800,  480} // slim video
+}; 
+
+static kal_uint16 read_cmos_sensor(kal_uint32 addr)
+{
+	kal_uint16 get_byte=0;
+
+	char pu_send_cmd[1] = {(char)(addr & 0xFF) };
+	iReadRegI2C(pu_send_cmd, 1, (u8*)&get_byte, 1, imgsensor.i2c_write_id);
+
+	return get_byte;
+}
+
+static void write_cmos_sensor(kal_uint32 addr, kal_uint32 para)
+{
+#if 1
+		char pu_send_cmd[2] = {(char)(addr & 0xFF), (char)(para & 0xFF)};
+		iWriteRegI2C(pu_send_cmd, 2, imgsensor.i2c_write_id);
+#else
+		iWriteReg((u16)addr, (u32)para, 2, imgsensor.i2c_write_id);
+#endif
+}
+
+static void set_dummy()
+{
+
+
+}    /*    set_dummy  */
+
+static kal_uint32 return_sensor_id()
+{
+    return ((read_cmos_sensor(0xf0) << 8) | read_cmos_sensor(0xf1));
+}
+static void set_max_framerate(UINT16 framerate,kal_bool min_framelength_en)
+{
+    //kal_int16 dummy_line;
+    kal_uint32 frame_length = imgsensor.frame_length;
+    //unsigned long flags;
+
+    LOG_INF("framerate = %d, min framelength should enable = %d\n", framerate,min_framelength_en);
+
+    frame_length = imgsensor.pclk / framerate * 10 / imgsensor.line_length;
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.frame_length = (frame_length > imgsensor.min_frame_length) ? frame_length : imgsensor.min_frame_length;
+    imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
+    //dummy_line = frame_length - imgsensor.min_frame_length;
+    //if (dummy_line < 0)
+        //imgsensor.dummy_line = 0;
+    //else
+        //imgsensor.dummy_line = dummy_line;
+    //imgsensor.frame_length = frame_length + imgsensor.dummy_line;
+    if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+    {
+        imgsensor.frame_length = imgsensor_info.max_frame_length;
+        imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
+    }
+    if (min_framelength_en)
+        imgsensor.min_frame_length = imgsensor.frame_length;
+    spin_unlock(&imgsensor_drv_lock);
+    set_dummy();
+}    /*    set_max_framerate  */
+
+
+/*************************************************************************
+* FUNCTION
+*    set_shutter
+*
+* DESCRIPTION
+*    This function set e-shutter of sensor to change exposure time.
+*
+* PARAMETERS
+*    iShutter : exposured lines
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static void set_shutter(kal_uint16 shutter)
+{
+    unsigned long flags;
+    //kal_uint16 realtime_fps = 0;
+    //kal_uint32 frame_length = 0;
+    spin_lock_irqsave(&imgsensor_drv_lock, flags);
+    imgsensor.shutter = shutter;
+    spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
+
+    spin_lock(&imgsensor_drv_lock);
+    if (shutter > imgsensor.min_frame_length - imgsensor_info.margin)
+        imgsensor.frame_length = shutter + imgsensor_info.margin;
+    else
+        imgsensor.frame_length = imgsensor.min_frame_length;
+    if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+        imgsensor.frame_length = imgsensor_info.max_frame_length;
+    spin_unlock(&imgsensor_drv_lock);
+    shutter = (shutter < imgsensor_info.min_shutter) ? imgsensor_info.min_shutter : shutter;
+    shutter = (shutter > (imgsensor_info.max_frame_length - imgsensor_info.margin)) ? (imgsensor_info.max_frame_length - imgsensor_info.margin) : shutter;
+
+	// Update Shutter
+	if(shutter > 4095) shutter = 4095;
+	if(shutter < 6) shutter = 6;
+/*	
+	if(shutter < 480)
+	{
+		write_cmos_sensor(0x18,0x02);
+	}
+	else
+	{
+		write_cmos_sensor(0x18,0x12);		
+	}
+*/	
+	write_cmos_sensor(0x04, shutter & 0xFF);	
+	write_cmos_sensor(0x03, (shutter>>8) & 0x0F);
+
+    LOG_INF("Exit! shutter =%d, framelength =%d\n", shutter,imgsensor.frame_length);
+
+}    /*    set_shutter */
+
+/*
+static kal_uint16 gain2reg(const kal_uint16 gain)
+{
+    kal_uint16 reg_gain = 0x0000;
+
+    reg_gain = ((gain / BASEGAIN) << 4) + ((gain % BASEGAIN) * 16 / BASEGAIN);
+    reg_gain = reg_gain & 0xFFFF;
+    return (kal_uint16)reg_gain;
+}
+*/
+
+/*************************************************************************
+* FUNCTION
+*    set_gain
+*
+* DESCRIPTION
+*    This function is to set global gain to sensor.
+*
+* PARAMETERS
+*    iGain : sensor global gain(base: 0x40)
+*
+* RETURNS
+*    the actually gain set to sensor.
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint16 set_gain(kal_uint16 gain)
+{
+#define ANALOG_GAIN_1 64  // 1.00x
+#define ANALOG_GAIN_2 87  // 1.36x
+#define ANALOG_GAIN_3 119  // 1.86x
+#define ANALOG_GAIN_4 161  // 2.52x
+#define ANALOG_GAIN_5 243  // 3.79x
+#define ANALOG_GAIN_6 340  // 5.32x
+#define ANALOG_GAIN_7 484  // 7.57x
+			
+	kal_uint16 iReg,temp,temp1; 	
+
+	
+	iReg = gain;
+	
+	if(iReg < 0x40)
+		iReg = 0x40;
+		
+	if((ANALOG_GAIN_1<= iReg)&&(iReg < ANALOG_GAIN_2))
+	{
+		//analog gain
+		write_cmos_sensor(0xb6, 0x00);
+		temp = iReg;
+		write_cmos_sensor(0xb1, temp>>6);
+		write_cmos_sensor(0xb2, (temp<<2)&0xfc);
+		LOG_INF("GC0409 analogic gain 1x , GC0409 add pregain = %d\n",temp);
+	}
+	else if(ANALOG_GAIN_2<= iReg)
+	{
+		//analog gain
+		write_cmos_sensor(0xb6, 0x01);
+		temp = 64*iReg/ANALOG_GAIN_2;
+		write_cmos_sensor(0xb1, temp>>6);
+		write_cmos_sensor(0xb2, (temp<<2)&0xfc);
+		LOG_INF("GC0409 analogic gain 1.36x , GC0409 add pregain = %d\n",temp);		
+	}
+
+/*
+	if(iReg < 0x40)
+		iReg = 0x40;
+		
+	if((ANALOG_GAIN_1<= iReg)&&(iReg < ANALOG_GAIN_2))
+	{
+		write_cmos_sensor(0x29, 0x0f); 
+		write_cmos_sensor(0xb0, 0x79);	
+		//analog gain
+		write_cmos_sensor(0xb6, 0x00);
+		temp = iReg;
+		write_cmos_sensor(0xb1, temp>>6);
+		write_cmos_sensor(0xb2, (temp<<2)&0xfc);
+		LOG_INF("GC0409 analogic gain 1x , GC0409 add pregain = %d\n",temp);
+	}
+	else if((ANALOG_GAIN_2<= iReg)&&(iReg < ANALOG_GAIN_3))
+	{
+		write_cmos_sensor(0x29, 0x0f); 
+		write_cmos_sensor(0xb0, 0x79);
+		//analog gain
+		write_cmos_sensor(0xb6, 0x01);
+		temp = 64*iReg/ANALOG_GAIN_2;
+		write_cmos_sensor(0xb1, temp>>6);
+		write_cmos_sensor(0xb2, (temp<<2)&0xfc);
+		LOG_INF("GC0409 analogic gain 1.36x , GC0409 add pregain = %d\n",temp);		
+	}
+	
+	else if((ANALOG_GAIN_3<= iReg)&&(iReg < ANALOG_GAIN_4))
+	{
+		write_cmos_sensor(0x29, 0x14); 
+		write_cmos_sensor(0xb0, 0x79);
+		//analog gain
+		write_cmos_sensor(0xb6, 0x02);
+		temp = 64*iReg/ANALOG_GAIN_3;
+		write_cmos_sensor(0xb1, temp>>6);
+		write_cmos_sensor(0xb2, (temp<<2)&0xfc);
+		LOG_INF("GC0409 analogic gain 1.86x , GC0409 add pregain = %d\n",temp); 
+	}
+	else if((ANALOG_GAIN_4<= iReg)&&(iReg < ANALOG_GAIN_5))
+	{
+		write_cmos_sensor(0x29, 0x14); 
+		write_cmos_sensor(0xb0, 0x79);
+		//analog gain
+		write_cmos_sensor(0xb6,	0x03);
+		temp = 64*iReg/ANALOG_GAIN_4;
+		write_cmos_sensor(0xb1, temp>>6);
+		write_cmos_sensor(0xb2, (temp<<2)&0xfc);
+		LOG_INF("GC0409 analogic gain 2.52x, temp = %d\n", temp);
+	}
+	else if((ANALOG_GAIN_5<= iReg)&&(iReg < ANALOG_GAIN_6))
+	{
+		write_cmos_sensor(0x29, 0x14); 
+		write_cmos_sensor(0xb0, 0x7c);
+		//analog gain
+		write_cmos_sensor(0xb6,  0x04);
+		temp = 64*iReg/ANALOG_GAIN_5;
+		write_cmos_sensor(0xb1, temp>>6);
+		write_cmos_sensor(0xb2, (temp<<2)&0xfc);
+		//SENSORDB("GC0409 analogic gain 3.79x , add pregain = %d\n",temp);
+	}
+	else if((ANALOG_GAIN_6<= iReg)&&(iReg < ANALOG_GAIN_7))
+	{
+		write_cmos_sensor(0x29, 0x14); 
+		write_cmos_sensor(0xb0, 0x7c);
+		//analog gain
+		write_cmos_sensor(0xb6,  0x05);
+		temp = 64*iReg/ANALOG_GAIN_6;
+		write_cmos_sensor(0xb1, temp>>6);
+		write_cmos_sensor(0xb2, (temp<<2)&0xfc);
+		//SENSORDB("GC0409 analogic gain 5.32x , add pregain = %d\n",temp);
+	}
+	else if(ANALOG_GAIN_7<= iReg)
+	{	
+		write_cmos_sensor(0x29, 0x14); 
+		write_cmos_sensor(0xb0, 0x7c);
+		//analog gain
+		write_cmos_sensor(0xb6,  0x06);
+		temp = 64*iReg/ANALOG_GAIN_7;
+		write_cmos_sensor(0xb1, temp>>6);
+		write_cmos_sensor(0xb2, (temp<<2)&0xfc);
+		//SENSORDB("GC0409 analogic gain 7.57x , add pregain = %d\n",temp);
+	}
+*/
+	
+	return gain;
+
+}    /*    set_gain  */
+
+static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gain)
+{
+    LOG_INF("le:0x%x, se:0x%x, gain:0x%x\n",le,se,gain);
+
+}
+
+static void set_mirror_flip(kal_uint8 image_mirror)
+{
+	LOG_INF("image_mirror = %d\n", image_mirror);
+}
+
+/*************************************************************************
+* FUNCTION
+*    night_mode
+*
+* DESCRIPTION
+*    This function night mode of sensor.
+*
+* PARAMETERS
+*    bEnable: KAL_TRUE -> enable night mode, otherwise, disable night mode
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static void night_mode(kal_bool enable)
+{
+/*No Need to implement this function*/
+}    /*    night_mode    */
+
+static void sensor_init(void)
+{
+////////////////////////////////////////////////////
+/////////////////////	SYS		////////////////////
+////////////////////////////////////////////////////
+	write_cmos_sensor(0xfe, 0x80);
+	write_cmos_sensor(0xfe, 0x80);
+	write_cmos_sensor(0xfe, 0x80);
+	write_cmos_sensor(0xf7, 0x01);
+	write_cmos_sensor(0xf8, 0x05);
+	write_cmos_sensor(0xf9, 0x0f);//[0] not_use_pll
+	write_cmos_sensor(0xfa, 0x00);
+	write_cmos_sensor(0xfc, 0x0f);//[0] apwd
+	write_cmos_sensor(0xfe, 0x00);
+	
+////////////////////////////////////////////////////
+/////////////// ANALOG & CISCTL/////////////////////
+////////////////////////////////////////////////////
+	write_cmos_sensor(0xfe, 0x00);
+	write_cmos_sensor(0x03, 0x01);//01
+	write_cmos_sensor(0x04, 0xf4);//e0//Exp_time
+	write_cmos_sensor(0x05, 0x06);//02
+	write_cmos_sensor(0x06, 0x08);//84//HB
+	write_cmos_sensor(0x07, 0x00);
+	write_cmos_sensor(0x08, 0x04);//24//VB
+	write_cmos_sensor(0x0a, 0x00);//row_start
+	write_cmos_sensor(0x0c, 0x04);
+	write_cmos_sensor(0x0d, 0x01);
+	write_cmos_sensor(0x0e, 0xe8);
+	write_cmos_sensor(0x0f, 0x03);
+	write_cmos_sensor(0x10, 0x30);//win_width
+	write_cmos_sensor(0x17, MIRROR);//Don't Change Here!!!
+	write_cmos_sensor(0x18, 0x12);
+	write_cmos_sensor(0x19, 0x0b);//0d//AD_pipe_number
+	write_cmos_sensor(0x1a, 0x1b);
+	write_cmos_sensor(0x1d, 0x4c);
+	write_cmos_sensor(0x1e, 0x50);
+	write_cmos_sensor(0x1f, 0x80);
+	write_cmos_sensor(0x23, 0x01);//00//[0]vpix_sw
+	write_cmos_sensor(0x24, 0xc8);
+	write_cmos_sensor(0x25, 0xe2);
+	write_cmos_sensor(0x27, 0xaf);
+	write_cmos_sensor(0x28, 0x24);
+	write_cmos_sensor(0x29, 0x0f);//0d//[5:0]buf_EQ_post_width
+	write_cmos_sensor(0x2f, 0x14);
+	write_cmos_sensor(0x3f, 0x18);//tx en
+	write_cmos_sensor(0x72, 0x98);//58//[7]vrefrh_en [6:4]rsgh_r
+	write_cmos_sensor(0x73, 0x9a);
+	write_cmos_sensor(0x74, 0x47);//49//[3]RESTH_sw [2:0]noican
+	write_cmos_sensor(0x76, 0xb2);
+	write_cmos_sensor(0x7a, 0xcb);//fb//[5:4]vpix_r
+	write_cmos_sensor(0xc2, 0x0c);
+	write_cmos_sensor(0xd0, 0x10);	
+	write_cmos_sensor(0xdc, 0x75);
+	write_cmos_sensor(0xeb, 0x78);
+
+////////////////////////////////////////////////////
+/////////////////////	ISP 	  //////////////////
+////////////////////////////////////////////////////
+	write_cmos_sensor(0xfe, 0x00);
+	write_cmos_sensor(0x90, 0x01);
+	write_cmos_sensor(0x92, STARTX);//Don't Change Here!!!
+	write_cmos_sensor(0x94, STARTY);//Don't Change Here!!!
+	write_cmos_sensor(0x95, 0x01);
+	write_cmos_sensor(0x96, 0xe0);
+	write_cmos_sensor(0x97, 0x03);
+	write_cmos_sensor(0x98, 0x20);
+	write_cmos_sensor(0xb0, 0x79);//global_gain[7:3]
+	write_cmos_sensor(0x67, 0x02);//global_gain[2:0]
+	write_cmos_sensor(0xb1, 0x01);
+	write_cmos_sensor(0xb2, 0x00);	
+	write_cmos_sensor(0xb6, 0x00);
+	write_cmos_sensor(0xb3, 0x40);
+	write_cmos_sensor(0xb4, 0x40);
+	write_cmos_sensor(0xb5, 0x40);
+	
+////////////////////////////////////////////////////
+/////////////////////	 BLK		////////////////
+////////////////////////////////////////////////////
+	write_cmos_sensor(0x40, 0x26); 
+	write_cmos_sensor(0x4f, BLK_VAL);//Don't Change Here!!!
+	
+/////////////////////////////////////////////////////     
+//////////////////////	dark sun	/////////////////      
+/////////////////////////////////////////////////////
+	write_cmos_sensor(0xfe, 0x00);
+	write_cmos_sensor(0xe0, 0x9f);
+	write_cmos_sensor(0xe4, 0x0f);
+	write_cmos_sensor(0xe5, 0xff);
+	
+////////////////////////////////////////////////////
+/////////////////////	 MIPI	////////////////////
+////////////////////////////////////////////////////
+	write_cmos_sensor(0xfe, 0x03);
+	write_cmos_sensor(0x10, 0x80);	
+	write_cmos_sensor(0x01, 0x03);
+	write_cmos_sensor(0x02, 0x44);
+	write_cmos_sensor(0x03, 0x96);
+	write_cmos_sensor(0x04, 0x01);
+	write_cmos_sensor(0x05, 0x00);
+	write_cmos_sensor(0x06, 0x80);
+	write_cmos_sensor(0x11, 0x2b);
+	write_cmos_sensor(0x12, 0xe8);
+	write_cmos_sensor(0x13, 0x03);
+	write_cmos_sensor(0x15, 0x00);
+	write_cmos_sensor(0x21, 0x10);
+	write_cmos_sensor(0x22, 0x00);
+	write_cmos_sensor(0x23, 0x0a);
+	write_cmos_sensor(0x24, 0x10);
+	write_cmos_sensor(0x25, 0x10);
+	write_cmos_sensor(0x26, 0x03);
+	write_cmos_sensor(0x29, 0x01);
+	write_cmos_sensor(0x2a, 0x0a);
+	write_cmos_sensor(0x2b, 0x03);
+	write_cmos_sensor(0xfe, 0x00);
+	write_cmos_sensor(0xf9, 0x0e);//[0] not_use_pll
+	write_cmos_sensor(0xfc, 0x0e);//[0] apwd
+	write_cmos_sensor(0xfe, 0x00);
+}    /*    sensor_init  */
+
+
+static void preview_setting(void)
+{
+	LOG_INF("E!\n");
+	//MIPI//
+	write_cmos_sensor(0xfe,0x03);
+	write_cmos_sensor(0x10,0x90);
+	write_cmos_sensor(0xfe,0x00);	
+	
+}    /*    preview_setting  */
+
+static void capture_setting(kal_uint16 currefps)
+{
+	LOG_INF("E! currefps:%d\n",currefps);
+	write_cmos_sensor(0xfe,0x03);
+	write_cmos_sensor(0x10,0x90);
+	write_cmos_sensor(0xfe,0x00);
+		
+}
+
+
+static void normal_video_setting(kal_uint16 currefps)
+{
+	LOG_INF("E! currefps:%d\n",currefps);
+	
+	write_cmos_sensor(0xfe,0x03);
+	write_cmos_sensor(0x10,0x90);
+	write_cmos_sensor(0xfe,0x00);
+		
+}
+
+static void hs_video_setting()
+{
+    LOG_INF("E\n");
+	write_cmos_sensor(0xfe,0x03);
+	write_cmos_sensor(0x10,0x90);
+	write_cmos_sensor(0xfe,0x00);
+}
+
+static void slim_video_setting()
+{
+    LOG_INF("E\n");
+	write_cmos_sensor(0xfe,0x03);
+	write_cmos_sensor(0x10,0x90);
+	write_cmos_sensor(0xfe,0x00);
+}
+
+static kal_uint32 set_test_pattern_mode(kal_bool enable)
+{
+    LOG_INF("enable: %d\n", enable);
+
+    if (enable) 
+	{
+        //write_cmos_sensor(0xfe, 0x00);
+    } 
+	else 
+	{
+        //write_cmos_sensor(0xfe, 0x00);
+    }
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.test_pattern = enable;
+    spin_unlock(&imgsensor_drv_lock);
+    return ERROR_NONE;
+}
+
+/*************************************************************************
+* FUNCTION
+*    get_imgsensor_id
+*
+* DESCRIPTION
+*    This function get the sensor ID
+*
+* PARAMETERS
+*    *sensorID : return the sensor ID
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 get_imgsensor_id(UINT32 *sensor_id)
+{
+    kal_uint8 i = 0;
+    kal_uint8 retry = 2;
+    //sensor have two i2c address 0x42 0x43, we should detect the module used i2c address
+    while (imgsensor_info.i2c_addr_table[i] != 0xff) {
+        spin_lock(&imgsensor_drv_lock);
+        imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
+        spin_unlock(&imgsensor_drv_lock);
+        do {
+            *sensor_id = return_sensor_id();
+            if (*sensor_id == imgsensor_info.sensor_id) {
+                LOG_INF("GC0409 get_imgsensor_id i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
+                return ERROR_NONE;
+            }
+            LOG_INF("GC0409 get_imgsensor_id Read sensor id fail, write id: 0x%x, id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
+            retry--;
+        } while(retry > 0);
+        i++;
+        retry = 2;
+    }
+    if (*sensor_id != imgsensor_info.sensor_id) {
+        // if Sensor ID is not correct, Must set *sensor_id to 0xFFFFFFFF
+        *sensor_id = 0xFFFFFFFF;
+        return ERROR_SENSOR_CONNECT_FAIL;
+    }
+    return ERROR_NONE;
+}
+
+
+/*************************************************************************
+* FUNCTION
+*    open
+*
+* DESCRIPTION
+*    This function initialize the registers of CMOS sensor
+*
+* PARAMETERS
+*    None
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 open(void)
+{
+    kal_uint8 i = 0;
+    kal_uint8 retry = 2;
+    kal_uint32 sensor_id = 0;
+    //LOG_1;
+    //LOG_2;
+    //sensor have two i2c address 0x42 0x43, we should detect the module used i2c address
+    while (imgsensor_info.i2c_addr_table[i] != 0xff) 
+    {
+        spin_lock(&imgsensor_drv_lock);
+        imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
+        spin_unlock(&imgsensor_drv_lock);
+	 do {
+	    sensor_id = return_sensor_id();
+	    if (sensor_id == imgsensor_info.sensor_id) 
+	    {
+	        LOG_INF("GC0409 open i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
+	        break;
+	    }
+	   	 LOG_INF("GC0409 open Read sensor id fail, write id: 0x%x, id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
+	   	 retry--;
+	 } while(retry > 0);
+	
+        i++;
+        if (sensor_id == imgsensor_info.sensor_id)
+            break;
+        retry = 2;
+    }
+	
+    if (imgsensor_info.sensor_id != sensor_id)
+        return ERROR_SENSOR_CONNECT_FAIL;
+
+    /* initail sequence write in  */
+    sensor_init();
+
+    spin_lock(&imgsensor_drv_lock);
+
+    imgsensor.autoflicker_en= KAL_FALSE;
+    imgsensor.sensor_mode = IMGSENSOR_MODE_INIT;
+    imgsensor.pclk = imgsensor_info.pre.pclk;
+    imgsensor.frame_length = imgsensor_info.pre.framelength;
+    imgsensor.line_length = imgsensor_info.pre.linelength;
+    imgsensor.min_frame_length = imgsensor_info.pre.framelength;
+    imgsensor.dummy_pixel = 0;
+    imgsensor.dummy_line = 0;
+    imgsensor.ihdr_en = 0;
+    imgsensor.test_pattern = KAL_FALSE;
+    imgsensor.current_fps = imgsensor_info.pre.max_framerate;
+    spin_unlock(&imgsensor_drv_lock);
+
+    return ERROR_NONE;
+}    /*    open  */
+
+/*************************************************************************
+* FUNCTION
+*    close
+*
+* DESCRIPTION
+*
+*
+* PARAMETERS
+*    None
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 close(void)
+{
+    LOG_INF("E\n");
+
+    /*No Need to implement this function*/
+
+    return ERROR_NONE;
+}    /*    close  */
+
+
+/*************************************************************************
+* FUNCTION
+* preview
+*
+* DESCRIPTION
+*    This function start the sensor preview.
+*
+* PARAMETERS
+*    *image_window : address pointer of pixel numbers in one period of HSYNC
+*  *sensor_config_data : address pointer of line numbers in one period of VSYNC
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_PREVIEW;
+    imgsensor.pclk = imgsensor_info.pre.pclk;
+    //imgsensor.video_mode = KAL_FALSE;
+    imgsensor.line_length = imgsensor_info.pre.linelength;
+    imgsensor.frame_length = imgsensor_info.pre.framelength;
+    imgsensor.min_frame_length = imgsensor_info.pre.framelength;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    preview_setting();
+	//set_mirror_flip(sensor_config_data->SensorImageMirror);
+    return ERROR_NONE;
+}    /*    preview   */
+
+/*************************************************************************
+* FUNCTION
+*    capture
+*
+* DESCRIPTION
+*    This function setup the CMOS sensor in capture MY_OUTPUT mode
+*
+* PARAMETERS
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                          MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+	
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_CAPTURE;
+    if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {//PIP capture: 24fps for less than 13M, 20fps for 16M,15fps for 20M
+        imgsensor.pclk = imgsensor_info.cap1.pclk;
+        imgsensor.line_length = imgsensor_info.cap1.linelength;
+        imgsensor.frame_length = imgsensor_info.cap1.framelength;
+        imgsensor.min_frame_length = imgsensor_info.cap1.framelength;
+        imgsensor.autoflicker_en = KAL_FALSE;
+    } else {
+        if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
+            LOG_INF("Warning: current_fps %d fps is not support, so use cap's setting: %d fps!\n",imgsensor.current_fps,imgsensor_info.cap.max_framerate/10);
+        imgsensor.pclk = imgsensor_info.cap.pclk;
+        imgsensor.line_length = imgsensor_info.cap.linelength;
+        imgsensor.frame_length = imgsensor_info.cap.framelength;
+        imgsensor.min_frame_length = imgsensor_info.cap.framelength;
+        imgsensor.autoflicker_en = KAL_FALSE;
+    }
+    spin_unlock(&imgsensor_drv_lock);
+    capture_setting(imgsensor.current_fps);
+	//set_mirror_flip(sensor_config_data->SensorImageMirror);
+    return ERROR_NONE;
+}    /* capture() */
+static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_VIDEO;
+    imgsensor.pclk = imgsensor_info.normal_video.pclk;
+    imgsensor.line_length = imgsensor_info.normal_video.linelength;
+    imgsensor.frame_length = imgsensor_info.normal_video.framelength;
+    imgsensor.min_frame_length = imgsensor_info.normal_video.framelength;
+    //imgsensor.current_fps = 300;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    normal_video_setting(imgsensor.current_fps);	
+	//set_mirror_flip(sensor_config_data->SensorImageMirror);
+    return ERROR_NONE;
+}    /*    normal_video   */
+
+static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_HIGH_SPEED_VIDEO;
+    imgsensor.pclk = imgsensor_info.hs_video.pclk;
+    //imgsensor.video_mode = KAL_TRUE;
+    imgsensor.line_length = imgsensor_info.hs_video.linelength;
+    imgsensor.frame_length = imgsensor_info.hs_video.framelength;
+    imgsensor.min_frame_length = imgsensor_info.hs_video.framelength;
+    imgsensor.dummy_line = 0;
+    imgsensor.dummy_pixel = 0;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    hs_video_setting();	
+	//set_mirror_flip(sensor_config_data->SensorImageMirror);
+    return ERROR_NONE;
+}    /*    hs_video   */
+
+static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_SLIM_VIDEO;
+    imgsensor.pclk = imgsensor_info.slim_video.pclk;
+    imgsensor.line_length = imgsensor_info.slim_video.linelength;
+    imgsensor.frame_length = imgsensor_info.slim_video.framelength;
+    imgsensor.min_frame_length = imgsensor_info.slim_video.framelength;
+    imgsensor.dummy_line = 0;
+    imgsensor.dummy_pixel = 0;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    slim_video_setting();
+	//set_mirror_flip(sensor_config_data->SensorImageMirror);
+
+    return ERROR_NONE;
+}    /*    slim_video     */
+
+
+
+static kal_uint32 get_resolution(MSDK_SENSOR_RESOLUTION_INFO_STRUCT *sensor_resolution)
+{
+    LOG_INF("E\n");
+    sensor_resolution->SensorFullWidth = imgsensor_info.cap.grabwindow_width;
+    sensor_resolution->SensorFullHeight = imgsensor_info.cap.grabwindow_height;
+
+    sensor_resolution->SensorPreviewWidth = imgsensor_info.pre.grabwindow_width;
+    sensor_resolution->SensorPreviewHeight = imgsensor_info.pre.grabwindow_height;
+
+    sensor_resolution->SensorVideoWidth = imgsensor_info.normal_video.grabwindow_width;
+    sensor_resolution->SensorVideoHeight = imgsensor_info.normal_video.grabwindow_height;
+
+
+    sensor_resolution->SensorHighSpeedVideoWidth = imgsensor_info.hs_video.grabwindow_width;
+    sensor_resolution->SensorHighSpeedVideoHeight = imgsensor_info.hs_video.grabwindow_height;
+
+    sensor_resolution->SensorSlimVideoWidth = imgsensor_info.slim_video.grabwindow_width;
+    sensor_resolution->SensorSlimVideoHeight = imgsensor_info.slim_video.grabwindow_height;
+    return ERROR_NONE;
+}    /*    get_resolution    */
+
+static kal_uint32 get_info(MSDK_SCENARIO_ID_ENUM scenario_id,
+                      MSDK_SENSOR_INFO_STRUCT *sensor_info,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("scenario_id = %d\n", scenario_id);
+
+    //sensor_info->SensorVideoFrameRate = imgsensor_info.normal_video.max_framerate/10; /* not use */
+    //sensor_info->SensorStillCaptureFrameRate= imgsensor_info.cap.max_framerate/10; /* not use */
+    //imgsensor_info->SensorWebCamCaptureFrameRate= imgsensor_info.v.max_framerate; /* not use */
+
+    sensor_info->SensorClockPolarity = SENSOR_CLOCK_POLARITY_LOW;
+    sensor_info->SensorClockFallingPolarity = SENSOR_CLOCK_POLARITY_LOW; /* not use */
+    sensor_info->SensorHsyncPolarity = SENSOR_CLOCK_POLARITY_LOW; // inverse with datasheet
+    sensor_info->SensorVsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
+    sensor_info->SensorInterruptDelayLines = 4; /* not use */
+    sensor_info->SensorResetActiveHigh = FALSE; /* not use */
+    sensor_info->SensorResetDelayCount = 5; /* not use */
+
+    sensor_info->SensroInterfaceType = imgsensor_info.sensor_interface_type;
+    sensor_info->MIPIsensorType = imgsensor_info.mipi_sensor_type;
+    sensor_info->SettleDelayMode = imgsensor_info.mipi_settle_delay_mode;
+    sensor_info->SensorOutputDataFormat = imgsensor_info.sensor_output_dataformat;
+
+    sensor_info->CaptureDelayFrame = imgsensor_info.cap_delay_frame;
+    sensor_info->PreviewDelayFrame = imgsensor_info.pre_delay_frame;
+    sensor_info->VideoDelayFrame = imgsensor_info.video_delay_frame;
+    sensor_info->HighSpeedVideoDelayFrame = imgsensor_info.hs_video_delay_frame;
+    sensor_info->SlimVideoDelayFrame = imgsensor_info.slim_video_delay_frame;
+
+    sensor_info->SensorMasterClockSwitch = 0; /* not use */
+    sensor_info->SensorDrivingCurrent = imgsensor_info.isp_driving_current;
+
+    sensor_info->AEShutDelayFrame = imgsensor_info.ae_shut_delay_frame;          /* The frame of setting shutter default 0 for TG int */
+    sensor_info->AESensorGainDelayFrame = imgsensor_info.ae_sensor_gain_delay_frame;    /* The frame of setting sensor gain */
+    sensor_info->AEISPGainDelayFrame = imgsensor_info.ae_ispGain_delay_frame;
+    sensor_info->IHDR_Support = imgsensor_info.ihdr_support;
+    sensor_info->IHDR_LE_FirstLine = imgsensor_info.ihdr_le_firstline;
+    sensor_info->SensorModeNum = imgsensor_info.sensor_mode_num;
+
+    sensor_info->SensorMIPILaneNumber = imgsensor_info.mipi_lane_num;
+    sensor_info->SensorClockFreq = imgsensor_info.mclk;
+    sensor_info->SensorClockDividCount = 3; /* not use */
+    sensor_info->SensorClockRisingCount = 0;
+    sensor_info->SensorClockFallingCount = 2; /* not use */
+    sensor_info->SensorPixelClockCount = 3; /* not use */
+    sensor_info->SensorDataLatchCount = 2; /* not use */
+
+    sensor_info->MIPIDataLowPwr2HighSpeedTermDelayCount = 0;
+    sensor_info->MIPICLKLowPwr2HighSpeedTermDelayCount = 0;
+    sensor_info->SensorWidthSampling = 0;  // 0 is default 1x
+    sensor_info->SensorHightSampling = 0;    // 0 is default 1x
+    sensor_info->SensorPacketECCOrder = 1;
+
+    switch (scenario_id) {
+        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+            sensor_info->SensorGrabStartX = imgsensor_info.pre.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
+
+            break;
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+            sensor_info->SensorGrabStartX = imgsensor_info.cap.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.cap.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.cap.mipi_data_lp2hs_settle_dc;
+
+            break;
+        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+
+            sensor_info->SensorGrabStartX = imgsensor_info.normal_video.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.normal_video.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.normal_video.mipi_data_lp2hs_settle_dc;
+
+            break;
+        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+            sensor_info->SensorGrabStartX = imgsensor_info.hs_video.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.hs_video.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.hs_video.mipi_data_lp2hs_settle_dc;
+
+            break;
+        case MSDK_SCENARIO_ID_SLIM_VIDEO:
+            sensor_info->SensorGrabStartX = imgsensor_info.slim_video.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.slim_video.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.slim_video.mipi_data_lp2hs_settle_dc;
+
+            break;
+        default:
+            sensor_info->SensorGrabStartX = imgsensor_info.pre.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
+            break;
+    }
+
+    return ERROR_NONE;
+}    /*    get_info  */
+
+
+static kal_uint32 control(MSDK_SCENARIO_ID_ENUM scenario_id, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("scenario_id = %d\n", scenario_id);
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.current_scenario_id = scenario_id;
+    spin_unlock(&imgsensor_drv_lock);
+    switch (scenario_id) {
+        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+            preview(image_window, sensor_config_data);
+            break;
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+            capture(image_window, sensor_config_data);
+            break;
+        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+            normal_video(image_window, sensor_config_data);
+            break;
+        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+            hs_video(image_window, sensor_config_data);
+            break;
+        case MSDK_SCENARIO_ID_SLIM_VIDEO:
+            slim_video(image_window, sensor_config_data);
+            break;
+        default:
+            LOG_INF("Error ScenarioId setting");
+            preview(image_window, sensor_config_data);
+            return ERROR_INVALID_SCENARIO_ID;
+    }
+    return ERROR_NONE;
+}    /* control() */
+
+
+
+static kal_uint32 set_video_mode(UINT16 framerate)
+{//This Function not used after ROME
+    LOG_INF("framerate = %d\n ", framerate);
+    // SetVideoMode Function should fix framerate
+    if (framerate == 0)
+        // Dynamic frame rate
+        return ERROR_NONE;
+    spin_lock(&imgsensor_drv_lock);
+    if ((framerate == 300) && (imgsensor.autoflicker_en == KAL_TRUE))
+        imgsensor.current_fps = 296;
+    else if ((framerate == 150) && (imgsensor.autoflicker_en == KAL_TRUE))
+        imgsensor.current_fps = 146;
+    else
+        imgsensor.current_fps = framerate;
+    spin_unlock(&imgsensor_drv_lock);
+    set_max_framerate(imgsensor.current_fps,1);
+
+    return ERROR_NONE;
+}
+
+static kal_uint32 set_auto_flicker_mode(kal_bool enable, UINT16 framerate)
+{
+    LOG_INF("enable = %d, framerate = %d \n", enable, framerate);
+    spin_lock(&imgsensor_drv_lock);
+    if (enable) //enable auto flicker
+        imgsensor.autoflicker_en = KAL_TRUE;
+    else //Cancel Auto flick
+        imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    return ERROR_NONE;
+}
+
+
+static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 framerate)
+{
+    kal_uint32 frame_length;
+
+    LOG_INF("scenario_id = %d, framerate = %d\n", scenario_id, framerate);
+
+    switch (scenario_id) {
+        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+            frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            set_dummy();
+            break;
+        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+            if(framerate == 0)
+                return ERROR_NONE;
+            frame_length = imgsensor_info.normal_video.pclk / framerate * 10 / imgsensor_info.normal_video.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.normal_video.framelength) ? (frame_length - imgsensor_info.normal_video.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.normal_video.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            set_dummy();
+            break;
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+        	  if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {
+                frame_length = imgsensor_info.cap1.pclk / framerate * 10 / imgsensor_info.cap1.linelength;
+                spin_lock(&imgsensor_drv_lock);
+		            imgsensor.dummy_line = (frame_length > imgsensor_info.cap1.framelength) ? (frame_length - imgsensor_info.cap1.framelength) : 0;
+		            imgsensor.frame_length = imgsensor_info.cap1.framelength + imgsensor.dummy_line;
+		            imgsensor.min_frame_length = imgsensor.frame_length;
+		            spin_unlock(&imgsensor_drv_lock);
+            } else {
+        		    if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
+                    LOG_INF("Warning: current_fps %d fps is not support, so use cap's setting: %d fps!\n",framerate,imgsensor_info.cap.max_framerate/10);
+                frame_length = imgsensor_info.cap.pclk / framerate * 10 / imgsensor_info.cap.linelength;
+                spin_lock(&imgsensor_drv_lock);
+		            imgsensor.dummy_line = (frame_length > imgsensor_info.cap.framelength) ? (frame_length - imgsensor_info.cap.framelength) : 0;
+		            imgsensor.frame_length = imgsensor_info.cap.framelength + imgsensor.dummy_line;
+		            imgsensor.min_frame_length = imgsensor.frame_length;
+		            spin_unlock(&imgsensor_drv_lock);
+            }
+            set_dummy();
+            break;
+        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+            frame_length = imgsensor_info.hs_video.pclk / framerate * 10 / imgsensor_info.hs_video.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.hs_video.framelength) ? (frame_length - imgsensor_info.hs_video.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.hs_video.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            set_dummy();
+            break;
+        case MSDK_SCENARIO_ID_SLIM_VIDEO:
+            frame_length = imgsensor_info.slim_video.pclk / framerate * 10 / imgsensor_info.slim_video.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.slim_video.framelength) ? (frame_length - imgsensor_info.slim_video.framelength): 0;
+            imgsensor.frame_length = imgsensor_info.slim_video.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            set_dummy();
+            break;
+        default:  //coding with  preview scenario by default
+            frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            set_dummy();
+            LOG_INF("error scenario_id = %d, we use preview scenario \n", scenario_id);
+            break;
+    }
+    return ERROR_NONE;
+}
+
+
+static kal_uint32 get_default_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 *framerate)
+{
+    LOG_INF("scenario_id = %d\n", scenario_id);
+
+    switch (scenario_id) {
+        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+            *framerate = imgsensor_info.pre.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+            *framerate = imgsensor_info.normal_video.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+            *framerate = imgsensor_info.cap.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+            *framerate = imgsensor_info.hs_video.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_SLIM_VIDEO:
+            *framerate = imgsensor_info.slim_video.max_framerate;
+            break;
+        default:
+            break;
+    }
+
+    return ERROR_NONE;
+}
+
+
+
+static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
+                             UINT8 *feature_para,UINT32 *feature_para_len)
+{
+    UINT16 *feature_return_para_16=(UINT16 *) feature_para;
+    UINT16 *feature_data_16=(UINT16 *) feature_para;
+    UINT32 *feature_return_para_32=(UINT32 *) feature_para;
+    UINT32 *feature_data_32=(UINT32 *) feature_para;
+    unsigned long long *feature_data=(unsigned long long *) feature_para;
+    //unsigned long long *feature_return_para=(unsigned long long *) feature_para;
+
+    SENSOR_WINSIZE_INFO_STRUCT *wininfo;
+    MSDK_SENSOR_REG_INFO_STRUCT *sensor_reg_data=(MSDK_SENSOR_REG_INFO_STRUCT *) feature_para;
+
+    LOG_INF("feature_id = %d\n", feature_id);
+    switch (feature_id) {
+        case SENSOR_FEATURE_GET_PERIOD:
+            *feature_return_para_16++ = imgsensor.line_length;
+            *feature_return_para_16 = imgsensor.frame_length;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:
+            *feature_return_para_32 = imgsensor.pclk;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_SET_ESHUTTER:
+            set_shutter(*feature_data);
+            break;
+        case SENSOR_FEATURE_SET_NIGHTMODE:
+            night_mode((BOOL) *feature_data);
+            break;
+        case SENSOR_FEATURE_SET_GAIN:
+            set_gain((UINT16) *feature_data);
+            break;
+        case SENSOR_FEATURE_SET_FLASHLIGHT:
+            break;
+        case SENSOR_FEATURE_SET_ISP_MASTER_CLOCK_FREQ:
+            break;
+        case SENSOR_FEATURE_SET_REGISTER:
+            write_cmos_sensor(sensor_reg_data->RegAddr, sensor_reg_data->RegData);
+            break;
+        case SENSOR_FEATURE_GET_REGISTER:
+            sensor_reg_data->RegData = read_cmos_sensor(sensor_reg_data->RegAddr);
+            break;
+        case SENSOR_FEATURE_GET_LENS_DRIVER_ID:
+            // get the lens driver ID from EEPROM or just return LENS_DRIVER_ID_DO_NOT_CARE
+            // if EEPROM does not exist in camera module.
+            *feature_return_para_32=LENS_DRIVER_ID_DO_NOT_CARE;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_SET_VIDEO_MODE:
+            set_video_mode(*feature_data);
+            break;
+        case SENSOR_FEATURE_CHECK_SENSOR_ID:
+            get_imgsensor_id(feature_return_para_32);
+            break;
+        case SENSOR_FEATURE_SET_AUTO_FLICKER_MODE:
+            set_auto_flicker_mode((BOOL)*feature_data_16,*(feature_data_16+1));
+            break;
+        case SENSOR_FEATURE_SET_MAX_FRAME_RATE_BY_SCENARIO:
+            set_max_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data, *(feature_data+1));
+            break;
+        case SENSOR_FEATURE_GET_DEFAULT_FRAME_RATE_BY_SCENARIO:
+            get_default_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*(feature_data), (MUINT32 *)(uintptr_t)(*(feature_data+1)));
+            break;
+        case SENSOR_FEATURE_SET_TEST_PATTERN:
+            set_test_pattern_mode((BOOL)*feature_data);
+            break;
+        case SENSOR_FEATURE_GET_TEST_PATTERN_CHECKSUM_VALUE: //for factory mode auto testing
+            *feature_return_para_32 = imgsensor_info.checksum_value;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_SET_FRAMERATE:
+            LOG_INF("current fps :%d\n", (UINT32)*feature_data);
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.current_fps = *feature_data;
+            spin_unlock(&imgsensor_drv_lock);
+            break;
+        case SENSOR_FEATURE_SET_HDR:
+            LOG_INF("ihdr enable :%d\n", (BOOL)*feature_data);
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.ihdr_en = (BOOL)*feature_data;
+            spin_unlock(&imgsensor_drv_lock);
+            break;
+        case SENSOR_FEATURE_GET_CROP_INFO:
+            LOG_INF("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n", (UINT32)*feature_data);
+
+            wininfo = (SENSOR_WINSIZE_INFO_STRUCT *)(uintptr_t)(*(feature_data+1));
+
+            switch (*feature_data_32) {
+                case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[1],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[2],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[3],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_SLIM_VIDEO:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[4],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+                default:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[0],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+            }
+            //break;
+        case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
+            LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",(UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
+            ihdr_write_shutter_gain((UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
+            break;
+        default:
+            break;
+    }
+
+    return ERROR_NONE;
+}    /*    feature_control()  */
+
+static SENSOR_FUNCTION_STRUCT sensor_func = {
+    open,
+    get_info,
+    get_resolution,
+    feature_control,
+    control,
+    close
+};
+
+UINT32 GC0409MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
+{
+    /* To Do : Check Sensor status here */
+    if (pfFunc!=NULL)
+        *pfFunc=&sensor_func;
+    return ERROR_NONE;
+}    /*    GC0409MIPI_RAW_SensorInit    */
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc0409_mipi_raw/gc0409mipi_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc0409_mipi_raw/gc0409mipi_Sensor.h
new file mode 100755
index 0000000..07b7aed
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc0409_mipi_raw/gc0409mipi_Sensor.h
@@ -0,0 +1,139 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *     GC0409mipi_Sensor.h
+ *
+ * Project:
+ * --------
+ *     ALPS
+ *
+ * Description:
+ * ------------
+ *     CMOS sensor header file
+ *
+ ****************************************************************************/
+#ifndef _GC0409MIPI_SENSOR_H
+#define _GC0409MIPI_SENSOR_H
+
+
+typedef enum{
+    IMGSENSOR_MODE_INIT,
+    IMGSENSOR_MODE_PREVIEW,
+    IMGSENSOR_MODE_CAPTURE,
+    IMGSENSOR_MODE_VIDEO,
+    IMGSENSOR_MODE_HIGH_SPEED_VIDEO,
+    IMGSENSOR_MODE_SLIM_VIDEO,
+} IMGSENSOR_MODE;
+
+typedef struct imgsensor_mode_struct {
+    kal_uint32 pclk;                //record different mode's pclk
+    kal_uint32 linelength;            //record different mode's linelength
+    kal_uint32 framelength;            //record different mode's framelength
+
+    kal_uint8 startx;                //record different mode's startx of grabwindow
+    kal_uint8 starty;                //record different mode's startx of grabwindow
+
+    kal_uint16 grabwindow_width;    //record different mode's width of grabwindow
+    kal_uint16 grabwindow_height;    //record different mode's height of grabwindow
+
+    /*     following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario    */
+    kal_uint8 mipi_data_lp2hs_settle_dc;
+
+    /*     following for GetDefaultFramerateByScenario()    */
+    kal_uint16 max_framerate;
+
+} imgsensor_mode_struct;
+
+/* SENSOR PRIVATE STRUCT FOR VARIABLES*/
+typedef struct imgsensor_struct {
+    kal_uint8 mirror;                //mirrorflip information
+
+    kal_uint8 sensor_mode;            //record IMGSENSOR_MODE enum value
+
+    kal_uint32 shutter;                //current shutter
+    kal_uint16 gain;                //current gain
+
+    kal_uint32 pclk;                //current pclk
+
+    kal_uint32 frame_length;        //current framelength
+    kal_uint32 line_length;            //current linelength
+
+    kal_uint32 min_frame_length;    //current min  framelength to max framerate
+    kal_uint16 dummy_pixel;            //current dummypixel
+    kal_uint16 dummy_line;            //current dummline
+
+    kal_uint16 current_fps;            //current max fps
+    kal_bool   autoflicker_en;        //record autoflicker enable or disable
+    kal_bool test_pattern;            //record test pattern mode or not
+    MSDK_SCENARIO_ID_ENUM current_scenario_id;//current scenario id
+    kal_uint8  ihdr_en;                //ihdr enable or disable
+
+    kal_uint8 i2c_write_id;            //record current sensor's i2c write id
+} imgsensor_struct;
+
+/* SENSOR PRIVATE STRUCT FOR CONSTANT*/
+typedef struct imgsensor_info_struct {
+    kal_uint32 sensor_id;            //record sensor id defined in Kd_imgsensor.h
+    kal_uint32 checksum_value;        //checksum value for Camera Auto Test
+    imgsensor_mode_struct pre;        //preview scenario relative information
+    imgsensor_mode_struct cap;        //capture scenario relative information
+    imgsensor_mode_struct cap1;        //capture for PIP 24fps relative information, capture1 mode must use same framelength, linelength with Capture mode for shutter calculate
+    imgsensor_mode_struct normal_video;//normal video  scenario relative information
+    imgsensor_mode_struct hs_video;    //high speed video scenario relative information
+    imgsensor_mode_struct slim_video;    //slim video for VT scenario relative information
+
+    kal_uint8  ae_shut_delay_frame;    //shutter delay frame for AE cycle
+    kal_uint8  ae_sensor_gain_delay_frame;    //sensor gain delay frame for AE cycle
+    kal_uint8  ae_ispGain_delay_frame;    //isp gain delay frame for AE cycle
+    kal_uint8  ihdr_support;        //1, support; 0,not support
+    kal_uint8  ihdr_le_firstline;    //1,le first ; 0, se first
+    kal_uint8  sensor_mode_num;        //support sensor mode num
+
+    kal_uint8  cap_delay_frame;        //enter capture delay frame num
+    kal_uint8  pre_delay_frame;        //enter preview delay frame num
+    kal_uint8  video_delay_frame;    //enter video delay frame num
+    kal_uint8  hs_video_delay_frame;    //enter high speed video  delay frame num
+    kal_uint8  slim_video_delay_frame;    //enter slim video delay frame num
+
+    kal_uint8  margin;                //sensor framelength & shutter margin
+    kal_uint32 min_shutter;            //min shutter
+    kal_uint32 max_frame_length;    //max framelength by sensor register's limitation
+
+    kal_uint8  isp_driving_current;    //mclk driving current
+    kal_uint8  sensor_interface_type;//sensor_interface_type
+    kal_uint8  mipi_sensor_type; //0,MIPI_OPHY_NCSI2; 1,MIPI_OPHY_CSI2, default is NCSI2, don't modify this para
+    kal_uint8  mipi_settle_delay_mode; //0, high speed signal auto detect; 1, use settle delay,unit is ns, default is auto detect, don't modify this para
+    kal_uint8  sensor_output_dataformat;//sensor output first pixel color
+    kal_uint8  mclk;                //mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
+
+    kal_uint8  mipi_lane_num;        //mipi lane num
+    kal_uint8  i2c_addr_table[5];    //record sensor support all write id addr, only supprt 4must end with 0xff
+} imgsensor_info_struct;
+
+/* SENSOR READ/WRITE ID */
+
+#define GC0409_VALID_IXEL_NUMS            800
+#define GC0409_VALID_LINE_NUMS            480
+#define GC0409_DEFAULT_DUMMY_PIXEL_NUMS   0x608
+#define GC0409_DEFAULT_DUMMY_LINE_NUMS    0x04
+
+#define GC0409_INTERNAL_DUMMY_PIXEL_NUMS  56
+#define GC0409_INTERNAL_DUMMY_LINE_NUMS   16
+
+#define GC0409_VIDEO_PERIOD_PIXEL_NUMS          (2400)
+#define GC0409_VIDEO_PERIOD_LINE_NUMS           (500)
+#define GC0409_PV_PERIOD_PIXEL_NUMS            (2400)
+#define GC0409_PV_PERIOD_LINE_NUMS             (500)
+
+#define GC0409_FULL_PERIOD_PIXEL_NUMS          (2400)
+#define GC0409_FULL_PERIOD_LINE_NUMS           (500)
+
+
+// end
+
+extern int iReadRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u8 * a_pRecvData, u16 a_sizeRecvData, u16 i2cId);
+extern int iWriteRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u16 i2cId);
+extern int iWriteReg(u16 a_u2Addr , u32 a_u4Data , u32 a_u4Bytes , u16 i2cId); 
+
+#endif
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2155mipi_yuv/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2155mipi_yuv/Makefile
new file mode 100755
index 0000000..d4287c0
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2155mipi_yuv/Makefile
@@ -0,0 +1,4 @@
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+obj-y += gc2155mipi_yuv_Sensor.o
+
+
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2155mipi_yuv/gc2155mipi_yuv_CameraCustomized.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2155mipi_yuv/gc2155mipi_yuv_CameraCustomized.h
new file mode 100755
index 0000000..220f867
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2155mipi_yuv/gc2155mipi_yuv_CameraCustomized.h
@@ -0,0 +1,163 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*****************************************************************************
+*  Copyright Statement:
+*  --------------------
+*  This software is protected by Copyright and the information contained
+*  herein is confidential. The software may not be copied and the information
+*  contained herein may not be used or disclosed except with the written
+*  permission of MediaTek Inc. (C) 2008
+*
+*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
+*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
+*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
+*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
+*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
+*
+*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
+*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
+*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+*
+*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
+*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
+*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
+*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
+*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
+*
+*****************************************************************************/
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *   sensor.h
+ *
+ * Project:
+ * --------
+ *   DUMA
+ *
+ * Description:
+ * ------------
+ *   Header file of camera customized parameters.
+ *
+ *
+ * Author:
+ * -------
+ *   Leo Lee
+ *
+ *============================================================================
+ *             HISTORY
+ * Below this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *------------------------------------------------------------------------------
+ * $Revision:$
+ * $Modtime:$
+ * $Log:$
+ *
+ * [GC2155MIPIYUV V1.0.0]
+ * 8.17.2012 Leo.Lee
+ * .First Release
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by GalaxyCoreinc. DO NOT MODIFY!!
+ *============================================================================
+ ****************************************************************************/
+
+#ifndef __CAMERA_CUSTOMIZED_H
+#define __CAMERA_CUSTOMIZED_H
+
+// the angle between handset and sensor placement in clockwise, should be one of 0, 90, 270
+#define MAIN_SENSOR_ORIENTATION_ANGLE	90
+#define SUB_SENSOR_ORIENTATION_ANGLE	0		// do not care if the sub sensor does not exist
+
+
+// First, we think you hold the cell phone vertical.
+// Second, we suppose the direction of upward is 0
+// Third, it is 90, 180, 270 in clockwise
+// here we define the main sensor and sub sensor angles to deal with the jpeg orientation
+#define MAIN_SENSOR_TO_PHONE_ANGLE	90
+#define SUB_SENSOR_TO_PHONE_ANGLE	0
+
+
+#define CAM_SIZE_QVGA_WIDTH 	320
+#define CAM_SIZE_QVGA_HEIGHT 	240
+#define CAM_SIZE_VGA_WIDTH 		640
+#define CAM_SIZE_VGA_HEIGHT 	480
+#define CAM_SIZE_05M_WIDTH 		800
+#define CAM_SIZE_05M_HEIGHT 	600
+#define CAM_SIZE_1M_WIDTH 		1280
+#define CAM_SIZE_1M_HEIGHT 		960
+#define CAM_SIZE_2M_WIDTH 		1600
+#define CAM_SIZE_2M_HEIGHT 		1200
+#define CAM_SIZE_3M_WIDTH 		2048
+#define CAM_SIZE_3M_HEIGHT 		1536
+#define CAM_SIZE_5M_WIDTH 		2592
+#define CAM_SIZE_5M_HEIGHT 		1944
+
+// for main sensor
+#define MAIN_NUM_OF_PREVIEW_RESOLUTION 3
+#define MAIN_NUM_OF_VIDEO_RESOLUTION 4
+#define MAIN_NUM_OF_STILL_RESOLUTION 7
+#define MAIN_VIDEO_RESOLUTION_PROFILE		{{176,144},{320,240},{640,480},{720,480}}
+#define MAIN_PREVIEW_RESOLUTION_PROFILE	{{232,174},{320,240},{240,320}}
+#define MAIN_STILL_RESOLUTION_PROFILE		{{CAM_SIZE_QVGA_WIDTH,CAM_SIZE_QVGA_HEIGHT}, \
+									 {CAM_SIZE_VGA_WIDTH,CAM_SIZE_VGA_HEIGHT}, \
+									 {CAM_SIZE_05M_WIDTH,CAM_SIZE_05M_HEIGHT}, \
+									 {CAM_SIZE_1M_WIDTH,CAM_SIZE_1M_HEIGHT}, \
+									 {CAM_SIZE_2M_WIDTH,CAM_SIZE_2M_HEIGHT}, \
+									 {CAM_SIZE_3M_WIDTH,CAM_SIZE_3M_HEIGHT}, \
+									 {CAM_SIZE_5M_WIDTH,CAM_SIZE_5M_HEIGHT}}
+
+// if sub sensor does not exist, set all the parameters as 0
+#define SUB_NUM_OF_PREVIEW_RESOLUTION 0
+#define SUB_NUM_OF_VIDEO_RESOLUTION 0
+#define SUB_NUM_OF_STILL_RESOLUTION 0
+#define SUB_VIDEO_RESOLUTION_PROFILE		{{0,0}}
+#define SUB_PREVIEW_RESOLUTION_PROFILE		{{0,0}}
+#define SUB_STILL_RESOLUTION_PROFILE		{{0,0}}
+
+//#define NUM_OF_PREVIEW_RESOLUTION 	max(MAIN_NUM_OF_PREVIEW_RESOLUTION,SUB_NUM_OF_PREVIEW_RESOLUTION)
+//#define NUM_OF_VIDEO_RESOLUTION 	max(MAIN_NUM_OF_VIDEO_RESOLUTION,SUB_NUM_OF_VIDEO_RESOLUTION)
+//#define NUM_OF_STILL_RESOLUTION 	max(MAIN_NUM_OF_STILL_RESOLUTION,SUB_NUM_OF_STILL_RESOLUTION)
+
+#define NUM_OF_VIDEO_STREAM_BUFF	8	// Maximun is 8
+#endif
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2155mipi_yuv/gc2155mipi_yuv_Camera_Sensor_para.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2155mipi_yuv/gc2155mipi_yuv_Camera_Sensor_para.h
new file mode 100755
index 0000000..ee6afd3
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2155mipi_yuv/gc2155mipi_yuv_Camera_Sensor_para.h
@@ -0,0 +1,158 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*****************************************************************************
+*  Copyright Statement:
+*  --------------------
+*  This software is protected by Copyright and the information contained
+*  herein is confidential. The software may not be copied and the information
+*  contained herein may not be used or disclosed except with the written
+*  permission of MediaTek Inc. (C) 2008
+*
+*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
+*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
+*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
+*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
+*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
+*
+*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
+*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
+*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+*
+*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
+*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
+*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
+*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
+*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
+*
+*****************************************************************************/
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *   camera_sensor_para.h
+ *
+ * Project:
+ * --------
+ *   DUMA
+ *
+ * Description:
+ * ------------
+ *   Header file of Sensor tuning parameters that should be generated by CCT
+ *
+ *
+ * Author:
+ * -------
+ *   Leo Leo
+ *
+ *============================================================================
+ *             HISTORY
+ * Below this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *------------------------------------------------------------------------------
+ * $Revision:$
+ * $Modtime:$
+ * $Log:$
+ *
+ * [GC2155MIPIYUV V1.0.0]
+ * 8.17.2012 Leo.Lee
+ * .First Release
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by GalaxyCoreinc. DO NOT MODIFY!!
+ *============================================================================
+ ****************************************************************************/
+/* SENSOR FULL SIZE */
+#ifndef __CAMERA_SENSOR_PARA_H
+#define __CAMERA_SENSOR_PARA_H
+
+#define CAMERA_SENSOR_REG_DEFAULT_VALUE  \
+		/* ARRAY: SENSOR.reg[11] */\
+		{\
+			/* STRUCT: SENSOR.reg[0] */\
+			{\
+				/* SENSOR.reg[0].addr */ 0xFFFFFFFF, /* SENSOR.reg[0].para */ 0xFFFFFFFF\
+			},\
+			/* STRUCT: SENSOR.reg[1] */\
+			{\
+				/* SENSOR.reg[1].addr */ 0xFFFFFFFF, /* SENSOR.reg[1].para */ 0xFFFFFFFF\
+			},\
+			/* STRUCT: SENSOR.reg[2] */\
+			{\
+				/* SENSOR.reg[2].addr */ 0xFFFFFFFF, /* SENSOR.reg[2].para */ 0xFFFFFFFF\
+			},\
+			/* STRUCT: SENSOR.reg[3] */\
+			{\
+				/* SENSOR.reg[3].addr */ 0xFFFFFFFF, /* SENSOR.reg[3].para */ 0xFFFFFFFF\
+			},\
+			/* STRUCT: SENSOR.reg[4] */\
+			{\
+				/* SENSOR.reg[4].addr */ 0xFFFFFFFF, /* SENSOR.reg[4].para */ 0xFFFFFFFF\
+			},\
+			/* STRUCT: SENSOR.reg[5] */\
+			{\
+				/* SENSOR.reg[5].addr */ 0xFFFFFFFF, /* SENSOR.reg[5].para */ 0xFFFFFFFF\
+			},\
+			/* STRUCT: SENSOR.reg[6] */\
+			{\
+				/* SENSOR.reg[6].addr */ 0xFFFFFFFF, /* SENSOR.reg[6].para */ 0xFFFFFFFF\
+			},\
+			/* STRUCT: SENSOR.reg[7] */\
+			{\
+				/* SENSOR.reg[7].addr */ 0xFFFFFFFF, /* SENSOR.reg[7].para */ 0xFFFFFFFF\
+			},\
+			/* STRUCT: SENSOR.reg[8] */\
+			{\
+				/* SENSOR.reg[8].addr */ 0xFFFFFFFF, /* SENSOR.reg[8].para */ 0xFFFFFFFF\
+			},\
+			/* STRUCT: SENSOR.reg[9] */\
+			{\
+				/* SENSOR.reg[9].addr */ 0xFFFFFFFF, /* SENSOR.reg[9].para */ 0xFFFFFFFF\
+			},\
+			/* STRUCT: SENSOR.reg[10] */\
+			{\
+				/* SENSOR.reg[10].addr */ 0xFFFFFFFF, /* SENSOR.reg[10].para */ 0xFFFFFFFF\
+			}\
+		}
+
+#define CAMERA_SENSOR_CCT_DEFAULT_VALUE {{ 0xFFFFFFFF, 0xFFFFFFFF } ,{ 0xFFFFFFFF, 0xFFFFFFFF } ,{ 0xFFFFFFFF, 0xFFFFFFFF } ,{ 0xFFFFFFFF, 0xFFFFFFFF } ,{ 0xFFFFFFFF, 0xFFFFFFFF }}
+#endif /* __CAMERA_SENSOR_PARA_H */
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2155mipi_yuv/gc2155mipi_yuv_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2155mipi_yuv/gc2155mipi_yuv_Sensor.c
new file mode 100755
index 0000000..c6bb7cf
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2155mipi_yuv/gc2155mipi_yuv_Sensor.c
@@ -0,0 +1,2213 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*****************************************************************************
+*  Copyright Statement:
+*  --------------------
+*  This software is protected by Copyright and the information contained
+*  herein is confidential. The software may not be copied and the information
+*  contained herein may not be used or disclosed except with the written
+*  permission of MediaTek Inc. (C) 2008
+*
+*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
+*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
+*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
+*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
+*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
+*
+*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
+*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
+*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+*
+*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
+*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
+*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
+*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
+*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
+*
+*****************************************************************************/
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *   sensor.c
+ *
+ * Project:
+ * --------
+ *  
+ *
+ * Description:
+ * ------------
+ *   Source code of Sensor driver
+ *
+ *
+ * Author:
+ * -------
+ *   Leo Lee
+ *
+ *============================================================================
+ *             HISTORY
+ * Below this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *------------------------------------------------------------------------------
+ * $Revision:$
+ * $Modtime:$
+ * $Log:$
+ *
+ * [GC2155MIPIYUV V1.0.0]
+ * 8.17.2012 Leo.Lee
+ * .First Release
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by GalaxyCoreinc. DO NOT MODIFY!!
+ *============================================================================
+ ****************************************************************************/
+//#include <windows.h>
+//#include <memory.h>
+//#include <nkintr.h>
+//#include <ceddk.h>
+//#include <ceddk_exp.h>
+
+//#include "kal_release.h"
+//#include "i2c_exp.h"
+//#include "gpio_exp.h"
+//#include "msdk_exp.h"
+//#include "msdk_sensor_exp.h"
+//#include "msdk_isp_exp.h"
+//#include "base_regs.h"
+//#include "Sensor.h"
+//#include "camera_sensor_para.h"
+//#include "CameraCustomized.h"
+
+#include <linux/videodev2.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <asm/atomic.h>
+//#include <mach/mt6516_pll.h>
+
+#include "kd_camera_hw.h"
+#include "kd_imgsensor.h"
+#include "kd_imgsensor_define.h"
+#include "kd_imgsensor_errcode.h"
+#include "kd_camera_feature.h"
+
+#include "gc2155mipi_yuv_Sensor.h"
+#include "gc2155mipi_yuv_Camera_Sensor_para.h"
+#include "gc2155mipi_yuv_CameraCustomized.h"
+
+#define GC2155MIPIYUV_DEBUG
+#ifdef GC2155MIPIYUV_DEBUG
+#define SENSORDB printk
+#else
+#define SENSORDB(x,...)
+#endif
+
+#define GC2155MIPI_2Lane
+
+//#define DEBUG_SENSOR_GC2155MIPI
+
+#define  GC2155MIPI_SET_PAGE0    GC2155MIPI_write_cmos_sensor(0xfe,0x00)
+#define  GC2155MIPI_SET_PAGE1    GC2155MIPI_write_cmos_sensor(0xfe,0x01)
+#define  GC2155MIPI_SET_PAGE2    GC2155MIPI_write_cmos_sensor(0xfe,0x02)
+#define  GC2155MIPI_SET_PAGE3    GC2155MIPI_write_cmos_sensor(0xfe,0x03)
+
+
+extern int iReadRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u8 * a_pRecvData, u16 a_sizeRecvData, u16 i2cId);
+extern int iWriteRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u16 i2cId);
+/*************************************************************************
+* FUNCTION
+*    GC2155MIPI_write_cmos_sensor
+*
+* DESCRIPTION
+*    This function wirte data to CMOS sensor through I2C
+*
+* PARAMETERS
+*    addr: the 16bit address of register
+*    para: the 8bit value of register
+*
+* RETURNS
+*    None
+*
+* LOCAL AFFECTED
+*
+*************************************************************************/
+static void GC2155MIPI_write_cmos_sensor(kal_uint8 addr, kal_uint8 para)
+{
+kal_uint8 out_buff[2];
+
+    out_buff[0] = addr;
+    out_buff[1] = para;
+
+    iWriteRegI2C((u8*)out_buff , (u16)sizeof(out_buff), GC2155MIPI_WRITE_ID); 
+
+#if (defined(__GC2155MIPI_DEBUG_TRACE__))
+  if (sizeof(out_buff) != rt) printk("I2C write %x, %x error\n", addr, para);
+#endif
+}
+
+/*************************************************************************
+* FUNCTION
+*    GC2155MIPI_read_cmos_sensor
+*
+* DESCRIPTION
+*    This function read data from CMOS sensor through I2C.
+*
+* PARAMETERS
+*    addr: the 16bit address of register
+*
+* RETURNS
+*    8bit data read through I2C
+*
+* LOCAL AFFECTED
+*
+*************************************************************************/
+static kal_uint8 GC2155MIPI_read_cmos_sensor(kal_uint8 addr)
+{
+  kal_uint8 in_buff[1] = {0xFF};
+  kal_uint8 out_buff[1];
+  
+  out_buff[0] = addr;
+
+    if (0 != iReadRegI2C((u8*)out_buff , (u16) sizeof(out_buff), (u8*)in_buff, (u16) sizeof(in_buff), GC2155MIPI_WRITE_ID)) {
+        SENSORDB("ERROR: GC2155MIPI_read_cmos_sensor \n");
+    }
+
+#if (defined(__GC2155MIPI_DEBUG_TRACE__))
+  if (size != rt) printk("I2C read %x error\n", addr);
+#endif
+
+  return in_buff[0];
+}
+
+
+#ifdef DEBUG_SENSOR_GC2155MIPI
+#define gc2155mipi_OP_CODE_INI		0x00		/* Initial value. */
+#define gc2155mipi_OP_CODE_REG		0x01		/* Register */
+#define gc2155mipi_OP_CODE_DLY		0x02		/* Delay */
+#define gc2155mipi_OP_CODE_END		0x03		/* End of initial setting. */
+static kal_uint16 fromsd;
+
+typedef struct
+{
+	u16 init_reg;
+	u16 init_val;	/* Save the register value and delay tick */
+	u8 op_code;		/* 0 - Initial value, 1 - Register, 2 - Delay, 3 - End of setting. */
+} gc2155mipi_initial_set_struct;
+
+gc2155mipi_initial_set_struct gc2155mipi_Init_Reg[5000];
+
+static u32 strtol(const char *nptr, u8 base)
+{
+
+	printk("gc2155mipi___%s____\n",__func__); 
+
+	u8 ret;
+	if(!nptr || (base!=16 && base!=10 && base!=8))
+	{
+		printk("gc2155mipi %s(): NULL pointer input\n", __FUNCTION__);
+		return -1;
+	}
+	for(ret=0; *nptr; nptr++)
+	{
+		if((base==16 && *nptr>='A' && *nptr<='F') || 
+				(base==16 && *nptr>='a' && *nptr<='f') || 
+				(base>=10 && *nptr>='0' && *nptr<='9') ||
+				(base>=8 && *nptr>='0' && *nptr<='7') )
+		{
+			ret *= base;
+			if(base==16 && *nptr>='A' && *nptr<='F')
+				ret += *nptr-'A'+10;
+			else if(base==16 && *nptr>='a' && *nptr<='f')
+				ret += *nptr-'a'+10;
+			else if(base>=10 && *nptr>='0' && *nptr<='9')
+				ret += *nptr-'0';
+			else if(base>=8 && *nptr>='0' && *nptr<='7')
+				ret += *nptr-'0';
+		}
+		else
+			return ret;
+	}
+	return ret;
+}
+
+static u8 GC2155MIPI_Initialize_from_T_Flash()
+{
+	//FS_HANDLE fp = -1;				/* Default, no file opened. */
+	//u8 *data_buff = NULL;
+	u8 *curr_ptr = NULL;
+	u32 file_size = 0;
+	//u32 bytes_read = 0;
+	u32 i = 0, j = 0;
+	u8 func_ind[4] = {0};	/* REG or DLY */
+
+	printk("gc2155mipi___%s____11111111111111\n",__func__); 
+
+
+
+	struct file *fp; 
+	mm_segment_t fs; 
+	loff_t pos = 0; 
+	static u8 data_buff[10*1024] ;
+
+	fp = filp_open("/mnt/sdcard/gc2155mipi_sd.txt", O_RDONLY , 0); 
+	if (IS_ERR(fp)) 
+	{ 
+		printk("2155 create file error 1111111\n");  
+		return -1; 
+	} 
+	else
+	{
+		printk("2155 create file error 2222222\n");  
+	}
+	fs = get_fs(); 
+	set_fs(KERNEL_DS); 
+
+	file_size = vfs_llseek(fp, 0, SEEK_END);
+	vfs_read(fp, data_buff, file_size, &pos); 
+	//printk("%s %d %d\n", buf,iFileLen,pos); 
+	filp_close(fp, NULL); 
+	set_fs(fs);
+
+
+	printk("gc2155mipi___%s____22222222222222222\n",__func__); 
+
+
+
+	/* Start parse the setting witch read from t-flash. */
+	curr_ptr = data_buff;
+	while (curr_ptr < (data_buff + file_size))
+	{
+		while ((*curr_ptr == ' ') || (*curr_ptr == '\t'))/* Skip the Space & TAB */
+			curr_ptr++;				
+
+		if (((*curr_ptr) == '/') && ((*(curr_ptr + 1)) == '*'))
+		{
+			while (!(((*curr_ptr) == '*') && ((*(curr_ptr + 1)) == '/')))
+			{
+				curr_ptr++;		/* Skip block comment code. */
+			}
+
+			while (!((*curr_ptr == 0x0D) && (*(curr_ptr+1) == 0x0A)))
+			{
+				curr_ptr++;
+			}
+
+			curr_ptr += 2;						/* Skip the enter line */
+
+			continue ;
+		}
+
+		if (((*curr_ptr) == '/') || ((*curr_ptr) == '{') || ((*curr_ptr) == '}'))		/* Comment line, skip it. */
+		{
+			while (!((*curr_ptr == 0x0D) && (*(curr_ptr+1) == 0x0A)))
+			{
+				curr_ptr++;
+			}
+
+			curr_ptr += 2;						/* Skip the enter line */
+
+			continue ;
+		}
+		/* This just content one enter line. */
+		if (((*curr_ptr) == 0x0D) && ((*(curr_ptr + 1)) == 0x0A))
+		{
+			curr_ptr += 2;
+			continue ;
+		}
+		//printk(" curr_ptr1 = %s\n",curr_ptr);
+		memcpy(func_ind, curr_ptr, 3);
+
+
+		if (strcmp((const char *)func_ind, "REG") == 0)		/* REG */
+		{
+			curr_ptr += 6;				/* Skip "REG(0x" or "DLY(" */
+			gc2155mipi_Init_Reg[i].op_code = gc2155mipi_OP_CODE_REG;
+
+			gc2155mipi_Init_Reg[i].init_reg = strtol((const char *)curr_ptr, 16);
+			curr_ptr += 5;	/* Skip "00, 0x" */
+
+			gc2155mipi_Init_Reg[i].init_val = strtol((const char *)curr_ptr, 16);
+			curr_ptr += 4;	/* Skip "00);" */
+
+		}
+		else									/* DLY */
+		{
+			/* Need add delay for this setting. */ 
+			curr_ptr += 4;	
+			gc2155mipi_Init_Reg[i].op_code = gc2155mipi_OP_CODE_DLY;
+
+			gc2155mipi_Init_Reg[i].init_reg = 0xFF;
+			gc2155mipi_Init_Reg[i].init_val = strtol((const char *)curr_ptr,  10);	/* Get the delay ticks, the delay should less then 50 */
+		}
+		i++;
+
+
+		/* Skip to next line directly. */
+		while (!((*curr_ptr == 0x0D) && (*(curr_ptr+1) == 0x0A)))
+		{
+			curr_ptr++;
+		}
+		curr_ptr += 2;
+	}
+
+	/* (0xFFFF, 0xFFFF) means the end of initial setting. */
+	gc2155mipi_Init_Reg[i].op_code = gc2155mipi_OP_CODE_END;
+	gc2155mipi_Init_Reg[i].init_reg = 0xFF;
+	gc2155mipi_Init_Reg[i].init_val = 0xFF;
+	i++;
+	//for (j=0; j<i; j++)
+	printk("gc2155mipi %x  ==  %x\n",gc2155mipi_Init_Reg[j].init_reg, gc2155mipi_Init_Reg[j].init_val);
+	
+	printk("gc2155mipi___%s____3333333333333333\n",__func__); 
+
+	/* Start apply the initial setting to sensor. */
+#if 1
+	for (j=0; j<i; j++)
+	{
+		if (gc2155mipi_Init_Reg[j].op_code == gc2155mipi_OP_CODE_END)	/* End of the setting. */
+		{
+			printk("gc2155mipi REG OK -----------------END!\n");
+		
+			break ;
+		}
+		else if (gc2155mipi_Init_Reg[j].op_code == gc2155mipi_OP_CODE_DLY)
+		{
+			msleep(gc2155mipi_Init_Reg[j].init_val);		/* Delay */
+			printk("gc2155mipi REG OK -----------------DLY!\n");			
+		}
+		else if (gc2155mipi_Init_Reg[j].op_code == gc2155mipi_OP_CODE_REG)
+		{
+
+			GC2155MIPI_write_cmos_sensor(gc2155mipi_Init_Reg[j].init_reg, gc2155mipi_Init_Reg[j].init_val);
+			printk("gc2155mipi REG OK!-----------------REG(0x%x,0x%x)\n",gc2155mipi_Init_Reg[j].init_reg, gc2155mipi_Init_Reg[j].init_val);			
+			printk("gc2155mipi REG OK!-----------------REG(0x%x,0x%x)\n",gc2155mipi_Init_Reg[j].init_reg, gc2155mipi_Init_Reg[j].init_val);			
+			printk("gc2155mipi REG OK!-----------------REG(0x%x,0x%x)\n",gc2155mipi_Init_Reg[j].init_reg, gc2155mipi_Init_Reg[j].init_val);			
+			
+		}
+		else
+		{
+			printk("gc2155mipi REG ERROR!\n");
+		}
+	}
+#endif
+	return 1;	
+}
+
+#endif
+
+
+/*******************************************************************************
+* // Adapter for Winmo typedef 
+********************************************************************************/
+#define Sleep(ms) mdelay(ms)
+#define RETAILMSG(x,...)
+#define TEXT
+
+
+/*******************************************************************************
+* // End Adapter for Winmo typedef 
+********************************************************************************/
+/* Global Valuable */
+
+static kal_uint32 zoom_factor = 0; 
+
+static kal_bool GC2155MIPI_VEDIO_encode_mode = KAL_FALSE; //Picture(Jpeg) or Video(Mpeg4)
+static kal_bool GC2155MIPI_sensor_cap_state = KAL_FALSE; //Preview or Capture
+
+static kal_uint16 GC2155MIPI_exposure_lines=0, GC2155MIPI_extra_exposure_lines = 0;
+
+static kal_uint16 GC2155MIPI_Capture_Shutter=0;
+static kal_uint16 GC2155MIPI_Capture_Extra_Lines=0;
+
+kal_uint32 GC2155MIPI_capture_pclk_in_M=520,GC2155MIPI_preview_pclk_in_M=390,GC2155MIPI_PV_dummy_pixels=0,GC2155MIPI_PV_dummy_lines=0,GC2155MIPI_isp_master_clock=0;
+
+static kal_uint32  GC2155MIPI_sensor_pclk=390;
+
+static kal_uint32 Preview_Shutter = 0;
+static kal_uint32 Capture_Shutter = 0;
+
+MSDK_SENSOR_CONFIG_STRUCT GC2155MIPISensorConfigData;
+
+kal_uint16 GC2155MIPI_read_shutter(void)
+{
+	return  (GC2155MIPI_read_cmos_sensor(0x03) << 8)|GC2155MIPI_read_cmos_sensor(0x04) ;
+} /* GC2155MIPI read_shutter */
+
+
+
+static void GC2155MIPI_write_shutter(kal_uint32 shutter)
+{
+
+	if(shutter < 1)	
+ 	return;
+
+	GC2155MIPI_write_cmos_sensor(0x03, (shutter >> 8) & 0x1f);
+	GC2155MIPI_write_cmos_sensor(0x04, shutter & 0xff);
+}    /* GC2155MIPI_write_shutter */
+
+
+static void GC2155MIPI_set_mirror_flip(kal_uint8 image_mirror)
+{
+	kal_uint8 GC2155MIPI_HV_Mirror;
+
+	switch (image_mirror) 
+	{
+		case IMAGE_NORMAL:
+			GC2155MIPI_HV_Mirror = 0x14; 
+		    break;
+		case IMAGE_H_MIRROR:
+			GC2155MIPI_HV_Mirror = 0x15;
+		    break;
+		case IMAGE_V_MIRROR:
+			GC2155MIPI_HV_Mirror = 0x16; 
+		    break;
+		case IMAGE_HV_MIRROR:
+			GC2155MIPI_HV_Mirror = 0x17;
+		    break;
+		default:
+		    break;
+	}
+	GC2155MIPI_write_cmos_sensor(0x17, GC2155MIPI_HV_Mirror);
+}
+
+static void GC2155MIPI_set_AE_mode(kal_bool AE_enable)
+{
+	kal_uint8 temp_AE_reg = 0;
+
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+	if (AE_enable == KAL_TRUE)
+	{
+		// turn on AEC/AGC
+		GC2155MIPI_write_cmos_sensor(0xb6, 0x01);
+	}
+	else
+	{
+		// turn off AEC/AGC
+		GC2155MIPI_write_cmos_sensor(0xb6, 0x00);
+	}
+}
+
+
+static void GC2155MIPI_set_AWB_mode(kal_bool AWB_enable)
+{
+	kal_uint8 temp_AWB_reg = 0;
+
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+	temp_AWB_reg = GC2155MIPI_read_cmos_sensor(0x82);
+	if (AWB_enable == KAL_TRUE)
+	{
+		//enable Auto WB
+		temp_AWB_reg = temp_AWB_reg | 0x02;
+	}
+	else
+	{
+		//turn off AWB
+		temp_AWB_reg = temp_AWB_reg & 0xfd;
+	}
+	GC2155MIPI_write_cmos_sensor(0x82, temp_AWB_reg);
+}
+
+
+/*************************************************************************
+* FUNCTION
+*	GC2155MIPI_night_mode
+*
+* DESCRIPTION
+*	This function night mode of GC2155MIPI.
+*
+* PARAMETERS
+*	none
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+void GC2155MIPI_night_mode(kal_bool enable)
+{
+	
+		/* ==Video Preview, Auto Mode, use 39MHz PCLK, 30fps; Night Mode use 39M, 15fps */
+		if (GC2155MIPI_sensor_cap_state == KAL_FALSE) 
+		{
+			if (enable) 
+			{
+				if (GC2155MIPI_VEDIO_encode_mode == KAL_TRUE) 
+				{
+					GC2155MIPI_write_cmos_sensor(0xfe, 0x01);
+					GC2155MIPI_write_cmos_sensor(0x3c, 0x60);
+					GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+				}
+				else 
+				{
+					GC2155MIPI_write_cmos_sensor(0xfe, 0x01);
+					GC2155MIPI_write_cmos_sensor(0x3c, 0x60);
+					GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+				}
+			}
+			else 
+			{
+				/* when enter normal mode (disable night mode) without light, the AE vibrate */
+				if (GC2155MIPI_VEDIO_encode_mode == KAL_TRUE) 
+				{
+					GC2155MIPI_write_cmos_sensor(0xfe, 0x01);
+					GC2155MIPI_write_cmos_sensor(0x3c, 0x40);
+					GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+				}
+				else 
+				{
+					GC2155MIPI_write_cmos_sensor(0xfe, 0x01);
+					GC2155MIPI_write_cmos_sensor(0x3c, 0x40);
+					GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+				}
+		}
+	}
+}	/* GC2155MIPI_night_mode */
+
+
+
+/*************************************************************************
+* FUNCTION
+*	GC2155MIPI_GetSensorID
+*
+* DESCRIPTION
+*	This function get the sensor ID
+*
+* PARAMETERS
+*	None
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 GC2155MIPI_GetSensorID(kal_uint32 *sensorID)
+
+{
+	   int  retry = 3; 
+    // check if sensor ID correct
+    do {
+	
+	*sensorID=((GC2155MIPI_read_cmos_sensor(0xf0) << 8) | GC2155MIPI_read_cmos_sensor(0xf1));	
+	 if (*sensorID == GC2155MIPI_SENSOR_ID)
+            break; 
+
+	SENSORDB("GC2155MIPI_GetSensorID:%x \n",*sensorID);
+	retry--;
+
+	  } while (retry > 0);
+	
+	if (*sensorID != GC2155MIPI_SENSOR_ID) {		
+		*sensorID = 0xFFFFFFFF;		
+		return ERROR_SENSOR_CONNECT_FAIL;
+	}
+	/* camera_pdn_reverse = 1; */
+	return ERROR_NONE;
+}   /* GC2155MIPIOpen  */
+
+static void GC2155MIPI_Sensor_Init(void)
+{
+	zoom_factor = 0; 
+	SENSORDB("GC2155MIPI_Sensor_Init");
+	GC2155MIPI_write_cmos_sensor(0xfe, 0xf0);
+	GC2155MIPI_write_cmos_sensor(0xfe, 0xf0);
+	GC2155MIPI_write_cmos_sensor(0xfe, 0xf0);
+	GC2155MIPI_write_cmos_sensor(0xfc, 0x06);
+	GC2155MIPI_write_cmos_sensor(0xf6, 0x00);
+	GC2155MIPI_write_cmos_sensor(0xf7, 0x1d);
+	GC2155MIPI_write_cmos_sensor(0xf8, 0x84);
+	GC2155MIPI_write_cmos_sensor(0xfa, 0x00);
+	GC2155MIPI_write_cmos_sensor(0xf9, 0x8e);
+	GC2155MIPI_write_cmos_sensor(0xf2, 0x00);
+	/////////////////////////////////////////////////
+	//////////////////ISP reg//////////////////////
+	////////////////////////////////////////////////////
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x03 , 0x04);
+	GC2155MIPI_write_cmos_sensor(0x04 , 0xe2);
+	GC2155MIPI_write_cmos_sensor(0x09 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x0a , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x0b , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x0c , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x0d , 0x04);
+	GC2155MIPI_write_cmos_sensor(0x0e , 0xc0);
+	GC2155MIPI_write_cmos_sensor(0x0f , 0x06);
+	GC2155MIPI_write_cmos_sensor(0x10 , 0x50);
+	GC2155MIPI_write_cmos_sensor(0x12 , 0x2e);
+	GC2155MIPI_write_cmos_sensor(0x17 , 0x14); // mirror
+	GC2155MIPI_write_cmos_sensor(0x18 , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x19 , 0x0e);
+	GC2155MIPI_write_cmos_sensor(0x1a , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x1b , 0x4b);
+	GC2155MIPI_write_cmos_sensor(0x1c , 0x07);
+	GC2155MIPI_write_cmos_sensor(0x1d , 0x10);
+	GC2155MIPI_write_cmos_sensor(0x1e , 0x98);
+	GC2155MIPI_write_cmos_sensor(0x1f , 0x78);
+	GC2155MIPI_write_cmos_sensor(0x20 , 0x05);
+	GC2155MIPI_write_cmos_sensor(0x21 , 0x40);
+	GC2155MIPI_write_cmos_sensor(0x22 , 0xf0);
+	GC2155MIPI_write_cmos_sensor(0x24 , 0x16);
+	GC2155MIPI_write_cmos_sensor(0x25 , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x26 , 0x10);
+	GC2155MIPI_write_cmos_sensor(0x2d , 0x40);
+	GC2155MIPI_write_cmos_sensor(0x30 , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x31 , 0x90);
+	GC2155MIPI_write_cmos_sensor(0x33 , 0x04);
+	GC2155MIPI_write_cmos_sensor(0x34 , 0x01);
+	/////////////////////////////////////////////////
+	//////////////////ISP reg////////////////////
+	/////////////////////////////////////////////////
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x80 , 0xff);
+	GC2155MIPI_write_cmos_sensor(0x81 , 0x2c);
+	GC2155MIPI_write_cmos_sensor(0x82 , 0xfa);
+	GC2155MIPI_write_cmos_sensor(0x83 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x84 , 0x03); //01
+	GC2155MIPI_write_cmos_sensor(0x85 , 0x08);// 
+	GC2155MIPI_write_cmos_sensor(0x86 , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x89 , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x8a , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x8b , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xb0 , 0x55);
+	GC2155MIPI_write_cmos_sensor(0xc3 , 0x11); //00
+	GC2155MIPI_write_cmos_sensor(0xc4 , 0x20);
+	GC2155MIPI_write_cmos_sensor(0xc5 , 0x30);
+	GC2155MIPI_write_cmos_sensor(0xc6 , 0x38);
+	GC2155MIPI_write_cmos_sensor(0xc7 , 0x40);
+	GC2155MIPI_write_cmos_sensor(0xec , 0x02);
+	GC2155MIPI_write_cmos_sensor(0xed , 0x04);
+	GC2155MIPI_write_cmos_sensor(0xee , 0x60);
+	GC2155MIPI_write_cmos_sensor(0xef , 0x90);
+	GC2155MIPI_write_cmos_sensor(0xb6 , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x90 , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x91 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x92 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x93 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x94 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x95 , 0x04);
+	GC2155MIPI_write_cmos_sensor(0x96 , 0xb0);
+	GC2155MIPI_write_cmos_sensor(0x97 , 0x06);
+	GC2155MIPI_write_cmos_sensor(0x98 , 0x40);
+	/////////////////////////////////////////
+	/////////// , 0xBLK ////////////////////////
+	/////////////////////////////////////////
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x18 , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x40 , 0x42);
+	GC2155MIPI_write_cmos_sensor(0x41 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x43 , 0x5b);
+	GC2155MIPI_write_cmos_sensor(0x5e , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x5f , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x60 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x61 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x62 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x63 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x64 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x65 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x66 , 0x20);
+	GC2155MIPI_write_cmos_sensor(0x67 , 0x20);
+	GC2155MIPI_write_cmos_sensor(0x68 , 0x20);
+	GC2155MIPI_write_cmos_sensor(0x69 , 0x20);
+	GC2155MIPI_write_cmos_sensor(0x6a , 0x08);
+	GC2155MIPI_write_cmos_sensor(0x6b , 0x08);
+	GC2155MIPI_write_cmos_sensor(0x6c , 0x08);
+	GC2155MIPI_write_cmos_sensor(0x6d , 0x08);
+	GC2155MIPI_write_cmos_sensor(0x6e , 0x08);
+	GC2155MIPI_write_cmos_sensor(0x6f , 0x08);
+	GC2155MIPI_write_cmos_sensor(0x70 , 0x08);
+	GC2155MIPI_write_cmos_sensor(0x71 , 0x08);
+	GC2155MIPI_write_cmos_sensor(0x72 , 0xf0);
+	GC2155MIPI_write_cmos_sensor(0x7e , 0x3c);
+	GC2155MIPI_write_cmos_sensor(0x7f , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+	////////////////////////////////////////
+	/////////// AEC ////////////////////////
+	////////////////////////////////////////
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x01 , 0x08);
+	GC2155MIPI_write_cmos_sensor(0x02 , 0xc0);
+	GC2155MIPI_write_cmos_sensor(0x03 , 0x04);
+	GC2155MIPI_write_cmos_sensor(0x04 , 0x90);
+	GC2155MIPI_write_cmos_sensor(0x05 , 0x30);
+	GC2155MIPI_write_cmos_sensor(0x06 , 0x98);
+	GC2155MIPI_write_cmos_sensor(0x07 , 0x28);
+	GC2155MIPI_write_cmos_sensor(0x08 , 0x6c);
+	GC2155MIPI_write_cmos_sensor(0x09 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x0a , 0xc2);
+	GC2155MIPI_write_cmos_sensor(0x0b , 0x11);
+	GC2155MIPI_write_cmos_sensor(0x0c , 0x10);
+	GC2155MIPI_write_cmos_sensor(0x13 , 0x2d);
+	GC2155MIPI_write_cmos_sensor(0x17 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x1c , 0x11);
+	GC2155MIPI_write_cmos_sensor(0x1e , 0x61);
+	GC2155MIPI_write_cmos_sensor(0x1f , 0x30);
+	GC2155MIPI_write_cmos_sensor(0x20 , 0x40);
+	GC2155MIPI_write_cmos_sensor(0x22 , 0x80);
+	GC2155MIPI_write_cmos_sensor(0x23 , 0x20);
+
+	GC2155MIPI_write_cmos_sensor(0x12 , 0x35);
+	GC2155MIPI_write_cmos_sensor(0x15 , 0x50);
+	GC2155MIPI_write_cmos_sensor(0x10 , 0x31);
+	GC2155MIPI_write_cmos_sensor(0x3e , 0x28);
+	GC2155MIPI_write_cmos_sensor(0x3f , 0xe0);
+	GC2155MIPI_write_cmos_sensor(0x40 , 0xe0);
+	GC2155MIPI_write_cmos_sensor(0x41 , 0x08);
+
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x0f , 0x05);
+	/////////////////////////////
+	//////// INTPEE /////////////
+	/////////////////////////////
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x90 , 0x6c);
+	GC2155MIPI_write_cmos_sensor(0x91 , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x92 , 0xc4);
+	GC2155MIPI_write_cmos_sensor(0x97 , 0x64);
+	GC2155MIPI_write_cmos_sensor(0x98 , 0x88);
+	GC2155MIPI_write_cmos_sensor(0x9d , 0x08);
+	GC2155MIPI_write_cmos_sensor(0xa2 , 0x11);
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+	/////////////////////////////
+	//////// DNDD///////////////
+	/////////////////////////////
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x80 , 0xc1);
+	GC2155MIPI_write_cmos_sensor(0x81 , 0x08);
+	GC2155MIPI_write_cmos_sensor(0x82 , 0x05);
+	GC2155MIPI_write_cmos_sensor(0x83 , 0x04);
+	GC2155MIPI_write_cmos_sensor(0x84 , 0x0a);
+	GC2155MIPI_write_cmos_sensor(0x86 , 0x80);
+	GC2155MIPI_write_cmos_sensor(0x87 , 0x30);
+	GC2155MIPI_write_cmos_sensor(0x88 , 0x15);
+	GC2155MIPI_write_cmos_sensor(0x89 , 0x80);
+	GC2155MIPI_write_cmos_sensor(0x8a , 0x60);
+	GC2155MIPI_write_cmos_sensor(0x8b , 0x30);
+	/////////////////////////////////////////
+	/////////// ASDE ////////////////////////
+	/////////////////////////////////////////
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x21 , 0x14);
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x3c , 0x06);
+	GC2155MIPI_write_cmos_sensor(0x3d , 0x40);
+	GC2155MIPI_write_cmos_sensor(0x48 , 0x30);
+	GC2155MIPI_write_cmos_sensor(0x49 , 0x06);
+	GC2155MIPI_write_cmos_sensor(0x4b , 0x08);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x20);
+	GC2155MIPI_write_cmos_sensor(0xa3 , 0x50);
+	GC2155MIPI_write_cmos_sensor(0xa4 , 0x30);
+	GC2155MIPI_write_cmos_sensor(0xa5 , 0x40);
+	GC2155MIPI_write_cmos_sensor(0xa6 , 0x80);
+	GC2155MIPI_write_cmos_sensor(0xab , 0x40);
+	GC2155MIPI_write_cmos_sensor(0xae , 0x0c);
+	GC2155MIPI_write_cmos_sensor(0xb3 , 0x42);
+	GC2155MIPI_write_cmos_sensor(0xb4 , 0x24);
+	GC2155MIPI_write_cmos_sensor(0xb6 , 0x50);
+	GC2155MIPI_write_cmos_sensor(0xb7 , 0x01);
+	GC2155MIPI_write_cmos_sensor(0xb9 , 0x28); 
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);	 
+	///////////////////gamma1////////////////////
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x10 , 0x0d);
+	GC2155MIPI_write_cmos_sensor(0x11 , 0x12);
+	GC2155MIPI_write_cmos_sensor(0x12 , 0x17);
+	GC2155MIPI_write_cmos_sensor(0x13 , 0x1c);
+	GC2155MIPI_write_cmos_sensor(0x14 , 0x27);
+	GC2155MIPI_write_cmos_sensor(0x15 , 0x34);
+	GC2155MIPI_write_cmos_sensor(0x16 , 0x44);
+	GC2155MIPI_write_cmos_sensor(0x17 , 0x55);
+	GC2155MIPI_write_cmos_sensor(0x18 , 0x6e);
+	GC2155MIPI_write_cmos_sensor(0x19 , 0x81);
+	GC2155MIPI_write_cmos_sensor(0x1a , 0x91);
+	GC2155MIPI_write_cmos_sensor(0x1b , 0x9c);
+	GC2155MIPI_write_cmos_sensor(0x1c , 0xaa);
+	GC2155MIPI_write_cmos_sensor(0x1d , 0xbb);
+	GC2155MIPI_write_cmos_sensor(0x1e , 0xca);
+	GC2155MIPI_write_cmos_sensor(0x1f , 0xd5);
+	GC2155MIPI_write_cmos_sensor(0x20 , 0xe0);
+	GC2155MIPI_write_cmos_sensor(0x21 , 0xe7);
+	GC2155MIPI_write_cmos_sensor(0x22 , 0xed);
+	GC2155MIPI_write_cmos_sensor(0x23 , 0xf6);
+	GC2155MIPI_write_cmos_sensor(0x24 , 0xfb);
+	GC2155MIPI_write_cmos_sensor(0x25 , 0xff);
+	///////////////////gamma2////////////////////
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x26 , 0x0d);
+	GC2155MIPI_write_cmos_sensor(0x27 , 0x12);
+	GC2155MIPI_write_cmos_sensor(0x28 , 0x17);
+	GC2155MIPI_write_cmos_sensor(0x29 , 0x1c);
+	GC2155MIPI_write_cmos_sensor(0x2a , 0x27);
+	GC2155MIPI_write_cmos_sensor(0x2b , 0x34);
+	GC2155MIPI_write_cmos_sensor(0x2c , 0x44);
+	GC2155MIPI_write_cmos_sensor(0x2d , 0x55);
+	GC2155MIPI_write_cmos_sensor(0x2e , 0x6e);
+	GC2155MIPI_write_cmos_sensor(0x2f , 0x81);
+	GC2155MIPI_write_cmos_sensor(0x30 , 0x91);
+	GC2155MIPI_write_cmos_sensor(0x31 , 0x9c);
+	GC2155MIPI_write_cmos_sensor(0x32 , 0xaa);
+	GC2155MIPI_write_cmos_sensor(0x33 , 0xbb);
+	GC2155MIPI_write_cmos_sensor(0x34 , 0xca);
+	GC2155MIPI_write_cmos_sensor(0x35 , 0xd5);
+	GC2155MIPI_write_cmos_sensor(0x36 , 0xe0);
+	GC2155MIPI_write_cmos_sensor(0x37 , 0xe7);
+	GC2155MIPI_write_cmos_sensor(0x38 , 0xed);
+	GC2155MIPI_write_cmos_sensor(0x39 , 0xf6);
+	GC2155MIPI_write_cmos_sensor(0x3a , 0xfb);
+	GC2155MIPI_write_cmos_sensor(0x3b , 0xff);
+	/////////////////////////////////////////////// 
+	///////////YCP /////////////////////// 
+	/////////////////////////////////////////////// 
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x02);
+	GC2155MIPI_write_cmos_sensor(0xd1 , 0x28);
+	GC2155MIPI_write_cmos_sensor(0xd2 , 0x28);
+	GC2155MIPI_write_cmos_sensor(0xdd , 0x14);
+	GC2155MIPI_write_cmos_sensor(0xde , 0x88);
+	GC2155MIPI_write_cmos_sensor(0xed , 0x80);
+	/////////////////////////////////////////////
+	//////////////////////// LSC ///////////////
+	//////////////////////////////////////////
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x01);
+	GC2155MIPI_write_cmos_sensor(0xc2 , 0x1f);
+	GC2155MIPI_write_cmos_sensor(0xc3 , 0x13);
+	GC2155MIPI_write_cmos_sensor(0xc4 , 0x0e);
+	GC2155MIPI_write_cmos_sensor(0xc8 , 0x16);
+	GC2155MIPI_write_cmos_sensor(0xc9 , 0x0f);
+	GC2155MIPI_write_cmos_sensor(0xca , 0x0c);
+	GC2155MIPI_write_cmos_sensor(0xbc , 0x52);
+	GC2155MIPI_write_cmos_sensor(0xbd , 0x2c);
+	GC2155MIPI_write_cmos_sensor(0xbe , 0x27);
+	GC2155MIPI_write_cmos_sensor(0xb6 , 0x47);
+	GC2155MIPI_write_cmos_sensor(0xb7 , 0x32);
+	GC2155MIPI_write_cmos_sensor(0xb8 , 0x30);
+	GC2155MIPI_write_cmos_sensor(0xc5 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xc6 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xc7 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xcb , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xcc , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xcd , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xbf , 0x0e);
+	GC2155MIPI_write_cmos_sensor(0xc0 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xc1 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xb9 , 0x08);
+	GC2155MIPI_write_cmos_sensor(0xba , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xbb , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xaa , 0x0a);
+	GC2155MIPI_write_cmos_sensor(0xab , 0x0c);
+	GC2155MIPI_write_cmos_sensor(0xac , 0x0d);
+	GC2155MIPI_write_cmos_sensor(0xad , 0x02);
+	GC2155MIPI_write_cmos_sensor(0xae , 0x06);
+	GC2155MIPI_write_cmos_sensor(0xaf , 0x05);
+	GC2155MIPI_write_cmos_sensor(0xb0 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xb1 , 0x05);
+	GC2155MIPI_write_cmos_sensor(0xb2 , 0x02);
+	GC2155MIPI_write_cmos_sensor(0xb3 , 0x04);
+	GC2155MIPI_write_cmos_sensor(0xb4 , 0x04);
+	GC2155MIPI_write_cmos_sensor(0xb5 , 0x05);
+	GC2155MIPI_write_cmos_sensor(0xd0 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xd1 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xd2 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xd6 , 0x02);
+	GC2155MIPI_write_cmos_sensor(0xd7 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xd8 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xd9 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xda , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xdb , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xd3 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xd4 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xd5 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xa4 , 0x04);
+	GC2155MIPI_write_cmos_sensor(0xa5 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xa6 , 0x77);
+	GC2155MIPI_write_cmos_sensor(0xa7 , 0x77);
+	GC2155MIPI_write_cmos_sensor(0xa8 , 0x77);
+	GC2155MIPI_write_cmos_sensor(0xa9 , 0x77);
+	GC2155MIPI_write_cmos_sensor(0xa1 , 0x80);
+	GC2155MIPI_write_cmos_sensor(0xa2 , 0x80);
+
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x01);
+	GC2155MIPI_write_cmos_sensor(0xdc , 0x35);
+	GC2155MIPI_write_cmos_sensor(0xdd , 0x28);
+	GC2155MIPI_write_cmos_sensor(0xdf , 0x0d);
+	GC2155MIPI_write_cmos_sensor(0xe0 , 0x70);
+	GC2155MIPI_write_cmos_sensor(0xe1 , 0x78);
+	GC2155MIPI_write_cmos_sensor(0xe2 , 0x70);
+	GC2155MIPI_write_cmos_sensor(0xe3 , 0x78);
+	GC2155MIPI_write_cmos_sensor(0xe6 , 0x90);
+	GC2155MIPI_write_cmos_sensor(0xe7 , 0x70);
+	GC2155MIPI_write_cmos_sensor(0xe8 , 0x90);
+	GC2155MIPI_write_cmos_sensor(0xe9 , 0x70);
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+	///////////////////////////////////////////////
+	/////////// AWB////////////////////////
+	///////////////////////////////////////////////
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4f , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x4f , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x4b , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4f , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x71);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x91);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x50);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x70);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x90);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xb0);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xd0);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x4f);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x6f);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x8f);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xaf);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xcf);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x6e);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x8e);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xae);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xce);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x4d);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x6d);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x8d);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xad);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xcd);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x4c);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x6c);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x8c);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xac);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xcc);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xec);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x4b);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x6b);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x8b);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xab);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x8a);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x04);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xaa);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x04);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xca);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x04);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xa9);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x04);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xc9);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x04);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xcb);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x05);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xeb);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x05);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x0b);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x05);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x2b);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x05);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x4b);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x05);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xea);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x05);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x0a);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x05);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x2a);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x05);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x6a);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x06);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x29);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x06);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x49);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x06);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x69);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x06);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x89);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x06);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xa9);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x06);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xc9);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x06);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x48);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x06);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x68);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x06);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x09);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x07);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xa8);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x07);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xc8);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x07);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xe8);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x07);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x08);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x07);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x28);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x07);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x87);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x07);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xa7);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x07);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xc7);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x07);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x02);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0xe7);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x07);
+	GC2155MIPI_write_cmos_sensor(0x4c , 0x03);
+	GC2155MIPI_write_cmos_sensor(0x4d , 0x07);
+	GC2155MIPI_write_cmos_sensor(0x4e , 0x07);
+	GC2155MIPI_write_cmos_sensor(0x4f , 0x01);
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x01);
+	
+	GC2155MIPI_write_cmos_sensor(0x50 , 0x80);
+	GC2155MIPI_write_cmos_sensor(0x51 , 0xa8);
+	GC2155MIPI_write_cmos_sensor(0x52 , 0x57);
+	GC2155MIPI_write_cmos_sensor(0x53 , 0x38);
+	GC2155MIPI_write_cmos_sensor(0x54 , 0xc7);
+	GC2155MIPI_write_cmos_sensor(0x56 , 0x0e);
+	GC2155MIPI_write_cmos_sensor(0x58 , 0x08);
+	GC2155MIPI_write_cmos_sensor(0x5b , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x5c , 0x74);
+	GC2155MIPI_write_cmos_sensor(0x5d , 0x8b);
+	GC2155MIPI_write_cmos_sensor(0x61 , 0xd3);
+	GC2155MIPI_write_cmos_sensor(0x62 , 0x90);
+	GC2155MIPI_write_cmos_sensor(0x63 , 0xaa);
+	GC2155MIPI_write_cmos_sensor(0x65 , 0x04);
+	GC2155MIPI_write_cmos_sensor(0x67 , 0xb2);
+	GC2155MIPI_write_cmos_sensor(0x68 , 0xac);
+	GC2155MIPI_write_cmos_sensor(0x69 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x6a , 0xb2);
+	GC2155MIPI_write_cmos_sensor(0x6b , 0xac);
+	GC2155MIPI_write_cmos_sensor(0x6c , 0xdc);
+	GC2155MIPI_write_cmos_sensor(0x6d , 0xb0);
+	GC2155MIPI_write_cmos_sensor(0x6e , 0x30);
+	GC2155MIPI_write_cmos_sensor(0x6f , 0x40);
+	GC2155MIPI_write_cmos_sensor(0x70 , 0x05);
+	GC2155MIPI_write_cmos_sensor(0x71 , 0x80);
+	GC2155MIPI_write_cmos_sensor(0x72 , 0x80);
+	GC2155MIPI_write_cmos_sensor(0x73 , 0x30);
+	GC2155MIPI_write_cmos_sensor(0x74 , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x75 , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x7f , 0x08);
+	GC2155MIPI_write_cmos_sensor(0x76 , 0x70);
+	GC2155MIPI_write_cmos_sensor(0x77 , 0x48);
+	GC2155MIPI_write_cmos_sensor(0x78 , 0xa0);
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+	//////////////////////////////////////////
+	///////////CC////////////////////////
+	//////////////////////////////////////////
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x02);
+	GC2155MIPI_write_cmos_sensor(0xc0 , 0x01);
+	GC2155MIPI_write_cmos_sensor(0xc1 , 0x4a);
+	GC2155MIPI_write_cmos_sensor(0xc2 , 0xf3);
+	GC2155MIPI_write_cmos_sensor(0xc3 , 0xfc);
+	GC2155MIPI_write_cmos_sensor(0xc4 , 0xe4);
+	GC2155MIPI_write_cmos_sensor(0xc5 , 0x48);
+	GC2155MIPI_write_cmos_sensor(0xc6 , 0xec);
+	GC2155MIPI_write_cmos_sensor(0xc7 , 0x45);
+	GC2155MIPI_write_cmos_sensor(0xc8 , 0xf8);
+	GC2155MIPI_write_cmos_sensor(0xc9 , 0x02);
+	GC2155MIPI_write_cmos_sensor(0xca , 0xfe);
+	GC2155MIPI_write_cmos_sensor(0xcb , 0x42);
+	GC2155MIPI_write_cmos_sensor(0xcc , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xcd , 0x45);
+	GC2155MIPI_write_cmos_sensor(0xce , 0xf0);
+	GC2155MIPI_write_cmos_sensor(0xcf , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xe3 , 0xf0);
+	GC2155MIPI_write_cmos_sensor(0xe4 , 0x45);
+	GC2155MIPI_write_cmos_sensor(0xe5 , 0xe8); 
+	//////////////////////////////////////////
+	///////////ABS ////////////////////
+	//////////////////////////////////////////
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x9f , 0x42);
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00); 
+	//////////////////////////////////////
+	///////////  OUTPUT   ////////////////
+	//////////////////////////////////////
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+	GC2155MIPI_write_cmos_sensor(0xf2, 0x00);
+
+	//////////////frame rate 50Hz/////////
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x05 , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x06 , 0x56);
+	GC2155MIPI_write_cmos_sensor(0x07 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x08 , 0x32);
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x25 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0x26 , 0xfa); 
+	GC2155MIPI_write_cmos_sensor(0x27 , 0x04); 
+	GC2155MIPI_write_cmos_sensor(0x28 , 0xe2); //20fps 
+	GC2155MIPI_write_cmos_sensor(0x29 , 0x06); 
+	GC2155MIPI_write_cmos_sensor(0x2a , 0xd6); //14fps 
+	GC2155MIPI_write_cmos_sensor(0x2b , 0x07); 
+	GC2155MIPI_write_cmos_sensor(0x2c , 0xd0); //12fps
+	GC2155MIPI_write_cmos_sensor(0x2d , 0x0b); 
+	GC2155MIPI_write_cmos_sensor(0x2e , 0xb8); //8fps
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+
+		/////////////////////////////////////////////////////
+	//////////////////////   MIPI   /////////////////////
+	/////////////////////////////////////////////////////
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x03);
+	GC2155MIPI_write_cmos_sensor(0x02, 0x22);
+	GC2155MIPI_write_cmos_sensor(0x03, 0x10); // 0x12 20140821
+	GC2155MIPI_write_cmos_sensor(0x04, 0x10); // 0x01 
+	GC2155MIPI_write_cmos_sensor(0x05, 0x00);
+	GC2155MIPI_write_cmos_sensor(0x06, 0x88);
+	#if defined(GC2155MIPI_2Lane)
+		GC2155MIPI_write_cmos_sensor(0x01, 0x87);
+		GC2155MIPI_write_cmos_sensor(0x10, 0x95);
+	#else
+		GC2155MIPI_write_cmos_sensor(0x01, 0x83);
+		GC2155MIPI_write_cmos_sensor(0x10, 0x94);
+	#endif
+	GC2155MIPI_write_cmos_sensor(0x11, 0x1e);
+	GC2155MIPI_write_cmos_sensor(0x12, 0x80);
+	GC2155MIPI_write_cmos_sensor(0x13, 0x0c);
+	GC2155MIPI_write_cmos_sensor(0x15, 0x10);
+	GC2155MIPI_write_cmos_sensor(0x17, 0xf0);
+	
+	GC2155MIPI_write_cmos_sensor(0x21, 0x10);
+	GC2155MIPI_write_cmos_sensor(0x22, 0x04);
+	GC2155MIPI_write_cmos_sensor(0x23, 0x10);
+	GC2155MIPI_write_cmos_sensor(0x24, 0x10);
+	GC2155MIPI_write_cmos_sensor(0x25, 0x10);
+	GC2155MIPI_write_cmos_sensor(0x26, 0x05);
+	GC2155MIPI_write_cmos_sensor(0x29, 0x03);
+	GC2155MIPI_write_cmos_sensor(0x2a, 0x0a);
+	GC2155MIPI_write_cmos_sensor(0x2b, 0x06);
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+	
+}
+
+
+static void GC2155MIPI_Sensor_SVGA(void)
+{
+	SENSORDB("GC2155MIPI_Sensor_SVGA");
+	GC2155MIPI_write_cmos_sensor(0xf7, 0x1d);
+	GC2155MIPI_write_cmos_sensor(0xfd, 0x01);
+	GC2155MIPI_write_cmos_sensor(0xfa, 0x00);
+	//// crop window             
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+	GC2155MIPI_write_cmos_sensor(0x90, 0x01);
+	GC2155MIPI_write_cmos_sensor(0x91, 0x00);
+	GC2155MIPI_write_cmos_sensor(0x92, 0x00);
+	GC2155MIPI_write_cmos_sensor(0x93, 0x00);
+	GC2155MIPI_write_cmos_sensor(0x94, 0x00);
+	GC2155MIPI_write_cmos_sensor(0x95, 0x02);
+	GC2155MIPI_write_cmos_sensor(0x96, 0x58);
+	GC2155MIPI_write_cmos_sensor(0x97, 0x03);
+	GC2155MIPI_write_cmos_sensor(0x98, 0x20);
+	GC2155MIPI_write_cmos_sensor(0x99, 0x11);
+	GC2155MIPI_write_cmos_sensor(0x9a, 0x06);
+	//// AWB                     
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+	GC2155MIPI_write_cmos_sensor(0xec, 0x01);
+	GC2155MIPI_write_cmos_sensor(0xed, 0x02);
+	GC2155MIPI_write_cmos_sensor(0xee, 0x30);
+	GC2155MIPI_write_cmos_sensor(0xef, 0x48);
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x01);
+	GC2155MIPI_write_cmos_sensor(0x74, 0x00);
+	//// AEC                     
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x01);
+	GC2155MIPI_write_cmos_sensor(0x01, 0x04);
+	GC2155MIPI_write_cmos_sensor(0x02, 0x60);
+	GC2155MIPI_write_cmos_sensor(0x03, 0x02);
+	GC2155MIPI_write_cmos_sensor(0x04, 0x48);
+	GC2155MIPI_write_cmos_sensor(0x05, 0x18);
+	GC2155MIPI_write_cmos_sensor(0x06, 0x4c);
+	GC2155MIPI_write_cmos_sensor(0x07, 0x14);
+	GC2155MIPI_write_cmos_sensor(0x08, 0x36);
+	GC2155MIPI_write_cmos_sensor(0x0a, 0xc0);
+	GC2155MIPI_write_cmos_sensor(0x21, 0x14);
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+	//// gamma
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xc3 , 0x11);
+	GC2155MIPI_write_cmos_sensor(0xc4 , 0x20);
+	GC2155MIPI_write_cmos_sensor(0xc5 , 0x30);
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+	//// mipi
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x03);
+	GC2155MIPI_write_cmos_sensor(0x12, 0x40);
+	GC2155MIPI_write_cmos_sensor(0x13, 0x06);
+#if defined(GC2155MIPI_2Lane)
+	GC2155MIPI_write_cmos_sensor(0x04, 0x90);
+	GC2155MIPI_write_cmos_sensor(0x05, 0x01);
+#else
+	GC2155MIPI_write_cmos_sensor(0x04, 0x01);
+	GC2155MIPI_write_cmos_sensor(0x05, 0x00);
+#endif
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+}
+
+static void GC2155MIPI_Sensor_2M(void)
+{
+	SENSORDB("GC2155MIPI_Sensor_2M");
+	GC2155MIPI_write_cmos_sensor(0xf7, 0x1d);	
+	GC2155MIPI_write_cmos_sensor(0xfd, 0x00); 
+#ifdef GC2155MIPI_2Lane
+	GC2155MIPI_write_cmos_sensor(0xfa, 0x00); 
+#else
+	GC2155MIPI_write_cmos_sensor(0xfa, 0x11); 
+#endif
+	//// crop window           
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+	GC2155MIPI_write_cmos_sensor(0x90, 0x01); 
+	GC2155MIPI_write_cmos_sensor(0x91, 0x00);
+	GC2155MIPI_write_cmos_sensor(0x92, 0x00);
+	GC2155MIPI_write_cmos_sensor(0x93, 0x00);
+	GC2155MIPI_write_cmos_sensor(0x94, 0x00);
+	GC2155MIPI_write_cmos_sensor(0x95, 0x04);
+	GC2155MIPI_write_cmos_sensor(0x96, 0xb0);
+	GC2155MIPI_write_cmos_sensor(0x97, 0x06);
+	GC2155MIPI_write_cmos_sensor(0x98, 0x40);
+	GC2155MIPI_write_cmos_sensor(0x99, 0x11); 
+	GC2155MIPI_write_cmos_sensor(0x9a, 0x06);
+	//// AWB                   
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+	GC2155MIPI_write_cmos_sensor(0xec, 0x02); 
+	GC2155MIPI_write_cmos_sensor(0xed, 0x04);
+	GC2155MIPI_write_cmos_sensor(0xee, 0x60);
+	GC2155MIPI_write_cmos_sensor(0xef, 0x90);
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x01);
+	GC2155MIPI_write_cmos_sensor(0x74, 0x01); 
+	//// AEC                    
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x01);
+	GC2155MIPI_write_cmos_sensor(0x01, 0x08);
+	GC2155MIPI_write_cmos_sensor(0x02, 0xc0);
+	GC2155MIPI_write_cmos_sensor(0x03, 0x04);
+	GC2155MIPI_write_cmos_sensor(0x04, 0x90);
+	GC2155MIPI_write_cmos_sensor(0x05, 0x30);
+	GC2155MIPI_write_cmos_sensor(0x06, 0x98);
+	GC2155MIPI_write_cmos_sensor(0x07, 0x28);
+	GC2155MIPI_write_cmos_sensor(0x08, 0x6c);
+	GC2155MIPI_write_cmos_sensor(0x0a, 0xc2);
+#ifdef GC2155MIPI_2Lane
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x21 , 0x14);
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+	//// gamma
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xc3 , 0x11);
+	GC2155MIPI_write_cmos_sensor(0xc4 , 0x20);
+	GC2155MIPI_write_cmos_sensor(0xc5 , 0x30);
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+#else
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x01);
+	GC2155MIPI_write_cmos_sensor(0x21 , 0x15);
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+	//// gamma
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xc3 , 0x00);
+	GC2155MIPI_write_cmos_sensor(0xc4 , 0x90);
+	GC2155MIPI_write_cmos_sensor(0xc5 , 0x98);
+	GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+#endif
+	//// mipi
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x03);
+	GC2155MIPI_write_cmos_sensor(0x12, 0x80);
+	GC2155MIPI_write_cmos_sensor(0x13, 0x0c);
+	GC2155MIPI_write_cmos_sensor(0x04, 0x01);
+	GC2155MIPI_write_cmos_sensor(0x05, 0x00);
+	GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+
+}
+
+
+/*****************************************************************************/
+/* Windows Mobile Sensor Interface */
+/*****************************************************************************/
+/*************************************************************************
+* FUNCTION
+*	GC2155MIPIOpen
+*
+* DESCRIPTION
+*	This function initialize the registers of CMOS sensor
+*
+* PARAMETERS
+*	None
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+UINT32 GC2155MIPIOpen(void)
+{
+	volatile signed char i;
+	kal_uint16 sensor_id=0;
+
+	zoom_factor = 0; 
+	Sleep(10);
+
+
+	//  Read sensor ID to adjust I2C is OK?
+	for(i=0;i<3;i++)
+	{
+		sensor_id=((GC2155MIPI_read_cmos_sensor(0xf0) << 8) | GC2155MIPI_read_cmos_sensor(0xf1));   
+		SENSORDB("GC2155MIPI_Open, sensor_id:%x \n",sensor_id);
+		if (sensor_id != GC2155MIPI_SENSOR_ID)
+		return ERROR_SENSOR_CONNECT_FAIL;
+	}
+	
+		SENSORDB("GC2155MIPI Sensor Read ID OK \r\n");
+		GC2155MIPI_Sensor_Init();
+
+#ifdef DEBUG_SENSOR_GC2155MIPI  
+		struct file *fp; 
+		mm_segment_t fs; 
+		loff_t pos = 0; 
+		static char buf[60*1024] ;
+
+		printk("open 2155 debug \n");
+		printk("open 2155 debug \n");
+		printk("open 2155 debug \n");	
+
+
+		fp = filp_open("/mnt/sdcard/gc2155mipi_sd.txt", O_RDONLY , 0); 
+
+		if (IS_ERR(fp)) 
+		{ 
+
+			fromsd = 0;   
+			printk("open 2155 file error\n");
+			printk("open 2155 file error\n");
+			printk("open 2155 file error\n");		
+
+
+		} 
+		else 
+		{
+			fromsd = 1;
+			printk("open 2155 file ok\n");
+			printk("open 2155 file ok\n");
+			printk("open 2155 file ok\n");
+
+			//gc2155mipi_Initialize_from_T_Flash();
+			
+			filp_close(fp, NULL); 
+			set_fs(fs);
+		}
+
+		if(fromsd == 1)
+		{
+			printk("________________2155 from t!\n");
+			printk("________________2155 from t!\n");
+			printk("________________2155 from t!\n");		
+			GC2155MIPI_Initialize_from_T_Flash();
+			printk("______after_____2155 from t!\n");	
+		}
+		else
+		{
+			//GC2155MIPI_MPEG4_encode_mode = KAL_FALSE;
+			printk("________________2155 not from t!\n");	
+			printk("________________2155 not from t!\n");
+			printk("________________2155 not from t!\n");		
+			RETAILMSG(1, (TEXT("Sensor Read ID OK \r\n"))); 
+		}
+
+#endif
+	
+	Preview_Shutter =GC2155MIPI_read_shutter();
+	
+	return ERROR_NONE;
+}	/* GC2155MIPIOpen() */
+
+/*************************************************************************
+* FUNCTION
+*	GC2155MIPIClose
+*
+* DESCRIPTION
+*	This function is to turn off sensor module power.
+*
+* PARAMETERS
+*	None
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+UINT32 GC2155MIPIClose(void)
+{
+//	CISModulePowerOn(FALSE);
+	return ERROR_NONE;
+}	/* GC2155MIPIClose() */
+
+/*************************************************************************
+* FUNCTION
+*	GC2155MIPIPreview
+*
+* DESCRIPTION
+*	This function start the sensor preview.
+*
+* PARAMETERS
+*	*image_window : address pointer of pixel numbers in one period of HSYNC
+*  *sensor_config_data : address pointer of line numbers in one period of VSYNC
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+UINT32 GC2155MIPIPreview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	kal_uint8 iTemp, temp_AE_reg, temp_AWB_reg;
+	kal_uint16 iDummyPixels = 0, iDummyLines = 0, iStartX = 0, iStartY = 0;
+
+	SENSORDB("GC2155MIPIPrevie\n");
+
+	GC2155MIPI_sensor_cap_state = KAL_FALSE;
+
+
+	GC2155MIPI_Sensor_SVGA();
+	GC2155MIPI_write_shutter(Preview_Shutter);
+	GC2155MIPI_set_AE_mode(KAL_TRUE); 
+
+	memcpy(&GC2155MIPISensorConfigData, sensor_config_data, sizeof(MSDK_SENSOR_CONFIG_STRUCT));
+	return ERROR_NONE;
+}	/* GC2155MIPIPreview() */
+
+
+
+
+UINT32 GC2155MIPICapture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    volatile kal_uint32 shutter = GC2155MIPI_exposure_lines, temp_reg;
+    kal_uint8 temp_AE_reg, temp;
+    kal_uint16 AE_setting_delay = 0;
+
+    SENSORDB("GC2155MIPICapture\n");
+
+  if(GC2155MIPI_sensor_cap_state == KAL_FALSE)
+ 	{
+
+#if defined(GC2155MIPI_2Lane)
+
+	GC2155MIPI_Sensor_2M();
+
+#else
+	// turn off AEC/AGC
+	GC2155MIPI_set_AE_mode(KAL_FALSE);
+	
+	shutter = GC2155MIPI_read_shutter();
+	Preview_Shutter = shutter;
+	
+	GC2155MIPI_Sensor_2M();
+	
+	Capture_Shutter = shutter / 2; 
+	// set shutter
+	GC2155MIPI_write_shutter(Capture_Shutter);
+#endif
+
+	Sleep(200);
+
+      }
+
+     GC2155MIPI_sensor_cap_state = KAL_TRUE;
+
+	image_window->GrabStartX=1;
+        image_window->GrabStartY=1;
+        image_window->ExposureWindowWidth=GC2155MIPI_IMAGE_SENSOR_FULL_WIDTH - image_window->GrabStartX;
+        image_window->ExposureWindowHeight=GC2155MIPI_IMAGE_SENSOR_FULL_HEIGHT -image_window->GrabStartY;    	 
+
+    memcpy(&GC2155MIPISensorConfigData, sensor_config_data, sizeof(MSDK_SENSOR_CONFIG_STRUCT));
+	return ERROR_NONE;
+}	/* GC2155MIPICapture() */
+
+
+
+UINT32 GC2155MIPIGetResolution(MSDK_SENSOR_RESOLUTION_INFO_STRUCT *pSensorResolution)
+{
+	pSensorResolution->SensorFullWidth=GC2155MIPI_IMAGE_SENSOR_FULL_WIDTH - 2 * IMAGE_SENSOR_START_GRAB_X;
+	pSensorResolution->SensorFullHeight=GC2155MIPI_IMAGE_SENSOR_FULL_HEIGHT - 2 * IMAGE_SENSOR_START_GRAB_Y;
+	pSensorResolution->SensorPreviewWidth=GC2155MIPI_IMAGE_SENSOR_PV_WIDTH - 2 * IMAGE_SENSOR_START_GRAB_X;
+	pSensorResolution->SensorPreviewHeight=GC2155MIPI_IMAGE_SENSOR_PV_HEIGHT - 2 * IMAGE_SENSOR_START_GRAB_Y;
+	pSensorResolution->SensorVideoWidth=GC2155MIPI_IMAGE_SENSOR_PV_WIDTH - 2 * IMAGE_SENSOR_START_GRAB_X;
+	pSensorResolution->SensorVideoHeight=GC2155MIPI_IMAGE_SENSOR_PV_HEIGHT - 2 * IMAGE_SENSOR_START_GRAB_Y;
+	return ERROR_NONE;
+}	/* GC2155MIPIGetResolution() */
+
+UINT32 GC2155MIPIGetInfo(MSDK_SCENARIO_ID_ENUM ScenarioId,
+					  MSDK_SENSOR_INFO_STRUCT *pSensorInfo,
+					  MSDK_SENSOR_CONFIG_STRUCT *pSensorConfigData)
+{
+
+	pSensorInfo->SensorPreviewResolutionX=GC2155MIPI_IMAGE_SENSOR_PV_WIDTH;
+	pSensorInfo->SensorPreviewResolutionY=GC2155MIPI_IMAGE_SENSOR_PV_HEIGHT;
+	pSensorInfo->SensorFullResolutionX=GC2155MIPI_IMAGE_SENSOR_FULL_WIDTH;
+	pSensorInfo->SensorFullResolutionY=GC2155MIPI_IMAGE_SENSOR_FULL_HEIGHT;
+
+	pSensorInfo->SensorCameraPreviewFrameRate=30;
+	pSensorInfo->SensorVideoFrameRate=30;
+	pSensorInfo->SensorStillCaptureFrameRate=10;
+	pSensorInfo->SensorWebCamCaptureFrameRate=15;
+	pSensorInfo->SensorResetActiveHigh=FALSE;
+	pSensorInfo->SensorResetDelayCount=1;
+	pSensorInfo->SensorOutputDataFormat=SENSOR_OUTPUT_FORMAT_YUYV;
+	pSensorInfo->SensorClockPolarity=SENSOR_CLOCK_POLARITY_LOW;	/*??? */
+	pSensorInfo->SensorClockFallingPolarity=SENSOR_CLOCK_POLARITY_LOW;
+	pSensorInfo->SensorHsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
+	pSensorInfo->SensorVsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
+	pSensorInfo->SensorInterruptDelayLines = 1;
+	pSensorInfo->CaptureDelayFrame = 4; 
+	pSensorInfo->PreviewDelayFrame = 1; 
+	pSensorInfo->VideoDelayFrame = 0; 
+       pSensorInfo->YUVAwbDelayFrame = 2;  // add by lanking
+	pSensorInfo->YUVEffectDelayFrame = 2;  // add by lanking
+	pSensorInfo->SensorMasterClockSwitch = 0; 
+	pSensorInfo->SensorDrivingCurrent = ISP_DRIVING_6MA;
+
+
+	pSensorInfo->SensroInterfaceType = SENSOR_INTERFACE_TYPE_MIPI;
+
+	switch (ScenarioId)
+	{
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+		case MSDK_SCENARIO_ID_CAMERA_ZSD:
+		default:
+
+			pSensorInfo->SensorClockFreq=24;
+			pSensorInfo->SensorClockDividCount=3;
+			pSensorInfo->SensorClockRisingCount= 0;
+			pSensorInfo->SensorClockFallingCount= 2;
+			pSensorInfo->SensorPixelClockCount= 3;
+			pSensorInfo->SensorDataLatchCount= 2;
+                     pSensorInfo->SensorGrabStartX = 2; 
+                     pSensorInfo->SensorGrabStartY = 2;
+		#ifdef GC2155MIPI_2Lane
+			pSensorInfo->SensorMIPILaneNumber = SENSOR_MIPI_2_LANE;		
+		#else
+			pSensorInfo->SensorMIPILaneNumber = SENSOR_MIPI_1_LANE;
+		#endif
+			pSensorInfo->MIPIDataLowPwr2HighSpeedTermDelayCount = 0; 
+			pSensorInfo->MIPIDataLowPwr2HighSpeedSettleDelayCount = 14;
+			pSensorInfo->MIPICLKLowPwr2HighSpeedTermDelayCount = 0;
+			pSensorInfo->SensorWidthSampling = 0;  // 0 is default 1x
+			pSensorInfo->SensorHightSampling = 0;   // 0 is default 1x 
+			pSensorInfo->SensorPacketECCOrder = 1;
+
+	
+		break;
+	
+	}
+	memcpy(pSensorConfigData, &GC2155MIPISensorConfigData, sizeof(MSDK_SENSOR_CONFIG_STRUCT));
+	return ERROR_NONE;
+}	/* GC2155MIPIGetInfo() */
+
+
+UINT32 GC2155MIPIControl(MSDK_SCENARIO_ID_ENUM ScenarioId, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *pImageWindow,
+					  MSDK_SENSOR_CONFIG_STRUCT *pSensorConfigData)
+{
+	switch (ScenarioId)
+	{
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+			GC2155MIPIPreview(pImageWindow, pSensorConfigData);
+		break;
+		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+		case MSDK_SCENARIO_ID_CAMERA_ZSD:
+			GC2155MIPICapture(pImageWindow, pSensorConfigData);
+		break;
+		default:
+		    break; 
+	}
+	return TRUE;
+}	/* GC2155MIPIControl() */
+
+BOOL GC2155MIPI_set_param_wb(UINT16 para)
+{
+	switch (para)
+	{
+		case AWB_MODE_AUTO:
+			GC2155MIPI_set_AWB_mode(KAL_TRUE);
+		break;
+		case AWB_MODE_CLOUDY_DAYLIGHT: //cloudy
+			GC2155MIPI_set_AWB_mode(KAL_FALSE);
+			GC2155MIPI_write_cmos_sensor(0xb3, 0x58);
+			GC2155MIPI_write_cmos_sensor(0xb4, 0x40);
+			GC2155MIPI_write_cmos_sensor(0xb5, 0x50);
+		break;
+		case AWB_MODE_DAYLIGHT: //sunny
+			GC2155MIPI_set_AWB_mode(KAL_FALSE);
+			GC2155MIPI_write_cmos_sensor(0xb3, 0x70);
+			GC2155MIPI_write_cmos_sensor(0xb4, 0x40);
+			GC2155MIPI_write_cmos_sensor(0xb5, 0x50);
+		break;
+		case AWB_MODE_INCANDESCENT: //office
+			GC2155MIPI_set_AWB_mode(KAL_FALSE);
+			GC2155MIPI_write_cmos_sensor(0xb3, 0x50);
+			GC2155MIPI_write_cmos_sensor(0xb4, 0x40);
+			GC2155MIPI_write_cmos_sensor(0xb5, 0xa8);
+		break;
+		case AWB_MODE_TUNGSTEN: //home
+			GC2155MIPI_set_AWB_mode(KAL_FALSE);
+			GC2155MIPI_write_cmos_sensor(0xb3, 0xa0);
+			GC2155MIPI_write_cmos_sensor(0xb4, 0x45);
+			GC2155MIPI_write_cmos_sensor(0xb5, 0x40);
+		break;
+		case AWB_MODE_FLUORESCENT:
+			GC2155MIPI_set_AWB_mode(KAL_FALSE);
+			GC2155MIPI_write_cmos_sensor(0xb3, 0x72);
+			GC2155MIPI_write_cmos_sensor(0xb4, 0x40);
+			GC2155MIPI_write_cmos_sensor(0xb5, 0x5b);
+		break;	
+		default:
+		return FALSE;
+	}
+	return TRUE;
+} /* GC2155MIPI_set_param_wb */
+
+BOOL GC2155MIPI_set_param_effect(UINT16 para)
+{
+	kal_uint32 ret = KAL_TRUE;
+	switch (para)
+	{
+		case MEFFECT_OFF:
+			GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+			GC2155MIPI_write_cmos_sensor(0x83, 0xe0);
+		break;
+
+		case MEFFECT_SEPIA:
+			GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+			GC2155MIPI_write_cmos_sensor(0x83, 0x82);
+		break;  
+
+		case MEFFECT_NEGATIVE:		
+			GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+			GC2155MIPI_write_cmos_sensor(0x83, 0x01);
+		break; 
+
+		case MEFFECT_SEPIAGREEN:		
+			GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+			GC2155MIPI_write_cmos_sensor(0x83, 0x52);
+		break;
+
+		case MEFFECT_SEPIABLUE:	
+			GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+			GC2155MIPI_write_cmos_sensor(0x83, 0x62);
+		break;
+
+		case MEFFECT_MONO:				
+			GC2155MIPI_write_cmos_sensor(0xfe, 0x00);
+			GC2155MIPI_write_cmos_sensor(0x83, 0x12);
+		break;
+
+		default:
+		return FALSE;
+	}
+
+	return ret;
+} /* GC2155MIPI_set_param_effect */
+
+BOOL GC2155MIPI_set_param_banding(UINT16 para)
+{
+    switch (para)
+    {
+        case AE_FLICKER_MODE_50HZ:
+			
+		GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+		GC2155MIPI_write_cmos_sensor(0x05 , 0x01);
+		GC2155MIPI_write_cmos_sensor(0x06 , 0x56);
+		GC2155MIPI_write_cmos_sensor(0x07 , 0x00);
+		GC2155MIPI_write_cmos_sensor(0x08 , 0x32);
+		GC2155MIPI_write_cmos_sensor(0xfe , 0x01);
+		GC2155MIPI_write_cmos_sensor(0x25 , 0x00);
+		GC2155MIPI_write_cmos_sensor(0x26 , 0xfa); 
+		GC2155MIPI_write_cmos_sensor(0x27 , 0x04); 
+		GC2155MIPI_write_cmos_sensor(0x28 , 0xe2); //20fps 
+		GC2155MIPI_write_cmos_sensor(0x29 , 0x06); 
+		GC2155MIPI_write_cmos_sensor(0x2a , 0xd6); //14fps 
+		GC2155MIPI_write_cmos_sensor(0x2b , 0x07); 
+		GC2155MIPI_write_cmos_sensor(0x2c , 0xd0); //12fps 
+		GC2155MIPI_write_cmos_sensor(0x2d , 0x0b); 
+		GC2155MIPI_write_cmos_sensor(0x2e , 0xb8); //8fps
+		GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+            break;
+
+        case AE_FLICKER_MODE_60HZ:
+		GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+		GC2155MIPI_write_cmos_sensor(0x05 , 0x01);
+		GC2155MIPI_write_cmos_sensor(0x06 , 0x58);
+		GC2155MIPI_write_cmos_sensor(0x07 , 0x00);
+		GC2155MIPI_write_cmos_sensor(0x08 , 0x32);
+		GC2155MIPI_write_cmos_sensor(0xfe , 0x01);
+		GC2155MIPI_write_cmos_sensor(0x25 , 0x00);
+		GC2155MIPI_write_cmos_sensor(0x26 , 0xd0); 
+		GC2155MIPI_write_cmos_sensor(0x27 , 0x04); 
+		GC2155MIPI_write_cmos_sensor(0x28 , 0xe0); //20fps 
+		GC2155MIPI_write_cmos_sensor(0x29 , 0x06); 
+		GC2155MIPI_write_cmos_sensor(0x2a , 0x80); //14fps 
+		GC2155MIPI_write_cmos_sensor(0x2b , 0x08); 
+		GC2155MIPI_write_cmos_sensor(0x2c , 0x20); //12fps 
+		GC2155MIPI_write_cmos_sensor(0x2d , 0x0b); 
+		GC2155MIPI_write_cmos_sensor(0x2e , 0x60); //8fps
+		GC2155MIPI_write_cmos_sensor(0xfe , 0x00);
+            break;
+
+          default:
+              return FALSE;
+    }
+
+    return TRUE;
+} /* GC2155MIPI_set_param_banding */
+
+BOOL GC2155MIPI_set_param_exposure(UINT16 para)
+{
+	switch (para)
+	{
+		case AE_EV_COMP_n13:
+			GC2155MIPI_SET_PAGE1;
+			GC2155MIPI_write_cmos_sensor(0x13,0x10);
+			GC2155MIPI_SET_PAGE0;
+		break;
+		case AE_EV_COMP_n10:
+			GC2155MIPI_SET_PAGE1;
+			GC2155MIPI_write_cmos_sensor(0x13,0x15);
+			GC2155MIPI_SET_PAGE0;
+		break;
+		case AE_EV_COMP_n07:
+			GC2155MIPI_SET_PAGE1;
+			GC2155MIPI_write_cmos_sensor(0x13,0x20);
+			GC2155MIPI_SET_PAGE0;
+		break;
+		case AE_EV_COMP_n03:
+			GC2155MIPI_SET_PAGE1;
+			GC2155MIPI_write_cmos_sensor(0x13,0x25);
+			GC2155MIPI_SET_PAGE0;
+		break;
+		case AE_EV_COMP_00:
+			GC2155MIPI_SET_PAGE1;
+			GC2155MIPI_write_cmos_sensor(0x13,0x2d);
+			GC2155MIPI_SET_PAGE0;
+		break;
+		case AE_EV_COMP_03:
+			GC2155MIPI_SET_PAGE1;
+			GC2155MIPI_write_cmos_sensor(0x13,0x35);
+			GC2155MIPI_SET_PAGE0;
+		break;
+		case AE_EV_COMP_07:
+			GC2155MIPI_SET_PAGE1;
+			GC2155MIPI_write_cmos_sensor(0x13,0x40);
+			GC2155MIPI_SET_PAGE0;
+		break;
+		case AE_EV_COMP_10:
+			GC2155MIPI_SET_PAGE1;
+			GC2155MIPI_write_cmos_sensor(0x13,0x45);
+			GC2155MIPI_SET_PAGE0;
+		break;
+		case AE_EV_COMP_13:
+			GC2155MIPI_SET_PAGE1;
+			GC2155MIPI_write_cmos_sensor(0x13,0x50);
+			GC2155MIPI_SET_PAGE0;
+		break;
+		default:
+		return FALSE;
+	}
+	return TRUE;
+} /* GC2155MIPI_set_param_exposure */
+
+UINT32 GC2155MIPIYUVSensorSetting(FEATURE_ID iCmd, UINT32 iPara)
+{
+//   if( GC2155MIPI_sensor_cap_state == KAL_TRUE)
+//	   return TRUE;
+
+
+#ifdef DEBUG_SENSOR_GC2155MIPI
+		printk("______%s______GC2155MIPI YUV setting\n",__func__);
+		return TRUE;
+#endif
+
+	switch (iCmd) {
+	case FID_SCENE_MODE:	    
+//	    printk("Set Scene Mode:%d\n", iPara); 
+	    if (iPara == SCENE_MODE_OFF)
+	    {
+	        GC2155MIPI_night_mode(0); 
+	    }
+	    else if (iPara == SCENE_MODE_NIGHTSCENE)
+	    {
+               GC2155MIPI_night_mode(1); 
+	    }	    
+	    break; 	    
+	case FID_AWB_MODE:
+	    printk("Set AWB Mode:%d\n", iPara); 	    
+           GC2155MIPI_set_param_wb(iPara);
+	break;
+	case FID_COLOR_EFFECT:
+	    printk("Set Color Effect:%d\n", iPara); 	    	    
+           GC2155MIPI_set_param_effect(iPara);
+	break;
+	case FID_AE_EV:
+           printk("Set EV:%d\n", iPara); 	    	    
+           GC2155MIPI_set_param_exposure(iPara);
+	break;
+	case FID_AE_FLICKER:
+          printk("Set Flicker:%d\n", iPara); 	    	    	    
+           GC2155MIPI_set_param_banding(iPara);
+	break;
+        case FID_AE_SCENE_MODE: 
+            if (iPara == AE_MODE_OFF) {
+                GC2155MIPI_set_AE_mode(KAL_FALSE);
+            }
+            else {
+                GC2155MIPI_set_AE_mode(KAL_TRUE);
+	    }
+            break; 
+	case FID_ZOOM_FACTOR:
+	    zoom_factor = iPara; 
+        break; 
+	default:
+	break;
+	}
+	return TRUE;
+}   /* GC2155MIPIYUVSensorSetting */
+
+UINT32 GC2155MIPIYUVSetVideoMode(UINT16 u2FrameRate)
+{
+    kal_uint8 iTemp;
+    /* to fix VSYNC, to fix frame rate */
+    //printk("Set YUV Video Mode \n");  
+
+    if (u2FrameRate == 30)
+    {
+    }
+    else if (u2FrameRate == 15)       
+    {
+    }
+    else 
+    {
+        printk("Wrong frame rate setting \n");
+    }
+    GC2155MIPI_VEDIO_encode_mode = KAL_TRUE; 
+        
+    return TRUE;
+}
+
+/*************************************************************************
+  * FUNCTION
+  * GC2155MIPISetMaxFramerateByScenario
+  *
+  * DESCRIPTION
+  * This function is for android4.4 kk
+  * RETURNS
+  * None
+  *
+  * add by lanking
+  *
+  *************************************************************************/
+
+  UINT32 GC2155MIPISetMaxFramerateByScenario(MSDK_SCENARIO_ID_ENUM scenarioId, MUINT32 frameRate) {
+	kal_uint32 pclk;
+	kal_int16 dummyLine;
+	kal_uint16 lineLength,frameHeight;
+		
+	SENSORDB("GC2145SetMaxFramerateByScenario: scenarioId = %d, frame rate = %d\n",scenarioId,frameRate);
+	/*
+	switch (scenarioId) {
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+			pclk = 134200000;
+			lineLength = IMX111MIPI_PV_LINE_LENGTH_PIXELS;
+			frameHeight = (10 * pclk)/frameRate/lineLength;
+			dummyLine = frameHeight - IMX111MIPI_PV_FRAME_LENGTH_LINES;
+			break;
+        case MSDK_SCENARIO_ID_CAMERA_3D_CAPTURE: //added   
+			break;		
+		default:
+			break;
+	}	
+	*/
+	return ERROR_NONE;
+}
+
+/*************************************************************************
+  * FUNCTION
+  * GC2155MIPIGetDefaultFramerateByScenario
+  *
+  * DESCRIPTION
+  * This function is for android4.4 kk
+  * RETURNS
+  * None
+  *
+  * GLOBALS AFFECTED
+  *
+  *************************************************************************/
+UINT32 GC2155MIPIGetDefaultFramerateByScenario(MSDK_SCENARIO_ID_ENUM scenarioId, MUINT32 *pframeRate) 
+{
+
+	switch (scenarioId)
+	 {
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+			 *pframeRate = 300;
+			 break;
+		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+		case MSDK_SCENARIO_ID_CAMERA_ZSD:
+			 *pframeRate = 220;
+			break;		//hhl 2-28
+        case MSDK_SCENARIO_ID_CAMERA_3D_PREVIEW: //added
+        case MSDK_SCENARIO_ID_CAMERA_3D_VIDEO:
+        case MSDK_SCENARIO_ID_CAMERA_3D_CAPTURE: //added   
+			 *pframeRate = 300;
+			break;		
+		default:
+			break;
+	}
+
+ }
+ 
+ /*************************************************************************
+  * FUNCTION
+  * GC2155MIPIFeatureControl
+  *
+  * DESCRIPTION
+  * 
+  * RETURNS
+  * None
+  *
+  * GLOBALS AFFECTED
+  *
+  *************************************************************************/
+
+UINT32 GC2155MIPIFeatureControl(MSDK_SENSOR_FEATURE_ENUM FeatureId,
+							 UINT8 *pFeaturePara,UINT32 *pFeatureParaLen)
+{
+	UINT16 *pFeatureReturnPara16=(UINT16 *) pFeaturePara;
+	UINT16 *pFeatureData16=(UINT16 *) pFeaturePara;
+	UINT32 *pFeatureReturnPara32=(UINT32 *) pFeaturePara;
+	UINT32 *pFeatureData32=(UINT32 *) pFeaturePara;
+    unsigned long long *feature_data=(unsigned long long *) pFeaturePara;
+    unsigned long long *feature_return_para=(unsigned long long *) pFeaturePara;
+	MSDK_SENSOR_CONFIG_STRUCT *pSensorConfigData=(MSDK_SENSOR_CONFIG_STRUCT *) pFeaturePara;
+	MSDK_SENSOR_REG_INFO_STRUCT *pSensorRegData=(MSDK_SENSOR_REG_INFO_STRUCT *) pFeaturePara;
+
+	switch (FeatureId)
+	{
+		case SENSOR_FEATURE_GET_RESOLUTION:
+			*pFeatureReturnPara16++=GC2155MIPI_IMAGE_SENSOR_FULL_WIDTH;
+			*pFeatureReturnPara16=GC2155MIPI_IMAGE_SENSOR_FULL_HEIGHT;
+			*pFeatureParaLen=4;
+		break;
+		case SENSOR_FEATURE_GET_PERIOD:
+			*pFeatureReturnPara16++=GC2155MIPI_IMAGE_SENSOR_PV_WIDTH;
+			*pFeatureReturnPara16=GC2155MIPI_IMAGE_SENSOR_PV_HEIGHT;
+			*pFeatureParaLen=4;
+		break;
+		case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:
+			//*pFeatureReturnPara32 = GC2155MIPI_sensor_pclk/10;
+			*pFeatureParaLen=4;
+		break;
+		case SENSOR_FEATURE_SET_ESHUTTER:
+		break;
+		case SENSOR_FEATURE_SET_NIGHTMODE:
+			GC2155MIPI_night_mode((BOOL) *feature_data);
+		break;
+		case SENSOR_FEATURE_SET_GAIN:
+		case SENSOR_FEATURE_SET_FLASHLIGHT:
+		break;
+		case SENSOR_FEATURE_SET_ISP_MASTER_CLOCK_FREQ:
+			GC2155MIPI_isp_master_clock=*pFeatureData32;
+		break;
+		case SENSOR_FEATURE_SET_REGISTER:
+			GC2155MIPI_write_cmos_sensor(pSensorRegData->RegAddr, pSensorRegData->RegData);
+		break;
+		case SENSOR_FEATURE_GET_REGISTER:
+			pSensorRegData->RegData = GC2155MIPI_read_cmos_sensor(pSensorRegData->RegAddr);
+		break;
+		case SENSOR_FEATURE_GET_CONFIG_PARA:
+			memcpy(pSensorConfigData, &GC2155MIPISensorConfigData, sizeof(MSDK_SENSOR_CONFIG_STRUCT));
+			*pFeatureParaLen=sizeof(MSDK_SENSOR_CONFIG_STRUCT);
+		break;
+		case SENSOR_FEATURE_SET_CCT_REGISTER:
+		case SENSOR_FEATURE_GET_CCT_REGISTER:
+		case SENSOR_FEATURE_SET_ENG_REGISTER:
+		case SENSOR_FEATURE_GET_ENG_REGISTER:
+		case SENSOR_FEATURE_GET_REGISTER_DEFAULT:
+
+		case SENSOR_FEATURE_CAMERA_PARA_TO_SENSOR:
+		case SENSOR_FEATURE_SENSOR_TO_CAMERA_PARA:
+		case SENSOR_FEATURE_GET_GROUP_INFO:
+		case SENSOR_FEATURE_GET_ITEM_INFO:
+		case SENSOR_FEATURE_SET_ITEM_INFO:
+		case SENSOR_FEATURE_GET_ENG_INFO:
+		break;
+		case SENSOR_FEATURE_GET_GROUP_COUNT:
+                        *pFeatureReturnPara32++=0;
+                        *pFeatureParaLen=4;	    
+		    break; 
+		case SENSOR_FEATURE_GET_LENS_DRIVER_ID:
+			// get the lens driver ID from EEPROM or just return LENS_DRIVER_ID_DO_NOT_CARE
+			// if EEPROM does not exist in camera module.
+			*pFeatureReturnPara32=LENS_DRIVER_ID_DO_NOT_CARE;
+			*pFeatureParaLen=4;
+		break;
+		case SENSOR_FEATURE_CHECK_SENSOR_ID:
+			 GC2155MIPI_GetSensorID(pFeatureData32);
+			 break;
+		case SENSOR_FEATURE_SET_YUV_CMD:
+		       //printk("GC2155MIPI YUV sensor Setting:%d, %d \n", *pFeatureData32,  *(pFeatureData32+1));
+			GC2155MIPIYUVSensorSetting((FEATURE_ID)*feature_data, *(feature_data+1));
+		break;
+		case SENSOR_FEATURE_SET_VIDEO_MODE:
+		       GC2155MIPIYUVSetVideoMode(*feature_data);
+		       break; 
+		default:
+			break;			
+	}
+	return ERROR_NONE;
+}	/* GC2155MIPIFeatureControl() */
+
+
+SENSOR_FUNCTION_STRUCT	SensorFuncGC2155MIPI=
+{
+	GC2155MIPIOpen,
+	GC2155MIPIGetInfo,
+	GC2155MIPIGetResolution,
+	GC2155MIPIFeatureControl,
+	GC2155MIPIControl,
+	GC2155MIPIClose
+};
+
+UINT32 GC2155MIPI_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
+{
+	/* To Do : Check Sensor status here */
+	if (pfFunc!=NULL)
+		*pfFunc=&SensorFuncGC2155MIPI;
+
+	return ERROR_NONE;
+}	/* SensorInit() */
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2155mipi_yuv/gc2155mipi_yuv_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2155mipi_yuv/gc2155mipi_yuv_Sensor.h
new file mode 100755
index 0000000..1f30cb6
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2155mipi_yuv/gc2155mipi_yuv_Sensor.h
@@ -0,0 +1,170 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*****************************************************************************
+*  Copyright Statement:
+*  --------------------
+*  This software is protected by Copyright and the information contained
+*  herein is confidential. The software may not be copied and the information
+*  contained herein may not be used or disclosed except with the written
+*  permission of MediaTek Inc. (C) 2008
+*
+*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
+*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
+*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
+*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
+*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
+*
+*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
+*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
+*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+*
+*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
+*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
+*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
+*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
+*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
+*
+*****************************************************************************/
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *   sensor.h
+ *
+ * Project:
+ * --------
+ *   DUMA
+ *
+ * Description:
+ * ------------
+ *   Header file of Sensor driver
+ *
+ *
+ * Author:
+ * -------
+ *   Leo Lee
+ *
+ *============================================================================
+ *             HISTORY
+ * Below this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *------------------------------------------------------------------------------
+ * $Revision:$
+ * $Modtime:$
+ * $Log:$
+ *
+ * [GC2155MIPIYUV V1.0.0]
+ * 8.17.2012 Leo.Lee
+ * .First Release
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by GalaxyCoreinc. DO NOT MODIFY!!
+ *============================================================================
+ ****************************************************************************/
+/* SENSOR FULL SIZE */
+#ifndef __SENSOR_H
+#define __SENSOR_H
+
+typedef enum _GC2155MIPI_OP_TYPE_ {
+        GC2155MIPI_MODE_NONE,
+        GC2155MIPI_MODE_PREVIEW,
+        GC2155MIPI_MODE_CAPTURE,
+        GC2155MIPI_MODE_QCIF_VIDEO,
+        GC2155MIPI_MODE_CIF_VIDEO,
+        GC2155MIPI_MODE_QVGA_VIDEO
+    } GC2155MIPI_OP_TYPE;
+
+extern GC2155MIPI_OP_TYPE GC2155MIPI_g_iGC2155MIPI_Mode;
+
+/* START GRAB PIXEL OFFSET */
+#define IMAGE_SENSOR_START_GRAB_X		        2	// 0 or 1 recommended
+#define IMAGE_SENSOR_START_GRAB_Y		        2	// 0 or 1 recommended
+
+/* SENSOR PIXEL/LINE NUMBERS IN ONE PERIOD */
+#define GC2155MIPI_FULL_PERIOD_PIXEL_NUMS  (1940)  // default pixel#(w/o dummy pixels) in UXGA mode
+#define GC2155MIPI_FULL_PERIOD_LINE_NUMS   (1238)  // default line#(w/o dummy lines) in UXGA mode
+#define GC2155MIPI_PV_PERIOD_PIXEL_NUMS    (970)  // default pixel#(w/o dummy pixels) in SVGA mode
+#define GC2155MIPI_PV_PERIOD_LINE_NUMS     (670)   // default line#(w/o dummy lines) in SVGA mode
+
+/* SENSOR EXPOSURE LINE LIMITATION */
+#define GC2155MIPI_FULL_EXPOSURE_LIMITATION    (1236)
+#define GC2155MIPI_PV_EXPOSURE_LIMITATION      (671)
+
+/* SENSOR FULL SIZE */
+#define GC2155MIPI_IMAGE_SENSOR_FULL_WIDTH	   (1600)
+#define GC2155MIPI_IMAGE_SENSOR_FULL_HEIGHT	  (1200)
+
+/* SENSOR PV SIZE */
+#define GC2155MIPI_IMAGE_SENSOR_PV_WIDTH   (800)
+#define GC2155MIPI_IMAGE_SENSOR_PV_HEIGHT  (600)
+
+#define GC2155MIPI_VIDEO_QCIF_WIDTH   (176)
+#define GC2155MIPI_VIDEO_QCIF_HEIGHT  (144)
+
+/* SENSOR READ/WRITE ID */
+#define GC2155MIPI_WRITE_ID	        0x78
+#define GC2155MIPI_READ_ID		0x79
+
+
+/* SENSOR CHIP VERSION */
+//#define GC2155MIPI_SENSOR_ID							0x2155
+
+//s_add for porting
+//s_add for porting
+//s_add for porting
+
+//export functions
+UINT32 GC2155MIPIOpen(void);
+UINT32 GC2155MIPIGetResolution(MSDK_SENSOR_RESOLUTION_INFO_STRUCT *pSensorResolution);
+UINT32 GC2155MIPIGetInfo(MSDK_SCENARIO_ID_ENUM ScenarioId, MSDK_SENSOR_INFO_STRUCT *pSensorInfo, MSDK_SENSOR_CONFIG_STRUCT *pSensorConfigData);
+UINT32 GC2155MIPIControl(MSDK_SCENARIO_ID_ENUM ScenarioId, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *pImageWindow, MSDK_SENSOR_CONFIG_STRUCT *pSensorConfigData);
+UINT32 GC2155MIPIFeatureControl(MSDK_SENSOR_FEATURE_ENUM FeatureId, UINT8 *pFeaturePara,UINT32 *pFeatureParaLen);
+UINT32 GC2155MIPIClose(void);
+
+
+//e_add for porting
+//e_add for porting
+//e_add for porting
+
+
+#endif /* __SENSOR_H */
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2235_mipi_raw/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2235_mipi_raw/Makefile
new file mode 100755
index 0000000..631ac5b
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2235_mipi_raw/Makefile
@@ -0,0 +1,4 @@
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+obj-y += gc2235mipi_Sensor.o
+
+
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2235_mipi_raw/gc2235mipi_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2235_mipi_raw/gc2235mipi_Sensor.c
new file mode 100755
index 0000000..70d950b
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2235_mipi_raw/gc2235mipi_Sensor.c
@@ -0,0 +1,1435 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *     GC2235mipi_Sensor.c
+ *
+ * Project:
+ * --------
+ *     ALPS
+ *
+ * Description:
+ * ------------
+ *     Source code of Sensor driver
+ *
+ *
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *============================================================================
+ ****************************************************************************/
+
+#include <linux/videodev2.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <asm/atomic.h>
+//#include <asm/system.h>
+#include <linux/xlog.h>
+
+#include "kd_camera_hw.h"
+#include "kd_imgsensor.h"
+#include "kd_imgsensor_define.h"
+#include "kd_imgsensor_errcode.h"
+
+#include "gc2235mipi_Sensor.h"
+
+/****************************Modify Following Strings for Debug****************************/
+#define PFX "GC2235_camera_sensor"
+#define LOG_1 LOG_INF("GC2235,MIPI 2LANE\n")
+#define LOG_2 LOG_INF("preview 1280*960@30fps,864Mbps/lane; video 1280*960@30fps,864Mbps/lane; capture 5M@30fps,864Mbps/lane\n")
+/****************************   Modify end    *******************************************/
+#define Sleep(ms) mdelay(ms)
+#define  GC2235MIPI_2Lane
+
+#define LOG_INF(format, args...)    xlog_printk(ANDROID_LOG_INFO   , PFX, "[%s] " format, __FUNCTION__, ##args)
+
+static DEFINE_SPINLOCK(imgsensor_drv_lock);
+
+
+static imgsensor_info_struct imgsensor_info = {
+    .sensor_id = GC2235MIPI_SENSOR_ID,        //record sensor id defined in Kd_imgsensor.h
+
+    .checksum_value = 0x9d1c9dad,        //checksum value for Camera Auto Test
+
+    .pre = {
+    #ifdef GC2235MIPI_2Lane
+        .pclk = 30000000,                //record different mode's pclk
+        .linelength = 1107,                //record different mode's linelength
+        .framelength = 1387,            //record different mode's framelength
+    #else
+	  .pclk = 21000000,                //record different mode's pclk
+        .linelength = 1050,                //record different mode's linelength
+        .framelength = 1258,            //record different mode's framelength
+   #endif
+        .startx = 0,                    //record different mode's startx of grabwindow
+        .starty = 0,                    //record different mode's starty of grabwindow
+        .grabwindow_width = 1600,        //record different mode's width of grabwindow
+        .grabwindow_height = 1200,        //record different mode's height of grabwindow
+        /*     following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario    */
+        .mipi_data_lp2hs_settle_dc = 14,//unit , ns
+        /*     following for GetDefaultFramerateByScenario()    */
+        .max_framerate = 300,
+    },
+    .cap = {
+     #ifdef GC2235MIPI_2Lane
+        .pclk = 30000000,                //record different mode's pclk
+        .linelength = 1107,                //record different mode's linelength
+        .framelength = 1387,            //record different mode's framelength
+    #else
+	  .pclk = 21000000,                //record different mode's pclk
+        .linelength = 1050,                //record different mode's linelength
+        .framelength = 1258,            //record different mode's framelength
+    #endif
+        .startx = 0,
+        .starty = 0,
+        .grabwindow_width = 1600,
+        .grabwindow_height = 1200,
+        .mipi_data_lp2hs_settle_dc = 14,//unit , ns
+        .max_framerate = 300,
+    },
+    .cap1 = {
+    #ifdef GC2235MIPI_2Lane
+        .pclk = 30000000,                //record different mode's pclk
+        .linelength = 1107,                //record different mode's linelength
+        .framelength = 1387,            //record different mode's framelength
+    #else
+	  .pclk = 21000000,                //record different mode's pclk
+        .linelength = 1050,                //record different mode's linelength
+        .framelength = 1258,            //record different mode's framelength
+    #endif
+        .startx = 0,
+        .starty = 0,
+        .grabwindow_width = 1600,
+        .grabwindow_height = 1200,
+        .mipi_data_lp2hs_settle_dc = 14,//unit , ns
+        .max_framerate = 300,
+    },
+    .normal_video = {
+     #ifdef GC2235MIPI_2Lane
+        .pclk = 30000000,                //record different mode's pclk
+        .linelength = 1107,                //record different mode's linelength
+        .framelength = 1387,            //record different mode's framelength
+    #else
+	  .pclk = 21000000,                //record different mode's pclk
+        .linelength = 1050,                //record different mode's linelength
+        .framelength = 1258,            //record different mode's framelength
+    #endif
+        .startx = 0,
+        .starty = 0,
+        .grabwindow_width = 1600,
+        .grabwindow_height = 1200,
+        .mipi_data_lp2hs_settle_dc = 14,//unit , ns
+        .max_framerate = 300,
+    },
+    .hs_video = {
+     #ifdef GC2235MIPI_2Lane
+        .pclk = 30000000,                //record different mode's pclk
+        .linelength = 1107,                //record different mode's linelength
+        .framelength = 1387,            //record different mode's framelength
+    #else
+	  .pclk = 21000000,                //record different mode's pclk
+        .linelength = 1050,                //record different mode's linelength
+        .framelength = 1258,            //record different mode's framelength
+    #endif
+        .startx = 0,
+        .starty = 0,
+        .grabwindow_width = 1600,
+        .grabwindow_height = 1200,
+        .mipi_data_lp2hs_settle_dc = 14,//unit , ns
+        .max_framerate = 300,
+    },
+    .slim_video = {
+     #ifdef GC2235MIPI_2Lane
+        .pclk = 30000000,                //record different mode's pclk
+        .linelength = 1107,                //record different mode's linelength
+        .framelength = 1387,            //record different mode's framelength
+    #else
+	  .pclk = 21000000,                //record different mode's pclk
+        .linelength = 1050,                //record different mode's linelength
+        .framelength = 1258,            //record different mode's framelength
+    #endif
+        .startx = 0,
+        .starty = 0,
+        .grabwindow_width = 1600,
+        .grabwindow_height = 1200,
+        .mipi_data_lp2hs_settle_dc = 14,//unit , ns
+        .max_framerate = 300,
+    },
+    .margin = 0,            //sensor framelength & shutter margin
+    .min_shutter = 1,        //min shutter
+    .max_frame_length = 0x7fff,//max framelength by sensor register's limitation
+    .ae_shut_delay_frame = 0,    //shutter delay frame for AE cycle, 2 frame with ispGain_delay-shut_delay=2-0=2
+    .ae_sensor_gain_delay_frame = 1,//sensor gain delay frame for AE cycle,2 frame with ispGain_delay-sensor_gain_delay=2-0=2
+    .ae_ispGain_delay_frame = 3,//isp gain delay frame for AE cycle
+    .ihdr_support = 0,      //1, support; 0,not support
+    .ihdr_le_firstline = 0,  //1,le first ; 0, se first
+    .sensor_mode_num = 5,      //support sensor mode num
+
+    .cap_delay_frame = 3,        //enter capture delay frame num
+    .pre_delay_frame = 3,         //enter preview delay frame num
+    .video_delay_frame = 3,        //enter video delay frame num
+    .hs_video_delay_frame = 3,    //enter high speed video  delay frame num
+    .slim_video_delay_frame = 3,//enter slim video delay frame num
+
+    .isp_driving_current = ISP_DRIVING_6MA, //mclk driving current
+    .sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,//sensor_interface_type
+    .mipi_sensor_type = MIPI_OPHY_NCSI2, //0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2
+    .mipi_settle_delay_mode = MIPI_SETTLEDELAY_AUTO,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
+    .sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_B,//sensor output first pixel color
+    .mclk = 24,//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
+  #ifdef GC2235MIPI_2Lane
+    .mipi_lane_num = SENSOR_MIPI_2_LANE,//mipi lane num
+  #else
+      .mipi_lane_num = SENSOR_MIPI_1_LANE,//mipi lane num
+ #endif
+    .i2c_addr_table = {0x78, 0xff},//record sensor support all write id addr, only supprt 4must end with 0xff
+};
+
+
+static imgsensor_struct imgsensor = {
+    .mirror = IMAGE_NORMAL,                //mirrorflip information
+    .sensor_mode = IMGSENSOR_MODE_INIT, //IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
+    .shutter = 0x3D0,                    //current shutter
+    .gain = 0x100,                        //current gain
+    .dummy_pixel = 0,                    //current dummypixel
+    .dummy_line = 0,                    //current dummyline
+    .current_fps = 300,  //full size current fps : 24fps for PIP, 30fps for Normal or ZSD
+    .autoflicker_en = KAL_FALSE,  //auto flicker enable: KAL_FALSE for disable auto flicker, KAL_TRUE for enable auto flicker
+    .test_pattern = KAL_FALSE,        //test pattern mode or not. KAL_FALSE for in test pattern mode, KAL_TRUE for normal output
+    .current_scenario_id = MSDK_SCENARIO_ID_CAMERA_PREVIEW,//current scenario id
+    .ihdr_en = 0, //sensor need support LE, SE with HDR feature
+    .i2c_write_id = 0x78,//record current sensor's i2c write id
+};
+
+
+/* Sensor output window information */
+static SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[5] =
+{
+	{ 1600, 1200,	 0,    0, 1600, 1200, 1600,  1200, 0000, 0000, 1600,  1200, 	 0,    0, 1600,  1200}, // Preview 
+	{ 1600, 1200,	 0,    0, 1600, 1200, 1600,  1200, 0000, 0000, 1600,  1200, 	 0,    0, 1600,  1200}, // capture 
+	{ 1600, 1200,	 0,    0, 1600, 1200, 1600,  1200, 0000, 0000, 1600,  1200, 	 0,    0, 1600,  1200}, // video 
+	{ 1600, 1200,	 0,    0, 1600, 1200, 1600,  1200, 0000, 0000, 1600,  1200, 	 0,    0, 1600,  1200}, //hight speed video 
+	{ 1600, 1200,	 0,    0, 1600, 1200, 1600,  1200, 0000, 0000, 1600,  1200, 	 0,    0, 1600,  1200}};// slim video 
+
+
+
+static kal_uint16 read_cmos_sensor(kal_uint32 addr)
+{
+	kal_uint16 get_byte=0;
+
+	char pu_send_cmd[1] = {(char)(addr & 0xFF) };
+	iReadRegI2C(pu_send_cmd, 1, (u8*)&get_byte, 1, imgsensor.i2c_write_id);
+
+	return get_byte;
+
+}
+
+static void write_cmos_sensor(kal_uint32 addr, kal_uint32 para)
+{
+#if 1
+		char pu_send_cmd[2] = {(char)(addr & 0xFF), (char)(para & 0xFF)};
+		iWriteRegI2C(pu_send_cmd, 2, imgsensor.i2c_write_id);
+#else
+		iWriteReg((u16)addr, (u32)para, 2, imgsensor.i2c_write_id);
+#endif
+
+}
+
+static void set_dummy()
+{
+ 	kal_uint32 hb = 0;
+	kal_uint32 vb = 0;	
+	LOG_INF("dummyline = %d, dummypixels = %d \n", imgsensor.dummy_line, imgsensor.dummy_pixel);
+
+//  modify by yfx
+#if 0
+	hb = imgsensor.dummy_pixel + GC2235_DEFAULT_DUMMY_PIXEL_NUMS;
+	vb = imgsensor.dummy_line + GC2235_DEFAULT_DUMMY_LINE_NUMS;
+
+	
+	//Set HB
+	write_cmos_sensor(0x05, (hb >> 8)& 0xFF);
+	write_cmos_sensor(0x06, hb & 0xFF);
+
+	//Set VB
+	write_cmos_sensor(0x07, (vb >> 8) & 0xFF);
+	write_cmos_sensor(0x08, vb & 0xFF);
+	mdelay(50);
+#endif
+//  end	
+}    /*    set_dummy  */
+
+static kal_uint32 return_sensor_id()
+{
+    return ((read_cmos_sensor(0xf0) << 8) | read_cmos_sensor(0xf1));
+}
+static void set_max_framerate(UINT16 framerate,kal_bool min_framelength_en)
+{
+    kal_int16 dummy_line;
+    kal_uint32 frame_length = imgsensor.frame_length;
+    //unsigned long flags;
+
+    LOG_INF("framerate = %d, min framelength should enable? \n", framerate,min_framelength_en);
+
+    frame_length = imgsensor.pclk / framerate * 10 / imgsensor.line_length;
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.frame_length = (frame_length > imgsensor.min_frame_length) ? frame_length : imgsensor.min_frame_length;
+    imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
+    //dummy_line = frame_length - imgsensor.min_frame_length;
+    //if (dummy_line < 0)
+        //imgsensor.dummy_line = 0;
+    //else
+        //imgsensor.dummy_line = dummy_line;
+    //imgsensor.frame_length = frame_length + imgsensor.dummy_line;
+    if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+    {
+        imgsensor.frame_length = imgsensor_info.max_frame_length;
+        imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
+    }
+    if (min_framelength_en)
+        imgsensor.min_frame_length = imgsensor.frame_length;
+    spin_unlock(&imgsensor_drv_lock);
+    set_dummy();
+}    /*    set_max_framerate  */
+
+
+
+/*************************************************************************
+* FUNCTION
+*    set_shutter
+*
+* DESCRIPTION
+*    This function set e-shutter of sensor to change exposure time.
+*
+* PARAMETERS
+*    iShutter : exposured lines
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static void set_shutter(kal_uint16 shutter)
+{
+    unsigned long flags;
+    kal_uint16 realtime_fps = 0;
+    kal_uint32 frame_length = 0;
+    spin_lock_irqsave(&imgsensor_drv_lock, flags);
+    imgsensor.shutter = shutter;
+    spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
+
+    spin_lock(&imgsensor_drv_lock);
+    if (shutter > imgsensor.min_frame_length - imgsensor_info.margin)
+        imgsensor.frame_length = shutter + imgsensor_info.margin;
+    else
+        imgsensor.frame_length = imgsensor.min_frame_length;
+    if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+        imgsensor.frame_length = imgsensor_info.max_frame_length;
+    spin_unlock(&imgsensor_drv_lock);
+    shutter = (shutter < imgsensor_info.min_shutter) ? imgsensor_info.min_shutter : shutter;
+    shutter = (shutter > (imgsensor_info.max_frame_length - imgsensor_info.margin)) ? (imgsensor_info.max_frame_length - imgsensor_info.margin) : shutter;
+
+	// Update Shutter
+	if(shutter > 8191) shutter = 8191;
+	if(shutter < 1) shutter = 1;
+	write_cmos_sensor(0x03, (shutter>>8) & 0x1F);
+	write_cmos_sensor(0x04, shutter & 0xFF);
+
+// del by yfx for test
+//    LOG_INF("Exit! shutter =%d, framelength =%d\n", shutter,imgsensor.frame_length);
+
+}    /*    set_shutter */
+
+
+
+static kal_uint16 gain2reg(const kal_uint16 gain)
+{
+    kal_uint16 reg_gain = 0x0000;
+
+    reg_gain = ((gain / BASEGAIN) << 4) + ((gain % BASEGAIN) * 16 / BASEGAIN);
+    reg_gain = reg_gain & 0xFFFF;
+    return (kal_uint16)reg_gain;
+}
+
+/*************************************************************************
+* FUNCTION
+*    set_gain
+*
+* DESCRIPTION
+*    This function is to set global gain to sensor.
+*
+* PARAMETERS
+*    iGain : sensor global gain(base: 0x40)
+*
+* RETURNS
+*    the actually gain set to sensor.
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint16 set_gain(kal_uint16 gain)
+{
+
+			
+	kal_uint16 iReg,temp,temp1; 	
+
+	
+	iReg = gain;
+	
+	if(256> iReg)
+		{
+			write_cmos_sensor(0xb0, 0x40);// 
+			write_cmos_sensor(0xb1, iReg);// 
+
+		}
+	else
+		{
+			temp = 64*iReg/256;
+			write_cmos_sensor(0xb0, temp);// 
+			write_cmos_sensor(0xb1, 0xff);// 
+		}
+		
+	
+	return gain;
+
+}    /*    set_gain  */
+
+static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gain)
+{
+    LOG_INF("le:0x%x, se:0x%x, gain:0x%x\n",le,se,gain);
+    if (imgsensor.ihdr_en) {
+       
+    }
+
+}
+
+
+
+static void set_mirror_flip(kal_uint8 image_mirror)
+{
+	LOG_INF("image_mirror = %d\n", image_mirror);
+	
+	switch (image_mirror)
+	{
+		case IMAGE_NORMAL://IMAGE_NORMAL:
+			write_cmos_sensor(0x17,0x14);//bit[1][0]
+			write_cmos_sensor(0x92,0x03);
+			write_cmos_sensor(0x94,0x0b);
+			break;
+		case IMAGE_H_MIRROR://IMAGE_H_MIRROR:
+			write_cmos_sensor(0x17,0x15);
+			write_cmos_sensor(0x92,0x03);
+			write_cmos_sensor(0x94,0x0b);
+			break;
+		case IMAGE_V_MIRROR://IMAGE_V_MIRROR:
+			write_cmos_sensor(0x17,0x16);
+			write_cmos_sensor(0x92,0x02);
+			write_cmos_sensor(0x94,0x0b);
+			break;
+		case IMAGE_HV_MIRROR://IMAGE_HV_MIRROR:
+			write_cmos_sensor(0x17,0x17);
+			write_cmos_sensor(0x92,0x02);
+			write_cmos_sensor(0x94,0x0b);
+			break;
+	}
+
+
+}
+
+/*************************************************************************
+* FUNCTION
+*    night_mode
+*
+* DESCRIPTION
+*    This function night mode of sensor.
+*
+* PARAMETERS
+*    bEnable: KAL_TRUE -> enable night mode, otherwise, disable night mode
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static void night_mode(kal_bool enable)
+{
+/*No Need to implement this function*/
+}    /*    night_mode    */
+
+static void sensor_init(void)
+{
+	LOG_INF("E");
+/////////////////////////////////////////////////////
+	//////////////////////	 SYS   //////////////////////
+	/////////////////////////////////////////////////////
+	write_cmos_sensor(0xfe, 0x80);
+	write_cmos_sensor(0xfe, 0x80);
+	write_cmos_sensor(0xfe, 0x80);
+	write_cmos_sensor(0xf2, 0x00);
+	write_cmos_sensor(0xf6, 0x00);
+	write_cmos_sensor(0xfc, 0x06);
+#ifdef GC2235MIPI_2Lane
+	write_cmos_sensor(0xf7, 0x15); //pll enable
+	write_cmos_sensor(0xf8, 0x84); //Pll mode 2
+	write_cmos_sensor(0xfa, 0x00); //div
+#else
+	write_cmos_sensor(0xf7, 0x15); //pll enable
+	write_cmos_sensor(0xf8, 0x86); //Pll mode 2
+	write_cmos_sensor(0xfa, 0x11); //div
+#endif
+	write_cmos_sensor(0xf9, 0xfe); //[0] pll enable
+	write_cmos_sensor(0xfe, 0x00);
+	
+	/////////////////////////////////////////////////////
+	////////////////   ANALOG & CISCTL	 ////////////////
+	/////////////////////////////////////////////////////
+#ifdef GC2235MIPI_2Lane
+	write_cmos_sensor(0x03, 0x05);
+	write_cmos_sensor(0x04, 0x4b);
+	write_cmos_sensor(0x05, 0x01);
+	write_cmos_sensor(0x06, 0x1d);
+	write_cmos_sensor(0x07, 0x00);
+	write_cmos_sensor(0x08, 0x9b);
+#else
+	write_cmos_sensor(0x03, 0x04);
+	write_cmos_sensor(0x04, 0xb0);
+	write_cmos_sensor(0x05, 0x00);
+	write_cmos_sensor(0x06, 0xe4);
+	write_cmos_sensor(0x07, 0x00);
+	write_cmos_sensor(0x08, 0x1a);
+#endif
+	write_cmos_sensor(0x0a, 0x02);
+	write_cmos_sensor(0x0c, 0x00);
+	write_cmos_sensor(0x0d, 0x04);
+	write_cmos_sensor(0x0e, 0xd0);
+	write_cmos_sensor(0x0f, 0x06); 
+	write_cmos_sensor(0x10, 0x50);
+	
+	write_cmos_sensor(0x17, 0x15);//14 //[0]mirror [1]flip
+	write_cmos_sensor(0x18, 0x12); //  0x1e
+	write_cmos_sensor(0x19, 0x06);
+	write_cmos_sensor(0x1a, 0x01);
+#ifdef GC2235MIPI_2Lane
+	write_cmos_sensor(0x1b, 0x48);
+#else
+	write_cmos_sensor(0x1b, 0x4d);
+#endif
+	write_cmos_sensor(0x1e, 0x88); 
+	write_cmos_sensor(0x1f, 0x48); 
+	write_cmos_sensor(0x20, 0x03);
+	write_cmos_sensor(0x21, 0x6f);
+	write_cmos_sensor(0x22, 0x80); 
+	write_cmos_sensor(0x23, 0xc1);
+	write_cmos_sensor(0x24, 0x2f);//PAD_drv
+	write_cmos_sensor(0x26, 0x01);
+	write_cmos_sensor(0x27, 0x30);
+	write_cmos_sensor(0x3f, 0x00);
+	
+	/////////////////////////////////////////////////////
+	//////////////////////	 ISP   //////////////////////
+	/////////////////////////////////////////////////////
+	write_cmos_sensor(0x8b, 0xa0);
+	write_cmos_sensor(0x8c, 0x02);
+	write_cmos_sensor(0x90, 0x01);
+	write_cmos_sensor(0x92, 0x03);
+	write_cmos_sensor(0x94, 0x06);
+	write_cmos_sensor(0x95, 0x04);
+	write_cmos_sensor(0x96, 0xb0);
+	write_cmos_sensor(0x97, 0x06);
+	write_cmos_sensor(0x98, 0x40);
+	
+	/////////////////////////////////////////////////////
+	//////////////////////	 BLK   //////////////////////
+	/////////////////////////////////////////////////////
+	write_cmos_sensor(0x40, 0x72); //smooth speed 
+	write_cmos_sensor(0x41, 0x04);
+	write_cmos_sensor(0x43, 0x18); //global_offset 20140124 lanking
+	write_cmos_sensor(0x5e, 0x00);
+	write_cmos_sensor(0x5f, 0x00);
+	write_cmos_sensor(0x60, 0x00);
+	write_cmos_sensor(0x61, 0x00); 
+	write_cmos_sensor(0x62, 0x00);
+	write_cmos_sensor(0x63, 0x00); 
+	write_cmos_sensor(0x64, 0x00);
+	write_cmos_sensor(0x65, 0x00);
+	write_cmos_sensor(0x66, 0x20);
+	write_cmos_sensor(0x67, 0x20); 
+	write_cmos_sensor(0x68, 0x20);
+	write_cmos_sensor(0x69, 0x20);
+	Sleep(100);
+
+	
+	/////////////////////////////////////////////////////
+	//////////////////////	 GAIN	/////////////////////
+	/////////////////////////////////////////////////////
+	write_cmos_sensor(0xb2, 0x00);
+	write_cmos_sensor(0xb3, 0x40);
+	write_cmos_sensor(0xb4, 0x40);
+	write_cmos_sensor(0xb5, 0x40);
+	
+	/////////////////////////////////////////////////////
+	////////////////////   DARK SUN   ///////////////////
+	/////////////////////////////////////////////////////
+	write_cmos_sensor(0xb8, 0x0f);
+	write_cmos_sensor(0xb9, 0x23);
+	write_cmos_sensor(0xba, 0xff);
+	write_cmos_sensor(0xbc, 0x00);
+	write_cmos_sensor(0xbd, 0x00);
+	write_cmos_sensor(0xbe, 0xff);
+	write_cmos_sensor(0xbf, 0x09);
+
+	/////////////////////////////////////////////////////
+	//////////////////////	 OUTPUT	/////////////////////
+	/////////////////////////////////////////////////////
+	write_cmos_sensor(0xfe, 0x03);
+#ifdef GC2235MIPI_2Lane
+	write_cmos_sensor(0x01, 0x07);
+	write_cmos_sensor(0x02, 0x11);//mipi drv
+	write_cmos_sensor(0x03, 0x11);//mipi drv
+	write_cmos_sensor(0x06, 0x80);
+	write_cmos_sensor(0x11, 0x2b);
+	write_cmos_sensor(0x12, 0xd0);
+	write_cmos_sensor(0x13, 0x07);
+	write_cmos_sensor(0x15, 0x10);
+	write_cmos_sensor(0x04, 0x20);
+	write_cmos_sensor(0x05, 0x00);
+	write_cmos_sensor(0x17, 0x01);
+#else
+	write_cmos_sensor(0x01, 0x03);
+	write_cmos_sensor(0x02, 0x11);//mipi drv
+	write_cmos_sensor(0x03, 0x11);//mipi drv
+	write_cmos_sensor(0x06, 0x80);
+	write_cmos_sensor(0x11, 0x2a);
+	write_cmos_sensor(0x12, 0x40);
+	write_cmos_sensor(0x13, 0x06);
+	write_cmos_sensor(0x15, 0x10);
+	write_cmos_sensor(0x04, 0x01);
+	write_cmos_sensor(0x05, 0x00);
+	write_cmos_sensor(0x17, 0x01);
+#endif	
+
+	write_cmos_sensor(0x21, 0x01);
+	write_cmos_sensor(0x22, 0x02);
+	write_cmos_sensor(0x23, 0x01);
+	write_cmos_sensor(0x29, 0x02);
+	write_cmos_sensor(0x2a, 0x01);
+#ifdef GC2235MIPI_2Lane
+	write_cmos_sensor(0x10, 0x81);  // 93 line_sync_mode 
+#else
+	write_cmos_sensor(0x10, 0x84);  // 92  line_sync_mode
+#endif	
+	write_cmos_sensor(0xfe, 0x00);
+	write_cmos_sensor(0xf2, 0x00);
+
+}    /*    sensor_init  */
+
+
+static void preview_setting(void)
+{
+	LOG_INF("E!\n");
+ // AEC&frame length//; 		
+
+  //MIPI//
+  write_cmos_sensor(0xfe,0x03);
+#ifdef GC2235MIPI_2Lane
+	write_cmos_sensor(0x10, 0x91);  // 93 line_sync_mode 
+#else
+	write_cmos_sensor(0x10, 0x94);  // 92  line_sync_mode
+#endif	 
+  write_cmos_sensor(0xfe,0x00);	
+	
+}    /*    preview_setting  */
+
+static void capture_setting(kal_uint16 currefps)
+{
+	LOG_INF("E! currefps:%d\n",currefps);
+
+	write_cmos_sensor(0xfe,0x03);
+#ifdef GC2235MIPI_2Lane
+	write_cmos_sensor(0x10, 0x91);  // 93 line_sync_mode 
+#else
+	write_cmos_sensor(0x10, 0x94);  // 92  line_sync_mode
+#endif	 
+  	write_cmos_sensor(0xfe,0x00);	
+		
+}
+
+
+static void normal_video_setting(kal_uint16 currefps)
+{
+	LOG_INF("E! currefps:%d\n",currefps);
+	
+		  write_cmos_sensor(0xfe,0x03);
+#ifdef GC2235MIPI_2Lane
+	write_cmos_sensor(0x10, 0x91);  // 93 line_sync_mode 
+#else
+	write_cmos_sensor(0x10, 0x94);  // 92  line_sync_mode
+#endif	 
+  	write_cmos_sensor(0xfe,0x00);	
+		
+}
+
+static void hs_video_setting()
+{
+    LOG_INF("E\n");
+	
+	write_cmos_sensor(0xfe,0x03);
+#ifdef GC2235MIPI_2Lane
+	write_cmos_sensor(0x10, 0x91);  // 93 line_sync_mode 
+#else
+	write_cmos_sensor(0x10, 0x94);  // 92  line_sync_mode
+#endif	 
+  	write_cmos_sensor(0xfe,0x00);	
+
+}
+
+static void slim_video_setting()
+{
+    LOG_INF("E\n");
+	
+	write_cmos_sensor(0xfe,0x03);
+#ifdef GC2235MIPI_2Lane
+	write_cmos_sensor(0x10, 0x91);  // 93 line_sync_mode 
+#else
+	write_cmos_sensor(0x10, 0x94);  // 92  line_sync_mode
+#endif	 
+  	write_cmos_sensor(0xfe,0x00);	
+}
+
+static kal_uint32 set_test_pattern_mode(kal_bool enable)
+{
+    LOG_INF("enable: %d\n", enable);
+
+    if(enable)
+    {
+    	/////////////// mode/////////////
+
+    }
+	else
+	{
+	/////////////// mode/////////////
+	}
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.test_pattern = enable;
+    spin_unlock(&imgsensor_drv_lock);
+    return ERROR_NONE;
+}
+
+/*************************************************************************
+* FUNCTION
+*    get_imgsensor_id
+*
+* DESCRIPTION
+*    This function get the sensor ID
+*
+* PARAMETERS
+*    *sensorID : return the sensor ID
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 get_imgsensor_id(UINT32 *sensor_id)
+{
+    kal_uint8 i = 0;
+    kal_uint8 retry = 2;
+    //sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
+    while (imgsensor_info.i2c_addr_table[i] != 0xff) {
+        spin_lock(&imgsensor_drv_lock);
+        imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
+        spin_unlock(&imgsensor_drv_lock);
+        do {
+            *sensor_id = return_sensor_id();
+            if (*sensor_id == imgsensor_info.sensor_id) {
+                LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
+                return ERROR_NONE;
+            }
+            LOG_INF("Read sensor id fail, write id: 0x%x, id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
+            retry--;
+        } while(retry > 0);
+        i++;
+        retry = 2;
+    }
+    if (*sensor_id != imgsensor_info.sensor_id) {
+        // if Sensor ID is not correct, Must set *sensor_id to 0xFFFFFFFF
+        *sensor_id = 0xFFFFFFFF;
+        return ERROR_SENSOR_CONNECT_FAIL;
+    }
+    return ERROR_NONE;
+}
+
+
+/*************************************************************************
+* FUNCTION
+*    open
+*
+* DESCRIPTION
+*    This function initialize the registers of CMOS sensor
+*
+* PARAMETERS
+*    None
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 open(void)
+{
+    kal_uint8 i = 0;
+    kal_uint8 retry = 2;
+    kal_uint32 sensor_id = 0;
+    LOG_1;
+    LOG_2;
+    //sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
+    while (imgsensor_info.i2c_addr_table[i] != 0xff) {
+        spin_lock(&imgsensor_drv_lock);
+        imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
+        spin_unlock(&imgsensor_drv_lock);
+        do {
+            sensor_id = return_sensor_id();
+            if (sensor_id == imgsensor_info.sensor_id) {
+                LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
+                break;
+            }
+            LOG_INF("Read sensor id fail, write id: 0x%x, id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
+            retry--;
+        } while(retry > 0);
+        i++;
+        if (sensor_id == imgsensor_info.sensor_id)
+            break;
+        retry = 2;
+    }
+    if (imgsensor_info.sensor_id != sensor_id)
+        return ERROR_SENSOR_CONNECT_FAIL;
+
+    /* initail sequence write in  */
+    sensor_init();
+
+    spin_lock(&imgsensor_drv_lock);
+
+    imgsensor.autoflicker_en= KAL_FALSE;
+    imgsensor.sensor_mode = IMGSENSOR_MODE_INIT;
+    imgsensor.pclk = imgsensor_info.pre.pclk;
+    imgsensor.frame_length = imgsensor_info.pre.framelength;
+    imgsensor.line_length = imgsensor_info.pre.linelength;
+    imgsensor.min_frame_length = imgsensor_info.pre.framelength;
+    imgsensor.dummy_pixel = 0;
+    imgsensor.dummy_line = 0;
+    imgsensor.ihdr_en = 0;
+    imgsensor.test_pattern = KAL_FALSE;
+    imgsensor.current_fps = imgsensor_info.pre.max_framerate;
+    spin_unlock(&imgsensor_drv_lock);
+
+    return ERROR_NONE;
+}    /*    open  */
+
+
+
+/*************************************************************************
+* FUNCTION
+*    close
+*
+* DESCRIPTION
+*
+*
+* PARAMETERS
+*    None
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 close(void)
+{
+    LOG_INF("E\n");
+
+    /*No Need to implement this function*/
+
+    return ERROR_NONE;
+}    /*    close  */
+
+
+/*************************************************************************
+* FUNCTION
+* preview
+*
+* DESCRIPTION
+*    This function start the sensor preview.
+*
+* PARAMETERS
+*    *image_window : address pointer of pixel numbers in one period of HSYNC
+*  *sensor_config_data : address pointer of line numbers in one period of VSYNC
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_PREVIEW;
+    imgsensor.pclk = imgsensor_info.pre.pclk;
+    //imgsensor.video_mode = KAL_FALSE;
+    imgsensor.line_length = imgsensor_info.pre.linelength;
+    imgsensor.frame_length = imgsensor_info.pre.framelength;
+    imgsensor.min_frame_length = imgsensor_info.pre.framelength;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    preview_setting();
+	//set_mirror_flip(sensor_config_data->SensorImageMirror);
+    return ERROR_NONE;
+}    /*    preview   */
+
+/*************************************************************************
+* FUNCTION
+*    capture
+*
+* DESCRIPTION
+*    This function setup the CMOS sensor in capture MY_OUTPUT mode
+*
+* PARAMETERS
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                          MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+	
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_CAPTURE;
+    if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {//PIP capture: 24fps for less than 13M, 20fps for 16M,15fps for 20M
+        imgsensor.pclk = imgsensor_info.cap1.pclk;
+        imgsensor.line_length = imgsensor_info.cap1.linelength;
+        imgsensor.frame_length = imgsensor_info.cap1.framelength;
+        imgsensor.min_frame_length = imgsensor_info.cap1.framelength;
+        imgsensor.autoflicker_en = KAL_FALSE;
+    } else {
+        if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
+            LOG_INF("Warning: current_fps %d fps is not support, so use cap's setting: %d fps!\n",imgsensor.current_fps,imgsensor_info.cap.max_framerate/10);
+        imgsensor.pclk = imgsensor_info.cap.pclk;
+        imgsensor.line_length = imgsensor_info.cap.linelength;
+        imgsensor.frame_length = imgsensor_info.cap.framelength;
+        imgsensor.min_frame_length = imgsensor_info.cap.framelength;
+        imgsensor.autoflicker_en = KAL_FALSE;
+    }
+    spin_unlock(&imgsensor_drv_lock);
+    capture_setting(imgsensor.current_fps);
+	//set_mirror_flip(sensor_config_data->SensorImageMirror);
+    return ERROR_NONE;
+}    /* capture() */
+static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_VIDEO;
+    imgsensor.pclk = imgsensor_info.normal_video.pclk;
+    imgsensor.line_length = imgsensor_info.normal_video.linelength;
+    imgsensor.frame_length = imgsensor_info.normal_video.framelength;
+    imgsensor.min_frame_length = imgsensor_info.normal_video.framelength;
+    //imgsensor.current_fps = 300;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    normal_video_setting(imgsensor.current_fps);	
+	//set_mirror_flip(sensor_config_data->SensorImageMirror);
+    return ERROR_NONE;
+}    /*    normal_video   */
+
+static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_HIGH_SPEED_VIDEO;
+    imgsensor.pclk = imgsensor_info.hs_video.pclk;
+    //imgsensor.video_mode = KAL_TRUE;
+    imgsensor.line_length = imgsensor_info.hs_video.linelength;
+    imgsensor.frame_length = imgsensor_info.hs_video.framelength;
+    imgsensor.min_frame_length = imgsensor_info.hs_video.framelength;
+    imgsensor.dummy_line = 0;
+    imgsensor.dummy_pixel = 0;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    hs_video_setting();	
+	//set_mirror_flip(sensor_config_data->SensorImageMirror);
+    return ERROR_NONE;
+}    /*    hs_video   */
+
+static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_SLIM_VIDEO;
+    imgsensor.pclk = imgsensor_info.slim_video.pclk;
+    imgsensor.line_length = imgsensor_info.slim_video.linelength;
+    imgsensor.frame_length = imgsensor_info.slim_video.framelength;
+    imgsensor.min_frame_length = imgsensor_info.slim_video.framelength;
+    imgsensor.dummy_line = 0;
+    imgsensor.dummy_pixel = 0;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    slim_video_setting();
+	//set_mirror_flip(sensor_config_data->SensorImageMirror);
+
+    return ERROR_NONE;
+}    /*    slim_video     */
+
+
+
+static kal_uint32 get_resolution(MSDK_SENSOR_RESOLUTION_INFO_STRUCT *sensor_resolution)
+{
+    LOG_INF("E\n");
+    sensor_resolution->SensorFullWidth = imgsensor_info.cap.grabwindow_width;
+    sensor_resolution->SensorFullHeight = imgsensor_info.cap.grabwindow_height;
+
+    sensor_resolution->SensorPreviewWidth = imgsensor_info.pre.grabwindow_width;
+    sensor_resolution->SensorPreviewHeight = imgsensor_info.pre.grabwindow_height;
+
+    sensor_resolution->SensorVideoWidth = imgsensor_info.normal_video.grabwindow_width;
+    sensor_resolution->SensorVideoHeight = imgsensor_info.normal_video.grabwindow_height;
+
+
+    sensor_resolution->SensorHighSpeedVideoWidth     = imgsensor_info.hs_video.grabwindow_width;
+    sensor_resolution->SensorHighSpeedVideoHeight     = imgsensor_info.hs_video.grabwindow_height;
+
+    sensor_resolution->SensorSlimVideoWidth     = imgsensor_info.slim_video.grabwindow_width;
+    sensor_resolution->SensorSlimVideoHeight     = imgsensor_info.slim_video.grabwindow_height;
+    return ERROR_NONE;
+}    /*    get_resolution    */
+
+static kal_uint32 get_info(MSDK_SCENARIO_ID_ENUM scenario_id,
+                      MSDK_SENSOR_INFO_STRUCT *sensor_info,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("scenario_id = %d\n", scenario_id);
+
+
+    //sensor_info->SensorVideoFrameRate = imgsensor_info.normal_video.max_framerate/10; /* not use */
+    //sensor_info->SensorStillCaptureFrameRate= imgsensor_info.cap.max_framerate/10; /* not use */
+    //imgsensor_info->SensorWebCamCaptureFrameRate= imgsensor_info.v.max_framerate; /* not use */
+
+    sensor_info->SensorClockPolarity = SENSOR_CLOCK_POLARITY_LOW;
+    sensor_info->SensorClockFallingPolarity = SENSOR_CLOCK_POLARITY_LOW; /* not use */
+    sensor_info->SensorHsyncPolarity = SENSOR_CLOCK_POLARITY_LOW; // inverse with datasheet
+    sensor_info->SensorVsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
+    sensor_info->SensorInterruptDelayLines = 4; /* not use */
+    sensor_info->SensorResetActiveHigh = FALSE; /* not use */
+    sensor_info->SensorResetDelayCount = 5; /* not use */
+
+    sensor_info->SensroInterfaceType = imgsensor_info.sensor_interface_type;
+    sensor_info->MIPIsensorType = imgsensor_info.mipi_sensor_type;
+    sensor_info->SettleDelayMode = imgsensor_info.mipi_settle_delay_mode;
+    sensor_info->SensorOutputDataFormat = imgsensor_info.sensor_output_dataformat;
+
+    sensor_info->CaptureDelayFrame = imgsensor_info.cap_delay_frame;
+    sensor_info->PreviewDelayFrame = imgsensor_info.pre_delay_frame;
+    sensor_info->VideoDelayFrame = imgsensor_info.video_delay_frame;
+    sensor_info->HighSpeedVideoDelayFrame = imgsensor_info.hs_video_delay_frame;
+    sensor_info->SlimVideoDelayFrame = imgsensor_info.slim_video_delay_frame;
+
+    sensor_info->SensorMasterClockSwitch = 0; /* not use */
+    sensor_info->SensorDrivingCurrent = imgsensor_info.isp_driving_current;
+
+    sensor_info->AEShutDelayFrame = imgsensor_info.ae_shut_delay_frame;          /* The frame of setting shutter default 0 for TG int */
+    sensor_info->AESensorGainDelayFrame = imgsensor_info.ae_sensor_gain_delay_frame;    /* The frame of setting sensor gain */
+    sensor_info->AEISPGainDelayFrame = imgsensor_info.ae_ispGain_delay_frame;
+    sensor_info->IHDR_Support = imgsensor_info.ihdr_support;
+    sensor_info->IHDR_LE_FirstLine = imgsensor_info.ihdr_le_firstline;
+    sensor_info->SensorModeNum = imgsensor_info.sensor_mode_num;
+
+    sensor_info->SensorMIPILaneNumber = imgsensor_info.mipi_lane_num;
+    sensor_info->SensorClockFreq = imgsensor_info.mclk;
+    sensor_info->SensorClockDividCount = 3; /* not use */
+    sensor_info->SensorClockRisingCount = 0;
+    sensor_info->SensorClockFallingCount = 2; /* not use */
+    sensor_info->SensorPixelClockCount = 3; /* not use */
+    sensor_info->SensorDataLatchCount = 2; /* not use */
+
+    sensor_info->MIPIDataLowPwr2HighSpeedTermDelayCount = 0;
+    sensor_info->MIPICLKLowPwr2HighSpeedTermDelayCount = 0;
+    sensor_info->SensorWidthSampling = 0;  // 0 is default 1x
+    sensor_info->SensorHightSampling = 0;    // 0 is default 1x
+    sensor_info->SensorPacketECCOrder = 1;
+
+    switch (scenario_id) {
+        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+            sensor_info->SensorGrabStartX = imgsensor_info.pre.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
+
+            break;
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+            sensor_info->SensorGrabStartX = imgsensor_info.cap.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.cap.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.cap.mipi_data_lp2hs_settle_dc;
+
+            break;
+        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+
+            sensor_info->SensorGrabStartX = imgsensor_info.normal_video.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.normal_video.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.normal_video.mipi_data_lp2hs_settle_dc;
+
+            break;
+        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+            sensor_info->SensorGrabStartX = imgsensor_info.hs_video.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.hs_video.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.hs_video.mipi_data_lp2hs_settle_dc;
+
+            break;
+        case MSDK_SCENARIO_ID_SLIM_VIDEO:
+            sensor_info->SensorGrabStartX = imgsensor_info.slim_video.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.slim_video.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.slim_video.mipi_data_lp2hs_settle_dc;
+
+            break;
+        default:
+            sensor_info->SensorGrabStartX = imgsensor_info.pre.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
+            break;
+    }
+
+    return ERROR_NONE;
+}    /*    get_info  */
+
+
+static kal_uint32 control(MSDK_SCENARIO_ID_ENUM scenario_id, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("scenario_id = %d\n", scenario_id);
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.current_scenario_id = scenario_id;
+    spin_unlock(&imgsensor_drv_lock);
+    switch (scenario_id) {
+        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+            preview(image_window, sensor_config_data);
+            break;
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+            capture(image_window, sensor_config_data);
+            break;
+        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+            normal_video(image_window, sensor_config_data);
+            break;
+        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+            hs_video(image_window, sensor_config_data);
+            break;
+        case MSDK_SCENARIO_ID_SLIM_VIDEO:
+            slim_video(image_window, sensor_config_data);
+            break;
+        default:
+            LOG_INF("Error ScenarioId setting");
+            preview(image_window, sensor_config_data);
+            return ERROR_INVALID_SCENARIO_ID;
+    }
+    return ERROR_NONE;
+}    /* control() */
+
+
+
+static kal_uint32 set_video_mode(UINT16 framerate)
+{//This Function not used after ROME
+    LOG_INF("framerate = %d\n ", framerate);
+    // SetVideoMode Function should fix framerate
+    if (framerate == 0)
+        // Dynamic frame rate
+        return ERROR_NONE;
+    spin_lock(&imgsensor_drv_lock);
+    if ((framerate == 300) && (imgsensor.autoflicker_en == KAL_TRUE))
+        imgsensor.current_fps = 296;
+    else if ((framerate == 150) && (imgsensor.autoflicker_en == KAL_TRUE))
+        imgsensor.current_fps = 146;
+    else
+        imgsensor.current_fps = framerate;
+    spin_unlock(&imgsensor_drv_lock);
+    set_max_framerate(imgsensor.current_fps,1);
+
+    return ERROR_NONE;
+}
+
+static kal_uint32 set_auto_flicker_mode(kal_bool enable, UINT16 framerate)
+{
+    LOG_INF("enable = %d, framerate = %d \n", enable, framerate);
+    spin_lock(&imgsensor_drv_lock);
+    if (enable) //enable auto flicker
+        imgsensor.autoflicker_en = KAL_TRUE;
+    else //Cancel Auto flick
+        imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    return ERROR_NONE;
+}
+
+
+static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 framerate)
+{
+    kal_uint32 frame_length;
+
+    LOG_INF("scenario_id = %d, framerate = %d\n", scenario_id, framerate);
+
+    switch (scenario_id) {
+        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+            frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            set_dummy();
+            break;
+        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+            if(framerate == 0)
+                return ERROR_NONE;
+            frame_length = imgsensor_info.normal_video.pclk / framerate * 10 / imgsensor_info.normal_video.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.normal_video.framelength) ? (frame_length - imgsensor_info.normal_video.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.normal_video.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            set_dummy();
+            break;
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+        	  if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {
+                frame_length = imgsensor_info.cap1.pclk / framerate * 10 / imgsensor_info.cap1.linelength;
+                spin_lock(&imgsensor_drv_lock);
+		            imgsensor.dummy_line = (frame_length > imgsensor_info.cap1.framelength) ? (frame_length - imgsensor_info.cap1.framelength) : 0;
+		            imgsensor.frame_length = imgsensor_info.cap1.framelength + imgsensor.dummy_line;
+		            imgsensor.min_frame_length = imgsensor.frame_length;
+		            spin_unlock(&imgsensor_drv_lock);
+            } else {
+        		    if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
+                    LOG_INF("Warning: current_fps %d fps is not support, so use cap's setting: %d fps!\n",framerate,imgsensor_info.cap.max_framerate/10);
+                frame_length = imgsensor_info.cap.pclk / framerate * 10 / imgsensor_info.cap.linelength;
+                spin_lock(&imgsensor_drv_lock);
+		            imgsensor.dummy_line = (frame_length > imgsensor_info.cap.framelength) ? (frame_length - imgsensor_info.cap.framelength) : 0;
+		            imgsensor.frame_length = imgsensor_info.cap.framelength + imgsensor.dummy_line;
+		            imgsensor.min_frame_length = imgsensor.frame_length;
+		            spin_unlock(&imgsensor_drv_lock);
+            }
+            set_dummy();
+            break;
+        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+            frame_length = imgsensor_info.hs_video.pclk / framerate * 10 / imgsensor_info.hs_video.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.hs_video.framelength) ? (frame_length - imgsensor_info.hs_video.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.hs_video.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            set_dummy();
+            break;
+        case MSDK_SCENARIO_ID_SLIM_VIDEO:
+            frame_length = imgsensor_info.slim_video.pclk / framerate * 10 / imgsensor_info.slim_video.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.slim_video.framelength) ? (frame_length - imgsensor_info.slim_video.framelength): 0;
+            imgsensor.frame_length = imgsensor_info.slim_video.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            set_dummy();
+            break;
+        default:  //coding with  preview scenario by default
+            frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            set_dummy();
+            LOG_INF("error scenario_id = %d, we use preview scenario \n", scenario_id);
+            break;
+    }
+    return ERROR_NONE;
+}
+
+
+static kal_uint32 get_default_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 *framerate)
+{
+    LOG_INF("scenario_id = %d\n", scenario_id);
+
+    switch (scenario_id) {
+        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+            *framerate = imgsensor_info.pre.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+            *framerate = imgsensor_info.normal_video.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+            *framerate = imgsensor_info.cap.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+            *framerate = imgsensor_info.hs_video.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_SLIM_VIDEO:
+            *framerate = imgsensor_info.slim_video.max_framerate;
+            break;
+        default:
+            break;
+    }
+
+    return ERROR_NONE;
+}
+
+
+
+static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
+                             UINT8 *feature_para,UINT32 *feature_para_len)
+{
+    UINT16 *feature_return_para_16=(UINT16 *) feature_para;
+    UINT16 *feature_data_16=(UINT16 *) feature_para;
+    UINT32 *feature_return_para_32=(UINT32 *) feature_para;
+    UINT32 *feature_data_32=(UINT32 *) feature_para;
+	unsigned long long *feature_data=(unsigned long long *) feature_para;
+    unsigned long long *feature_return_para=(unsigned long long *) feature_para;
+
+    SENSOR_WINSIZE_INFO_STRUCT *wininfo;
+    MSDK_SENSOR_REG_INFO_STRUCT *sensor_reg_data=(MSDK_SENSOR_REG_INFO_STRUCT *) feature_para;
+
+    LOG_INF("feature_id = %d\n", feature_id);
+    switch (feature_id) {
+        case SENSOR_FEATURE_GET_PERIOD:
+            *feature_return_para_16++ = imgsensor.line_length;
+            *feature_return_para_16 = imgsensor.frame_length;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:
+            *feature_return_para_32 = imgsensor.pclk;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_SET_ESHUTTER:
+			set_shutter(*feature_data);
+            break;
+        case SENSOR_FEATURE_SET_NIGHTMODE:
+			night_mode((BOOL) *feature_data);
+            break;
+        case SENSOR_FEATURE_SET_GAIN:
+			set_gain((UINT16) *feature_data);
+            break;
+        case SENSOR_FEATURE_SET_FLASHLIGHT:
+            break;
+        case SENSOR_FEATURE_SET_ISP_MASTER_CLOCK_FREQ:
+            break;
+        case SENSOR_FEATURE_SET_REGISTER:
+            write_cmos_sensor(sensor_reg_data->RegAddr, sensor_reg_data->RegData);
+            break;
+        case SENSOR_FEATURE_GET_REGISTER:
+            sensor_reg_data->RegData = read_cmos_sensor(sensor_reg_data->RegAddr);
+            break;
+        case SENSOR_FEATURE_GET_LENS_DRIVER_ID:
+            // get the lens driver ID from EEPROM or just return LENS_DRIVER_ID_DO_NOT_CARE
+            // if EEPROM does not exist in camera module.
+            *feature_return_para_32=LENS_DRIVER_ID_DO_NOT_CARE;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_SET_VIDEO_MODE:
+			set_video_mode(*feature_data);
+            break;
+        case SENSOR_FEATURE_CHECK_SENSOR_ID:
+            get_imgsensor_id(feature_return_para_32);
+            break;
+        case SENSOR_FEATURE_SET_AUTO_FLICKER_MODE:
+            set_auto_flicker_mode((BOOL)*feature_data_16,*(feature_data_16+1));
+			break;
+		case SENSOR_FEATURE_SET_MAX_FRAME_RATE_BY_SCENARIO:
+			set_max_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data, *(feature_data+1));
+			break;
+		case SENSOR_FEATURE_GET_DEFAULT_FRAME_RATE_BY_SCENARIO:
+			get_default_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data, (MUINT32 *)(uintptr_t)(*(feature_data+1)));
+			break;
+		case SENSOR_FEATURE_SET_TEST_PATTERN:
+			set_test_pattern_mode((BOOL)*feature_data);
+			break;
+		case SENSOR_FEATURE_GET_TEST_PATTERN_CHECKSUM_VALUE: //for factory mode auto testing			 
+			*feature_return_para_32 = imgsensor_info.checksum_value;
+			*feature_para_len=4;							 
+			break;				
+		case SENSOR_FEATURE_SET_FRAMERATE:
+			LOG_INF("current fps :%d\n",  (UINT32)*feature_data);
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.current_fps = *feature_data;
+			spin_unlock(&imgsensor_drv_lock);		
+			break;
+		case SENSOR_FEATURE_SET_HDR:
+			LOG_INF("ihdr enable :%d\n", (BOOL)*feature_data);
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.ihdr_en = (bool)*feature_data;
+			spin_unlock(&imgsensor_drv_lock);		
+			break;
+		case SENSOR_FEATURE_GET_CROP_INFO:
+			LOG_INF("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n", (UINT32)*feature_data);
+			wininfo = (SENSOR_WINSIZE_INFO_STRUCT *)(uintptr_t)(*(feature_data+1));
+		
+            switch (*feature_data_32) {
+                case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[1],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[2],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[3],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_SLIM_VIDEO:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[4],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+                default:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[0],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+            }
+        case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
+			LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",(UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2)); 
+			ihdr_write_shutter_gain((UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));	
+            break;
+        default:
+            break;
+    }
+
+    return ERROR_NONE;
+}    /*    feature_control()  */
+
+static SENSOR_FUNCTION_STRUCT sensor_func = {
+    open,
+    get_info,
+    get_resolution,
+    feature_control,
+    control,
+    close
+};
+
+UINT32 GC2235_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
+{
+	/* To Do : Check Sensor status here */
+	if (pfFunc!=NULL)
+		*pfFunc=&sensor_func;
+	return ERROR_NONE;
+}	/*	GC2235MIPI_RAW_SensorInit	*/
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2235_mipi_raw/gc2235mipi_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2235_mipi_raw/gc2235mipi_Sensor.h
new file mode 100755
index 0000000..1cb66e3
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2235_mipi_raw/gc2235mipi_Sensor.h
@@ -0,0 +1,144 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *     GC2235mipi_Sensor.h
+ *
+ * Project:
+ * --------
+ *     ALPS
+ *
+ * Description:
+ * ------------
+ *     CMOS sensor header file
+ *
+ ****************************************************************************/
+#ifndef _GC2235MIPI_SENSOR_H
+#define _GC2235MIPI_SENSOR_H
+
+
+typedef enum{
+    IMGSENSOR_MODE_INIT,
+    IMGSENSOR_MODE_PREVIEW,
+    IMGSENSOR_MODE_CAPTURE,
+    IMGSENSOR_MODE_VIDEO,
+    IMGSENSOR_MODE_HIGH_SPEED_VIDEO,
+    IMGSENSOR_MODE_SLIM_VIDEO,
+} IMGSENSOR_MODE;
+
+typedef struct imgsensor_mode_struct {
+    kal_uint32 pclk;                //record different mode's pclk
+    kal_uint32 linelength;            //record different mode's linelength
+    kal_uint32 framelength;            //record different mode's framelength
+
+    kal_uint8 startx;                //record different mode's startx of grabwindow
+    kal_uint8 starty;                //record different mode's startx of grabwindow
+
+    kal_uint16 grabwindow_width;    //record different mode's width of grabwindow
+    kal_uint16 grabwindow_height;    //record different mode's height of grabwindow
+
+    /*     following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario    */
+    kal_uint8 mipi_data_lp2hs_settle_dc;
+
+    /*     following for GetDefaultFramerateByScenario()    */
+    kal_uint16 max_framerate;
+
+} imgsensor_mode_struct;
+
+/* SENSOR PRIVATE STRUCT FOR VARIABLES*/
+typedef struct imgsensor_struct {
+    kal_uint8 mirror;                //mirrorflip information
+
+    kal_uint8 sensor_mode;            //record IMGSENSOR_MODE enum value
+
+    kal_uint32 shutter;                //current shutter
+    kal_uint16 gain;                //current gain
+
+    kal_uint32 pclk;                //current pclk
+
+    kal_uint32 frame_length;        //current framelength
+    kal_uint32 line_length;            //current linelength
+
+    kal_uint32 min_frame_length;    //current min  framelength to max framerate
+    kal_uint16 dummy_pixel;            //current dummypixel
+    kal_uint16 dummy_line;            //current dummline
+
+    kal_uint16 current_fps;            //current max fps
+    kal_bool   autoflicker_en;        //record autoflicker enable or disable
+    kal_bool test_pattern;            //record test pattern mode or not
+    MSDK_SCENARIO_ID_ENUM current_scenario_id;//current scenario id
+    kal_uint8  ihdr_en;                //ihdr enable or disable
+
+    kal_uint8 i2c_write_id;            //record current sensor's i2c write id
+} imgsensor_struct;
+
+/* SENSOR PRIVATE STRUCT FOR CONSTANT*/
+typedef struct imgsensor_info_struct {
+    kal_uint32 sensor_id;            //record sensor id defined in Kd_imgsensor.h
+    kal_uint32 checksum_value;        //checksum value for Camera Auto Test
+    imgsensor_mode_struct pre;        //preview scenario relative information
+    imgsensor_mode_struct cap;        //capture scenario relative information
+    imgsensor_mode_struct cap1;        //capture for PIP 24fps relative information, capture1 mode must use same framelength, linelength with Capture mode for shutter calculate
+    imgsensor_mode_struct normal_video;//normal video  scenario relative information
+    imgsensor_mode_struct hs_video;    //high speed video scenario relative information
+    imgsensor_mode_struct slim_video;    //slim video for VT scenario relative information
+
+    kal_uint8  ae_shut_delay_frame;    //shutter delay frame for AE cycle
+    kal_uint8  ae_sensor_gain_delay_frame;    //sensor gain delay frame for AE cycle
+    kal_uint8  ae_ispGain_delay_frame;    //isp gain delay frame for AE cycle
+    kal_uint8  ihdr_support;        //1, support; 0,not support
+    kal_uint8  ihdr_le_firstline;    //1,le first ; 0, se first
+    kal_uint8  sensor_mode_num;        //support sensor mode num
+
+    kal_uint8  cap_delay_frame;        //enter capture delay frame num
+    kal_uint8  pre_delay_frame;        //enter preview delay frame num
+    kal_uint8  video_delay_frame;    //enter video delay frame num
+    kal_uint8  hs_video_delay_frame;    //enter high speed video  delay frame num
+    kal_uint8  slim_video_delay_frame;    //enter slim video delay frame num
+
+    kal_uint8  margin;                //sensor framelength & shutter margin
+    kal_uint32 min_shutter;            //min shutter
+    kal_uint32 max_frame_length;    //max framelength by sensor register's limitation
+
+    kal_uint8  isp_driving_current;    //mclk driving current
+    kal_uint8  sensor_interface_type;//sensor_interface_type
+    kal_uint8  mipi_sensor_type; //0,MIPI_OPHY_NCSI2; 1,MIPI_OPHY_CSI2, default is NCSI2, don't modify this para
+    kal_uint8  mipi_settle_delay_mode; //0, high speed signal auto detect; 1, use settle delay,unit is ns, default is auto detect, don't modify this para
+    kal_uint8  sensor_output_dataformat;//sensor output first pixel color
+    kal_uint8  mclk;                //mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
+
+    kal_uint8  mipi_lane_num;        //mipi lane num
+    kal_uint8  i2c_addr_table[5];    //record sensor support all write id addr, only supprt 4must end with 0xff
+} imgsensor_info_struct;
+
+/* SENSOR READ/WRITE ID */
+//#define IMGSENSOR_WRITE_ID_1 (0x6c)
+//#define IMGSENSOR_READ_ID_1  (0x6d)
+//#define IMGSENSOR_WRITE_ID_2 (0x20)
+//#define IMGSENSOR_READ_ID_2  (0x21)
+
+// add by yfx
+#define GC2235_VALID_IXEL_NUMS            800
+#define GC2235_VALID_LINE_NUMS            1200
+#define GC2235_DEFAULT_DUMMY_PIXEL_NUMS   0x11c //244 
+#define GC2235_DEFAULT_DUMMY_LINE_NUMS    0x0e //64
+
+#define GC2235_INTERNAL_DUMMY_PIXEL_NUMS  36
+#define GC2235_INTERNAL_DUMMY_LINE_NUMS   32
+
+#define GC2235_VIDEO_PERIOD_PIXEL_NUMS          (1107)
+#define GC2235_VIDEO_PERIOD_LINE_NUMS           (1387)
+#define GC2235_PV_PERIOD_PIXEL_NUMS            (1107)
+#define GC2235_PV_PERIOD_LINE_NUMS             (1387)
+
+#define GC2235_FULL_PERIOD_PIXEL_NUMS          (1107)
+#define GC2235_FULL_PERIOD_LINE_NUMS           (1387)
+
+
+// end
+
+extern int iReadRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u8 * a_pRecvData, u16 a_sizeRecvData, u16 i2cId);
+extern int iWriteRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u16 i2cId);
+extern int iWriteReg(u16 a_u2Addr , u32 a_u4Data , u32 a_u4Bytes , u16 i2cId); 
+
+#endif
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2355_mipi_raw/gc2355mipi_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2355_mipi_raw/gc2355mipi_Sensor.c
old mode 100644
new mode 100755
index 08ec2d1..8530335
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2355_mipi_raw/gc2355mipi_Sensor.c
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2355_mipi_raw/gc2355mipi_Sensor.c
@@ -26,7 +26,7 @@
 #include <linux/uaccess.h>
 #include <linux/fs.h>
 #include <asm/atomic.h>
-//#include <asm/system.h>
+#include <asm/system.h>
 #include <linux/xlog.h>
 
 #include "kd_camera_hw.h"
@@ -35,6 +35,7 @@
 #include "kd_imgsensor_errcode.h"
 
 #include "gc2355mipi_Sensor.h"
+#define GC2355MIPI_2Lane   //   for  mipi lane num
 /****************************Modify Following Strings for Debug****************************/
 #define PFX "GC2355_camera_sensor"
 #define LOG_1 LOG_INF("GC2355,MIPI 2LANE\n")
@@ -42,7 +43,6 @@
 /****************************   Modify end    *******************************************/
 
 #define LOG_INF(format, args...)    pr_debug(PFX "[%s] " format, __FUNCTION__, ##args)
-
 static DEFINE_SPINLOCK(imgsensor_drv_lock);
 
 
@@ -50,12 +50,12 @@ static imgsensor_info_struct imgsensor_info = {
     .sensor_id = GC2355_SENSOR_ID,        //record sensor id defined in Kd_imgsensor.h
 
     //.checksum_value = 0x9d1c9dad,        //checksum value for Camera Auto Test
-    .checksum_value = 0xffd8e112,        //checksum value for Camera Auto Test
+    .checksum_value = 0x9d1c9dad,        //checksum value for Camera Auto Test
 
     .pre = {
         .pclk = 42000000,                //record different mode's pclk
-        .linelength = 1120,                //record different mode's linelength
-        .framelength = 1246,            //record different mode's framelength
+        .linelength = 1680,                //record different mode's linelength
+        .framelength = 1250,            //record different mode's framelength
         .startx = 0,                    //record different mode's startx of grabwindow
         .starty = 0,                    //record different mode's starty of grabwindow
         .grabwindow_width = 1600,        //record different mode's width of grabwindow
@@ -67,8 +67,8 @@ static imgsensor_info_struct imgsensor_info = {
     },
     .cap = {
         .pclk = 42000000,
-        .linelength = 1120,
-        .framelength = 1246,
+        .linelength = 1680,
+        .framelength = 1250,
         .startx = 0,
         .starty = 0,
         .grabwindow_width = 1600,
@@ -77,9 +77,9 @@ static imgsensor_info_struct imgsensor_info = {
         .max_framerate = 300,
     },
     .cap1 = {                            //capture for PIP 24fps relative information, capture1 mode must use same framelength, linelength with Capture mode for shutter calculate
-        .pclk = 42000000,
-        .linelength = 1120,
-        .framelength = 1246,
+         .pclk = 42000000,
+        .linelength = 1680,
+        .framelength = 1250,
         .startx = 0,
         .starty = 0,
         .grabwindow_width = 1600,
@@ -89,8 +89,8 @@ static imgsensor_info_struct imgsensor_info = {
     },
     .normal_video = {
         .pclk = 42000000,
-        .linelength = 1120,
-        .framelength = 1246,
+        .linelength = 1680,
+        .framelength = 1250,
         .startx = 0,
         .starty = 0,
         .grabwindow_width = 1600,
@@ -99,32 +99,31 @@ static imgsensor_info_struct imgsensor_info = {
         .max_framerate = 300,
     },
     .hs_video = {
-        .pclk = 42000000,                //record different mode's pclk
-        .linelength = 1120,                //record different mode's linelength
-        .framelength = 1246,            //record different mode's framelength
-        .startx = 0,                    //record different mode's startx of grabwindow
-        .starty = 0,                    //record different mode's starty of grabwindow
-        .grabwindow_width = 1600,        //record different mode's width of grabwindow
-        .grabwindow_height = 1200,        //record different mode's height of grabwindow
-        /*     following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario    */
+        .pclk = 42000000,
+        .linelength = 1680,
+        .framelength = 1250,
+        .startx = 0,
+        .starty = 0,
+        .grabwindow_width = 1600,
+        .grabwindow_height = 1200,
         .mipi_data_lp2hs_settle_dc = 14,//unit , ns
         /*     following for GetDefaultFramerateByScenario()    */
         .max_framerate = 300,
     },
     .slim_video = {
-        .pclk = 42000000,
-        .linelength = 1120,
-        .framelength = 1246,
+         .pclk = 42000000,
+        .linelength = 1680,
+        .framelength = 1250,
         .startx = 0,
         .starty = 0,
-        .grabwindow_width = 1280,
-        .grabwindow_height = 720,
+        .grabwindow_width = 1600,
+        .grabwindow_height = 1200,
         .mipi_data_lp2hs_settle_dc = 14,//unit , ns
         .max_framerate = 300,
     },
     .margin = 0,            //sensor framelength & shutter margin
-    .min_shutter = 12,        //min shutter
-    .max_frame_length = 0x7fff,//max framelength by sensor register's limitation
+    .min_shutter = 7,        //min shutter
+    .max_frame_length = 0x3fff,//max framelength by sensor register's limitation
     .ae_shut_delay_frame = 0,    //shutter delay frame for AE cycle, 2 frame with ispGain_delay-shut_delay=2-0=2
     .ae_sensor_gain_delay_frame = 0,//sensor gain delay frame for AE cycle,2 frame with ispGain_delay-sensor_gain_delay=2-0=2
     .ae_ispGain_delay_frame = 2,//isp gain delay frame for AE cycle
@@ -142,15 +141,27 @@ static imgsensor_info_struct imgsensor_info = {
     .sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,//sensor_interface_type
     .mipi_sensor_type = MIPI_OPHY_NCSI2, //0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2
     .mipi_settle_delay_mode = MIPI_SETTLEDELAY_AUTO,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
-    .sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_R,//sensor output first pixel color
+#ifdef VANZO_IMGSENSOR_GC2355_ROTATION	
+    .sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_B,//sensor output first pixel color
+#else
+	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_R,
+#endif
     .mclk = 24,//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
+  #if defined (GC2355MIPI_2Lane)
     .mipi_lane_num = SENSOR_MIPI_2_LANE,//mipi lane num
+  #else
+      .mipi_lane_num = SENSOR_MIPI_1_LANE,//mipi lane num
+  #endif
     .i2c_addr_table = {0x78, 0xff},//record sensor support all write id addr, only supprt 4must end with 0xff
 };
 
 
 static imgsensor_struct imgsensor = {
-    .mirror = IMAGE_NORMAL,                //mirrorflip information
+#ifdef VANZO_IMGSENSOR_GC2355_ROTATION
+    .mirror = IMAGE_HV_MIRROR,                //mirrorflip information
+#else
+    .mirror = IMAGE_NORMAL,
+#endif
     .sensor_mode = IMGSENSOR_MODE_INIT, //IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
     .shutter = 0x3D0,                    //current shutter
     .gain = 0x100,                        //current gain
@@ -172,7 +183,7 @@ static SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[5] =
 	{ 1600, 1200,	 0,    0, 1600, 1200, 1600,  1200, 0000, 0000, 1600,  1200, 	 0,    0, 1600,  1200}, // capture
 	{ 1600, 1200,	 0,    0, 1600, 1200, 1600,  1200, 0000, 0000, 1600,  1200, 	 0,    0, 1600,  1200}, // video
 	{ 1600, 1200,	 0,    0, 1600, 1200, 1600,  1200, 0000, 0000, 1600,  1200, 	 0,    0, 1600,  1200}, //hight speed video
-	{ 1600, 1200,	 0,    0, 1600, 1200, 1600,  1200, 0000, 0000, 1600,  1200, 	 0,    0, 1280,  720}};// slim video
+	{ 1600, 1200,	 0,    0, 1600, 1200, 1600,  1200, 0000, 0000, 1600,  1200, 	 0,    0, 1600,  1200}};// slim video
 
 
 
@@ -200,6 +211,7 @@ static void write_cmos_sensor(kal_uint32 addr, kal_uint32 para)
 
 static void set_dummy(void)
 {
+#if 0
  	kal_uint32 hb = 0;
 	kal_uint32 vb = 0;
 	LOG_INF("dummyline = %d, dummypixels = %d \n", imgsensor.dummy_line, imgsensor.dummy_pixel);
@@ -217,6 +229,7 @@ static void set_dummy(void)
 	write_cmos_sensor(0x08, vb & 0xFF);
     mdelay(50);
 //  end
+#endif
 }    /*    set_dummy  */
 
 static kal_uint32 return_sensor_id(void)
@@ -296,7 +309,7 @@ static void set_shutter(kal_uint16 shutter)
 
 	// Update Shutter
 	if(shutter > 16383) shutter = 16383;
-	if(shutter < 12) shutter = 12;
+	if(shutter < 7) shutter = 7;
 	write_cmos_sensor(0x03, (shutter>>8) & 0x3F);
 	write_cmos_sensor(0x04, shutter & 0xFF);
 
@@ -305,7 +318,7 @@ static void set_shutter(kal_uint16 shutter)
 }    /*    set_shutter */
 
 
-#if 0
+
 static kal_uint16 gain2reg(const kal_uint16 gain)
 {
     kal_uint16 reg_gain = 0x0000;
@@ -314,7 +327,7 @@ static kal_uint16 gain2reg(const kal_uint16 gain)
     reg_gain = reg_gain & 0xFFFF;
     return (kal_uint16)reg_gain;
 }
-#endif
+
 /*************************************************************************
 * FUNCTION
 *    set_gain
@@ -343,8 +356,6 @@ static kal_uint16 set_gain(kal_uint16 gain)
 
 	kal_uint16 iReg,temp;
 
-	write_cmos_sensor(0xb1, 0x01);
-	write_cmos_sensor(0xb2, 0x00);
 
 	iReg = gain;
 
@@ -436,8 +447,6 @@ static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gai
 
 }
 
-
-#if 0
 static void set_mirror_flip(kal_uint8 image_mirror)
 {
 	LOG_INF("image_mirror = %d\n", image_mirror);
@@ -468,7 +477,6 @@ static void set_mirror_flip(kal_uint8 image_mirror)
 
 
 }
-#endif
 /*************************************************************************
 * FUNCTION
 *    night_mode
@@ -494,30 +502,38 @@ static void sensor_init(void)
 {
 	LOG_INF("E");
 	/* SYS */
+/////////////////////////////////////////////////////
+	//////////////////////	 SYS   //////////////////////
+	/////////////////////////////////////////////////////
 	write_cmos_sensor(0xfe,0x80);
 	write_cmos_sensor(0xfe,0x80);
 	write_cmos_sensor(0xfe,0x80);
-	write_cmos_sensor(0xf2,0x00); //sync_pad_io_ebi
-	write_cmos_sensor(0xf6,0x00); //up down
-	write_cmos_sensor(0xf7,0x31); //19 //pll enable
-	write_cmos_sensor(0xf8,0x06); //Pll mode 2  /////86--
-	write_cmos_sensor(0xf9,0x0e); //de//[0] pll enable
-	write_cmos_sensor(0xfa,0x00); //div
-	write_cmos_sensor(0xfc,0x06); //4e
-	//write_cmos_sensor(0xfd,0x00);
+	write_cmos_sensor(0xf2,0x00); 
+	write_cmos_sensor(0xf6,0x00); 
+#if defined(GC2355MIPI_2Lane)
+	write_cmos_sensor(0xf7,0x31); 
+#else
+	write_cmos_sensor(0xf7,0x19); 
+#endif
+	write_cmos_sensor(0xf8,0x06); 
+	write_cmos_sensor(0xf9,0x0e); 
+	write_cmos_sensor(0xfa,0x00); 
+	write_cmos_sensor(0xfc,0x06); 
 	write_cmos_sensor(0xfe,0x00);
-
-	/* ANALOG & CISCTL*/
-	write_cmos_sensor(0x03,0x0b);
-	write_cmos_sensor(0x04,0xb8);
-	write_cmos_sensor(0x05,0x01); //max 30fps  03
-	write_cmos_sensor(0x06,0x22);
+	
+	/////////////////////////////////////////////////////
+	///////////////    ANALOG & CISCTL    ///////////////
+	/////////////////////////////////////////////////////
+	write_cmos_sensor(0x03,0x07); 
+	write_cmos_sensor(0x04,0xd0); 
+	write_cmos_sensor(0x05,0x03);
+	write_cmos_sensor(0x06,0x4c);
 	write_cmos_sensor(0x07,0x00);
-	write_cmos_sensor(0x08,0x14); //22
-	write_cmos_sensor(0x0a,0x00); //row start
-	write_cmos_sensor(0x0c,0x04); //0c//col start
+	write_cmos_sensor(0x08,0x12);
+	write_cmos_sensor(0x0a,0x00);
+	write_cmos_sensor(0x0c,0x04);
 	write_cmos_sensor(0x0d,0x04);
-	write_cmos_sensor(0x0e,0xc0); //c0
+	write_cmos_sensor(0x0e,0xc0);
 	write_cmos_sensor(0x0f,0x06);
 	write_cmos_sensor(0x10,0x50); //Window setting 1616x1216
 	/*write_cmos_sensor(0x11,0x00);
@@ -526,30 +542,27 @@ static void sensor_init(void)
 	write_cmos_sensor(0x14,0x01);
 	write_cmos_sensor(0x15,0x00);
 	write_cmos_sensor(0x16,0xc1);*/
-	write_cmos_sensor(0x17,0x14);//14
+	write_cmos_sensor(0x17,0x17);
 	//write_cmos_sensor(0x18,0x02);
 	write_cmos_sensor(0x19,0x0b);
-	write_cmos_sensor(0x1b,0x49); //48
+	write_cmos_sensor(0x1b,0x48);
 	write_cmos_sensor(0x1c,0x12);
-	write_cmos_sensor(0x1d,0x10); //double reset
-	write_cmos_sensor(0x1e,0xbc); //a8//col_r/rowclk_mode/rsthigh_en FPN
-	write_cmos_sensor(0x1f,0xc8); //c8//rsgl_s_mode/vpix_s_mode 
+	write_cmos_sensor(0x1d,0x10);
+	write_cmos_sensor(0x1e,0xbc);
+	write_cmos_sensor(0x1f,0xc9);
 	write_cmos_sensor(0x20,0x71);
-	write_cmos_sensor(0x21,0x20); //rsg    //////40
+	write_cmos_sensor(0x21,0x20); //rsg ??   //////40
 	write_cmos_sensor(0x22,0xa0); //e0   //80  //f0
 	write_cmos_sensor(0x23,0x51); //51
 	write_cmos_sensor(0x24,0x19); //0b //55
 	//write_cmos_sensor(0x25,0x10);  //10
 	//write_cmos_sensor(0x26,0x00);
 	write_cmos_sensor(0x27,0x20);
-	write_cmos_sensor(0x28,0x00);//10
-	//write_cmos_sensor(0x29,0x00);
-	//write_cmos_sensor(0x2a,0x00);
-	write_cmos_sensor(0x2b,0x81); //00 sf_s_mode FPN
-	write_cmos_sensor(0x2c,0x38); //50 //5c ispg FPN
-	//write_cmos_sensor(0x2d,0x15);
-	write_cmos_sensor(0x2e,0x16); //05//eq width
-	write_cmos_sensor(0x2f,0x14); //[3:0]tx_width 0
+	write_cmos_sensor(0x28,0x00);
+	write_cmos_sensor(0x2b,0x80);// 0x81 20140926
+	write_cmos_sensor(0x2c,0x38);
+	write_cmos_sensor(0x2e,0x16);
+	write_cmos_sensor(0x2f,0x14);
 	write_cmos_sensor(0x30,0x00);
 	write_cmos_sensor(0x31,0x01);
 	write_cmos_sensor(0x32,0x02);
@@ -557,8 +570,42 @@ static void sensor_init(void)
 	write_cmos_sensor(0x34,0x07);
 	write_cmos_sensor(0x35,0x0b);
 	write_cmos_sensor(0x36,0x0f);
-
+	write_cmos_sensor(0xfe, 0x03);
+#if defined(GC2355MIPI_2Lane)
+	write_cmos_sensor(0x01, 0x87);
+	write_cmos_sensor(0x22, 0x03);  
+	write_cmos_sensor(0x23, 0x20);
+	write_cmos_sensor(0x25, 0x10);
+	write_cmos_sensor(0x29, 0x02);
+#else
+	write_cmos_sensor(0x01, 0x83);
+	write_cmos_sensor(0x22, 0x05);  
+	write_cmos_sensor(0x23, 0x30);
+	write_cmos_sensor(0x25, 0x15);
+	write_cmos_sensor(0x29, 0x06);
+#endif
+	write_cmos_sensor(0x02, 0x11); // 00 20150522
+	write_cmos_sensor(0x03, 0x91); // 90 tarvis 20150611
+	write_cmos_sensor(0x04, 0x01);
+	write_cmos_sensor(0x05, 0x00);
+	write_cmos_sensor(0x06, 0xa2);
+	write_cmos_sensor(0x11, 0x2b);
+	write_cmos_sensor(0x12, 0xd0); 
+	write_cmos_sensor(0x13, 0x07); 
+	write_cmos_sensor(0x15, 0x60);
+
+	write_cmos_sensor(0x21, 0x10);
+	write_cmos_sensor(0x24, 0x02);
+	write_cmos_sensor(0x26, 0x08);
+	write_cmos_sensor(0x27, 0x06);
+	write_cmos_sensor(0x2a, 0x0a); 
+	write_cmos_sensor(0x2b, 0x08);
 	/* gain */
+	write_cmos_sensor(0x40, 0x00);
+	write_cmos_sensor(0x41, 0x00);    
+	write_cmos_sensor(0x42, 0x40);
+	write_cmos_sensor(0x43, 0x06);  
+	write_cmos_sensor(0xfe, 0x00);
 	write_cmos_sensor(0xb0,0x50);
 	write_cmos_sensor(0xb1,0x01);
 	write_cmos_sensor(0xb2,0x00);
@@ -569,124 +616,76 @@ static void sensor_init(void)
 
 	/* crop */
 	write_cmos_sensor(0x92,0x02);
+	write_cmos_sensor(0x94,0x00);
 	write_cmos_sensor(0x95,0x04);
 	write_cmos_sensor(0x96,0xb0);
 	write_cmos_sensor(0x97,0x06);
 	write_cmos_sensor(0x98,0x40); //out window set 1600x1200
 
-	/*	BLK	 */
-	write_cmos_sensor(0x18,0x02);//1a-lily
-	write_cmos_sensor(0x1a,0x01);//09-lily //01
-	write_cmos_sensor(0x40,0x42);//43-lily
-	write_cmos_sensor(0x4e,0x3c); //BLK select
-	write_cmos_sensor(0x4f,0x00);
-	write_cmos_sensor(0x5e,0x00);//18-lily //offset ratio
-	write_cmos_sensor(0x66,0x20);//20-lily //dark ratio
-	write_cmos_sensor(0x6a,0x00);//39
-	write_cmos_sensor(0x6b,0x00);
-	write_cmos_sensor(0x6c,0x00);
-	write_cmos_sensor(0x6d,0x00);
-	write_cmos_sensor(0x6e,0x00);
-	write_cmos_sensor(0x6f,0x00);
-	write_cmos_sensor(0x70,0x00);
-	write_cmos_sensor(0x71,0x00); //manual offset
-
-	/* Dark sun */
-	write_cmos_sensor(0x87,0x03); //
-	write_cmos_sensor(0xe0,0xe7); //dark sun en/extend mode
-	write_cmos_sensor(0xe2,0x03);
-	write_cmos_sensor(0xe3,0xc0); //clamp
+	/////////////////////////////////////////////////////
+	//////////////////////    BLK   /////////////////////
+	/////////////////////////////////////////////////////
+	write_cmos_sensor(0x18,0x02);
+	write_cmos_sensor(0x1a,0x01);
+	write_cmos_sensor(0x40,0x42);
+	write_cmos_sensor(0x41,0x00); 
+	write_cmos_sensor(0x44,0x00); 
+	write_cmos_sensor(0x45,0x00);
+	write_cmos_sensor(0x46,0x00);	
+	write_cmos_sensor(0x47,0x00); 
+	write_cmos_sensor(0x48,0x00); 
+	write_cmos_sensor(0x49,0x00);
+	write_cmos_sensor(0x4a,0x00);	
+	write_cmos_sensor(0x4b,0x00);	
+	write_cmos_sensor(0x4e,0x3c); 
+	write_cmos_sensor(0x4f,0x00); 
+	write_cmos_sensor(0x5e,0x00);
+	write_cmos_sensor(0x66,0x20);
+	write_cmos_sensor(0x6a,0x02);
+	write_cmos_sensor(0x6b,0x02);
+	write_cmos_sensor(0x6c,0x02);
+	write_cmos_sensor(0x6d,0x02);
+	write_cmos_sensor(0x6e,0x02);
+	write_cmos_sensor(0x6f,0x02);
+	write_cmos_sensor(0x70,0x02);
+	write_cmos_sensor(0x71,0x02);
+
+	/////////////////////////////////////////////////////
+	////////////////////  dark sun  /////////////////////
+	/////////////////////////////////////////////////////
+	write_cmos_sensor(0x87,0x03); 
+	write_cmos_sensor(0xe0,0xe7); 
+	write_cmos_sensor(0xe3,0xc0); 
 
 	/*MIPI*/
 	  write_cmos_sensor(0xfe, 0x03);
+#if defined(GC2355MIPI_2Lane)
 	  write_cmos_sensor(0x10, 0x81);
-	  write_cmos_sensor(0x01, 0x87);
-	  write_cmos_sensor(0x02, 0x11);
-	  write_cmos_sensor(0x03, 0x91);
-	  write_cmos_sensor(0x04, 0x01);
-	  write_cmos_sensor(0x05, 0x00);
-	  write_cmos_sensor(0x06, 0xa2);
-
-	  write_cmos_sensor(0x11, 0x2b);//2b
-	  write_cmos_sensor(0x15, 0x60);
-	  write_cmos_sensor(0x12, 0xd0); //d0//40
-	  write_cmos_sensor(0x13, 0x07); //07//06
-	  write_cmos_sensor(0x21, 0x10);
-	  write_cmos_sensor(0x22, 0x03);
-	  write_cmos_sensor(0x23, 0x20);
-	  write_cmos_sensor(0x24, 0x02);
-	  write_cmos_sensor(0x25, 0x10);
-	  write_cmos_sensor(0x26, 0x08);
+#else
 	//  write_cmos_sensor(0x27, 0x06);
-	  write_cmos_sensor(0x29, 0x02);//04
-	  write_cmos_sensor(0x2a, 0x0a);
-	  write_cmos_sensor(0x2b, 0x08);
-	  write_cmos_sensor(0x10, 0x81);//91//94//1lane raw8
-	  write_cmos_sensor(0x40, 0x00);
-	  write_cmos_sensor(0x41, 0x00);
-	  write_cmos_sensor(0x42, 0x40);
-	  write_cmos_sensor(0x43, 0x06);
+	write_cmos_sensor(0x10, 0x80);
+#endif
 	  write_cmos_sensor(0xfe, 0x00);
 
 }    /*    sensor_init  */
 
 
-static void preview_setting(kal_uint16 currefps)
+static void preview_setting(void)
 {
-  kal_uint32 frame_length;
-  kal_uint32 hb = 0;
-  kal_uint32 vb = 0;
-
-  LOG_INF("E! currefps:%d\n",currefps);
-  if(currefps != 0)
-  {
-      frame_length = imgsensor_info.pre.pclk / imgsensor.current_fps * 10 / imgsensor_info.pre.linelength;
-      imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
-      imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
-      imgsensor.min_frame_length = imgsensor.frame_length;
-  }
-  else
-  {
-      imgsensor.dummy_pixel = 0;
-      imgsensor.dummy_line = 0;
-  }
-  hb = imgsensor.dummy_pixel + GC2355_DEFAULT_DUMMY_PIXEL_NUMS;
-  vb = imgsensor.dummy_line + GC2355_DEFAULT_DUMMY_LINE_NUMS;
-  LOG_INF("dummyline = %d(%d), dummypixels = %d(%d) \n", imgsensor.dummy_line,vb, imgsensor.dummy_pixel,hb);
+
+	LOG_INF("E!\n");
  // AEC&frame length//
-  write_cmos_sensor(0x03,0x0a);
-  write_cmos_sensor(0x04,0x41);
   //Set HB
-  write_cmos_sensor(0x05, (hb >> 8)& 0xFF);
-  write_cmos_sensor(0x06, hb & 0xFF);
   //Set VB
-  write_cmos_sensor(0x07, (vb >> 8) & 0xFF);
-  write_cmos_sensor(0x08, vb & 0xFF);
-
-  write_cmos_sensor(0x09,0x00);
-  write_cmos_sensor(0x0a,0x00);
-  write_cmos_sensor(0x0b,0x00);
-  write_cmos_sensor(0x0c,0x04);
-  write_cmos_sensor(0x0d,0x04);
-  write_cmos_sensor(0x0e,0xc0);
-  write_cmos_sensor(0x0f,0x06);
-  write_cmos_sensor(0x10,0x50);
-  write_cmos_sensor(0x92,0x02);
-  write_cmos_sensor(0x95,0x04);
-  write_cmos_sensor(0x96,0xb0);
-  write_cmos_sensor(0x97,0x06);
-  write_cmos_sensor(0x98,0x40);
-  write_cmos_sensor(0xb0,0x50);
-  write_cmos_sensor(0xb1,0x01);
-  write_cmos_sensor(0xb2,0x00);
-  write_cmos_sensor(0xb6,0x00);
+
 
   //MIPI//
   write_cmos_sensor(0xfe,0x03);
-  //write_cmos_sensor(0x10,0x81); /*Stream off*/
-  write_cmos_sensor(0x12,0xd0); //d0//40
-  write_cmos_sensor(0x13,0x07);
+ #if defined(GC2355MIPI_2Lane)
   write_cmos_sensor(0x10,0x91); /*Stream on*/
+#else
+	write_cmos_sensor(0x10, 0x90);
+#endif
   write_cmos_sensor(0xfe,0x00);
 
 }    /*    preview_setting  */
@@ -697,35 +696,14 @@ static void capture_setting(kal_uint16 currefps)
     ///30fps for Normal capture & ZSD
     // max 30fps//
     // AEC&frame length//
-    write_cmos_sensor(0x03,0x0a);
-    write_cmos_sensor(0x04,0x41);
-    write_cmos_sensor(0x05,0x01); //max 30fps  03
-    write_cmos_sensor(0x06,0x1c);
-    write_cmos_sensor(0x07,0x00);
-    write_cmos_sensor(0x08,0x0e); //22
-
-    write_cmos_sensor(0x09,0x00);
-    write_cmos_sensor(0x0a,0x00);
-    write_cmos_sensor(0x0b,0x00);
-    write_cmos_sensor(0x0c,0x04);
-    write_cmos_sensor(0x0d,0x04);
-    write_cmos_sensor(0x0e,0xc0);
-    write_cmos_sensor(0x0f,0x06);
-    write_cmos_sensor(0x10,0x50);
-    write_cmos_sensor(0x92,0x02);
-    write_cmos_sensor(0x95,0x04);
-    write_cmos_sensor(0x96,0xb0);
-    write_cmos_sensor(0x97,0x06);
-    write_cmos_sensor(0x98,0x40);
-    write_cmos_sensor(0xb0,0x50);
-    write_cmos_sensor(0xb1,0x01);
-    write_cmos_sensor(0xb2,0x00);
-    write_cmos_sensor(0xb6,0x00);
+
     //MIPI//
     write_cmos_sensor(0xfe,0x03);
-    write_cmos_sensor(0x12,0xd0); //d0//40
-    write_cmos_sensor(0x13,0x07);
+ #if defined(GC2355MIPI_2Lane)
     write_cmos_sensor(0x10,0x91);
+#else
+	write_cmos_sensor(0x10, 0x90);
+#endif
     write_cmos_sensor(0xfe,0x00);
 
 
@@ -734,120 +712,42 @@ static void capture_setting(kal_uint16 currefps)
 
 static void normal_video_setting(kal_uint16 currefps)
 {
-    kal_uint32 frame_length;
-    kal_uint32 hb = 0;
-    kal_uint32 vb = 0;
     LOG_INF("E! currefps:%d\n",currefps);
-    if(currefps != 0)
-    {
-        frame_length = imgsensor_info.normal_video.pclk / imgsensor.current_fps * 10 / imgsensor_info.normal_video.linelength;
-        imgsensor.dummy_line = (frame_length > imgsensor_info.normal_video.framelength) ? (frame_length - imgsensor_info.normal_video.framelength) : 0;
-        imgsensor.frame_length = imgsensor_info.normal_video.framelength + imgsensor.dummy_line;
-        imgsensor.min_frame_length = imgsensor.frame_length;
 
-    }
-    else
-    {
-        imgsensor.dummy_pixel = 0;
-        imgsensor.dummy_line = 0;
-    }
-    hb = imgsensor.dummy_pixel + GC2355_DEFAULT_DUMMY_PIXEL_NUMS;
-    vb = imgsensor.dummy_line + GC2355_DEFAULT_DUMMY_LINE_NUMS;
-    LOG_INF("dummyline = %d(%d), dummypixels = %d(%d) \n", imgsensor.dummy_line,vb, imgsensor.dummy_pixel,hb);
 
     // AEC&frame length//
-    write_cmos_sensor(0x03,0x0a);
-    write_cmos_sensor(0x04,0x41);
     //Set HB
-    write_cmos_sensor(0x05, (hb >> 8)& 0xFF);
-    write_cmos_sensor(0x06, hb & 0xFF);
     //Set VB
-    write_cmos_sensor(0x07, (vb >> 8) & 0xFF);
-    write_cmos_sensor(0x08, vb & 0xFF);
 
 
-	write_cmos_sensor(0x09,0x00);
-	write_cmos_sensor(0x0a,0x00);
-	write_cmos_sensor(0x0b,0x00);
-	write_cmos_sensor(0x0c,0x04);
-	write_cmos_sensor(0x0d,0x04);
-	write_cmos_sensor(0x0e,0xc0);
-	write_cmos_sensor(0x0f,0x06);
-	write_cmos_sensor(0x10,0x50);
-	write_cmos_sensor(0x92,0x02);
-	write_cmos_sensor(0x95,0x04);
-	write_cmos_sensor(0x96,0xb0);
-	write_cmos_sensor(0x97,0x06);
-	write_cmos_sensor(0x98,0x40);
-	write_cmos_sensor(0xb0,0x50);
-	write_cmos_sensor(0xb1,0x01);
-	write_cmos_sensor(0xb2,0x00);
-	write_cmos_sensor(0xb6,0x00);
 	 //MIPI//
 	 write_cmos_sensor(0xfe,0x03);
-	 write_cmos_sensor(0x12,0xd0); //d0//40
-	 write_cmos_sensor(0x13,0x07);
+ #if defined(GC2355MIPI_2Lane)
 	 write_cmos_sensor(0x10,0x91);
+#else
+	write_cmos_sensor(0x10, 0x90);
+#endif
 	 write_cmos_sensor(0xfe,0x00);
 
 }
 
-static void hs_video_setting(kal_uint16 currefps)
+static void hs_video_setting()
 {
-kal_uint32 frame_length;
- kal_uint32 hb = 0;
- kal_uint32 vb = 0;
-
- LOG_INF("E! currefps:%d\n",currefps);
- if(currefps != 0)
- {
-	 frame_length = imgsensor_info.pre.pclk / imgsensor.current_fps * 10 / imgsensor_info.pre.linelength;
-	 imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
-	 imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
-	 imgsensor.min_frame_length = imgsensor.frame_length;
- }
- else
- {
-	 imgsensor.dummy_pixel = 0;
-	 imgsensor.dummy_line = 0;
- }
- hb = imgsensor.dummy_pixel + GC2355_DEFAULT_DUMMY_PIXEL_NUMS;
- vb = imgsensor.dummy_line + GC2355_DEFAULT_DUMMY_LINE_NUMS;
- LOG_INF("dummyline = %d(%d), dummypixels = %d(%d) \n", imgsensor.dummy_line,vb, imgsensor.dummy_pixel,hb);
+
+    LOG_INF("E\n");
+	
 // AEC&frame length//
- write_cmos_sensor(0x03,0x0a);
- write_cmos_sensor(0x04,0x41);
  //Set HB
- write_cmos_sensor(0x05, (hb >> 8)& 0xFF);
- write_cmos_sensor(0x06, hb & 0xFF);
  //Set VB
- write_cmos_sensor(0x07, (vb >> 8) & 0xFF);
- write_cmos_sensor(0x08, vb & 0xFF);
-
- write_cmos_sensor(0x09,0x00);
- write_cmos_sensor(0x0a,0x00);
- write_cmos_sensor(0x0b,0x00);
- write_cmos_sensor(0x0c,0x04);
- write_cmos_sensor(0x0d,0x04);
- write_cmos_sensor(0x0e,0xc0);
- write_cmos_sensor(0x0f,0x06);
- write_cmos_sensor(0x10,0x50);
- write_cmos_sensor(0x92,0x02);
- write_cmos_sensor(0x95,0x04);
- write_cmos_sensor(0x96,0xb0);
- write_cmos_sensor(0x97,0x06);
- write_cmos_sensor(0x98,0x40);
- write_cmos_sensor(0xb0,0x50);
- write_cmos_sensor(0xb1,0x01);
- write_cmos_sensor(0xb2,0x00);
- write_cmos_sensor(0xb6,0x00);
+
 
  //MIPI//
  write_cmos_sensor(0xfe,0x03);
- //write_cmos_sensor(0x10,0x81); /*Stream off*/
- write_cmos_sensor(0x12,0xd0); //d0//40
- write_cmos_sensor(0x13,0x07);
+ #if defined(GC2355MIPI_2Lane)
  write_cmos_sensor(0x10,0x91); /*Stream on*/
+#else
+	write_cmos_sensor(0x10, 0x90);
+#endif
  write_cmos_sensor(0xfe,0x00);
 
 }
@@ -857,34 +757,13 @@ static void slim_video_setting()
     LOG_INF("E\n");
      // use preview setting
      // AEC&frame length//
-     write_cmos_sensor(0x03,0x0a);
-     write_cmos_sensor(0x04,0x41);
-     write_cmos_sensor(0x05,0x01); //max 30fps 03
-     write_cmos_sensor(0x06,0x1c);
-     write_cmos_sensor(0x07,0x00);
-     write_cmos_sensor(0x08,0x0e); //22
-     write_cmos_sensor(0x09,0x00);
-     write_cmos_sensor(0x0a,0x00);
-     write_cmos_sensor(0x0b,0x00);
-     write_cmos_sensor(0x0c,0x04);
-     write_cmos_sensor(0x0d,0x04);
-     write_cmos_sensor(0x0e,0xc0);
-     write_cmos_sensor(0x0f,0x06);
-     write_cmos_sensor(0x10,0x50);
-     write_cmos_sensor(0x92,0x02);
-     write_cmos_sensor(0x95,0x04);
-     write_cmos_sensor(0x96,0xb0);
-     write_cmos_sensor(0x97,0x06);
-     write_cmos_sensor(0x98,0x40);
-     write_cmos_sensor(0xb0,0x50);
-     write_cmos_sensor(0xb1,0x01);
-     write_cmos_sensor(0xb2,0x00);
-     write_cmos_sensor(0xb6,0x00);
      //MIPI//
      write_cmos_sensor(0xfe,0x03);
-     write_cmos_sensor(0x12,0xd0); //d0//40
-     write_cmos_sensor(0x13,0x07);
+ #if defined(GC2355MIPI_2Lane)
      write_cmos_sensor(0x10,0x91);
+#else
+	write_cmos_sensor(0x10, 0x90);
+#endif
      write_cmos_sensor(0xfe,0x00);
 
 }
@@ -1079,8 +958,8 @@ static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
     imgsensor.min_frame_length = imgsensor_info.pre.framelength;
     imgsensor.autoflicker_en = KAL_FALSE;
     spin_unlock(&imgsensor_drv_lock);
-    preview_setting(imgsensor.current_fps);
-	//set_mirror_flip(sensor_config_data->SensorImageMirror);
+    preview_setting();
+	set_mirror_flip(imgsensor.mirror);
     return ERROR_NONE;
 }    /*    preview   */
 
@@ -1123,7 +1002,7 @@ static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
     }
     spin_unlock(&imgsensor_drv_lock);
     capture_setting(imgsensor.current_fps);
-	//set_mirror_flip(sensor_config_data->SensorImageMirror);
+	set_mirror_flip(imgsensor.mirror);
     return ERROR_NONE;
 }    /* capture() */
 static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
@@ -1141,7 +1020,7 @@ static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
     imgsensor.autoflicker_en = KAL_FALSE;
     spin_unlock(&imgsensor_drv_lock);
     normal_video_setting(imgsensor.current_fps);
-	//set_mirror_flip(sensor_config_data->SensorImageMirror);
+	set_mirror_flip(imgsensor.mirror);
     return ERROR_NONE;
 }    /*    normal_video   */
 
@@ -1161,8 +1040,8 @@ static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
     imgsensor.dummy_pixel = 0;
     imgsensor.autoflicker_en = KAL_FALSE;
     spin_unlock(&imgsensor_drv_lock);
-    hs_video_setting(imgsensor.current_fps);
-	//set_mirror_flip(sensor_config_data->SensorImageMirror);
+    hs_video_setting();
+	set_mirror_flip(imgsensor.mirror);
     return ERROR_NONE;
 }    /*    hs_video   */
 
@@ -1182,7 +1061,7 @@ static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
     imgsensor.autoflicker_en = KAL_FALSE;
     spin_unlock(&imgsensor_drv_lock);
     slim_video_setting();
-	//set_mirror_flip(sensor_config_data->SensorImageMirror);
+	set_mirror_flip(imgsensor.mirror);
 
     return ERROR_NONE;
 }    /*    slim_video     */
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2355_mipi_raw/gc2355mipi_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2355_mipi_raw/gc2355mipi_Sensor.h
index 6aa230f..4d3430a 100644
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2355_mipi_raw/gc2355mipi_Sensor.h
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2355_mipi_raw/gc2355mipi_Sensor.h
@@ -125,13 +125,13 @@ typedef struct imgsensor_info_struct {
 #define GC2355_INTERNAL_DUMMY_PIXEL_NUMS  36
 #define GC2355_INTERNAL_DUMMY_LINE_NUMS   32
 
-#define GC2355_VIDEO_PERIOD_PIXEL_NUMS          (1120)
-#define GC2355_VIDEO_PERIOD_LINE_NUMS           (1246)
-#define GC2355_PV_PERIOD_PIXEL_NUMS            (1120)
-#define GC2355_PV_PERIOD_LINE_NUMS             (1246)
+#define GC2355_VIDEO_PERIOD_PIXEL_NUMS          (1680)
+#define GC2355_VIDEO_PERIOD_LINE_NUMS           (1250)
+#define GC2355_PV_PERIOD_PIXEL_NUMS            (1680)
+#define GC2355_PV_PERIOD_LINE_NUMS             (1250)
 
-#define GC2355_FULL_PERIOD_PIXEL_NUMS          (1120)
-#define GC2355_FULL_PERIOD_LINE_NUMS           (1246)
+#define GC2355_FULL_PERIOD_PIXEL_NUMS          (1680)
+#define GC2355_FULL_PERIOD_LINE_NUMS           (1250)
 
 
 // end
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2755_mipi_raw/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2755_mipi_raw/Makefile
old mode 100644
new mode 100755
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2755_mipi_raw/gc2755mipi_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2755_mipi_raw/gc2755mipi_Sensor.c
old mode 100644
new mode 100755
index 3758567..66ac052
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2755_mipi_raw/gc2755mipi_Sensor.c
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2755_mipi_raw/gc2755mipi_Sensor.c
@@ -50,7 +50,7 @@ kal_bool GC2755DuringTestPattern = KAL_FALSE;
 static imgsensor_info_struct imgsensor_info = {
     .sensor_id = GC2755_SENSOR_ID,        //record sensor id defined in Kd_imgsensor.h
 
-    .checksum_value = 0x10f3ca1e,        //checksum value for Camera Auto Test
+    .checksum_value = 0xf7375923,        //checksum value for Camera Auto Test
 
     .pre = {
         .pclk = 42000000,                //record different mode's pclk
@@ -88,25 +88,25 @@ static imgsensor_info_struct imgsensor_info = {
         .max_framerate = 100,
     },
     .normal_video = {
-          .pclk = 42000000,
+        .pclk = 42000000,
         .linelength = 1772,
         .framelength = 1185,
         .startx = 0,
         .starty = 0,
         .grabwindow_width = 1920,
         .grabwindow_height = 1080,
-        .mipi_data_lp2hs_settle_dc = 14,
+        .mipi_data_lp2hs_settle_dc = 14,//unit , ns
         .max_framerate = 100,
     },
     .hs_video = {
-          .pclk = 42000000,
+        .pclk = 42000000,
         .linelength = 1772,
         .framelength = 1185,
         .startx = 0,
         .starty = 0,
         .grabwindow_width = 1920,
         .grabwindow_height = 1080,
-        .mipi_data_lp2hs_settle_dc = 14,
+        .mipi_data_lp2hs_settle_dc = 14,//unit , ns
         .max_framerate = 100,
     },
     .slim_video = {
@@ -117,7 +117,7 @@ static imgsensor_info_struct imgsensor_info = {
         .starty = 0,
         .grabwindow_width = 1920,
         .grabwindow_height = 1080,
-        .mipi_data_lp2hs_settle_dc = 14,
+        .mipi_data_lp2hs_settle_dc = 14,//unit , ns
         .max_framerate = 100,
     },
     .margin = 0,            //sensor framelength & shutter margin
@@ -140,7 +140,11 @@ static imgsensor_info_struct imgsensor_info = {
     .sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,//sensor_interface_type
     .mipi_sensor_type = MIPI_OPHY_NCSI2, //0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2
     .mipi_settle_delay_mode = MIPI_SETTLEDELAY_AUTO,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
+#ifdef VANZO_IMGSENSOR_GC2755_ROTATION
+    .sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_R,//sensor output first pixel color
+#else
     .sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_B,//sensor output first pixel color
+#endif
     .mclk = 24,//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
     .mipi_lane_num = SENSOR_MIPI_2_LANE,//mipi lane num
     .i2c_addr_table = {0x78, 0xff},//record sensor support all write id addr, only supprt 4must end with 0xff
@@ -148,7 +152,11 @@ static imgsensor_info_struct imgsensor_info = {
 
 
 static imgsensor_struct imgsensor = {
+#ifdef VANZO_IMGSENSOR_GC2755_ROTATION
+    .mirror = IMAGE_HV_MIRROR,                //mirrorflip information
+#else
     .mirror = IMAGE_NORMAL,                //mirrorflip information
+#endif
     .sensor_mode = IMGSENSOR_MODE_INIT, //IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
     .shutter = 0x3ED,                    //current shutter
     .gain = 0x40,                        //current gain
@@ -199,6 +207,13 @@ static void write_cmos_sensor(kal_uint32 addr, kal_uint32 para)
 static void set_dummy()
 {
 
+//  modify by yfx
+
+	
+	//Set HB
+
+	//Set VB
+
 //  end	
 }    /*    set_dummy  */
 
@@ -328,8 +343,6 @@ static kal_uint16 set_gain(kal_uint16 gain)
 			
 	kal_uint16 iReg,temp,temp1; 	
 
-	write_cmos_sensor(0xb1, 0x01);
-	write_cmos_sensor(0xb2, 0x00);
 	
 	iReg = gain;
 	
@@ -369,6 +382,7 @@ static kal_uint16 set_gain(kal_uint16 gain)
 			LOG_INF("GC2755 analogic gain 2.02x , GC2755 add pregain = %d\n",temp); 
 	}
 	
+//	else if(ANALOG_GAIN_4<= iReg)
 	else
 	{
 			//analog gain
@@ -396,31 +410,32 @@ static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gai
 static void set_mirror_flip(kal_uint8 image_mirror)
 {
 	LOG_INF("image_mirror = %d\n", image_mirror);
-	/*
+	
 	switch (image_mirror)
 	{
 		case IMAGE_NORMAL://IMAGE_NORMAL:
-			write_cmos_sensor(0x17,0x14);//bit[1][0]
+			write_cmos_sensor(0x17,0x15);//bit[1][0]
 	//		write_cmos_sensor(0x92,0x03);
 	//		write_cmos_sensor(0x94,0x0b);
 			break;
 		case IMAGE_H_MIRROR://IMAGE_H_MIRROR:
-			write_cmos_sensor(0x17,0x15);
+			write_cmos_sensor(0x17,0x14);
 	//		GC2755_write_cmos_sensor(0x92,0x03);
 	//		GC2755_write_cmos_sensor(0x94,0x0b);
 			break;
 		case IMAGE_V_MIRROR://IMAGE_V_MIRROR:
-			write_cmos_sensor(0x17,0x16);
+			write_cmos_sensor(0x17,0x17);
 	//		GC2755_write_cmos_sensor(0x92,0x02);
 	//		GC2755_write_cmos_sensor(0x94,0x0b);
 			break;
 		case IMAGE_HV_MIRROR://IMAGE_HV_MIRROR:
-			write_cmos_sensor(0x17,0x17);
+			write_cmos_sensor(0x17,0x16);
 	//		GC2755_write_cmos_sensor(0x92,0x02);
 	//		GC2755_write_cmos_sensor(0x94,0x0b);
 			break;
 	}
-    */
+
+
 }
 
 /*************************************************************************
@@ -460,18 +475,17 @@ static void sensor_init(void)
 	write_cmos_sensor(0xf8, 0x06);
 	write_cmos_sensor(0xf9, 0x0e);
 	write_cmos_sensor(0xfa, 0x00);
-
 	write_cmos_sensor(0xfe, 0x00);
 
 	/////////////////////////////////////////////////////
 	////////////////     ANALOG & CISCTL   ////////////////
 	/////////////////////////////////////////////////////
 	write_cmos_sensor(0x03, 0x03);
-	write_cmos_sensor(0x04, 0xed); 
+	write_cmos_sensor(0x04, 0xb4); 
 	write_cmos_sensor(0x05, 0x03);
-	write_cmos_sensor(0x06, 0x12);//HB=786
+	write_cmos_sensor(0x06, 0x12);
 	write_cmos_sensor(0x07, 0x00);
-	write_cmos_sensor(0x08, 0x49);//VB=73
+	write_cmos_sensor(0x08, 0x49);
 	write_cmos_sensor(0x0a, 0x00);
 	write_cmos_sensor(0x0c, 0x04);
 	write_cmos_sensor(0x0d, 0x04);
@@ -484,19 +498,19 @@ static void sensor_init(void)
 	write_cmos_sensor(0x14, 0x01);
 	write_cmos_sensor(0x17, 0x15);
 	write_cmos_sensor(0x19, 0x08);
-	write_cmos_sensor(0x1b, 0x4b);//4f
+	write_cmos_sensor(0x1b, 0x4b);
 	write_cmos_sensor(0x1c, 0x11);
 	write_cmos_sensor(0x1d, 0x10);
 	write_cmos_sensor(0x1e, 0xcc);
 	write_cmos_sensor(0x1f, 0xc9);
-	write_cmos_sensor(0x20, 0x61);//71
+	write_cmos_sensor(0x20, 0x61);
 	write_cmos_sensor(0x21, 0x20);
 	write_cmos_sensor(0x22, 0xd0);
 	write_cmos_sensor(0x23, 0x51);
 	write_cmos_sensor(0x24, 0x19);
 	write_cmos_sensor(0x27, 0x20);
 	write_cmos_sensor(0x28, 0x00);
-	write_cmos_sensor(0x2b, 0x80);//81
+	write_cmos_sensor(0x2b, 0x80);
 	write_cmos_sensor(0x2c, 0x38);
 	write_cmos_sensor(0x2e, 0x1f);
 	write_cmos_sensor(0x2f, 0x14);
@@ -522,8 +536,8 @@ static void sensor_init(void)
 	////////////////////////////////////////////////////
 	/////////////////////   crop   /////////////////////
 	////////////////////////////////////////////////////
-	write_cmos_sensor(0x92, 0x03);
-	write_cmos_sensor(0x94, 0x08);//08
+	write_cmos_sensor(0x92, 0x05);
+	write_cmos_sensor(0x94, 0x08);
 	write_cmos_sensor(0x95, 0x04);
 	write_cmos_sensor(0x96, 0x38);
 	write_cmos_sensor(0x97, 0x07);
@@ -540,32 +554,32 @@ static void sensor_init(void)
 	write_cmos_sensor(0x4f, 0x00);
 	write_cmos_sensor(0x5e, 0x00);
 	write_cmos_sensor(0x66, 0x20);
-	write_cmos_sensor(0x6a, 0x02);
-	write_cmos_sensor(0x6b, 0x02);
-	write_cmos_sensor(0x6c, 0x02);
-	write_cmos_sensor(0x6d, 0x02);
-	write_cmos_sensor(0x6e, 0x02);
-	write_cmos_sensor(0x6f, 0x02);
-	write_cmos_sensor(0x70, 0x02);
-	write_cmos_sensor(0x71, 0x02);
+	write_cmos_sensor(0x6a, 0x00);
+	write_cmos_sensor(0x6b, 0x00);
+	write_cmos_sensor(0x6c, 0x00);
+	write_cmos_sensor(0x6d, 0x00);
+	write_cmos_sensor(0x6e, 0x00);
+	write_cmos_sensor(0x6f, 0x00);
+	write_cmos_sensor(0x70, 0x00);
+	write_cmos_sensor(0x71, 0x00);
 
 	////////////////////////////////////////////////////
 	///////////////////// dark sun   /////////////////////
 	////////////////////////////////////////////////////
 	write_cmos_sensor(0x87, 0x03);
-	write_cmos_sensor(0xe5, 0x25);//27
+	write_cmos_sensor(0xe5, 0x25);
 	write_cmos_sensor(0xe6, 0xb0);
-	write_cmos_sensor(0xe7, 0xf3);//53
+	write_cmos_sensor(0xe7, 0xf3);
 	write_cmos_sensor(0xe8, 0xff);
-	write_cmos_sensor(0xe9, 0x0f);//3f
+	write_cmos_sensor(0xe9, 0x0f);
 
 	////////////////////////////////////////////////////
 	/////////////////////   MIPI   /////////////////////
 	////////////////////////////////////////////////////
 	write_cmos_sensor(0xfe, 0x03);
 	write_cmos_sensor(0x01, 0x87);
-	write_cmos_sensor(0x02, 0x11);//00 travis20150403 
-	write_cmos_sensor(0x03, 0x11);//10 travis20150403
+	write_cmos_sensor(0x02, 0x11); // 00 20150522
+	write_cmos_sensor(0x03, 0x11);// 10 travis 20150611
 	write_cmos_sensor(0x04, 0x01);
 	write_cmos_sensor(0x05, 0x00);
 	write_cmos_sensor(0x06, 0xa2);
@@ -582,8 +596,8 @@ static void sensor_init(void)
 	write_cmos_sensor(0x25, 0x10);
 	write_cmos_sensor(0x26, 0x04);
 	write_cmos_sensor(0x27, 0x06);
-	write_cmos_sensor(0x29, 0x02);//erick
-	write_cmos_sensor(0x2a, 0x08);//erick 
+	write_cmos_sensor(0x29, 0x02);
+	write_cmos_sensor(0x2a, 0x08);
 	write_cmos_sensor(0x2b, 0x04);
 	write_cmos_sensor(0xfe, 0x00);
 }    /*    sensor_init  */
@@ -604,7 +618,7 @@ static void capture_setting(kal_uint16 currefps)
 	LOG_INF("E! currefps:%d\n",currefps);
 	write_cmos_sensor(0xfe,0x03);
 	write_cmos_sensor(0x10,0x91);
-	write_cmos_sensor(0xfe,0x00);
+		  write_cmos_sensor(0xfe,0x00);
 		
 }
 
@@ -615,7 +629,7 @@ static void normal_video_setting(kal_uint16 currefps)
 	
 	write_cmos_sensor(0xfe,0x03);
 	write_cmos_sensor(0x10,0x91);
-	write_cmos_sensor(0xfe,0x00);
+	 write_cmos_sensor(0xfe,0x00);
 		
 }
 
@@ -638,10 +652,8 @@ static kal_uint32 set_test_pattern_mode(kal_bool enable)
 
     if (enable) {
         write_cmos_sensor(0xfe, 0x00);
-        write_cmos_sensor(0x8c, 0x10); 
     } else {
         write_cmos_sensor(0xfe, 0x00);
-        write_cmos_sensor(0x8c, 0x00); 
     }
     spin_lock(&imgsensor_drv_lock);
     imgsensor.test_pattern = enable;
@@ -822,7 +834,7 @@ static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
     imgsensor.autoflicker_en = KAL_FALSE;
     spin_unlock(&imgsensor_drv_lock);
     preview_setting();
-	//set_mirror_flip(sensor_config_data->SensorImageMirror);
+	set_mirror_flip(imgsensor.mirror);
     return ERROR_NONE;
 }    /*    preview   */
 
@@ -865,7 +877,7 @@ static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
     }
     spin_unlock(&imgsensor_drv_lock);
     capture_setting(imgsensor.current_fps);
-	//set_mirror_flip(sensor_config_data->SensorImageMirror);
+	set_mirror_flip(imgsensor.mirror);
     return ERROR_NONE;
 }    /* capture() */
 static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
@@ -883,7 +895,7 @@ static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
     imgsensor.autoflicker_en = KAL_FALSE;
     spin_unlock(&imgsensor_drv_lock);
     normal_video_setting(imgsensor.current_fps);	
-	//set_mirror_flip(sensor_config_data->SensorImageMirror);
+	set_mirror_flip(imgsensor.mirror);
     return ERROR_NONE;
 }    /*    normal_video   */
 
@@ -904,7 +916,7 @@ static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
     imgsensor.autoflicker_en = KAL_FALSE;
     spin_unlock(&imgsensor_drv_lock);
     hs_video_setting();	
-	//set_mirror_flip(sensor_config_data->SensorImageMirror);
+	set_mirror_flip(imgsensor.mirror);
     return ERROR_NONE;
 }    /*    hs_video   */
 
@@ -924,7 +936,7 @@ static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
     imgsensor.autoflicker_en = KAL_FALSE;
     spin_unlock(&imgsensor_drv_lock);
     slim_video_setting();
-	//set_mirror_flip(sensor_config_data->SensorImageMirror);
+	set_mirror_flip(imgsensor.mirror);
 
     return ERROR_NONE;
 }    /*    slim_video     */
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2755_mipi_raw/gc2755mipi_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2755_mipi_raw/gc2755mipi_Sensor.h
old mode 100644
new mode 100755
index c5f80a8..ab50666
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2755_mipi_raw/gc2755mipi_Sensor.h
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2755_mipi_raw/gc2755mipi_Sensor.h
@@ -128,11 +128,11 @@ typedef struct imgsensor_info_struct {
 
 #define GC2755_VIDEO_PERIOD_PIXEL_NUMS          (1772)
 #define GC2755_VIDEO_PERIOD_LINE_NUMS           (1185)
-#define GC2755_PV_PERIOD_PIXEL_NUMS             (1772)
-#define GC2755_PV_PERIOD_LINE_NUMS              (1185)
+#define GC2755_PV_PERIOD_PIXEL_NUMS            (1772)
+#define GC2755_PV_PERIOD_LINE_NUMS             (1185)
 
-#define GC2755_FULL_PERIOD_PIXEL_NUMS           (1772)
-#define GC2755_FULL_PERIOD_LINE_NUMS            (1185)
+#define GC2755_FULL_PERIOD_PIXEL_NUMS          (1772)
+#define GC2755_FULL_PERIOD_LINE_NUMS           (1185)
 
 
 // end
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc5004_mipi_raw/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc5004_mipi_raw/Makefile
index 6b8b8b6..2726dd8 100644
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc5004_mipi_raw/Makefile
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc5004_mipi_raw/Makefile
@@ -1,4 +1,4 @@
 include $(srctree)/drivers/misc/mediatek/Makefile.custom
-obj-y += gc5004mipiraw_Sensor.o
 
+obj-y += gc5004mipiraw_Sensor.o 
 
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc5004_mipi_raw/gc5004mipiraw_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc5004_mipi_raw/gc5004mipiraw_Sensor.c
old mode 100644
new mode 100755
index 6431022..30c9e5a
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc5004_mipi_raw/gc5004mipiraw_Sensor.c
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc5004_mipi_raw/gc5004mipiraw_Sensor.c
@@ -233,7 +233,7 @@ static void set_max_framerate(UINT16 framerate,kal_bool min_framelength_en)
     kal_uint32 frame_length = imgsensor.frame_length;
     //unsigned long flags;
 
-    LOG_INF("framerate = %d, min framelength should enable? \n", framerate,min_framelength_en);
+    LOG_INF("framerate = %d, min framelength should enable = %d\n", framerate,min_framelength_en);
 
     frame_length = imgsensor.pclk / framerate * 10 / imgsensor.line_length;
     spin_lock(&imgsensor_drv_lock);
@@ -364,9 +364,6 @@ static kal_uint16 set_gain(kal_uint16 gain)
 #define ANALOG_GAIN_7 435  // 7.15x
 			
 	kal_uint16 iReg,temp,temp1; 	
-
-	write_cmos_sensor(0xb1, 0x01);
-	write_cmos_sensor(0xb2, 0x00);
 	
 	iReg = gain;
 	
@@ -532,7 +529,7 @@ static void sensor_init(void)
 	write_cmos_sensor(0x0e, 0xa8); 
 	write_cmos_sensor(0x0f, 0x0a); 
 	write_cmos_sensor(0x10, 0x50); 
-	write_cmos_sensor(0x17, 0x16); //[0]mirror [1]flip
+	write_cmos_sensor(0x17, 0x15); //[0]mirror [1]flip
 	write_cmos_sensor(0x18, 0x02); //sdark off
 	write_cmos_sensor(0x19, 0x0c); 
 	write_cmos_sensor(0x1a, 0x13); 
@@ -651,8 +648,8 @@ static void sensor_init(void)
 	/////////////////////////////////////////////////////
 	write_cmos_sensor(0xfe, 0x03);
 	write_cmos_sensor(0x01, 0x07);
-	write_cmos_sensor(0x02, 0x11);//33
-	write_cmos_sensor(0x03, 0x11);//93
+	write_cmos_sensor(0x02, 0x33); // 33
+	write_cmos_sensor(0x03, 0x93);
 	write_cmos_sensor(0x04, 0x80);
 	write_cmos_sensor(0x05, 0x02);
 	write_cmos_sensor(0x06, 0x80);
@@ -699,7 +696,7 @@ static void preview_setting(void)
 	write_cmos_sensor(0x4e, 0x00); //blk 20140722
 	write_cmos_sensor(0x4f, 0x06); 
   
-	write_cmos_sensor(0x17, 0x36); 
+	write_cmos_sensor(0x17, 0x35); 
 	write_cmos_sensor(0x92, 0x02); //add  //mly  00 tao 9.26
 	write_cmos_sensor(0x94, 0x05); //07  tao 9.26  
 	write_cmos_sensor(0x95, 0x03);
@@ -739,7 +736,7 @@ static void capture_setting(kal_uint16 currefps)
 	write_cmos_sensor(0x4e, 0x00); //blk 20140722
 	write_cmos_sensor(0x4f, 0x3c); 
 	
-	write_cmos_sensor(0x17, 0x16); 
+	write_cmos_sensor(0x17, 0x15); 
 	write_cmos_sensor(0x92, 0x01);//add //mly
 	write_cmos_sensor(0x94, 0x0a);//0d //mly  0e  tao 9.26
 	write_cmos_sensor(0x95, 0x07);
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc5004_mipi_raw/gc5004mipiraw_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc5004_mipi_raw/gc5004mipiraw_Sensor.h
old mode 100644
new mode 100755
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc5024_mipi_raw/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc5024_mipi_raw/Makefile
old mode 100644
new mode 100755
index 8809909..0c02926
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc5024_mipi_raw/Makefile
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc5024_mipi_raw/Makefile
@@ -1,4 +1,4 @@
 include $(srctree)/drivers/misc/mediatek/Makefile.custom
-obj-y += gc5024mipi_Sensor.o
 
+obj-y += gc5024mipi_Sensor.o 
 
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc5024_mipi_raw/gc5024mipi_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc5024_mipi_raw/gc5024mipi_Sensor.c
old mode 100644
new mode 100755
index 480d6b3..62aa028
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc5024_mipi_raw/gc5024mipi_Sensor.c
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc5024_mipi_raw/gc5024mipi_Sensor.c
@@ -274,13 +274,13 @@ static void set_shutter(kal_uint16 shutter)
   	{
 		write_cmos_sensor(0xfe, 0x00);
 		write_cmos_sensor(0x32, 0x09);
-		write_cmos_sensor(0xb0, 0x50);
+		write_cmos_sensor(0xb0, 0x53);
   	}
   	else 
 	{
 		write_cmos_sensor(0xfe, 0x00);
 		write_cmos_sensor(0x32, 0x49);
-		write_cmos_sensor(0xb0, 0x40);	
+		write_cmos_sensor(0xb0, 0x4b);	
   	}	
 	//Update Shutter
 	write_cmos_sensor(0xfe, 0x00);	
@@ -319,12 +319,13 @@ static kal_uint16 gain2reg(const kal_uint16 gain)
 *
 *************************************************************************/
 
-#define ANALOG_GAIN_1 64  // 1x
-#define ANALOG_GAIN_2 88  // 1.38x
-#define ANALOG_GAIN_3 122  // 1.91x
-#define ANALOG_GAIN_4 174  // 2.72x
-#define ANALOG_GAIN_5 245  // 3.83x
-#define ANALOG_GAIN_6 351  // 5.48x
+#define ANALOG_GAIN_1 64   // 1.000x
+#define ANALOG_GAIN_2 88   // 1.375x
+#define ANALOG_GAIN_3 121  // 1.891x 
+#define ANALOG_GAIN_4 168  // 2.625x
+#define ANALOG_GAIN_5 239  // 3.734x
+#define ANALOG_GAIN_6 336  // 5.250x
+#define ANALOG_GAIN_7 481  // 7.516x
 
 static kal_uint16 set_gain(kal_uint16 gain)
 {	
@@ -357,8 +358,8 @@ static kal_uint16 set_gain(kal_uint16 gain)
 	else if((ANALOG_GAIN_2<= iReg)&&(iReg < ANALOG_GAIN_3))
 	{
 		write_cmos_sensor(0xfe, 0x00);
-		write_cmos_sensor(0x21, 0x0b);
-		write_cmos_sensor(0x29, 0x1b);
+		write_cmos_sensor(0x21, 0x0f);
+		write_cmos_sensor(0x29, 0x0f);
 		write_cmos_sensor(0xe8, 0x03); 
 		write_cmos_sensor(0xe9, 0x01); 
  		write_cmos_sensor(0xea, 0x02); 
@@ -372,19 +373,19 @@ static kal_uint16 set_gain(kal_uint16 gain)
 		temp = 64*iReg/ANALOG_GAIN_2;
 		write_cmos_sensor(0xb1, temp>>6);
 		write_cmos_sensor(0xb2, (temp<<2)&0xfc);
-		LOG_INF("GC5024MIPI analogic gain 1.38x , GC5024MIPI add pregain = %d\n",temp);
+		LOG_INF("GC5024MIPI analogic gain 1.375x , GC5024MIPI add pregain = %d\n",temp);
 	}
 	else if((ANALOG_GAIN_3<= iReg)&&(iReg < ANALOG_GAIN_4))
 	{
 		write_cmos_sensor(0xfe, 0x00);
-		write_cmos_sensor(0x21, 0x0d);
-		write_cmos_sensor(0x29, 0x1d);
-		write_cmos_sensor(0xe8, 0x02); 
- 		write_cmos_sensor(0xe9, 0x02); 
+		write_cmos_sensor(0x21, 0x0b);
+		write_cmos_sensor(0x29, 0x1b);
+		write_cmos_sensor(0xe8, 0x03); 
+ 		write_cmos_sensor(0xe9, 0x01); 
  		write_cmos_sensor(0xea, 0x02); 
  		write_cmos_sensor(0xeb, 0x02); 
- 		write_cmos_sensor(0xec, 0x02); 
- 		write_cmos_sensor(0xed, 0x02); 
+ 		write_cmos_sensor(0xec, 0x03); 
+ 		write_cmos_sensor(0xed, 0x01); 
  		write_cmos_sensor(0xee, 0x02); 
  		write_cmos_sensor(0xef, 0x02); 
 		//analog gain
@@ -392,11 +393,31 @@ static kal_uint16 set_gain(kal_uint16 gain)
 		temp = 64*iReg/ANALOG_GAIN_3;
 		write_cmos_sensor(0xb1, temp>>6);
 		write_cmos_sensor(0xb2, (temp<<2)&0xfc);
-		LOG_INF("GC5024MIPI analogic gain 1.91x , GC5024MIPI add pregain = %d\n",temp);
+		LOG_INF("GC5024MIPI analogic gain 1.891x , GC5024MIPI add pregain = %d\n",temp);
 	}
 	else if((ANALOG_GAIN_4<= iReg)&&(iReg < ANALOG_GAIN_5))
 	{
 		write_cmos_sensor(0xfe, 0x00);
+		write_cmos_sensor(0x21, 0x0d);
+		write_cmos_sensor(0x29, 0x1d);
+		write_cmos_sensor(0xe8, 0x02); 
+		write_cmos_sensor(0xe9, 0x02); 
+		write_cmos_sensor(0xea, 0x02); 
+		write_cmos_sensor(0xeb, 0x02); 
+		write_cmos_sensor(0xec, 0x02); 
+		write_cmos_sensor(0xed, 0x02); 
+		write_cmos_sensor(0xee, 0x02); 
+		write_cmos_sensor(0xef, 0x02); 
+		//analog gain
+		write_cmos_sensor(0xb6,  0x03);//
+		temp = 64*iReg/ANALOG_GAIN_4;
+		write_cmos_sensor(0xb1, temp>>6);
+		write_cmos_sensor(0xb2, (temp<<2)&0xfc);
+		LOG_INF("GC5024MIPI analogic gain 2.625x , GC5024MIPI add pregain = %d\n",temp);
+	}
+	else if((ANALOG_GAIN_5<= iReg)&&(iReg < ANALOG_GAIN_6))
+	{
+		write_cmos_sensor(0xfe, 0x00);
 		write_cmos_sensor(0x21, 0x08);
 		write_cmos_sensor(0x29, 0x38);
 		write_cmos_sensor(0xe8, 0x03); 
@@ -408,16 +429,16 @@ static kal_uint16 set_gain(kal_uint16 gain)
 		write_cmos_sensor(0xee, 0x03); 
 		write_cmos_sensor(0xef, 0x03); 
 		//analog gain
-		write_cmos_sensor(0xb6,  0x03);//
-		temp = 64*iReg/ANALOG_GAIN_4;
+		write_cmos_sensor(0xb6,  0x04);//
+		temp = 64*iReg/ANALOG_GAIN_5;
 		write_cmos_sensor(0xb1, temp>>6);
 		write_cmos_sensor(0xb2, (temp<<2)&0xfc);
-		LOG_INF("GC5024MIPI analogic gain 2.72x , GC5024MIPI add pregain = %d\n",temp);
+		LOG_INF("GC5024MIPI analogic gain 3.734x , GC5024MIPI add pregain = %d\n",temp);
 	}
-	else if((ANALOG_GAIN_5<= iReg)&&(iReg < ANALOG_GAIN_6))
+	else if((ANALOG_GAIN_6<= iReg)&&(iReg < ANALOG_GAIN_7))
 	{
 		write_cmos_sensor(0xfe, 0x00);
-		write_cmos_sensor(0x21, 0x08);
+		write_cmos_sensor(0x21, 0x08); 
 		write_cmos_sensor(0x29, 0x38);
 		write_cmos_sensor(0xe8, 0x03); 
 		write_cmos_sensor(0xe9, 0x03); 
@@ -428,13 +449,13 @@ static kal_uint16 set_gain(kal_uint16 gain)
 		write_cmos_sensor(0xee, 0x03); 
 		write_cmos_sensor(0xef, 0x03); 
 		//analog gain
-		write_cmos_sensor(0xb6,  0x04);//
-		temp = 64*iReg/ANALOG_GAIN_5;
+		write_cmos_sensor(0xb6,  0x05);//
+		temp = 64*iReg/ANALOG_GAIN_6;
 		write_cmos_sensor(0xb1, temp>>6);
 		write_cmos_sensor(0xb2, (temp<<2)&0xfc);
-		LOG_INF("GC5024MIPI analogic gain 3.83x , GC5024MIPI add pregain = %d\n",temp);
+		LOG_INF("GC5024MIPI analogic gain 5.250x , GC5024MIPI add pregain = %d\n",temp);
 	}
-	else if(ANALOG_GAIN_6<= iReg)
+	else if(ANALOG_GAIN_7<= iReg)
 	{
 		write_cmos_sensor(0xfe, 0x00);
 		write_cmos_sensor(0x21, 0x08); 
@@ -448,11 +469,11 @@ static kal_uint16 set_gain(kal_uint16 gain)
 		write_cmos_sensor(0xee, 0x03); 
 		write_cmos_sensor(0xef, 0x03); 
 		//analog gain
-		write_cmos_sensor(0xb6,  0x05);//
-		temp = 64*iReg/ANALOG_GAIN_6;
+		write_cmos_sensor(0xb6,  0x06);//
+		temp = 64*iReg/ANALOG_GAIN_7;
 		write_cmos_sensor(0xb1, temp>>6);
 		write_cmos_sensor(0xb2, (temp<<2)&0xfc);
-		LOG_INF("GC5024MIPI analogic gain 5.48x , GC5024MIPI add pregain = %d\n",temp);
+		LOG_INF("GC5024MIPI analogic gain 7.516x , GC5024MIPI add pregain = %d\n",temp);
 	}
 	return gain;
 
@@ -496,7 +517,7 @@ static void night_mode(kal_bool enable)
 static void sensor_init(void)
 {
 	LOG_INF("E");
-       /*SYS*/
+    /*SYS*/
 	write_cmos_sensor(0xfe, 0x80);				
 	write_cmos_sensor(0xfe, 0x80);						  
 	write_cmos_sensor(0xfe, 0x80);
@@ -539,6 +560,7 @@ static void sensor_init(void)
 	write_cmos_sensor(0x32, 0x49); 
 	
 	write_cmos_sensor(0xcd, 0xaa); 	     
+	write_cmos_sensor(0xd0, 0xc2);
 	write_cmos_sensor(0xd1, 0xc4);
 	write_cmos_sensor(0xd2, 0xcb);								  
 	write_cmos_sensor(0xd3, 0x73); 		 
@@ -560,13 +582,14 @@ static void sensor_init(void)
 	write_cmos_sensor(0x98, 0x20); 
 	
 	/*Gain*/
-	write_cmos_sensor(0x99, 0x02); 
-	write_cmos_sensor(0x9a, 0x03); 
-	write_cmos_sensor(0x9b, 0x04); 
-	write_cmos_sensor(0x9c, 0x0d); 
-	write_cmos_sensor(0x9d, 0x15); 
-	write_cmos_sensor(0x9e, 0x1d);
-	write_cmos_sensor(0xb0, 0x40); 
+	write_cmos_sensor(0x99, 0x01); 
+	write_cmos_sensor(0x9a, 0x02); 
+	write_cmos_sensor(0x9b, 0x03); 
+	write_cmos_sensor(0x9c, 0x04); 
+	write_cmos_sensor(0x9d, 0x0d); 
+	write_cmos_sensor(0x9e, 0x15);
+	write_cmos_sensor(0x9f, 0x1d);
+	write_cmos_sensor(0xb0, 0x4b); 
 	write_cmos_sensor(0xb1, 0x01);
 	write_cmos_sensor(0xb2, 0x00);
 	write_cmos_sensor(0xb6, 0x00);
@@ -637,7 +660,7 @@ static void preview_setting(void)
 	//2592x1944
 	/*SYS*/
 	write_cmos_sensor(0xfe, 0x03);				
-	write_cmos_sensor(0x10, 0x00);//Stream off						  
+	write_cmos_sensor(0x10, 0x81);//Stream off						  
 	write_cmos_sensor(0xfe, 0x00);
 	/*Analog*/		  
 	write_cmos_sensor(0x0a, 0x00);					  	  
@@ -668,7 +691,7 @@ static void capture_setting(kal_uint16 currefps)
 	//2592x1944
 	/*SYS*/
 	write_cmos_sensor(0xfe, 0x03);				
-	write_cmos_sensor(0x10, 0x00);//Stream off						  
+	write_cmos_sensor(0x10, 0x81);//Stream off						  
 	write_cmos_sensor(0xfe, 0x00);
 	/*Analog*/		  
 	write_cmos_sensor(0x0a, 0x00);					  	  
@@ -699,7 +722,7 @@ static void normal_video_setting(kal_uint16 currefps)
 	//2560x1440
 	/*SYS*/
 	write_cmos_sensor(0xfe, 0x03);
-	write_cmos_sensor(0x10, 0x00); //Stream off
+	write_cmos_sensor(0x10, 0x81); //Stream off
 	write_cmos_sensor(0xfe, 0x00);
 	/*Analog*/
 	write_cmos_sensor(0x0a, 0xfc);					   
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc5024_mipi_raw/gc5024mipi_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc5024_mipi_raw/gc5024mipi_Sensor.h
old mode 100644
new mode 100755
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/hi545_mipi_raw/hi545mipi_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/hi545_mipi_raw/hi545mipi_Sensor.c
old mode 100644
new mode 100755
index 3c08814..5ab3e7b
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/hi545_mipi_raw/hi545mipi_Sensor.c
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/hi545_mipi_raw/hi545mipi_Sensor.c
@@ -36,20 +36,16 @@
 
 #include "hi545mipi_Sensor.h"
 
-extern void kdSetI2CSpeed(u32 i2cSpeed);
 
 /****************************Modify Following Strings for Debug****************************/
-#define DEBUG_TAG   "[V28]"
-#define PFX "[HI545]"DEBUG_TAG
+#define PFX "HI545_camera_sensor"
 #define LOG_1 LOG_INF("HI545,MIPI 2LANE\n")
 #define LOG_2 LOG_INF("preview 1296*972@30fps; video 1296*972@30fps; capture 5M@30fps\n")
 /****************************   Modify end    *******************************************/
 
-#define LOG_INF(format, args...)    xlog_printk(ANDROID_LOG_INFO   , PFX, "[%s] " format, __FUNCTION__, ##args)
+#define LOG_INF(format, args...)    pr_debug(PFX "[%s] " format, __FUNCTION__, ##args)
 
-#define USE_I2C_400K    1
 
-static void capture_setting(kal_uint16 currefps);
 
 static DEFINE_SPINLOCK(imgsensor_drv_lock);
 
@@ -57,7 +53,7 @@ static DEFINE_SPINLOCK(imgsensor_drv_lock);
 static imgsensor_info_struct imgsensor_info = {
     .sensor_id = HI545MIPI_SENSOR_ID,        //record sensor id defined in Kd_imgsensor.h
 
-    .checksum_value = 0x55e2a82f,        //checksum value for Camera Auto Test, 0x40aeb1f5
+    .checksum_value = 0x40aeb1f5,        //checksum value for Camera Auto Test
 
 	.pre = {
 		.pclk = 176000000,				//record different mode's pclk
@@ -65,12 +61,12 @@ static imgsensor_info_struct imgsensor_info = {
 		.framelength = 2017,			//record different mode's framelength
 		.startx = 0,					//record different mode's startx of grabwindow
 		.starty = 0,					//record different mode's starty of grabwindow
-		.grabwindow_width = 2592,		//record different mode's width of grabwindow
-		.grabwindow_height = 1944,		//record different mode's height of grabwindow
+		.grabwindow_width = 1296,		//record different mode's width of grabwindow
+		.grabwindow_height = 972,		//record different mode's height of grabwindow
 		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
-		.mipi_data_lp2hs_settle_dc = 14,
+		.mipi_data_lp2hs_settle_dc = 85,
 		/*	 following for GetDefaultFramerateByScenario()	*/
-		.max_framerate = 300,
+		.max_framerate = 300,	
 	},
 	.cap = {
 		.pclk = 176000000,
@@ -80,7 +76,7 @@ static imgsensor_info_struct imgsensor_info = {
 		.starty = 0,
 		.grabwindow_width = 2592,
 		.grabwindow_height = 1944,
-		.mipi_data_lp2hs_settle_dc = 14,
+		.mipi_data_lp2hs_settle_dc = 85,
 		.max_framerate = 300,
 	},
 	.cap1 = {
@@ -91,8 +87,8 @@ static imgsensor_info_struct imgsensor_info = {
 		.starty = 0,
 		.grabwindow_width = 2592,
 		.grabwindow_height = 1944,
-		.mipi_data_lp2hs_settle_dc = 14,
-		.max_framerate = 300,
+		.mipi_data_lp2hs_settle_dc = 85,
+		.max_framerate = 300,	
 	},
 	.normal_video = {
 		.pclk = 176000000,
@@ -102,7 +98,7 @@ static imgsensor_info_struct imgsensor_info = {
 		.starty = 0,
 		.grabwindow_width = 1296,
 		.grabwindow_height = 972,
-		.mipi_data_lp2hs_settle_dc = 14,
+		.mipi_data_lp2hs_settle_dc = 85,
 		.max_framerate = 300,
 	},
 	.hs_video = {
@@ -113,7 +109,7 @@ static imgsensor_info_struct imgsensor_info = {
 		.starty = 0,
 		.grabwindow_width = 640,
 		.grabwindow_height = 480,
-		.mipi_data_lp2hs_settle_dc = 14,
+		.mipi_data_lp2hs_settle_dc = 85,
 		.max_framerate = 1200,
 	},
 	.slim_video = {
@@ -124,7 +120,7 @@ static imgsensor_info_struct imgsensor_info = {
 		.starty = 0,
 		.grabwindow_width = 1280,
 		.grabwindow_height = 720,
-		.mipi_data_lp2hs_settle_dc = 14,
+		.mipi_data_lp2hs_settle_dc = 85,
 		.max_framerate = 300,
 	},
 
@@ -132,14 +128,14 @@ static imgsensor_info_struct imgsensor_info = {
     .min_shutter = 1,        //min shutter
     .max_frame_length = 0xffff,//max framelength by sensor register's limitation
     .ae_shut_delay_frame = 0,    //shutter delay frame for AE cycle, 2 frame with ispGain_delay-shut_delay=2-0=2
-    .ae_sensor_gain_delay_frame = 0,//sensor gain delay frame for AE cycle,2 frame with ispGain_delay-sensor_gain_delay=2-0=2
+    .ae_sensor_gain_delay_frame = 1,//sensor gain delay frame for AE cycle,2 frame with ispGain_delay-sensor_gain_delay=2-0=2
     .ae_ispGain_delay_frame = 2,//isp gain delay frame for AE cycle
     .ihdr_support = 0,      //1, support; 0,not support
     .ihdr_le_firstline = 0,  //1,le first ; 0, se first
     .sensor_mode_num = 5,      //support sensor mode num
 
-    .cap_delay_frame = 1,        //enter capture delay frame num
-    .pre_delay_frame = 1,         //enter preview delay frame num
+    .cap_delay_frame = 4,        //enter capture delay frame num
+    .pre_delay_frame = 4,         //enter preview delay frame num
     .video_delay_frame = 4,        //enter video delay frame num
     .hs_video_delay_frame = 3,    //enter high speed video  delay frame num
     .slim_video_delay_frame = 3,//enter slim video delay frame num
@@ -147,9 +143,9 @@ static imgsensor_info_struct imgsensor_info = {
     .isp_driving_current = ISP_DRIVING_6MA, //mclk driving current
     .sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,//sensor_interface_type
     .mipi_sensor_type = MIPI_OPHY_NCSI2, //0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2
-    .mipi_settle_delay_mode = MIPI_SETTLEDELAY_AUTO,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
+    .mipi_settle_delay_mode = 1,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
     .sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_Gb,//sensor output first pixel color
-    .mclk = 24,//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
+    .mclk = 18,//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
     .mipi_lane_num = SENSOR_MIPI_2_LANE,//mipi lane num
     .i2c_addr_table = {0x40, 0xff},//record sensor support all write id addr, only supprt 4must end with 0xff
 };
@@ -159,7 +155,7 @@ static imgsensor_struct imgsensor = {
     .mirror = IMAGE_V_MIRROR,                //mirrorflip information
     .sensor_mode = IMGSENSOR_MODE_INIT, //IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
     .shutter = 0x3D0,                    //current shutter
-    .gain = 0x100,                        //current gain
+    .gain = 0x0,                        //current gain
     .dummy_pixel = 0,                    //current dummypixel
     .dummy_line = 0,                    //current dummyline
     .current_fps = 300,  //full size current fps : 24fps for PIP, 30fps for Normal or ZSD
@@ -173,11 +169,11 @@ static imgsensor_struct imgsensor = {
 
 /* Sensor output window information */
 static SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[5] =
-{{ 2592, 1944,	  0,	0, 2592, 1944, 1296,   972, 0000, 0000, 1296,   972,	  0,	0, 1296,   972}, // Preview
- { 2592, 1944,	  0,	0, 2592, 1944, 2592,  1944, 0000, 0000, 2592,  1944,	  0,	0, 2592,  1944}, // capture
- { 2592, 1944,	  0,	0, 2592, 1944, 1296,   972, 0000, 0000, 1296,   972,	  0,	0, 1296,   972}, // video
- { 2592, 1944,	  0,	0, 2592, 1944, 648,   488, 0000, 0000, 648,   488,	  0,	0, 640,   480}, //hight speed video
- { 2592, 1944,	  0,	0, 2592, 1944, 1296,   972, 0000, 0000, 1296,   972,	  0,	0, 1296,   972}};// slim video
+{{ 2592, 1944,	  0,	0, 2592, 1944, 1296,   972, 0000, 0000, 1296,   972,	  0,	0, 1296,   972}, // Preview 
+ { 2592, 1944,	  0,	0, 2592, 1944, 2592,  1944, 0000, 0000, 2592,  1944,	  0,	0, 2592,  1944}, // capture 
+ { 2592, 1944,	  0,	0, 2592, 1944, 1296,   972, 0000, 0000, 1296,   972,	  0,	0, 1296,   972}, // video 
+ { 2592, 1944,	  0,	0, 2592, 1944, 648,   488, 0000, 0000, 648,   488,	  0,	0, 640,   480}, //hight speed video 
+ { 2592, 1944,	  0,	0, 2592, 1944, 1296,   972, 0000, 0000, 1296,   972,	  0,	0, 1296,   972}};// slim video 
 
 
 
@@ -200,8 +196,10 @@ static void set_dummy()
 {
 	LOG_INF("dummyline = %d, dummypixels = %d \n", imgsensor.dummy_line, imgsensor.dummy_pixel);
 
-	write_cmos_sensor(0x0006, imgsensor.frame_length);
+	write_cmos_sensor(0x0046, 0x0100);	
+	write_cmos_sensor(0x0006, imgsensor.frame_length);  
 	write_cmos_sensor(0x0008, imgsensor.line_length);
+	write_cmos_sensor(0x0046, 0x0000);	
 
 }    /*    set_dummy  */
 
@@ -215,7 +213,6 @@ static void set_max_framerate(UINT16 framerate,kal_bool min_framelength_en)
     kal_uint32 frame_length = imgsensor.frame_length;
     //unsigned long flags;
 
-    LOG_INF("framerate = %d, min framelength should enable? \n", framerate,min_framelength_en);
 
     frame_length = imgsensor.pclk / framerate * 10 / imgsensor.line_length;
     spin_lock(&imgsensor_drv_lock);
@@ -290,18 +287,21 @@ static void set_shutter(kal_uint16 shutter)
             set_max_framerate(146,0);
         else {
         // Extend frame length
+            write_cmos_sensor(0x0046, 0x0100);
        		write_cmos_sensor(0x0006, imgsensor.frame_length);
+       		write_cmos_sensor(0x0046, 0x0000);
         }
     } else {
         // Extend frame length
+            write_cmos_sensor(0x0046, 0x0100);
 			write_cmos_sensor(0x0006, imgsensor.frame_length);
-
+			write_cmos_sensor(0x0046, 0x0000);
     }
 
     // Update Shutter
-	write_cmos_sensor(0x0046, 0x0100);
+	write_cmos_sensor(0x0046, 0x0100);		
 	write_cmos_sensor(0x0004, shutter);
-	write_cmos_sensor(0x0046, 0x0000);
+	write_cmos_sensor(0x0046, 0x0000);	
 
     LOG_INF("Exit! shutter =%d, framelength =%d\n", shutter,imgsensor.frame_length);
 
@@ -312,9 +312,9 @@ static void set_shutter(kal_uint16 shutter)
 static kal_uint16 gain2reg(const kal_uint16 gain)
 {
 	kal_uint16 reg_gain = 0x0000;
-
+	
 	reg_gain = gain / 4 - 16;
-
+	
 	return (kal_uint16)reg_gain;
 
 }
@@ -360,9 +360,9 @@ static kal_uint16 set_gain(kal_uint16 gain)
     spin_unlock(&imgsensor_drv_lock);
     LOG_INF("gain = %d , reg_gain = 0x%x\n ", gain, reg_gain);
 
-	write_cmos_sensor(0x0046, 0x0100);
-	write_cmos_sensor(0x003a, reg_gain << 8);
-	write_cmos_sensor(0x0046, 0x0000);
+	write_cmos_sensor(0x0046, 0x0100);	
+	write_cmos_sensor(0x003a, reg_gain << 8);  
+	write_cmos_sensor(0x0046, 0x0000);	
 
     return gain;
 }    /*    set_gain  */
@@ -431,40 +431,40 @@ static void sensor_init(void)
 	//	Initial Date		: 2014-07-31
 	//
 	//	Customs          : Internal
-	//	AP or B/E        :
+	//	AP or B/E        : 
 	//	Demo Board       : USB3.0 Tool
-	//
+	//	
 	//	Image size       : 2604x1956
 	//	mclk/pclk        : 24mhz / 88Mhz
 	//	MIPI speed(Mbps) : 880Mbps (each lane)
-	//	MIPI						 : Non-continuous
+	//	MIPI						 : Non-continuous 
 	//	Frame Length     : 1984
 	//	V-Blank          : 546us
 	//	Line Length	     : 2880
-	//	H-Blank          : 386ns / 387ns
-	//	Max Fps          : 30fps (= Exp.time : 33ms )
+	//	H-Blank          : 386ns / 387ns	
+	//	Max Fps          : 30fps (= Exp.time : 33ms )	
 	//	Pixel order      : Blue 1st (=BGGR)
 	//	X/Y-flip         : No-X/Y flip
 	//	I2C Address      : 0x40(Write), 0x41(Read)
 	//	AG               : x1
 	//	DG               : x1
 	//	OTP Type         : Single Write/read
-	//
+	//	
 	//
 	//////////////////////////////////////////////////////////////////////////
 	//<<<<<<<<<  Notice >>>>>>>>>/////////////////////////////////////////////
 	//////////////////////////////////////////////////////////////////////////
 	//
 	//	Notice
-	//	1) I2C Address & Data Type is 2Byte.
-	//	2) I2C Data construction that high byte is low addres, and low byte is high address.
-	//		 Initial register address must have used the even number.
+	//	1) I2C Address & Data Type is 2Byte. 
+	//	2) I2C Data construction that high byte is low addres, and low byte is high address. 
+	//		 Initial register address must have used the even number. 
 	//		 ex){Address, Data} = {Address(Even, 2byte), Data(2byte)} <==== Used Type
 	//												= {Address(Even, 2byte(low address)), Data(1byte)} + {Address(Odd, 2byte(high address)), Data(1byte)} <== Not Used Type
 	//												= write_cmos_sensor(0x0000, 0x0F03} => write_cmos_sensor(0x0000, 0x0F} + write_cmos_sensor(0x0001, 0x03}
 	//	3) The Continuous Mode of MIPI 2 Lane set is write_cmos_sensor(0x0902, 0x4301}. And, 1lane set is write_cmos_sensor(0x0902, 0x0301}.
-	//		 The Non-continuous Mode of MIPI 2 Lane set is write_cmos_sensor(0x0902, 0x4101}. And, 1lane set is write_cmos_sensor(0x0902, 0x0101}.
-	//	4) Analog Gain address is 0x003a.
+	//		 The Non-continuous Mode of MIPI 2 Lane set is write_cmos_sensor(0x0902, 0x4101}. And, 1lane set is write_cmos_sensor(0x0902, 0x0101}.	
+	//	4) Analog Gain address is 0x003a. 
 	//			ex)	0x0000 = x1, 0x7000 = x8, 0xf000 = x16
 	//
 	/////////////////////////////////////////////////////////////////////////
@@ -2328,14 +2328,14 @@ static void sensor_init(void)
 	write_cmos_sensor(0x0138, 0x0004); //pxl_drv_pwr
 	write_cmos_sensor(0x013A, 0x0100); //tx_idle
 	write_cmos_sensor(0x0C00, 0x3BC1); //BLC_ctl1. Line BLC on = 0x3b, off = 0x2A //LBLC_ctl1. [0]en_blc, [1]en_lblc_dpc, [2]en_channel_blc, [3]en_adj_pxl_dpc, [4]en_adp_dead_pxl_th
-	write_cmos_sensor(0x0C0E, 0x0500); //0x07 BLC display On, 0x05 BLC D off //BLC_ctl3. Frame BLC On = 0x05, off=0x04 //FBLC_ctl3. [0]en_fblc, [1]en_blc_bypass, [2]en_fblc_dpc, [5]en_fobp_dig_offset, [7]en_lobp_dpc_bypass
+	write_cmos_sensor(0x0C0E, 0x0500); //0x07 BLC display On, 0x05 BLC D off //BLC_ctl3. Frame BLC On = 0x05, off=0x04 //FBLC_ctl3. [0]en_fblc, [1]en_blc_bypass, [2]en_fblc_dpc, [5]en_fobp_dig_offset, [7]en_lobp_dpc_bypass 
 	write_cmos_sensor(0x0C10, 0x0510); //dig_blc_offset_h
 	write_cmos_sensor(0x0C16, 0x0000); //fobp_dig_b_offset. red b[7] sign(0:+,1:-), b[6:0] dc offset 128(max)
 	write_cmos_sensor(0x0C18, 0x0000); //fobp_dig_Gb_offset. Gr b[7] sign(0:+,1:-), b[6:0] dc offset 128(max)
 	write_cmos_sensor(0x0C36, 0x0100); //r_g_sum_ctl. [0]:g_sum_en. '1'enable, '0'disable.
 
 	//--- MIPI blank time --------------//
-	write_cmos_sensor(0x0902, 0x4101); //mipi_value_clk_trail. MIPI CLK mode [1]'1'cont(0x43),'0'non-cont(0x41) [6]'1'2lane(0x41), '0'1lane(0x01)
+	write_cmos_sensor(0x0902, 0x4101); //mipi_value_clk_trail. MIPI CLK mode [1]'1'cont(0x43),'0'non-cont(0x41) [6]'1'2lane(0x41), '0'1lane(0x01) 
 	write_cmos_sensor(0x090A, 0x03E4); //mipi_vblank_delay_h.
 	write_cmos_sensor(0x090C, 0x0020); //mipi_hblank_short_delay_h.
 	write_cmos_sensor(0x090E, 0x0020); //mipi_hblank_long_delay_h.
@@ -2355,9 +2355,9 @@ static void sensor_init(void)
 	write_cmos_sensor(0x0018, 0x0AD1); //x_addr_end_hact_h. 2769. 2769-170+1=2606
 	write_cmos_sensor(0x0020, 0x0700); //x_regin_sel
 	write_cmos_sensor(0x0022, 0x0004); //y_addr_start_fobp_h.
-	write_cmos_sensor(0x0028, 0x000B); //y_addr_end_fobp_h.
+	write_cmos_sensor(0x0028, 0x000B); //y_addr_end_fobp_h.  
 	write_cmos_sensor(0x0024, 0xFFFA); //y_addr_start_dummy_h.
-	write_cmos_sensor(0x002A, 0xFFFF); //y_addr_end_dummy_h.
+	write_cmos_sensor(0x002A, 0xFFFF); //y_addr_end_dummy_h.  
 	write_cmos_sensor(0x0026, 0x0012); //y_addr_start_vact_h. 18
 	write_cmos_sensor(0x002C, 0x07B5); //y_addr_end_vact_h.  1973. 1973-18+1=1956
 	write_cmos_sensor(0x0034, 0x0700); //Y_region_sel
@@ -2372,8 +2372,8 @@ static void sensor_init(void)
 
 	//----< Image FMT Size >--------------------//
 	//Image size 2604x1956
-	write_cmos_sensor(0x0110, 0x0A2C); //X_output_size_h
-	write_cmos_sensor(0x0112, 0x07A4); //Y_output_size_h
+	write_cmos_sensor(0x0110, 0x0A2C); //X_output_size_h     
+	write_cmos_sensor(0x0112, 0x07A4); //Y_output_size_h     
 	//------------------------------------------//
 
 	//----< Frame / Line Length >--------------//
@@ -2386,9 +2386,9 @@ static void sensor_init(void)
 	write_cmos_sensor(0x003C, 0x0000); //fixed frame off. b[0] '1'enable, '0'disable
 	write_cmos_sensor(0x0000, 0x0300); //orientation. [0]:x-flip, [1]:y-flip.
 	write_cmos_sensor(0x0500, 0x0000); //DGA_ctl.  b[1]'0'OTP_color_ratio_disable, '1' OTP_color_ratio_enable, b[2]'0'data_pedestal_en, '1'data_pedestal_dis.
-	write_cmos_sensor(0x0700, 0x0590); //Scaler Normal
-	write_cmos_sensor(0x001E, 0x0101);
-	write_cmos_sensor(0x0032, 0x0101);
+	write_cmos_sensor(0x0700, 0x0590); //Scaler Normal 
+	write_cmos_sensor(0x001E, 0x0101); 
+	write_cmos_sensor(0x0032, 0x0101); 
 	write_cmos_sensor(0x0A02, 0x0100); // Fast sleep Enable
 	write_cmos_sensor(0x0116, 0x003B); // FBLC Ratio
 	//----------------//
@@ -2407,7 +2407,7 @@ static void sensor_init(void)
 
 	//-----< Exp.Time >------------------------//
 	// Pclk_88Mhz @ Line_length_pclk : 2880 @Exp.Time 33.33ms
-	write_cmos_sensor(0x0002, 0x04b0);	//Fine_int : 33.33ms@Pclk88mhz@Line_length2880
+	write_cmos_sensor(0x0002, 0x04b0);	//Fine_int : 33.33ms@Pclk88mhz@Line_length2880 
 	write_cmos_sensor(0x0004, 0x04b0); //coarse_int : 33.33ms@Pclk88mhz@Line_length2880
 
 	//--- ISP enable Selection ---------------//
@@ -2419,8 +2419,7 @@ static void sensor_init(void)
 
 
 static void preview_setting(void)
-{
-#if 0       // original preview setting
+{ 
 	//////////////////////////////////////////////////////////////////////////
 	//			Sensor        	 : Hi-545
 	//      Set Name         : Preview
@@ -2438,11 +2437,11 @@ static void preview_setting(void)
 	write_cmos_sensor(0x0B16, 0x4A8B); //140718 sys_clk 1/2
 	write_cmos_sensor(0x0B18, 0x0000); //140718
 	write_cmos_sensor(0x0B1A, 0x1044); //140718
-	write_cmos_sensor(0x004C, 0x0100);
-	write_cmos_sensor(0x000C, 0x0000);
+	write_cmos_sensor(0x004C, 0x0100); 
+	write_cmos_sensor(0x000C, 0x0000); 
 
 	//---< mipi time >---//
-	write_cmos_sensor(0x0902, 0x4101); //mipi_value_clk_trail.
+	write_cmos_sensor(0x0902, 0x4101); //mipi_value_clk_trail.  
 	write_cmos_sensor(0x090A, 0x01E4); //mipi_vblank_delay_h.
 	write_cmos_sensor(0x090C, 0x0005); //mipi_hblank_short_delay_h.
 	write_cmos_sensor(0x090E, 0x0100); //mipi_hblank_long_delay_h.
@@ -2459,19 +2458,19 @@ static void preview_setting(void)
 	write_cmos_sensor(0x002C, 0x07AF); //y_addr_end_vact_h.   1967. 1967-24+1=1944
 
 	//---< Crop size : 2592x1944 >----//
-	write_cmos_sensor(0x0128, 0x0002); // digital_crop_x_offset_l
-	write_cmos_sensor(0x012A, 0x0000); // digital_crop_y_offset_l
-	write_cmos_sensor(0x012C, 0x0A20); // digital_crop_image_width
+	write_cmos_sensor(0x0128, 0x0002); // digital_crop_x_offset_l  
+	write_cmos_sensor(0x012A, 0x0000); // digital_crop_y_offset_l  
+	write_cmos_sensor(0x012C, 0x0A20); // digital_crop_image_width 
 	write_cmos_sensor(0x012E, 0x0798); // digital_crop_image_height
 
 	//---< FMT Size : 1296x972 >---------//
-	write_cmos_sensor(0x0110, 0x0510); //X_output_size_h
-	write_cmos_sensor(0x0112, 0x03CC); //Y_output_size_h
+	write_cmos_sensor(0x0110, 0x0510); //X_output_size_h 
+	write_cmos_sensor(0x0112, 0x03CC); //Y_output_size_h 
 
 	//---< Frame/Line Length >-----//
 //	write_cmos_sensor(0x0006, 0x07e1); //frame_length_h 2017
 //	write_cmos_sensor(0x0008, 0x0B40); //line_length_h 2880
-	write_cmos_sensor(0x000A, 0x0DB0);
+	write_cmos_sensor(0x000A, 0x0DB0); 
 
 	//---< ETC set >---------------//
 //	write_cmos_sensor(0x0000, 0x0100); //orientation. [0]:x-flip, [1]:y-flip.
@@ -2481,17 +2480,14 @@ static void preview_setting(void)
 	write_cmos_sensor(0x0A02, 0x0100); //140718 Fast sleep Enable
 	write_cmos_sensor(0x0A04, 0x0133); //TEST PATTERN
 
-	write_cmos_sensor(0x0118, 0x0100); //sleep Off
-	//mDELAY(30);       // for faster
-#else
-    capture_setting(300);
-#endif
+	write_cmos_sensor(0x0118, 0x0100); //sleep Off 
+	mDELAY(50);
 }    /*    preview_setting  */
 
 static void capture_setting(kal_uint16 currefps)
 {
     LOG_INF("E! currefps:%d\n",currefps);
-    if (currefps == 240) { //24fps for PIP
+    if (currefps == 150) { //24fps for PIP
 		//////////////////////////////////////////////////////////////////////////
 		//			Sensor        	 : Hi-545
 		//      Set Name         : Capture
@@ -2506,54 +2502,45 @@ static void capture_setting(kal_uint16 currefps)
 
 		//--- SREG ---//
 		write_cmos_sensor(0x0B02, 0x0014); //140718
-		write_cmos_sensor(0x0B16, 0x4A0B);
+		write_cmos_sensor(0x0B16, 0x4A0B); 
 		write_cmos_sensor(0x0B18, 0x0000); //140718
 		write_cmos_sensor(0x0B1A, 0x1044); //140718
-		write_cmos_sensor(0x004C, 0x0100);
-		write_cmos_sensor(0x000C, 0x0000);
+		write_cmos_sensor(0x004C, 0x0100); 
+		write_cmos_sensor(0x000C, 0x0000); 
 
 		//---< mipi time >---//
-		write_cmos_sensor(0x0902, 0x4101);
-		write_cmos_sensor(0x090A, 0x03E4);
-		write_cmos_sensor(0x090C, 0x0020);
-		write_cmos_sensor(0x090E, 0x0020);
-		write_cmos_sensor(0x0910, 0x5D07);
-		write_cmos_sensor(0x0912, 0x061e);
-		write_cmos_sensor(0x0914, 0x0407);
-		write_cmos_sensor(0x0916, 0x0b0a);
-		write_cmos_sensor(0x0918, 0x0e09);
+		write_cmos_sensor(0x0902, 0x4101); 
+		write_cmos_sensor(0x090A, 0x03E4); 
+		write_cmos_sensor(0x090C, 0x0020); 
+		write_cmos_sensor(0x090E, 0x0020); 
+		write_cmos_sensor(0x0910, 0x5D07); 
+		write_cmos_sensor(0x0912, 0x061e); 
+		write_cmos_sensor(0x0914, 0x0407); 
+		write_cmos_sensor(0x0916, 0x0b0a); 
+		write_cmos_sensor(0x0918, 0x0e09); 
 
 		//---< Pixel Array Address >------//
 		write_cmos_sensor(0x0012, 0x00AA); //x_addr_start_hact_h. 170
-		write_cmos_sensor(0x0018, 0x0ACB); //x_addr_end_hact_h. 2763 . 2763-170+1=2594
-		write_cmos_sensor(0x0026, 0x0018); //y_addr_start_vact_h. 24
-		write_cmos_sensor(0x002C, 0x07AF); //y_addr_end_vact_h.   1967. 1967-24+1=1944
 
 		//---< Crop size : 2592x1944 >----//
-		write_cmos_sensor(0x0128, 0x0002); //digital_crop_x_offset_l
-		write_cmos_sensor(0x012A, 0x0000); //digital_crop_y_offset_l
-		write_cmos_sensor(0x012C, 0x0A20); //2592 digital_crop_image_width
-		write_cmos_sensor(0x012E, 0x0798); //1944 digital_crop_image_height
+		write_cmos_sensor(0x0128, 0x0002); //digital_crop_x_offset_l  
 
 		//---< FMT Size : 2592x1944 >---------//
-		write_cmos_sensor(0x0110, 0x0A20); //X_output_size_h
-		write_cmos_sensor(0x0112, 0x0798); //Y_output_size_h
+		write_cmos_sensor(0x0110, 0x0A20); //X_output_size_h 
+		write_cmos_sensor(0x0112, 0x0798); //Y_output_size_h 
 
 		//---< Frame/Line Length >-----//
-		write_cmos_sensor(0x0006, 0x07e1); //frame_length_h 2017
-		write_cmos_sensor(0x0008, 0x0B40); //line_length_h 2880
-		write_cmos_sensor(0x000A, 0x0DB0);
+	write_cmos_sensor(0x0006, 0x0FB5); //frame_length_h 4021 write_cmos_sensor(0x0008, 0x0B40); //line_length_h 2880 write_cmos_sensor(0x000A, 0x0DB0); 
 
 		//---< ETC set >---------------//
 //		write_cmos_sensor(0x0000, 0x0100); //orientation. [0]:x-flip, [1]:y-flip.
-		write_cmos_sensor(0x0700, 0x0590); //140718
+	write_cmos_sensor(0x0000, 0x0100); //orientation. [0]:x-flip, [1]:y-flip. write_cmos_sensor(0x0700, 0x0590); //140718
 		write_cmos_sensor(0x001E, 0x0101); //140718
 		write_cmos_sensor(0x0032, 0x0101); //140718
 		write_cmos_sensor(0x0A02, 0x0100); //140718 Fast sleep Enable
-		write_cmos_sensor(0x0A04, 0x011B); //TEST PATTERN enable
 
-		write_cmos_sensor(0x0118, 0x0100); //sleep Off
-		//mDELAY(30);       // for faster
+		write_cmos_sensor(0x0118, 0x0100); //sleep Off 		
+		mDELAY(30);
 
     } else {
 		//////////////////////////////////////////////////////////////////////////
@@ -2570,22 +2557,22 @@ static void capture_setting(kal_uint16 currefps)
 
 		//--- SREG ---//
 		write_cmos_sensor(0x0B02, 0x0014); //140718
-		write_cmos_sensor(0x0B16, 0x4A0B);
+		write_cmos_sensor(0x0B16, 0x4A0B); 
 		write_cmos_sensor(0x0B18, 0x0000); //140718
 		write_cmos_sensor(0x0B1A, 0x1044); //140718
-		write_cmos_sensor(0x004C, 0x0100);
-		write_cmos_sensor(0x000C, 0x0000);
+		write_cmos_sensor(0x004C, 0x0100); 
+		write_cmos_sensor(0x000C, 0x0000); 
 
 		//---< mipi time >---//
-		write_cmos_sensor(0x0902, 0x4101);
-		write_cmos_sensor(0x090A, 0x03E4);
-		write_cmos_sensor(0x090C, 0x0020);
-		write_cmos_sensor(0x090E, 0x0020);
-		write_cmos_sensor(0x0910, 0x5D07);
-		write_cmos_sensor(0x0912, 0x061e);
-		write_cmos_sensor(0x0914, 0x0407);
-		write_cmos_sensor(0x0916, 0x0b0a);
-		write_cmos_sensor(0x0918, 0x0e09);
+		write_cmos_sensor(0x0902, 0x4101); 
+		write_cmos_sensor(0x090A, 0x03E4); 
+		write_cmos_sensor(0x090C, 0x0020); 
+		write_cmos_sensor(0x090E, 0x0020); 
+		write_cmos_sensor(0x0910, 0x5D07); 
+		write_cmos_sensor(0x0912, 0x061e); 
+		write_cmos_sensor(0x0914, 0x0407); 
+		write_cmos_sensor(0x0916, 0x0b0a); 
+		write_cmos_sensor(0x0918, 0x0e09); 
 
 		//---< Pixel Array Address >------//
 		write_cmos_sensor(0x0012, 0x00AA); //x_addr_start_hact_h. 170
@@ -2594,19 +2581,19 @@ static void capture_setting(kal_uint16 currefps)
 		write_cmos_sensor(0x002C, 0x07AF); //y_addr_end_vact_h.   1967. 1967-24+1=1944
 
 		//---< Crop size : 2592x1944 >----//
-		write_cmos_sensor(0x0128, 0x0002); //digital_crop_x_offset_l
-		write_cmos_sensor(0x012A, 0x0000); //digital_crop_y_offset_l
-		write_cmos_sensor(0x012C, 0x0A20); //2592 digital_crop_image_width
-		write_cmos_sensor(0x012E, 0x0798); //1944 digital_crop_image_height
+		write_cmos_sensor(0x0128, 0x0002); //digital_crop_x_offset_l  
+		write_cmos_sensor(0x012A, 0x0000); //digital_crop_y_offset_l  
+		write_cmos_sensor(0x012C, 0x0A20); //2592 digital_crop_image_width 
+		write_cmos_sensor(0x012E, 0x0798); //1944 digital_crop_image_height 
 
 		//---< FMT Size : 2592x1944 >---------//
-		write_cmos_sensor(0x0110, 0x0A20); //X_output_size_h
-		write_cmos_sensor(0x0112, 0x0798); //Y_output_size_h
+		write_cmos_sensor(0x0110, 0x0A20); //X_output_size_h 
+		write_cmos_sensor(0x0112, 0x0798); //Y_output_size_h 
 
 		//---< Frame/Line Length >-----//
 		write_cmos_sensor(0x0006, 0x07e1); //frame_length_h 2017
 		write_cmos_sensor(0x0008, 0x0B40); //line_length_h 2880
-		write_cmos_sensor(0x000A, 0x0DB0);
+		write_cmos_sensor(0x000A, 0x0DB0); 
 
 		//---< ETC set >---------------//
 //		write_cmos_sensor(0x0000, 0x0100); //orientation. [0]:x-flip, [1]:y-flip.
@@ -2616,8 +2603,8 @@ static void capture_setting(kal_uint16 currefps)
 		write_cmos_sensor(0x0A02, 0x0100); //140718 Fast sleep Enable
 		write_cmos_sensor(0x0A04, 0x011B); //TEST PATTERN enable
 
-		write_cmos_sensor(0x0118, 0x0100); //sleep Off
-		//mDELAY(30);       // for faster
+		write_cmos_sensor(0x0118, 0x0100); //sleep Off 		
+		mDELAY(30);
 	}
 
 }
@@ -2625,7 +2612,7 @@ static void capture_setting(kal_uint16 currefps)
 static void normal_video_setting(kal_uint16 currefps)
 {
 	LOG_INF("E! currefps:%d\n",currefps);
-
+	
 	//////////////////////////////////////////////////////////////////////////
 	//			Sensor			 : Hi-545
 	//		Set Name		 : Preview
@@ -2643,11 +2630,11 @@ static void normal_video_setting(kal_uint16 currefps)
 	write_cmos_sensor(0x0B16, 0x4A8B); //140718 sys_clk 1/2
 	write_cmos_sensor(0x0B18, 0x0000); //140718
 	write_cmos_sensor(0x0B1A, 0x1044); //140718
-	write_cmos_sensor(0x004C, 0x0100);
-	write_cmos_sensor(0x000C, 0x0000);
+	write_cmos_sensor(0x004C, 0x0100); 
+	write_cmos_sensor(0x000C, 0x0000); 
 
 	//---< mipi time >---//
-	write_cmos_sensor(0x0902, 0x4101); //mipi_value_clk_trail.
+	write_cmos_sensor(0x0902, 0x4101); //mipi_value_clk_trail.	
 	write_cmos_sensor(0x090A, 0x01E4); //mipi_vblank_delay_h.
 	write_cmos_sensor(0x090C, 0x0005); //mipi_hblank_short_delay_h.
 	write_cmos_sensor(0x090E, 0x0100); //mipi_hblank_long_delay_h.
@@ -2664,19 +2651,19 @@ static void normal_video_setting(kal_uint16 currefps)
 	write_cmos_sensor(0x002C, 0x07AF); //y_addr_end_vact_h.   1967. 1967-24+1=1944
 
 	//---< Crop size : 2592x1944 >----//
-	write_cmos_sensor(0x0128, 0x0002); // digital_crop_x_offset_l
-	write_cmos_sensor(0x012A, 0x0000); // digital_crop_y_offset_l
-	write_cmos_sensor(0x012C, 0x0A20); // digital_crop_image_width
+	write_cmos_sensor(0x0128, 0x0002); // digital_crop_x_offset_l  
+	write_cmos_sensor(0x012A, 0x0000); // digital_crop_y_offset_l  
+	write_cmos_sensor(0x012C, 0x0A20); // digital_crop_image_width 
 	write_cmos_sensor(0x012E, 0x0798); // digital_crop_image_height
 
 	//---< FMT Size : 1296x972 >---------//
-	write_cmos_sensor(0x0110, 0x0510); //X_output_size_h
-	write_cmos_sensor(0x0112, 0x03CC); //Y_output_size_h
+	write_cmos_sensor(0x0110, 0x0510); //X_output_size_h 
+	write_cmos_sensor(0x0112, 0x03CC); //Y_output_size_h 
 
 	//---< Frame/Line Length >-----//
 //	write_cmos_sensor(0x0006, 0x07e1); //frame_length_h 2017
 //	write_cmos_sensor(0x0008, 0x0B40); //line_length_h 2880
-	write_cmos_sensor(0x000A, 0x0DB0);
+	write_cmos_sensor(0x000A, 0x0DB0); 
 
 	//---< ETC set >---------------//
 //	write_cmos_sensor(0x0000, 0x0100); //orientation. [0]:x-flip, [1]:y-flip.
@@ -2686,9 +2673,9 @@ static void normal_video_setting(kal_uint16 currefps)
 	write_cmos_sensor(0x0A02, 0x0100); //140718 Fast sleep Enable
 	write_cmos_sensor(0x0A04, 0x0133); //TEST PATTERN
 
-	write_cmos_sensor(0x0118, 0x0100); //sleep Off
+	write_cmos_sensor(0x0118, 0x0100); //sleep Off 
 	mDELAY(30);
-
+		
 }
 
 static void hs_video_setting()
@@ -2702,57 +2689,57 @@ static void hs_video_setting()
 	//			set file				 : v0.36
 	//			Date						 : 20140718
 	//////////////////////////////////////////////////////////////////////////
-
+	
 	write_cmos_sensor(0x0118, 0x0000); //sleep On
-
+	
 	//--- SREG ---//
 	write_cmos_sensor(0x0B02, 0x0014); //140718
-	write_cmos_sensor(0x0B16, 0x4A0B);
+	write_cmos_sensor(0x0B16, 0x4A0B); 
 	write_cmos_sensor(0x0B18, 0x0000); //140718
 	write_cmos_sensor(0x0B1A, 0x1044); //140718
-	write_cmos_sensor(0x004C, 0x0100);
+	write_cmos_sensor(0x004C, 0x0100); 
 	write_cmos_sensor(0x000C, 0x0000);
-
+	
 	//---< mipi time >---//
-	write_cmos_sensor(0x0902, 0x4101);
-	write_cmos_sensor(0x090A, 0x03E4);
-	write_cmos_sensor(0x090C, 0x0020);
-	write_cmos_sensor(0x090E, 0x0020);
-	write_cmos_sensor(0x0910, 0x5D07);
-	write_cmos_sensor(0x0912, 0x061e);
-	write_cmos_sensor(0x0914, 0x0407);
-	write_cmos_sensor(0x0916, 0x0b0a);
-	write_cmos_sensor(0x0918, 0x0e09);
-
+	write_cmos_sensor(0x0902, 0x4101); 
+	write_cmos_sensor(0x090A, 0x03E4); 
+	write_cmos_sensor(0x090C, 0x0020); 
+	write_cmos_sensor(0x090E, 0x0020); 
+	write_cmos_sensor(0x0910, 0x5D07); 
+	write_cmos_sensor(0x0912, 0x061e); 
+	write_cmos_sensor(0x0914, 0x0407); 
+	write_cmos_sensor(0x0916, 0x0b0a); 
+	write_cmos_sensor(0x0918, 0x0e09); 
+	
 	//---< Pixel Array Address >------//
 	write_cmos_sensor(0x0012, 0x00AA); //x_addr_start_hact_h.	// 164 + 6 = 170
-	write_cmos_sensor(0x0018, 0x0ACD); //x_addr_end_hact_h. 	// 2771 - 6 = 2765
+	write_cmos_sensor(0x0018, 0x0ACD); //x_addr_end_hact_h. 	// 2771 - 6 = 2765 
 	write_cmos_sensor(0x0026, 0x0012); //y_addr_start_vact_h.	// 16 + 2 = 18 (0x12)
 	write_cmos_sensor(0x002C, 0x07B1); //y_addr_end_vact_h. 	// 1971 - 2 = 1969 (0x7B1)
-
+	
 	//---< Crop size : 648x488 >----//
 	write_cmos_sensor(0x0128, 0x0002); // digital_crop_x_offset_l
 	write_cmos_sensor(0x012A, 0x0000); // digital_crop_y_offset_l
 	write_cmos_sensor(0x012C, 0x0510); // digital_crop_image_width	// 1296 (0x510)
 	write_cmos_sensor(0x012E, 0x01E8); // digital_crop_image_height // VGA = 488 (0x1E8)
-
+	
 	//---< FMT Size : 648x488 >---------//
 	write_cmos_sensor(0x0110, 0x0288); //X_output_size_h	// 648
 	write_cmos_sensor(0x0112, 0x01E8); //Y_output_size_h	// 488
-
+	
 	//---< Frame/Line Length >-----//
 	write_cmos_sensor(0x0006, 0x01FA); //frame_length_h 1984 - 1956 = 28 --> 488 + 18 = 506(0x1FA) for frame rate
 	write_cmos_sensor(0x0008, 0x0B40); //line_length_h 2880
 	write_cmos_sensor(0x000A, 0x0DB0); //line_length for binning 3504
-
+	
 	//---< ETC set >---------------//
-//	write_cmos_sensor(0x0000, 0x0000);
+//	write_cmos_sensor(0x0000, 0x0000); 
 	write_cmos_sensor(0x0700, 0x215A); // Scaler b[7:6] r_byrscl_y_ratio, b[5:4] r_byrscl_x_ratio [ '01' 3/4 scale down, '10' 1/2 scale down]
 	write_cmos_sensor(0x001E, 0x0301); //140718
 	write_cmos_sensor(0x0032, 0x0701); //140718
 	write_cmos_sensor(0x0A02, 0x0100); //140718 Fast sleep Enable
 	write_cmos_sensor(0x0A04, 0x013B); //TEST PATTERN enable
-
+	
 	write_cmos_sensor(0x0118, 0x0100); //sleep Off = Streaming On
 
 	mDELAY(30);
@@ -2779,11 +2766,11 @@ static void slim_video_setting()
 	write_cmos_sensor(0x0B16, 0x4A8B); //140718 sys_clk 1/2
 	write_cmos_sensor(0x0B18, 0x0000); //140718
 	write_cmos_sensor(0x0B1A, 0x1044); //140718
-	write_cmos_sensor(0x004C, 0x0100);
-	write_cmos_sensor(0x000C, 0x0000);
+	write_cmos_sensor(0x004C, 0x0100); 
+	write_cmos_sensor(0x000C, 0x0000); 
 
 	//---< mipi time >---//
-	write_cmos_sensor(0x0902, 0x4101); //mipi_value_clk_trail.
+	write_cmos_sensor(0x0902, 0x4101); //mipi_value_clk_trail.	
 	write_cmos_sensor(0x090A, 0x01E4); //mipi_vblank_delay_h.
 	write_cmos_sensor(0x090C, 0x0005); //mipi_hblank_short_delay_h.
 	write_cmos_sensor(0x090E, 0x0100); //mipi_hblank_long_delay_h.
@@ -2800,19 +2787,19 @@ static void slim_video_setting()
 	write_cmos_sensor(0x002C, 0x07AF); //y_addr_end_vact_h.   1967. 1967-24+1=1944
 
 	//---< Crop size : 2592x1944 >----//
-	write_cmos_sensor(0x0128, 0x0002); // digital_crop_x_offset_l
-	write_cmos_sensor(0x012A, 0x0000); // digital_crop_y_offset_l
-	write_cmos_sensor(0x012C, 0x0A20); // digital_crop_image_width
+	write_cmos_sensor(0x0128, 0x0002); // digital_crop_x_offset_l  
+	write_cmos_sensor(0x012A, 0x0000); // digital_crop_y_offset_l  
+	write_cmos_sensor(0x012C, 0x0A20); // digital_crop_image_width 
 	write_cmos_sensor(0x012E, 0x0798); // digital_crop_image_height
 
 	//---< FMT Size : 1296x972 >---------//
-	write_cmos_sensor(0x0110, 0x0510); //X_output_size_h
-	write_cmos_sensor(0x0112, 0x03CC); //Y_output_size_h
+	write_cmos_sensor(0x0110, 0x0510); //X_output_size_h 
+	write_cmos_sensor(0x0112, 0x03CC); //Y_output_size_h 
 
 	//---< Frame/Line Length >-----//
 //	write_cmos_sensor(0x0006, 0x07e1); //frame_length_h 2017
 //	write_cmos_sensor(0x0008, 0x0B40); //line_length_h 2880
-	write_cmos_sensor(0x000A, 0x0DB0);
+	write_cmos_sensor(0x000A, 0x0DB0); 
 
 	//---< ETC set >---------------//
 //	write_cmos_sensor(0x0000, 0x0100); //orientation. [0]:x-flip, [1]:y-flip.
@@ -2822,7 +2809,7 @@ static void slim_video_setting()
 	write_cmos_sensor(0x0A02, 0x0100); //140718 Fast sleep Enable
 	write_cmos_sensor(0x0A04, 0x0133); //TEST PATTERN
 
-	write_cmos_sensor(0x0118, 0x0100); //sleep Off
+	write_cmos_sensor(0x0118, 0x0100); //sleep Off 
 	mDELAY(30);
 
 }
@@ -2833,10 +2820,10 @@ static kal_uint32 set_test_pattern_mode(kal_bool enable)
     LOG_INF("enable: %d\n", enable);
 
     if (enable) {
-        write_cmos_sensor(0x020a,0x0200);
+        write_cmos_sensor(0x020a,0x0200);        
 
     } else {
-        write_cmos_sensor(0x020a,0x0000);
+        write_cmos_sensor(0x020a,0x0000); 
     }
     spin_lock(&imgsensor_drv_lock);
     imgsensor.test_pattern = enable;
@@ -2871,15 +2858,12 @@ static kal_uint32 get_imgsensor_id(UINT32 *sensor_id)
         spin_unlock(&imgsensor_drv_lock);
         do {
             *sensor_id = return_sensor_id();
-            if(*sensor_id == 0x545)
-            {
 				//*sensor_id = 0x544;
-            }
             if (*sensor_id == imgsensor_info.sensor_id) {
                 LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
                 return ERROR_NONE;
             }
-            LOG_INF("Read sensor id fail, write id: 0x%x, id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
+            LOG_INF("Read sensor id fail, write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
             retry--;
         } while(retry > 0);
         i++;
@@ -2916,13 +2900,9 @@ static kal_uint32 open(void)
     kal_uint8 retry = 2;
     kal_uint32 sensor_id = 0;
     LOG_1;
-    LOG_2;
+    LOG_2; 
 
-#if USE_I2C_400K
-    kdSetI2CSpeed(400);
-#else
     // do nothing, because default, uses 100K in kd_sensorlist.c
-#endif
 
     //sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
     while (imgsensor_info.i2c_addr_table[i] != 0xff) {
@@ -2931,10 +2911,7 @@ static kal_uint32 open(void)
         spin_unlock(&imgsensor_drv_lock);
         do {
             sensor_id = return_sensor_id();
-            if(sensor_id == 0x545)
-            {
             	//sensor_id = 0x544;
-            }
             if (sensor_id == imgsensor_info.sensor_id) {
                 LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
                 break;
@@ -3020,7 +2997,7 @@ static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
                       MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
 {
     LOG_INF("E\n");
-
+	
     spin_lock(&imgsensor_drv_lock);
     imgsensor.sensor_mode = IMGSENSOR_MODE_PREVIEW;
     imgsensor.pclk = imgsensor_info.pre.pclk;
@@ -3054,7 +3031,7 @@ static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
                           MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
 {
     LOG_INF("E\n");
-
+	
     spin_lock(&imgsensor_drv_lock);
     imgsensor.sensor_mode = IMGSENSOR_MODE_CAPTURE;
     if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {//PIP capture: 24fps for less than 13M, 20fps for 16M,15fps for 20M
@@ -3091,7 +3068,7 @@ static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
     //imgsensor.current_fps = 300;
     imgsensor.autoflicker_en = KAL_FALSE;
     spin_unlock(&imgsensor_drv_lock);
-    normal_video_setting(imgsensor.current_fps);
+    normal_video_setting(imgsensor.current_fps);	
 	set_mirror_flip(imgsensor.mirror);
     return ERROR_NONE;
 }    /*    normal_video   */
@@ -3112,7 +3089,7 @@ static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
     imgsensor.dummy_pixel = 0;
     imgsensor.autoflicker_en = KAL_FALSE;
     spin_unlock(&imgsensor_drv_lock);
-    hs_video_setting();
+    hs_video_setting();	
 	set_mirror_flip(imgsensor.mirror);
     return ERROR_NONE;
 }    /*    hs_video   */
@@ -3142,7 +3119,7 @@ static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 
 static kal_uint32 get_resolution(MSDK_SENSOR_RESOLUTION_INFO_STRUCT *sensor_resolution)
 {
-    LOG_INF("E %p\n", sensor_resolution);
+    LOG_INF("E\n");
     sensor_resolution->SensorFullWidth = imgsensor_info.cap.grabwindow_width;
     sensor_resolution->SensorFullHeight = imgsensor_info.cap.grabwindow_height;
 
@@ -3298,7 +3275,7 @@ static kal_uint32 control(MSDK_SCENARIO_ID_ENUM scenario_id, MSDK_SENSOR_EXPOSUR
 
 
 static kal_uint32 set_video_mode(UINT16 framerate)
-{
+{//
     LOG_INF("framerate = %d\n ", framerate);
     // SetVideoMode Function should fix framerate
     if (framerate == 0)
@@ -3438,272 +3415,7 @@ static kal_uint32 get_default_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenar
 }
 
 
-static int strcmp1(MUINT8 *s1, MUINT8 *s2)
-{
-	while(*s1 && *s2)
-	{
-		if(*s1 > *s2)
-			return 1;
-		else if(*s1 < *s2)
-			return -1;
-		else
-		{
-			++s1;
-			++s2;
-			continue;
-		}
-	}
-	if(*s1)
-		return 1;
-	if(*s2)
-		return -1;
-	return 0;
-}
 
-static void  debug_imgsensor(MSDK_SENSOR_FEATURE_ENUM feature_id,
-                             UINT8 *feature_para,UINT32 *feature_para_len)
-{
-	MSDK_SENSOR_DBG_IMGSENSOR_INFO_STRUCT *debug_info = (MSDK_SENSOR_DBG_IMGSENSOR_INFO_STRUCT *)feature_para;
-	if(strcmp1(debug_info->debugStruct, (MUINT8 *)"sensor_output_dataformat") == 0)
-	{
-		LOG_INF("enter sensor_output_dataformat\n");
-		if(debug_info->isGet == 1)
-			debug_info->value = imgsensor_info.sensor_output_dataformat;
-		else
-			imgsensor_info.sensor_output_dataformat = debug_info->value;
-	}
-	else if(strcmp1(debug_info->debugStruct, (MUINT8 *)"sensor_id") == 0)
-	{
-		if(debug_info->isGet == 1)
-			debug_info->value = imgsensor_info.sensor_id;
-		else
-			imgsensor_info.sensor_id = debug_info->value;
-	}
-	else if(strcmp1(debug_info->debugStruct, (MUINT8 *)"checksum_value") == 0)
-	{
-		if(debug_info->isGet == 1)
-			debug_info->value = imgsensor_info.checksum_value;
-		else
-			imgsensor_info.checksum_value = debug_info->value;
-	}
-	else if(strcmp1(debug_info->debugStruct, (MUINT8 *)"isp_driving_current") == 0)
-	{
-		if(debug_info->isGet == 1)
-			debug_info->value = imgsensor_info.isp_driving_current;
-		else
-			imgsensor_info.isp_driving_current = debug_info->value;
-	}
-	else if(strcmp1(debug_info->debugStruct, (MUINT8 *)"sensor_interface_type") == 0)
-	{
-		if(debug_info->isGet == 1)
-			debug_info->value = imgsensor_info.sensor_interface_type;
-		else
-			imgsensor_info.sensor_interface_type = debug_info->value;
-	}
-	else if(strcmp1(debug_info->debugStruct, (MUINT8 *)"mclk") == 0)
-	{
-		if(debug_info->isGet == 1)
-			debug_info->value = imgsensor_info.mclk;
-		else
-			imgsensor_info.mclk = debug_info->value;
-	}
-	else if(strcmp1(debug_info->debugStruct, (MUINT8 *)"mipi_lane_num") == 0)
-	{
-		if(debug_info->isGet == 1)
-			debug_info->value = imgsensor_info.mipi_lane_num;
-		else
-			imgsensor_info.mipi_lane_num = debug_info->value;
-	}
-	else if(strcmp1(debug_info->debugStruct, (MUINT8 *)"i2c_addr_table") == 0)	// just use the first address
-	{
-		if(debug_info->isGet == 1)
-			debug_info->value = imgsensor_info.i2c_addr_table[0];
-		else
-			imgsensor_info.i2c_addr_table[0] = debug_info->value;
-	}
-	else if(strcmp1(debug_info->debugStruct, (MUINT8 *)"mipi_sensor_type") == 0)
-	{
-		if(debug_info->isGet == 1)
-			debug_info->value = imgsensor_info.mipi_sensor_type;
-		else
-			imgsensor_info.mipi_sensor_type = debug_info->value;
-	}
-	else if(strcmp1(debug_info->debugStruct, (MUINT8 *)"mipi_settle_delay_mode") == 0)
-	{
-		if(debug_info->isGet == 1)
-			debug_info->value = imgsensor_info.mipi_settle_delay_mode;
-		else
-			imgsensor_info.mipi_settle_delay_mode = debug_info->value;
-	}
-	else if(strcmp1(debug_info->debugStruct, (MUINT8 *)"cap_delay_frame") == 0)
-	{
-		if(debug_info->isGet == 1)
-			debug_info->value = imgsensor_info.cap_delay_frame;
-		else
-			imgsensor_info.cap_delay_frame = debug_info->value;
-	}
-	else if(strcmp1(debug_info->debugStruct, (MUINT8 *)"pre_delay_frame") == 0)
-	{
-		if(debug_info->isGet == 1)
-			debug_info->value = imgsensor_info.pre_delay_frame;
-		else
-			imgsensor_info.pre_delay_frame = debug_info->value;
-	}
-	else if(strcmp1(debug_info->debugStruct, (MUINT8 *)"video_delay_frame") == 0)
-	{
-		if(debug_info->isGet == 1)
-			debug_info->value = imgsensor_info.video_delay_frame;
-		else
-			imgsensor_info.video_delay_frame = debug_info->value;
-	}
-	else if(strcmp1(debug_info->debugStruct, (MUINT8 *)"hs_video_delay_frame") == 0)
-	{
-		if(debug_info->isGet == 1)
-			debug_info->value = imgsensor_info.hs_video_delay_frame;
-		else
-			imgsensor_info.hs_video_delay_frame = debug_info->value;
-	}
-	else if(strcmp1(debug_info->debugStruct, (MUINT8 *)"slim_video_delay_frame") == 0)
-	{
-		if(debug_info->isGet == 1)
-			debug_info->value = imgsensor_info.slim_video_delay_frame;
-		else
-			imgsensor_info.slim_video_delay_frame = debug_info->value;
-	}
-	else if(strcmp1(debug_info->debugStruct, (MUINT8 *)"sensor_mode_num") == 0)
-	{
-		if(debug_info->isGet == 1)
-			debug_info->value = imgsensor_info.sensor_mode_num;
-		else
-			imgsensor_info.sensor_mode_num = debug_info->value;
-	}
-	else if(strcmp1(debug_info->debugStruct, (MUINT8 *)"ihdr_le_firstline") == 0)
-	{
-		if(debug_info->isGet == 1)
-			debug_info->value = imgsensor_info.ihdr_le_firstline;
-		else
-			imgsensor_info.ihdr_le_firstline = debug_info->value;
-	}
-	else if(strcmp1(debug_info->debugStruct, (MUINT8 *)"ihdr_support") == 0)
-	{
-		if(debug_info->isGet == 1)
-			debug_info->value = imgsensor_info.ihdr_support;
-		else
-			imgsensor_info.ihdr_support = debug_info->value;
-	}
-	else if(strcmp1(debug_info->debugStruct, (MUINT8 *)"ae_ispGain_delay_frame") == 0)
-	{
-		if(debug_info->isGet == 1)
-			debug_info->value = imgsensor_info.ae_ispGain_delay_frame;
-		else
-			imgsensor_info.ae_ispGain_delay_frame = debug_info->value;
-	}
-	else if(strcmp1(debug_info->debugStruct, (MUINT8 *)"ae_sensor_gain_delay_frame") == 0)
-	{
-		if(debug_info->isGet == 1)
-			debug_info->value = imgsensor_info.ae_sensor_gain_delay_frame;
-		else
-			imgsensor_info.ae_sensor_gain_delay_frame = debug_info->value;
-	}
-	else if(strcmp1(debug_info->debugStruct, (MUINT8 *)"ae_shut_delay_frame") == 0)
-	{
-		if(debug_info->isGet == 1)
-			debug_info->value = imgsensor_info.ae_shut_delay_frame;
-		else
-			imgsensor_info.ae_shut_delay_frame = debug_info->value;
-	}
-	else if(strcmp1(debug_info->debugStruct, (MUINT8 *)"max_frame_length") == 0)
-	{
-		if(debug_info->isGet == 1)
-			debug_info->value = imgsensor_info.max_frame_length;
-		else
-			imgsensor_info.max_frame_length = debug_info->value;
-	}
-	else if(strcmp1(debug_info->debugStruct, (MUINT8 *)"min_shutter") == 0)
-	{
-		if(debug_info->isGet == 1)
-			debug_info->value = imgsensor_info.min_shutter;
-		else
-			imgsensor_info.min_shutter = debug_info->value;
-	}
-	else if(strcmp1(debug_info->debugStruct, (MUINT8 *)"margin") == 0)
-	{
-		if(debug_info->isGet == 1)
-			debug_info->value = imgsensor_info.margin;
-		else
-			imgsensor_info.margin = debug_info->value;
-	}
-	else if(strcmp1(debug_info->debugStruct, (MUINT8 *)"pre") == 0)
-	{
-		if(strcmp1(debug_info->debugSubstruct, (MUINT8 *)"pclk") == 0)
-		{
-			if(debug_info->isGet == 1)
-				debug_info->value = imgsensor_info.pre.pclk;
-			else
-				imgsensor_info.pre.pclk = debug_info->value;
-		}
-		else if(strcmp1(debug_info->debugSubstruct, (MUINT8 *)"linelength") == 0)
-		{
-			if(debug_info->isGet == 1)
-				debug_info->value = imgsensor_info.pre.linelength;
-			else
-				imgsensor_info.pre.linelength = debug_info->value;
-		}
-		else if(strcmp1(debug_info->debugSubstruct, (MUINT8 *)"framelength") == 0)
-		{
-			if(debug_info->isGet == 1)
-				debug_info->value = imgsensor_info.pre.framelength;
-			else
-				imgsensor_info.pre.framelength = debug_info->value;
-		}
-		else if(strcmp1(debug_info->debugSubstruct, (MUINT8 *)"startx") == 0)
-		{
-			if(debug_info->isGet == 1)
-				debug_info->value = imgsensor_info.pre.startx;
-			else
-				imgsensor_info.pre.startx = debug_info->value;
-		}
-		else if(strcmp1(debug_info->debugSubstruct, (MUINT8 *)"starty") == 0)
-		{
-			if(debug_info->isGet == 1)
-				debug_info->value = imgsensor_info.pre.starty;
-			else
-				imgsensor_info.pre.starty = debug_info->value;
-		}
-		else if(strcmp1(debug_info->debugSubstruct, (MUINT8 *)"grabwindow_width") == 0)
-		{
-			if(debug_info->isGet == 1)
-				debug_info->value = imgsensor_info.pre.grabwindow_width;
-			else
-				imgsensor_info.pre.grabwindow_width = debug_info->value;
-		}
-		else if(strcmp1(debug_info->debugSubstruct, (MUINT8 *)"grabwindow_height") == 0)
-		{
-			if(debug_info->isGet == 1)
-				debug_info->value = imgsensor_info.pre.grabwindow_height;
-			else
-				imgsensor_info.pre.grabwindow_height = debug_info->value;
-		}
-		else if(strcmp1(debug_info->debugSubstruct, (MUINT8 *)"mipi_data_lp2hs_settle_dc") == 0)
-		{
-			if(debug_info->isGet == 1)
-				debug_info->value = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
-			else
-				imgsensor_info.pre.mipi_data_lp2hs_settle_dc = debug_info->value;
-		}
-		else if(strcmp1(debug_info->debugSubstruct, (MUINT8 *)"max_framerate") == 0)
-		{
-			if(debug_info->isGet == 1)
-				debug_info->value = imgsensor_info.pre.max_framerate;
-			else
-				imgsensor_info.pre.max_framerate = debug_info->value;
-		}
-	}
-	else
-	{
-		LOG_INF("unknown debug\n");
-	}
-}
 
 static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
                              UINT8 *feature_para,UINT32 *feature_para_len)
@@ -3714,21 +3426,19 @@ static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
     UINT32 *feature_data_32=(UINT32 *) feature_para;
 	unsigned long long *feature_data=(unsigned long long *) feature_para;
     unsigned long long *feature_return_para=(unsigned long long *) feature_para;
-
+	
     SENSOR_WINSIZE_INFO_STRUCT *wininfo;
     MSDK_SENSOR_REG_INFO_STRUCT *sensor_reg_data=(MSDK_SENSOR_REG_INFO_STRUCT *) feature_para;
 
-    LOG_INF("feature_id = %d\n", feature_id);
+    printk("feature_id = %d\n", feature_id);
     switch (feature_id) {
-		case SENSOR_FEATURE_DEBUG_IMGSENSOR:
-			debug_imgsensor(feature_id, feature_para, feature_para_len);
-			break;
         case SENSOR_FEATURE_GET_PERIOD:
             *feature_return_para_16++ = imgsensor.line_length;
             *feature_return_para_16 = imgsensor.frame_length;
             *feature_para_len=4;
             break;
         case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:
+            LOG_INF("feature_Control imgsensor.pclk = %d,imgsensor.current_fps = %d\n", imgsensor.pclk,imgsensor.current_fps);
             *feature_return_para_32 = imgsensor.pclk;
             *feature_para_len=4;
             break;
@@ -3770,7 +3480,7 @@ static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
             set_max_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data, *(feature_data+1));
             break;
         case SENSOR_FEATURE_GET_DEFAULT_FRAME_RATE_BY_SCENARIO:
-            get_default_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data, (MUINT32 *)(uintptr_t)(*(feature_data+1)));
+            get_default_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*(feature_data), (MUINT32 *)(uintptr_t)(*(feature_data+1)));
             break;
         case SENSOR_FEATURE_SET_TEST_PATTERN:
             set_test_pattern_mode((BOOL)*feature_data);
@@ -3780,7 +3490,6 @@ static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
             *feature_para_len=4;
             break;
         case SENSOR_FEATURE_SET_FRAMERATE:
-            LOG_INF("current fps :%d\n", (UINT32)*feature_data);
             spin_lock(&imgsensor_drv_lock);
             imgsensor.current_fps = *feature_data;
             spin_unlock(&imgsensor_drv_lock);
@@ -3788,11 +3497,11 @@ static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
         case SENSOR_FEATURE_SET_HDR:
             LOG_INF("ihdr enable :%d\n", (BOOL)*feature_data);
             spin_lock(&imgsensor_drv_lock);
-            imgsensor.ihdr_en = *feature_data;
+            imgsensor.ihdr_en = (BOOL)*feature_data;
             spin_unlock(&imgsensor_drv_lock);
             break;
         case SENSOR_FEATURE_GET_CROP_INFO:
-            LOG_INF("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n", (UINT32)*feature_data);
+
             wininfo = (SENSOR_WINSIZE_INFO_STRUCT *)(uintptr_t)(*(feature_data+1));
 
             switch (*feature_data_32) {
@@ -3813,7 +3522,6 @@ static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
                     memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[0],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
                     break;
             }
-            break;
         case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
             LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n", (UINT16)*feature_data, (UINT16)*(feature_data+1), (UINT16)*(feature_data+2));
             ihdr_write_shutter_gain((UINT16)*feature_data, (UINT16)*(feature_data+1), (UINT16)*(feature_data+2));
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/hi545_mipi_raw/hi545mipi_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/hi545_mipi_raw/hi545mipi_Sensor.h
old mode 100644
new mode 100755
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/imx145_mipi_raw/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx145_mipi_raw/Makefile
old mode 100644
new mode 100755
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/imx145_mipi_raw/imx145mipiraw_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx145_mipi_raw/imx145mipiraw_Sensor.c
old mode 100644
new mode 100755
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/imx145_mipi_raw/imx145mipiraw_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx145_mipi_raw/imx145mipiraw_Sensor.h
old mode 100644
new mode 100755
index fa8bc2b..1e57cff
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/imx145_mipi_raw/imx145mipiraw_Sensor.h
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx145_mipi_raw/imx145mipiraw_Sensor.h
@@ -36,7 +36,7 @@
  *
  * Filename:
  * ---------
- *   imx145mipiraw_sensor.h
+ *   imx175mipiraw_sensor.h
  *
  * Project:
  * --------
@@ -51,8 +51,8 @@
 
  *============================================================================
  ****************************************************************************/
-#ifndef _IMX145mipi_SENSOR_H
-#define _IMX145mipi_SENSOR_H
+#ifndef _IMX145MIPI_SENSOR_H
+#define _IMX145MIPI_SENSOR_H
 
 
 typedef enum{
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/imx164_mipi_raw/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx164_mipi_raw/Makefile
old mode 100644
new mode 100755
index 4fff5c9..c889220
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/imx164_mipi_raw/Makefile
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx164_mipi_raw/Makefile
@@ -1,2 +1,5 @@
 include $(srctree)/drivers/misc/mediatek/Makefile.custom
+
 obj-y += imx164mipiraw_Sensor.o
+
+
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/imx164_mipi_raw/imx164mipiraw_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx164_mipi_raw/imx164mipiraw_Sensor.c
old mode 100644
new mode 100755
index be21666..43acf40
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/imx164_mipi_raw/imx164mipiraw_Sensor.c
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx164_mipi_raw/imx164mipiraw_Sensor.c
@@ -2,7 +2,7 @@
  *
  * Filename:
  * ---------
- *	 imx152mipi_Sensor.c
+ *	 imx164mipi_Sensor.c
  *
  * Project:
  * --------
@@ -26,7 +26,7 @@
 #include <linux/uaccess.h>
 #include <linux/fs.h>
 #include <asm/atomic.h>
-#include "system.h"
+//#include <asm/system.h>
 #include <linux/xlog.h>
 
 #include "kd_camera_hw.h"
@@ -37,8 +37,8 @@
 #include "imx164mipiraw_Sensor.h"
 
 /****************************Modify following Strings for debug****************************/
-#define PFX "IMX164_camera_sensor"
-#define LOG_1 LOG_INF("IMX164,MIPI 4LANE\n")
+#define PFX "imx164_camera_sensor"
+#define LOG_1 LOG_INF("imx164,MIPI 2LANE\n")
 #define LOG_2 LOG_INF("preview 1280*960@30fps,864Mbps/lane; video 1280*960@30fps,864Mbps/lane; capture 5M@30fps,864Mbps/lane\n")
 /****************************   Modify end    *******************************************/
 
@@ -53,75 +53,75 @@ static imgsensor_info_struct imgsensor_info = {
 	.checksum_value = 0x9e08861c,		//checksum value for Camera Auto Test
 	
 	.pre = {
-		.pclk = 265714286,				//record different mode's pclk
-		.linelength = 0xDD8,				//record different mode's linelength
-		.framelength = 0x9BF,			//record different mode's framelength
-		.startx = 0,					//record different mode's startx of grabwindow
-		.starty = 0,					//record different mode's starty of grabwindow
-		.grabwindow_width = 1632,		//record different mode's width of grabwindow
-		.grabwindow_height = 1224,		//record different mode's height of grabwindow
+		.pclk = 259200000,				//record different mode's pclk
+		.linelength = 0xf54,				//record different mode's linelength
+		.framelength = 0xc44,			//record different mode's framelength
+		.startx = 8,					//record different mode's startx of grabwindow
+		.starty = 8,					//record different mode's starty of grabwindow
+		.grabwindow_width = 1600,		//record different mode's width of grabwindow
+		.grabwindow_height = 1200,		//record different mode's height of grabwindow
 		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
 		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
 		/*	 following for GetDefaultFramerateByScenario()	*/
 		.max_framerate = 300,	
 	},
 	.cap = {
-		.pclk = 265800000,
-		.linelength = 0xDD8,
-		.framelength = 0x9C0,
-		.startx = 0,
-		.starty = 0,
-		.grabwindow_width = 3264,
-		.grabwindow_height = 2448,
+		.pclk = 259200000,
+		.linelength = 0x1b70,
+		.framelength = 0xc44,
+		.startx = 16,
+		.starty = 16,
+		.grabwindow_width = 3200,
+		.grabwindow_height = 2400,
 		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
 		.max_framerate = 300,
 	},
 	.cap1 = {							//capture for PIP 24fps relative information, capture1 mode must use same framelength, linelength with Capture mode for shutter calculate
-		.pclk = 212640000,
-		.linelength = 0xDD8,
-		.framelength = 0x9C0,
-		.startx = 0,
-		.starty = 0,
-		.grabwindow_width = 3264,
-		.grabwindow_height = 2448,
+		.pclk = 259200000,
+		.linelength = 0x1b70,
+		.framelength = 0xc44,
+		.startx = 16,
+		.starty = 16,
+		.grabwindow_width = 3200,
+		.grabwindow_height = 2400,
 		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
 		.max_framerate = 240,	//less than 13M(include 13M),cap1 max framerate is 24fps,16M max framerate is 20fps, 20M max framerate is 15fps  
 	},
 	.normal_video = {
-		.pclk = 265800000,
-		.linelength = 0xDD8,
-		.framelength = 0x9C0,
-		.startx = 4,
-		.starty = 4,
-		.grabwindow_width = 3264,
-		.grabwindow_height = 2448,
+		.pclk = 259200000,
+		.linelength = 0x1b70,
+		.framelength = 0xc44,
+		.startx = 16,
+		.starty = 16,
+		.grabwindow_width = 3200,
+		.grabwindow_height = 2400,
 		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
 		.max_framerate = 300,
 	},
 	.hs_video = {
-		.pclk = 265714286,
-		.linelength = 0xEF8,
-		.framelength = 0x483,
-		.startx = 0,
-		.starty = 0,
-		.grabwindow_width = 1280,
-		.grabwindow_height = 720,
+		.pclk = 259200000,
+		.linelength = 0xf54,
+		.framelength = 0x48e,
+		.startx = 8,
+		.starty = 8,
+		.grabwindow_width = 1920,
+		.grabwindow_height = 1080,
 		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
 		.max_framerate = 600,
 	},
 	.slim_video = {
-		.pclk = 265714286,
-		.linelength = 0xEF8,
-		.framelength = 0x483,
-		.startx = 0,
-		.starty = 0,
+		.pclk = 265600000,
+		.linelength = 0xf54,
+		.framelength = 0x85c,
+		.startx = 8,
+		.starty = 8,
 		.grabwindow_width = 1280,
 		.grabwindow_height = 720,
 		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
-		.max_framerate = 600,
+		.max_framerate = 300,
 
 	},
-	.margin = 16,			//sensor framelength & shutter margin
+	.margin = 5,			//sensor framelength & shutter margin
 	.min_shutter = 2,		//min shutter
 	.max_frame_length = 0xffff,//max framelength by sensor register's limitation
 	.ae_shut_delay_frame = 0,	//shutter delay frame for AE cycle, 2 frame with ispGain_delay-shut_delay=2-0=2
@@ -131,17 +131,17 @@ static imgsensor_info_struct imgsensor_info = {
 	.ihdr_le_firstline = 0,  //1,le first ; 0, se first
 	.sensor_mode_num = 5,	  //support sensor mode num
 	
-	.cap_delay_frame = 3,		//enter capture delay frame num
-	.pre_delay_frame = 3, 		//enter preview delay frame num
-	.video_delay_frame = 3,		//enter video delay frame num
-	.hs_video_delay_frame = 3,	//enter high speed video  delay frame num
-	.slim_video_delay_frame = 3,//enter slim video delay frame num
+	.cap_delay_frame = 2,		//enter capture delay frame num
+	.pre_delay_frame = 2, 		//enter preview delay frame num
+	.video_delay_frame = 2,		//enter video delay frame num
+	.hs_video_delay_frame = 2,	//enter high speed video  delay frame num
+	.slim_video_delay_frame = 2,//enter slim video delay frame num
 	
 	.isp_driving_current = ISP_DRIVING_8MA, //mclk driving current
 	.sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,//sensor_interface_type
 	.mipi_sensor_type = MIPI_OPHY_NCSI2, //0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2
 	.mipi_settle_delay_mode = 1,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
-	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_R,//sensor output first pixel color
+	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_B,//sensor output first pixel color
 	.mclk = 24,//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
 	.mipi_lane_num = SENSOR_MIPI_4_LANE,//mipi lane num
 	.i2c_addr_table = {0x21, 0x20, 0xff},//record sensor support all write id addr, only supprt 4must end with 0xff
@@ -166,11 +166,11 @@ static imgsensor_struct imgsensor = {
 
 /* Sensor output window information */
 static SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[5] =	 
-{{ 3280, 2464,	0, 	0, 3280, 2464, 1640, 1232, 0, 0, 1640, 1232,		2,	2, 1632,  1224}, // Preview 
- { 3280, 2464,	0,	0, 3280, 2464, 3280, 2464, 0, 0, 3280, 2464,	4,	4, 3264, 2448}, // capture 
- { 3280, 2464,	0,	0, 3280, 2464, 3280, 2464, 0, 0, 3280, 2464,	4,	4, 3264, 2448},  // video 
- { 3280, 2464,	0,  0, 3280, 2464, 1920, 1080, 0, 0, 1920, 1080,	0,	0, 1920, 1080}, //hight speed video 
- { 3280, 2464,	0,  0, 3280, 2464, 1640,  926, 0, 0, 1640,  926,	0,	0, 1280,  720}};// slim video 
+{{ 3280, 2464,	0, 	0, 3280, 2464, 1640, 1232, 0, 0, 1640, 1232,		8,	8, 1600,  1200}, // Preview 
+ { 3280, 2464,	0,	0, 3280, 2464, 3280, 2464, 0, 0, 3280, 2464,	16,	16, 3200, 2400}, // capture 
+ { 3280, 2464,	0,	0, 3280, 2464, 3280, 2464, 0, 0, 3280, 2464,	16,	16, 3200, 2400},  // video 
+ { 3280, 2464,	0,  0, 3280, 2464, 1920, 1080, 0, 0, 1920, 1080,	8,	8, 1920, 1080}, //hight speed video 
+ { 3280, 2464,	0,  0, 3280, 2464, 1640,  926, 0, 0, 1640,  926,	8,	8, 1280,  720}};// slim video 
 
 
 #define IMX164MIPI_MaxGainIndex (97)
@@ -295,22 +295,24 @@ static void set_dummy()
 {
 	LOG_INF("dummyline = %d, dummypixels = %d \n", imgsensor.dummy_line, imgsensor.dummy_pixel);
 	/* you can set dummy by imgsensor.dummy_line and imgsensor.dummy_pixel, or you can set dummy by imgsensor.frame_length and imgsensor.line_length */
-    write_cmos_sensor(0x0104, 1); 
-    write_cmos_sensor(0x0340, (imgsensor.frame_length >>8) & 0xFF);
-    write_cmos_sensor(0x0341, imgsensor.frame_length & 0xFF);	
-    write_cmos_sensor(0x0342, (imgsensor.line_length >>8) & 0xFF);
-    write_cmos_sensor(0x0343, imgsensor.line_length & 0xFF);
-    write_cmos_sensor(0x0104, 0); 
+	write_cmos_sensor(0x0104, 1); 
+	write_cmos_sensor(0x0160, (imgsensor.frame_length >>8) & 0xFF);
+  write_cmos_sensor(0x0161, imgsensor.frame_length & 0xFF);	
+  write_cmos_sensor(0x0162, (imgsensor.line_length >>8) & 0xFF);
+  write_cmos_sensor(0x0163, imgsensor.line_length & 0xFF);
+  write_cmos_sensor(0x0104, 0);
   
 }	/*	set_dummy  */
 
 static kal_uint32 return_sensor_id()
 {
-	return ((read_cmos_sensor(0x0016) << 8) | read_cmos_sensor(0x0017));
-	//int sensorid;
-	//sensorid =  ((read_cmos_sensor(0x0000) << 8) | read_cmos_sensor(0x0001));
-	//LOG_INF("read sensor id:%x", sensorid);
-	//return 0x0152;
+	return ((read_cmos_sensor(0x0000) << 8) | read_cmos_sensor(0x0001));
+	/*
+	int sensorid;
+	sensorid =  ((read_cmos_sensor(0x0000) << 8) | read_cmos_sensor(0x0001));
+	printk("IMX164 read sensor id:0x%x", sensorid);
+	return sensorid;
+	*/
 }
 static void set_max_framerate(UINT16 framerate,kal_bool min_framelength_en)
 {
@@ -353,6 +355,7 @@ static void write_shutter(kal_uint16 shutter)
 	// OV Recommend Solution
 	// if shutter bigger than frame_length, should extend frame length first
 	spin_lock(&imgsensor_drv_lock);
+	shutter = shutter * 14 / 10;
 	if (shutter > imgsensor.min_frame_length - imgsensor_info.margin)		
 		imgsensor.frame_length = shutter + imgsensor_info.margin;
 	else
@@ -375,24 +378,18 @@ static void write_shutter(kal_uint16 shutter)
 			set_max_framerate(146,0);	
 		else {
 		// Extend frame length
-       	write_cmos_sensor(0x0104, 1); 
-		write_cmos_sensor(0x0340, imgsensor.frame_length >> 8);
-		write_cmos_sensor(0x0341, imgsensor.frame_length & 0xFF);
-		write_cmos_sensor(0x0104, 0); 
+		write_cmos_sensor(0x0160, imgsensor.frame_length >> 8);
+		write_cmos_sensor(0x0161, imgsensor.frame_length & 0xFF);
 		}
 	} else {
 		// Extend frame length
-		write_cmos_sensor(0x0104, 1); 
-		write_cmos_sensor(0x0340, imgsensor.frame_length >> 8);
-		write_cmos_sensor(0x0341, imgsensor.frame_length & 0xFF);
-		write_cmos_sensor(0x0104, 0); 
+		write_cmos_sensor(0x0160, imgsensor.frame_length >> 8);
+		write_cmos_sensor(0x0161, imgsensor.frame_length & 0xFF);
 	}
 
 	// Update Shutter
-	write_cmos_sensor(0x0104, 1); 
-	write_cmos_sensor(0x0202, (shutter >> 8) & 0xFF);
-	write_cmos_sensor(0x0203, (shutter ) & 0xFF);
-	write_cmos_sensor(0x0104, 0); 
+	write_cmos_sensor(0x015a, (shutter >> 8) & 0xFF);
+	write_cmos_sensor(0x015b, (shutter ) & 0xFF);	  
 	LOG_INF("Exit! shutter =%d, framelength =%d\n", shutter,imgsensor.frame_length);
 
 	//LOG_INF("frame_length = %d ", frame_length);
@@ -423,6 +420,7 @@ static void set_shutter(kal_uint16 shutter)
 	kal_uint16 realtime_fps = 0;
 	kal_uint32 frame_length = 0;
 	spin_lock_irqsave(&imgsensor_drv_lock, flags);
+	shutter = shutter * 14 / 10;
 	imgsensor.shutter = shutter;
 	spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
 	
@@ -451,24 +449,18 @@ static void set_shutter(kal_uint16 shutter)
 			set_max_framerate(146,0);	
 		else {
 		// Extend frame length
-		write_cmos_sensor(0x0104, 1); 
-		write_cmos_sensor(0x0340, imgsensor.frame_length >> 8);
-		write_cmos_sensor(0x0341, imgsensor.frame_length & 0xFF);
-		write_cmos_sensor(0x0104, 0); 
+		write_cmos_sensor(0x0160, imgsensor.frame_length >> 8);
+		write_cmos_sensor(0x0161, imgsensor.frame_length & 0xFF);
 		}
 	} else {
 		// Extend frame length
-		write_cmos_sensor(0x0104, 1); 
-		write_cmos_sensor(0x0340, imgsensor.frame_length >> 8);
-		write_cmos_sensor(0x0341, imgsensor.frame_length & 0xFF);
-		write_cmos_sensor(0x0104, 0); 
+		write_cmos_sensor(0x0160, imgsensor.frame_length >> 8);
+		write_cmos_sensor(0x0161, imgsensor.frame_length & 0xFF);
 	}
-
+  
 	// Update Shutter
-	write_cmos_sensor(0x0104, 1); 
-	write_cmos_sensor(0x0202, (shutter >> 8) & 0xFF);
-	write_cmos_sensor(0x0203, (shutter ) & 0xFF);
-	write_cmos_sensor(0x0104, 0); 
+	write_cmos_sensor(0x015a, (shutter >> 8) & 0xFF);
+	write_cmos_sensor(0x015b, (shutter ) & 0xFF);	 
 	LOG_INF("Exit! shutter =%d, framelength =%d\n", shutter,imgsensor.frame_length);
 
 }	/*	set_shutter */
@@ -477,6 +469,12 @@ static void set_shutter(kal_uint16 shutter)
 
 static kal_uint16 gain2reg(const kal_uint16 gain)
 {
+	/*
+			kal_uint32 temp_reg;
+		temp_reg = ((2*256*((kal_uint32)gain-64))/((kal_uint32)gain)+1)/2;
+
+		return (temp_reg&0xff) ; 
+	*/
 	kal_uint8 iI;
     LOG_INF("[IMX164MIPI]enter IMX164MIPIGain2Reg function\n");
     for (iI = 0; iI < (IMX164MIPI_MaxGainIndex-1); iI++) 
@@ -519,21 +517,20 @@ static kal_uint16 gain2reg(const kal_uint16 gain)
 * GLOBALS AFFECTED
 *
 *************************************************************************/
-UINT16 iPreGain166 = 0;
+static UINT16 iPreGain = 0;
 static kal_uint16 set_gain(kal_uint16 gain)
 {
 	kal_uint16 reg_gain;
 
- 	if (iPreGain166 != gain)
+ 	if (iPreGain != gain)
 	{
 		reg_gain = gain2reg(gain);
 		spin_lock(&imgsensor_drv_lock);
 		imgsensor.gain = reg_gain; 
 		spin_unlock(&imgsensor_drv_lock);
-		write_cmos_sensor(0x0104, 1);
-		write_cmos_sensor(0x0204, 0x00);
-		write_cmos_sensor(0x0205, (kal_uint8)reg_gain);
-		write_cmos_sensor(0x0104, 0); 
+		if(reg_gain > 0xe0)
+    	reg_gain = 0xe0;
+		write_cmos_sensor(0x0157, (kal_uint8)reg_gain); 
 		LOG_INF("gain = %d , reg_gain = 0x%x\n ", gain, reg_gain);
  	}
 	
@@ -542,7 +539,6 @@ static kal_uint16 set_gain(kal_uint16 gain)
 
 static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gain)
 {
-#if 0
 	LOG_INF("le:0x%x, se:0x%x, gain:0x%x\n",le,se,gain);
 	if (imgsensor.ihdr_en) {
 		
@@ -572,7 +568,7 @@ static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gai
 
 		set_gain(gain);
 	}
-#endif
+
 }
 
 
@@ -594,22 +590,20 @@ static void set_mirror_flip(kal_uint8 image_mirror)
 	   ********************************************************/
 	kal_uint8  iTemp; 
 	LOG_INF("set_mirror_flip function\n");
-    iTemp = read_cmos_sensor(0x0101);
-    iTemp &=~0x03;	//Clear the mirror and flip bits.
-
+    iTemp = read_cmos_sensor(0x0172) & 0x00;	//Clear the mirror and flip bits.
     switch (image_mirror)
     {
         case IMAGE_NORMAL:
-            write_cmos_sensor(0x0101, iTemp);	//Set normal
+            write_cmos_sensor(0x0172, 0x03);	//Set normal
             break;
         case IMAGE_V_MIRROR:
-            write_cmos_sensor(0x0101, iTemp | 0x02);	//Set flip
+            write_cmos_sensor(0x0172, iTemp | 0x01);	//Set flip
             break;
         case IMAGE_H_MIRROR:
-            write_cmos_sensor(0x0101, iTemp | 0x01);	//Set mirror
+            write_cmos_sensor(0x0172, iTemp | 0x02);	//Set mirror
             break;
         case IMAGE_HV_MIRROR:
-            write_cmos_sensor(0x0101, iTemp | 0x03);	//Set mirror and flip
+            write_cmos_sensor(0x0172, 0x00);	//Set mirror and flip
             break;
     }
 	LOG_INF("Error image_mirror setting\n");
@@ -646,82 +640,78 @@ static void sensor_init(void)
 
 static void preview_setting(void)
 {
-
-	write_cmos_sensor(0x0100,   0x00);
-	write_cmos_sensor(0x0111,   0x02);
-	write_cmos_sensor(0x0112,   0x0A);
-	write_cmos_sensor(0x0113,   0x0A);
-	write_cmos_sensor(0x0114,   0x03);
-	write_cmos_sensor(0x0136,   0x18);
-	write_cmos_sensor(0x0137,   0x00);  
-	write_cmos_sensor(0x0202,   0x04);
-	write_cmos_sensor(0x0203,   0x93);
-	write_cmos_sensor(0x0204,   0x00);
-	write_cmos_sensor(0x0205,   0x00);
-	write_cmos_sensor(0x0300,   0x00);
-	write_cmos_sensor(0x0301,   0x07);
-	write_cmos_sensor(0x0302,   0x00);
-	write_cmos_sensor(0x0303,   0x01);
-	write_cmos_sensor(0x0304,   0x00);
-	write_cmos_sensor(0x0305,   0x04);
-	write_cmos_sensor(0x0306,   0x01);
-	write_cmos_sensor(0x0307,   0x36);
-	write_cmos_sensor(0x0308,   0x00);
-	write_cmos_sensor(0x0309,   0x0A);
-	write_cmos_sensor(0x030A,   0x00);
-	write_cmos_sensor(0x030B,   0x01);
-	write_cmos_sensor(0x0340,   0x09);
-	write_cmos_sensor(0x0341,   0xBF);
-	write_cmos_sensor(0x0342,   0x0D);
-	write_cmos_sensor(0x0343,   0xD8);
-	write_cmos_sensor(0x0344 ,  0x00);
-	write_cmos_sensor(0x0345 ,  0x90);
-	write_cmos_sensor(0x0346 ,  0x00);
-	write_cmos_sensor(0x0347 ,  0x00);
-	write_cmos_sensor(0x0348 ,  0x0D);
-	write_cmos_sensor(0x0349 ,  0x5F);
-	write_cmos_sensor(0x034A ,  0x09);
-	write_cmos_sensor(0x034B ,  0x9F);
-	write_cmos_sensor(0x034C ,  0x06);
-	write_cmos_sensor(0x034D ,  0x68);
-	write_cmos_sensor(0x034E ,  0x04);
-	write_cmos_sensor(0x034F ,  0xD0);
-	write_cmos_sensor(0x0400 ,  0x00);
-	write_cmos_sensor(0x0401 ,  0x00);
-	write_cmos_sensor(0x0402 ,  0x00);
-	write_cmos_sensor(0x0403 ,  0x00);
-	write_cmos_sensor(0x0404 ,  0x00);
-	write_cmos_sensor(0x0405 ,  0x10);
-	write_cmos_sensor(0x0408 ,  0x00);
-	write_cmos_sensor(0x0409 ,  0x00);
-	write_cmos_sensor(0x040A ,  0x00);
-	write_cmos_sensor(0x040B ,  0x00);
-	write_cmos_sensor(0x040C ,  0x06);
-	write_cmos_sensor(0x040D ,  0x68);
-	write_cmos_sensor(0x040E ,  0x04);
-	write_cmos_sensor(0x040F ,  0xD0);
-	write_cmos_sensor(0x0820 ,  0x07);
-	write_cmos_sensor(0x0821 ,  0x44);
-	write_cmos_sensor(0x0822 ,  0x00);
-	write_cmos_sensor(0x0823 ,  0x00);
-	write_cmos_sensor(0x0900 ,  0x01);
-	write_cmos_sensor(0x0901 ,  0x22);
-	write_cmos_sensor(0x0902 ,  0x00);
-	write_cmos_sensor(0x0216 ,  0x00);
-	write_cmos_sensor(0x0217 ,  0x00);
-	write_cmos_sensor(0x0220 ,  0x00);
-	write_cmos_sensor(0x0221 ,  0x00);
-	write_cmos_sensor(0x0222 ,  0x01);
-	write_cmos_sensor(0x0B8E ,  0x00);
-	write_cmos_sensor(0x0B8F ,  0x01);
-	write_cmos_sensor(0x0B90 ,  0x00);
-	write_cmos_sensor(0x0B91 ,  0x01);
-	write_cmos_sensor(0x0B92 ,  0x00);
-	write_cmos_sensor(0x0B93 ,  0x01);
-	write_cmos_sensor(0x0B94 ,  0x00);
-	write_cmos_sensor(0x0B95 ,  0x01);
-	write_cmos_sensor(0x0100 ,  0x01);
-
+  write_cmos_sensor(0x41C0,0x01);
+	write_cmos_sensor(0x0104,0x01);
+	write_cmos_sensor(0x0100,0x00);
+	write_cmos_sensor(0x0103,0x01);
+	write_cmos_sensor(0x0114,0x03);
+	write_cmos_sensor(0x0118,0x00);
+	write_cmos_sensor(0x0119,0x87);
+	write_cmos_sensor(0x011a,0x00);
+	write_cmos_sensor(0x011b,0x4f);
+	write_cmos_sensor(0x011c,0x00);
+	write_cmos_sensor(0x011d,0x77);
+	write_cmos_sensor(0x011e,0x00);
+	write_cmos_sensor(0x011f,0x47);
+	write_cmos_sensor(0x0120,0x00);
+	write_cmos_sensor(0x0121,0x3f);
+	write_cmos_sensor(0x0122,0x00);
+	write_cmos_sensor(0x0123,0x4f);
+	write_cmos_sensor(0x0124,0x00);
+	write_cmos_sensor(0x011f,0x01);
+	write_cmos_sensor(0x030E,0x01);
+	write_cmos_sensor(0x0202,0x03);
+	write_cmos_sensor(0x0203,0xcc);
+	write_cmos_sensor(0x0301,0x05);
+	write_cmos_sensor(0x0303,0x01);
+	write_cmos_sensor(0x0304,0x03);
+	write_cmos_sensor(0x0305,0x06);
+	write_cmos_sensor(0x0306,0x00);
+	write_cmos_sensor(0x0307,0x51);
+	write_cmos_sensor(0x0309,0x0A);
+	write_cmos_sensor(0x030B,0x01);
+	write_cmos_sensor(0x030C,0x00);
+	write_cmos_sensor(0x030D,0x72);
+	write_cmos_sensor(0x0160,((imgsensor_info.pre.framelength >> 8) & 0xFF));  
+	write_cmos_sensor(0x0161,(imgsensor_info.pre.framelength & 0xFF));	       
+	write_cmos_sensor(0x0162,((imgsensor_info.pre.linelength >> 8) & 0xFF));   
+	write_cmos_sensor(0x0163,(imgsensor_info.pre.linelength & 0xFF));	         
+	write_cmos_sensor(0x0164,0x00);
+	write_cmos_sensor(0x0165,0x00);
+	write_cmos_sensor(0x0166,0x0c);
+	write_cmos_sensor(0x0167,0xd7);
+	write_cmos_sensor(0x0168,0x00);
+	write_cmos_sensor(0x0169,0x00);
+	write_cmos_sensor(0x016A,0x09);
+	write_cmos_sensor(0x016B,0xa7);
+	write_cmos_sensor(0x016C,0x0c);
+	write_cmos_sensor(0x016D,0xd0);
+	write_cmos_sensor(0x016E,0x09);
+	write_cmos_sensor(0x016F,0xa0);
+	write_cmos_sensor(0x0170,0x01);
+	write_cmos_sensor(0x0171,0x01);
+	write_cmos_sensor(0x0172,0x03);//03
+	write_cmos_sensor(0x0174,0x01);
+	write_cmos_sensor(0x0175,0x00);
+	write_cmos_sensor(0x018C,0x0a);
+	write_cmos_sensor(0x018D,0x0a);
+	write_cmos_sensor(0x455E,0x00);
+	write_cmos_sensor(0x471E,0x4B);
+	write_cmos_sensor(0x4767,0x0F);
+	write_cmos_sensor(0x4750,0x14);
+	write_cmos_sensor(0x4540,0x00);
+	write_cmos_sensor(0x47B4,0x14);
+	write_cmos_sensor(0x4713,0x30);
+	write_cmos_sensor(0x478B,0x10);
+	write_cmos_sensor(0x478F,0x10);
+	write_cmos_sensor(0x4793,0x10);
+	write_cmos_sensor(0x4797,0x0E);
+	write_cmos_sensor(0x479B,0x0E);
+	write_cmos_sensor(0x0104,0x00);
+	write_cmos_sensor(0x0100,0x01);
+
+
+	 
 }	/*	preview_setting  */
 
 static void capture_setting(kal_uint16 currefps)
@@ -729,159 +719,156 @@ static void capture_setting(kal_uint16 currefps)
 	LOG_INF("E! currefps:%d\n",currefps);
 	if (currefps == 240) { //24fps for PIP
 		//@@full_132PCLK_24.75
+      write_cmos_sensor(0x41C0,0x01);
+			write_cmos_sensor(0x0104,0x01);
+			write_cmos_sensor(0x0100,0x00);
+			write_cmos_sensor(0x0103,0x01);
+			write_cmos_sensor(0x0114,0x03);
+			write_cmos_sensor(0x0118,0x00);
+			write_cmos_sensor(0x0119,0x87);
+			write_cmos_sensor(0x011a,0x00);
+			write_cmos_sensor(0x011b,0x4f);
+			write_cmos_sensor(0x011c,0x00);
+			write_cmos_sensor(0x011d,0x77);
+			write_cmos_sensor(0x011e,0x00);
+			write_cmos_sensor(0x011f,0x47);
+			write_cmos_sensor(0x0120,0x00);
+			write_cmos_sensor(0x0121,0x3f);
+			write_cmos_sensor(0x0122,0x00);
+			write_cmos_sensor(0x0123,0x4f);
+			write_cmos_sensor(0x0124,0x00);
+			write_cmos_sensor(0x011f,0x01);
+			write_cmos_sensor(0x030E,0x01);
+			write_cmos_sensor(0x0202,0x03);
+			write_cmos_sensor(0x0203,0xcc);
+			write_cmos_sensor(0x0301,0x05);
+			write_cmos_sensor(0x0303,0x01);
+			write_cmos_sensor(0x0304,0x03);
+			write_cmos_sensor(0x0305,0x06);
+			write_cmos_sensor(0x0306,0x00);
+			write_cmos_sensor(0x0307,0x51);
+			write_cmos_sensor(0x0309,0x0A);
+			write_cmos_sensor(0x030B,0x01);
+			write_cmos_sensor(0x030C,0x00);
+			write_cmos_sensor(0x030D,0x72);
+			write_cmos_sensor(0x0160,((imgsensor_info.cap.framelength >> 8) & 0xFF));  
+			write_cmos_sensor(0x0161,(imgsensor_info.cap.framelength & 0xFF));         
+			write_cmos_sensor(0x0162,((imgsensor_info.cap.linelength >> 8) & 0xFF));	 
+			write_cmos_sensor(0x0163,(imgsensor_info.cap.linelength & 0xFF));          
+			write_cmos_sensor(0x0164,0x00);
+			write_cmos_sensor(0x0165,0x00);
+			write_cmos_sensor(0x0166,0x0c);
+			write_cmos_sensor(0x0167,0xd7);
+			write_cmos_sensor(0x0168,0x00);
+			write_cmos_sensor(0x0169,0x00);
+			write_cmos_sensor(0x016A,0x09);
+			write_cmos_sensor(0x016B,0xa7);
+			write_cmos_sensor(0x016C,0x0c);
+			write_cmos_sensor(0x016D,0xd0);
+			write_cmos_sensor(0x016E,0x09);
+			write_cmos_sensor(0x016F,0xa0);
+			write_cmos_sensor(0x0170,0x01);
+			write_cmos_sensor(0x0171,0x01);
+			write_cmos_sensor(0x0172,0x03);//03
+			write_cmos_sensor(0x0174,0x00);
+			write_cmos_sensor(0x0175,0x00);
+			write_cmos_sensor(0x018C,0x0a);
+			write_cmos_sensor(0x018D,0x0a);
+			write_cmos_sensor(0x455E,0x00);
+			write_cmos_sensor(0x471E,0x4B);
+			write_cmos_sensor(0x4767,0x0F);
+			write_cmos_sensor(0x4750,0x14);
+			write_cmos_sensor(0x4540,0x00);
+			write_cmos_sensor(0x47B4,0x14);
+			write_cmos_sensor(0x4713,0x30);
+			write_cmos_sensor(0x478B,0x10);
+			write_cmos_sensor(0x478F,0x10);
+			write_cmos_sensor(0x4793,0x10);
+			write_cmos_sensor(0x4797,0x0E);
+			write_cmos_sensor(0x479B,0x0E);
+			write_cmos_sensor(0x0104,0x00);
+			write_cmos_sensor(0x0100,0x01);
 
-	write_cmos_sensor(0x0100,   0x00);
-	write_cmos_sensor(0x0111,   0x02);
-	write_cmos_sensor(0x0112,   0x0A);
-	write_cmos_sensor(0x0113,   0x0A);
-	write_cmos_sensor(0x0114,   0x03);
-	write_cmos_sensor(0x0136,   0x18);
-	write_cmos_sensor(0x0137,   0x00);  
-	write_cmos_sensor(0x0202,   0x04);
-	write_cmos_sensor(0x0203,   0x93);
-	write_cmos_sensor(0x0204,   0x00);
-	write_cmos_sensor(0x0205,   0x00);
-	write_cmos_sensor(0x0300,   0x00);
-	write_cmos_sensor(0x0301,   0x0A);
-	write_cmos_sensor(0x0302,   0x00);
-	write_cmos_sensor(0x0303,   0x01);
-	write_cmos_sensor(0x0304,   0x00);
-	write_cmos_sensor(0x0305,   0x05);//0x04);
-	write_cmos_sensor(0x0306,   0x01);
-	write_cmos_sensor(0x0307,   0xBB);
-	write_cmos_sensor(0x0308,   0x00);
-	write_cmos_sensor(0x0309,   0x0A);
-	write_cmos_sensor(0x030A,   0x00);
-	write_cmos_sensor(0x030B,   0x01);
-	write_cmos_sensor(0x0340,   0x09);
-	write_cmos_sensor(0x0341,   0xC0);
-	write_cmos_sensor(0x0342,   0x0D);
-	write_cmos_sensor(0x0343,   0xD8);
-	write_cmos_sensor(0x0344 ,  0x00);
-	write_cmos_sensor(0x0345 ,  0x90);
-	write_cmos_sensor(0x0346 ,  0x00);
-	write_cmos_sensor(0x0347 ,  0x00);
-	write_cmos_sensor(0x0348 ,  0x0D);
-	write_cmos_sensor(0x0349 ,  0x5F);
-	write_cmos_sensor(0x034A ,  0x09);
-	write_cmos_sensor(0x034B ,  0x9F);
-	write_cmos_sensor(0x034C ,  0x0C);
-	write_cmos_sensor(0x034D ,  0xD0);
-	write_cmos_sensor(0x034E ,  0x09);
-	write_cmos_sensor(0x034F ,  0xA0);
-	write_cmos_sensor(0x0400 ,  0x00);
-	write_cmos_sensor(0x0401 ,  0x00);
-	write_cmos_sensor(0x0402 ,  0x00);
-	write_cmos_sensor(0x0403 ,  0x00);
-	write_cmos_sensor(0x0404 ,  0x00);
-	write_cmos_sensor(0x0405 ,  0x10);
-	write_cmos_sensor(0x0408 ,  0x00);
-	write_cmos_sensor(0x0409 ,  0x00);
-	write_cmos_sensor(0x040A ,  0x00);
-	write_cmos_sensor(0x040B ,  0x00);
-	write_cmos_sensor(0x040C ,  0x0C);
-	write_cmos_sensor(0x040D ,  0xD0);
-	write_cmos_sensor(0x040E ,  0x09);
-	write_cmos_sensor(0x040F ,  0xA0);
-	write_cmos_sensor(0x0820 ,  0x0A);
-	write_cmos_sensor(0x0821 ,  0x62);
-	write_cmos_sensor(0x0822 ,  0x00);
-	write_cmos_sensor(0x0823 ,  0x00);
-  write_cmos_sensor(0x0900 ,  0x00);
-	write_cmos_sensor(0x0901 ,  0x00);
-	write_cmos_sensor(0x0902 ,  0x00);
-	write_cmos_sensor(0x0216 ,  0x00);
-	write_cmos_sensor(0x0217 ,  0x00);
-	write_cmos_sensor(0x0220 ,  0x00);
-	write_cmos_sensor(0x0221 ,  0x00);
-	write_cmos_sensor(0x0222 ,  0x01);
-	write_cmos_sensor(0x0B8E ,  0x00);
-	write_cmos_sensor(0x0B8F ,  0x01);
-	write_cmos_sensor(0x0B90 ,  0x00);
-	write_cmos_sensor(0x0B91 ,  0x01);
-	write_cmos_sensor(0x0B92 ,  0x00);
-	write_cmos_sensor(0x0B93 ,  0x01);
-  write_cmos_sensor(0x0B94 ,  0x00);
-	write_cmos_sensor(0x0B95 ,  0x01);
-  write_cmos_sensor(0x0100 ,  0x01);
 
 	} else {   //30fps			//30fps for Normal capture & ZSD
-
-	write_cmos_sensor(0x0100,   0x00);
-	write_cmos_sensor(0x0111,   0x02);
-	write_cmos_sensor(0x0112,   0x0A);
-	write_cmos_sensor(0x0113,   0x0A);
-	write_cmos_sensor(0x0114,   0x03);
-	write_cmos_sensor(0x0136,   0x18);
-	write_cmos_sensor(0x0137,   0x00);  
-	write_cmos_sensor(0x0202,   0x04);
-	write_cmos_sensor(0x0203,   0x93);
-	write_cmos_sensor(0x0204,   0x00);
-	write_cmos_sensor(0x0205,   0x00);
-	write_cmos_sensor(0x0300,   0x00);
-	write_cmos_sensor(0x0301,   0x0A);
-	write_cmos_sensor(0x0302,   0x00);
-	write_cmos_sensor(0x0303,   0x01);
-	write_cmos_sensor(0x0304,   0x00);
-	write_cmos_sensor(0x0305,   0x04);
-	write_cmos_sensor(0x0306,   0x01);
-	write_cmos_sensor(0x0307,   0xBB);
-	write_cmos_sensor(0x0308,   0x00);
-	write_cmos_sensor(0x0309,   0x0A);
-	write_cmos_sensor(0x030A,   0x00);
-	write_cmos_sensor(0x030B,   0x01);
-	write_cmos_sensor(0x0340,   0x09);
-	write_cmos_sensor(0x0341,   0xC0);
-	write_cmos_sensor(0x0342,   0x0D);
-	write_cmos_sensor(0x0343,   0xD8);
-	write_cmos_sensor(0x0344 ,  0x00);
-	write_cmos_sensor(0x0345 ,  0x90);
-	write_cmos_sensor(0x0346 ,  0x00);
-	write_cmos_sensor(0x0347 ,  0x00);
-	write_cmos_sensor(0x0348 ,  0x0D);
-	write_cmos_sensor(0x0349 ,  0x5F);
-	write_cmos_sensor(0x034A ,  0x09);
-	write_cmos_sensor(0x034B ,  0x9F);
-	write_cmos_sensor(0x034C ,  0x0C);
-	write_cmos_sensor(0x034D ,  0xD0);
-	write_cmos_sensor(0x034E ,  0x09);
-	write_cmos_sensor(0x034F ,  0xA0);
-	write_cmos_sensor(0x0400 ,  0x00);
-	write_cmos_sensor(0x0401 ,  0x00);
-	write_cmos_sensor(0x0402 ,  0x00);
-	write_cmos_sensor(0x0403 ,  0x00);
-	write_cmos_sensor(0x0404 ,  0x00);
-	write_cmos_sensor(0x0405 ,  0x10);
-	write_cmos_sensor(0x0408 ,  0x00);
-	write_cmos_sensor(0x0409 ,  0x00);
-	write_cmos_sensor(0x040A ,  0x00);
-	write_cmos_sensor(0x040B ,  0x00);
-	write_cmos_sensor(0x040C ,  0x0C);
-	write_cmos_sensor(0x040D ,  0xD0);
-	write_cmos_sensor(0x040E ,  0x09);
-	write_cmos_sensor(0x040F ,  0xA0);
-	write_cmos_sensor(0x0820 ,  0x0A);
-	write_cmos_sensor(0x0821 ,  0x62);
-	write_cmos_sensor(0x0822 ,  0x00);
-	write_cmos_sensor(0x0823 ,  0x00);
-  write_cmos_sensor(0x0900 ,  0x00);
-	write_cmos_sensor(0x0901 ,  0x00);
-	write_cmos_sensor(0x0902 ,  0x00);
-	write_cmos_sensor(0x0216 ,  0x00);
-	write_cmos_sensor(0x0217 ,  0x00);
-	write_cmos_sensor(0x0220 ,  0x00);
-	write_cmos_sensor(0x0221 ,  0x00);
-	write_cmos_sensor(0x0222 ,  0x01);
-	write_cmos_sensor(0x0B8E ,  0x00);
-	write_cmos_sensor(0x0B8F ,  0x01);
-	write_cmos_sensor(0x0B90 ,  0x00);
-	write_cmos_sensor(0x0B91 ,  0x01);
-	write_cmos_sensor(0x0B92 ,  0x00);
-	write_cmos_sensor(0x0B93 ,  0x01);
-  write_cmos_sensor(0x0B94 ,  0x00);
-	write_cmos_sensor(0x0B95 ,  0x01);
-  write_cmos_sensor(0x0100 ,  0x01);
-
+		  
+		 write_cmos_sensor(0x41C0,0x01);
+			write_cmos_sensor(0x0104,0x01);
+			write_cmos_sensor(0x0100,0x00);
+			write_cmos_sensor(0x0103,0x01);
+			write_cmos_sensor(0x0114,0x03);
+			write_cmos_sensor(0x0118,0x00);
+			write_cmos_sensor(0x0119,0x87);
+			write_cmos_sensor(0x011a,0x00);
+			write_cmos_sensor(0x011b,0x4f);
+			write_cmos_sensor(0x011c,0x00);
+			write_cmos_sensor(0x011d,0x77);
+			write_cmos_sensor(0x011e,0x00);
+			write_cmos_sensor(0x011f,0x47);
+			write_cmos_sensor(0x0120,0x00);
+			write_cmos_sensor(0x0121,0x3f);
+			write_cmos_sensor(0x0122,0x00);
+			write_cmos_sensor(0x0123,0x4f);
+			write_cmos_sensor(0x0124,0x00);
+			write_cmos_sensor(0x011f,0x01);
+			write_cmos_sensor(0x030E,0x01);
+			write_cmos_sensor(0x0202,0x03);
+			write_cmos_sensor(0x0203,0xcc);
+			write_cmos_sensor(0x0301,0x05);
+			write_cmos_sensor(0x0303,0x01);
+			write_cmos_sensor(0x0304,0x03);
+			write_cmos_sensor(0x0305,0x06);
+			write_cmos_sensor(0x0306,0x00);
+			write_cmos_sensor(0x0307,0x51);
+			write_cmos_sensor(0x0309,0x0A);
+			write_cmos_sensor(0x030B,0x01);
+			write_cmos_sensor(0x030C,0x00);
+			write_cmos_sensor(0x030D,0x72);
+			write_cmos_sensor(0x0160,((imgsensor_info.cap.framelength >> 8) & 0xFF));  
+			write_cmos_sensor(0x0161,(imgsensor_info.cap.framelength & 0xFF));         
+			write_cmos_sensor(0x0162,((imgsensor_info.cap.linelength >> 8) & 0xFF));	 
+			write_cmos_sensor(0x0163,(imgsensor_info.cap.linelength & 0xFF));          
+			write_cmos_sensor(0x0164,0x00);
+			write_cmos_sensor(0x0165,0x00);
+			write_cmos_sensor(0x0166,0x0c);
+			write_cmos_sensor(0x0167,0xd7);
+			write_cmos_sensor(0x0168,0x00);
+			write_cmos_sensor(0x0169,0x00);
+			write_cmos_sensor(0x016A,0x09);
+			write_cmos_sensor(0x016B,0xa7);
+			write_cmos_sensor(0x016C,0x0c);
+			write_cmos_sensor(0x016D,0xd0);
+			write_cmos_sensor(0x016E,0x09);
+			write_cmos_sensor(0x016F,0xa0);
+			write_cmos_sensor(0x0170,0x01);
+			write_cmos_sensor(0x0171,0x01);
+			write_cmos_sensor(0x0172,0x03);
+			write_cmos_sensor(0x0174,0x00);
+			write_cmos_sensor(0x0175,0x00);
+			write_cmos_sensor(0x018C,0x0a);
+			write_cmos_sensor(0x018D,0x0a);
+			write_cmos_sensor(0x455E,0x00);
+			write_cmos_sensor(0x471E,0x4B);
+			write_cmos_sensor(0x4767,0x0F);
+			write_cmos_sensor(0x4750,0x14);
+			write_cmos_sensor(0x4540,0x00);
+			write_cmos_sensor(0x47B4,0x14);
+			write_cmos_sensor(0x4713,0x30);
+			write_cmos_sensor(0x478B,0x10);
+			write_cmos_sensor(0x478F,0x10);
+			write_cmos_sensor(0x4793,0x10);
+			write_cmos_sensor(0x4797,0x0E);
+			write_cmos_sensor(0x479B,0x0E);
+			write_cmos_sensor(0x0104,0x00);
+			write_cmos_sensor(0x0100,0x01);
+
+
+		if (imgsensor.ihdr_en) {
+		
+	} else {
+		
+	}
+		
 	}
 		
 }
@@ -889,159 +876,156 @@ static void capture_setting(kal_uint16 currefps)
 static void normal_video_setting(kal_uint16 currefps)
 {
 	LOG_INF("E! currefps:%d\n",currefps);
-	write_cmos_sensor(0x0100,   0x00);
-	write_cmos_sensor(0x0111,   0x02);
-	write_cmos_sensor(0x0112,   0x0A);
-	write_cmos_sensor(0x0113,   0x0A);
-	write_cmos_sensor(0x0114,   0x03);
-	write_cmos_sensor(0x0136,   0x18);
-	write_cmos_sensor(0x0137,   0x00);  
-	write_cmos_sensor(0x0202,   0x04);
-	write_cmos_sensor(0x0203,   0x93);
-	write_cmos_sensor(0x0204,   0x00);
-	write_cmos_sensor(0x0205,   0x00);
-	write_cmos_sensor(0x0300,   0x00);
-	write_cmos_sensor(0x0301,   0x0A);
-	write_cmos_sensor(0x0302,   0x00);
-	write_cmos_sensor(0x0303,   0x01);
-	write_cmos_sensor(0x0304,   0x00);
-	write_cmos_sensor(0x0305,   0x04);
-	write_cmos_sensor(0x0306,   0x01);
-	write_cmos_sensor(0x0307,   0xBB);
-	write_cmos_sensor(0x0308,   0x00);
-	write_cmos_sensor(0x0309,   0x0A);
-	write_cmos_sensor(0x030A,   0x00);
-	write_cmos_sensor(0x030B,   0x01);
-	write_cmos_sensor(0x0340,   0x09);
-	write_cmos_sensor(0x0341,   0xC0);
-	write_cmos_sensor(0x0342,   0x0D);
-	write_cmos_sensor(0x0343,   0xD8);
-	write_cmos_sensor(0x0344 ,  0x00);
-	write_cmos_sensor(0x0345 ,  0x90);
-	write_cmos_sensor(0x0346 ,  0x00);
-	write_cmos_sensor(0x0347 ,  0x00);
-	write_cmos_sensor(0x0348 ,  0x0D);
-	write_cmos_sensor(0x0349 ,  0x5F);
-	write_cmos_sensor(0x034A ,  0x09);
-	write_cmos_sensor(0x034B ,  0x9F);
-	write_cmos_sensor(0x034C ,  0x0C);
-	write_cmos_sensor(0x034D ,  0xD0);
-	write_cmos_sensor(0x034E ,  0x09);
-	write_cmos_sensor(0x034F ,  0xA0);
-	write_cmos_sensor(0x0400 ,  0x00);
-	write_cmos_sensor(0x0401 ,  0x00);
-	write_cmos_sensor(0x0402 ,  0x00);
-	write_cmos_sensor(0x0403 ,  0x00);
-	write_cmos_sensor(0x0404 ,  0x00);
-	write_cmos_sensor(0x0405 ,  0x10);
-	write_cmos_sensor(0x0408 ,  0x00);
-	write_cmos_sensor(0x0409 ,  0x00);
-	write_cmos_sensor(0x040A ,  0x00);
-	write_cmos_sensor(0x040B ,  0x00);
-	write_cmos_sensor(0x040C ,  0x0C);
-	write_cmos_sensor(0x040D ,  0xD0);
-	write_cmos_sensor(0x040E ,  0x09);
-	write_cmos_sensor(0x040F ,  0xA0);
-	write_cmos_sensor(0x0820 ,  0x0A);
-	write_cmos_sensor(0x0821 ,  0x62);
-	write_cmos_sensor(0x0822 ,  0x00);
-	write_cmos_sensor(0x0823 ,  0x00);
-  write_cmos_sensor(0x0900 ,  0x00);
-	write_cmos_sensor(0x0901 ,  0x00);
-	write_cmos_sensor(0x0902 ,  0x00);
-	write_cmos_sensor(0x0216 ,  0x00);
-	write_cmos_sensor(0x0217 ,  0x00);
-	write_cmos_sensor(0x0220 ,  0x00);
-	write_cmos_sensor(0x0221 ,  0x00);
-	write_cmos_sensor(0x0222 ,  0x01);
-	write_cmos_sensor(0x0B8E ,  0x00);
-	write_cmos_sensor(0x0B8F ,  0x01);
-	write_cmos_sensor(0x0B90 ,  0x00);
-	write_cmos_sensor(0x0B91 ,  0x01);
-	write_cmos_sensor(0x0B92 ,  0x00);
-	write_cmos_sensor(0x0B93 ,  0x01);
-  write_cmos_sensor(0x0B94 ,  0x00);
-	write_cmos_sensor(0x0B95 ,  0x01);
-  write_cmos_sensor(0x0100 ,  0x01);
+	     write_cmos_sensor(0x41C0,0x01);
+			write_cmos_sensor(0x0104,0x01);
+			write_cmos_sensor(0x0100,0x00);
+			write_cmos_sensor(0x0103,0x01);
+			write_cmos_sensor(0x0114,0x03);
+			write_cmos_sensor(0x0118,0x00);
+			write_cmos_sensor(0x0119,0x87);
+			write_cmos_sensor(0x011a,0x00);
+			write_cmos_sensor(0x011b,0x4f);
+			write_cmos_sensor(0x011c,0x00);
+			write_cmos_sensor(0x011d,0x77);
+			write_cmos_sensor(0x011e,0x00);
+			write_cmos_sensor(0x011f,0x47);
+			write_cmos_sensor(0x0120,0x00);
+			write_cmos_sensor(0x0121,0x3f);
+			write_cmos_sensor(0x0122,0x00);
+			write_cmos_sensor(0x0123,0x4f);
+			write_cmos_sensor(0x0124,0x00);
+			write_cmos_sensor(0x011f,0x01);
+			write_cmos_sensor(0x030E,0x01);
+			write_cmos_sensor(0x0202,0x03);
+			write_cmos_sensor(0x0203,0xcc);
+			write_cmos_sensor(0x0301,0x05);
+			write_cmos_sensor(0x0303,0x01);
+			write_cmos_sensor(0x0304,0x03);
+			write_cmos_sensor(0x0305,0x06);
+			write_cmos_sensor(0x0306,0x00);
+			write_cmos_sensor(0x0307,0x51);
+			write_cmos_sensor(0x0309,0x0A);
+			write_cmos_sensor(0x030B,0x01);
+			write_cmos_sensor(0x030C,0x00);
+			write_cmos_sensor(0x030D,0x72);
+			write_cmos_sensor(0x0160,((imgsensor_info.cap.framelength >> 8) & 0xFF));  
+			write_cmos_sensor(0x0161,(imgsensor_info.cap.framelength & 0xFF));         
+			write_cmos_sensor(0x0162,((imgsensor_info.cap.linelength >> 8) & 0xFF));	 
+			write_cmos_sensor(0x0163,(imgsensor_info.cap.linelength & 0xFF));          
+			write_cmos_sensor(0x0164,0x00);
+			write_cmos_sensor(0x0165,0x00);
+			write_cmos_sensor(0x0166,0x0c);
+			write_cmos_sensor(0x0167,0xd7);
+			write_cmos_sensor(0x0168,0x00);
+			write_cmos_sensor(0x0169,0x00);
+			write_cmos_sensor(0x016A,0x09);
+			write_cmos_sensor(0x016B,0xa7);
+			write_cmos_sensor(0x016C,0x0c);
+			write_cmos_sensor(0x016D,0xd0);
+			write_cmos_sensor(0x016E,0x09);
+			write_cmos_sensor(0x016F,0xa0);
+			write_cmos_sensor(0x0170,0x01);
+			write_cmos_sensor(0x0171,0x01);
+			write_cmos_sensor(0x0172,0x03);
+			write_cmos_sensor(0x0174,0x00);
+			write_cmos_sensor(0x0175,0x00);
+			write_cmos_sensor(0x018C,0x0a);
+			write_cmos_sensor(0x018D,0x0a);
+			write_cmos_sensor(0x455E,0x00);
+			write_cmos_sensor(0x471E,0x4B);
+			write_cmos_sensor(0x4767,0x0F);
+			write_cmos_sensor(0x4750,0x14);
+			write_cmos_sensor(0x4540,0x00);
+			write_cmos_sensor(0x47B4,0x14);
+			write_cmos_sensor(0x4713,0x30);
+			write_cmos_sensor(0x478B,0x10);
+			write_cmos_sensor(0x478F,0x10);
+			write_cmos_sensor(0x4793,0x10);
+			write_cmos_sensor(0x4797,0x0E);
+			write_cmos_sensor(0x479B,0x0E);
+			write_cmos_sensor(0x0104,0x00);
+			write_cmos_sensor(0x0100,0x01);
+	if (imgsensor.ihdr_en) {
+	} else {
+	}
+
 }
 static void hs_video_setting()
 {
 	LOG_INF("E\n");
-	
-	write_cmos_sensor(0x0100,   0x00);
-	write_cmos_sensor(0x0111,   0x02);
-	write_cmos_sensor(0x0112,   0x0A);
-	write_cmos_sensor(0x0113,   0x0A);
-	write_cmos_sensor(0x0114,   0x03);
-	write_cmos_sensor(0x0136,   0x18);
-	write_cmos_sensor(0x0137,   0x00);  
-	write_cmos_sensor(0x0202,   0x04);
-	write_cmos_sensor(0x0203,   0x3B);
-	write_cmos_sensor(0x0204,   0x00);
-	write_cmos_sensor(0x0205,   0x00);
-	write_cmos_sensor(0x0300,   0x00);
-	write_cmos_sensor(0x0301,   0x07);
-	write_cmos_sensor(0x0302,   0x00);
-	write_cmos_sensor(0x0303,   0x01);
-	write_cmos_sensor(0x0304,   0x00);
-	write_cmos_sensor(0x0305,   0x04);
-	write_cmos_sensor(0x0306,   0x01);
-	write_cmos_sensor(0x0307,   0x36);
-	write_cmos_sensor(0x0308,   0x00);
-	write_cmos_sensor(0x0309,   0x0A);
-	write_cmos_sensor(0x030A,   0x00);
-	write_cmos_sensor(0x030B,   0x01);
-	write_cmos_sensor(0x0340,   0x04);
-	write_cmos_sensor(0x0341,   0x83);
-	write_cmos_sensor(0x0342,   0x0E);
-	write_cmos_sensor(0x0343,   0xF8);
-	write_cmos_sensor(0x0344 ,  0x00);
-	write_cmos_sensor(0x0345 ,  0x00);
-	write_cmos_sensor(0x0346 ,  0x00);
-	write_cmos_sensor(0x0347 ,  0xE0);
-	write_cmos_sensor(0x0348 ,  0x0D);
-	write_cmos_sensor(0x0349 ,  0xEF);
-	write_cmos_sensor(0x034A ,  0x08);
-	write_cmos_sensor(0x034B ,  0xBF);
-	write_cmos_sensor(0x034C ,  0x05);
-	write_cmos_sensor(0x034D ,  0x10);
-	write_cmos_sensor(0x034E ,  0x02);
-	write_cmos_sensor(0x034F ,  0xDF);
-	write_cmos_sensor(0x0400 ,  0x00);
-	write_cmos_sensor(0x0401 ,  0x02);
-	write_cmos_sensor(0x0402 ,  0x00);
-	write_cmos_sensor(0x0403 ,  0x00);
-	write_cmos_sensor(0x0404 ,  0x00);
-	write_cmos_sensor(0x0405 ,  0x16);
-	write_cmos_sensor(0x0408 ,  0x00);
-	write_cmos_sensor(0x0409 ,  0x00);
-	write_cmos_sensor(0x040A ,  0x00);
-	write_cmos_sensor(0x040B ,  0x00);
-	write_cmos_sensor(0x040C ,  0x06);
-	write_cmos_sensor(0x040D ,  0xF8);
-	write_cmos_sensor(0x040E ,  0x03);
-	write_cmos_sensor(0x040F ,  0xF0);
-	write_cmos_sensor(0x0820 ,  0x07);
-	write_cmos_sensor(0x0821 ,  0x44);
-	write_cmos_sensor(0x0822 ,  0x00);
-	write_cmos_sensor(0x0823 ,  0x00);
-  write_cmos_sensor(0x0900 ,  0x01);
-	write_cmos_sensor(0x0901 ,  0x22);
-	write_cmos_sensor(0x0902 ,  0x00);
-	write_cmos_sensor(0x0216 ,  0x00);
-	write_cmos_sensor(0x0217 ,  0x00);
-	write_cmos_sensor(0x0220 ,  0x00);
-	write_cmos_sensor(0x0221 ,  0x00);
-	write_cmos_sensor(0x0222 ,  0x01);
-	write_cmos_sensor(0x0B8E ,  0x00);
-	write_cmos_sensor(0x0B8F ,  0x01);
-	write_cmos_sensor(0x0B90 ,  0x00);
-	write_cmos_sensor(0x0B91 ,  0x01);
-	write_cmos_sensor(0x0B92 ,  0x00);
-	write_cmos_sensor(0x0B93 ,  0x01);
-  write_cmos_sensor(0x0B94 ,  0x00);
-	write_cmos_sensor(0x0B95 ,  0x01);
-  write_cmos_sensor(0x0100 ,  0x01);
+
+	    write_cmos_sensor(0x41C0,0x01);
+			write_cmos_sensor(0x0104,0x01);
+			write_cmos_sensor(0x0100,0x00);
+			write_cmos_sensor(0x0103,0x01);
+			write_cmos_sensor(0x0114,0x03);
+			write_cmos_sensor(0x0118,0x00);
+			write_cmos_sensor(0x0119,0x87);
+			write_cmos_sensor(0x011a,0x00);
+			write_cmos_sensor(0x011b,0x4f);
+			write_cmos_sensor(0x011c,0x00);
+			write_cmos_sensor(0x011d,0x77);
+			write_cmos_sensor(0x011e,0x00);
+			write_cmos_sensor(0x011f,0x47);
+			write_cmos_sensor(0x0120,0x00);
+			write_cmos_sensor(0x0121,0x3f);
+			write_cmos_sensor(0x0122,0x00);
+			write_cmos_sensor(0x0123,0x4f);
+			write_cmos_sensor(0x0124,0x00);
+			write_cmos_sensor(0x011f,0x01);
+			write_cmos_sensor(0x030E,0x01);
+			write_cmos_sensor(0x0202,0x03);
+			write_cmos_sensor(0x0203,0xcc);
+			write_cmos_sensor(0x0301,0x05);
+			write_cmos_sensor(0x0303,0x01);
+			write_cmos_sensor(0x0304,0x03);
+			write_cmos_sensor(0x0305,0x06);
+			write_cmos_sensor(0x0306,0x00);
+			write_cmos_sensor(0x0307,0x51);
+			write_cmos_sensor(0x0309,0x0A);
+			write_cmos_sensor(0x030B,0x01);
+			write_cmos_sensor(0x030C,0x00);
+			write_cmos_sensor(0x030D,0x72);
+			write_cmos_sensor(0x0160,((imgsensor_info.cap.framelength >> 8) & 0xFF));  
+			write_cmos_sensor(0x0161,(imgsensor_info.cap.framelength & 0xFF));         
+			write_cmos_sensor(0x0162,((imgsensor_info.cap.linelength >> 8) & 0xFF));	 
+			write_cmos_sensor(0x0163,(imgsensor_info.cap.linelength & 0xFF));          
+			write_cmos_sensor(0x0164,0x02);
+			write_cmos_sensor(0x0165,0xa8);
+			write_cmos_sensor(0x0166,0x0a);
+			write_cmos_sensor(0x0167,0x27);
+			write_cmos_sensor(0x0168,0x02);
+			write_cmos_sensor(0x0169,0xb4);
+			write_cmos_sensor(0x016A,0x06);
+			write_cmos_sensor(0x016B,0xe8);
+			write_cmos_sensor(0x016C,0x07);
+			write_cmos_sensor(0x016D,0x80);
+			write_cmos_sensor(0x016E,0x04);
+			write_cmos_sensor(0x016F,0x38);
+			write_cmos_sensor(0x0170,0x01);
+			write_cmos_sensor(0x0171,0x01);
+			write_cmos_sensor(0x0172,0x03);
+			write_cmos_sensor(0x0174,0x00);
+			write_cmos_sensor(0x0175,0x00);
+			write_cmos_sensor(0x018C,0x0a);
+			write_cmos_sensor(0x018D,0x0a);
+			write_cmos_sensor(0x455E,0x00);
+			write_cmos_sensor(0x471E,0x4B);
+			write_cmos_sensor(0x4767,0x0F);
+			write_cmos_sensor(0x4750,0x14);
+			write_cmos_sensor(0x4540,0x00);
+			write_cmos_sensor(0x47B4,0x14);
+			write_cmos_sensor(0x4713,0x30);
+			write_cmos_sensor(0x478B,0x10);
+			write_cmos_sensor(0x478F,0x10);
+			write_cmos_sensor(0x4793,0x10);
+			write_cmos_sensor(0x4797,0x0E);
+			write_cmos_sensor(0x479B,0x0E);
+			write_cmos_sensor(0x0104,0x00);
+			write_cmos_sensor(0x0100,0x01);
+	if (imgsensor.ihdr_en) {
+	} else {
+	}
 
 }
 
@@ -1049,86 +1033,83 @@ static void slim_video_setting()
 {
 	LOG_INF("E\n");
 
-	write_cmos_sensor(0x0100,   0x00);
-	write_cmos_sensor(0x0111,   0x02);
-	write_cmos_sensor(0x0112,   0x0A);
-	write_cmos_sensor(0x0113,   0x0A);
-	write_cmos_sensor(0x0114,   0x03);
-	write_cmos_sensor(0x0136,   0x18);
-	write_cmos_sensor(0x0137,   0x00);  
-	write_cmos_sensor(0x0202,   0x04);
-	write_cmos_sensor(0x0203,   0x3B);
-	write_cmos_sensor(0x0204,   0x00);
-	write_cmos_sensor(0x0205,   0x00);
-	write_cmos_sensor(0x0300,   0x00);
-	write_cmos_sensor(0x0301,   0x07);
-	write_cmos_sensor(0x0302,   0x00);
-	write_cmos_sensor(0x0303,   0x01);
-	write_cmos_sensor(0x0304,   0x00);
-	write_cmos_sensor(0x0305,   0x04);
-	write_cmos_sensor(0x0306,   0x01);
-	write_cmos_sensor(0x0307,   0x36);
-	write_cmos_sensor(0x0308,   0x00);
-	write_cmos_sensor(0x0309,   0x0A);
-	write_cmos_sensor(0x030A,   0x00);
-	write_cmos_sensor(0x030B,   0x01);
-	write_cmos_sensor(0x0340,   0x04);
-	write_cmos_sensor(0x0341,   0x83);
-	write_cmos_sensor(0x0342,   0x0E);
-	write_cmos_sensor(0x0343,   0xF8);
-	write_cmos_sensor(0x0344 ,  0x00);
-	write_cmos_sensor(0x0345 ,  0x00);
-	write_cmos_sensor(0x0346 ,  0x00);
-	write_cmos_sensor(0x0347 ,  0xE0);
-	write_cmos_sensor(0x0348 ,  0x0D);
-	write_cmos_sensor(0x0349 ,  0xEF);
-	write_cmos_sensor(0x034A ,  0x08);
-	write_cmos_sensor(0x034B ,  0xBF);
-	write_cmos_sensor(0x034C ,  0x05);
-	write_cmos_sensor(0x034D ,  0x10);
-	write_cmos_sensor(0x034E ,  0x02);
-	write_cmos_sensor(0x034F ,  0xDF);
-	write_cmos_sensor(0x0400 ,  0x00);
-	write_cmos_sensor(0x0401 ,  0x02);
-	write_cmos_sensor(0x0402 ,  0x00);
-	write_cmos_sensor(0x0403 ,  0x00);
-	write_cmos_sensor(0x0404 ,  0x00);
-	write_cmos_sensor(0x0405 ,  0x16);
-	write_cmos_sensor(0x0408 ,  0x00);
-	write_cmos_sensor(0x0409 ,  0x00);
-	write_cmos_sensor(0x040A ,  0x00);
-	write_cmos_sensor(0x040B ,  0x00);
-	write_cmos_sensor(0x040C ,  0x06);
-	write_cmos_sensor(0x040D ,  0xF8);
-	write_cmos_sensor(0x040E ,  0x03);
-	write_cmos_sensor(0x040F ,  0xF0);
-	write_cmos_sensor(0x0820 ,  0x07);
-	write_cmos_sensor(0x0821 ,  0x44);
-	write_cmos_sensor(0x0822 ,  0x00);
-	write_cmos_sensor(0x0823 ,  0x00);
-  write_cmos_sensor(0x0900 ,  0x01);
-	write_cmos_sensor(0x0901 ,  0x22);
-	write_cmos_sensor(0x0902 ,  0x00);
-	write_cmos_sensor(0x0216 ,  0x00);
-	write_cmos_sensor(0x0217 ,  0x00);
-	write_cmos_sensor(0x0220 ,  0x00);
-	write_cmos_sensor(0x0221 ,  0x00);
-	write_cmos_sensor(0x0222 ,  0x01);
-	write_cmos_sensor(0x0B8E ,  0x00);
-	write_cmos_sensor(0x0B8F ,  0x01);
-	write_cmos_sensor(0x0B90 ,  0x00);
-	write_cmos_sensor(0x0B91 ,  0x01);
-	write_cmos_sensor(0x0B92 ,  0x00);
-	write_cmos_sensor(0x0B93 ,  0x01);
-  write_cmos_sensor(0x0B94 ,  0x00);
-	write_cmos_sensor(0x0B95 ,  0x01);
-  write_cmos_sensor(0x0100 ,  0x01);
-
-
-
+  write_cmos_sensor(0x41C0,0x01);
+	write_cmos_sensor(0x0104,0x01);
+	write_cmos_sensor(0x0100,0x00);
+	write_cmos_sensor(0x0103,0x01);
+	write_cmos_sensor(0x0114,0x03);
+	write_cmos_sensor(0x0118,0x00);
+	write_cmos_sensor(0x0119,0x87);
+	write_cmos_sensor(0x011a,0x00);
+	write_cmos_sensor(0x011b,0x4f);
+	write_cmos_sensor(0x011c,0x00);
+	write_cmos_sensor(0x011d,0x77);
+	write_cmos_sensor(0x011e,0x00);
+	write_cmos_sensor(0x011f,0x47);
+	write_cmos_sensor(0x0120,0x00);
+	write_cmos_sensor(0x0121,0x3f);
+	write_cmos_sensor(0x0122,0x00);
+	write_cmos_sensor(0x0123,0x4f);
+	write_cmos_sensor(0x0124,0x00);
+	write_cmos_sensor(0x011f,0x01);
+	write_cmos_sensor(0x030E,0x01);
+	write_cmos_sensor(0x0202,0x03);
+	write_cmos_sensor(0x0203,0xcc);
+	write_cmos_sensor(0x0301,0x05);
+	write_cmos_sensor(0x0303,0x01);
+	write_cmos_sensor(0x0304,0x03);
+	write_cmos_sensor(0x0305,0x06);
+	write_cmos_sensor(0x0306,0x00);
+	write_cmos_sensor(0x0307,0x51);
+	write_cmos_sensor(0x0309,0x0A);
+	write_cmos_sensor(0x030B,0x01);
+	write_cmos_sensor(0x030C,0x00);
+	write_cmos_sensor(0x030D,0x72);
+	write_cmos_sensor(0x0160,((imgsensor_info.pre.framelength >> 8) & 0xFF));  
+	write_cmos_sensor(0x0161,(imgsensor_info.pre.framelength & 0xFF));	       
+	write_cmos_sensor(0x0162,((imgsensor_info.pre.linelength >> 8) & 0xFF));   
+	write_cmos_sensor(0x0163,(imgsensor_info.pre.linelength & 0xFF));	         
+	write_cmos_sensor(0x0164,0x00);
+	write_cmos_sensor(0x0165,0x00);
+	write_cmos_sensor(0x0166,0x0c);
+	write_cmos_sensor(0x0167,0xd7);
+	write_cmos_sensor(0x0168,0x00);
+	write_cmos_sensor(0x0169,0x00);
+	write_cmos_sensor(0x016A,0x09);
+	write_cmos_sensor(0x016B,0xa7);
+	write_cmos_sensor(0x016C,0x0c);
+	write_cmos_sensor(0x016D,0xd0);
+	write_cmos_sensor(0x016E,0x09);
+	write_cmos_sensor(0x016F,0xa0);
+	write_cmos_sensor(0x0170,0x01);
+	write_cmos_sensor(0x0171,0x01);
+	write_cmos_sensor(0x0172,0x03);
+	write_cmos_sensor(0x0174,0x01);
+	write_cmos_sensor(0x0175,0x00);
+	write_cmos_sensor(0x018C,0x0a);
+	write_cmos_sensor(0x018D,0x0a);
+	write_cmos_sensor(0x455E,0x00);
+	write_cmos_sensor(0x471E,0x4B);
+	write_cmos_sensor(0x4767,0x0F);
+	write_cmos_sensor(0x4750,0x14);
+	write_cmos_sensor(0x4540,0x00);
+	write_cmos_sensor(0x47B4,0x14);
+	write_cmos_sensor(0x4713,0x30);
+	write_cmos_sensor(0x478B,0x10);
+	write_cmos_sensor(0x478F,0x10);
+	write_cmos_sensor(0x4793,0x10);
+	write_cmos_sensor(0x4797,0x0E);
+	write_cmos_sensor(0x479B,0x0E);
+	write_cmos_sensor(0x0104,0x00);
+	write_cmos_sensor(0x0100,0x01);
+	//@@video_720p_30fps_800Mbps
+	
+	if (imgsensor.ihdr_en) {
+	} else {
+	}
 }
 //
-kal_uint8  test_pattern_flag166=0;
+static kal_uint8  test_pattern_flag=0;
 
 static kal_uint32 set_test_pattern_mode(kal_bool enable)
 {
@@ -1139,7 +1120,7 @@ static kal_uint32 set_test_pattern_mode(kal_bool enable)
 		   {   
 			   //1640 x 1232
 			   // enable color bar
-			   test_pattern_flag166=TRUE;
+			   test_pattern_flag=TRUE;
 			   write_cmos_sensor(0x0600, 0x00); 
 			   write_cmos_sensor(0x0601, 0x02); 	 
 			   write_cmos_sensor(0x0624, 0x06); //W:3280---h
@@ -1159,7 +1140,7 @@ static kal_uint32 set_test_pattern_mode(kal_bool enable)
 		   else 
 		   {   
 			   //1640 x 1232
-			   test_pattern_flag166=FALSE;
+			   test_pattern_flag=FALSE;
 			   write_cmos_sensor(0x0600, 0x00); 
 			   write_cmos_sensor(0x0601, 0x00); 	 
 			   write_cmos_sensor(0x0624, 0x06); //W:3280---h
@@ -1183,7 +1164,7 @@ static kal_uint32 set_test_pattern_mode(kal_bool enable)
 		   {   
 			   //3280 x 2464
 			   // enable color bar
-			   test_pattern_flag166=TRUE;
+			   test_pattern_flag=TRUE;
 			   write_cmos_sensor(0x0600, 0x00); 
 			   write_cmos_sensor(0x0601, 0x02); 	 
 			   write_cmos_sensor(0x0624, 0x0C); //W:3280---h
@@ -1202,7 +1183,7 @@ static kal_uint32 set_test_pattern_mode(kal_bool enable)
 		   } 
 		   else 
 		   {   
-			   test_pattern_flag166=FALSE;
+			   test_pattern_flag=FALSE;
 			   write_cmos_sensor(0x0600, 0x00); 
 			   write_cmos_sensor(0x0601, 0x02); 	 
 			   write_cmos_sensor(0x0624, 0x0C); //W:3280---h
@@ -1249,7 +1230,7 @@ static kal_uint32 set_test_pattern_mode(kal_bool enable)
 static kal_uint32 get_imgsensor_id(UINT32 *sensor_id) 
 {
 	kal_uint8 i = 0;
-	kal_uint8 retry = 2;
+	kal_uint8 retry = 1;
 	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
 	while (imgsensor_info.i2c_addr_table[i] != 0xff) {
 		spin_lock(&imgsensor_drv_lock);
@@ -1257,15 +1238,16 @@ static kal_uint32 get_imgsensor_id(UINT32 *sensor_id)
 		spin_unlock(&imgsensor_drv_lock);
 		do {
 			*sensor_id = return_sensor_id();
-			if (*sensor_id == imgsensor_info.sensor_id) {				
-				printk("IMX164 i2c write id: 0x%x, sensor id: 0x%x,0x%x\n", imgsensor.i2c_write_id,*sensor_id,imgsensor_info.sensor_id);	  
+			if (*sensor_id == imgsensor_info.sensor_id) 
+            {				
+				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);	  
 				return ERROR_NONE;
 			}	
-			printk("IMX164 Read sensor id fail, i2c write id: 0x%x id: 0x%x ,0x%x\n", imgsensor.i2c_write_id,*sensor_id,imgsensor_info.sensor_id);
+			LOG_INF("Read sensor id fail, i2c write id: 0x%x id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
 			retry--;
 		} while(retry > 0);
 		i++;
-		retry = 2;
+		retry = 1;
 	}
 	if (*sensor_id != imgsensor_info.sensor_id) {
 		// if Sensor ID is not correct, Must set *sensor_id to 0xFFFFFFFF 
@@ -1310,7 +1292,7 @@ static kal_uint32 open(void)
 				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);	  
 				break;
 			}	
-			LOG_INF("Read sensor id fail, id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
+			LOG_INF("Read sensor id fail, i2c write id: 0x%x,sensor id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
 			retry--;
 		} while(retry > 0);
 		i++;
@@ -1324,7 +1306,7 @@ static kal_uint32 open(void)
 	/* initail sequence write in  */
 	sensor_init();
 	
-	iPreGain166 = 0;
+	iPreGain = 0;
 	
 	spin_lock(&imgsensor_drv_lock);
 
@@ -1448,10 +1430,10 @@ static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 
 	capture_setting(imgsensor.current_fps); 
 	
-	if(test_pattern_flag166)
+	if(test_pattern_flag)
 	{
 		set_test_pattern_mode(TRUE);
-		test_pattern_flag166=FALSE;
+		test_pattern_flag=FALSE;
 	}
 	return ERROR_NONE;
 }	/* capture() */
@@ -1814,7 +1796,7 @@ static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
 	UINT32 *feature_return_para_32=(UINT32 *) feature_para;
 	UINT32 *feature_data_32=(UINT32 *) feature_para;
     unsigned long long *feature_data=(unsigned long long *) feature_para;
-	
+
 	SENSOR_WINSIZE_INFO_STRUCT *wininfo;	
 	MSDK_SENSOR_REG_INFO_STRUCT *sensor_reg_data=(MSDK_SENSOR_REG_INFO_STRUCT *) feature_para;
  
@@ -1825,18 +1807,18 @@ static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
 			*feature_return_para_16 = imgsensor.frame_length;
 			*feature_para_len=4;
 			break;
-		case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:	 
-			LOG_INF("feature_Control imgsensor.pclk = %d,imgsensor.current_fps = %d\n", imgsensor.pclk,imgsensor.current_fps);
+		case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:
+            LOG_INF("feature_Control imgsensor.pclk = %d,imgsensor.current_fps = %d\n", imgsensor.pclk,imgsensor.current_fps);
 			*feature_return_para_32 = imgsensor.pclk;
 			*feature_para_len=4;
-			break;		   
+			break;
 		case SENSOR_FEATURE_SET_ESHUTTER:
             set_shutter(*feature_data);
 			break;
 		case SENSOR_FEATURE_SET_NIGHTMODE:
             night_mode((BOOL) *feature_data);
 			break;
-		case SENSOR_FEATURE_SET_GAIN:		
+		case SENSOR_FEATURE_SET_GAIN:
             set_gain((UINT16) *feature_data);
 			break;
 		case SENSOR_FEATURE_SET_FLASHLIGHT:
@@ -1857,10 +1839,10 @@ static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
 			break;
 		case SENSOR_FEATURE_SET_VIDEO_MODE:
             set_video_mode(*feature_data);
-			break; 
+			break;
 		case SENSOR_FEATURE_CHECK_SENSOR_ID:
-			get_imgsensor_id(feature_return_para_32); 
-			break; 
+			get_imgsensor_id(feature_return_para_32);
+			break;
 		case SENSOR_FEATURE_SET_AUTO_FLICKER_MODE:
 			set_auto_flicker_mode((BOOL)*feature_data_16,*(feature_data_16+1));
 			break;
@@ -1873,30 +1855,30 @@ static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
 		case SENSOR_FEATURE_SET_TEST_PATTERN:
             set_test_pattern_mode((BOOL)*feature_data);
 			break;
-		case SENSOR_FEATURE_GET_TEST_PATTERN_CHECKSUM_VALUE: //for factory mode auto testing			 
+		case SENSOR_FEATURE_GET_TEST_PATTERN_CHECKSUM_VALUE: //for factory mode auto testing
 			*feature_return_para_32 = imgsensor_info.checksum_value;
-			*feature_para_len=4;							 
-			break;				
+			*feature_para_len=4;
+			break;
 		case SENSOR_FEATURE_SET_FRAMERATE:
             LOG_INF("current fps :%d\n", (UINT32)*feature_data);
 			spin_lock(&imgsensor_drv_lock);
             imgsensor.current_fps = *feature_data;
-			spin_unlock(&imgsensor_drv_lock);		
+			spin_unlock(&imgsensor_drv_lock);
 			break;
 		case SENSOR_FEATURE_SET_HDR:
             LOG_INF("ihdr enable :%d\n", (BOOL)*feature_data);
 			spin_lock(&imgsensor_drv_lock);
-            imgsensor.ihdr_en = (BOOL)*feature_data;
-			spin_unlock(&imgsensor_drv_lock);		
+			imgsensor.ihdr_en = *feature_data;
+			spin_unlock(&imgsensor_drv_lock);
 			break;
 		case SENSOR_FEATURE_GET_CROP_INFO:
             LOG_INF("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n", (UINT32)*feature_data);
             wininfo = (SENSOR_WINSIZE_INFO_STRUCT *)(uintptr_t)(*(feature_data+1));
-		
+
 			switch (*feature_data_32) {
 				case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
 					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[1],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-					break;	  
+					break;
 				case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
 					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[2],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
 					break;
@@ -1911,9 +1893,9 @@ static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
 					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[0],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
 					break;
 			}
-            break;
 		case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
-			LOG_INF("No IHDR function; SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",*feature_data_32,*(feature_data_32+1),*(feature_data_32+2)); 
+            LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",(UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
+            ihdr_write_shutter_gain((UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
 			break;
 		default:
 			break;
@@ -1937,4 +1919,4 @@ UINT32 IMX164_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
 	if (pfFunc!=NULL)
 		*pfFunc=&sensor_func;
 	return ERROR_NONE;
-}	/*	OV5693_MIPI_RAW_SensorInit	*/
+}	/*	MIPI_RAW_SensorInit	*/
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/imx164_mipi_raw/imx164mipiraw_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx164_mipi_raw/imx164mipiraw_Sensor.h
old mode 100644
new mode 100755
index cb74367..0f1d773
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/imx164_mipi_raw/imx164mipiraw_Sensor.h
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx164_mipi_raw/imx164mipiraw_Sensor.h
@@ -1,20 +1,58 @@
 /*****************************************************************************
+*  Copyright Statement:
+*  --------------------
+*  This software is protected by Copyright and the information contained
+*  herein is confidential. The software may not be copied and the information
+*  contained herein may not be used or disclosed except with the written
+*  permission of MediaTek Inc. (C) 2008
+*
+*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
+*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
+*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
+*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
+*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
+*
+*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
+*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
+*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+*
+*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
+*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
+*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
+*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
+*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
+*
+*****************************************************************************/
+/*****************************************************************************
  *
  * Filename:
  * ---------
- *	 OV5693mipi_Sensor.h
+ *   imx179mipiraw_sensor.h
  *
  * Project:
  * --------
- *	 ALPS
+ *   YUSU
  *
  * Description:
  * ------------
- *	 CMOS sensor header file
+ *   Header file of Sensor driver
+ *
  *
+ * Author:
+
+ *============================================================================
  ****************************************************************************/
-#ifndef _IMX164MIPI_SENSOR_H
-#define _IMX164MIPI_SENSOR_H
+#ifndef _IMX164mipi_SENSOR_H
+#define _IMX164mipi_SENSOR_H
 
 
 typedef enum{
@@ -74,11 +112,11 @@ typedef struct imgsensor_struct {
 
 /* SENSOR PRIVATE STRUCT FOR CONSTANT*/
 typedef struct imgsensor_info_struct { 
-	kal_uint32 sensor_id;			//record sensor id defined in Kd_imgsensor.h
+    kal_uint32 sensor_id;           //record sensor id defined in Kd_imgsensor.h
 	kal_uint32 checksum_value;		//checksum value for Camera Auto Test
 	imgsensor_mode_struct pre;		//preview scenario relative information
 	imgsensor_mode_struct cap;		//capture scenario relative information
-	imgsensor_mode_struct cap1;		//capture for PIP 24fps relative information, capture1 mode must use same framelength, linelength with Capture mode for shutter calculate
+	imgsensor_mode_struct cap1;		//capture for PIP 24fps relative information
 	imgsensor_mode_struct normal_video;//normal video  scenario relative information
 	imgsensor_mode_struct hs_video;	//high speed video scenario relative information
 	imgsensor_mode_struct slim_video;	//slim video for VT scenario relative information
@@ -102,13 +140,14 @@ typedef struct imgsensor_info_struct {
 
 	kal_uint8  isp_driving_current;	//mclk driving current
 	kal_uint8  sensor_interface_type;//sensor_interface_type
-	kal_uint8  mipi_sensor_type; //0,MIPI_OPHY_NCSI2; 1,MIPI_OPHY_CSI2, default is NCSI2, don't modify this para
-	kal_uint8  mipi_settle_delay_mode; //0, high speed signal auto detect; 1, use settle delay,unit is ns, default is auto detect, don't modify this para
-	kal_uint8  sensor_output_dataformat;//sensor output first pixel color
+    kal_uint8  mipi_sensor_type; //0,MIPI_OPHY_NCSI2; 1,MIPI_OPHY_CSI2, default is NCSI2, don't modify this para
+    kal_uint8  mipi_settle_delay_mode; //0, high speed signal auto detect; 1, use settle delay,unit is ns, default is auto detect, don't modify this para
+	kal_uint8  sensor_output_dataformat;
 	kal_uint8  mclk;				//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
 	
 	kal_uint8  mipi_lane_num;		//mipi lane num
 	kal_uint8  i2c_addr_table[5];	//record sensor support all write id addr, only supprt 4must end with 0xff
+    kal_uint32  i2c_speed;     //i2c speed
 } imgsensor_info_struct;
 
 /* SENSOR READ/WRITE ID */
@@ -119,5 +158,6 @@ typedef struct imgsensor_info_struct {
 
 extern int iReadRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u8 * a_pRecvData, u16 a_sizeRecvData, u16 i2cId);
 extern int iWriteRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u16 i2cId);
+extern void kdSetI2CSpeed(u16 i2cSpeed);
 
 #endif 
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/imx166_mipi_raw/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx166_mipi_raw/Makefile
new file mode 100755
index 0000000..096eedf
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx166_mipi_raw/Makefile
@@ -0,0 +1,4 @@
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+obj-y += imx166mipiraw_Sensor.o
+
+
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/imx166_mipi_raw/imx166mipiraw_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx166_mipi_raw/imx166mipiraw_Sensor.c
new file mode 100755
index 0000000..31d3df1
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx166_mipi_raw/imx166mipiraw_Sensor.c
@@ -0,0 +1,1939 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *	 imx152mipi_Sensor.c
+ *
+ * Project:
+ * --------
+ *	 ALPS
+ *
+ * Description:
+ * ------------
+ *	 Source code of Sensor driver
+ *
+ *
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *============================================================================
+ ****************************************************************************/
+
+#include <linux/videodev2.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <asm/atomic.h>
+#include <asm/system.h>
+#include <linux/xlog.h>
+
+#include "kd_camera_hw.h"
+#include "kd_imgsensor.h"
+#include "kd_imgsensor_define.h"
+#include "kd_imgsensor_errcode.h"
+
+#include "imx166mipiraw_Sensor.h"
+
+/****************************Modify following Strings for debug****************************/
+#define PFX "IMX166_camera_sensor"
+#define LOG_1 LOG_INF("IMX166,MIPI 4LANE\n")
+#define LOG_2 LOG_INF("preview 1280*960@30fps,864Mbps/lane; video 1280*960@30fps,864Mbps/lane; capture 5M@30fps,864Mbps/lane\n")
+/****************************   Modify end    *******************************************/
+
+#define LOG_INF(format, args...)	xlog_printk(ANDROID_LOG_INFO   , PFX, "[%s] " format, __FUNCTION__, ##args)
+
+static DEFINE_SPINLOCK(imgsensor_drv_lock);
+
+
+static imgsensor_info_struct imgsensor_info = { 
+	.sensor_id = IMX166_SENSOR_ID,		//record sensor id defined in Kd_imgsensor.h
+	
+	.checksum_value = 0x9e08861c,		//checksum value for Camera Auto Test
+	
+	.pre = {
+		.pclk = 265714286,				//record different mode's pclk
+		.linelength = 0xDD8,				//record different mode's linelength
+		.framelength = 0x9BF,			//record different mode's framelength
+		.startx = 0,					//record different mode's startx of grabwindow
+		.starty = 0,					//record different mode's starty of grabwindow
+		.grabwindow_width = 1632,		//record different mode's width of grabwindow
+		.grabwindow_height = 1224,		//record different mode's height of grabwindow
+		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
+		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
+		/*	 following for GetDefaultFramerateByScenario()	*/
+		.max_framerate = 300,	
+	},
+	.cap = {
+		.pclk = 265800000,
+		.linelength = 0xDD8,
+		.framelength = 0x9C0,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 3264,
+		.grabwindow_height = 2448,
+		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
+		.max_framerate = 300,
+	},
+	.cap1 = {							//capture for PIP 24fps relative information, capture1 mode must use same framelength, linelength with Capture mode for shutter calculate
+		.pclk = 212640000,
+		.linelength = 0xDD8,
+		.framelength = 0x9C0,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 3264,
+		.grabwindow_height = 2448,
+		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
+		.max_framerate = 240,	//less than 13M(include 13M),cap1 max framerate is 24fps,16M max framerate is 20fps, 20M max framerate is 15fps  
+	},
+	.normal_video = {
+		.pclk = 265800000,
+		.linelength = 0xDD8,
+		.framelength = 0x9C0,
+		.startx = 4,
+		.starty = 4,
+		.grabwindow_width = 3264,
+		.grabwindow_height = 2448,
+		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
+		.max_framerate = 300,
+	},
+	.hs_video = {
+		.pclk = 265714286,
+		.linelength = 0xEF8,
+		.framelength = 0x483,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 1280,
+		.grabwindow_height = 720,
+		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
+		.max_framerate = 600,
+	},
+	.slim_video = {
+		.pclk = 265714286,
+		.linelength = 0xEF8,
+		.framelength = 0x483,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 1280,
+		.grabwindow_height = 720,
+		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
+		.max_framerate = 600,
+
+	},
+	.margin = 16,			//sensor framelength & shutter margin
+	.min_shutter = 2,		//min shutter
+	.max_frame_length = 0xffff,//max framelength by sensor register's limitation
+	.ae_shut_delay_frame = 0,	//shutter delay frame for AE cycle, 2 frame with ispGain_delay-shut_delay=2-0=2
+	.ae_sensor_gain_delay_frame = 1,//sensor gain delay frame for AE cycle,2 frame with ispGain_delay-sensor_gain_delay=2-0=2
+	.ae_ispGain_delay_frame = 2,//isp gain delay frame for AE cycle
+	.ihdr_support = 0,	  //1, support; 0,not support
+	.ihdr_le_firstline = 0,  //1,le first ; 0, se first
+	.sensor_mode_num = 5,	  //support sensor mode num
+	
+	.cap_delay_frame = 3,		//enter capture delay frame num
+	.pre_delay_frame = 3, 		//enter preview delay frame num
+	.video_delay_frame = 3,		//enter video delay frame num
+	.hs_video_delay_frame = 3,	//enter high speed video  delay frame num
+	.slim_video_delay_frame = 3,//enter slim video delay frame num
+	
+	.isp_driving_current = ISP_DRIVING_8MA, //mclk driving current
+	.sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,//sensor_interface_type
+	.mipi_sensor_type = MIPI_OPHY_NCSI2, //0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2
+	.mipi_settle_delay_mode = 1,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
+	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_R,//sensor output first pixel color
+	.mclk = 24,//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
+	.mipi_lane_num = SENSOR_MIPI_4_LANE,//mipi lane num
+	.i2c_addr_table = {0x21, 0x20, 0xff},//record sensor support all write id addr, only supprt 4must end with 0xff
+};
+
+
+static imgsensor_struct imgsensor = {
+	.mirror = IMAGE_NORMAL,				//mirrorflip information
+	.sensor_mode = IMGSENSOR_MODE_INIT, //IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
+	.shutter = 0x3D0,					//current shutter
+	.gain = 0x100,						//current gain
+	.dummy_pixel = 0,					//current dummypixel
+	.dummy_line = 0,					//current dummyline
+	.current_fps = 300,  //full size current fps : 24fps for PIP, 30fps for Normal or ZSD
+	.autoflicker_en = KAL_FALSE,  //auto flicker enable: KAL_FALSE for disable auto flicker, KAL_TRUE for enable auto flicker
+	.test_pattern = KAL_FALSE,		//test pattern mode or not. KAL_FALSE for in test pattern mode, KAL_TRUE for normal output
+	.current_scenario_id = MSDK_SCENARIO_ID_CAMERA_PREVIEW,//current scenario id
+	.ihdr_en = 0, //sensor need support LE, SE with HDR feature
+	.i2c_write_id = 0x20,//record current sensor's i2c write id
+};
+
+
+/* Sensor output window information */
+static SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[5] =	 
+{{ 3280, 2464,	0, 	0, 3280, 2464, 1640, 1232, 0, 0, 1640, 1232,		2,	2, 1632,  1224}, // Preview 
+ { 3280, 2464,	0,	0, 3280, 2464, 3280, 2464, 0, 0, 3280, 2464,	4,	4, 3264, 2448}, // capture 
+ { 3280, 2464,	0,	0, 3280, 2464, 3280, 2464, 0, 0, 3280, 2464,	4,	4, 3264, 2448},  // video 
+ { 3280, 2464,	0,  0, 3280, 2464, 1920, 1080, 0, 0, 1920, 1080,	0,	0, 1920, 1080}, //hight speed video 
+ { 3280, 2464,	0,  0, 3280, 2464, 1640,  926, 0, 0, 1640,  926,	0,	0, 1280,  720}};// slim video 
+
+
+#define IMX166MIPI_MaxGainIndex (97)
+kal_uint16 IMX166MIPI_sensorGainMapping[IMX166MIPI_MaxGainIndex][2] ={
+{ 64 ,0  },   
+{ 68 ,12 },   
+{ 71 ,23 },   
+{ 74 ,33 },   
+{ 77 ,42 },   
+{ 81 ,52 },   
+{ 84 ,59 },   
+{ 87 ,66 },   
+{ 90 ,73 },   
+{ 93 ,79 },   
+{ 96 ,85 },   
+{ 100,91 },   
+{ 103,96 },   
+{ 106,101},   
+{ 109,105},   
+{ 113,110},   
+{ 116,114},   
+{ 120,118},   
+{ 122,121},   
+{ 125,125},   
+{ 128,128},   
+{ 132,131},   
+{ 135,134},   
+{ 138,137},
+{ 141,139},
+{ 144,142},   
+{ 148,145},   
+{ 151,147},   
+{ 153,149}, 
+{ 157,151},
+{ 160,153},      
+{ 164,156},   
+{ 168,158},   
+{ 169,159},   
+{ 173,161},   
+{ 176,163},   
+{ 180,165}, 
+{ 182,166},   
+{ 187,168},
+{ 189,169},
+{ 193,171},
+{ 196,172},
+{ 200,174},
+{ 203,175}, 
+{ 205,176},
+{ 208,177}, 
+{ 213,179}, 
+{ 216,180},  
+{ 219,181},   
+{ 222,182},
+{ 225,183},  
+{ 228,184},   
+{ 232,185},
+{ 235,186},
+{ 238,187},
+{ 241,188},
+{ 245,189},
+{ 249,190},
+{ 253,191},
+{ 256,192}, 
+{ 260,193},
+{ 265,194},
+{ 269,195},
+{ 274,196},   
+{ 278,197},
+{ 283,198},
+{ 288,199},
+{ 293,200},
+{ 298,201},   
+{ 304,202},   
+{ 310,203},
+{ 315,204},
+{ 322,205},   
+{ 328,206},   
+{ 335,207},   
+{ 342,208},   
+{ 349,209},   
+{ 357,210},   
+{ 365,211},   
+{ 373,212}, 
+{ 381,213},
+{ 400,215},      
+{ 420,217},   
+{ 432,218},   
+{ 443,219},      
+{ 468,221},   
+{ 482,222},   
+{ 497,223},   
+{ 512,224},
+{ 529,225}, 	 
+{ 546,226},   
+{ 566,227},   
+{ 585,228}, 	 
+{ 607,229},   
+{ 631,230},   
+{ 656,231},   
+{ 683,232}
+};
+
+
+static kal_uint16 read_cmos_sensor(kal_uint32 addr)
+{
+	kal_uint16 get_byte=0;
+
+	char pu_send_cmd[2] = {(char)(addr >> 8), (char)(addr & 0xFF) };
+	iReadRegI2C(pu_send_cmd, 2, (u8*)&get_byte, 1, imgsensor.i2c_write_id);
+
+	return get_byte;
+}
+
+static void write_cmos_sensor(kal_uint32 addr, kal_uint32 para)
+{
+	char pu_send_cmd[3] = {(char)(addr >> 8), (char)(addr & 0xFF), (char)(para & 0xFF)};
+	iWriteRegI2C(pu_send_cmd, 3, imgsensor.i2c_write_id);
+}
+
+static void set_dummy()
+{
+	LOG_INF("dummyline = %d, dummypixels = %d \n", imgsensor.dummy_line, imgsensor.dummy_pixel);
+	/* you can set dummy by imgsensor.dummy_line and imgsensor.dummy_pixel, or you can set dummy by imgsensor.frame_length and imgsensor.line_length */
+    write_cmos_sensor(0x0104, 1); 
+    write_cmos_sensor(0x0340, (imgsensor.frame_length >>8) & 0xFF);
+    write_cmos_sensor(0x0341, imgsensor.frame_length & 0xFF);	
+    write_cmos_sensor(0x0342, (imgsensor.line_length >>8) & 0xFF);
+    write_cmos_sensor(0x0343, imgsensor.line_length & 0xFF);
+    write_cmos_sensor(0x0104, 0); 
+  
+}	/*	set_dummy  */
+
+static kal_uint32 return_sensor_id()
+{
+	return ((read_cmos_sensor(0x0016) << 8) | read_cmos_sensor(0x0017));
+	//int sensorid;
+	//sensorid =  ((read_cmos_sensor(0x0000) << 8) | read_cmos_sensor(0x0001));
+	//LOG_INF("read sensor id:%x", sensorid);
+	//return 0x0152;
+}
+static void set_max_framerate(UINT16 framerate,kal_bool min_framelength_en)
+{
+	kal_int16 dummy_line;
+	kal_uint32 frame_length = imgsensor.frame_length;
+	//unsigned long flags;
+
+	LOG_INF("framerate = %d, min framelength should enable? \n", framerate,min_framelength_en);
+   
+	frame_length = imgsensor.pclk / framerate * 10 / imgsensor.line_length;
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.frame_length = (frame_length > imgsensor.min_frame_length) ? frame_length : imgsensor.min_frame_length; 
+	imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
+	//dummy_line = frame_length - imgsensor.min_frame_length;
+	//if (dummy_line < 0)
+		//imgsensor.dummy_line = 0;
+	//else
+		//imgsensor.dummy_line = dummy_line;
+	//imgsensor.frame_length = frame_length + imgsensor.dummy_line;
+	if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+	{
+		imgsensor.frame_length = imgsensor_info.max_frame_length;
+		imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
+	}
+	if (min_framelength_en)
+		imgsensor.min_frame_length = imgsensor.frame_length;
+	spin_unlock(&imgsensor_drv_lock);
+	set_dummy();
+}	/*	set_max_framerate  */
+
+
+static void write_shutter(kal_uint16 shutter)
+{
+	kal_uint16 realtime_fps = 0;
+	kal_uint32 frame_length = 0;
+	   
+	/* 0x3500, 0x3501, 0x3502 will increase VBLANK to get exposure larger than frame exposure */
+	/* AE doesn't update sensor gain at capture mode, thus extra exposure lines must be updated here. */
+	
+	// OV Recommend Solution
+	// if shutter bigger than frame_length, should extend frame length first
+	spin_lock(&imgsensor_drv_lock);
+	if (shutter > imgsensor.min_frame_length - imgsensor_info.margin)		
+		imgsensor.frame_length = shutter + imgsensor_info.margin;
+	else
+		imgsensor.frame_length = imgsensor.min_frame_length;
+	if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+		imgsensor.frame_length = imgsensor_info.max_frame_length;
+	spin_unlock(&imgsensor_drv_lock);
+	shutter = (shutter < imgsensor_info.min_shutter) ? imgsensor_info.min_shutter : shutter;
+	shutter = (shutter > (imgsensor_info.max_frame_length - imgsensor_info.margin)) ? (imgsensor_info.max_frame_length - imgsensor_info.margin) : shutter;
+
+    // Framelength should be an even number
+    shutter = (shutter >> 1) << 1;
+    imgsensor.frame_length = (imgsensor.frame_length >> 1) << 1;
+	
+	if (imgsensor.autoflicker_en) { 
+		realtime_fps = imgsensor.pclk / imgsensor.line_length * 10 / imgsensor.frame_length;
+		if(realtime_fps >= 297 && realtime_fps <= 305)
+			set_max_framerate(296,0);
+		else if(realtime_fps >= 147 && realtime_fps <= 150)
+			set_max_framerate(146,0);	
+		else {
+		// Extend frame length
+       	write_cmos_sensor(0x0104, 1); 
+		write_cmos_sensor(0x0340, imgsensor.frame_length >> 8);
+		write_cmos_sensor(0x0341, imgsensor.frame_length & 0xFF);
+		write_cmos_sensor(0x0104, 0); 
+		}
+	} else {
+		// Extend frame length
+		write_cmos_sensor(0x0104, 1); 
+		write_cmos_sensor(0x0340, imgsensor.frame_length >> 8);
+		write_cmos_sensor(0x0341, imgsensor.frame_length & 0xFF);
+		write_cmos_sensor(0x0104, 0); 
+	}
+
+	// Update Shutter
+	write_cmos_sensor(0x0104, 1); 
+	write_cmos_sensor(0x0202, (shutter >> 8) & 0xFF);
+	write_cmos_sensor(0x0203, (shutter ) & 0xFF);
+	write_cmos_sensor(0x0104, 0); 
+	LOG_INF("Exit! shutter =%d, framelength =%d\n", shutter,imgsensor.frame_length);
+
+	//LOG_INF("frame_length = %d ", frame_length);
+	
+}	/*	write_shutter  */
+
+
+
+/*************************************************************************
+* FUNCTION
+*	set_shutter
+*
+* DESCRIPTION
+*	This function set e-shutter of sensor to change exposure time.
+*
+* PARAMETERS
+*	iShutter : exposured lines
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static void set_shutter(kal_uint16 shutter)
+{
+	unsigned long flags;
+	kal_uint16 realtime_fps = 0;
+	kal_uint32 frame_length = 0;
+	spin_lock_irqsave(&imgsensor_drv_lock, flags);
+	imgsensor.shutter = shutter;
+	spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
+	
+	//write_shutter(shutter);
+	/* 0x3500, 0x3501, 0x3502 will increase VBLANK to get exposure larger than frame exposure */
+	/* AE doesn't update sensor gain at capture mode, thus extra exposure lines must be updated here. */
+	
+	// OV Recommend Solution
+	// if shutter bigger than frame_length, should extend frame length first
+	spin_lock(&imgsensor_drv_lock);
+	if (shutter > imgsensor.min_frame_length - imgsensor_info.margin)		
+		imgsensor.frame_length = shutter + imgsensor_info.margin;
+	else
+		imgsensor.frame_length = imgsensor.min_frame_length;
+	if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+		imgsensor.frame_length = imgsensor_info.max_frame_length;
+	spin_unlock(&imgsensor_drv_lock);
+	shutter = (shutter < imgsensor_info.min_shutter) ? imgsensor_info.min_shutter : shutter;
+	shutter = (shutter > (imgsensor_info.max_frame_length - imgsensor_info.margin)) ? (imgsensor_info.max_frame_length - imgsensor_info.margin) : shutter;
+	
+	if (imgsensor.autoflicker_en) { 
+		realtime_fps = imgsensor.pclk / imgsensor.line_length * 10 / imgsensor.frame_length;
+		if(realtime_fps >= 297 && realtime_fps <= 305)
+			set_max_framerate(296,0);
+		else if(realtime_fps >= 147 && realtime_fps <= 150)
+			set_max_framerate(146,0);	
+		else {
+		// Extend frame length
+		write_cmos_sensor(0x0104, 1); 
+		write_cmos_sensor(0x0340, imgsensor.frame_length >> 8);
+		write_cmos_sensor(0x0341, imgsensor.frame_length & 0xFF);
+		write_cmos_sensor(0x0104, 0); 
+		}
+	} else {
+		// Extend frame length
+		write_cmos_sensor(0x0104, 1); 
+		write_cmos_sensor(0x0340, imgsensor.frame_length >> 8);
+		write_cmos_sensor(0x0341, imgsensor.frame_length & 0xFF);
+		write_cmos_sensor(0x0104, 0); 
+	}
+
+	// Update Shutter
+	write_cmos_sensor(0x0104, 1); 
+	write_cmos_sensor(0x0202, (shutter >> 8) & 0xFF);
+	write_cmos_sensor(0x0203, (shutter ) & 0xFF);
+	write_cmos_sensor(0x0104, 0); 
+	LOG_INF("Exit! shutter =%d, framelength =%d\n", shutter,imgsensor.frame_length);
+
+}	/*	set_shutter */
+
+
+
+static kal_uint16 gain2reg(const kal_uint16 gain)
+{
+	kal_uint8 iI;
+    LOG_INF("[IMX166MIPI]enter IMX166MIPIGain2Reg function\n");
+    for (iI = 0; iI < (IMX166MIPI_MaxGainIndex-1); iI++) 
+	{
+
+        if(gain <IMX166MIPI_sensorGainMapping[iI][0])
+		{    
+            break;
+        }
+		if(gain < IMX166MIPI_sensorGainMapping[iI][0])
+		{                
+			return IMX166MIPI_sensorGainMapping[iI][1];       
+		}
+			
+
+    }
+    if(gain != IMX166MIPI_sensorGainMapping[iI][0])
+    {
+         LOG_INF("Gain mapping don't correctly:%d %d \n", gain, IMX166MIPI_sensorGainMapping[iI][0]);
+    }
+	LOG_INF("exit IMX166MIPIGain2Reg function\n");
+    return IMX166MIPI_sensorGainMapping[iI-1][1];
+	//return NONE;
+
+}
+
+/*************************************************************************
+* FUNCTION
+*	set_gain
+*
+* DESCRIPTION
+*	This function is to set global gain to sensor.
+*
+* PARAMETERS
+*	iGain : sensor global gain(base: 0x40)
+*
+* RETURNS
+*	the actually gain set to sensor.
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+UINT16 iPreGain166 = 0;
+static kal_uint16 set_gain(kal_uint16 gain)
+{
+	kal_uint16 reg_gain;
+
+ 	if (iPreGain166 != gain)
+	{
+		reg_gain = gain2reg(gain);
+		spin_lock(&imgsensor_drv_lock);
+		imgsensor.gain = reg_gain; 
+		spin_unlock(&imgsensor_drv_lock);
+		write_cmos_sensor(0x0104, 1);
+		write_cmos_sensor(0x0204, 0x00);
+		write_cmos_sensor(0x0205, (kal_uint8)reg_gain);
+		write_cmos_sensor(0x0104, 0); 
+		LOG_INF("gain = %d , reg_gain = 0x%x\n ", gain, reg_gain);
+ 	}
+	
+	return gain;
+}	/*	set_gain  */
+
+static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gain)
+{
+#if 0
+	LOG_INF("le:0x%x, se:0x%x, gain:0x%x\n",le,se,gain);
+	if (imgsensor.ihdr_en) {
+		
+		spin_lock(&imgsensor_drv_lock);
+			if (le > imgsensor.min_frame_length - imgsensor_info.margin)		
+				imgsensor.frame_length = le + imgsensor_info.margin;
+			else
+				imgsensor.frame_length = imgsensor.min_frame_length;
+			if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+				imgsensor.frame_length = imgsensor_info.max_frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			if (le < imgsensor_info.min_shutter) le = imgsensor_info.min_shutter;
+			if (se < imgsensor_info.min_shutter) se = imgsensor_info.min_shutter;
+			
+			
+				// Extend frame length first
+				write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
+				write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
+
+		write_cmos_sensor(0x3502, (le << 4) & 0xFF);
+		write_cmos_sensor(0x3501, (le >> 4) & 0xFF);	 
+		write_cmos_sensor(0x3500, (le >> 12) & 0x0F);
+		
+		write_cmos_sensor(0x3508, (se << 4) & 0xFF); 
+		write_cmos_sensor(0x3507, (se >> 4) & 0xFF);
+		write_cmos_sensor(0x3506, (se >> 12) & 0x0F); 
+
+		set_gain(gain);
+	}
+#endif
+}
+
+
+
+static void set_mirror_flip(kal_uint8 image_mirror)
+{
+	LOG_INF("image_mirror = %d\n", image_mirror);
+
+	/********************************************************
+	   *
+	   *   0x3820[2] ISP Vertical flip
+	   *   0x3820[1] Sensor Vertical flip
+	   *
+	   *   0x3821[2] ISP Horizontal mirror
+	   *   0x3821[1] Sensor Horizontal mirror
+	   *
+	   *   ISP and Sensor flip or mirror register bit should be the same!!
+	   *
+	   ********************************************************/
+	kal_uint8  iTemp; 
+	LOG_INF("set_mirror_flip function\n");
+    iTemp = read_cmos_sensor(0x0101);
+    iTemp &=~0x03;	//Clear the mirror and flip bits.
+
+    switch (image_mirror)
+    {
+        case IMAGE_NORMAL:
+            write_cmos_sensor(0x0101, iTemp);	//Set normal
+            break;
+        case IMAGE_V_MIRROR:
+            write_cmos_sensor(0x0101, iTemp | 0x02);	//Set flip
+            break;
+        case IMAGE_H_MIRROR:
+            write_cmos_sensor(0x0101, iTemp | 0x01);	//Set mirror
+            break;
+        case IMAGE_HV_MIRROR:
+            write_cmos_sensor(0x0101, iTemp | 0x03);	//Set mirror and flip
+            break;
+    }
+	LOG_INF("Error image_mirror setting\n");
+
+}
+
+/*************************************************************************
+* FUNCTION
+*	night_mode
+*
+* DESCRIPTION
+*	This function night mode of sensor.
+*
+* PARAMETERS
+*	bEnable: KAL_TRUE -> enable night mode, otherwise, disable night mode
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static void night_mode(kal_bool enable)
+{
+/*No Need to implement this function*/ 
+}	/*	night_mode	*/
+
+static void sensor_init(void)
+{
+	LOG_INF("E\n");
+	//write_cmos_sensor(0x0100,0x01);  //wake up
+}	/*	sensor_init  */
+
+
+static void preview_setting(void)
+{
+
+	write_cmos_sensor(0x0100,   0x00);
+	write_cmos_sensor(0x0111,   0x02);
+	write_cmos_sensor(0x0112,   0x0A);
+	write_cmos_sensor(0x0113,   0x0A);
+	write_cmos_sensor(0x0114,   0x03);
+	write_cmos_sensor(0x0136,   0x18);
+	write_cmos_sensor(0x0137,   0x00);  
+	write_cmos_sensor(0x0202,   0x04);
+	write_cmos_sensor(0x0203,   0x93);
+	write_cmos_sensor(0x0204,   0x00);
+	write_cmos_sensor(0x0205,   0x00);
+	write_cmos_sensor(0x0300,   0x00);
+	write_cmos_sensor(0x0301,   0x07);
+	write_cmos_sensor(0x0302,   0x00);
+	write_cmos_sensor(0x0303,   0x01);
+	write_cmos_sensor(0x0304,   0x00);
+	write_cmos_sensor(0x0305,   0x04);
+	write_cmos_sensor(0x0306,   0x01);
+	write_cmos_sensor(0x0307,   0x36);
+	write_cmos_sensor(0x0308,   0x00);
+	write_cmos_sensor(0x0309,   0x0A);
+	write_cmos_sensor(0x030A,   0x00);
+	write_cmos_sensor(0x030B,   0x01);
+	write_cmos_sensor(0x0340,   0x09);
+	write_cmos_sensor(0x0341,   0xBF);
+	write_cmos_sensor(0x0342,   0x0D);
+	write_cmos_sensor(0x0343,   0xD8);
+	write_cmos_sensor(0x0344 ,  0x00);
+	write_cmos_sensor(0x0345 ,  0x90);
+	write_cmos_sensor(0x0346 ,  0x00);
+	write_cmos_sensor(0x0347 ,  0x00);
+	write_cmos_sensor(0x0348 ,  0x0D);
+	write_cmos_sensor(0x0349 ,  0x5F);
+	write_cmos_sensor(0x034A ,  0x09);
+	write_cmos_sensor(0x034B ,  0x9F);
+	write_cmos_sensor(0x034C ,  0x06);
+	write_cmos_sensor(0x034D ,  0x68);
+	write_cmos_sensor(0x034E ,  0x04);
+	write_cmos_sensor(0x034F ,  0xD0);
+	write_cmos_sensor(0x0400 ,  0x00);
+	write_cmos_sensor(0x0401 ,  0x00);
+	write_cmos_sensor(0x0402 ,  0x00);
+	write_cmos_sensor(0x0403 ,  0x00);
+	write_cmos_sensor(0x0404 ,  0x00);
+	write_cmos_sensor(0x0405 ,  0x10);
+	write_cmos_sensor(0x0408 ,  0x00);
+	write_cmos_sensor(0x0409 ,  0x00);
+	write_cmos_sensor(0x040A ,  0x00);
+	write_cmos_sensor(0x040B ,  0x00);
+	write_cmos_sensor(0x040C ,  0x06);
+	write_cmos_sensor(0x040D ,  0x68);
+	write_cmos_sensor(0x040E ,  0x04);
+	write_cmos_sensor(0x040F ,  0xD0);
+	write_cmos_sensor(0x0820 ,  0x07);
+	write_cmos_sensor(0x0821 ,  0x44);
+	write_cmos_sensor(0x0822 ,  0x00);
+	write_cmos_sensor(0x0823 ,  0x00);
+	write_cmos_sensor(0x0900 ,  0x01);
+	write_cmos_sensor(0x0901 ,  0x22);
+	write_cmos_sensor(0x0902 ,  0x00);
+	write_cmos_sensor(0x0216 ,  0x00);
+	write_cmos_sensor(0x0217 ,  0x00);
+	write_cmos_sensor(0x0220 ,  0x00);
+	write_cmos_sensor(0x0221 ,  0x00);
+	write_cmos_sensor(0x0222 ,  0x01);
+	write_cmos_sensor(0x0B8E ,  0x00);
+	write_cmos_sensor(0x0B8F ,  0x01);
+	write_cmos_sensor(0x0B90 ,  0x00);
+	write_cmos_sensor(0x0B91 ,  0x01);
+	write_cmos_sensor(0x0B92 ,  0x00);
+	write_cmos_sensor(0x0B93 ,  0x01);
+	write_cmos_sensor(0x0B94 ,  0x00);
+	write_cmos_sensor(0x0B95 ,  0x01);
+	write_cmos_sensor(0x0100 ,  0x01);
+
+}	/*	preview_setting  */
+
+static void capture_setting(kal_uint16 currefps)
+{
+	LOG_INF("E! currefps:%d\n",currefps);
+	if (currefps == 240) { //24fps for PIP
+		//@@full_132PCLK_24.75
+
+	write_cmos_sensor(0x0100,   0x00);
+	write_cmos_sensor(0x0111,   0x02);
+	write_cmos_sensor(0x0112,   0x0A);
+	write_cmos_sensor(0x0113,   0x0A);
+	write_cmos_sensor(0x0114,   0x03);
+	write_cmos_sensor(0x0136,   0x18);
+	write_cmos_sensor(0x0137,   0x00);  
+	write_cmos_sensor(0x0202,   0x04);
+	write_cmos_sensor(0x0203,   0x93);
+	write_cmos_sensor(0x0204,   0x00);
+	write_cmos_sensor(0x0205,   0x00);
+	write_cmos_sensor(0x0300,   0x00);
+	write_cmos_sensor(0x0301,   0x0A);
+	write_cmos_sensor(0x0302,   0x00);
+	write_cmos_sensor(0x0303,   0x01);
+	write_cmos_sensor(0x0304,   0x00);
+	write_cmos_sensor(0x0305,   0x05);//0x04);
+	write_cmos_sensor(0x0306,   0x01);
+	write_cmos_sensor(0x0307,   0xBB);
+	write_cmos_sensor(0x0308,   0x00);
+	write_cmos_sensor(0x0309,   0x0A);
+	write_cmos_sensor(0x030A,   0x00);
+	write_cmos_sensor(0x030B,   0x01);
+	write_cmos_sensor(0x0340,   0x09);
+	write_cmos_sensor(0x0341,   0xC0);
+	write_cmos_sensor(0x0342,   0x0D);
+	write_cmos_sensor(0x0343,   0xD8);
+	write_cmos_sensor(0x0344 ,  0x00);
+	write_cmos_sensor(0x0345 ,  0x90);
+	write_cmos_sensor(0x0346 ,  0x00);
+	write_cmos_sensor(0x0347 ,  0x00);
+	write_cmos_sensor(0x0348 ,  0x0D);
+	write_cmos_sensor(0x0349 ,  0x5F);
+	write_cmos_sensor(0x034A ,  0x09);
+	write_cmos_sensor(0x034B ,  0x9F);
+	write_cmos_sensor(0x034C ,  0x0C);
+	write_cmos_sensor(0x034D ,  0xD0);
+	write_cmos_sensor(0x034E ,  0x09);
+	write_cmos_sensor(0x034F ,  0xA0);
+	write_cmos_sensor(0x0400 ,  0x00);
+	write_cmos_sensor(0x0401 ,  0x00);
+	write_cmos_sensor(0x0402 ,  0x00);
+	write_cmos_sensor(0x0403 ,  0x00);
+	write_cmos_sensor(0x0404 ,  0x00);
+	write_cmos_sensor(0x0405 ,  0x10);
+	write_cmos_sensor(0x0408 ,  0x00);
+	write_cmos_sensor(0x0409 ,  0x00);
+	write_cmos_sensor(0x040A ,  0x00);
+	write_cmos_sensor(0x040B ,  0x00);
+	write_cmos_sensor(0x040C ,  0x0C);
+	write_cmos_sensor(0x040D ,  0xD0);
+	write_cmos_sensor(0x040E ,  0x09);
+	write_cmos_sensor(0x040F ,  0xA0);
+	write_cmos_sensor(0x0820 ,  0x0A);
+	write_cmos_sensor(0x0821 ,  0x62);
+	write_cmos_sensor(0x0822 ,  0x00);
+	write_cmos_sensor(0x0823 ,  0x00);
+  write_cmos_sensor(0x0900 ,  0x00);
+	write_cmos_sensor(0x0901 ,  0x00);
+	write_cmos_sensor(0x0902 ,  0x00);
+	write_cmos_sensor(0x0216 ,  0x00);
+	write_cmos_sensor(0x0217 ,  0x00);
+	write_cmos_sensor(0x0220 ,  0x00);
+	write_cmos_sensor(0x0221 ,  0x00);
+	write_cmos_sensor(0x0222 ,  0x01);
+	write_cmos_sensor(0x0B8E ,  0x00);
+	write_cmos_sensor(0x0B8F ,  0x01);
+	write_cmos_sensor(0x0B90 ,  0x00);
+	write_cmos_sensor(0x0B91 ,  0x01);
+	write_cmos_sensor(0x0B92 ,  0x00);
+	write_cmos_sensor(0x0B93 ,  0x01);
+  write_cmos_sensor(0x0B94 ,  0x00);
+	write_cmos_sensor(0x0B95 ,  0x01);
+  write_cmos_sensor(0x0100 ,  0x01);
+
+	} else {   //30fps			//30fps for Normal capture & ZSD
+
+	write_cmos_sensor(0x0100,   0x00);
+	write_cmos_sensor(0x0111,   0x02);
+	write_cmos_sensor(0x0112,   0x0A);
+	write_cmos_sensor(0x0113,   0x0A);
+	write_cmos_sensor(0x0114,   0x03);
+	write_cmos_sensor(0x0136,   0x18);
+	write_cmos_sensor(0x0137,   0x00);  
+	write_cmos_sensor(0x0202,   0x04);
+	write_cmos_sensor(0x0203,   0x93);
+	write_cmos_sensor(0x0204,   0x00);
+	write_cmos_sensor(0x0205,   0x00);
+	write_cmos_sensor(0x0300,   0x00);
+	write_cmos_sensor(0x0301,   0x0A);
+	write_cmos_sensor(0x0302,   0x00);
+	write_cmos_sensor(0x0303,   0x01);
+	write_cmos_sensor(0x0304,   0x00);
+	write_cmos_sensor(0x0305,   0x04);
+	write_cmos_sensor(0x0306,   0x01);
+	write_cmos_sensor(0x0307,   0xBB);
+	write_cmos_sensor(0x0308,   0x00);
+	write_cmos_sensor(0x0309,   0x0A);
+	write_cmos_sensor(0x030A,   0x00);
+	write_cmos_sensor(0x030B,   0x01);
+	write_cmos_sensor(0x0340,   0x09);
+	write_cmos_sensor(0x0341,   0xC0);
+	write_cmos_sensor(0x0342,   0x0D);
+	write_cmos_sensor(0x0343,   0xD8);
+	write_cmos_sensor(0x0344 ,  0x00);
+	write_cmos_sensor(0x0345 ,  0x90);
+	write_cmos_sensor(0x0346 ,  0x00);
+	write_cmos_sensor(0x0347 ,  0x00);
+	write_cmos_sensor(0x0348 ,  0x0D);
+	write_cmos_sensor(0x0349 ,  0x5F);
+	write_cmos_sensor(0x034A ,  0x09);
+	write_cmos_sensor(0x034B ,  0x9F);
+	write_cmos_sensor(0x034C ,  0x0C);
+	write_cmos_sensor(0x034D ,  0xD0);
+	write_cmos_sensor(0x034E ,  0x09);
+	write_cmos_sensor(0x034F ,  0xA0);
+	write_cmos_sensor(0x0400 ,  0x00);
+	write_cmos_sensor(0x0401 ,  0x00);
+	write_cmos_sensor(0x0402 ,  0x00);
+	write_cmos_sensor(0x0403 ,  0x00);
+	write_cmos_sensor(0x0404 ,  0x00);
+	write_cmos_sensor(0x0405 ,  0x10);
+	write_cmos_sensor(0x0408 ,  0x00);
+	write_cmos_sensor(0x0409 ,  0x00);
+	write_cmos_sensor(0x040A ,  0x00);
+	write_cmos_sensor(0x040B ,  0x00);
+	write_cmos_sensor(0x040C ,  0x0C);
+	write_cmos_sensor(0x040D ,  0xD0);
+	write_cmos_sensor(0x040E ,  0x09);
+	write_cmos_sensor(0x040F ,  0xA0);
+	write_cmos_sensor(0x0820 ,  0x0A);
+	write_cmos_sensor(0x0821 ,  0x62);
+	write_cmos_sensor(0x0822 ,  0x00);
+	write_cmos_sensor(0x0823 ,  0x00);
+  write_cmos_sensor(0x0900 ,  0x00);
+	write_cmos_sensor(0x0901 ,  0x00);
+	write_cmos_sensor(0x0902 ,  0x00);
+	write_cmos_sensor(0x0216 ,  0x00);
+	write_cmos_sensor(0x0217 ,  0x00);
+	write_cmos_sensor(0x0220 ,  0x00);
+	write_cmos_sensor(0x0221 ,  0x00);
+	write_cmos_sensor(0x0222 ,  0x01);
+	write_cmos_sensor(0x0B8E ,  0x00);
+	write_cmos_sensor(0x0B8F ,  0x01);
+	write_cmos_sensor(0x0B90 ,  0x00);
+	write_cmos_sensor(0x0B91 ,  0x01);
+	write_cmos_sensor(0x0B92 ,  0x00);
+	write_cmos_sensor(0x0B93 ,  0x01);
+  write_cmos_sensor(0x0B94 ,  0x00);
+	write_cmos_sensor(0x0B95 ,  0x01);
+  write_cmos_sensor(0x0100 ,  0x01);
+
+	}
+		
+}
+
+static void normal_video_setting(kal_uint16 currefps)
+{
+	LOG_INF("E! currefps:%d\n",currefps);
+	write_cmos_sensor(0x0100,   0x00);
+	write_cmos_sensor(0x0111,   0x02);
+	write_cmos_sensor(0x0112,   0x0A);
+	write_cmos_sensor(0x0113,   0x0A);
+	write_cmos_sensor(0x0114,   0x03);
+	write_cmos_sensor(0x0136,   0x18);
+	write_cmos_sensor(0x0137,   0x00);  
+	write_cmos_sensor(0x0202,   0x04);
+	write_cmos_sensor(0x0203,   0x93);
+	write_cmos_sensor(0x0204,   0x00);
+	write_cmos_sensor(0x0205,   0x00);
+	write_cmos_sensor(0x0300,   0x00);
+	write_cmos_sensor(0x0301,   0x0A);
+	write_cmos_sensor(0x0302,   0x00);
+	write_cmos_sensor(0x0303,   0x01);
+	write_cmos_sensor(0x0304,   0x00);
+	write_cmos_sensor(0x0305,   0x04);
+	write_cmos_sensor(0x0306,   0x01);
+	write_cmos_sensor(0x0307,   0xBB);
+	write_cmos_sensor(0x0308,   0x00);
+	write_cmos_sensor(0x0309,   0x0A);
+	write_cmos_sensor(0x030A,   0x00);
+	write_cmos_sensor(0x030B,   0x01);
+	write_cmos_sensor(0x0340,   0x09);
+	write_cmos_sensor(0x0341,   0xC0);
+	write_cmos_sensor(0x0342,   0x0D);
+	write_cmos_sensor(0x0343,   0xD8);
+	write_cmos_sensor(0x0344 ,  0x00);
+	write_cmos_sensor(0x0345 ,  0x90);
+	write_cmos_sensor(0x0346 ,  0x00);
+	write_cmos_sensor(0x0347 ,  0x00);
+	write_cmos_sensor(0x0348 ,  0x0D);
+	write_cmos_sensor(0x0349 ,  0x5F);
+	write_cmos_sensor(0x034A ,  0x09);
+	write_cmos_sensor(0x034B ,  0x9F);
+	write_cmos_sensor(0x034C ,  0x0C);
+	write_cmos_sensor(0x034D ,  0xD0);
+	write_cmos_sensor(0x034E ,  0x09);
+	write_cmos_sensor(0x034F ,  0xA0);
+	write_cmos_sensor(0x0400 ,  0x00);
+	write_cmos_sensor(0x0401 ,  0x00);
+	write_cmos_sensor(0x0402 ,  0x00);
+	write_cmos_sensor(0x0403 ,  0x00);
+	write_cmos_sensor(0x0404 ,  0x00);
+	write_cmos_sensor(0x0405 ,  0x10);
+	write_cmos_sensor(0x0408 ,  0x00);
+	write_cmos_sensor(0x0409 ,  0x00);
+	write_cmos_sensor(0x040A ,  0x00);
+	write_cmos_sensor(0x040B ,  0x00);
+	write_cmos_sensor(0x040C ,  0x0C);
+	write_cmos_sensor(0x040D ,  0xD0);
+	write_cmos_sensor(0x040E ,  0x09);
+	write_cmos_sensor(0x040F ,  0xA0);
+	write_cmos_sensor(0x0820 ,  0x0A);
+	write_cmos_sensor(0x0821 ,  0x62);
+	write_cmos_sensor(0x0822 ,  0x00);
+	write_cmos_sensor(0x0823 ,  0x00);
+  write_cmos_sensor(0x0900 ,  0x00);
+	write_cmos_sensor(0x0901 ,  0x00);
+	write_cmos_sensor(0x0902 ,  0x00);
+	write_cmos_sensor(0x0216 ,  0x00);
+	write_cmos_sensor(0x0217 ,  0x00);
+	write_cmos_sensor(0x0220 ,  0x00);
+	write_cmos_sensor(0x0221 ,  0x00);
+	write_cmos_sensor(0x0222 ,  0x01);
+	write_cmos_sensor(0x0B8E ,  0x00);
+	write_cmos_sensor(0x0B8F ,  0x01);
+	write_cmos_sensor(0x0B90 ,  0x00);
+	write_cmos_sensor(0x0B91 ,  0x01);
+	write_cmos_sensor(0x0B92 ,  0x00);
+	write_cmos_sensor(0x0B93 ,  0x01);
+  write_cmos_sensor(0x0B94 ,  0x00);
+	write_cmos_sensor(0x0B95 ,  0x01);
+  write_cmos_sensor(0x0100 ,  0x01);
+}
+static void hs_video_setting()
+{
+	LOG_INF("E\n");
+	
+	write_cmos_sensor(0x0100,   0x00);
+	write_cmos_sensor(0x0111,   0x02);
+	write_cmos_sensor(0x0112,   0x0A);
+	write_cmos_sensor(0x0113,   0x0A);
+	write_cmos_sensor(0x0114,   0x03);
+	write_cmos_sensor(0x0136,   0x18);
+	write_cmos_sensor(0x0137,   0x00);  
+	write_cmos_sensor(0x0202,   0x04);
+	write_cmos_sensor(0x0203,   0x3B);
+	write_cmos_sensor(0x0204,   0x00);
+	write_cmos_sensor(0x0205,   0x00);
+	write_cmos_sensor(0x0300,   0x00);
+	write_cmos_sensor(0x0301,   0x07);
+	write_cmos_sensor(0x0302,   0x00);
+	write_cmos_sensor(0x0303,   0x01);
+	write_cmos_sensor(0x0304,   0x00);
+	write_cmos_sensor(0x0305,   0x04);
+	write_cmos_sensor(0x0306,   0x01);
+	write_cmos_sensor(0x0307,   0x36);
+	write_cmos_sensor(0x0308,   0x00);
+	write_cmos_sensor(0x0309,   0x0A);
+	write_cmos_sensor(0x030A,   0x00);
+	write_cmos_sensor(0x030B,   0x01);
+	write_cmos_sensor(0x0340,   0x04);
+	write_cmos_sensor(0x0341,   0x83);
+	write_cmos_sensor(0x0342,   0x0E);
+	write_cmos_sensor(0x0343,   0xF8);
+	write_cmos_sensor(0x0344 ,  0x00);
+	write_cmos_sensor(0x0345 ,  0x00);
+	write_cmos_sensor(0x0346 ,  0x00);
+	write_cmos_sensor(0x0347 ,  0xE0);
+	write_cmos_sensor(0x0348 ,  0x0D);
+	write_cmos_sensor(0x0349 ,  0xEF);
+	write_cmos_sensor(0x034A ,  0x08);
+	write_cmos_sensor(0x034B ,  0xBF);
+	write_cmos_sensor(0x034C ,  0x05);
+	write_cmos_sensor(0x034D ,  0x10);
+	write_cmos_sensor(0x034E ,  0x02);
+	write_cmos_sensor(0x034F ,  0xDF);
+	write_cmos_sensor(0x0400 ,  0x00);
+	write_cmos_sensor(0x0401 ,  0x02);
+	write_cmos_sensor(0x0402 ,  0x00);
+	write_cmos_sensor(0x0403 ,  0x00);
+	write_cmos_sensor(0x0404 ,  0x00);
+	write_cmos_sensor(0x0405 ,  0x16);
+	write_cmos_sensor(0x0408 ,  0x00);
+	write_cmos_sensor(0x0409 ,  0x00);
+	write_cmos_sensor(0x040A ,  0x00);
+	write_cmos_sensor(0x040B ,  0x00);
+	write_cmos_sensor(0x040C ,  0x06);
+	write_cmos_sensor(0x040D ,  0xF8);
+	write_cmos_sensor(0x040E ,  0x03);
+	write_cmos_sensor(0x040F ,  0xF0);
+	write_cmos_sensor(0x0820 ,  0x07);
+	write_cmos_sensor(0x0821 ,  0x44);
+	write_cmos_sensor(0x0822 ,  0x00);
+	write_cmos_sensor(0x0823 ,  0x00);
+  write_cmos_sensor(0x0900 ,  0x01);
+	write_cmos_sensor(0x0901 ,  0x22);
+	write_cmos_sensor(0x0902 ,  0x00);
+	write_cmos_sensor(0x0216 ,  0x00);
+	write_cmos_sensor(0x0217 ,  0x00);
+	write_cmos_sensor(0x0220 ,  0x00);
+	write_cmos_sensor(0x0221 ,  0x00);
+	write_cmos_sensor(0x0222 ,  0x01);
+	write_cmos_sensor(0x0B8E ,  0x00);
+	write_cmos_sensor(0x0B8F ,  0x01);
+	write_cmos_sensor(0x0B90 ,  0x00);
+	write_cmos_sensor(0x0B91 ,  0x01);
+	write_cmos_sensor(0x0B92 ,  0x00);
+	write_cmos_sensor(0x0B93 ,  0x01);
+  write_cmos_sensor(0x0B94 ,  0x00);
+	write_cmos_sensor(0x0B95 ,  0x01);
+  write_cmos_sensor(0x0100 ,  0x01);
+
+}
+
+static void slim_video_setting()
+{
+	LOG_INF("E\n");
+
+	write_cmos_sensor(0x0100,   0x00);
+	write_cmos_sensor(0x0111,   0x02);
+	write_cmos_sensor(0x0112,   0x0A);
+	write_cmos_sensor(0x0113,   0x0A);
+	write_cmos_sensor(0x0114,   0x03);
+	write_cmos_sensor(0x0136,   0x18);
+	write_cmos_sensor(0x0137,   0x00);  
+	write_cmos_sensor(0x0202,   0x04);
+	write_cmos_sensor(0x0203,   0x3B);
+	write_cmos_sensor(0x0204,   0x00);
+	write_cmos_sensor(0x0205,   0x00);
+	write_cmos_sensor(0x0300,   0x00);
+	write_cmos_sensor(0x0301,   0x07);
+	write_cmos_sensor(0x0302,   0x00);
+	write_cmos_sensor(0x0303,   0x01);
+	write_cmos_sensor(0x0304,   0x00);
+	write_cmos_sensor(0x0305,   0x04);
+	write_cmos_sensor(0x0306,   0x01);
+	write_cmos_sensor(0x0307,   0x36);
+	write_cmos_sensor(0x0308,   0x00);
+	write_cmos_sensor(0x0309,   0x0A);
+	write_cmos_sensor(0x030A,   0x00);
+	write_cmos_sensor(0x030B,   0x01);
+	write_cmos_sensor(0x0340,   0x04);
+	write_cmos_sensor(0x0341,   0x83);
+	write_cmos_sensor(0x0342,   0x0E);
+	write_cmos_sensor(0x0343,   0xF8);
+	write_cmos_sensor(0x0344 ,  0x00);
+	write_cmos_sensor(0x0345 ,  0x00);
+	write_cmos_sensor(0x0346 ,  0x00);
+	write_cmos_sensor(0x0347 ,  0xE0);
+	write_cmos_sensor(0x0348 ,  0x0D);
+	write_cmos_sensor(0x0349 ,  0xEF);
+	write_cmos_sensor(0x034A ,  0x08);
+	write_cmos_sensor(0x034B ,  0xBF);
+	write_cmos_sensor(0x034C ,  0x05);
+	write_cmos_sensor(0x034D ,  0x10);
+	write_cmos_sensor(0x034E ,  0x02);
+	write_cmos_sensor(0x034F ,  0xDF);
+	write_cmos_sensor(0x0400 ,  0x00);
+	write_cmos_sensor(0x0401 ,  0x02);
+	write_cmos_sensor(0x0402 ,  0x00);
+	write_cmos_sensor(0x0403 ,  0x00);
+	write_cmos_sensor(0x0404 ,  0x00);
+	write_cmos_sensor(0x0405 ,  0x16);
+	write_cmos_sensor(0x0408 ,  0x00);
+	write_cmos_sensor(0x0409 ,  0x00);
+	write_cmos_sensor(0x040A ,  0x00);
+	write_cmos_sensor(0x040B ,  0x00);
+	write_cmos_sensor(0x040C ,  0x06);
+	write_cmos_sensor(0x040D ,  0xF8);
+	write_cmos_sensor(0x040E ,  0x03);
+	write_cmos_sensor(0x040F ,  0xF0);
+	write_cmos_sensor(0x0820 ,  0x07);
+	write_cmos_sensor(0x0821 ,  0x44);
+	write_cmos_sensor(0x0822 ,  0x00);
+	write_cmos_sensor(0x0823 ,  0x00);
+  write_cmos_sensor(0x0900 ,  0x01);
+	write_cmos_sensor(0x0901 ,  0x22);
+	write_cmos_sensor(0x0902 ,  0x00);
+	write_cmos_sensor(0x0216 ,  0x00);
+	write_cmos_sensor(0x0217 ,  0x00);
+	write_cmos_sensor(0x0220 ,  0x00);
+	write_cmos_sensor(0x0221 ,  0x00);
+	write_cmos_sensor(0x0222 ,  0x01);
+	write_cmos_sensor(0x0B8E ,  0x00);
+	write_cmos_sensor(0x0B8F ,  0x01);
+	write_cmos_sensor(0x0B90 ,  0x00);
+	write_cmos_sensor(0x0B91 ,  0x01);
+	write_cmos_sensor(0x0B92 ,  0x00);
+	write_cmos_sensor(0x0B93 ,  0x01);
+  write_cmos_sensor(0x0B94 ,  0x00);
+	write_cmos_sensor(0x0B95 ,  0x01);
+  write_cmos_sensor(0x0100 ,  0x01);
+
+
+
+}
+//
+kal_uint8  test_pattern_flag166=0;
+
+static kal_uint32 set_test_pattern_mode(kal_bool enable)
+{
+	LOG_INF("enable: %d\n", enable);
+	if(imgsensor.current_scenario_id != MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG)
+	   {
+		   if(enable) 
+		   {   
+			   //1640 x 1232
+			   // enable color bar
+			   test_pattern_flag166=TRUE;
+			   write_cmos_sensor(0x0600, 0x00); 
+			   write_cmos_sensor(0x0601, 0x02); 	 
+			   write_cmos_sensor(0x0624, 0x06); //W:3280---h
+			   write_cmos_sensor(0x0625, 0x68); //		  l
+			   write_cmos_sensor(0x0626, 0x04); //H:2464   h
+			   write_cmos_sensor(0x0627, 0xd0); //		  l
+			   write_cmos_sensor(0x6128, 0x00); 
+			   write_cmos_sensor(0x6129, 0x02); 		 
+			   write_cmos_sensor(0x613C, 0x06); //W 		h
+			   write_cmos_sensor(0x613D, 0x68); //		   l
+			   write_cmos_sensor(0x613E, 0x04); //H 		h
+			   write_cmos_sensor(0x613F, 0xd0); //			   l
+			   write_cmos_sensor(0x6506, 0x00); 
+			   write_cmos_sensor(0x6507, 0x00);
+	
+		   } 
+		   else 
+		   {   
+			   //1640 x 1232
+			   test_pattern_flag166=FALSE;
+			   write_cmos_sensor(0x0600, 0x00); 
+			   write_cmos_sensor(0x0601, 0x00); 	 
+			   write_cmos_sensor(0x0624, 0x06); //W:3280---h
+			   write_cmos_sensor(0x0625, 0x68); //		  l
+			   write_cmos_sensor(0x0626, 0x04); //H:2464   h
+			   write_cmos_sensor(0x0627, 0xd0); //		  l
+			   write_cmos_sensor(0x6128, 0x00); 
+			   write_cmos_sensor(0x6129, 0x02); 		 
+			   write_cmos_sensor(0x613C, 0x06); //W 		h
+			   write_cmos_sensor(0x613D, 0x68); //		   l
+			   write_cmos_sensor(0x613E, 0x04); //H 		h
+			   write_cmos_sensor(0x613F, 0xd0); //			   l
+			   write_cmos_sensor(0x6506, 0x00); 
+			   write_cmos_sensor(0x6507, 0x00);
+	
+		   }
+	   }
+	   else
+	   {
+		   if(enable) 
+		   {   
+			   //3280 x 2464
+			   // enable color bar
+			   test_pattern_flag166=TRUE;
+			   write_cmos_sensor(0x0600, 0x00); 
+			   write_cmos_sensor(0x0601, 0x02); 	 
+			   write_cmos_sensor(0x0624, 0x0C); //W:3280---h
+			   write_cmos_sensor(0x0625, 0xD0); //		  l
+			   write_cmos_sensor(0x0626, 0x09); //H:2464   h
+			   write_cmos_sensor(0x0627, 0xA0); //		  l
+			   write_cmos_sensor(0x6128, 0x00); 
+			   write_cmos_sensor(0x6129, 0x02); 		 
+			   write_cmos_sensor(0x613C, 0x0C); //W 		h
+			   write_cmos_sensor(0x613D, 0xD0); //		   l
+			   write_cmos_sensor(0x613E, 0x09); //H 		h
+			   write_cmos_sensor(0x613F, 0xA0); //			   l
+			   write_cmos_sensor(0x6506, 0x00); 
+			   write_cmos_sensor(0x6507, 0x00);
+	
+		   } 
+		   else 
+		   {   
+			   test_pattern_flag166=FALSE;
+			   write_cmos_sensor(0x0600, 0x00); 
+			   write_cmos_sensor(0x0601, 0x02); 	 
+			   write_cmos_sensor(0x0624, 0x0C); //W:3280---h
+			   write_cmos_sensor(0x0625, 0xD0); //		  l
+			   write_cmos_sensor(0x0626, 0x09); //H:2464   h
+			   write_cmos_sensor(0x0627, 0xA0); //		  l
+			   write_cmos_sensor(0x6128, 0x00); 
+			   write_cmos_sensor(0x6129, 0x02); 		 
+			   write_cmos_sensor(0x613C, 0x0C); //W 		h
+			   write_cmos_sensor(0x613D, 0xD0); //		   l
+			   write_cmos_sensor(0x613E, 0x09); //H 		h
+			   write_cmos_sensor(0x613F, 0xA0); //			   l
+			   write_cmos_sensor(0x6506, 0x00); 
+			   write_cmos_sensor(0x6507, 0x00);
+	
+	
+		   }
+	   }
+		   
+	   return ERROR_NONE;
+
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.test_pattern = enable;
+	spin_unlock(&imgsensor_drv_lock);
+	return ERROR_NONE;
+}
+
+/*************************************************************************
+* FUNCTION
+*	get_imgsensor_id
+*
+* DESCRIPTION
+*	This function get the sensor ID 
+*
+* PARAMETERS
+*	*sensorID : return the sensor ID 
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 get_imgsensor_id(UINT32 *sensor_id) 
+{
+	kal_uint8 i = 0;
+	kal_uint8 retry = 2;
+	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
+	while (imgsensor_info.i2c_addr_table[i] != 0xff) {
+		spin_lock(&imgsensor_drv_lock);
+		imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
+		spin_unlock(&imgsensor_drv_lock);
+		do {
+			*sensor_id = return_sensor_id();
+			if (*sensor_id == imgsensor_info.sensor_id) {				
+				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);	  
+				return ERROR_NONE;
+			}	
+			LOG_INF("Read sensor id fail, i2c write id: 0x%x id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
+			retry--;
+		} while(retry > 0);
+		i++;
+		retry = 2;
+	}
+	if (*sensor_id != imgsensor_info.sensor_id) {
+		// if Sensor ID is not correct, Must set *sensor_id to 0xFFFFFFFF 
+		*sensor_id = 0xFFFFFFFF;
+		return ERROR_SENSOR_CONNECT_FAIL;
+	}
+	return ERROR_NONE;
+}
+
+
+/*************************************************************************
+* FUNCTION
+*	open
+*
+* DESCRIPTION
+*	This function initialize the registers of CMOS sensor
+*
+* PARAMETERS
+*	None
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 open(void)
+{
+	kal_uint8 i = 0;
+	kal_uint8 retry = 2;
+	kal_uint32 sensor_id = 0; 
+	LOG_1;
+	LOG_2;
+	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
+	while (imgsensor_info.i2c_addr_table[i] != 0xff) {
+		spin_lock(&imgsensor_drv_lock);
+		imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
+		spin_unlock(&imgsensor_drv_lock);
+		do {
+			sensor_id = return_sensor_id();
+			if (sensor_id == imgsensor_info.sensor_id) {				
+				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);	  
+				break;
+			}	
+			LOG_INF("Read sensor id fail, id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
+			retry--;
+		} while(retry > 0);
+		i++;
+		if (sensor_id == imgsensor_info.sensor_id)
+			break;
+		retry = 2;
+	}		 
+	if (imgsensor_info.sensor_id != sensor_id)
+		return ERROR_SENSOR_CONNECT_FAIL;
+	
+	/* initail sequence write in  */
+	sensor_init();
+	
+	iPreGain166 = 0;
+	
+	spin_lock(&imgsensor_drv_lock);
+
+	imgsensor.autoflicker_en= KAL_FALSE;
+	imgsensor.sensor_mode = IMGSENSOR_MODE_INIT;
+	imgsensor.pclk = imgsensor_info.pre.pclk;
+	imgsensor.frame_length = imgsensor_info.pre.framelength;
+	imgsensor.line_length = imgsensor_info.pre.linelength;
+	imgsensor.min_frame_length = imgsensor_info.pre.framelength;
+	imgsensor.dummy_pixel = 0;
+	imgsensor.dummy_line = 0;
+	imgsensor.ihdr_en = 0;
+	imgsensor.test_pattern = KAL_FALSE;
+	imgsensor.current_fps = imgsensor_info.pre.max_framerate;
+	spin_unlock(&imgsensor_drv_lock);
+
+	return ERROR_NONE;
+}	/*	open  */
+
+
+
+/*************************************************************************
+* FUNCTION
+*	close
+*
+* DESCRIPTION
+*	
+*
+* PARAMETERS
+*	None
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 close(void)
+{
+	LOG_INF("E\n");
+
+	/*No Need to implement this function*/ 
+	
+	return ERROR_NONE;
+}	/*	close  */
+
+
+/*************************************************************************
+* FUNCTION
+* preview
+*
+* DESCRIPTION
+*	This function start the sensor preview.
+*
+* PARAMETERS
+*	*image_window : address pointer of pixel numbers in one period of HSYNC
+*  *sensor_config_data : address pointer of line numbers in one period of VSYNC
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("E\n");
+
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.sensor_mode = IMGSENSOR_MODE_PREVIEW;
+	imgsensor.pclk = imgsensor_info.pre.pclk;
+	//imgsensor.video_mode = KAL_FALSE;
+	imgsensor.line_length = imgsensor_info.pre.linelength;
+	imgsensor.frame_length = imgsensor_info.pre.framelength; 
+	imgsensor.min_frame_length = imgsensor_info.pre.framelength;
+	imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	preview_setting();
+	return ERROR_NONE;
+}	/*	preview   */
+
+/*************************************************************************
+* FUNCTION
+*	capture
+*
+* DESCRIPTION
+*	This function setup the CMOS sensor in capture MY_OUTPUT mode
+*
+* PARAMETERS
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+						  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("E\n");
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.sensor_mode = IMGSENSOR_MODE_CAPTURE;
+	if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {//PIP capture: 24fps for less than 13M, 20fps for 16M,15fps for 20M
+		imgsensor.pclk = imgsensor_info.cap1.pclk;
+		imgsensor.line_length = imgsensor_info.cap1.linelength;
+		imgsensor.frame_length = imgsensor_info.cap1.framelength;  
+		imgsensor.min_frame_length = imgsensor_info.cap1.framelength;
+		imgsensor.autoflicker_en = KAL_FALSE;
+	} else {
+		if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
+			LOG_INF("Warning: current_fps %d fps is not support, so use cap1's setting: %d fps!\n",imgsensor_info.cap1.max_framerate/10);
+		imgsensor.pclk = imgsensor_info.cap.pclk;
+		imgsensor.line_length = imgsensor_info.cap.linelength;
+		imgsensor.frame_length = imgsensor_info.cap.framelength;  
+		imgsensor.min_frame_length = imgsensor_info.cap.framelength;
+		imgsensor.autoflicker_en = KAL_FALSE;
+	}
+
+	spin_unlock(&imgsensor_drv_lock);
+
+	capture_setting(imgsensor.current_fps); 
+	
+	if(test_pattern_flag166)
+	{
+		set_test_pattern_mode(TRUE);
+		test_pattern_flag166=FALSE;
+	}
+	return ERROR_NONE;
+}	/* capture() */
+static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("E\n");
+	
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.sensor_mode = IMGSENSOR_MODE_VIDEO;
+	imgsensor.pclk = imgsensor_info.normal_video.pclk;
+	imgsensor.line_length = imgsensor_info.normal_video.linelength;
+	imgsensor.frame_length = imgsensor_info.normal_video.framelength;  
+	imgsensor.min_frame_length = imgsensor_info.normal_video.framelength;
+	//imgsensor.current_fps = 300;
+	imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	normal_video_setting(imgsensor.current_fps);
+	
+	
+	return ERROR_NONE;
+}	/*	normal_video   */
+
+static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("E\n");
+	
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.sensor_mode = IMGSENSOR_MODE_HIGH_SPEED_VIDEO;
+	imgsensor.pclk = imgsensor_info.hs_video.pclk;
+	//imgsensor.video_mode = KAL_TRUE;
+	imgsensor.line_length = imgsensor_info.hs_video.linelength;
+	imgsensor.frame_length = imgsensor_info.hs_video.framelength; 
+	imgsensor.min_frame_length = imgsensor_info.hs_video.framelength;
+	imgsensor.dummy_line = 0;
+	imgsensor.dummy_pixel = 0;
+	imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	hs_video_setting();
+	
+	return ERROR_NONE;
+}	/*	hs_video   */
+
+static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("E\n");
+	
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.sensor_mode = IMGSENSOR_MODE_SLIM_VIDEO;
+	imgsensor.pclk = imgsensor_info.slim_video.pclk;
+	imgsensor.line_length = imgsensor_info.slim_video.linelength;
+	imgsensor.frame_length = imgsensor_info.slim_video.framelength; 
+	imgsensor.min_frame_length = imgsensor_info.slim_video.framelength;
+	imgsensor.dummy_line = 0;
+	imgsensor.dummy_pixel = 0;
+	imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	slim_video_setting();
+	
+	return ERROR_NONE;
+}	/*	slim_video	 */
+
+
+
+static kal_uint32 get_resolution(MSDK_SENSOR_RESOLUTION_INFO_STRUCT *sensor_resolution)
+{
+	LOG_INF("E\n");
+	sensor_resolution->SensorFullWidth = imgsensor_info.cap.grabwindow_width;
+	sensor_resolution->SensorFullHeight = imgsensor_info.cap.grabwindow_height;
+	
+	sensor_resolution->SensorPreviewWidth = imgsensor_info.pre.grabwindow_width;
+	sensor_resolution->SensorPreviewHeight = imgsensor_info.pre.grabwindow_height;
+
+	sensor_resolution->SensorVideoWidth = imgsensor_info.normal_video.grabwindow_width;
+	sensor_resolution->SensorVideoHeight = imgsensor_info.normal_video.grabwindow_height;		
+
+	
+	sensor_resolution->SensorHighSpeedVideoWidth	 = imgsensor_info.hs_video.grabwindow_width;
+	sensor_resolution->SensorHighSpeedVideoHeight	 = imgsensor_info.hs_video.grabwindow_height;
+	
+	sensor_resolution->SensorSlimVideoWidth	 = imgsensor_info.slim_video.grabwindow_width;
+	sensor_resolution->SensorSlimVideoHeight	 = imgsensor_info.slim_video.grabwindow_height;
+	return ERROR_NONE;
+}	/*	get_resolution	*/
+
+static kal_uint32 get_info(MSDK_SCENARIO_ID_ENUM scenario_id,
+					  MSDK_SENSOR_INFO_STRUCT *sensor_info,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("scenario_id = %d\n", scenario_id);
+
+	
+	//sensor_info->SensorVideoFrameRate = imgsensor_info.normal_video.max_framerate/10; /* not use */
+	//sensor_info->SensorStillCaptureFrameRate= imgsensor_info.cap.max_framerate/10; /* not use */
+	//imgsensor_info->SensorWebCamCaptureFrameRate= imgsensor_info.v.max_framerate; /* not use */
+
+	sensor_info->SensorClockPolarity = SENSOR_CLOCK_POLARITY_LOW;
+	sensor_info->SensorClockFallingPolarity = SENSOR_CLOCK_POLARITY_LOW; /* not use */
+	sensor_info->SensorHsyncPolarity = SENSOR_CLOCK_POLARITY_LOW; // inverse with datasheet
+	sensor_info->SensorVsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
+	sensor_info->SensorInterruptDelayLines = 4; /* not use */
+	sensor_info->SensorResetActiveHigh = FALSE; /* not use */
+	sensor_info->SensorResetDelayCount = 5; /* not use */
+
+	sensor_info->SensroInterfaceType = imgsensor_info.sensor_interface_type;
+	sensor_info->MIPIsensorType = imgsensor_info.mipi_sensor_type;
+	sensor_info->SettleDelayMode = imgsensor_info.mipi_settle_delay_mode;
+	sensor_info->SensorOutputDataFormat = imgsensor_info.sensor_output_dataformat;
+
+	sensor_info->CaptureDelayFrame = imgsensor_info.cap_delay_frame; 
+	sensor_info->PreviewDelayFrame = imgsensor_info.pre_delay_frame; 
+	sensor_info->VideoDelayFrame = imgsensor_info.video_delay_frame;
+	sensor_info->HighSpeedVideoDelayFrame = imgsensor_info.hs_video_delay_frame;
+	sensor_info->SlimVideoDelayFrame = imgsensor_info.slim_video_delay_frame;
+
+	sensor_info->SensorMasterClockSwitch = 0; /* not use */
+	sensor_info->SensorDrivingCurrent = imgsensor_info.isp_driving_current;
+	
+	sensor_info->AEShutDelayFrame = imgsensor_info.ae_shut_delay_frame; 		 /* The frame of setting shutter default 0 for TG int */
+	sensor_info->AESensorGainDelayFrame = imgsensor_info.ae_sensor_gain_delay_frame;	/* The frame of setting sensor gain */
+	sensor_info->AEISPGainDelayFrame = imgsensor_info.ae_ispGain_delay_frame;	
+	sensor_info->IHDR_Support = imgsensor_info.ihdr_support;
+	sensor_info->IHDR_LE_FirstLine = imgsensor_info.ihdr_le_firstline;
+	sensor_info->SensorModeNum = imgsensor_info.sensor_mode_num;
+	
+	sensor_info->SensorMIPILaneNumber = imgsensor_info.mipi_lane_num; 
+	sensor_info->SensorClockFreq = imgsensor_info.mclk;
+	sensor_info->SensorClockDividCount = 3; /* not use */
+	sensor_info->SensorClockRisingCount = 0;
+	sensor_info->SensorClockFallingCount = 2; /* not use */
+	sensor_info->SensorPixelClockCount = 3; /* not use */
+	sensor_info->SensorDataLatchCount = 2; /* not use */
+	
+	sensor_info->MIPIDataLowPwr2HighSpeedTermDelayCount = 0; 
+	sensor_info->MIPICLKLowPwr2HighSpeedTermDelayCount = 0;
+	sensor_info->SensorWidthSampling = 0;  // 0 is default 1x
+	sensor_info->SensorHightSampling = 0;	// 0 is default 1x 
+	sensor_info->SensorPacketECCOrder = 1;
+
+	switch (scenario_id) {
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+			sensor_info->SensorGrabStartX = imgsensor_info.pre.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;		
+			
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
+			
+			break;
+		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+			sensor_info->SensorGrabStartX = imgsensor_info.cap.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.cap.starty;
+				  
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.cap.mipi_data_lp2hs_settle_dc; 
+
+			break;	 
+		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+			
+			sensor_info->SensorGrabStartX = imgsensor_info.normal_video.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.normal_video.starty;
+	   
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.normal_video.mipi_data_lp2hs_settle_dc; 
+
+			break;	  
+		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:			
+			sensor_info->SensorGrabStartX = imgsensor_info.hs_video.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.hs_video.starty;
+				  
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.hs_video.mipi_data_lp2hs_settle_dc; 
+
+			break;
+		case MSDK_SCENARIO_ID_SLIM_VIDEO:
+			sensor_info->SensorGrabStartX = imgsensor_info.slim_video.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.slim_video.starty;
+				  
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.slim_video.mipi_data_lp2hs_settle_dc; 
+
+			break;
+		default:			
+			sensor_info->SensorGrabStartX = imgsensor_info.pre.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;		
+			
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
+			break;
+	}
+	
+	return ERROR_NONE;
+}	/*	get_info  */
+
+
+static kal_uint32 control(MSDK_SCENARIO_ID_ENUM scenario_id, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("scenario_id = %d\n", scenario_id);
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.current_scenario_id = scenario_id;
+	spin_unlock(&imgsensor_drv_lock);
+	switch (scenario_id) {
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+			preview(image_window, sensor_config_data);
+			break;
+		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+			capture(image_window, sensor_config_data);
+			break;	
+		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+			normal_video(image_window, sensor_config_data);
+			break;	  
+		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+			hs_video(image_window, sensor_config_data);
+			break;
+		case MSDK_SCENARIO_ID_SLIM_VIDEO:
+			slim_video(image_window, sensor_config_data);
+			break;	  
+		default:
+			LOG_INF("Error ScenarioId setting");
+			preview(image_window, sensor_config_data);
+			return ERROR_INVALID_SCENARIO_ID;
+	}
+	return ERROR_NONE;
+}	/* control() */
+
+
+
+static kal_uint32 set_video_mode(UINT16 framerate)
+{
+	LOG_INF("framerate = %d\n ", framerate);
+	// SetVideoMode Function should fix framerate
+	if (framerate == 0)
+		// Dynamic frame rate
+		return ERROR_NONE;
+	spin_lock(&imgsensor_drv_lock);
+	if ((framerate == 300) && (imgsensor.autoflicker_en == KAL_TRUE))
+		imgsensor.current_fps = 296;
+	else if ((framerate == 150) && (imgsensor.autoflicker_en == KAL_TRUE))
+		imgsensor.current_fps = 146;
+	else
+		imgsensor.current_fps = framerate;
+	spin_unlock(&imgsensor_drv_lock);
+	set_max_framerate(imgsensor.current_fps,1);
+
+	return ERROR_NONE;
+}
+
+static kal_uint32 set_auto_flicker_mode(kal_bool enable, UINT16 framerate)
+{
+	LOG_INF("enable = %d, framerate = %d \n", enable, framerate);
+	spin_lock(&imgsensor_drv_lock);
+	if (enable) //enable auto flicker	  
+		imgsensor.autoflicker_en = KAL_TRUE;
+	else //Cancel Auto flick
+		imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	return ERROR_NONE;
+}
+
+
+static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 framerate) 
+{
+	kal_uint32 frame_length;
+  
+	LOG_INF("scenario_id = %d, framerate = %d\n", scenario_id, framerate);
+
+	switch (scenario_id) {
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+			frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
+			imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			set_dummy();			
+			break;			
+		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+			if(framerate == 0)
+				return ERROR_NONE;
+			frame_length = imgsensor_info.normal_video.pclk / framerate * 10 / imgsensor_info.normal_video.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = (frame_length > imgsensor_info.normal_video.framelength) ? (frame_length - imgsensor_info.normal_video.framelength) : 0;			
+			imgsensor.frame_length = imgsensor_info.normal_video.framelength + imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			set_dummy();			
+			break;
+		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:		
+			frame_length = imgsensor_info.cap.pclk / framerate * 10 / imgsensor_info.cap.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = (frame_length > imgsensor_info.cap.framelength) ? (frame_length - imgsensor_info.cap.framelength) : 0;
+			imgsensor.frame_length = imgsensor_info.cap.framelength + imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			set_dummy();			
+			break;	
+		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+			frame_length = imgsensor_info.hs_video.pclk / framerate * 10 / imgsensor_info.hs_video.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = (frame_length > imgsensor_info.hs_video.framelength) ? (frame_length - imgsensor_info.hs_video.framelength) : 0;
+			imgsensor.frame_length = imgsensor_info.hs_video.framelength + imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			set_dummy();			
+			break;
+		case MSDK_SCENARIO_ID_SLIM_VIDEO:
+			frame_length = imgsensor_info.slim_video.pclk / framerate * 10 / imgsensor_info.slim_video.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = (frame_length > imgsensor_info.slim_video.framelength) ? (frame_length - imgsensor_info.slim_video.framelength): 0;	
+			imgsensor.frame_length = imgsensor_info.slim_video.framelength + imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			set_dummy();	
+			break;		
+		default:  //coding with  preview scenario by default
+			frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
+			imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			set_dummy();	
+			LOG_INF("error scenario_id = %d, we use preview scenario \n", scenario_id);
+			break;
+	}	
+	return ERROR_NONE;
+}
+
+
+static kal_uint32 get_default_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 *framerate) 
+{
+	LOG_INF("scenario_id = %d\n", scenario_id);
+
+	switch (scenario_id) {
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+			*framerate = imgsensor_info.pre.max_framerate;
+			break;
+		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+			*framerate = imgsensor_info.normal_video.max_framerate;
+			break;
+		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+			*framerate = imgsensor_info.cap.max_framerate;
+			break;		
+		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+			*framerate = imgsensor_info.hs_video.max_framerate;
+			break;
+		case MSDK_SCENARIO_ID_SLIM_VIDEO: 
+			*framerate = imgsensor_info.slim_video.max_framerate;
+			break;
+		default:
+			break;
+	}
+
+	return ERROR_NONE;
+}
+
+
+
+static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
+							 UINT8 *feature_para,UINT32 *feature_para_len)
+{
+	UINT16 *feature_return_para_16=(UINT16 *) feature_para;
+	UINT16 *feature_data_16=(UINT16 *) feature_para;
+	UINT32 *feature_return_para_32=(UINT32 *) feature_para;
+	UINT32 *feature_data_32=(UINT32 *) feature_para;
+    unsigned long long *feature_data=(unsigned long long *) feature_para;
+
+	SENSOR_WINSIZE_INFO_STRUCT *wininfo;
+	MSDK_SENSOR_REG_INFO_STRUCT *sensor_reg_data=(MSDK_SENSOR_REG_INFO_STRUCT *) feature_para;
+ 
+	LOG_INF("feature_id = %d\n", feature_id);
+	switch (feature_id) {
+		case SENSOR_FEATURE_GET_PERIOD:
+			*feature_return_para_16++ = imgsensor.line_length;
+			*feature_return_para_16 = imgsensor.frame_length;
+			*feature_para_len=4;
+			break;
+		case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:
+			*feature_return_para_32 = imgsensor.pclk;
+			*feature_para_len=4;
+			break;		   
+		case SENSOR_FEATURE_SET_ESHUTTER:
+            set_shutter(*feature_data);
+			break;
+		case SENSOR_FEATURE_SET_NIGHTMODE:
+            night_mode((BOOL) *feature_data);
+			break;
+		case SENSOR_FEATURE_SET_GAIN:
+            set_gain((UINT16) *feature_data);
+			break;
+		case SENSOR_FEATURE_SET_FLASHLIGHT:
+			break;
+		case SENSOR_FEATURE_SET_ISP_MASTER_CLOCK_FREQ:
+			break;
+		case SENSOR_FEATURE_SET_REGISTER:
+			write_cmos_sensor(sensor_reg_data->RegAddr, sensor_reg_data->RegData);
+			break;
+		case SENSOR_FEATURE_GET_REGISTER:
+			sensor_reg_data->RegData = read_cmos_sensor(sensor_reg_data->RegAddr);
+			break;
+		case SENSOR_FEATURE_GET_LENS_DRIVER_ID:
+			// get the lens driver ID from EEPROM or just return LENS_DRIVER_ID_DO_NOT_CARE
+			// if EEPROM does not exist in camera module.
+			*feature_return_para_32=LENS_DRIVER_ID_DO_NOT_CARE;
+			*feature_para_len=4;
+			break;
+		case SENSOR_FEATURE_SET_VIDEO_MODE:
+            set_video_mode(*feature_data);
+			break;
+		case SENSOR_FEATURE_CHECK_SENSOR_ID:
+			get_imgsensor_id(feature_return_para_32);
+			break;
+		case SENSOR_FEATURE_SET_AUTO_FLICKER_MODE:
+			set_auto_flicker_mode((BOOL)*feature_data_16,*(feature_data_16+1));
+			break;
+		case SENSOR_FEATURE_SET_MAX_FRAME_RATE_BY_SCENARIO:
+            set_max_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data, *(feature_data+1));
+			break;
+		case SENSOR_FEATURE_GET_DEFAULT_FRAME_RATE_BY_SCENARIO:
+            get_default_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*(feature_data), (MUINT32 *)(uintptr_t)(*(feature_data+1)));
+			break;
+		case SENSOR_FEATURE_SET_TEST_PATTERN:
+            set_test_pattern_mode((BOOL)*feature_data);
+			break;
+		case SENSOR_FEATURE_GET_TEST_PATTERN_CHECKSUM_VALUE: //for factory mode auto testing			 
+			*feature_return_para_32 = imgsensor_info.checksum_value;
+			*feature_para_len=4;							 
+			break;				
+		case SENSOR_FEATURE_SET_FRAMERATE:
+            LOG_INF("current fps :%d\n", (UINT32)*feature_data);
+			spin_lock(&imgsensor_drv_lock);
+            imgsensor.current_fps = *feature_data;
+			spin_unlock(&imgsensor_drv_lock);
+			break;
+		case SENSOR_FEATURE_SET_HDR:
+            LOG_INF("ihdr enable :%d\n", (BOOL)*feature_data);
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.ihdr_en = *feature_data;
+			spin_unlock(&imgsensor_drv_lock);
+			break;
+		case SENSOR_FEATURE_GET_CROP_INFO:
+            LOG_INF("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n", (UINT32)*feature_data);
+            wininfo = (SENSOR_WINSIZE_INFO_STRUCT *)(uintptr_t)(*(feature_data+1));
+
+			switch (*feature_data_32) {
+				case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[1],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+					break;	  
+				case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[2],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+					break;
+				case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[3],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+					break;
+				case MSDK_SCENARIO_ID_SLIM_VIDEO:
+					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[4],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+					break;
+				case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+				default:
+					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[0],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+					break;
+			}
+		case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
+            LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",(UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
+            ihdr_write_shutter_gain((UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
+			break;
+		default:
+			break;
+	}
+  
+	return ERROR_NONE;
+}	/*	feature_control()  */
+
+static SENSOR_FUNCTION_STRUCT sensor_func = {
+	open,
+	get_info,
+	get_resolution,
+	feature_control,
+	control,
+	close
+};
+
+UINT32 IMX166_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
+{
+	/* To Do : Check Sensor status here */
+	if (pfFunc!=NULL)
+		*pfFunc=&sensor_func;
+	return ERROR_NONE;
+}	/*	OV5693_MIPI_RAW_SensorInit	*/
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/imx166_mipi_raw/imx166mipiraw_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx166_mipi_raw/imx166mipiraw_Sensor.h
new file mode 100755
index 0000000..b6738a6
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx166_mipi_raw/imx166mipiraw_Sensor.h
@@ -0,0 +1,123 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *	 OV5693mipi_Sensor.h
+ *
+ * Project:
+ * --------
+ *	 ALPS
+ *
+ * Description:
+ * ------------
+ *	 CMOS sensor header file
+ *
+ ****************************************************************************/
+#ifndef _IMX166MIPI_SENSOR_H
+#define _IMX166MIPI_SENSOR_H
+
+
+typedef enum{
+	IMGSENSOR_MODE_INIT,
+	IMGSENSOR_MODE_PREVIEW,
+	IMGSENSOR_MODE_CAPTURE,
+	IMGSENSOR_MODE_VIDEO,
+	IMGSENSOR_MODE_HIGH_SPEED_VIDEO,
+	IMGSENSOR_MODE_SLIM_VIDEO,
+} IMGSENSOR_MODE;
+
+typedef struct imgsensor_mode_struct {
+	kal_uint32 pclk;				//record different mode's pclk
+	kal_uint32 linelength;			//record different mode's linelength
+	kal_uint32 framelength;			//record different mode's framelength
+
+	kal_uint8 startx;				//record different mode's startx of grabwindow
+	kal_uint8 starty;				//record different mode's startx of grabwindow
+
+	kal_uint16 grabwindow_width;	//record different mode's width of grabwindow
+	kal_uint16 grabwindow_height;	//record different mode's height of grabwindow
+
+	/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
+	kal_uint8 mipi_data_lp2hs_settle_dc;
+
+	/*	 following for GetDefaultFramerateByScenario()	*/
+	kal_uint16 max_framerate;
+	
+} imgsensor_mode_struct;
+
+/* SENSOR PRIVATE STRUCT FOR VARIABLES*/
+typedef struct imgsensor_struct {
+	kal_uint8 mirror;				//mirrorflip information
+
+	kal_uint8 sensor_mode;			//record IMGSENSOR_MODE enum value
+
+	kal_uint32 shutter;				//current shutter
+	kal_uint16 gain;				//current gain
+	
+	kal_uint32 pclk;				//current pclk
+
+	kal_uint32 frame_length;		//current framelength
+	kal_uint32 line_length;			//current linelength
+
+	kal_uint32 min_frame_length;	//current min  framelength to max framerate
+	kal_uint16 dummy_pixel;			//current dummypixel
+	kal_uint16 dummy_line;			//current dummline
+	
+	kal_uint16 current_fps;			//current max fps
+	kal_bool   autoflicker_en;		//record autoflicker enable or disable
+	kal_bool test_pattern;			//record test pattern mode or not
+	MSDK_SCENARIO_ID_ENUM current_scenario_id;//current scenario id
+	kal_uint8  ihdr_en;				//ihdr enable or disable
+	
+	kal_uint8 i2c_write_id;			//record current sensor's i2c write id
+} imgsensor_struct;
+
+/* SENSOR PRIVATE STRUCT FOR CONSTANT*/
+typedef struct imgsensor_info_struct { 
+	kal_uint32 sensor_id;			//record sensor id defined in Kd_imgsensor.h
+	kal_uint32 checksum_value;		//checksum value for Camera Auto Test
+	imgsensor_mode_struct pre;		//preview scenario relative information
+	imgsensor_mode_struct cap;		//capture scenario relative information
+	imgsensor_mode_struct cap1;		//capture for PIP 24fps relative information, capture1 mode must use same framelength, linelength with Capture mode for shutter calculate
+	imgsensor_mode_struct normal_video;//normal video  scenario relative information
+	imgsensor_mode_struct hs_video;	//high speed video scenario relative information
+	imgsensor_mode_struct slim_video;	//slim video for VT scenario relative information
+	
+	kal_uint8  ae_shut_delay_frame;	//shutter delay frame for AE cycle
+	kal_uint8  ae_sensor_gain_delay_frame;	//sensor gain delay frame for AE cycle
+	kal_uint8  ae_ispGain_delay_frame;	//isp gain delay frame for AE cycle
+	kal_uint8  ihdr_support;		//1, support; 0,not support
+	kal_uint8  ihdr_le_firstline;	//1,le first ; 0, se first
+	kal_uint8  sensor_mode_num;		//support sensor mode num
+	
+	kal_uint8  cap_delay_frame;		//enter capture delay frame num
+	kal_uint8  pre_delay_frame;		//enter preview delay frame num
+	kal_uint8  video_delay_frame;	//enter video delay frame num
+	kal_uint8  hs_video_delay_frame;	//enter high speed video  delay frame num
+	kal_uint8  slim_video_delay_frame;	//enter slim video delay frame num
+  
+	kal_uint8  margin;				//sensor framelength & shutter margin 
+	kal_uint32 min_shutter;			//min shutter
+	kal_uint32 max_frame_length;	//max framelength by sensor register's limitation
+
+	kal_uint8  isp_driving_current;	//mclk driving current
+	kal_uint8  sensor_interface_type;//sensor_interface_type
+	kal_uint8  mipi_sensor_type; //0,MIPI_OPHY_NCSI2; 1,MIPI_OPHY_CSI2, default is NCSI2, don't modify this para
+	kal_uint8  mipi_settle_delay_mode; //0, high speed signal auto detect; 1, use settle delay,unit is ns, default is auto detect, don't modify this para
+	kal_uint8  sensor_output_dataformat;//sensor output first pixel color
+	kal_uint8  mclk;				//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
+	
+	kal_uint8  mipi_lane_num;		//mipi lane num
+	kal_uint8  i2c_addr_table[5];	//record sensor support all write id addr, only supprt 4must end with 0xff
+} imgsensor_info_struct;
+
+/* SENSOR READ/WRITE ID */
+//#define IMGSENSOR_WRITE_ID_1 (0x6c)
+//#define IMGSENSOR_READ_ID_1  (0x6d)
+//#define IMGSENSOR_WRITE_ID_2 (0x20)
+//#define IMGSENSOR_READ_ID_2  (0x21)
+
+extern int iReadRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u8 * a_pRecvData, u16 a_sizeRecvData, u16 i2cId);
+extern int iWriteRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u16 i2cId);
+
+#endif 
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/imx175_mipi_raw/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx175_mipi_raw/Makefile
index 3022fd7..1866714 100644
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/imx175_mipi_raw/Makefile
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx175_mipi_raw/Makefile
@@ -1,4 +1,4 @@
 include $(srctree)/drivers/misc/mediatek/Makefile.custom
-obj-y += imx175mipiraw_Sensor.o
 
+obj-y += imx175mipiraw_Sensor.o
 
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/imx175_mipi_raw/imx175mipiraw_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx175_mipi_raw/imx175mipiraw_Sensor.c
index ebda2f1..e3c39c4 100644
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/imx175_mipi_raw/imx175mipiraw_Sensor.c
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx175_mipi_raw/imx175mipiraw_Sensor.c
@@ -2,15 +2,15 @@
  *
  * Filename:
  * ---------
- *	 imx175mipi_Sensor.c
+ *     OV5693mipi_Sensor.c
  *
  * Project:
  * --------
- *	 ALPS
+ *     ALPS
  *
  * Description:
  * ------------
- *	 Source code of Sensor driver
+ *     Source code of Sensor driver
  *
  *
  *------------------------------------------------------------------------------
@@ -38,121 +38,134 @@
 
 /****************************Modify following Strings for debug****************************/
 #define PFX "imx175_camera_sensor"
-#define LOG_1 LOG_INF("imx175,MIPI 2LANE\n")
-#define LOG_2 LOG_INF("preview 1280*960@30fps,864Mbps/lane; video 1280*960@30fps,864Mbps/lane; capture 5M@30fps,864Mbps/lane\n")
-/****************************   Modify end    *******************************************/
 
+#define LOG_1 LOG_INF("IMX175,MIPI 4LANE\n")
+#define LOG_2 LOG_INF("preview 1640*1232@30fps,176.8Mbps/lane; video 3280*2464@30fps,176.8Mbps/lane; capture 8M@30fps,176.8MbpsMbps/lane\n")
+/****************************   Modify end    *******************************************/
 #define LOG_INF(format, args...)	xlog_printk(ANDROID_LOG_INFO   , PFX, "[%s] " format, __FUNCTION__, ##args)
 
 static DEFINE_SPINLOCK(imgsensor_drv_lock);
+static kal_uint8  test_pattern_flag=0;
 
+#define MIPI_SETTLEDELAY_AUTO     0
+#define MIPI_SETTLEDELAY_MANNUAL  1
+
+#define BIRD_IMX175_HV_MIRROR
 
 static imgsensor_info_struct imgsensor_info = { 
-	.sensor_id = IMX175_SENSOR_ID,		//record sensor id defined in Kd_imgsensor.h
+	.sensor_id = IMX175_SENSOR_ID,
 	
-	.checksum_value = 0x9e08861c,		//checksum value for Camera Auto Test
+	.checksum_value = 0x1ec5153d,
 	
 	.pre = {
-		.pclk = 259200000,				//record different mode's pclk
-		.linelength = 0xf54,				//record different mode's linelength
-		.framelength = 0xc44,			//record different mode's framelength
-		.startx = 8,					//record different mode's startx of grabwindow
-		.starty = 8,					//record different mode's starty of grabwindow
-		.grabwindow_width = 1600,		//record different mode's width of grabwindow
-		.grabwindow_height = 1200,		//record different mode's height of grabwindow
+		.pclk = 176800000,				//record different mode's pclk
+		.linelength = 3440,				//record different mode's linelength
+		.framelength = 1713,			//record different mode's framelength
+		.startx = 0,					//record different mode's startx of grabwindow
+		.starty = 0,					//record different mode's starty of grabwindow
+		.grabwindow_width = 1640,		//record different mode's width of grabwindow
+		.grabwindow_height = 1232,		//record different mode's height of grabwindow
 		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
-		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
+		.mipi_data_lp2hs_settle_dc = 85,
 		/*	 following for GetDefaultFramerateByScenario()	*/
 		.max_framerate = 300,	
 	},
 	.cap = {
-		.pclk = 259200000,
-		.linelength = 0x1b70,
-		.framelength = 0xc44,
-		.startx = 16,
-		.starty = 16,
-		.grabwindow_width = 3200,
-		.grabwindow_height = 2400,
-		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
+		.pclk = 176800000,
+		.linelength = 3440,
+		.framelength = 2478,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 3280,
+		.grabwindow_height = 2464,
+		.mipi_data_lp2hs_settle_dc = 85,
 		.max_framerate = 300,
 	},
-	.cap1 = {							//capture for PIP 24fps relative information, capture1 mode must use same framelength, linelength with Capture mode for shutter calculate
-		.pclk = 259200000,
-		.linelength = 0x1b70,
-		.framelength = 0xc44,
-		.startx = 16,
-		.starty = 16,
-		.grabwindow_width = 3200,
-		.grabwindow_height = 2400,
-		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
-		.max_framerate = 240,	//less than 13M(include 13M),cap1 max framerate is 24fps,16M max framerate is 20fps, 20M max framerate is 15fps  
+	.cap1 = {
+		.pclk = 176800000,
+		.linelength = 3440,
+		.framelength = 3098,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 3280,
+		.grabwindow_height = 2464,
+		.mipi_data_lp2hs_settle_dc = 85,
+		.max_framerate = 240,	
 	},
 	.normal_video = {
-		.pclk = 259200000,
-		.linelength = 0x1b70,
-		.framelength = 0xc44,
-		.startx = 16,
-		.starty = 16,
-		.grabwindow_width = 3200,
-		.grabwindow_height = 2400,
-		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
+		.pclk = 176800000,
+		.linelength = 3440,
+		.framelength = 2478,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 3280,
+		.grabwindow_height = 2464,
+		.mipi_data_lp2hs_settle_dc = 85,
 		.max_framerate = 300,
 	},
 	.hs_video = {
-		.pclk = 259200000,
-		.linelength = 0xf54,
-		.framelength = 0x48e,
-		.startx = 8,
-		.starty = 8,
-		.grabwindow_width = 1920,
-		.grabwindow_height = 1080,
-		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
-		.max_framerate = 600,
+        .pclk = 176800000,				//record different mode's pclk
+		.linelength = 3440,				//record different mode's linelength
+		.framelength = 1713,			//record different mode's framelength
+		.startx = 0,					//record different mode's startx of grabwindow
+		.starty = 0,					//record different mode's starty of grabwindow
+		.grabwindow_width = 1640,		//record different mode's width of grabwindow
+		.grabwindow_height = 1232,		//record different mode's height of grabwindow
+		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
+		.mipi_data_lp2hs_settle_dc = 85,
+		/*	 following for GetDefaultFramerateByScenario()	*/
+		.max_framerate = 300,	
 	},
 	.slim_video = {
-		.pclk = 265600000,
-		.linelength = 0xf54,
-		.framelength = 0x85c,
-		.startx = 8,
-		.starty = 8,
-		.grabwindow_width = 1280,
-		.grabwindow_height = 720,
-		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
-		.max_framerate = 300,
-
+        .pclk = 176800000,				//record different mode's pclk
+		.linelength = 3440,				//record different mode's linelength
+		.framelength = 1678,			//record different mode's framelength
+		.startx = 0,					//record different mode's startx of grabwindow
+		.starty = 0,					//record different mode's starty of grabwindow
+		.grabwindow_width = 3280,		//record different mode's width of grabwindow
+		.grabwindow_height = 1664,		//record different mode's height of grabwindow
+		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
+		.mipi_data_lp2hs_settle_dc = 85,
+		/*	 following for GetDefaultFramerateByScenario()	*/
+		.max_framerate = 300,	
 	},
-	.margin = 5,			//sensor framelength & shutter margin
-	.min_shutter = 2,		//min shutter
-	.max_frame_length = 0xffff,//max framelength by sensor register's limitation
-	.ae_shut_delay_frame = 0,	//shutter delay frame for AE cycle, 2 frame with ispGain_delay-shut_delay=2-0=2
-	.ae_sensor_gain_delay_frame = 1,//sensor gain delay frame for AE cycle,2 frame with ispGain_delay-sensor_gain_delay=2-0=2
-	.ae_ispGain_delay_frame = 2,//isp gain delay frame for AE cycle
+	.margin = 4,
+	.min_shutter = 1,
+	.max_frame_length = 0x7fff,
+	.ae_shut_delay_frame = 0,
+	.ae_sensor_gain_delay_frame = 0,
+	.ae_ispGain_delay_frame = 2,
 	.ihdr_support = 0,	  //1, support; 0,not support
 	.ihdr_le_firstline = 0,  //1,le first ; 0, se first
-	.sensor_mode_num = 5,	  //support sensor mode num
+	.sensor_mode_num = 3,	  //support sensor mode num
 	
-	.cap_delay_frame = 2,		//enter capture delay frame num
-	.pre_delay_frame = 2, 		//enter preview delay frame num
-	.video_delay_frame = 2,		//enter video delay frame num
-	.hs_video_delay_frame = 2,	//enter high speed video  delay frame num
-	.slim_video_delay_frame = 2,//enter slim video delay frame num
+	.cap_delay_frame = 3, 
+	.pre_delay_frame = 3, 
+	.video_delay_frame = 3,
+	.hs_video_delay_frame = 3,
+	.slim_video_delay_frame = 3,
 	
-	.isp_driving_current = ISP_DRIVING_8MA, //mclk driving current
-	.sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,//sensor_interface_type
-	.mipi_sensor_type = MIPI_OPHY_NCSI2, //0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2
-	.mipi_settle_delay_mode = 1,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
-	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_R,//sensor output first pixel color
-	.mclk = 24,//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
-	.mipi_lane_num = SENSOR_MIPI_4_LANE,//mipi lane num
-	.i2c_addr_table = {0x21, 0x20, 0xff},//record sensor support all write id addr, only supprt 4must end with 0xff
+	.isp_driving_current = ISP_DRIVING_6MA,
+	.sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,
+	.mipi_sensor_type = MIPI_OPHY_NCSI2, //0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2 
+    .mipi_settle_delay_mode = MIPI_SETTLEDELAY_AUTO,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
+#if defined(BIRD_IMX175_HV_MIRROR)   
+	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_B,    
+#else	
+	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_R,
+#endif	
+	.mclk = 24,
+	.mipi_lane_num = SENSOR_MIPI_2_LANE,
+	.i2c_addr_table = {0x20, 0xff},
+    .i2c_speed = 300, // i2c read/write speed
 };
 
 
 static imgsensor_struct imgsensor = {
 	.mirror = IMAGE_NORMAL,				//mirrorflip information
 	.sensor_mode = IMGSENSOR_MODE_INIT, //IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
-	.shutter = 0x3D0,					//current shutter
-	.gain = 0x100,						//current gain
+	.shutter = 0x09AD,					//current shutter
+	.gain = 222,						//current gain
 	.dummy_pixel = 0,					//current dummypixel
 	.dummy_line = 0,					//current dummyline
 	.current_fps = 300,  //full size current fps : 24fps for PIP, 30fps for Normal or ZSD
@@ -160,21 +173,22 @@ static imgsensor_struct imgsensor = {
 	.test_pattern = KAL_FALSE,		//test pattern mode or not. KAL_FALSE for in test pattern mode, KAL_TRUE for normal output
 	.current_scenario_id = MSDK_SCENARIO_ID_CAMERA_PREVIEW,//current scenario id
 	.ihdr_en = 0, //sensor need support LE, SE with HDR feature
-	.i2c_write_id = 0x20,//record current sensor's i2c write id
+	.i2c_write_id = 0x20,
 };
 
 
 /* Sensor output window information */
 static SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[5] =	 
-{{ 3280, 2464,	0, 	0, 3280, 2464, 1640, 1232, 0, 0, 1640, 1232,		8,	8, 1600,  1200}, // Preview 
- { 3280, 2464,	0,	0, 3280, 2464, 3280, 2464, 0, 0, 3280, 2464,	16,	16, 3200, 2400}, // capture 
- { 3280, 2464,	0,	0, 3280, 2464, 3280, 2464, 0, 0, 3280, 2464,	16,	16, 3200, 2400},  // video 
- { 3280, 2464,	0,  0, 3280, 2464, 1920, 1080, 0, 0, 1920, 1080,	8,	8, 1920, 1080}, //hight speed video 
- { 3280, 2464,	0,  0, 3280, 2464, 1640,  926, 0, 0, 1640,  926,	8,	8, 1280,  720}};// slim video 
-
-
-#define IMX175MIPI_MaxGainIndex (97)
-kal_uint16 IMX175MIPI_sensorGainMapping[IMX175MIPI_MaxGainIndex][2] ={
+{{ 3280, 2464,	 0,	0, 3280, 2464, 1640,  1232, 0000, 0000, 1640, 1232,	  0,	0, 1640,  1232}, // Preview 
+ { 3280, 2464,	 0,	0, 3280, 2464, 3280,  2464, 0000, 0000, 3280, 2464,	  0,	0, 3280,  2464}, // capture 
+ { 3280, 2464,	 0,	0, 3280, 2464, 3280,  2464, 0000, 0000, 3280, 2464,	  0,	0, 3280,  2464}, // video 
+ { 3280, 2464,	 0, 0, 3280, 2464, 1640,  1232, 0000, 0000, 1640, 1232,	  0,	0, 1640,  1232}, //hight speed video 
+ { 3280, 2464,	 0, 0, 3280, 2464, 3280,  1664, 0000, 0000, 3280, 1664,	  2,	2, 1080,  720},// slim video 
+ };// slim video  
+
+// Gain Index
+#define MaxGainIndex (97)
+static kal_uint16 sensorGainMapping[MaxGainIndex][2] ={
 { 64 ,0  },   
 { 68 ,12 },   
 { 71 ,23 },   
@@ -274,63 +288,70 @@ kal_uint16 IMX175MIPI_sensorGainMapping[IMX175MIPI_MaxGainIndex][2] ={
 { 683,232}
 };
 
-
 static kal_uint16 read_cmos_sensor(kal_uint32 addr)
 {
+    kdSetI2CSpeed(imgsensor_info.i2c_speed); // Add this func to set i2c speed by each sensor
 	kal_uint16 get_byte=0;
 
 	char pu_send_cmd[2] = {(char)(addr >> 8), (char)(addr & 0xFF) };
 	iReadRegI2C(pu_send_cmd, 2, (u8*)&get_byte, 1, imgsensor.i2c_write_id);
-
 	return get_byte;
 }
 
 static void write_cmos_sensor(kal_uint32 addr, kal_uint32 para)
 {
+    kdSetI2CSpeed(imgsensor_info.i2c_speed); // Add this func to set i2c speed by each sensor
 	char pu_send_cmd[3] = {(char)(addr >> 8), (char)(addr & 0xFF), (char)(para & 0xFF)};
 	iWriteRegI2C(pu_send_cmd, 3, imgsensor.i2c_write_id);
 }
 
+static kal_uint16 read_cmos_sensor_8(kal_uint16 addr)
+{
+    kdSetI2CSpeed(imgsensor_info.i2c_speed); // Add this func to set i2c speed by each sensor
+    kal_uint16 get_byte=0;
+    char pu_send_cmd[2] = {(char)(addr >> 8) , (char)(addr & 0xFF) };
+    iReadRegI2C(pu_send_cmd , 2, (u8*)&get_byte,1,imgsensor.i2c_write_id);
+    return get_byte;
+}
+
+
+static void write_cmos_sensor_8(kal_uint16 addr, kal_uint8 para)
+{
+    kdSetI2CSpeed(imgsensor_info.i2c_speed); // Add this func to set i2c speed by each sensor
+	char pu_send_cmd[4] = {(char)(addr >> 8), (char)(addr & 0xFF), (char)(para & 0xFF)};
+	iWriteRegI2C(pu_send_cmd, 3, imgsensor.i2c_write_id);
+}   
 static void set_dummy()
 {
 	LOG_INF("dummyline = %d, dummypixels = %d \n", imgsensor.dummy_line, imgsensor.dummy_pixel);
-	/* you can set dummy by imgsensor.dummy_line and imgsensor.dummy_pixel, or you can set dummy by imgsensor.frame_length and imgsensor.line_length */
-	write_cmos_sensor(0x0104, 1); 
-	write_cmos_sensor(0x0160, (imgsensor.frame_length >>8) & 0xFF);
-  write_cmos_sensor(0x0161, imgsensor.frame_length & 0xFF);	
-  write_cmos_sensor(0x0162, (imgsensor.line_length >>8) & 0xFF);
-  write_cmos_sensor(0x0163, imgsensor.line_length & 0xFF);
-  write_cmos_sensor(0x0104, 0);
-  
+    write_cmos_sensor_8(0x0104, 0x01); 
+    write_cmos_sensor(0x0340, (imgsensor.frame_length >>8) & 0xFF);
+    write_cmos_sensor(0x0341, imgsensor.frame_length & 0xFF);	
+    write_cmos_sensor(0x0342, (imgsensor.line_length >>8) & 0xFF);
+    write_cmos_sensor(0x0343, imgsensor.line_length & 0xFF);
+    write_cmos_sensor_8(0x0104, 0x00);  
 }	/*	set_dummy  */
 
+
 static kal_uint32 return_sensor_id()
 {
-	return ((read_cmos_sensor(0x0000) << 8) | read_cmos_sensor(0x0001));
-	/*
-	int sensorid;
-	sensorid =  ((read_cmos_sensor(0x0000) << 8) | read_cmos_sensor(0x0001));
-	printk("IMX175 read sensor id:0x%x", sensorid);
-	return sensorid;
-	*/
+    return (((read_cmos_sensor(0x0040)&&0x0f)<<8)  | (read_cmos_sensor(0x0041)) );;
 }
 static void set_max_framerate(UINT16 framerate,kal_bool min_framelength_en)
 {
 	kal_int16 dummy_line;
 	kal_uint32 frame_length = imgsensor.frame_length;
 	//unsigned long flags;
-
-	LOG_INF("framerate = %d, min framelength should enable? \n", framerate,min_framelength_en);
-   
+	LOG_INF("framerate = %d, min framelength should enable? \n", framerate,min_framelength_en);   
 	frame_length = imgsensor.pclk / framerate * 10 / imgsensor.line_length;
 	spin_lock(&imgsensor_drv_lock);
-	imgsensor.frame_length = (frame_length > imgsensor.min_frame_length) ? frame_length : imgsensor.min_frame_length; 
+	imgsensor.frame_length = (frame_length > imgsensor.min_frame_length)?frame_length:imgsensor.min_frame_length;
 	imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
 	//dummy_line = frame_length - imgsensor.min_frame_length;
 	//if (dummy_line < 0)
-		//imgsensor.dummy_line = 0;
+	//	imgsensor.dummy_line = 0;
 	//else
-		//imgsensor.dummy_line = dummy_line;
+	//	imgsensor.dummy_line = dummy_line;
 	//imgsensor.frame_length = frame_length + imgsensor.dummy_line;
 	if (imgsensor.frame_length > imgsensor_info.max_frame_length)
 	{
@@ -343,161 +364,101 @@ static void set_max_framerate(UINT16 framerate,kal_bool min_framelength_en)
 	set_dummy();
 }	/*	set_max_framerate  */
 
-
-static void write_shutter(kal_uint16 shutter)
-{
-	kal_uint16 realtime_fps = 0;
-	kal_uint32 frame_length = 0;
-	   
-	/* 0x3500, 0x3501, 0x3502 will increase VBLANK to get exposure larger than frame exposure */
-	/* AE doesn't update sensor gain at capture mode, thus extra exposure lines must be updated here. */
-	
-	// OV Recommend Solution
-	// if shutter bigger than frame_length, should extend frame length first
-	spin_lock(&imgsensor_drv_lock);
-	shutter = shutter * 14 / 10;
-	if (shutter > imgsensor.min_frame_length - imgsensor_info.margin)		
-		imgsensor.frame_length = shutter + imgsensor_info.margin;
-	else
-		imgsensor.frame_length = imgsensor.min_frame_length;
-	if (imgsensor.frame_length > imgsensor_info.max_frame_length)
-		imgsensor.frame_length = imgsensor_info.max_frame_length;
-	spin_unlock(&imgsensor_drv_lock);
-	shutter = (shutter < imgsensor_info.min_shutter) ? imgsensor_info.min_shutter : shutter;
-	shutter = (shutter > (imgsensor_info.max_frame_length - imgsensor_info.margin)) ? (imgsensor_info.max_frame_length - imgsensor_info.margin) : shutter;
-
-    // Framelength should be an even number
-    shutter = (shutter >> 1) << 1;
-    imgsensor.frame_length = (imgsensor.frame_length >> 1) << 1;
-	
-	if (imgsensor.autoflicker_en) { 
-		realtime_fps = imgsensor.pclk / imgsensor.line_length * 10 / imgsensor.frame_length;
-		if(realtime_fps >= 297 && realtime_fps <= 305)
-			set_max_framerate(296,0);
-		else if(realtime_fps >= 147 && realtime_fps <= 150)
-			set_max_framerate(146,0);	
-		else {
-		// Extend frame length
-		write_cmos_sensor(0x0160, imgsensor.frame_length >> 8);
-		write_cmos_sensor(0x0161, imgsensor.frame_length & 0xFF);
-		}
-	} else {
-		// Extend frame length
-		write_cmos_sensor(0x0160, imgsensor.frame_length >> 8);
-		write_cmos_sensor(0x0161, imgsensor.frame_length & 0xFF);
-	}
-
-	// Update Shutter
-	write_cmos_sensor(0x015a, (shutter >> 8) & 0xFF);
-	write_cmos_sensor(0x015b, (shutter ) & 0xFF);	  
-	LOG_INF("Exit! shutter =%d, framelength =%d\n", shutter,imgsensor.frame_length);
-
-	//LOG_INF("frame_length = %d ", frame_length);
-	
-}	/*	write_shutter  */
-
-
-
 /*************************************************************************
 * FUNCTION
-*	set_shutter
+*    set_shutter
 *
 * DESCRIPTION
-*	This function set e-shutter of sensor to change exposure time.
+*    This function set e-shutter of sensor to change exposure time.
 *
 * PARAMETERS
-*	iShutter : exposured lines
+*    iShutter : exposured lines
 *
 * RETURNS
-*	None
+*    None
 *
 * GLOBALS AFFECTED
 *
 *************************************************************************/
 static void set_shutter(kal_uint16 shutter)
 {
-	unsigned long flags;
-	kal_uint16 realtime_fps = 0;
-	kal_uint32 frame_length = 0;
-	spin_lock_irqsave(&imgsensor_drv_lock, flags);
-	shutter = shutter * 14 / 10;
-	imgsensor.shutter = shutter;
-	spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
-	
-	//write_shutter(shutter);
-	/* 0x3500, 0x3501, 0x3502 will increase VBLANK to get exposure larger than frame exposure */
-	/* AE doesn't update sensor gain at capture mode, thus extra exposure lines must be updated here. */
-	
-	// OV Recommend Solution
-	// if shutter bigger than frame_length, should extend frame length first
-	spin_lock(&imgsensor_drv_lock);
-	if (shutter > imgsensor.min_frame_length - imgsensor_info.margin)		
-		imgsensor.frame_length = shutter + imgsensor_info.margin;
-	else
-		imgsensor.frame_length = imgsensor.min_frame_length;
-	if (imgsensor.frame_length > imgsensor_info.max_frame_length)
-		imgsensor.frame_length = imgsensor_info.max_frame_length;
-	spin_unlock(&imgsensor_drv_lock);
-	shutter = (shutter < imgsensor_info.min_shutter) ? imgsensor_info.min_shutter : shutter;
-	shutter = (shutter > (imgsensor_info.max_frame_length - imgsensor_info.margin)) ? (imgsensor_info.max_frame_length - imgsensor_info.margin) : shutter;
-	
-	if (imgsensor.autoflicker_en) { 
-		realtime_fps = imgsensor.pclk / imgsensor.line_length * 10 / imgsensor.frame_length;
-		if(realtime_fps >= 297 && realtime_fps <= 305)
-			set_max_framerate(296,0);
-		else if(realtime_fps >= 147 && realtime_fps <= 150)
-			set_max_framerate(146,0);	
-		else {
-		// Extend frame length
-		write_cmos_sensor(0x0160, imgsensor.frame_length >> 8);
-		write_cmos_sensor(0x0161, imgsensor.frame_length & 0xFF);
-		}
-	} else {
-		// Extend frame length
-		write_cmos_sensor(0x0160, imgsensor.frame_length >> 8);
-		write_cmos_sensor(0x0161, imgsensor.frame_length & 0xFF);
-	}
-  
-	// Update Shutter
-	write_cmos_sensor(0x015a, (shutter >> 8) & 0xFF);
-	write_cmos_sensor(0x015b, (shutter ) & 0xFF);	 
-	LOG_INF("Exit! shutter =%d, framelength =%d\n", shutter,imgsensor.frame_length);
+    unsigned long flags;
+    kal_uint16 realtime_fps = 0;
+    kal_uint32 frame_length = 0;
+    spin_lock_irqsave(&imgsensor_drv_lock, flags);
+    imgsensor.shutter = shutter;
+    spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
+
+    //write_shutter(shutter);
+    /* 0x3500, 0x3501, 0x3502 will increase VBLANK to get exposure larger than frame exposure */
+    /* AE doesn't update sensor gain at capture mode, thus extra exposure lines must be updated here. */
+
+    // OV Recommend Solution
+    // if shutter bigger than frame_length, should extend frame length first
+    spin_lock(&imgsensor_drv_lock);
+    if (shutter > imgsensor.min_frame_length - imgsensor_info.margin)
+        imgsensor.frame_length = shutter + imgsensor_info.margin;
+    else
+        imgsensor.frame_length = imgsensor.min_frame_length;
+    if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+        imgsensor.frame_length = imgsensor_info.max_frame_length;
+    spin_unlock(&imgsensor_drv_lock);
+    shutter = (shutter < imgsensor_info.min_shutter) ? imgsensor_info.min_shutter : shutter;
+    shutter = (shutter > (imgsensor_info.max_frame_length - imgsensor_info.margin)) ? (imgsensor_info.max_frame_length - imgsensor_info.margin) : shutter;
+
+    if (imgsensor.autoflicker_en) {
+        realtime_fps = imgsensor.pclk / imgsensor.line_length * 10 / imgsensor.frame_length;
+        if(realtime_fps >= 297 && realtime_fps <= 305)
+            set_max_framerate(296,0);
+        else if(realtime_fps >= 147 && realtime_fps <= 150)
+            set_max_framerate(146,0);
+        else {
+        // Extend frame length
+		write_cmos_sensor_8(0x0104, 0x01); 
+		write_cmos_sensor(0x0340, (imgsensor.frame_length >> 8) & 0xFF);
+		write_cmos_sensor(0x0341, imgsensor.frame_length & 0xFF);
+		write_cmos_sensor_8(0x0104, 0x00); 
+
+        }
+    } else {
+        // Extend frame length
+		write_cmos_sensor_8(0x0104, 0x01); 
+		write_cmos_sensor(0x0340, (imgsensor.frame_length >> 8) & 0xFF);
+		write_cmos_sensor(0x0341, imgsensor.frame_length & 0xFF);
+		write_cmos_sensor_8(0x0104, 0x00); 
+
+    }
 
-}	/*	set_shutter */
+    // Update Shutter
+	write_cmos_sensor_8(0x0104, 0x01); 
+	write_cmos_sensor(0x0202, (shutter >> 8) & 0xFF);
+	write_cmos_sensor(0x0203, shutter  & 0xFF);	
+	write_cmos_sensor_8(0x0104, 0x00); 
+    LOG_INF("Exit! shutter =%d, framelength =%d\n", shutter,imgsensor.frame_length);
+
+}    /*    set_shutter */
 
 
 
 static kal_uint16 gain2reg(const kal_uint16 gain)
 {
-	/*
-			kal_uint32 temp_reg;
-		temp_reg = ((2*256*((kal_uint32)gain-64))/((kal_uint32)gain)+1)/2;
-
-		return (temp_reg&0xff) ; 
-	*/
-	kal_uint8 iI;
-    LOG_INF("[IMX175MIPI]enter IMX175MIPIGain2Reg function\n");
-    for (iI = 0; iI < (IMX175MIPI_MaxGainIndex-1); iI++) 
+    kal_uint8 iI;	    
+    for (iI = 0; iI < (sensorGainMapping-1); iI++) 
 	{
-
-        if(gain <IMX175MIPI_sensorGainMapping[iI][0])
+        if(gain <= sensorGainMapping[iI][0])
 		{    
             break;
         }
-		if(gain < IMX175MIPI_sensorGainMapping[iI][0])
-		{                
-			return IMX175MIPI_sensorGainMapping[iI][1];       
-		}
-			
-
     }
-    if(gain != IMX175MIPI_sensorGainMapping[iI][0])
+/*
+    if(gain != sensorGainMapping[iI][0])
     {
-         LOG_INF("Gain mapping don't correctly:%d %d \n", gain, IMX175MIPI_sensorGainMapping[iI][0]);
+         //LOG_INF("Gain mapping don't correctly:%d %d \n", gain, sensorGainMapping[iI][0]);		 
+		 return sensorGainMapping[iI][1];
     }
-	LOG_INF("exit IMX175MIPIGain2Reg function\n");
-    return IMX175MIPI_sensorGainMapping[iI-1][1];
-	//return NONE;
+    else return (kal_uint16)gain;
+*/
+	return sensorGainMapping[iI][1];
 
 }
 
@@ -517,96 +478,66 @@ static kal_uint16 gain2reg(const kal_uint16 gain)
 * GLOBALS AFFECTED
 *
 *************************************************************************/
-static UINT16 iPreGain = 0;
 static kal_uint16 set_gain(kal_uint16 gain)
 {
 	kal_uint16 reg_gain;
 
- 	if (iPreGain != gain)
+	/* 0x350A[0:1], 0x350B[0:7] AGC real gain */
+	/* [0:3] = N meams N /16 X	*/
+	/* [4:9] = M meams M X		 */
+	/* Total gain = M + N /16 X   */
+	if (gain < BASEGAIN || gain > 32 * BASEGAIN) 
 	{
-		reg_gain = gain2reg(gain);
-		spin_lock(&imgsensor_drv_lock);
-		imgsensor.gain = reg_gain; 
-		spin_unlock(&imgsensor_drv_lock);
-		if(reg_gain > 0xe0)
-    	reg_gain = 0xe0;
-		write_cmos_sensor(0x0157, (kal_uint8)reg_gain); 
-		LOG_INF("gain = %d , reg_gain = 0x%x\n ", gain, reg_gain);
- 	}
-	
+		LOG_INF("Error gain setting");
+		if (gain < BASEGAIN)
+			gain = BASEGAIN;
+		else if (gain > 32 * BASEGAIN)
+			gain = 32 * BASEGAIN;		 
+	}
+	reg_gain = gain2reg(gain);
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.gain = reg_gain; 
+	spin_unlock(&imgsensor_drv_lock);
+	LOG_INF("gain = %d , reg_gain = 0x%x\n ", gain, reg_gain);
+	write_cmos_sensor_8(0x0104, 0x01); 
+	write_cmos_sensor(0x0204, (reg_gain>>8)& 0xFF);
+	write_cmos_sensor(0x0205, reg_gain & 0xFF);
+	write_cmos_sensor_8(0x0104, 0x00); 	
 	return gain;
 }	/*	set_gain  */
 
-static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gain)
-{
-	LOG_INF("le:0x%x, se:0x%x, gain:0x%x\n",le,se,gain);
-	if (imgsensor.ihdr_en) {
-		
-		spin_lock(&imgsensor_drv_lock);
-			if (le > imgsensor.min_frame_length - imgsensor_info.margin)		
-				imgsensor.frame_length = le + imgsensor_info.margin;
-			else
-				imgsensor.frame_length = imgsensor.min_frame_length;
-			if (imgsensor.frame_length > imgsensor_info.max_frame_length)
-				imgsensor.frame_length = imgsensor_info.max_frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			if (le < imgsensor_info.min_shutter) le = imgsensor_info.min_shutter;
-			if (se < imgsensor_info.min_shutter) se = imgsensor_info.min_shutter;
-			
-			
-				// Extend frame length first
-				write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
-				write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
-
-		write_cmos_sensor(0x3502, (le << 4) & 0xFF);
-		write_cmos_sensor(0x3501, (le >> 4) & 0xFF);	 
-		write_cmos_sensor(0x3500, (le >> 12) & 0x0F);
-		
-		write_cmos_sensor(0x3508, (se << 4) & 0xFF); 
-		write_cmos_sensor(0x3507, (se >> 4) & 0xFF);
-		write_cmos_sensor(0x3506, (se >> 12) & 0x0F); 
-
-		set_gain(gain);
-	}
-
-}
-
-
-
 static void set_mirror_flip(kal_uint8 image_mirror)
 {
 	LOG_INF("image_mirror = %d\n", image_mirror);
 
 	/********************************************************
 	   *
-	   *   0x3820[2] ISP Vertical flip
-	   *   0x3820[1] Sensor Vertical flip
-	   *
-	   *   0x3821[2] ISP Horizontal mirror
-	   *   0x3821[1] Sensor Horizontal mirror
+	   *   0x0101 Sensor mirror flip 
 	   *
 	   *   ISP and Sensor flip or mirror register bit should be the same!!
 	   *
 	   ********************************************************/
 	kal_uint8  iTemp; 
-	LOG_INF("set_mirror_flip function\n");
-    iTemp = read_cmos_sensor(0x0172) & 0x03;	//Clear the mirror and flip bits.
-    switch (image_mirror)
-    {
-        case IMAGE_NORMAL:
-            write_cmos_sensor(0x0172, 0x03);	//Set normal
-            break;
-        case IMAGE_V_MIRROR:
-            write_cmos_sensor(0x0172, iTemp | 0x01);	//Set flip
-            break;
-        case IMAGE_H_MIRROR:
-            write_cmos_sensor(0x0172, iTemp | 0x02);	//Set mirror
-            break;
-        case IMAGE_HV_MIRROR:
-            write_cmos_sensor(0x0172, 0x00);	//Set mirror and flip
-            break;
-    }
-	LOG_INF("Error image_mirror setting\n");
+	
+	iTemp = read_cmos_sensor(0x0101);
+	iTemp&= ~0x03; //Clear the mirror and flip bits.
+	switch (image_mirror) 
+	{
+		case IMAGE_NORMAL:
+			write_cmos_sensor_8(0x0101, iTemp);    //Set normal
+			break;
+		case IMAGE_H_MIRROR:
+            write_cmos_sensor_8(0x0101, iTemp | 0x01); //Set mirror
+			break;
+		case IMAGE_V_MIRROR:
+            write_cmos_sensor_8(0x0101, iTemp | 0x02); //Set flip
+			break;
+		case IMAGE_HV_MIRROR:
+            write_cmos_sensor_8(0x0101, iTemp | 0x03); //Set mirror and flip
+			break;
+		default:
+			LOG_INF("Error image_mirror setting\n");
+	}
 
 }
 
@@ -631,584 +562,475 @@ static void night_mode(kal_bool enable)
 /*No Need to implement this function*/ 
 }	/*	night_mode	*/
 
-static void sensor_init(void)
-{
-	LOG_INF("E\n");
-	//write_cmos_sensor(0x0100,0x01);  //wake up
-}	/*	sensor_init  */
-
 
 static void preview_setting(void)
 {
-  write_cmos_sensor(0x41C0,0x01);
-	write_cmos_sensor(0x0104,0x01);
-	write_cmos_sensor(0x0100,0x00);
-	write_cmos_sensor(0x0103,0x01);
-	write_cmos_sensor(0x0114,0x03);
-	write_cmos_sensor(0x0118,0x00);
-	write_cmos_sensor(0x0119,0x87);
-	write_cmos_sensor(0x011a,0x00);
-	write_cmos_sensor(0x011b,0x4f);
-	write_cmos_sensor(0x011c,0x00);
-	write_cmos_sensor(0x011d,0x77);
-	write_cmos_sensor(0x011e,0x00);
-	write_cmos_sensor(0x011f,0x47);
-	write_cmos_sensor(0x0120,0x00);
-	write_cmos_sensor(0x0121,0x3f);
-	write_cmos_sensor(0x0122,0x00);
-	write_cmos_sensor(0x0123,0x4f);
-	write_cmos_sensor(0x0124,0x00);
-	write_cmos_sensor(0x011f,0x01);
-	write_cmos_sensor(0x030E,0x01);
-	write_cmos_sensor(0x0202,0x03);
-	write_cmos_sensor(0x0203,0xcc);
-	write_cmos_sensor(0x0301,0x05);
-	write_cmos_sensor(0x0303,0x01);
-	write_cmos_sensor(0x0304,0x03);
-	write_cmos_sensor(0x0305,0x06);
-	write_cmos_sensor(0x0306,0x00);
-	write_cmos_sensor(0x0307,0x51);
-	write_cmos_sensor(0x0309,0x0A);
-	write_cmos_sensor(0x030B,0x01);
-	write_cmos_sensor(0x030C,0x00);
-	write_cmos_sensor(0x030D,0x72);
-	write_cmos_sensor(0x0160,((imgsensor_info.pre.framelength >> 8) & 0xFF));  
-	write_cmos_sensor(0x0161,(imgsensor_info.pre.framelength & 0xFF));	       
-	write_cmos_sensor(0x0162,((imgsensor_info.pre.linelength >> 8) & 0xFF));   
-	write_cmos_sensor(0x0163,(imgsensor_info.pre.linelength & 0xFF));	         
-	write_cmos_sensor(0x0164,0x00);
-	write_cmos_sensor(0x0165,0x00);
-	write_cmos_sensor(0x0166,0x0c);
-	write_cmos_sensor(0x0167,0xd7);
-	write_cmos_sensor(0x0168,0x00);
-	write_cmos_sensor(0x0169,0x00);
-	write_cmos_sensor(0x016A,0x09);
-	write_cmos_sensor(0x016B,0xa7);
-	write_cmos_sensor(0x016C,0x0c);
-	write_cmos_sensor(0x016D,0xd0);
-	write_cmos_sensor(0x016E,0x09);
-	write_cmos_sensor(0x016F,0xa0);
-	write_cmos_sensor(0x0170,0x01);
-	write_cmos_sensor(0x0171,0x01);
-	//write_cmos_sensor(0x0172,0x00);//03
-	write_cmos_sensor(0x0174,0x01);
-	write_cmos_sensor(0x0175,0x00);
-	write_cmos_sensor(0x018C,0x0a);
-	write_cmos_sensor(0x018D,0x0a);
-	write_cmos_sensor(0x455E,0x00);
-	write_cmos_sensor(0x471E,0x4B);
-	write_cmos_sensor(0x4767,0x0F);
-	write_cmos_sensor(0x4750,0x14);
-	write_cmos_sensor(0x4540,0x00);
-	write_cmos_sensor(0x47B4,0x14);
-	write_cmos_sensor(0x4713,0x30);
-	write_cmos_sensor(0x478B,0x10);
-	write_cmos_sensor(0x478F,0x10);
-	write_cmos_sensor(0x4793,0x10);
-	write_cmos_sensor(0x4797,0x0E);
-	write_cmos_sensor(0x479B,0x0E);
-	write_cmos_sensor(0x0104,0x00);
-	write_cmos_sensor(0x0100,0x01);
-
-
-	 
+	LOG_INF("E\n"); //1640x1232
+	LOG_INF("[IMX175MIPI]enter PreviewSetting function\n");
+	write_cmos_sensor(0x41C0, 0x01);
+	write_cmos_sensor(0x0104, 0x01);//group
+	write_cmos_sensor(0x0100, 0x00);//STREAM OFF 	
+	//write_cmos_sensor(0x0103, 0x01);//SW reset
+	write_cmos_sensor(0x0101, 0x00);//mirror bit[0] hor.bit[1] ver.	 
+	write_cmos_sensor(0x030E, 0x01); 	   
+	write_cmos_sensor(0x0202, 0x06); 		 
+	write_cmos_sensor(0x0203, 0xAD);
+	//PLL setting
+	write_cmos_sensor(0x0301, 0x0A); 		 
+	write_cmos_sensor(0x0303, 0x01); 		 
+	write_cmos_sensor(0x0305, 0x06); 		 
+	write_cmos_sensor(0x0309, 0x0A); 		 
+	write_cmos_sensor(0x030B, 0x01); 		 
+	write_cmos_sensor(0x030C, 0x00); 		 
+	write_cmos_sensor(0x030D, 0xDD); 
+	write_cmos_sensor(0x030E, 0x01);
+
+	write_cmos_sensor(0x0340, 0x06);
+	write_cmos_sensor(0x0341, 0xB1); 		 
+	write_cmos_sensor(0x0342, 0x0D); 		
+	write_cmos_sensor(0x0343, 0x70); 		 
+	write_cmos_sensor(0x0344, 0x00); 		 
+	write_cmos_sensor(0x0345, 0x00); 		 
+	write_cmos_sensor(0x0346, 0x00); 		 
+	write_cmos_sensor(0x0347, 0x00); 		 
+	write_cmos_sensor(0x0348, 0x0C); 		
+	write_cmos_sensor(0x0349, 0xCF); 		 
+	write_cmos_sensor(0x034A, 0x09); 		 
+	write_cmos_sensor(0x034B, 0x9F); 		 
+	write_cmos_sensor(0x034C, 0x06); 		 
+	write_cmos_sensor(0x034D, 0x68); 		 
+	write_cmos_sensor(0x034E, 0x04); 		 
+	write_cmos_sensor(0x034F, 0xD0); 		 
+	write_cmos_sensor(0x0383, 0x01); 		 
+	write_cmos_sensor(0x0387, 0x01); 		
+	write_cmos_sensor(0x0390, 0x01); 		 
+	write_cmos_sensor(0x0401, 0x00); 		 
+	write_cmos_sensor(0x0405, 0x10); 		 
+	write_cmos_sensor(0x3020, 0x10); 		 
+	write_cmos_sensor(0x3041, 0x15); 		 
+	write_cmos_sensor(0x3042, 0x87); 		 
+	write_cmos_sensor(0x3089, 0x4F); 		 
+	write_cmos_sensor(0x3309, 0x9A); 		 
+	write_cmos_sensor(0x3344, 0x6F); 		 
+	write_cmos_sensor(0x3345, 0x1F); 		 
+	write_cmos_sensor(0x3362, 0x0A); 		 
+	write_cmos_sensor(0x3363, 0x0A); 		 
+	write_cmos_sensor(0x3364, 0x02); 		
+	write_cmos_sensor(0x3368, 0x18); 		 
+	write_cmos_sensor(0x3369, 0x00); 		 
+	write_cmos_sensor(0x3370, 0x7F); 		 
+	write_cmos_sensor(0x3371, 0x37); 		 
+	write_cmos_sensor(0x3372, 0x67); 		 
+	write_cmos_sensor(0x3373, 0x3F); 		 
+	write_cmos_sensor(0x3374, 0x3F); 		 
+	write_cmos_sensor(0x3375, 0x47); 		 
+	write_cmos_sensor(0x3376, 0xCF); 		 
+	write_cmos_sensor(0x3377, 0x47); 		
+	write_cmos_sensor(0x33C8, 0x00); 		 
+	write_cmos_sensor(0x33D4, 0x06); 		 
+	write_cmos_sensor(0x33D5, 0x68); 		 
+	write_cmos_sensor(0x33D6, 0x04); 	   
+	write_cmos_sensor(0x33D7, 0xD0); 	  
+	write_cmos_sensor(0x4100, 0x0E); 	   
+	write_cmos_sensor(0x4108, 0x01);
+	write_cmos_sensor(0x4109, 0x7C);
+	write_cmos_sensor(0x0104, 0x00);//group
+	write_cmos_sensor(0x0100, 0x01);//STREAM ON
 }	/*	preview_setting  */
 
 static void capture_setting(kal_uint16 currefps)
 {
 	LOG_INF("E! currefps:%d\n",currefps);
-	if (currefps == 240) { //24fps for PIP
-		//@@full_132PCLK_24.75
-      write_cmos_sensor(0x41C0,0x01);
-			write_cmos_sensor(0x0104,0x01);
-			write_cmos_sensor(0x0100,0x00);
-			write_cmos_sensor(0x0103,0x01);
-			write_cmos_sensor(0x0114,0x03);
-			write_cmos_sensor(0x0118,0x00);
-			write_cmos_sensor(0x0119,0x87);
-			write_cmos_sensor(0x011a,0x00);
-			write_cmos_sensor(0x011b,0x4f);
-			write_cmos_sensor(0x011c,0x00);
-			write_cmos_sensor(0x011d,0x77);
-			write_cmos_sensor(0x011e,0x00);
-			write_cmos_sensor(0x011f,0x47);
-			write_cmos_sensor(0x0120,0x00);
-			write_cmos_sensor(0x0121,0x3f);
-			write_cmos_sensor(0x0122,0x00);
-			write_cmos_sensor(0x0123,0x4f);
-			write_cmos_sensor(0x0124,0x00);
-			write_cmos_sensor(0x011f,0x01);
-			write_cmos_sensor(0x030E,0x01);
-			write_cmos_sensor(0x0202,0x03);
-			write_cmos_sensor(0x0203,0xcc);
-			write_cmos_sensor(0x0301,0x05);
-			write_cmos_sensor(0x0303,0x01);
-			write_cmos_sensor(0x0304,0x03);
-			write_cmos_sensor(0x0305,0x06);
-			write_cmos_sensor(0x0306,0x00);
-			write_cmos_sensor(0x0307,0x51);
-			write_cmos_sensor(0x0309,0x0A);
-			write_cmos_sensor(0x030B,0x01);
-			write_cmos_sensor(0x030C,0x00);
-			write_cmos_sensor(0x030D,0x72);
-			write_cmos_sensor(0x0160,((imgsensor_info.cap.framelength >> 8) & 0xFF));  
-			write_cmos_sensor(0x0161,(imgsensor_info.cap.framelength & 0xFF));         
-			write_cmos_sensor(0x0162,((imgsensor_info.cap.linelength >> 8) & 0xFF));	 
-			write_cmos_sensor(0x0163,(imgsensor_info.cap.linelength & 0xFF));          
-			write_cmos_sensor(0x0164,0x00);
-			write_cmos_sensor(0x0165,0x00);
-			write_cmos_sensor(0x0166,0x0c);
-			write_cmos_sensor(0x0167,0xd7);
-			write_cmos_sensor(0x0168,0x00);
-			write_cmos_sensor(0x0169,0x00);
-			write_cmos_sensor(0x016A,0x09);
-			write_cmos_sensor(0x016B,0xa7);
-			write_cmos_sensor(0x016C,0x0c);
-			write_cmos_sensor(0x016D,0xd0);
-			write_cmos_sensor(0x016E,0x09);
-			write_cmos_sensor(0x016F,0xa0);
-			write_cmos_sensor(0x0170,0x01);
-			write_cmos_sensor(0x0171,0x01);
-			//write_cmos_sensor(0x0172,0x00);//03
-			write_cmos_sensor(0x0174,0x00);
-			write_cmos_sensor(0x0175,0x00);
-			write_cmos_sensor(0x018C,0x0a);
-			write_cmos_sensor(0x018D,0x0a);
-			write_cmos_sensor(0x455E,0x00);
-			write_cmos_sensor(0x471E,0x4B);
-			write_cmos_sensor(0x4767,0x0F);
-			write_cmos_sensor(0x4750,0x14);
-			write_cmos_sensor(0x4540,0x00);
-			write_cmos_sensor(0x47B4,0x14);
-			write_cmos_sensor(0x4713,0x30);
-			write_cmos_sensor(0x478B,0x10);
-			write_cmos_sensor(0x478F,0x10);
-			write_cmos_sensor(0x4793,0x10);
-			write_cmos_sensor(0x4797,0x0E);
-			write_cmos_sensor(0x479B,0x0E);
-			write_cmos_sensor(0x0104,0x00);
-			write_cmos_sensor(0x0100,0x01);
-
-
-	} else {   //30fps			//30fps for Normal capture & ZSD
-		  
-		 write_cmos_sensor(0x41C0,0x01);
-			write_cmos_sensor(0x0104,0x01);
-			write_cmos_sensor(0x0100,0x00);
-			write_cmos_sensor(0x0103,0x01);
-			write_cmos_sensor(0x0114,0x03);
-			write_cmos_sensor(0x0118,0x00);
-			write_cmos_sensor(0x0119,0x87);
-			write_cmos_sensor(0x011a,0x00);
-			write_cmos_sensor(0x011b,0x4f);
-			write_cmos_sensor(0x011c,0x00);
-			write_cmos_sensor(0x011d,0x77);
-			write_cmos_sensor(0x011e,0x00);
-			write_cmos_sensor(0x011f,0x47);
-			write_cmos_sensor(0x0120,0x00);
-			write_cmos_sensor(0x0121,0x3f);
-			write_cmos_sensor(0x0122,0x00);
-			write_cmos_sensor(0x0123,0x4f);
-			write_cmos_sensor(0x0124,0x00);
-			write_cmos_sensor(0x011f,0x01);
-			write_cmos_sensor(0x030E,0x01);
-			write_cmos_sensor(0x0202,0x03);
-			write_cmos_sensor(0x0203,0xcc);
-			write_cmos_sensor(0x0301,0x05);
-			write_cmos_sensor(0x0303,0x01);
-			write_cmos_sensor(0x0304,0x03);
-			write_cmos_sensor(0x0305,0x06);
-			write_cmos_sensor(0x0306,0x00);
-			write_cmos_sensor(0x0307,0x51);
-			write_cmos_sensor(0x0309,0x0A);
-			write_cmos_sensor(0x030B,0x01);
-			write_cmos_sensor(0x030C,0x00);
-			write_cmos_sensor(0x030D,0x72);
-			write_cmos_sensor(0x0160,((imgsensor_info.cap.framelength >> 8) & 0xFF));  
-			write_cmos_sensor(0x0161,(imgsensor_info.cap.framelength & 0xFF));         
-			write_cmos_sensor(0x0162,((imgsensor_info.cap.linelength >> 8) & 0xFF));	 
-			write_cmos_sensor(0x0163,(imgsensor_info.cap.linelength & 0xFF));          
-			write_cmos_sensor(0x0164,0x00);
-			write_cmos_sensor(0x0165,0x00);
-			write_cmos_sensor(0x0166,0x0c);
-			write_cmos_sensor(0x0167,0xd7);
-			write_cmos_sensor(0x0168,0x00);
-			write_cmos_sensor(0x0169,0x00);
-			write_cmos_sensor(0x016A,0x09);
-			write_cmos_sensor(0x016B,0xa7);
-			write_cmos_sensor(0x016C,0x0c);
-			write_cmos_sensor(0x016D,0xd0);
-			write_cmos_sensor(0x016E,0x09);
-			write_cmos_sensor(0x016F,0xa0);
-			write_cmos_sensor(0x0170,0x01);
-			write_cmos_sensor(0x0171,0x01);
-			//write_cmos_sensor(0x0172,0x03);
-			write_cmos_sensor(0x0174,0x00);
-			write_cmos_sensor(0x0175,0x00);
-			write_cmos_sensor(0x018C,0x0a);
-			write_cmos_sensor(0x018D,0x0a);
-			write_cmos_sensor(0x455E,0x00);
-			write_cmos_sensor(0x471E,0x4B);
-			write_cmos_sensor(0x4767,0x0F);
-			write_cmos_sensor(0x4750,0x14);
-			write_cmos_sensor(0x4540,0x00);
-			write_cmos_sensor(0x47B4,0x14);
-			write_cmos_sensor(0x4713,0x30);
-			write_cmos_sensor(0x478B,0x10);
-			write_cmos_sensor(0x478F,0x10);
-			write_cmos_sensor(0x4793,0x10);
-			write_cmos_sensor(0x4797,0x0E);
-			write_cmos_sensor(0x479B,0x0E);
-			write_cmos_sensor(0x0104,0x00);
-			write_cmos_sensor(0x0100,0x01);
-
-
-		if (imgsensor.ihdr_en) {
-		
-	} else {
-		
-	}
-		
+	if (currefps == 240) 
+	{ //24fps for PIP //@@full_132PCLK_24.75 3280x2464
+	 LOG_INF("[IMX175MIPI]enter IMX175MIPI_set_8M function\n");
+	write_cmos_sensor(0x41C0, 0x01);         
+	write_cmos_sensor(0x0100, 0x00);          
+	write_cmos_sensor(0x0101, 0x00);//mirror bit[0] hor.bit[1] ver.         
+	write_cmos_sensor(0x030E, 0x0C);          
+	write_cmos_sensor(0x0202, 0x09);
+	write_cmos_sensor(0x0203, 0xAA);
+	//PLLsetting
+	write_cmos_sensor(0x0301, 0x0A);          
+	write_cmos_sensor(0x0303, 0x01);          
+	write_cmos_sensor(0x0305, 0x06);          
+	write_cmos_sensor(0x0309, 0x0A);          
+	write_cmos_sensor(0x030B, 0x01);          
+	write_cmos_sensor(0x030C, 0x00);
+	write_cmos_sensor(0x030D, 0xDD);
+	write_cmos_sensor(0x030E, 0x01); 
+	
+	write_cmos_sensor(0x0340, 0x0c);
+	write_cmos_sensor(0x0341, 0x1a);          
+	write_cmos_sensor(0x0342, 0x0D);          
+	write_cmos_sensor(0x0343, 0x70);          
+	write_cmos_sensor(0x0344, 0x00);          
+	write_cmos_sensor(0x0345, 0x00);          
+	write_cmos_sensor(0x0346, 0x00);          
+	write_cmos_sensor(0x0347, 0x00);          
+	write_cmos_sensor(0x0348, 0x0C);          
+	write_cmos_sensor(0x0349, 0xCF);          
+	write_cmos_sensor(0x034A, 0x09);          
+	write_cmos_sensor(0x034B, 0x9F);          
+	write_cmos_sensor(0x034C, 0x0C);          
+	write_cmos_sensor(0x034D, 0xD0);          
+	write_cmos_sensor(0x034E, 0x09);         
+	write_cmos_sensor(0x034F, 0xA0);          
+	write_cmos_sensor(0x0383, 0x01);          
+	write_cmos_sensor(0x0387, 0x01);          
+	write_cmos_sensor(0x0390, 0x00);          
+	write_cmos_sensor(0x0401, 0x00);          
+	write_cmos_sensor(0x0405, 0x10);          
+	write_cmos_sensor(0x3020, 0x10);          
+	write_cmos_sensor(0x3041, 0x15);          
+	write_cmos_sensor(0x3042, 0x87);          
+	write_cmos_sensor(0x3089, 0x4F);          
+	write_cmos_sensor(0x3309, 0x9A);          
+	write_cmos_sensor(0x3344, 0x6F);          
+	write_cmos_sensor(0x3345, 0x1F);          
+	write_cmos_sensor(0x3362, 0x0A);          
+	write_cmos_sensor(0x3363, 0x0A);          
+	write_cmos_sensor(0x3364, 0x02);          
+	write_cmos_sensor(0x3368, 0x18);          
+	write_cmos_sensor(0x3369, 0x00);          
+	write_cmos_sensor(0x3370, 0x7F);         
+	write_cmos_sensor(0x3371, 0x37);          
+	write_cmos_sensor(0x3372, 0x67);          
+	write_cmos_sensor(0x3373, 0x3F);          
+	write_cmos_sensor(0x3374, 0x3F);         
+	write_cmos_sensor(0x3375, 0x47);          
+	write_cmos_sensor(0x3376, 0xCF);          
+	write_cmos_sensor(0x3377, 0x47);          
+	write_cmos_sensor(0x33C8, 0x00);          
+	write_cmos_sensor(0x33D4, 0x0C);          
+	write_cmos_sensor(0x33D5, 0xD0);          
+	write_cmos_sensor(0x33D6, 0x09);          
+	write_cmos_sensor(0x33D7, 0xA0);          
+	write_cmos_sensor(0x4100, 0x0E);          
+	write_cmos_sensor(0x4108, 0x01);          
+	write_cmos_sensor(0x4109, 0x7C);  
+	write_cmos_sensor(0x0100, 0x01);//STREAM ON
+	LOG_INF("[IMX175MIPI]exit IMX175MIPI_set_8M function\n"); 
 	}
-		
+	else
+	{   //30fps		
+		//30fps for Normal capture & ZSD
+	LOG_INF("[IMX175MIPI]enter IMX175MIPI_set_8M function\n");
+	write_cmos_sensor(0x41C0, 0x01);         
+	write_cmos_sensor(0x0100, 0x00);          
+	write_cmos_sensor(0x0101, 0x00);//mirror bit[0] hor.bit[1] ver.         
+	write_cmos_sensor(0x030E, 0x0C);          
+	write_cmos_sensor(0x0202, 0x09);
+	write_cmos_sensor(0x0203, 0xAA);
+	//PLLsetting
+	write_cmos_sensor(0x0301, 0x0A);          
+	write_cmos_sensor(0x0303, 0x01);          
+	write_cmos_sensor(0x0305, 0x06);          
+	write_cmos_sensor(0x0309, 0x0A);          
+	write_cmos_sensor(0x030B, 0x01);          
+	write_cmos_sensor(0x030C, 0x00);
+	write_cmos_sensor(0x030D, 0xDD);
+	write_cmos_sensor(0x030E, 0x01); 
+	
+	write_cmos_sensor(0x0340, 0x09);
+	write_cmos_sensor(0x0341, 0xAE);          
+	write_cmos_sensor(0x0342, 0x0D);          
+	write_cmos_sensor(0x0343, 0x70);          
+	write_cmos_sensor(0x0344, 0x00);          
+	write_cmos_sensor(0x0345, 0x00);          
+	write_cmos_sensor(0x0346, 0x00);          
+	write_cmos_sensor(0x0347, 0x00);          
+	write_cmos_sensor(0x0348, 0x0C);          
+	write_cmos_sensor(0x0349, 0xCF);          
+	write_cmos_sensor(0x034A, 0x09);          
+	write_cmos_sensor(0x034B, 0x9F);          
+	write_cmos_sensor(0x034C, 0x0C);          
+	write_cmos_sensor(0x034D, 0xD0);          
+	write_cmos_sensor(0x034E, 0x09);         
+	write_cmos_sensor(0x034F, 0xA0);          
+	write_cmos_sensor(0x0383, 0x01);          
+	write_cmos_sensor(0x0387, 0x01);          
+	write_cmos_sensor(0x0390, 0x00);          
+	write_cmos_sensor(0x0401, 0x00);          
+	write_cmos_sensor(0x0405, 0x10);          
+	write_cmos_sensor(0x3020, 0x10);          
+	write_cmos_sensor(0x3041, 0x15);          
+	write_cmos_sensor(0x3042, 0x87);          
+	write_cmos_sensor(0x3089, 0x4F);          
+	write_cmos_sensor(0x3309, 0x9A);          
+	write_cmos_sensor(0x3344, 0x6F);          
+	write_cmos_sensor(0x3345, 0x1F);          
+	write_cmos_sensor(0x3362, 0x0A);          
+	write_cmos_sensor(0x3363, 0x0A);          
+	write_cmos_sensor(0x3364, 0x02);          
+	write_cmos_sensor(0x3368, 0x18);          
+	write_cmos_sensor(0x3369, 0x00);          
+	write_cmos_sensor(0x3370, 0x7F);         
+	write_cmos_sensor(0x3371, 0x37);          
+	write_cmos_sensor(0x3372, 0x67);          
+	write_cmos_sensor(0x3373, 0x3F);          
+	write_cmos_sensor(0x3374, 0x3F);         
+	write_cmos_sensor(0x3375, 0x47);          
+	write_cmos_sensor(0x3376, 0xCF);          
+	write_cmos_sensor(0x3377, 0x47);          
+	write_cmos_sensor(0x33C8, 0x00);          
+	write_cmos_sensor(0x33D4, 0x0C);          
+	write_cmos_sensor(0x33D5, 0xD0);          
+	write_cmos_sensor(0x33D6, 0x09);          
+	write_cmos_sensor(0x33D7, 0xA0);          
+	write_cmos_sensor(0x4100, 0x0E);          
+	write_cmos_sensor(0x4108, 0x01);          
+	write_cmos_sensor(0x4109, 0x7C);  
+	write_cmos_sensor(0x0100, 0x01);//STREAM ON
+	LOG_INF("[IMX175MIPI]exit IMX175MIPI_set_8M function\n"); 
+	}	
 }
 
 static void normal_video_setting(kal_uint16 currefps)
-{
-	LOG_INF("E! currefps:%d\n",currefps);
-	     write_cmos_sensor(0x41C0,0x01);
-			write_cmos_sensor(0x0104,0x01);
-			write_cmos_sensor(0x0100,0x00);
-			write_cmos_sensor(0x0103,0x01);
-			write_cmos_sensor(0x0114,0x03);
-			write_cmos_sensor(0x0118,0x00);
-			write_cmos_sensor(0x0119,0x87);
-			write_cmos_sensor(0x011a,0x00);
-			write_cmos_sensor(0x011b,0x4f);
-			write_cmos_sensor(0x011c,0x00);
-			write_cmos_sensor(0x011d,0x77);
-			write_cmos_sensor(0x011e,0x00);
-			write_cmos_sensor(0x011f,0x47);
-			write_cmos_sensor(0x0120,0x00);
-			write_cmos_sensor(0x0121,0x3f);
-			write_cmos_sensor(0x0122,0x00);
-			write_cmos_sensor(0x0123,0x4f);
-			write_cmos_sensor(0x0124,0x00);
-			write_cmos_sensor(0x011f,0x01);
-			write_cmos_sensor(0x030E,0x01);
-			write_cmos_sensor(0x0202,0x03);
-			write_cmos_sensor(0x0203,0xcc);
-			write_cmos_sensor(0x0301,0x05);
-			write_cmos_sensor(0x0303,0x01);
-			write_cmos_sensor(0x0304,0x03);
-			write_cmos_sensor(0x0305,0x06);
-			write_cmos_sensor(0x0306,0x00);
-			write_cmos_sensor(0x0307,0x51);
-			write_cmos_sensor(0x0309,0x0A);
-			write_cmos_sensor(0x030B,0x01);
-			write_cmos_sensor(0x030C,0x00);
-			write_cmos_sensor(0x030D,0x72);
-			write_cmos_sensor(0x0160,((imgsensor_info.cap.framelength >> 8) & 0xFF));  
-			write_cmos_sensor(0x0161,(imgsensor_info.cap.framelength & 0xFF));         
-			write_cmos_sensor(0x0162,((imgsensor_info.cap.linelength >> 8) & 0xFF));	 
-			write_cmos_sensor(0x0163,(imgsensor_info.cap.linelength & 0xFF));          
-			write_cmos_sensor(0x0164,0x00);
-			write_cmos_sensor(0x0165,0x00);
-			write_cmos_sensor(0x0166,0x0c);
-			write_cmos_sensor(0x0167,0xd7);
-			write_cmos_sensor(0x0168,0x00);
-			write_cmos_sensor(0x0169,0x00);
-			write_cmos_sensor(0x016A,0x09);
-			write_cmos_sensor(0x016B,0xa7);
-			write_cmos_sensor(0x016C,0x0c);
-			write_cmos_sensor(0x016D,0xd0);
-			write_cmos_sensor(0x016E,0x09);
-			write_cmos_sensor(0x016F,0xa0);
-			write_cmos_sensor(0x0170,0x01);
-			write_cmos_sensor(0x0171,0x01);
-			//write_cmos_sensor(0x0172,0x03);
-			write_cmos_sensor(0x0174,0x00);
-			write_cmos_sensor(0x0175,0x00);
-			write_cmos_sensor(0x018C,0x0a);
-			write_cmos_sensor(0x018D,0x0a);
-			write_cmos_sensor(0x455E,0x00);
-			write_cmos_sensor(0x471E,0x4B);
-			write_cmos_sensor(0x4767,0x0F);
-			write_cmos_sensor(0x4750,0x14);
-			write_cmos_sensor(0x4540,0x00);
-			write_cmos_sensor(0x47B4,0x14);
-			write_cmos_sensor(0x4713,0x30);
-			write_cmos_sensor(0x478B,0x10);
-			write_cmos_sensor(0x478F,0x10);
-			write_cmos_sensor(0x4793,0x10);
-			write_cmos_sensor(0x4797,0x0E);
-			write_cmos_sensor(0x479B,0x0E);
-			write_cmos_sensor(0x0104,0x00);
-			write_cmos_sensor(0x0100,0x01);
-	if (imgsensor.ihdr_en) {
-	} else {
-	}
-
+{		
+		//30fps for Normal capture & ZSD
+		//5.1.2 FQPreview 3280x2464 30fps 24M MCLK 4lane 256Mbps/lane
+		LOG_INF("E! currefps:%d\n",currefps);
+	write_cmos_sensor(0x41C0, 0x01);         
+	write_cmos_sensor(0x0100, 0x00);          
+	write_cmos_sensor(0x0101, 0x00);//mirror bit[0] hor.bit[1] ver.         
+	write_cmos_sensor(0x030E, 0x0C);          
+	write_cmos_sensor(0x0202, 0x09);
+	write_cmos_sensor(0x0203, 0xAA);
+	//PLLsetting
+	write_cmos_sensor(0x0301, 0x0A);          
+	write_cmos_sensor(0x0303, 0x01);          
+	write_cmos_sensor(0x0305, 0x06);          
+	write_cmos_sensor(0x0309, 0x0A);          
+	write_cmos_sensor(0x030B, 0x01);          
+	write_cmos_sensor(0x030C, 0x00);
+	write_cmos_sensor(0x030D, 0xDD);
+	write_cmos_sensor(0x030E, 0x01); 
+	
+	write_cmos_sensor(0x0340, 0x09);
+	write_cmos_sensor(0x0341, 0xAE);          
+	write_cmos_sensor(0x0342, 0x0D);          
+	write_cmos_sensor(0x0343, 0x70);          
+	write_cmos_sensor(0x0344, 0x00);          
+	write_cmos_sensor(0x0345, 0x00);          
+	write_cmos_sensor(0x0346, 0x00);          
+	write_cmos_sensor(0x0347, 0x00);          
+	write_cmos_sensor(0x0348, 0x0C);          
+	write_cmos_sensor(0x0349, 0xCF);          
+	write_cmos_sensor(0x034A, 0x09);          
+	write_cmos_sensor(0x034B, 0x9F);          
+	write_cmos_sensor(0x034C, 0x0C);          
+	write_cmos_sensor(0x034D, 0xD0);          
+	write_cmos_sensor(0x034E, 0x09);         
+	write_cmos_sensor(0x034F, 0xA0);          
+	write_cmos_sensor(0x0383, 0x01);          
+	write_cmos_sensor(0x0387, 0x01);          
+	write_cmos_sensor(0x0390, 0x00);          
+	write_cmos_sensor(0x0401, 0x00);          
+	write_cmos_sensor(0x0405, 0x10);          
+	write_cmos_sensor(0x3020, 0x10);          
+	write_cmos_sensor(0x3041, 0x15);          
+	write_cmos_sensor(0x3042, 0x87);          
+	write_cmos_sensor(0x3089, 0x4F);          
+	write_cmos_sensor(0x3309, 0x9A);          
+	write_cmos_sensor(0x3344, 0x6F);          
+	write_cmos_sensor(0x3345, 0x1F);          
+	write_cmos_sensor(0x3362, 0x0A);          
+	write_cmos_sensor(0x3363, 0x0A);          
+	write_cmos_sensor(0x3364, 0x02);          
+	write_cmos_sensor(0x3368, 0x18);          
+	write_cmos_sensor(0x3369, 0x00);          
+	write_cmos_sensor(0x3370, 0x7F);         
+	write_cmos_sensor(0x3371, 0x37);          
+	write_cmos_sensor(0x3372, 0x67);          
+	write_cmos_sensor(0x3373, 0x3F);          
+	write_cmos_sensor(0x3374, 0x3F);         
+	write_cmos_sensor(0x3375, 0x47);          
+	write_cmos_sensor(0x3376, 0xCF);          
+	write_cmos_sensor(0x3377, 0x47);          
+	write_cmos_sensor(0x33C8, 0x00);          
+	write_cmos_sensor(0x33D4, 0x0C);          
+	write_cmos_sensor(0x33D5, 0xD0);          
+	write_cmos_sensor(0x33D6, 0x09);          
+	write_cmos_sensor(0x33D7, 0xA0);          
+	write_cmos_sensor(0x4100, 0x0E);          
+	write_cmos_sensor(0x4108, 0x01);          
+	write_cmos_sensor(0x4109, 0x7C);  
+	write_cmos_sensor(0x0100, 0x01);//STREAM ON
+	LOG_INF("[IMX175MIPI]exit IMX175MIPI_set_8M function\n"); 
 }
 static void hs_video_setting()
 {
+	
 	LOG_INF("E\n");
-
-	    write_cmos_sensor(0x41C0,0x01);
-			write_cmos_sensor(0x0104,0x01);
-			write_cmos_sensor(0x0100,0x00);
-			write_cmos_sensor(0x0103,0x01);
-			write_cmos_sensor(0x0114,0x03);
-			write_cmos_sensor(0x0118,0x00);
-			write_cmos_sensor(0x0119,0x87);
-			write_cmos_sensor(0x011a,0x00);
-			write_cmos_sensor(0x011b,0x4f);
-			write_cmos_sensor(0x011c,0x00);
-			write_cmos_sensor(0x011d,0x77);
-			write_cmos_sensor(0x011e,0x00);
-			write_cmos_sensor(0x011f,0x47);
-			write_cmos_sensor(0x0120,0x00);
-			write_cmos_sensor(0x0121,0x3f);
-			write_cmos_sensor(0x0122,0x00);
-			write_cmos_sensor(0x0123,0x4f);
-			write_cmos_sensor(0x0124,0x00);
-			write_cmos_sensor(0x011f,0x01);
-			write_cmos_sensor(0x030E,0x01);
-			write_cmos_sensor(0x0202,0x03);
-			write_cmos_sensor(0x0203,0xcc);
-			write_cmos_sensor(0x0301,0x05);
-			write_cmos_sensor(0x0303,0x01);
-			write_cmos_sensor(0x0304,0x03);
-			write_cmos_sensor(0x0305,0x06);
-			write_cmos_sensor(0x0306,0x00);
-			write_cmos_sensor(0x0307,0x51);
-			write_cmos_sensor(0x0309,0x0A);
-			write_cmos_sensor(0x030B,0x01);
-			write_cmos_sensor(0x030C,0x00);
-			write_cmos_sensor(0x030D,0x72);
-			write_cmos_sensor(0x0160,((imgsensor_info.cap.framelength >> 8) & 0xFF));  
-			write_cmos_sensor(0x0161,(imgsensor_info.cap.framelength & 0xFF));         
-			write_cmos_sensor(0x0162,((imgsensor_info.cap.linelength >> 8) & 0xFF));	 
-			write_cmos_sensor(0x0163,(imgsensor_info.cap.linelength & 0xFF));          
-			write_cmos_sensor(0x0164,0x02);
-			write_cmos_sensor(0x0165,0xa8);
-			write_cmos_sensor(0x0166,0x0a);
-			write_cmos_sensor(0x0167,0x27);
-			write_cmos_sensor(0x0168,0x02);
-			write_cmos_sensor(0x0169,0xb4);
-			write_cmos_sensor(0x016A,0x06);
-			write_cmos_sensor(0x016B,0xe8);
-			write_cmos_sensor(0x016C,0x07);
-			write_cmos_sensor(0x016D,0x80);
-			write_cmos_sensor(0x016E,0x04);
-			write_cmos_sensor(0x016F,0x38);
-			write_cmos_sensor(0x0170,0x01);
-			write_cmos_sensor(0x0171,0x01);
-			//write_cmos_sensor(0x0172,0x03);
-			write_cmos_sensor(0x0174,0x00);
-			write_cmos_sensor(0x0175,0x00);
-			write_cmos_sensor(0x018C,0x0a);
-			write_cmos_sensor(0x018D,0x0a);
-			write_cmos_sensor(0x455E,0x00);
-			write_cmos_sensor(0x471E,0x4B);
-			write_cmos_sensor(0x4767,0x0F);
-			write_cmos_sensor(0x4750,0x14);
-			write_cmos_sensor(0x4540,0x00);
-			write_cmos_sensor(0x47B4,0x14);
-			write_cmos_sensor(0x4713,0x30);
-			write_cmos_sensor(0x478B,0x10);
-			write_cmos_sensor(0x478F,0x10);
-			write_cmos_sensor(0x4793,0x10);
-			write_cmos_sensor(0x4797,0x0E);
-			write_cmos_sensor(0x479B,0x0E);
-			write_cmos_sensor(0x0104,0x00);
-			write_cmos_sensor(0x0100,0x01);
-	if (imgsensor.ihdr_en) {
-	} else {
-	}
-
+	LOG_INF("[IMX175MIPI]enter VideoFullSizeSetting function\n");
+	LOG_INF("[IMX175MIPI]enter PreviewSetting function\n");
+	write_cmos_sensor(0x41C0, 0x01);
+	write_cmos_sensor(0x0104, 0x01);//group
+	write_cmos_sensor(0x0100, 0x00);//STREAM OFF 	
+	//write_cmos_sensor(0x0103, 0x01);//SW reset
+	write_cmos_sensor(0x0101, 0x00);//mirror bit[0] hor.bit[1] ver.	 
+	write_cmos_sensor(0x030E, 0x01); 	   
+	write_cmos_sensor(0x0202, 0x06); 		 
+	write_cmos_sensor(0x0203, 0xAD);
+	//PLL setting
+	write_cmos_sensor(0x0301, 0x0A); 		 
+	write_cmos_sensor(0x0303, 0x01); 		 
+	write_cmos_sensor(0x0305, 0x06); 		 
+	write_cmos_sensor(0x0309, 0x0A); 		 
+	write_cmos_sensor(0x030B, 0x01); 		 
+	write_cmos_sensor(0x030C, 0x00); 		 
+	write_cmos_sensor(0x030D, 0xDD); 
+	write_cmos_sensor(0x030E, 0x01);
+
+	write_cmos_sensor(0x0340, 0x06);
+	write_cmos_sensor(0x0341, 0xB1); 		 
+	write_cmos_sensor(0x0342, 0x0D); 		
+	write_cmos_sensor(0x0343, 0x70); 		 
+	write_cmos_sensor(0x0344, 0x00); 		 
+	write_cmos_sensor(0x0345, 0x00); 		 
+	write_cmos_sensor(0x0346, 0x00); 		 
+	write_cmos_sensor(0x0347, 0x00); 		 
+	write_cmos_sensor(0x0348, 0x0C); 		
+	write_cmos_sensor(0x0349, 0xCF); 		 
+	write_cmos_sensor(0x034A, 0x09); 		 
+	write_cmos_sensor(0x034B, 0x9F); 		 
+	write_cmos_sensor(0x034C, 0x06); 		 
+	write_cmos_sensor(0x034D, 0x68); 		 
+	write_cmos_sensor(0x034E, 0x04); 		 
+	write_cmos_sensor(0x034F, 0xD0); 		 
+	write_cmos_sensor(0x0383, 0x01); 		 
+	write_cmos_sensor(0x0387, 0x01); 		
+	write_cmos_sensor(0x0390, 0x01); 		 
+	write_cmos_sensor(0x0401, 0x00); 		 
+	write_cmos_sensor(0x0405, 0x10); 		 
+	write_cmos_sensor(0x3020, 0x10); 		 
+	write_cmos_sensor(0x3041, 0x15); 		 
+	write_cmos_sensor(0x3042, 0x87); 		 
+	write_cmos_sensor(0x3089, 0x4F); 		 
+	write_cmos_sensor(0x3309, 0x9A); 		 
+	write_cmos_sensor(0x3344, 0x6F); 		 
+	write_cmos_sensor(0x3345, 0x1F); 		 
+	write_cmos_sensor(0x3362, 0x0A); 		 
+	write_cmos_sensor(0x3363, 0x0A); 		 
+	write_cmos_sensor(0x3364, 0x02); 		
+	write_cmos_sensor(0x3368, 0x18); 		 
+	write_cmos_sensor(0x3369, 0x00); 		 
+	write_cmos_sensor(0x3370, 0x7F); 		 
+	write_cmos_sensor(0x3371, 0x37); 		 
+	write_cmos_sensor(0x3372, 0x67); 		 
+	write_cmos_sensor(0x3373, 0x3F); 		 
+	write_cmos_sensor(0x3374, 0x3F); 		 
+	write_cmos_sensor(0x3375, 0x47); 		 
+	write_cmos_sensor(0x3376, 0xCF); 		 
+	write_cmos_sensor(0x3377, 0x47); 		
+	write_cmos_sensor(0x33C8, 0x00); 		 
+	write_cmos_sensor(0x33D4, 0x06); 		 
+	write_cmos_sensor(0x33D5, 0x68); 		 
+	write_cmos_sensor(0x33D6, 0x04); 	   
+	write_cmos_sensor(0x33D7, 0xD0); 	  
+	write_cmos_sensor(0x4100, 0x0E); 	   
+	write_cmos_sensor(0x4108, 0x01);
+	write_cmos_sensor(0x4109, 0x7C);
+	write_cmos_sensor(0x0104, 0x00);//group
+	write_cmos_sensor(0x0100, 0x01);//STREAM ON
+	LOG_INF("[IMX175MIPI]exit VideoFullSizeSetting function\n"); 
 }
 
 static void slim_video_setting()
 {
+	//5.1.2hs_video 3280x1664 30fps
 	LOG_INF("E\n");
-
-  write_cmos_sensor(0x41C0,0x01);
-	write_cmos_sensor(0x0104,0x01);
-	write_cmos_sensor(0x0100,0x00);
-	write_cmos_sensor(0x0103,0x01);
-	write_cmos_sensor(0x0114,0x03);
-	write_cmos_sensor(0x0118,0x00);
-	write_cmos_sensor(0x0119,0x87);
-	write_cmos_sensor(0x011a,0x00);
-	write_cmos_sensor(0x011b,0x4f);
-	write_cmos_sensor(0x011c,0x00);
-	write_cmos_sensor(0x011d,0x77);
-	write_cmos_sensor(0x011e,0x00);
-	write_cmos_sensor(0x011f,0x47);
-	write_cmos_sensor(0x0120,0x00);
-	write_cmos_sensor(0x0121,0x3f);
-	write_cmos_sensor(0x0122,0x00);
-	write_cmos_sensor(0x0123,0x4f);
-	write_cmos_sensor(0x0124,0x00);
-	write_cmos_sensor(0x011f,0x01);
-	write_cmos_sensor(0x030E,0x01);
-	write_cmos_sensor(0x0202,0x03);
-	write_cmos_sensor(0x0203,0xcc);
-	write_cmos_sensor(0x0301,0x05);
-	write_cmos_sensor(0x0303,0x01);
-	write_cmos_sensor(0x0304,0x03);
-	write_cmos_sensor(0x0305,0x06);
-	write_cmos_sensor(0x0306,0x00);
-	write_cmos_sensor(0x0307,0x51);
-	write_cmos_sensor(0x0309,0x0A);
-	write_cmos_sensor(0x030B,0x01);
-	write_cmos_sensor(0x030C,0x00);
-	write_cmos_sensor(0x030D,0x72);
-	write_cmos_sensor(0x0160,((imgsensor_info.pre.framelength >> 8) & 0xFF));  
-	write_cmos_sensor(0x0161,(imgsensor_info.pre.framelength & 0xFF));	       
-	write_cmos_sensor(0x0162,((imgsensor_info.pre.linelength >> 8) & 0xFF));   
-	write_cmos_sensor(0x0163,(imgsensor_info.pre.linelength & 0xFF));	         
-	write_cmos_sensor(0x0164,0x00);
-	write_cmos_sensor(0x0165,0x00);
-	write_cmos_sensor(0x0166,0x0c);
-	write_cmos_sensor(0x0167,0xd7);
-	write_cmos_sensor(0x0168,0x00);
-	write_cmos_sensor(0x0169,0x00);
-	write_cmos_sensor(0x016A,0x09);
-	write_cmos_sensor(0x016B,0xa7);
-	write_cmos_sensor(0x016C,0x0c);
-	write_cmos_sensor(0x016D,0xd0);
-	write_cmos_sensor(0x016E,0x09);
-	write_cmos_sensor(0x016F,0xa0);
-	write_cmos_sensor(0x0170,0x01);
-	write_cmos_sensor(0x0171,0x01);
-	//write_cmos_sensor(0x0172,0x03);
-	write_cmos_sensor(0x0174,0x01);
-	write_cmos_sensor(0x0175,0x00);
-	write_cmos_sensor(0x018C,0x0a);
-	write_cmos_sensor(0x018D,0x0a);
-	write_cmos_sensor(0x455E,0x00);
-	write_cmos_sensor(0x471E,0x4B);
-	write_cmos_sensor(0x4767,0x0F);
-	write_cmos_sensor(0x4750,0x14);
-	write_cmos_sensor(0x4540,0x00);
-	write_cmos_sensor(0x47B4,0x14);
-	write_cmos_sensor(0x4713,0x30);
-	write_cmos_sensor(0x478B,0x10);
-	write_cmos_sensor(0x478F,0x10);
-	write_cmos_sensor(0x4793,0x10);
-	write_cmos_sensor(0x4797,0x0E);
-	write_cmos_sensor(0x479B,0x0E);
-	write_cmos_sensor(0x0104,0x00);
-	write_cmos_sensor(0x0100,0x01);
-	//@@video_720p_30fps_800Mbps
+	LOG_INF("[IMX175MIPI]enter VideoFullSizeSetting function\n");
+	write_cmos_sensor(0x41C0, 0x01); 		
+	write_cmos_sensor(0x0100, 0x00); 		 
+	write_cmos_sensor(0x0101, 0x00);//mirror bit[0] hor.bit[1] ver.	
+	write_cmos_sensor(0x030E, 0x0C); 		 
+	write_cmos_sensor(0x0202, 0x06);
+	write_cmos_sensor(0x0203, 0x8A);
+	//PLLsetting
+	write_cmos_sensor(0x0301, 0x0A); 		 
+	write_cmos_sensor(0x0303, 0x01); 		 
+	write_cmos_sensor(0x0305, 0x06); 		 
+	write_cmos_sensor(0x0309, 0x0A); 		 
+	write_cmos_sensor(0x030B, 0x01); 		 
+	write_cmos_sensor(0x030C, 0x00);
+	write_cmos_sensor(0x030D, 0xDD);
+	write_cmos_sensor(0x030E, 0x01); 
 	
-	if (imgsensor.ihdr_en) {
-	} else {
-	}
+	write_cmos_sensor(0x0340, 0x06);
+	write_cmos_sensor(0x0341, 0x8E); 		 
+	write_cmos_sensor(0x0342, 0x0D); 		 
+	write_cmos_sensor(0x0343, 0x70); 		 
+	write_cmos_sensor(0x0344, 0x00); 		 
+	write_cmos_sensor(0x0345, 0x00); 		 
+	write_cmos_sensor(0x0346, 0x01); 		 
+	write_cmos_sensor(0x0347, 0x90); 		 
+	write_cmos_sensor(0x0348, 0x0C); 		 
+	write_cmos_sensor(0x0349, 0xCF); 		 
+	write_cmos_sensor(0x034A, 0x08); 		 
+	write_cmos_sensor(0x034B, 0x0F); 		 
+	write_cmos_sensor(0x034C, 0x0C); 		 
+	write_cmos_sensor(0x034D, 0xD0); 		 
+	write_cmos_sensor(0x034E, 0x06); 		
+	write_cmos_sensor(0x034F, 0x80); 		 
+	write_cmos_sensor(0x0383, 0x01); 		 
+	write_cmos_sensor(0x0387, 0x01); 		 
+	write_cmos_sensor(0x0390, 0x00); 		 
+	write_cmos_sensor(0x0401, 0x00); 		 
+	write_cmos_sensor(0x0405, 0x10); 		 
+	write_cmos_sensor(0x3020, 0x10); 		 
+	write_cmos_sensor(0x3041, 0x15); 		 
+	write_cmos_sensor(0x3042, 0x87); 		 
+	write_cmos_sensor(0x3089, 0x4F); 		 
+	write_cmos_sensor(0x3309, 0x9A); 		 
+	write_cmos_sensor(0x3344, 0x6F); 		 
+	write_cmos_sensor(0x3345, 0x1F); 		 
+	write_cmos_sensor(0x3362, 0x0A); 		 
+	write_cmos_sensor(0x3363, 0x0A); 		 
+	write_cmos_sensor(0x3364, 0x02); 		 
+	write_cmos_sensor(0x3368, 0x18); 		 
+	write_cmos_sensor(0x3369, 0x00); 		 
+	write_cmos_sensor(0x3370, 0x7F); 		
+	write_cmos_sensor(0x3371, 0x37); 		 
+	write_cmos_sensor(0x3372, 0x67); 		 
+	write_cmos_sensor(0x3373, 0x3F); 		 
+	write_cmos_sensor(0x3374, 0x3F); 		
+	write_cmos_sensor(0x3375, 0x47); 		 
+	write_cmos_sensor(0x3376, 0xCF); 		 
+	write_cmos_sensor(0x3377, 0x47); 		 
+	write_cmos_sensor(0x33C8, 0x00); 		 
+	write_cmos_sensor(0x33D4, 0x0C); 		 
+	write_cmos_sensor(0x33D5, 0xD0); 		 
+	write_cmos_sensor(0x33D6, 0x06); 		 
+	write_cmos_sensor(0x33D7, 0x80); 		 
+	write_cmos_sensor(0x4100, 0x0E); 		 
+	write_cmos_sensor(0x4108, 0x01); 		 
+	write_cmos_sensor(0x4109, 0x7C);  
+	write_cmos_sensor(0x0100, 0x01);//STREAM ON
+	LOG_INF("[IMX175MIPI]exit VideoFullSizeSetting function\n"); 
 }
-//
-static kal_uint8  test_pattern_flag=0;
 
 static kal_uint32 set_test_pattern_mode(kal_bool enable)
 {
-	LOG_INF("enable: %d\n", enable);
-	if(imgsensor.current_scenario_id != MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG)
-	   {
-		   if(enable) 
-		   {   
-			   //1640 x 1232
-			   // enable color bar
-			   test_pattern_flag=TRUE;
-			   write_cmos_sensor(0x0600, 0x00); 
-			   write_cmos_sensor(0x0601, 0x02); 	 
-			   write_cmos_sensor(0x0624, 0x06); //W:3280---h
-			   write_cmos_sensor(0x0625, 0x68); //		  l
-			   write_cmos_sensor(0x0626, 0x04); //H:2464   h
-			   write_cmos_sensor(0x0627, 0xd0); //		  l
-			   write_cmos_sensor(0x6128, 0x00); 
-			   write_cmos_sensor(0x6129, 0x02); 		 
-			   write_cmos_sensor(0x613C, 0x06); //W 		h
-			   write_cmos_sensor(0x613D, 0x68); //		   l
-			   write_cmos_sensor(0x613E, 0x04); //H 		h
-			   write_cmos_sensor(0x613F, 0xd0); //			   l
-			   write_cmos_sensor(0x6506, 0x00); 
-			   write_cmos_sensor(0x6507, 0x00);
-	
-		   } 
-		   else 
-		   {   
-			   //1640 x 1232
-			   test_pattern_flag=FALSE;
-			   write_cmos_sensor(0x0600, 0x00); 
-			   write_cmos_sensor(0x0601, 0x00); 	 
-			   write_cmos_sensor(0x0624, 0x06); //W:3280---h
-			   write_cmos_sensor(0x0625, 0x68); //		  l
-			   write_cmos_sensor(0x0626, 0x04); //H:2464   h
-			   write_cmos_sensor(0x0627, 0xd0); //		  l
-			   write_cmos_sensor(0x6128, 0x00); 
-			   write_cmos_sensor(0x6129, 0x02); 		 
-			   write_cmos_sensor(0x613C, 0x06); //W 		h
-			   write_cmos_sensor(0x613D, 0x68); //		   l
-			   write_cmos_sensor(0x613E, 0x04); //H 		h
-			   write_cmos_sensor(0x613F, 0xd0); //			   l
-			   write_cmos_sensor(0x6506, 0x00); 
-			   write_cmos_sensor(0x6507, 0x00);
-	
-		   }
-	   }
-	   else
-	   {
-		   if(enable) 
-		   {   
-			   //3280 x 2464
-			   // enable color bar
-			   test_pattern_flag=TRUE;
-			   write_cmos_sensor(0x0600, 0x00); 
-			   write_cmos_sensor(0x0601, 0x02); 	 
-			   write_cmos_sensor(0x0624, 0x0C); //W:3280---h
-			   write_cmos_sensor(0x0625, 0xD0); //		  l
-			   write_cmos_sensor(0x0626, 0x09); //H:2464   h
-			   write_cmos_sensor(0x0627, 0xA0); //		  l
-			   write_cmos_sensor(0x6128, 0x00); 
-			   write_cmos_sensor(0x6129, 0x02); 		 
-			   write_cmos_sensor(0x613C, 0x0C); //W 		h
-			   write_cmos_sensor(0x613D, 0xD0); //		   l
-			   write_cmos_sensor(0x613E, 0x09); //H 		h
-			   write_cmos_sensor(0x613F, 0xA0); //			   l
-			   write_cmos_sensor(0x6506, 0x00); 
-			   write_cmos_sensor(0x6507, 0x00);
-	
-		   } 
-		   else 
-		   {   
-			   test_pattern_flag=FALSE;
-			   write_cmos_sensor(0x0600, 0x00); 
-			   write_cmos_sensor(0x0601, 0x02); 	 
-			   write_cmos_sensor(0x0624, 0x0C); //W:3280---h
-			   write_cmos_sensor(0x0625, 0xD0); //		  l
-			   write_cmos_sensor(0x0626, 0x09); //H:2464   h
-			   write_cmos_sensor(0x0627, 0xA0); //		  l
-			   write_cmos_sensor(0x6128, 0x00); 
-			   write_cmos_sensor(0x6129, 0x02); 		 
-			   write_cmos_sensor(0x613C, 0x0C); //W 		h
-			   write_cmos_sensor(0x613D, 0xD0); //		   l
-			   write_cmos_sensor(0x613E, 0x09); //H 		h
-			   write_cmos_sensor(0x613F, 0xA0); //			   l
-			   write_cmos_sensor(0x6506, 0x00); 
-			   write_cmos_sensor(0x6507, 0x00);
-	
-	
-		   }
-	   }
-		   
-	   return ERROR_NONE;
-
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.test_pattern = enable;
-	spin_unlock(&imgsensor_drv_lock);
-	return ERROR_NONE;
+    LOG_INF("enable: %d\n", enable);
+    if(enable) 
+	{   // enable color bar
+		//test_pattern_flag=TRUE;
+        write_cmos_sensor(0x30D8, 0x10);  // color bar test pattern
+        write_cmos_sensor(0x0600, 0x00);  // color bar test pattern
+        write_cmos_sensor(0x0601, 0x02);  // color bar test pattern 
+    } 
+	else 
+	{   
+		//test_pattern_flag=FALSE;
+        write_cmos_sensor(0x30D8, 0x00);  // disable color bar test pattern
+    }
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.test_pattern = enable;
+    spin_unlock(&imgsensor_drv_lock);
+	LOG_INF("[IMX175MIPI] exit IMX175MIPISetTestPatternMode function \n");
+    return ERROR_NONE;
 }
 
 /*************************************************************************
@@ -1230,16 +1052,15 @@ static kal_uint32 set_test_pattern_mode(kal_bool enable)
 static kal_uint32 get_imgsensor_id(UINT32 *sensor_id) 
 {
 	kal_uint8 i = 0;
-	kal_uint8 retry = 1;
+	kal_uint8 retry = 2;
 	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
 	while (imgsensor_info.i2c_addr_table[i] != 0xff) {
 		spin_lock(&imgsensor_drv_lock);
 		imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
 		spin_unlock(&imgsensor_drv_lock);
 		do {
-			*sensor_id = return_sensor_id();
-			if (*sensor_id == imgsensor_info.sensor_id) 
-            {				
+            *sensor_id = return_sensor_id();
+			if (*sensor_id == imgsensor_info.sensor_id) {				
 				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);	  
 				return ERROR_NONE;
 			}	
@@ -1247,7 +1068,7 @@ static kal_uint32 get_imgsensor_id(UINT32 *sensor_id)
 			retry--;
 		} while(retry > 0);
 		i++;
-		retry = 1;
+		retry = 2;
 	}
 	if (*sensor_id != imgsensor_info.sensor_id) {
 		// if Sensor ID is not correct, Must set *sensor_id to 0xFFFFFFFF 
@@ -1276,23 +1097,25 @@ static kal_uint32 get_imgsensor_id(UINT32 *sensor_id)
 *************************************************************************/
 static kal_uint32 open(void)
 {
+	//const kal_uint8 i2c_addr[] = {IMGSENSOR_WRITE_ID_1, IMGSENSOR_WRITE_ID_2};
 	kal_uint8 i = 0;
 	kal_uint8 retry = 2;
 	kal_uint32 sensor_id = 0; 
-	LOG_1;
+	LOG_1;	
 	LOG_2;
+	
 	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
 	while (imgsensor_info.i2c_addr_table[i] != 0xff) {
 		spin_lock(&imgsensor_drv_lock);
 		imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
 		spin_unlock(&imgsensor_drv_lock);
 		do {
-			sensor_id = return_sensor_id();
+            sensor_id = return_sensor_id();
 			if (sensor_id == imgsensor_info.sensor_id) {				
 				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);	  
 				break;
 			}	
-			LOG_INF("Read sensor id fail, i2c write id: 0x%x,sensor id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
+			LOG_INF("Read sensor id fail, id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
 			retry--;
 		} while(retry > 0);
 		i++;
@@ -1304,10 +1127,8 @@ static kal_uint32 open(void)
 		return ERROR_SENSOR_CONNECT_FAIL;
 	
 	/* initail sequence write in  */
-	sensor_init();
-	
-	iPreGain = 0;
-	
+	//
+
 	spin_lock(&imgsensor_drv_lock);
 
 	imgsensor.autoflicker_en= KAL_FALSE;
@@ -1318,7 +1139,7 @@ static kal_uint32 open(void)
 	imgsensor.min_frame_length = imgsensor_info.pre.framelength;
 	imgsensor.dummy_pixel = 0;
 	imgsensor.dummy_line = 0;
-	imgsensor.ihdr_en = 0;
+	imgsensor.ihdr_en = KAL_FALSE;
 	imgsensor.test_pattern = KAL_FALSE;
 	imgsensor.current_fps = imgsensor_info.pre.max_framerate;
 	spin_unlock(&imgsensor_drv_lock);
@@ -1386,6 +1207,11 @@ static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 	imgsensor.autoflicker_en = KAL_FALSE;
 	spin_unlock(&imgsensor_drv_lock);
 	preview_setting();
+#if defined(BIRD_IMX175_HV_MIRROR)   
+	set_mirror_flip(IMAGE_HV_MIRROR);
+#else	
+	set_mirror_flip(IMAGE_NORMAL);
+#endif
 	return ERROR_NONE;
 }	/*	preview   */
 
@@ -1405,38 +1231,44 @@ static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 *
 *************************************************************************/
 static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-						  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+                          MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
 {
-	LOG_INF("E\n");
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.sensor_mode = IMGSENSOR_MODE_CAPTURE;
-	if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {//PIP capture: 24fps for less than 13M, 20fps for 16M,15fps for 20M
-		imgsensor.pclk = imgsensor_info.cap1.pclk;
-		imgsensor.line_length = imgsensor_info.cap1.linelength;
-		imgsensor.frame_length = imgsensor_info.cap1.framelength;  
-		imgsensor.min_frame_length = imgsensor_info.cap1.framelength;
-		imgsensor.autoflicker_en = KAL_FALSE;
-	} else {
-		if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
-			LOG_INF("Warning: current_fps %d fps is not support, so use cap1's setting: %d fps!\n",imgsensor_info.cap1.max_framerate/10);
-		imgsensor.pclk = imgsensor_info.cap.pclk;
-		imgsensor.line_length = imgsensor_info.cap.linelength;
-		imgsensor.frame_length = imgsensor_info.cap.framelength;  
-		imgsensor.min_frame_length = imgsensor_info.cap.framelength;
-		imgsensor.autoflicker_en = KAL_FALSE;
-	}
-
-	spin_unlock(&imgsensor_drv_lock);
-
-	capture_setting(imgsensor.current_fps); 
+    LOG_INF("E\n");
 	
-	if(test_pattern_flag)
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_CAPTURE;
+    if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {//PIP capture: 24fps for less than 13M, 20fps for 16M,15fps for 20M
+        imgsensor.pclk = imgsensor_info.cap1.pclk;
+        imgsensor.line_length = imgsensor_info.cap1.linelength;
+        imgsensor.frame_length = imgsensor_info.cap1.framelength;
+        imgsensor.min_frame_length = imgsensor_info.cap1.framelength;
+        imgsensor.autoflicker_en = KAL_FALSE;
+    } else {
+        if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
+            LOG_INF("Warning: current_fps %d fps is not support, so use cap's setting: %d fps!\n",imgsensor.current_fps,imgsensor_info.cap.max_framerate/10);
+        imgsensor.pclk = imgsensor_info.cap.pclk;
+        imgsensor.line_length = imgsensor_info.cap.linelength;
+        imgsensor.frame_length = imgsensor_info.cap.framelength;
+        imgsensor.min_frame_length = imgsensor_info.cap.framelength;
+        imgsensor.autoflicker_en = KAL_FALSE;
+    }
+    spin_unlock(&imgsensor_drv_lock);
+    capture_setting(imgsensor.current_fps);
+	if(imgsensor.test_pattern == KAL_TRUE)
 	{
 		set_test_pattern_mode(TRUE);
-		test_pattern_flag=FALSE;
+		spin_lock(&imgsensor_drv_lock);
+		imgsensor.test_pattern = KAL_FALSE;
+		spin_unlock(&imgsensor_drv_lock);
 	}
-	return ERROR_NONE;
-}	/* capture() */
+
+#if defined(BIRD_IMX175_HV_MIRROR)   
+		set_mirror_flip(IMAGE_HV_MIRROR);
+#else	
+		set_mirror_flip(IMAGE_NORMAL);
+#endif
+    return ERROR_NONE;
+}    /* capture() */
 static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
 {
@@ -1452,7 +1284,11 @@ static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 	imgsensor.autoflicker_en = KAL_FALSE;
 	spin_unlock(&imgsensor_drv_lock);
 	normal_video_setting(imgsensor.current_fps);
-	
+#if defined(BIRD_IMX175_HV_MIRROR)   
+		set_mirror_flip(IMAGE_HV_MIRROR);
+#else	
+		set_mirror_flip(IMAGE_NORMAL);
+#endif
 	
 	return ERROR_NONE;
 }	/*	normal_video   */
@@ -1471,10 +1307,15 @@ static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 	imgsensor.min_frame_length = imgsensor_info.hs_video.framelength;
 	imgsensor.dummy_line = 0;
 	imgsensor.dummy_pixel = 0;
+	//imgsensor.current_fps = 300;
 	imgsensor.autoflicker_en = KAL_FALSE;
 	spin_unlock(&imgsensor_drv_lock);
 	hs_video_setting();
-	
+#if defined(BIRD_IMX175_HV_MIRROR)   
+		set_mirror_flip(IMAGE_HV_MIRROR);
+#else	
+		set_mirror_flip(IMAGE_NORMAL);
+#endif
 	return ERROR_NONE;
 }	/*	hs_video   */
 
@@ -1486,14 +1327,23 @@ static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 	spin_lock(&imgsensor_drv_lock);
 	imgsensor.sensor_mode = IMGSENSOR_MODE_SLIM_VIDEO;
 	imgsensor.pclk = imgsensor_info.slim_video.pclk;
+	//imgsensor.video_mode = KAL_TRUE;
 	imgsensor.line_length = imgsensor_info.slim_video.linelength;
 	imgsensor.frame_length = imgsensor_info.slim_video.framelength; 
 	imgsensor.min_frame_length = imgsensor_info.slim_video.framelength;
 	imgsensor.dummy_line = 0;
 	imgsensor.dummy_pixel = 0;
+	//imgsensor.current_fps = 300;
 	imgsensor.autoflicker_en = KAL_FALSE;
 	spin_unlock(&imgsensor_drv_lock);
 	slim_video_setting();
+
+#if defined(BIRD_IMX175_HV_MIRROR)   
+		set_mirror_flip(IMAGE_HV_MIRROR);
+#else	
+		set_mirror_flip(IMAGE_NORMAL);
+#endif
+
 	
 	return ERROR_NONE;
 }	/*	slim_video	 */
@@ -1536,7 +1386,7 @@ static kal_uint32 get_info(MSDK_SCENARIO_ID_ENUM scenario_id,
 	sensor_info->SensorClockFallingPolarity = SENSOR_CLOCK_POLARITY_LOW; /* not use */
 	sensor_info->SensorHsyncPolarity = SENSOR_CLOCK_POLARITY_LOW; // inverse with datasheet
 	sensor_info->SensorVsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
-	sensor_info->SensorInterruptDelayLines = 4; /* not use */
+	sensor_info->SensorInterruptDelayLines = 1; /* not use */
 	sensor_info->SensorResetActiveHigh = FALSE; /* not use */
 	sensor_info->SensorResetDelayCount = 5; /* not use */
 
@@ -1563,7 +1413,7 @@ static kal_uint32 get_info(MSDK_SCENARIO_ID_ENUM scenario_id,
 	
 	sensor_info->SensorMIPILaneNumber = imgsensor_info.mipi_lane_num; 
 	sensor_info->SensorClockFreq = imgsensor_info.mclk;
-	sensor_info->SensorClockDividCount = 3; /* not use */
+	sensor_info->SensorClockDividCount = 5; /* not use */
 	sensor_info->SensorClockRisingCount = 0;
 	sensor_info->SensorClockFallingCount = 2; /* not use */
 	sensor_info->SensorPixelClockCount = 3; /* not use */
@@ -1673,7 +1523,6 @@ static kal_uint32 set_video_mode(UINT16 framerate)
 		imgsensor.current_fps = framerate;
 	spin_unlock(&imgsensor_drv_lock);
 	set_max_framerate(imgsensor.current_fps,1);
-
 	return ERROR_NONE;
 }
 
@@ -1692,39 +1541,49 @@ static kal_uint32 set_auto_flicker_mode(kal_bool enable, UINT16 framerate)
 
 static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 framerate) 
 {
-	kal_uint32 frame_length;
-  
+	kal_uint32 frame_length; 
 	LOG_INF("scenario_id = %d, framerate = %d\n", scenario_id, framerate);
 
 	switch (scenario_id) {
 		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
 			frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
 			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
+			imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength):0;
 			imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
 			imgsensor.min_frame_length = imgsensor.frame_length;
 			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();			
+			//set_dummy();			
 			break;			
 		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
 			if(framerate == 0)
 				return ERROR_NONE;
 			frame_length = imgsensor_info.normal_video.pclk / framerate * 10 / imgsensor_info.normal_video.linelength;
 			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.normal_video.framelength) ? (frame_length - imgsensor_info.normal_video.framelength) : 0;			
+			imgsensor.dummy_line = (frame_length > imgsensor_info.normal_video.framelength) ? (frame_length - imgsensor_info.normal_video.framelength):0;			
 			imgsensor.frame_length = imgsensor_info.normal_video.framelength + imgsensor.dummy_line;
 			imgsensor.min_frame_length = imgsensor.frame_length;
 			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();			
+			//set_dummy();			
 			break;
-		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:		
-			frame_length = imgsensor_info.cap.pclk / framerate * 10 / imgsensor_info.cap.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.cap.framelength) ? (frame_length - imgsensor_info.cap.framelength) : 0;
-			imgsensor.frame_length = imgsensor_info.cap.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();			
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+        	  if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {
+                frame_length = imgsensor_info.cap1.pclk / framerate * 10 / imgsensor_info.cap1.linelength;
+                spin_lock(&imgsensor_drv_lock);
+		            imgsensor.dummy_line = (frame_length > imgsensor_info.cap1.framelength) ? (frame_length - imgsensor_info.cap1.framelength) : 0;
+		            imgsensor.frame_length = imgsensor_info.cap1.framelength + imgsensor.dummy_line;
+		            imgsensor.min_frame_length = imgsensor.frame_length;
+		            spin_unlock(&imgsensor_drv_lock);
+            } else {
+        		    if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
+                    LOG_INF("Warning: current_fps %d fps is not support, so use cap's setting: %d fps!\n",framerate,imgsensor_info.cap.max_framerate/10);
+                frame_length = imgsensor_info.cap.pclk / framerate * 10 / imgsensor_info.cap.linelength;
+                spin_lock(&imgsensor_drv_lock);
+		            imgsensor.dummy_line = (frame_length > imgsensor_info.cap.framelength) ? (frame_length - imgsensor_info.cap.framelength) : 0;
+		            imgsensor.frame_length = imgsensor_info.cap.framelength + imgsensor.dummy_line;
+		            imgsensor.min_frame_length = imgsensor.frame_length;
+		            spin_unlock(&imgsensor_drv_lock);
+            }
+			//set_dummy();			
 			break;	
 		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
 			frame_length = imgsensor_info.hs_video.pclk / framerate * 10 / imgsensor_info.hs_video.linelength;
@@ -1733,16 +1592,16 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
 			imgsensor.frame_length = imgsensor_info.hs_video.framelength + imgsensor.dummy_line;
 			imgsensor.min_frame_length = imgsensor.frame_length;
 			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();			
+			//set_dummy();			
 			break;
 		case MSDK_SCENARIO_ID_SLIM_VIDEO:
 			frame_length = imgsensor_info.slim_video.pclk / framerate * 10 / imgsensor_info.slim_video.linelength;
 			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.slim_video.framelength) ? (frame_length - imgsensor_info.slim_video.framelength): 0;	
+			imgsensor.dummy_line = (frame_length > imgsensor_info.slim_video.framelength) ? (frame_length - imgsensor_info.slim_video.framelength): 0;
 			imgsensor.frame_length = imgsensor_info.slim_video.framelength + imgsensor.dummy_line;
 			imgsensor.min_frame_length = imgsensor.frame_length;
 			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();	
+			//set_dummy();			
 			break;		
 		default:  //coding with  preview scenario by default
 			frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
@@ -1751,7 +1610,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
 			imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
 			imgsensor.min_frame_length = imgsensor.frame_length;
 			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();	
+			//set_dummy();	
 			LOG_INF("error scenario_id = %d, we use preview scenario \n", scenario_id);
 			break;
 	}	
@@ -1783,11 +1642,9 @@ static kal_uint32 get_default_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenar
 			break;
 	}
 
-	return ERROR_NONE;
+    return ERROR_NONE;
 }
 
-
-
 static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
 							 UINT8 *feature_para,UINT32 *feature_para_len)
 {
@@ -1796,6 +1653,7 @@ static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
 	UINT32 *feature_return_para_32=(UINT32 *) feature_para;
 	UINT32 *feature_data_32=(UINT32 *) feature_para;
     unsigned long long *feature_data=(unsigned long long *) feature_para;
+    unsigned long long *feature_return_para=(unsigned long long *) feature_para;
 
 	SENSOR_WINSIZE_INFO_STRUCT *wininfo;	
 	MSDK_SENSOR_REG_INFO_STRUCT *sensor_reg_data=(MSDK_SENSOR_REG_INFO_STRUCT *) feature_para;
@@ -1878,7 +1736,7 @@ static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
 			switch (*feature_data_32) {
 				case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
 					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[1],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-					break;
+					break;	  
 				case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
 					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[2],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
 					break;
@@ -1894,8 +1752,8 @@ static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
 					break;
 			}
 		case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
-            LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",(UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
-            ihdr_write_shutter_gain((UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
+			LOG_INF("SENSOR_SET_SENSOR_IHDR is no support");
+			//LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",(UINT16)*feature_data_32,(UINT16)*(feature_data_32+1),(UINT16)*(feature_data_32+2)); 
 			break;
 		default:
 			break;
@@ -1919,4 +1777,4 @@ UINT32 IMX175_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
 	if (pfFunc!=NULL)
 		*pfFunc=&sensor_func;
 	return ERROR_NONE;
-}	/*	MIPI_RAW_SensorInit	*/
+}	/*	OV5693_MIPI_RAW_SensorInit	*/
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/imx175_mipi_raw/imx175mipiraw_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx175_mipi_raw/imx175mipiraw_Sensor.h
index 262edf1..71a840b 100644
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/imx175_mipi_raw/imx175mipiraw_Sensor.h
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx175_mipi_raw/imx175mipiraw_Sensor.h
@@ -1,20 +1,58 @@
 /*****************************************************************************
+*  Copyright Statement:
+*  --------------------
+*  This software is protected by Copyright and the information contained
+*  herein is confidential. The software may not be copied and the information
+*  contained herein may not be used or disclosed except with the written
+*  permission of MediaTek Inc. (C) 2008
+*
+*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
+*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
+*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
+*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
+*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
+*
+*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
+*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
+*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+*
+*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
+*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
+*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
+*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
+*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
+*
+*****************************************************************************/
+/*****************************************************************************
  *
  * Filename:
  * ---------
- *	 OV5693mipi_Sensor.h
+ *   imx175mipiraw_sensor.h
  *
  * Project:
  * --------
- *	 ALPS
+ *   YUSU
  *
  * Description:
  * ------------
- *	 CMOS sensor header file
+ *   Header file of Sensor driver
+ *
  *
+ * Author:
+
+ *============================================================================
  ****************************************************************************/
-#ifndef _IMX175MIPI_SENSOR_H
-#define _IMX175MIPI_SENSOR_H
+#ifndef _IMX175mipi_SENSOR_H
+#define _IMX175mipi_SENSOR_H
 
 
 typedef enum{
@@ -74,14 +112,14 @@ typedef struct imgsensor_struct {
 
 /* SENSOR PRIVATE STRUCT FOR CONSTANT*/
 typedef struct imgsensor_info_struct { 
-	kal_uint32 sensor_id;			//record sensor id defined in Kd_imgsensor.h
+    kal_uint32 sensor_id;           //record sensor id defined in Kd_imgsensor.h
 	kal_uint32 checksum_value;		//checksum value for Camera Auto Test
 	imgsensor_mode_struct pre;		//preview scenario relative information
 	imgsensor_mode_struct cap;		//capture scenario relative information
-	imgsensor_mode_struct cap1;		//capture for PIP 24fps relative information, capture1 mode must use same framelength, linelength with Capture mode for shutter calculate
+	imgsensor_mode_struct cap1;		//capture for PIP 24fps relative information
 	imgsensor_mode_struct normal_video;//normal video  scenario relative information
 	imgsensor_mode_struct hs_video;	//high speed video scenario relative information
-	imgsensor_mode_struct slim_video;	//slim video for VT scenario relative information
+    imgsensor_mode_struct slim_video;   //slim video for VT scenario relative information
 	
 	kal_uint8  ae_shut_delay_frame;	//shutter delay frame for AE cycle
 	kal_uint8  ae_sensor_gain_delay_frame;	//sensor gain delay frame for AE cycle
@@ -102,13 +140,14 @@ typedef struct imgsensor_info_struct {
 
 	kal_uint8  isp_driving_current;	//mclk driving current
 	kal_uint8  sensor_interface_type;//sensor_interface_type
-	kal_uint8  mipi_sensor_type; //0,MIPI_OPHY_NCSI2; 1,MIPI_OPHY_CSI2, default is NCSI2, don't modify this para
-	kal_uint8  mipi_settle_delay_mode; //0, high speed signal auto detect; 1, use settle delay,unit is ns, default is auto detect, don't modify this para
-	kal_uint8  sensor_output_dataformat;//sensor output first pixel color
+    kal_uint8  mipi_sensor_type; //0,MIPI_OPHY_NCSI2; 1,MIPI_OPHY_CSI2, default is NCSI2, don't modify this para
+    kal_uint8  mipi_settle_delay_mode; //0, high speed signal auto detect; 1, use settle delay,unit is ns, default is auto detect, don't modify this para
+	kal_uint8  sensor_output_dataformat;
 	kal_uint8  mclk;				//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
 	
 	kal_uint8  mipi_lane_num;		//mipi lane num
 	kal_uint8  i2c_addr_table[5];	//record sensor support all write id addr, only supprt 4must end with 0xff
+    kal_uint32  i2c_speed;     //i2c speed
 } imgsensor_info_struct;
 
 /* SENSOR READ/WRITE ID */
@@ -119,5 +158,6 @@ typedef struct imgsensor_info_struct {
 
 extern int iReadRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u8 * a_pRecvData, u16 a_sizeRecvData, u16 i2cId);
 extern int iWriteRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u16 i2cId);
+extern void kdSetI2CSpeed(u16 i2cSpeed);
 
 #endif 
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/imx179_mipi_raw/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx179_mipi_raw/Makefile
old mode 100644
new mode 100755
index a1e7c27..5e3b265
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/imx179_mipi_raw/Makefile
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx179_mipi_raw/Makefile
@@ -1,5 +1,4 @@
 include $(srctree)/drivers/misc/mediatek/Makefile.custom
-
 obj-y += imx179mipiraw_Sensor.o
 
 
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/imx179_mipi_raw/imx179mipiraw_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx179_mipi_raw/imx179mipiraw_Sensor.c
index 1c8e841..403d6e5 100644
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/imx179_mipi_raw/imx179mipiraw_Sensor.c
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx179_mipi_raw/imx179mipiraw_Sensor.c
@@ -26,7 +26,6 @@
 #include <linux/uaccess.h>
 #include <linux/fs.h>
 #include <asm/atomic.h>
-//#include <asm/system.h>
 #include <linux/xlog.h>
 
 #include "kd_camera_hw.h"
@@ -42,7 +41,7 @@
 #define LOG_1 LOG_INF("IMX179,MIPI 4LANE\n")
 #define LOG_2 LOG_INF("preview 1640*1232@30fps,256Mbps/lane; video 3280*2464@30fps,256Mbps/lane; capture 8M@30fps,256MbpsMbps/lane\n")
 /****************************   Modify end    *******************************************/
-#define LOG_INF(format, args...)	xlog_printk(ANDROID_LOG_INFO   , PFX, "[%s] " format, __FUNCTION__, ##args)
+#define LOG_INF(format, args...)	pr_debug(PFX "[%s] " format, __FUNCTION__, ##args)
 
 static DEFINE_SPINLOCK(imgsensor_drv_lock);
 static kal_uint8  test_pattern_flag=0;
@@ -53,56 +52,56 @@ static kal_uint8  test_pattern_flag=0;
 static imgsensor_info_struct imgsensor_info = { 
 	.sensor_id = IMX179_SENSOR_ID,
 	
-	.checksum_value = 0xaf072507,
+	.checksum_value = 0x1ec5153d,
 	
 	.pre = {
-		.pclk = 256000000,				//record different mode's pclk
+		.pclk = 176800000,				//record different mode's pclk
 		.linelength = 3440,				//record different mode's linelength
-		.framelength = 2481,			//record different mode's framelength
-		.startx = 0,					//record different mode's startx of grabwindow
-		.starty = 0,					//record different mode's starty of grabwindow
-		.grabwindow_width = 1640,		//record different mode's width of grabwindow
-		.grabwindow_height = 1232,		//record different mode's height of grabwindow
+		.framelength = 1678,			//record different mode's framelength
+		.startx = 2,					//record different mode's startx of grabwindow
+		.starty = 2,					//record different mode's starty of grabwindow
+		.grabwindow_width = 1632,		//record different mode's width of grabwindow
+		.grabwindow_height = 1224,		//record different mode's height of grabwindow
 		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
 		.mipi_data_lp2hs_settle_dc = 85,
 		/*	 following for GetDefaultFramerateByScenario()	*/
 		.max_framerate = 300,	
 	},
 	.cap = {
-		.pclk = 256000000,
+		.pclk = 176800000,
 		.linelength = 3440,
-		.framelength = 2481,
-		.startx = 0,
-		.starty = 0,
-		.grabwindow_width = 3280,
-		.grabwindow_height = 2464,
+		.framelength = 2478,
+		.startx = 4,
+		.starty = 4,
+		.grabwindow_width = 3264,
+		.grabwindow_height = 2448,
 		.mipi_data_lp2hs_settle_dc = 85,
-		.max_framerate = 300,
+		.max_framerate = 200,
 	},
 	.cap1 = {
-		.pclk = 204800000,
+		.pclk = 176800000,
 		.linelength = 3440,
-		.framelength = 2481,
-		.startx = 0,
-		.starty = 0,
-		.grabwindow_width = 3280,
-		.grabwindow_height = 2464,
+		.framelength = 2478,
+		.startx = 4,
+		.starty = 4,
+		.grabwindow_width = 3264,
+		.grabwindow_height = 2448,
 		.mipi_data_lp2hs_settle_dc = 85,
-		.max_framerate = 240,	
+		.max_framerate = 200,	
 	},
 	.normal_video = {
-		.pclk = 256000000,
+		.pclk = 176800000,
 		.linelength = 3440,
-		.framelength = 2481,
-		.startx = 0,
-		.starty = 0,
-		.grabwindow_width = 3280,
-		.grabwindow_height = 2464,
+		.framelength = 1713,
+		.startx = 2,
+		.starty = 2,
+		.grabwindow_width = 3264,
+		.grabwindow_height = 1600,
 		.mipi_data_lp2hs_settle_dc = 85,
 		.max_framerate = 300,
 	},
 	.hs_video = {
-		.pclk = 256000000,
+		.pclk = 176800000,
 		.linelength = 3440,
 		.framelength = 620,
 		.startx = 0,
@@ -113,7 +112,7 @@ static imgsensor_info_struct imgsensor_info = {
         .max_framerate = 1200,
 	},
 	.slim_video = {
-		.pclk = 160000000,
+		.pclk = 176800000,
 		.linelength = 3440,
 		.framelength = 1550,
 		.startx = 0,
@@ -123,6 +122,7 @@ static imgsensor_info_struct imgsensor_info = {
 		.mipi_data_lp2hs_settle_dc = 85,
 		.max_framerate = 300,
 	},
+
     .custom1 = {
         .pclk = 256000000,				//record different mode's pclk
 		.linelength = 3440,				//record different mode's linelength
@@ -191,6 +191,7 @@ static imgsensor_info_struct imgsensor_info = {
 		/*	 following for GetDefaultFramerateByScenario()	*/
 		.max_framerate = 300,	
     },
+    
 	.margin = 4,
 	.min_shutter = 1,
 	.max_frame_length = 0x7fff,
@@ -206,26 +207,28 @@ static imgsensor_info_struct imgsensor_info = {
 	.video_delay_frame = 3,
 	.hs_video_delay_frame = 3,
 	.slim_video_delay_frame = 3,
+
     .custom1_delay_frame = 2,
     .custom2_delay_frame = 2, 
     .custom3_delay_frame = 2, 
     .custom4_delay_frame = 2, 
     .custom5_delay_frame = 2,
+
 	
 	.isp_driving_current = ISP_DRIVING_6MA,
 	.sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,
 	.mipi_sensor_type = MIPI_OPHY_NCSI2, //0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2 
     .mipi_settle_delay_mode = MIPI_SETTLEDELAY_AUTO,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
-	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_R,//B
+	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_R,
 	.mclk = 24,
-	.mipi_lane_num = SENSOR_MIPI_4_LANE,
+	.mipi_lane_num = SENSOR_MIPI_2_LANE,
 	.i2c_addr_table = {0x20, 0xff},
     .i2c_speed = 300, // i2c read/write speed
 };
 
 
 static imgsensor_struct imgsensor = {
-	.mirror = IMAGE_NORMAL,   //IMAGE_NORMAL				//mirrorflip information
+	.mirror = IMAGE_NORMAL,				//mirrorflip information
 	.sensor_mode = IMGSENSOR_MODE_INIT, //IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
 	.shutter = 0x09AD,					//current shutter
 	.gain = 222,						//current gain
@@ -236,16 +239,16 @@ static imgsensor_struct imgsensor = {
 	.test_pattern = KAL_FALSE,		//test pattern mode or not. KAL_FALSE for in test pattern mode, KAL_TRUE for normal output
 	.current_scenario_id = MSDK_SCENARIO_ID_CAMERA_PREVIEW,//current scenario id
 	.ihdr_en = 0, //sensor need support LE, SE with HDR feature
-	.i2c_write_id = 0x6c,
+	.i2c_write_id = 0x20,
 };
 
 
 /* Sensor output window information */
-static SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[10] =	 
-{{ 3280, 2464,	 0,	0, 3280, 2464, 1640,  1232, 0000, 0000, 1640, 1232,	  0,	0, 1640,  1232}, // Preview 
- { 3280, 2464,	 0,	0, 3280, 2464, 3280,  2464, 0000, 0000, 3280, 2464,	  0,	0, 3280,  2464}, // capture 
- { 3280, 2464,	 0,	0, 3280, 2464, 3280,  2464, 0000, 0000, 3280, 2464,	  0,	0, 3280,  2464}, // video 
- { 3280, 2464,	 0, 0, 3280, 2464,  640,   480, 0000, 0000, 640,  480,	  0,	0, 640,   480}, //hight speed video 
+static SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[5] =	 
+{{ 3280, 2464,	 0,	0, 3280, 2464, 1640,  1232, 0000, 0000, 1640, 1232,	  2,	2, 1632,  1224}, // Preview 
+ { 3280, 2464,	 0,	0, 3280, 2464, 3280,  2464, 0000, 0000, 3280, 2464,	  4,	4, 3264, 2448}, // capture 
+ { 3280, 2464,	 0,	0, 3280, 2464, 3280,  2464, 0000, 0000, 3280, 1616,	  2,	2, 3264,  1600}, // video 
+ { 3280, 2464,	 0, 0, 3280, 2464, 640,   480,   0000, 0000, 640,  480,	  0,	0, 640,   480}, //hight speed video 
  { 3280, 2464,	 0, 0, 3280, 2464, 1288,  800,  0000, 0000, 1288,  800,	  2,	2, 1080,  720},// slim video 
  { 3280, 2464,	 0,	0, 3280, 2464, 1640,  1232, 0000, 0000, 1640, 1232,	  0,	0, 1640,  1232}, // Custom1 (defaultuse preview) 
  { 3280, 2464,	 0,	0, 3280, 2464, 1640,  1232, 0000, 0000, 1640, 1232,	  0,	0, 1640,  1232}, // Custom2 
@@ -410,7 +413,7 @@ static void set_max_framerate(UINT16 framerate,kal_bool min_framelength_en)
 	kal_int16 dummy_line;
 	kal_uint32 frame_length = imgsensor.frame_length;
 	//unsigned long flags;
-	LOG_INF("framerate = %d, min framelength should enable? \n", framerate,min_framelength_en);   
+	LOG_INF("framerate = %d, min framelength should enable = %d\n", framerate,min_framelength_en);   
 	frame_length = imgsensor.pclk / framerate * 10 / imgsensor.line_length;
 	spin_lock(&imgsensor_drv_lock);
 	imgsensor.frame_length = (frame_length > imgsensor.min_frame_length)?frame_length:imgsensor.min_frame_length;
@@ -487,7 +490,7 @@ static void set_shutter(kal_uint16 shutter)
 		write_cmos_sensor_8(0x0104, 0x01); 
 		write_cmos_sensor(0x0340, (imgsensor.frame_length >> 8) & 0xFF);
 		write_cmos_sensor(0x0341, imgsensor.frame_length & 0xFF);
-
+		write_cmos_sensor_8(0x0104, 0x00); 
 
         }
     } else {
@@ -495,12 +498,12 @@ static void set_shutter(kal_uint16 shutter)
 		write_cmos_sensor_8(0x0104, 0x01); 
 		write_cmos_sensor(0x0340, (imgsensor.frame_length >> 8) & 0xFF);
 		write_cmos_sensor(0x0341, imgsensor.frame_length & 0xFF);
-
+		write_cmos_sensor_8(0x0104, 0x00); 
 
     }
 
     // Update Shutter
-
+	write_cmos_sensor_8(0x0104, 0x01); 
 	write_cmos_sensor(0x0202, (shutter >> 8) & 0xFF);
 	write_cmos_sensor(0x0203, shutter  & 0xFF);	
 	write_cmos_sensor_8(0x0104, 0x00); 
@@ -513,7 +516,7 @@ static void set_shutter(kal_uint16 shutter)
 static kal_uint16 gain2reg(const kal_uint16 gain)
 {
     kal_uint8 iI;	    
-    for (iI = 0; iI < (MaxGainIndex-1); iI++) 
+    for (iI = 0; iI < (sensorGainMapping-1); iI++) 
 	{
         if(gain <= sensorGainMapping[iI][0])
 		{    
@@ -570,6 +573,7 @@ static kal_uint16 set_gain(kal_uint16 gain)
 	spin_unlock(&imgsensor_drv_lock);
 	LOG_INF("gain = %d , reg_gain = 0x%x\n ", gain, reg_gain);
 	write_cmos_sensor_8(0x0104, 0x01); 
+	write_cmos_sensor(0x0204, (reg_gain>>8)& 0xFF);
 	write_cmos_sensor(0x0205, reg_gain & 0xFF);
 	write_cmos_sensor_8(0x0104, 0x00); 	
 	return gain;
@@ -668,72 +672,71 @@ static void sensor_init(void)
 	LOG_INF("E\n");
 	write_cmos_sensor(0x41C0, 0x01);
 	write_cmos_sensor(0x0104, 0x01);//group
-	write_cmos_sensor(0x0100, 0x00);//STREAM OFF    
+	write_cmos_sensor(0x0100, 0x00);//STREAM OFF 	
 	write_cmos_sensor(0x0103, 0x01);//SW reset
-	//write_cmos_sensor(0x0101, 0x01); 		
-	write_cmos_sensor(0x030E, 0x01); 		  
-	write_cmos_sensor(0x0202, 0x09); //0x0202, 0x09		
-	write_cmos_sensor(0x0203, 0xcc);//(0x0203, 0xcc)
-	//PLL Setting
-	write_cmos_sensor(0x0301, 0x05); 		
-	write_cmos_sensor(0x0303, 0x01); 		
-	write_cmos_sensor(0x0305, 0x06); 		
-	write_cmos_sensor(0x0309, 0x05); 		
-	write_cmos_sensor(0x030B, 0x01); 		
-	write_cmos_sensor(0x030C, 0x00); 		
-	write_cmos_sensor(0x030D, 0xA2); //(0x030D, 0xA2)
+	write_cmos_sensor(0x0101, 0x00); 		 
+	write_cmos_sensor(0x030E, 0x01); 	   
+	write_cmos_sensor(0x0202, 0x06); 		 
+	write_cmos_sensor(0x0203, 0xAD);
+	//PLL setting
+	write_cmos_sensor(0x0301, 0x0A); 		 
+	write_cmos_sensor(0x0303, 0x01); 		 
+	write_cmos_sensor(0x0305, 0x06); 		 
+	write_cmos_sensor(0x0309, 0x0A); 		 
+	write_cmos_sensor(0x030B, 0x01); 		 
+	write_cmos_sensor(0x030C, 0x00); 		 
+	write_cmos_sensor(0x030D, 0xDD); 
 	write_cmos_sensor(0x030E, 0x01);
 
-	write_cmos_sensor(0x0340, 0x09);//(0x0340, 0x09)
-	write_cmos_sensor(0x0341, 0xD0); 		
-	write_cmos_sensor(0x0342, 0x0D); 	   
-	write_cmos_sensor(0x0343, 0x70);//(0x0343, 0x0D) 		
-	write_cmos_sensor(0x0344, 0x00); 		
-	write_cmos_sensor(0x0345, 0x00); 		
-	write_cmos_sensor(0x0346, 0x00); 		
-	write_cmos_sensor(0x0347, 0x00);// (0x0347, 0x00)		
-	write_cmos_sensor(0x0348, 0x0C); 	   
-	write_cmos_sensor(0x0349, 0xCF); 		
-	write_cmos_sensor(0x034A, 0x09);// (0x034A, 0x09)		
-	write_cmos_sensor(0x034B, 0x9F);//(0x034B, 0x9F) 		
-	write_cmos_sensor(0x034C, 0x06); 		
-	write_cmos_sensor(0x034D, 0x68); 		
-	write_cmos_sensor(0x034E, 0x04); 		
-	write_cmos_sensor(0x034F, 0xD0);//(0x034F, 0xD0) 		
-	write_cmos_sensor(0x0383, 0x01); 		
-	write_cmos_sensor(0x0387, 0x01); 	   
-	write_cmos_sensor(0x0390, 0x01); 		
-	write_cmos_sensor(0x0401, 0x00); 		
-	write_cmos_sensor(0x0405, 0x10); 		
-	write_cmos_sensor(0x3020, 0x10); 		
-	write_cmos_sensor(0x3041, 0x15); 		
-	write_cmos_sensor(0x3042, 0x87); 		
-	write_cmos_sensor(0x3089, 0x4F); 		
-	write_cmos_sensor(0x3309, 0x9A); 		
-	write_cmos_sensor(0x3344, 0x57);//(0x3344, 0x57) 		
-	write_cmos_sensor(0x3345, 0x1F); 		
-	write_cmos_sensor(0x3362, 0x0A); 		
-	write_cmos_sensor(0x3363, 0x0A); 		
-	write_cmos_sensor(0x3364, 0x00); 	   
-	write_cmos_sensor(0x3368, 0x18); 		
-	write_cmos_sensor(0x3369, 0x00); 		
-	write_cmos_sensor(0x3370, 0x77);// (0x3370, 0x77)			
-	write_cmos_sensor(0x3371, 0x2F);//(0x3371, 0x2F) 			
-	write_cmos_sensor(0x3372, 0x4F); 			
-	write_cmos_sensor(0x3373, 0x2F); 			
-	write_cmos_sensor(0x3374, 0x2F); 			
-	write_cmos_sensor(0x3375, 0x37); 			
-	write_cmos_sensor(0x3376, 0x9F); 			
-	write_cmos_sensor(0x3377, 0x37); 			
-	write_cmos_sensor(0x33C8, 0x00); 			
-	write_cmos_sensor(0x33D4, 0x06); 			
-	write_cmos_sensor(0x33D5, 0x68); 			
-	write_cmos_sensor(0x33D6, 0x04); 			
-	write_cmos_sensor(0x33D7, 0xD0); 			
-	write_cmos_sensor(0x4100, 0x0E); 			
-	write_cmos_sensor(0x4108, 0x01); 			
+	write_cmos_sensor(0x0340, 0x06);
+	write_cmos_sensor(0x0341, 0xB1); 		 
+	write_cmos_sensor(0x0342, 0x0D); 		
+	write_cmos_sensor(0x0343, 0x70); 		 
+	write_cmos_sensor(0x0344, 0x00); 		 
+	write_cmos_sensor(0x0345, 0x00); 		 
+	write_cmos_sensor(0x0346, 0x00); 		 
+	write_cmos_sensor(0x0347, 0x00); 		 
+	write_cmos_sensor(0x0348, 0x0C); 		
+	write_cmos_sensor(0x0349, 0xCF); 		 
+	write_cmos_sensor(0x034A, 0x09); 		 
+	write_cmos_sensor(0x034B, 0x9F); 		 
+	write_cmos_sensor(0x034C, 0x06); 		 
+	write_cmos_sensor(0x034D, 0x68); 		 
+	write_cmos_sensor(0x034E, 0x04); 		 
+	write_cmos_sensor(0x034F, 0xD0); 		 
+	write_cmos_sensor(0x0383, 0x01); 		 
+	write_cmos_sensor(0x0387, 0x01); 		
+	write_cmos_sensor(0x0390, 0x01); 		 
+	write_cmos_sensor(0x0401, 0x00); 		 
+	write_cmos_sensor(0x0405, 0x10); 		 
+	write_cmos_sensor(0x3020, 0x10); 		 
+	write_cmos_sensor(0x3041, 0x15); 		 
+	write_cmos_sensor(0x3042, 0x87); 		 
+	write_cmos_sensor(0x3089, 0x4F); 		 
+	write_cmos_sensor(0x3309, 0x9A); 		 
+	write_cmos_sensor(0x3344, 0x6F); 		 
+	write_cmos_sensor(0x3345, 0x1F); 		 
+	write_cmos_sensor(0x3362, 0x0A); 		 
+	write_cmos_sensor(0x3363, 0x0A); 		 
+	write_cmos_sensor(0x3364, 0x02); 	//2lane	
+	write_cmos_sensor(0x3368, 0x18); 		 
+	write_cmos_sensor(0x3369, 0x00); 		 
+	write_cmos_sensor(0x3370, 0x7F); 		 
+	write_cmos_sensor(0x3371, 0x37); 		 
+	write_cmos_sensor(0x3372, 0x67); 		 
+	write_cmos_sensor(0x3373, 0x3F); 		 
+	write_cmos_sensor(0x3374, 0x3F); 		 
+	write_cmos_sensor(0x3375, 0x47); 		 
+	write_cmos_sensor(0x3376, 0xCF); 		 
+	write_cmos_sensor(0x3377, 0x47); 		
+	write_cmos_sensor(0x33C8, 0x00); 		 
+	write_cmos_sensor(0x33D4, 0x06); 		 
+	write_cmos_sensor(0x33D5, 0x68); 		 
+	write_cmos_sensor(0x33D6, 0x04); 	   
+	write_cmos_sensor(0x33D7, 0xD0); 	  
+	write_cmos_sensor(0x4100, 0x0E); 	   
+	write_cmos_sensor(0x4108, 0x01);
 	write_cmos_sensor(0x4109, 0x7C);
-	write_cmos_sensor(0x3302, 0x01);
 	write_cmos_sensor(0x0104, 0x00);//group
 	write_cmos_sensor(0x0100, 0x01);//STREAM ON
 }	/*	sensor_init  */
@@ -745,37 +748,38 @@ static void preview_setting(void)
 	LOG_INF("E\n");
 	write_cmos_sensor(0x41C0, 0x01);
 	write_cmos_sensor(0x0104, 0x01);//group
-	write_cmos_sensor(0x0100, 0x00);//STREAM OFF 
-	//write_cmos_sensor(0x0101, 0x00); 
-	//write_cmos_sensor(0x0103, 0x01);//SW reset		 		   
-	write_cmos_sensor(0x0202, 0x09); //0x0202, 0x09		 
-	write_cmos_sensor(0x0203, 0xAD);//(0x0203, 0xcc)
+	write_cmos_sensor(0x0100, 0x00);//STREAM OFF 	
+	write_cmos_sensor(0x0103, 0x01);//SW reset
+	write_cmos_sensor(0x0101, 0x00); 		 
+	write_cmos_sensor(0x030E, 0x01); 	   
+	write_cmos_sensor(0x0202, 0x06); 		 
+	write_cmos_sensor(0x0203, 0xAD);
 	//PLL setting
-	write_cmos_sensor(0x0301, 0x05); 		 
+	write_cmos_sensor(0x0301, 0x0A); 		 
 	write_cmos_sensor(0x0303, 0x01); 		 
 	write_cmos_sensor(0x0305, 0x06); 		 
-	write_cmos_sensor(0x0309, 0x05); 		 
+	write_cmos_sensor(0x0309, 0x0A); 		 
 	write_cmos_sensor(0x030B, 0x01); 		 
 	write_cmos_sensor(0x030C, 0x00); 		 
-	write_cmos_sensor(0x030D, 0xA0); //(0x030D, 0xA2)
+	write_cmos_sensor(0x030D, 0xDD); 
 	write_cmos_sensor(0x030E, 0x01);
-	
-	write_cmos_sensor(0x0340, 0x09);//(0x0340, 0x09)
+
+	write_cmos_sensor(0x0340, 0x06);
 	write_cmos_sensor(0x0341, 0xB1); 		 
 	write_cmos_sensor(0x0342, 0x0D); 		
-	write_cmos_sensor(0x0343, 0x70);//(0x0343, 0x0D) 		 
+	write_cmos_sensor(0x0343, 0x70); 		 
 	write_cmos_sensor(0x0344, 0x00); 		 
 	write_cmos_sensor(0x0345, 0x00); 		 
 	write_cmos_sensor(0x0346, 0x00); 		 
-	write_cmos_sensor(0x0347, 0x00);// (0x0347, 0x00)		 
+	write_cmos_sensor(0x0347, 0x00); 		 
 	write_cmos_sensor(0x0348, 0x0C); 		
 	write_cmos_sensor(0x0349, 0xCF); 		 
-	write_cmos_sensor(0x034A, 0x09);// (0x034A, 0x09)		 
-	write_cmos_sensor(0x034B, 0x9F);//(0x034B, 0x9F) 		 
+	write_cmos_sensor(0x034A, 0x09); 		 
+	write_cmos_sensor(0x034B, 0x9F); 		 
 	write_cmos_sensor(0x034C, 0x06); 		 
 	write_cmos_sensor(0x034D, 0x68); 		 
 	write_cmos_sensor(0x034E, 0x04); 		 
-	write_cmos_sensor(0x034F, 0xD0);//(0x034F, 0xD0)		 
+	write_cmos_sensor(0x034F, 0xD0); 		 
 	write_cmos_sensor(0x0383, 0x01); 		 
 	write_cmos_sensor(0x0387, 0x01); 		
 	write_cmos_sensor(0x0390, 0x01); 		 
@@ -786,31 +790,31 @@ static void preview_setting(void)
 	write_cmos_sensor(0x3042, 0x87); 		 
 	write_cmos_sensor(0x3089, 0x4F); 		 
 	write_cmos_sensor(0x3309, 0x9A); 		 
-	write_cmos_sensor(0x3344, 0x57);//(0x3344, 0x57)		 
+	write_cmos_sensor(0x3344, 0x6F); 		 
 	write_cmos_sensor(0x3345, 0x1F); 		 
 	write_cmos_sensor(0x3362, 0x0A); 		 
 	write_cmos_sensor(0x3363, 0x0A); 		 
-	write_cmos_sensor(0x3364, 0x00); 		
+	write_cmos_sensor(0x3364, 0x02); 		//2lane
 	write_cmos_sensor(0x3368, 0x18); 		 
 	write_cmos_sensor(0x3369, 0x00); 		 
-	write_cmos_sensor(0x3370, 0x77);// (0x3370, 0x77)		 	 
-	write_cmos_sensor(0x3371, 0x2F);//(0x3371, 0x2F)             
-	write_cmos_sensor(0x3372, 0x4F);             
-	write_cmos_sensor(0x3373, 0x2F);             
-	write_cmos_sensor(0x3374, 0x2F);             
-	write_cmos_sensor(0x3375, 0x37);             
-	write_cmos_sensor(0x3376, 0x9F);             
-	write_cmos_sensor(0x3377, 0x37);             
-	write_cmos_sensor(0x33C8, 0x00);             
-	write_cmos_sensor(0x33D4, 0x06);             
-	write_cmos_sensor(0x33D5, 0x68);             
-	write_cmos_sensor(0x33D6, 0x04);             
-	write_cmos_sensor(0x33D7, 0xD0);             
-	write_cmos_sensor(0x4100, 0x0E);             
-	write_cmos_sensor(0x4108, 0x01);             
+	write_cmos_sensor(0x3370, 0x7F); 		 
+	write_cmos_sensor(0x3371, 0x37); 		 
+	write_cmos_sensor(0x3372, 0x67); 		 
+	write_cmos_sensor(0x3373, 0x3F); 		 
+	write_cmos_sensor(0x3374, 0x3F); 		 
+	write_cmos_sensor(0x3375, 0x47); 		 
+	write_cmos_sensor(0x3376, 0xCF); 		 
+	write_cmos_sensor(0x3377, 0x47); 		
+	write_cmos_sensor(0x33C8, 0x00); 		 
+	write_cmos_sensor(0x33D4, 0x06); 		 
+	write_cmos_sensor(0x33D5, 0x68); 		 
+	write_cmos_sensor(0x33D6, 0x04); 	   
+	write_cmos_sensor(0x33D7, 0xD0); 	  
+	write_cmos_sensor(0x4100, 0x0E); 	   
+	write_cmos_sensor(0x4108, 0x01);
 	write_cmos_sensor(0x4109, 0x7C);
 	write_cmos_sensor(0x0104, 0x00);//group
-	write_cmos_sensor(0x0100, 0x01);//STREAM ON	
+	write_cmos_sensor(0x0100, 0x01);//STREAM ON
 // The register only need to enable 1 time.     
 }	/*	preview_setting  */
 
@@ -818,224 +822,142 @@ static void capture_setting(kal_uint16 currefps)
 {
 	LOG_INF("E! currefps:%d\n",currefps);
 	if (currefps == 240) 
-	{ //24fps for PIP //@@full_132PCLK_24.75
-	 //5.1.2 FQPreview 3280x2464 30fps 24M MCLK 4lane 204.8Mbps/lane
-		write_cmos_sensor(0x41C0, 0x01);
-		write_cmos_sensor(0x0104, 0x01);//group
-		write_cmos_sensor(0x0100, 0x00);//STREAM OFF 
-		//write_cmos_sensor(0x0101, 0x00); 
-		//write_cmos_sensor(0x0103, 0x01);//SW reset		 		   
-		write_cmos_sensor(0x0202, 0x09); //0x0202, 0x09		 
-		write_cmos_sensor(0x0203, 0xAD);//(0x0203, 0xcc)
-		//PLL setting
-		write_cmos_sensor(0x0301, 0x05); 		 
-		write_cmos_sensor(0x0303, 0x01); 		 
-		write_cmos_sensor(0x0305, 0x06); 		 
-		write_cmos_sensor(0x0309, 0x05); 		 
-		write_cmos_sensor(0x030B, 0x01); 		 
-		write_cmos_sensor(0x030C, 0x00); 		 
-		write_cmos_sensor(0x030D, 0x80); //(0x030D, 0xA2)
-		write_cmos_sensor(0x030E, 0x01);
-		
-		write_cmos_sensor(0x0340, 0x09);//(0x0340, 0x09)
-		write_cmos_sensor(0x0341, 0xB1); 		 
-		write_cmos_sensor(0x0342, 0x0D); 		
-		write_cmos_sensor(0x0343, 0x70);//(0x0343, 0x0D) 		 
-		write_cmos_sensor(0x0344, 0x00); 		 
-		write_cmos_sensor(0x0345, 0x00); 		 
-		write_cmos_sensor(0x0346, 0x00); 		 
-		write_cmos_sensor(0x0347, 0x00);// (0x0347, 0x00)		 
-		write_cmos_sensor(0x0348, 0x0C); 		
-		write_cmos_sensor(0x0349, 0xCF); 		 
-		write_cmos_sensor(0x034A, 0x09);// (0x034A, 0x09)		 
-		write_cmos_sensor(0x034B, 0x9F);//(0x034B, 0x9F) 		 
-		write_cmos_sensor(0x034C, 0x0C); 		 
-		write_cmos_sensor(0x034D, 0xD0); 		 
-		write_cmos_sensor(0x034E, 0x09); 		 
-		write_cmos_sensor(0x034F, 0xA0);//(0x034F, 0xD0)		 
-		write_cmos_sensor(0x0383, 0x01); 		 
-		write_cmos_sensor(0x0387, 0x01); 		
-		write_cmos_sensor(0x0390, 0x00); 		 
-		write_cmos_sensor(0x0401, 0x00); 		 
-		write_cmos_sensor(0x0405, 0x10); 		 
-		write_cmos_sensor(0x3020, 0x10); 		 
-		write_cmos_sensor(0x3041, 0x15); 		 
-		write_cmos_sensor(0x3042, 0x87); 		 
-		write_cmos_sensor(0x3089, 0x4F); 		 
-		write_cmos_sensor(0x3309, 0x9A); 		 
-		write_cmos_sensor(0x3344, 0x4F);//(0x3344, 0x57)		 
-		write_cmos_sensor(0x3345, 0x1F); 		 
-		write_cmos_sensor(0x3362, 0x0A); 		 
-		write_cmos_sensor(0x3363, 0x0A); 		 
-		write_cmos_sensor(0x3364, 0x00); 		
-		write_cmos_sensor(0x3368, 0x18); 		 
-		write_cmos_sensor(0x3369, 0x00); 		 
-		write_cmos_sensor(0x3370, 0x6F);// (0x3370, 0x77)		 	 
-		write_cmos_sensor(0x3371, 0x27);//(0x3371, 0x2F)             
-		write_cmos_sensor(0x3372, 0x47);             
-		write_cmos_sensor(0x3373, 0x27);             
-		write_cmos_sensor(0x3374, 0x27);             
-		write_cmos_sensor(0x3375, 0x27);             
-		write_cmos_sensor(0x3376, 0x8F);             
-		write_cmos_sensor(0x3377, 0x37);             
-		write_cmos_sensor(0x33C8, 0x00);             
-		write_cmos_sensor(0x33D4, 0x0C);             
-		write_cmos_sensor(0x33D5, 0xD0);             
-		write_cmos_sensor(0x33D6, 0x09);             
-		write_cmos_sensor(0x33D7, 0xA0);             
-		write_cmos_sensor(0x4100, 0x0E);             
-		write_cmos_sensor(0x4108, 0x01);             
-		write_cmos_sensor(0x4109, 0x7C);
-		write_cmos_sensor(0x3302, 0x01);
-		write_cmos_sensor(0x0104, 0x00);//group
-		write_cmos_sensor(0x0100, 0x01);//STREAM ON
-	}
-	else if(currefps == 150) 
-	{ //D1 15fps for PIP //@@full_132PCLK_24.75
-	 
-		write_cmos_sensor(0x41C0, 0x01);
-		write_cmos_sensor(0x0104, 0x01);//group
-		write_cmos_sensor(0x0100, 0x00);//STREAM OFF 
-		//write_cmos_sensor(0x0101, 0x00); 
-		//write_cmos_sensor(0x0103, 0x01);//SW reset		 		   
-		write_cmos_sensor(0x0202, 0x7C); //0x0202, 0x09		 
-		write_cmos_sensor(0x0203, 0x7C);//(0x0203, 0xcc)
-		//PLL setting
-		write_cmos_sensor(0x0301, 0x2F); 		 
-		write_cmos_sensor(0x0303, 0x2F); 		 
-		write_cmos_sensor(0x0305, 0x2F); 		 
-		write_cmos_sensor(0x0309, 0x9F); 		 
-		write_cmos_sensor(0x030B, 0x37); 		 
-		write_cmos_sensor(0x030C, 0x4F); 		 
-		write_cmos_sensor(0x030D, 0x4F); //(0x030D, 0xA2)
-		write_cmos_sensor(0x030E, 0x01);
-		
-		write_cmos_sensor(0x0340, 0x0A);//(0x0340, 0x09)
-		write_cmos_sensor(0x0341, 0x4C); 		 
-		write_cmos_sensor(0x0342, 0x0D); 		
-		write_cmos_sensor(0x0343, 0x70);//(0x0343, 0x0D) 		 
-		write_cmos_sensor(0x0344, 0x00); 		 
-		write_cmos_sensor(0x0345, 0x00); 		 
-		write_cmos_sensor(0x0346, 0x00); 		 
-		write_cmos_sensor(0x0347, 0x00);// (0x0347, 0x00)		 
-		write_cmos_sensor(0x0348, 0x0C); 		
-		write_cmos_sensor(0x0349, 0xCF); 		 
-		write_cmos_sensor(0x034A, 0x09);// (0x034A, 0x09)		 
-		write_cmos_sensor(0x034B, 0x9F);//(0x034B, 0x9F) 		 
-		write_cmos_sensor(0x034C, 0x0C); 		 
-		write_cmos_sensor(0x034D, 0xD0); 		 
-		write_cmos_sensor(0x034E, 0x09); 		 
-		write_cmos_sensor(0x034F, 0xA0);//(0x034F, 0xD0)		 
-		write_cmos_sensor(0x0383, 0x01); 		 
-		write_cmos_sensor(0x0387, 0x01); 		
-		write_cmos_sensor(0x0390, 0x00); 		 
-		write_cmos_sensor(0x0401, 0x00); 		 
-		write_cmos_sensor(0x0405, 0x10); 		 
-		write_cmos_sensor(0x3020, 0x10); 		 
-		write_cmos_sensor(0x3041, 0x15); 		 
-		write_cmos_sensor(0x3042, 0x87); 		 
-		write_cmos_sensor(0x3089, 0x4F); 		 
-		write_cmos_sensor(0x3309, 0x9A); 		 
-		write_cmos_sensor(0x3344, 0x37);//(0x3344, 0x57)		 
-		write_cmos_sensor(0x3345, 0x1F); 		 
-		write_cmos_sensor(0x3362, 0x0A); 		 
-		write_cmos_sensor(0x3363, 0x0A); 		 
-		write_cmos_sensor(0x3364, 0x00); 		
-		write_cmos_sensor(0x3368, 0x18); 		 
-		write_cmos_sensor(0x3369, 0x00); 		 
-		write_cmos_sensor(0x3370, 0x5F);// (0x3370, 0x77)		 	 
-		write_cmos_sensor(0x3371, 0x17);//(0x3371, 0x2F)             
-		write_cmos_sensor(0x3372, 0x3F);             
-		write_cmos_sensor(0x3373, 0x1F);             
-		write_cmos_sensor(0x3374, 0x1F);             
-		write_cmos_sensor(0x3375, 0x17);             
-		write_cmos_sensor(0x3376, 0x5F);             
-		write_cmos_sensor(0x3377, 0x27);             
-		write_cmos_sensor(0x33C8, 0x00);             
-		write_cmos_sensor(0x33D4, 0x0C);             
-		write_cmos_sensor(0x33D5, 0xD0);             
-		write_cmos_sensor(0x33D6, 0x09);             
-		write_cmos_sensor(0x33D7, 0xA0);             
-		write_cmos_sensor(0x4100, 0x0E);             
-		write_cmos_sensor(0x4108, 0x01);             
-		write_cmos_sensor(0x4109, 0x7C);
-		write_cmos_sensor(0x3302, 0x01);
-		write_cmos_sensor(0x0104, 0x00);//group
-		write_cmos_sensor(0x0100, 0x01);//STREAM ON
+	{
+	 write_cmos_sensor(0x41C0, 0x01);         
+	write_cmos_sensor(0x0100, 0x00);          
+	write_cmos_sensor(0x0101, 0x00);         
+	write_cmos_sensor(0x030E, 0x0C);          
+	write_cmos_sensor(0x0202, 0x09);
+	write_cmos_sensor(0x0203, 0xAA);
+	//PLLsetting
+	write_cmos_sensor(0x0301, 0x0A);          
+	write_cmos_sensor(0x0303, 0x01);          
+	write_cmos_sensor(0x0305, 0x06);          
+	write_cmos_sensor(0x0309, 0x0A);          
+	write_cmos_sensor(0x030B, 0x01);          
+	write_cmos_sensor(0x030C, 0x00);
+	write_cmos_sensor(0x030D, 0xDD);
+	write_cmos_sensor(0x030E, 0x01); 
+	
+	write_cmos_sensor(0x0340, 0x09);
+	write_cmos_sensor(0x0341, 0xAE);          
+	write_cmos_sensor(0x0342, 0x0D);          
+	write_cmos_sensor(0x0343, 0x70);          
+	write_cmos_sensor(0x0344, 0x00);          
+	write_cmos_sensor(0x0345, 0x00);          
+	write_cmos_sensor(0x0346, 0x00);          
+	write_cmos_sensor(0x0347, 0x00);          
+	write_cmos_sensor(0x0348, 0x0C);          
+	write_cmos_sensor(0x0349, 0xCF);          
+	write_cmos_sensor(0x034A, 0x09);          
+	write_cmos_sensor(0x034B, 0x9F);          
+	write_cmos_sensor(0x034C, 0x0C);          
+	write_cmos_sensor(0x034D, 0xD0);          
+	write_cmos_sensor(0x034E, 0x09);         
+	write_cmos_sensor(0x034F, 0xA0);          
+	write_cmos_sensor(0x0383, 0x01);          
+	write_cmos_sensor(0x0387, 0x01);          
+	write_cmos_sensor(0x0390, 0x00);          
+	write_cmos_sensor(0x0401, 0x00);          
+	write_cmos_sensor(0x0405, 0x10);          
+	write_cmos_sensor(0x3020, 0x10);          
+	write_cmos_sensor(0x3041, 0x15);          
+	write_cmos_sensor(0x3042, 0x87);          
+	write_cmos_sensor(0x3089, 0x4F);          
+	write_cmos_sensor(0x3309, 0x9A);          
+	write_cmos_sensor(0x3344, 0x6F);          
+	write_cmos_sensor(0x3345, 0x1F);          
+	write_cmos_sensor(0x3362, 0x0A);          
+	write_cmos_sensor(0x3363, 0x0A);          
+	write_cmos_sensor(0x3364, 0x02);  //2lane        
+	write_cmos_sensor(0x3368, 0x18);          
+	write_cmos_sensor(0x3369, 0x00);          
+	write_cmos_sensor(0x3370, 0x7F);         
+	write_cmos_sensor(0x3371, 0x37);          
+	write_cmos_sensor(0x3372, 0x67);          
+	write_cmos_sensor(0x3373, 0x3F);          
+	write_cmos_sensor(0x3374, 0x3F);         
+	write_cmos_sensor(0x3375, 0x47);          
+	write_cmos_sensor(0x3376, 0xCF);          
+	write_cmos_sensor(0x3377, 0x47);          
+	write_cmos_sensor(0x33C8, 0x00);          
+	write_cmos_sensor(0x33D4, 0x0C);          
+	write_cmos_sensor(0x33D5, 0xD0);          
+	write_cmos_sensor(0x33D6, 0x09);          
+	write_cmos_sensor(0x33D7, 0xA0);          
+	write_cmos_sensor(0x4100, 0x0E);          
+	write_cmos_sensor(0x4108, 0x01);          
+	write_cmos_sensor(0x4109, 0x7C);  
+	write_cmos_sensor(0x0100, 0x01);//STREAM ON
 	}
 	else
-	{   //30fps		
-		//30fps for Normal capture & ZSD
-		//5.1.2 FQPreview 3280x2464 30fps 24M MCLK 4lane 256Mbps/lane
-	    write_cmos_sensor(0x41C0, 0x01);
-		write_cmos_sensor(0x0104, 0x01);//group
-		write_cmos_sensor(0x0100, 0x00);//STREAM OFF 
-		//write_cmos_sensor(0x0101, 0x00); 
-		//write_cmos_sensor(0x0103, 0x01);//SW reset		 		   
-		write_cmos_sensor(0x0202, 0x09); //0x0202, 0x09		 
-		write_cmos_sensor(0x0203, 0xAD);//(0x0203, 0xcc)
-		//PLL setting
-		write_cmos_sensor(0x0301, 0x05); 		 
-		write_cmos_sensor(0x0303, 0x01); 		 
-		write_cmos_sensor(0x0305, 0x06); 		 
-		write_cmos_sensor(0x0309, 0x05); 		 
-		write_cmos_sensor(0x030B, 0x01); 		 
-		write_cmos_sensor(0x030C, 0x00); 		 
-		write_cmos_sensor(0x030D, 0xA0); //(0x030D, 0xA2)
-		write_cmos_sensor(0x030E, 0x01);
-		
-		write_cmos_sensor(0x0340, 0x09);//(0x0340, 0x09)
-		write_cmos_sensor(0x0341, 0xB1); 		 
-		write_cmos_sensor(0x0342, 0x0D); 		
-		write_cmos_sensor(0x0343, 0x70);//(0x0343, 0x0D) 		 
-		write_cmos_sensor(0x0344, 0x00); 		 
-		write_cmos_sensor(0x0345, 0x00); 		 
-		write_cmos_sensor(0x0346, 0x00); 		 
-		write_cmos_sensor(0x0347, 0x00);// (0x0347, 0x00)		 
-		write_cmos_sensor(0x0348, 0x0C); 		
-		write_cmos_sensor(0x0349, 0xCF); 		 
-		write_cmos_sensor(0x034A, 0x09);// (0x034A, 0x09)		 
-		write_cmos_sensor(0x034B, 0x9F);//(0x034B, 0x9F) 		 
-		write_cmos_sensor(0x034C, 0x0C); 		 
-		write_cmos_sensor(0x034D, 0xD0); 		 
-		write_cmos_sensor(0x034E, 0x09); 		 
-		write_cmos_sensor(0x034F, 0xA0);//(0x034F, 0xD0)		 
-		write_cmos_sensor(0x0383, 0x01); 		 
-		write_cmos_sensor(0x0387, 0x01); 		
-		write_cmos_sensor(0x0390, 0x00); 		 
-		write_cmos_sensor(0x0401, 0x00); 		 
-		write_cmos_sensor(0x0405, 0x10); 		 
-		write_cmos_sensor(0x3020, 0x10); 		 
-		write_cmos_sensor(0x3041, 0x15); 		 
-		write_cmos_sensor(0x3042, 0x87); 		 
-		write_cmos_sensor(0x3089, 0x4F); 		 
-		write_cmos_sensor(0x3309, 0x9A); 		 
-		write_cmos_sensor(0x3344, 0x57);//(0x3344, 0x57)		 
-		write_cmos_sensor(0x3345, 0x1F); 		 
-		write_cmos_sensor(0x3362, 0x0A); 		 
-		write_cmos_sensor(0x3363, 0x0A); 		 
-		write_cmos_sensor(0x3364, 0x00); 		
-		write_cmos_sensor(0x3368, 0x18); 		 
-		write_cmos_sensor(0x3369, 0x00); 		 
-		write_cmos_sensor(0x3370, 0x77);// (0x3370, 0x77)		 	 
-		write_cmos_sensor(0x3371, 0x2F);//(0x3371, 0x2F)             
-		write_cmos_sensor(0x3372, 0x4F);             
-		write_cmos_sensor(0x3373, 0x2F);             
-		write_cmos_sensor(0x3374, 0x2F);             
-		write_cmos_sensor(0x3375, 0x37);             
-		write_cmos_sensor(0x3376, 0x9F);             
-		write_cmos_sensor(0x3377, 0x37);             
-		write_cmos_sensor(0x33C8, 0x00);             
-		write_cmos_sensor(0x33D4, 0x0C);             
-		write_cmos_sensor(0x33D5, 0xD0);             
-		write_cmos_sensor(0x33D6, 0x09);             
-		write_cmos_sensor(0x33D7, 0xA0);             
-		write_cmos_sensor(0x4100, 0x0E);             
-		write_cmos_sensor(0x4108, 0x01);             
-		write_cmos_sensor(0x4109, 0x7C);
-		write_cmos_sensor(0x3302, 0x01);
-		write_cmos_sensor(0x0104, 0x00);//group
-		write_cmos_sensor(0x0100, 0x01);//STREAM ON		
+	{   
+		write_cmos_sensor(0x41C0, 0x01);         
+	write_cmos_sensor(0x0100, 0x00);          
+	write_cmos_sensor(0x0101, 0x00);         
+	write_cmos_sensor(0x030E, 0x0C);          
+	write_cmos_sensor(0x0202, 0x09);
+	write_cmos_sensor(0x0203, 0xAA);
+	//PLLsetting
+	write_cmos_sensor(0x0301, 0x0A);          
+	write_cmos_sensor(0x0303, 0x01);          
+	write_cmos_sensor(0x0305, 0x06);          
+	write_cmos_sensor(0x0309, 0x0A);          
+	write_cmos_sensor(0x030B, 0x01);          
+	write_cmos_sensor(0x030C, 0x00);
+	write_cmos_sensor(0x030D, 0xDD);
+	write_cmos_sensor(0x030E, 0x01); 
+	
+	write_cmos_sensor(0x0340, 0x09);
+	write_cmos_sensor(0x0341, 0xAE);          
+	write_cmos_sensor(0x0342, 0x0D);          
+	write_cmos_sensor(0x0343, 0x70);          
+	write_cmos_sensor(0x0344, 0x00);          
+	write_cmos_sensor(0x0345, 0x00);          
+	write_cmos_sensor(0x0346, 0x00);          
+	write_cmos_sensor(0x0347, 0x00);          
+	write_cmos_sensor(0x0348, 0x0C);          
+	write_cmos_sensor(0x0349, 0xCF);          
+	write_cmos_sensor(0x034A, 0x09);          
+	write_cmos_sensor(0x034B, 0x9F);          
+	write_cmos_sensor(0x034C, 0x0C);          
+	write_cmos_sensor(0x034D, 0xD0);          
+	write_cmos_sensor(0x034E, 0x09);         
+	write_cmos_sensor(0x034F, 0xA0);          
+	write_cmos_sensor(0x0383, 0x01);          
+	write_cmos_sensor(0x0387, 0x01);          
+	write_cmos_sensor(0x0390, 0x00);          
+	write_cmos_sensor(0x0401, 0x00);          
+	write_cmos_sensor(0x0405, 0x10);          
+	write_cmos_sensor(0x3020, 0x10);          
+	write_cmos_sensor(0x3041, 0x15);          
+	write_cmos_sensor(0x3042, 0x87);          
+	write_cmos_sensor(0x3089, 0x4F);          
+	write_cmos_sensor(0x3309, 0x9A);          
+	write_cmos_sensor(0x3344, 0x6F);          
+	write_cmos_sensor(0x3345, 0x1F);          
+	write_cmos_sensor(0x3362, 0x0A);          
+	write_cmos_sensor(0x3363, 0x0A);          
+	write_cmos_sensor(0x3364, 0x02);  //2lane        
+	write_cmos_sensor(0x3368, 0x18);          
+	write_cmos_sensor(0x3369, 0x00);          
+	write_cmos_sensor(0x3370, 0x7F);         
+	write_cmos_sensor(0x3371, 0x37);          
+	write_cmos_sensor(0x3372, 0x67);          
+	write_cmos_sensor(0x3373, 0x3F);          
+	write_cmos_sensor(0x3374, 0x3F);         
+	write_cmos_sensor(0x3375, 0x47);          
+	write_cmos_sensor(0x3376, 0xCF);          
+	write_cmos_sensor(0x3377, 0x47);          
+	write_cmos_sensor(0x33C8, 0x00);          
+	write_cmos_sensor(0x33D4, 0x0C);          
+	write_cmos_sensor(0x33D5, 0xD0);          
+	write_cmos_sensor(0x33D6, 0x09);          
+	write_cmos_sensor(0x33D7, 0xA0);          
+	write_cmos_sensor(0x4100, 0x0E);          
+	write_cmos_sensor(0x4108, 0x01);          
+	write_cmos_sensor(0x4109, 0x7C);  
+	write_cmos_sensor(0x0100, 0x01);//STREAM ON		
 	}	
 }
 
@@ -1045,74 +967,74 @@ static void normal_video_setting(kal_uint16 currefps)
 		//5.1.2 FQPreview 3280x2464 30fps 24M MCLK 4lane 256Mbps/lane
 		LOG_INF("E! currefps:%d\n",currefps);
 	    write_cmos_sensor(0x41C0, 0x01);
-		write_cmos_sensor(0x0104, 0x01);//group
-		write_cmos_sensor(0x0100, 0x00);//STREAM OFF 
-		//write_cmos_sensor(0x0101, 0x00); 
-		//write_cmos_sensor(0x0103, 0x01);//SW reset		 		   
-		write_cmos_sensor(0x0202, 0x09); //0x0202, 0x09		 
-		write_cmos_sensor(0x0203, 0xAD);//(0x0203, 0xcc)
-		//PLL setting
-		write_cmos_sensor(0x0301, 0x05); 		 
-		write_cmos_sensor(0x0303, 0x01); 		 
-		write_cmos_sensor(0x0305, 0x06); 		 
-		write_cmos_sensor(0x0309, 0x05); 		 
-		write_cmos_sensor(0x030B, 0x01); 		 
-		write_cmos_sensor(0x030C, 0x00); 		 
-		write_cmos_sensor(0x030D, 0xA0); //(0x030D, 0xA2)
-		write_cmos_sensor(0x030E, 0x01);
-		
-		write_cmos_sensor(0x0340, 0x09);//(0x0340, 0x09)
-		write_cmos_sensor(0x0341, 0xB1); 		 
-		write_cmos_sensor(0x0342, 0x0D); 		
-		write_cmos_sensor(0x0343, 0x70);//(0x0343, 0x0D) 		 
-		write_cmos_sensor(0x0344, 0x00); 		 
-		write_cmos_sensor(0x0345, 0x00); 		 
-		write_cmos_sensor(0x0346, 0x00); 		 
-		write_cmos_sensor(0x0347, 0x00);// (0x0347, 0x00)		 
-		write_cmos_sensor(0x0348, 0x0C); 		
-		write_cmos_sensor(0x0349, 0xCF); 		 
-		write_cmos_sensor(0x034A, 0x09);// (0x034A, 0x09)		 
-		write_cmos_sensor(0x034B, 0x9F);//(0x034B, 0x9F) 		 
-		write_cmos_sensor(0x034C, 0x0C); 		 
-		write_cmos_sensor(0x034D, 0xD0); 		 
-		write_cmos_sensor(0x034E, 0x09); 		 
-		write_cmos_sensor(0x034F, 0xA0);//(0x034F, 0xD0)		 
-		write_cmos_sensor(0x0383, 0x01); 		 
-		write_cmos_sensor(0x0387, 0x01); 		
-		write_cmos_sensor(0x0390, 0x00); 		 
-		write_cmos_sensor(0x0401, 0x00); 		 
-		write_cmos_sensor(0x0405, 0x10); 		 
-		write_cmos_sensor(0x3020, 0x10); 		 
-		write_cmos_sensor(0x3041, 0x15); 		 
-		write_cmos_sensor(0x3042, 0x87); 		 
-		write_cmos_sensor(0x3089, 0x4F); 		 
-		write_cmos_sensor(0x3309, 0x9A); 		 
-		write_cmos_sensor(0x3344, 0x57);//(0x3344, 0x57)		 
-		write_cmos_sensor(0x3345, 0x1F); 		 
-		write_cmos_sensor(0x3362, 0x0A); 		 
-		write_cmos_sensor(0x3363, 0x0A); 		 
-		write_cmos_sensor(0x3364, 0x00); 		
-		write_cmos_sensor(0x3368, 0x18); 		 
-		write_cmos_sensor(0x3369, 0x00); 		 
-		write_cmos_sensor(0x3370, 0x77);// (0x3370, 0x77)		 	 
-		write_cmos_sensor(0x3371, 0x2F);//(0x3371, 0x2F)             
-		write_cmos_sensor(0x3372, 0x4F);             
-		write_cmos_sensor(0x3373, 0x2F);             
-		write_cmos_sensor(0x3374, 0x2F);             
-		write_cmos_sensor(0x3375, 0x37);             
-		write_cmos_sensor(0x3376, 0x9F);             
-		write_cmos_sensor(0x3377, 0x37);             
-		write_cmos_sensor(0x33C8, 0x00);             
-		write_cmos_sensor(0x33D4, 0x0C);             
-		write_cmos_sensor(0x33D5, 0xD0);             
-		write_cmos_sensor(0x33D6, 0x09);             
-		write_cmos_sensor(0x33D7, 0xA0);             
-		write_cmos_sensor(0x4100, 0x0E);             
-		write_cmos_sensor(0x4108, 0x01);             
-		write_cmos_sensor(0x4109, 0x7C);
-		write_cmos_sensor(0x3302, 0x01);
-		write_cmos_sensor(0x0104, 0x00);//group
-		write_cmos_sensor(0x0100, 0x01);//STREAM ON		
+	write_cmos_sensor(0x0104, 0x01);//group
+	write_cmos_sensor(0x0100, 0x00);//STREAM OFF 	
+	write_cmos_sensor(0x0103, 0x01);//SW reset
+	write_cmos_sensor(0x0101, 0x00); 		 
+	write_cmos_sensor(0x030E, 0x01); 	   
+	write_cmos_sensor(0x0202, 0x06); 		 
+	write_cmos_sensor(0x0203, 0xAD);
+	//PLL setting
+	write_cmos_sensor(0x0301, 0x0A); 		 
+	write_cmos_sensor(0x0303, 0x01); 		 
+	write_cmos_sensor(0x0305, 0x06); 		 
+	write_cmos_sensor(0x0309, 0x0A); 		 
+	write_cmos_sensor(0x030B, 0x01); 		 
+	write_cmos_sensor(0x030C, 0x00); 		 
+	write_cmos_sensor(0x030D, 0xDD); 
+	write_cmos_sensor(0x030E, 0x01);
+
+	write_cmos_sensor(0x0340, 0x06);
+	write_cmos_sensor(0x0341, 0xB1); 		 
+	write_cmos_sensor(0x0342, 0x0D); 		
+	write_cmos_sensor(0x0343, 0x70); 		 
+	write_cmos_sensor(0x0344, 0x00); 		 
+	write_cmos_sensor(0x0345, 0x00); 		 
+	write_cmos_sensor(0x0346, 0x00); 		 
+	write_cmos_sensor(0x0347, 0x00); 		 
+	write_cmos_sensor(0x0348, 0x0C); 		
+	write_cmos_sensor(0x0349, 0xCF); 		 
+	write_cmos_sensor(0x034A, 0x09); 		 
+	write_cmos_sensor(0x034B, 0x9F); 		 
+	write_cmos_sensor(0x034C, 0x06); 		 
+	write_cmos_sensor(0x034D, 0x68); 		 
+	write_cmos_sensor(0x034E, 0x04); 		 
+	write_cmos_sensor(0x034F, 0xD0); 		 
+	write_cmos_sensor(0x0383, 0x01); 		 
+	write_cmos_sensor(0x0387, 0x01); 		
+	write_cmos_sensor(0x0390, 0x01); 		 
+	write_cmos_sensor(0x0401, 0x00); 		 
+	write_cmos_sensor(0x0405, 0x10); 		 
+	write_cmos_sensor(0x3020, 0x10); 		 
+	write_cmos_sensor(0x3041, 0x15); 		 
+	write_cmos_sensor(0x3042, 0x87); 		 
+	write_cmos_sensor(0x3089, 0x4F); 		 
+	write_cmos_sensor(0x3309, 0x9A); 		 
+	write_cmos_sensor(0x3344, 0x6F); 		 
+	write_cmos_sensor(0x3345, 0x1F); 		 
+	write_cmos_sensor(0x3362, 0x0A); 		 
+	write_cmos_sensor(0x3363, 0x0A); 		 
+	write_cmos_sensor(0x3364, 0x02); 	//2lane	
+	write_cmos_sensor(0x3368, 0x18); 		 
+	write_cmos_sensor(0x3369, 0x00); 		 
+	write_cmos_sensor(0x3370, 0x7F); 		 
+	write_cmos_sensor(0x3371, 0x37); 		 
+	write_cmos_sensor(0x3372, 0x67); 		 
+	write_cmos_sensor(0x3373, 0x3F); 		 
+	write_cmos_sensor(0x3374, 0x3F); 		 
+	write_cmos_sensor(0x3375, 0x47); 		 
+	write_cmos_sensor(0x3376, 0xCF); 		 
+	write_cmos_sensor(0x3377, 0x47); 		
+	write_cmos_sensor(0x33C8, 0x00); 		 
+	write_cmos_sensor(0x33D4, 0x06); 		 
+	write_cmos_sensor(0x33D5, 0x68); 		 
+	write_cmos_sensor(0x33D6, 0x04); 	   
+	write_cmos_sensor(0x33D7, 0xD0); 	  
+	write_cmos_sensor(0x4100, 0x0E); 	   
+	write_cmos_sensor(0x4108, 0x01);
+	write_cmos_sensor(0x4109, 0x7C);
+	write_cmos_sensor(0x0104, 0x00);//group
+	write_cmos_sensor(0x0100, 0x01);//STREAM ON
 }
 static void hs_video_setting()
 {
@@ -1121,8 +1043,8 @@ static void hs_video_setting()
 	write_cmos_sensor(0x41C0, 0x01);
 	write_cmos_sensor(0x0104, 0x01);//group
 	write_cmos_sensor(0x0100, 0x00);//STREAM OFF 
-	//write_cmos_sensor(0x0101, 0x00); 
-	//write_cmos_sensor(0x0103, 0x01);//SW reset		 		   
+	write_cmos_sensor(0x0101, 0x00); 
+	write_cmos_sensor(0x0103, 0x01);//SW reset		 		   
 	write_cmos_sensor(0x0202, 0x02); //0x0202, 0x09		 
 	write_cmos_sensor(0x0203, 0x68);//(0x0203, 0xcc)
 	//PLL setting
@@ -1194,8 +1116,8 @@ static void slim_video_setting()
 	write_cmos_sensor(0x41C0, 0x01);
 	write_cmos_sensor(0x0104, 0x01);//group
 	write_cmos_sensor(0x0100, 0x00);//STREAM OFF 
-	//write_cmos_sensor(0x0101, 0x00); 
-	//write_cmos_sensor(0x0103, 0x01);//SW reset		 		   
+	write_cmos_sensor(0x0101, 0x00); 
+	write_cmos_sensor(0x0103, 0x01);//SW reset		 		   
 	write_cmos_sensor(0x0202, 0x06); //0x0202, 0x09		 
 	write_cmos_sensor(0x0203, 0x0A);//(0x0203, 0xcc)
 	//PLL setting
@@ -1313,7 +1235,7 @@ static kal_uint32 get_imgsensor_id(UINT32 *sensor_id)
 				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);	  
 				return ERROR_NONE;
 			}	
-			LOG_INF("Read sensor id fail, id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
+			LOG_INF("Read sensor id fail, write id:0x%x id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
 			retry--;
 		} while(retry > 0);
 		i++;
@@ -1347,7 +1269,7 @@ static kal_uint32 get_imgsensor_id(UINT32 *sensor_id)
 static kal_uint32 open(void)
 {
 	//const kal_uint8 i2c_addr[] = {IMGSENSOR_WRITE_ID_1, IMGSENSOR_WRITE_ID_2};
-	kal_uint8 iTemp,i = 0;
+	kal_uint8 i = 0;
 	kal_uint8 retry = 2;
 	kal_uint32 sensor_id = 0; 
 	LOG_1;	
@@ -1364,7 +1286,7 @@ static kal_uint32 open(void)
 				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);	  
 				break;
 			}	
-			LOG_INF("Read sensor id fail, id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
+			LOG_INF("Read sensor id fail, write id:0x%x id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
 			retry--;
 		} while(retry > 0);
 		i++;
@@ -1377,10 +1299,6 @@ static kal_uint32 open(void)
 	
 	/* initail sequence write in  */
 	sensor_init();
-	
-	iTemp = read_cmos_sensor(0x0101);
-	iTemp&= ~0x03; //Clear the mirror and flip bits.
-	write_cmos_sensor_8(0x0101, iTemp | 0x03); //Set mirror and flip
 
 	spin_lock(&imgsensor_drv_lock);
 
@@ -1460,7 +1378,7 @@ static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 	imgsensor.autoflicker_en = KAL_FALSE;
 	spin_unlock(&imgsensor_drv_lock);
 	preview_setting();
-	set_mirror_flip(sensor_config_data->SensorImageMirror);
+	//set_mirror_flip(sensor_config_data->SensorImageMirror);
 	return ERROR_NONE;
 }	/*	preview   */
 
@@ -1511,7 +1429,7 @@ static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 		spin_unlock(&imgsensor_drv_lock);
 	}
 
-	set_mirror_flip(sensor_config_data->SensorImageMirror);
+	//set_mirror_flip(sensor_config_data->SensorImageMirror);
     return ERROR_NONE;
 }    /* capture() */
 static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
@@ -1529,7 +1447,7 @@ static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 	imgsensor.autoflicker_en = KAL_FALSE;
 	spin_unlock(&imgsensor_drv_lock);
 	normal_video_setting(imgsensor.current_fps);
-	set_mirror_flip(sensor_config_data->SensorImageMirror);
+	//set_mirror_flip(sensor_config_data->SensorImageMirror);
 	
 	return ERROR_NONE;
 }	/*	normal_video   */
@@ -1552,7 +1470,7 @@ static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 	imgsensor.autoflicker_en = KAL_FALSE;
 	spin_unlock(&imgsensor_drv_lock);
 	hs_video_setting();
-	set_mirror_flip(sensor_config_data->SensorImageMirror);
+	//set_mirror_flip(sensor_config_data->SensorImageMirror);
 	return ERROR_NONE;
 }	/*	hs_video   */
 
@@ -1951,7 +1869,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
 			imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
 			imgsensor.min_frame_length = imgsensor.frame_length;
 			spin_unlock(&imgsensor_drv_lock);
-			//set_dummy();			
+			set_dummy();			
 			break;			
 		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
 			if(framerate == 0)
@@ -1962,7 +1880,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
 			imgsensor.frame_length = imgsensor_info.normal_video.framelength + imgsensor.dummy_line;
 			imgsensor.min_frame_length = imgsensor.frame_length;
 			spin_unlock(&imgsensor_drv_lock);
-			//set_dummy();			
+			set_dummy();			
 			break;
         case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
         	  if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {
@@ -1982,7 +1900,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
 		            imgsensor.min_frame_length = imgsensor.frame_length;
 		            spin_unlock(&imgsensor_drv_lock);
             }
-			//set_dummy();			
+			set_dummy();			
 			break;	
 		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
 			frame_length = imgsensor_info.hs_video.pclk / framerate * 10 / imgsensor_info.hs_video.linelength;
@@ -1991,7 +1909,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
 			imgsensor.frame_length = imgsensor_info.hs_video.framelength + imgsensor.dummy_line;
 			imgsensor.min_frame_length = imgsensor.frame_length;
 			spin_unlock(&imgsensor_drv_lock);
-			//set_dummy();			
+			set_dummy();			
 			break;
 		case MSDK_SCENARIO_ID_SLIM_VIDEO:
 			frame_length = imgsensor_info.slim_video.pclk / framerate * 10 / imgsensor_info.slim_video.linelength;
@@ -2000,7 +1918,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
 			imgsensor.frame_length = imgsensor_info.slim_video.framelength + imgsensor.dummy_line;
 			imgsensor.min_frame_length = imgsensor.frame_length;
 			spin_unlock(&imgsensor_drv_lock);
-			//set_dummy();			
+			set_dummy();			
         case MSDK_SCENARIO_ID_CUSTOM1:
             frame_length = imgsensor_info.custom1.pclk / framerate * 10 / imgsensor_info.custom1.linelength;
             spin_lock(&imgsensor_drv_lock);
@@ -2010,7 +1928,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
             imgsensor.frame_length = imgsensor_info.custom1.framelength + imgsensor.dummy_line;
             imgsensor.min_frame_length = imgsensor.frame_length;
             spin_unlock(&imgsensor_drv_lock);
-            //set_dummy();            
+            set_dummy();            
             break;
         case MSDK_SCENARIO_ID_CUSTOM2:
             frame_length = imgsensor_info.custom2.pclk / framerate * 10 / imgsensor_info.custom2.linelength;
@@ -2021,7 +1939,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
             imgsensor.frame_length = imgsensor_info.custom2.framelength + imgsensor.dummy_line;
             imgsensor.min_frame_length = imgsensor.frame_length;
             spin_unlock(&imgsensor_drv_lock);
-            //set_dummy();            
+            set_dummy();            
             break; 
         case MSDK_SCENARIO_ID_CUSTOM3:
             frame_length = imgsensor_info.custom3.pclk / framerate * 10 / imgsensor_info.custom3.linelength;
@@ -2032,7 +1950,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
             imgsensor.frame_length = imgsensor_info.custom3.framelength + imgsensor.dummy_line;
             imgsensor.min_frame_length = imgsensor.frame_length;
             spin_unlock(&imgsensor_drv_lock);
-            //set_dummy();            
+            set_dummy();            
             break; 
         case MSDK_SCENARIO_ID_CUSTOM4:
             frame_length = imgsensor_info.custom4.pclk / framerate * 10 / imgsensor_info.custom4.linelength;
@@ -2043,7 +1961,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
             imgsensor.frame_length = imgsensor_info.custom4.framelength + imgsensor.dummy_line;
             imgsensor.min_frame_length = imgsensor.frame_length;
             spin_unlock(&imgsensor_drv_lock);
-            //set_dummy();            
+            set_dummy();            
             break; 
         case MSDK_SCENARIO_ID_CUSTOM5:
             frame_length = imgsensor_info.custom5.pclk / framerate * 10 / imgsensor_info.custom5.linelength;
@@ -2054,7 +1972,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
             imgsensor.frame_length = imgsensor_info.custom1.framelength + imgsensor.dummy_line;
             imgsensor.min_frame_length = imgsensor.frame_length;
             spin_unlock(&imgsensor_drv_lock);
-            //set_dummy();            
+            set_dummy();            
 			break;		
 		default:  //coding with  preview scenario by default
 			frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
@@ -2063,7 +1981,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
 			imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
 			imgsensor.min_frame_length = imgsensor.frame_length;
 			spin_unlock(&imgsensor_drv_lock);
-			//set_dummy();	
+			set_dummy();	
 			LOG_INF("error scenario_id = %d, we use preview scenario \n", scenario_id);
 			break;
 	}	
@@ -2220,7 +2138,7 @@ static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
 			}
             break;
 		case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
-			//LOG_INF("SENSOR_SET_SENSOR_IHDR is no support");
+			LOG_INF("SENSOR_SET_SENSOR_IHDR is no support");
 			//LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",(UINT16)*feature_data_32,(UINT16)*(feature_data_32+1),(UINT16)*(feature_data_32+2)); 
 			//ihdr_write_shutter_gain((UINT16)*feature_data_32,(UINT16)*(feature_data_32+1),(UINT16)*(feature_data_32+2));	
 			break;
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/imx179_mipi_raw/imx179mipiraw_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx179_mipi_raw/imx179mipiraw_Sensor.h
index abb8f59..b133954 100644
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/imx179_mipi_raw/imx179mipiraw_Sensor.h
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx179_mipi_raw/imx179mipiraw_Sensor.h
@@ -1,38 +1,4 @@
 /*****************************************************************************
-*  Copyright Statement:
-*  --------------------
-*  This software is protected by Copyright and the information contained
-*  herein is confidential. The software may not be copied and the information
-*  contained herein may not be used or disclosed except with the written
-*  permission of MediaTek Inc. (C) 2008
-*
-*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
-*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
-*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
-*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
-*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
-*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
-*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
-*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
-*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
-*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
-*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
-*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
-*
-*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
-*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
-*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
-*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
-*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
-*
-*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
-*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
-*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
-*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
-*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
-*
-*****************************************************************************/
-/*****************************************************************************
  *
  * Filename:
  * ---------
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/imx179_mipi_raw_4lane/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx179_mipi_raw_4lane/Makefile
new file mode 100755
index 0000000..a1e7c27
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx179_mipi_raw_4lane/Makefile
@@ -0,0 +1,5 @@
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+
+obj-y += imx179mipiraw_Sensor.o
+
+
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/imx179_mipi_raw_4lane/imx179mipiraw_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx179_mipi_raw_4lane/imx179mipiraw_Sensor.c
new file mode 100755
index 0000000..15b0a2f
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx179_mipi_raw_4lane/imx179mipiraw_Sensor.c
@@ -0,0 +1,2249 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *     OV5693mipi_Sensor.c
+ *
+ * Project:
+ * --------
+ *     ALPS
+ *
+ * Description:
+ * ------------
+ *     Source code of Sensor driver
+ *
+ *
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *============================================================================
+ ****************************************************************************/
+
+#include <linux/videodev2.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <asm/atomic.h>
+//#include <asm/system.h>
+#include <linux/xlog.h>
+
+#include "kd_camera_hw.h"
+#include "kd_imgsensor.h"
+#include "kd_imgsensor_define.h"
+#include "kd_imgsensor_errcode.h"
+
+#include "imx179mipiraw_Sensor.h"
+
+/****************************Modify following Strings for debug****************************/
+#define PFX "imx179_camera_sensor"
+
+#define LOG_1 LOG_INF("IMX179,MIPI 4LANE\n")
+#define LOG_2 LOG_INF("preview 1640*1232@30fps,256Mbps/lane; video 3280*2464@30fps,256Mbps/lane; capture 8M@30fps,256MbpsMbps/lane\n")
+/****************************   Modify end    *******************************************/
+#define LOG_INF(format, args...)	xlog_printk(ANDROID_LOG_INFO   , PFX, "[%s] " format, __FUNCTION__, ##args)
+
+static DEFINE_SPINLOCK(imgsensor_drv_lock);
+static kal_uint8  test_pattern_flag=0;
+
+#define MIPI_SETTLEDELAY_AUTO     0
+#define MIPI_SETTLEDELAY_MANNUAL  1
+
+static imgsensor_info_struct imgsensor_info = { 
+	.sensor_id = IMX179_SENSOR_ID,
+	
+	.checksum_value = 0xaf072507,
+	
+	.pre = {
+		.pclk = 256000000,				//record different mode's pclk
+		.linelength = 3440,				//record different mode's linelength
+		.framelength = 2481,			//record different mode's framelength
+		.startx = 0,					//record different mode's startx of grabwindow
+		.starty = 0,					//record different mode's starty of grabwindow
+		.grabwindow_width = 1640,		//record different mode's width of grabwindow
+		.grabwindow_height = 1232,		//record different mode's height of grabwindow
+		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
+		.mipi_data_lp2hs_settle_dc = 85,
+		/*	 following for GetDefaultFramerateByScenario()	*/
+		.max_framerate = 300,	
+	},
+	.cap = {
+		.pclk = 256000000,
+		.linelength = 3440,
+		.framelength = 2481,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 3280,
+		.grabwindow_height = 2464,
+		.mipi_data_lp2hs_settle_dc = 85,
+		.max_framerate = 300,
+	},
+	.cap1 = {
+		.pclk = 204800000,
+		.linelength = 3440,
+		.framelength = 2481,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 3280,
+		.grabwindow_height = 2464,
+		.mipi_data_lp2hs_settle_dc = 85,
+		.max_framerate = 240,	
+	},
+	.normal_video = {
+		.pclk = 256000000,
+		.linelength = 3440,
+		.framelength = 2481,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 3280,
+		.grabwindow_height = 2464,
+		.mipi_data_lp2hs_settle_dc = 85,
+		.max_framerate = 300,
+	},
+	.hs_video = {
+		.pclk = 256000000,
+		.linelength = 3440,
+		.framelength = 620,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 640,
+		.grabwindow_height = 480,
+		.mipi_data_lp2hs_settle_dc = 85,
+        .max_framerate = 1200,
+	},
+	.slim_video = {
+		.pclk = 160000000,
+		.linelength = 3440,
+		.framelength = 1550,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 1280,
+		.grabwindow_height = 720,
+		.mipi_data_lp2hs_settle_dc = 85,
+		.max_framerate = 300,
+	},
+    .custom1 = {
+        .pclk = 256000000,				//record different mode's pclk
+		.linelength = 3440,				//record different mode's linelength
+		.framelength = 2481,			//record different mode's framelength
+		.startx = 0,					//record different mode's startx of grabwindow
+		.starty = 0,					//record different mode's starty of grabwindow
+		.grabwindow_width = 1640,		//record different mode's width of grabwindow
+		.grabwindow_height = 1232,		//record different mode's height of grabwindow
+		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
+		.mipi_data_lp2hs_settle_dc = 85,
+		/*	 following for GetDefaultFramerateByScenario()	*/
+		.max_framerate = 300,	
+
+    },
+    .custom2 = {
+        .pclk = 256000000,				//record different mode's pclk
+		.linelength = 3440,				//record different mode's linelength
+		.framelength = 2481,			//record different mode's framelength
+		.startx = 0,					//record different mode's startx of grabwindow
+		.starty = 0,					//record different mode's starty of grabwindow
+		.grabwindow_width = 1640,		//record different mode's width of grabwindow
+		.grabwindow_height = 1232,		//record different mode's height of grabwindow
+		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
+		.mipi_data_lp2hs_settle_dc = 85,
+		/*	 following for GetDefaultFramerateByScenario()	*/
+		.max_framerate = 300,	
+
+    },
+    .custom3 = {
+       .pclk = 256000000,				//record different mode's pclk
+		.linelength = 3440,				//record different mode's linelength
+		.framelength = 2481,			//record different mode's framelength
+		.startx = 0,					//record different mode's startx of grabwindow
+		.starty = 0,					//record different mode's starty of grabwindow
+		.grabwindow_width = 1640,		//record different mode's width of grabwindow
+		.grabwindow_height = 1232,		//record different mode's height of grabwindow
+		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
+		.mipi_data_lp2hs_settle_dc = 85,
+		/*	 following for GetDefaultFramerateByScenario()	*/
+		.max_framerate = 300,	
+
+    },
+    .custom4 = {
+      .pclk = 256000000,				//record different mode's pclk
+		.linelength = 3440,				//record different mode's linelength
+		.framelength = 2481,			//record different mode's framelength
+		.startx = 0,					//record different mode's startx of grabwindow
+		.starty = 0,					//record different mode's starty of grabwindow
+		.grabwindow_width = 1640,		//record different mode's width of grabwindow
+		.grabwindow_height = 1232,		//record different mode's height of grabwindow
+		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
+		.mipi_data_lp2hs_settle_dc = 85,
+		/*	 following for GetDefaultFramerateByScenario()	*/
+		.max_framerate = 300,	
+    },
+    .custom5 = {
+       .pclk = 256000000,				//record different mode's pclk
+		.linelength = 3440,				//record different mode's linelength
+		.framelength = 2481,			//record different mode's framelength
+		.startx = 0,					//record different mode's startx of grabwindow
+		.starty = 0,					//record different mode's starty of grabwindow
+		.grabwindow_width = 1640,		//record different mode's width of grabwindow
+		.grabwindow_height = 1232,		//record different mode's height of grabwindow
+		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
+		.mipi_data_lp2hs_settle_dc = 85,
+		/*	 following for GetDefaultFramerateByScenario()	*/
+		.max_framerate = 300,	
+    },
+	.margin = 4,
+	.min_shutter = 1,
+	.max_frame_length = 0x7fff,
+	.ae_shut_delay_frame = 0,
+	.ae_sensor_gain_delay_frame = 0,
+	.ae_ispGain_delay_frame = 2,
+	.ihdr_support = 0,	  //1, support; 0,not support
+	.ihdr_le_firstline = 0,  //1,le first ; 0, se first
+	.sensor_mode_num = 5,	  //support sensor mode num
+	
+	.cap_delay_frame = 3, 
+	.pre_delay_frame = 3, 
+	.video_delay_frame = 3,
+	.hs_video_delay_frame = 3,
+	.slim_video_delay_frame = 3,
+    .custom1_delay_frame = 2,
+    .custom2_delay_frame = 2, 
+    .custom3_delay_frame = 2, 
+    .custom4_delay_frame = 2, 
+    .custom5_delay_frame = 2,
+	
+	.isp_driving_current = ISP_DRIVING_6MA,
+	.sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,
+	.mipi_sensor_type = MIPI_OPHY_NCSI2, //0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2 
+    .mipi_settle_delay_mode = MIPI_SETTLEDELAY_AUTO,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
+	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_R,
+	.mclk = 24,
+	.mipi_lane_num = SENSOR_MIPI_4_LANE,
+	.i2c_addr_table = {0x20, 0xff},
+    .i2c_speed = 300, // i2c read/write speed
+};
+
+
+static imgsensor_struct imgsensor = {
+	.mirror = IMAGE_NORMAL,				//mirrorflip information
+	.sensor_mode = IMGSENSOR_MODE_INIT, //IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
+	.shutter = 0x09AD,					//current shutter
+	.gain = 222,						//current gain
+	.dummy_pixel = 0,					//current dummypixel
+	.dummy_line = 0,					//current dummyline
+	.current_fps = 0,  //full size current fps : 24fps for PIP, 30fps for Normal or ZSD
+	.autoflicker_en = KAL_FALSE,  //auto flicker enable: KAL_FALSE for disable auto flicker, KAL_TRUE for enable auto flicker
+	.test_pattern = KAL_FALSE,		//test pattern mode or not. KAL_FALSE for in test pattern mode, KAL_TRUE for normal output
+	.current_scenario_id = MSDK_SCENARIO_ID_CAMERA_PREVIEW,//current scenario id
+	.ihdr_en = 0, //sensor need support LE, SE with HDR feature
+	.i2c_write_id = 0x6c,
+};
+
+
+/* Sensor output window information */
+static SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[10] =	 
+{{ 3280, 2464,	 0,	0, 3280, 2464, 1640,  1232, 0000, 0000, 1640, 1232,	  0,	0, 1640,  1232}, // Preview 
+ { 3280, 2464,	 0,	0, 3280, 2464, 3280,  2464, 0000, 0000, 3280, 2464,	  0,	0, 3280,  2464}, // capture 
+ { 3280, 2464,	 0,	0, 3280, 2464, 3280,  2464, 0000, 0000, 3280, 2464,	  0,	0, 3280,  2464}, // video 
+ { 3280, 2464,	 0, 0, 3280, 2464,  640,   480, 0000, 0000, 640,  480,	  0,	0, 640,   480}, //hight speed video 
+ { 3280, 2464,	 0, 0, 3280, 2464, 1288,  800,  0000, 0000, 1288,  800,	  2,	2, 1080,  720},// slim video 
+ { 3280, 2464,	 0,	0, 3280, 2464, 1640,  1232, 0000, 0000, 1640, 1232,	  0,	0, 1640,  1232}, // Custom1 (defaultuse preview) 
+ { 3280, 2464,	 0,	0, 3280, 2464, 1640,  1232, 0000, 0000, 1640, 1232,	  0,	0, 1640,  1232}, // Custom2 
+ { 3280, 2464,	 0,	0, 3280, 2464, 1640,  1232, 0000, 0000, 1640, 1232,	  0,	0, 1640,  1232}, // Custom3 
+ { 3280, 2464,	 0,	0, 3280, 2464, 1640,  1232, 0000, 0000, 1640, 1232,	  0,	0, 1640,  1232}, // Custom4 
+ { 3280, 2464,	 0,	0, 3280, 2464, 1640,  1232, 0000, 0000, 1640, 1232,	  0,	0, 1640,  1232}, // Custom5 
+ };// slim video  
+
+// Gain Index
+#define MaxGainIndex (97)
+static kal_uint16 sensorGainMapping[MaxGainIndex][2] ={
+{ 64 ,0  },   
+{ 68 ,12 },   
+{ 71 ,23 },   
+{ 74 ,33 },   
+{ 77 ,42 },   
+{ 81 ,52 },   
+{ 84 ,59 },   
+{ 87 ,66 },   
+{ 90 ,73 },   
+{ 93 ,79 },   
+{ 96 ,85 },   
+{ 100,91 },   
+{ 103,96 },   
+{ 106,101},   
+{ 109,105},   
+{ 113,110},   
+{ 116,114},   
+{ 120,118},   
+{ 122,121},   
+{ 125,125},   
+{ 128,128},   
+{ 132,131},   
+{ 135,134},   
+{ 138,137},
+{ 141,139},
+{ 144,142},   
+{ 148,145},   
+{ 151,147},   
+{ 153,149}, 
+{ 157,151},
+{ 160,153},      
+{ 164,156},   
+{ 168,158},   
+{ 169,159},   
+{ 173,161},   
+{ 176,163},   
+{ 180,165}, 
+{ 182,166},   
+{ 187,168},
+{ 189,169},
+{ 193,171},
+{ 196,172},
+{ 200,174},
+{ 203,175}, 
+{ 205,176},
+{ 208,177}, 
+{ 213,179}, 
+{ 216,180},  
+{ 219,181},   
+{ 222,182},
+{ 225,183},  
+{ 228,184},   
+{ 232,185},
+{ 235,186},
+{ 238,187},
+{ 241,188},
+{ 245,189},
+{ 249,190},
+{ 253,191},
+{ 256,192}, 
+{ 260,193},
+{ 265,194},
+{ 269,195},
+{ 274,196},   
+{ 278,197},
+{ 283,198},
+{ 288,199},
+{ 293,200},
+{ 298,201},   
+{ 304,202},   
+{ 310,203},
+{ 315,204},
+{ 322,205},   
+{ 328,206},   
+{ 335,207},   
+{ 342,208},   
+{ 349,209},   
+{ 357,210},   
+{ 365,211},   
+{ 373,212}, 
+{ 381,213},
+{ 400,215},      
+{ 420,217},   
+{ 432,218},   
+{ 443,219},      
+{ 468,221},   
+{ 482,222},   
+{ 497,223},   
+{ 512,224},
+{ 529,225}, 	 
+{ 546,226},   
+{ 566,227},   
+{ 585,228}, 	 
+{ 607,229},   
+{ 631,230},   
+{ 656,231},   
+{ 683,232}
+};
+
+static kal_uint16 read_cmos_sensor(kal_uint32 addr)
+{
+    kdSetI2CSpeed(imgsensor_info.i2c_speed); // Add this func to set i2c speed by each sensor
+	kal_uint16 get_byte=0;
+
+	char pu_send_cmd[2] = {(char)(addr >> 8), (char)(addr & 0xFF) };
+	iReadRegI2C(pu_send_cmd, 2, (u8*)&get_byte, 1, imgsensor.i2c_write_id);
+	return get_byte;
+}
+
+static void write_cmos_sensor(kal_uint32 addr, kal_uint32 para)
+{
+    kdSetI2CSpeed(imgsensor_info.i2c_speed); // Add this func to set i2c speed by each sensor
+	char pu_send_cmd[3] = {(char)(addr >> 8), (char)(addr & 0xFF), (char)(para & 0xFF)};
+	iWriteRegI2C(pu_send_cmd, 3, imgsensor.i2c_write_id);
+}
+
+static kal_uint16 read_cmos_sensor_8(kal_uint16 addr)
+{
+    kdSetI2CSpeed(imgsensor_info.i2c_speed); // Add this func to set i2c speed by each sensor
+    kal_uint16 get_byte=0;
+    char pu_send_cmd[2] = {(char)(addr >> 8) , (char)(addr & 0xFF) };
+    iReadRegI2C(pu_send_cmd , 2, (u8*)&get_byte,1,imgsensor.i2c_write_id);
+    return get_byte;
+}
+
+
+static void write_cmos_sensor_8(kal_uint16 addr, kal_uint8 para)
+{
+    kdSetI2CSpeed(imgsensor_info.i2c_speed); // Add this func to set i2c speed by each sensor
+	char pu_send_cmd[4] = {(char)(addr >> 8), (char)(addr & 0xFF), (char)(para & 0xFF)};
+	iWriteRegI2C(pu_send_cmd, 3, imgsensor.i2c_write_id);
+}   
+static void set_dummy()
+{
+	LOG_INF("dummyline = %d, dummypixels = %d \n", imgsensor.dummy_line, imgsensor.dummy_pixel);
+    write_cmos_sensor_8(0x0104, 0x01); 
+    write_cmos_sensor(0x0340, (imgsensor.frame_length >>8) & 0xFF);
+    write_cmos_sensor(0x0341, imgsensor.frame_length & 0xFF);	
+    write_cmos_sensor(0x0342, (imgsensor.line_length >>8) & 0xFF);
+    write_cmos_sensor(0x0343, imgsensor.line_length & 0xFF);
+    write_cmos_sensor_8(0x0104, 0x00);  
+}	/*	set_dummy  */
+
+
+static kal_uint32 return_sensor_id()
+{
+    return (((read_cmos_sensor(0x0002)&&0x0f)<<8)  | (read_cmos_sensor(0x0003)) );;
+}
+static void set_max_framerate(UINT16 framerate,kal_bool min_framelength_en)
+{
+	kal_int16 dummy_line;
+	kal_uint32 frame_length = imgsensor.frame_length;
+	//unsigned long flags;
+	LOG_INF("framerate = %d, min framelength should enable? \n", framerate,min_framelength_en);   
+	frame_length = imgsensor.pclk / framerate * 10 / imgsensor.line_length;
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.frame_length = (frame_length > imgsensor.min_frame_length)?frame_length:imgsensor.min_frame_length;
+	imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
+	//dummy_line = frame_length - imgsensor.min_frame_length;
+	//if (dummy_line < 0)
+	//	imgsensor.dummy_line = 0;
+	//else
+	//	imgsensor.dummy_line = dummy_line;
+	//imgsensor.frame_length = frame_length + imgsensor.dummy_line;
+	if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+	{
+		imgsensor.frame_length = imgsensor_info.max_frame_length;
+		imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
+	}
+	if (min_framelength_en)
+		imgsensor.min_frame_length = imgsensor.frame_length;
+	spin_unlock(&imgsensor_drv_lock);
+	set_dummy();
+}	/*	set_max_framerate  */
+
+
+
+/*************************************************************************
+* FUNCTION
+*    set_shutter
+*
+* DESCRIPTION
+*    This function set e-shutter of sensor to change exposure time.
+*
+* PARAMETERS
+*    iShutter : exposured lines
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static void set_shutter(kal_uint16 shutter)
+{
+    unsigned long flags;
+    kal_uint16 realtime_fps = 0;
+    kal_uint32 frame_length = 0;
+    spin_lock_irqsave(&imgsensor_drv_lock, flags);
+    imgsensor.shutter = shutter;
+    spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
+
+    //write_shutter(shutter);
+    /* 0x3500, 0x3501, 0x3502 will increase VBLANK to get exposure larger than frame exposure */
+    /* AE doesn't update sensor gain at capture mode, thus extra exposure lines must be updated here. */
+
+    // OV Recommend Solution
+    // if shutter bigger than frame_length, should extend frame length first
+    spin_lock(&imgsensor_drv_lock);
+    if (shutter > imgsensor.min_frame_length - imgsensor_info.margin)
+        imgsensor.frame_length = shutter + imgsensor_info.margin;
+    else
+        imgsensor.frame_length = imgsensor.min_frame_length;
+    if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+        imgsensor.frame_length = imgsensor_info.max_frame_length;
+    spin_unlock(&imgsensor_drv_lock);
+    shutter = (shutter < imgsensor_info.min_shutter) ? imgsensor_info.min_shutter : shutter;
+    shutter = (shutter > (imgsensor_info.max_frame_length - imgsensor_info.margin)) ? (imgsensor_info.max_frame_length - imgsensor_info.margin) : shutter;
+
+    if (imgsensor.autoflicker_en) {
+        realtime_fps = imgsensor.pclk / imgsensor.line_length * 10 / imgsensor.frame_length;
+        if(realtime_fps >= 297 && realtime_fps <= 305)
+            set_max_framerate(296,0);
+        else if(realtime_fps >= 147 && realtime_fps <= 150)
+            set_max_framerate(146,0);
+        else {
+        // Extend frame length
+		write_cmos_sensor_8(0x0104, 0x01); 
+		write_cmos_sensor(0x0340, (imgsensor.frame_length >> 8) & 0xFF);
+		write_cmos_sensor(0x0341, imgsensor.frame_length & 0xFF);
+
+
+        }
+    } else {
+        // Extend frame length
+		write_cmos_sensor_8(0x0104, 0x01); 
+		write_cmos_sensor(0x0340, (imgsensor.frame_length >> 8) & 0xFF);
+		write_cmos_sensor(0x0341, imgsensor.frame_length & 0xFF);
+
+
+    }
+
+    // Update Shutter
+
+	write_cmos_sensor(0x0202, (shutter >> 8) & 0xFF);
+	write_cmos_sensor(0x0203, shutter  & 0xFF);	
+	write_cmos_sensor_8(0x0104, 0x00); 
+    LOG_INF("Exit! shutter =%d, framelength =%d\n", shutter,imgsensor.frame_length);
+
+}    /*    set_shutter */
+
+
+
+static kal_uint16 gain2reg(const kal_uint16 gain)
+{
+    kal_uint8 iI;	    
+    for (iI = 0; iI < (MaxGainIndex-1); iI++) 
+	{
+        if(gain <= sensorGainMapping[iI][0])
+		{    
+            break;
+        }
+    }
+/*
+    if(gain != sensorGainMapping[iI][0])
+    {
+         //SENSORDB("Gain mapping don't correctly:%d %d \n", gain, sensorGainMapping[iI][0]);		 
+		 return sensorGainMapping[iI][1];
+    }
+    else return (kal_uint16)gain;
+*/
+	return sensorGainMapping[iI][1];
+
+}
+
+/*************************************************************************
+* FUNCTION
+*	set_gain
+*
+* DESCRIPTION
+*	This function is to set global gain to sensor.
+*
+* PARAMETERS
+*	iGain : sensor global gain(base: 0x40)
+*
+* RETURNS
+*	the actually gain set to sensor.
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint16 set_gain(kal_uint16 gain)
+{
+	kal_uint16 reg_gain;
+
+	/* 0x350A[0:1], 0x350B[0:7] AGC real gain */
+	/* [0:3] = N meams N /16 X	*/
+	/* [4:9] = M meams M X		 */
+	/* Total gain = M + N /16 X   */
+	if (gain < BASEGAIN || gain > 32 * BASEGAIN) 
+	{
+		LOG_INF("Error gain setting");
+		if (gain < BASEGAIN)
+			gain = BASEGAIN;
+		else if (gain > 32 * BASEGAIN)
+			gain = 32 * BASEGAIN;		 
+	}
+	reg_gain = gain2reg(gain);
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.gain = reg_gain; 
+	spin_unlock(&imgsensor_drv_lock);
+	LOG_INF("gain = %d , reg_gain = 0x%x\n ", gain, reg_gain);
+	write_cmos_sensor_8(0x0104, 0x01); 
+	write_cmos_sensor(0x0205, reg_gain & 0xFF);
+	write_cmos_sensor_8(0x0104, 0x00); 	
+	return gain;
+}	/*	set_gain  */
+static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gain)
+{
+    LOG_INF("le:0x%x, se:0x%x, gain:0x%x\n",le,se,gain);
+    if (imgsensor.ihdr_en) {
+
+        spin_lock(&imgsensor_drv_lock);
+        if (le > imgsensor.min_frame_length - imgsensor_info.margin)
+            imgsensor.frame_length = le + imgsensor_info.margin;
+        else
+            imgsensor.frame_length = imgsensor.min_frame_length;
+        if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+            imgsensor.frame_length = imgsensor_info.max_frame_length;
+        spin_unlock(&imgsensor_drv_lock);
+        if (le < imgsensor_info.min_shutter) le = imgsensor_info.min_shutter;
+        if (se < imgsensor_info.min_shutter) se = imgsensor_info.min_shutter;
+
+
+        // Extend frame length first
+        write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
+        write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
+
+        write_cmos_sensor(0x3502, (le << 4) & 0xFF);
+        write_cmos_sensor(0x3501, (le >> 4) & 0xFF);
+        write_cmos_sensor(0x3500, (le >> 12) & 0x0F);
+
+        write_cmos_sensor(0x3508, (se << 4) & 0xFF);
+        write_cmos_sensor(0x3507, (se >> 4) & 0xFF);
+        write_cmos_sensor(0x3506, (se >> 12) & 0x0F);
+
+        set_gain(gain);
+    }
+
+}
+static void set_mirror_flip(kal_uint8 image_mirror)
+{
+	LOG_INF("image_mirror = %d\n", image_mirror);
+
+	/********************************************************
+	   *
+	   *   0x0101 Sensor mirror flip 
+	   *
+	   *   ISP and Sensor flip or mirror register bit should be the same!!
+	   *
+	   ********************************************************/
+	kal_uint8  iTemp; 
+	
+	iTemp = read_cmos_sensor(0x0101);
+	iTemp&= ~0x03; //Clear the mirror and flip bits.
+	switch (image_mirror) 
+	{
+		case IMAGE_NORMAL:
+			write_cmos_sensor_8(0x0101, iTemp);    //Set normal
+			break;
+		case IMAGE_H_MIRROR:
+            write_cmos_sensor_8(0x0101, iTemp | 0x01); //Set mirror
+			break;
+		case IMAGE_V_MIRROR:
+            write_cmos_sensor_8(0x0101, iTemp | 0x02); //Set flip
+			break;
+		case IMAGE_HV_MIRROR:
+            write_cmos_sensor_8(0x0101, iTemp | 0x03); //Set mirror and flip
+			break;
+		default:
+			LOG_INF("Error image_mirror setting\n");
+	}
+
+}
+
+/*************************************************************************
+* FUNCTION
+*	night_mode
+*
+* DESCRIPTION
+*	This function night mode of sensor.
+*
+* PARAMETERS
+*	bEnable: KAL_TRUE -> enable night mode, otherwise, disable night mode
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static void night_mode(kal_bool enable)
+{
+/*No Need to implement this function*/ 
+}	/*	night_mode	*/
+
+static void sensor_init(void)
+{
+	LOG_INF("E\n");
+	write_cmos_sensor(0x41C0, 0x01);
+	write_cmos_sensor(0x0104, 0x01);//group
+	write_cmos_sensor(0x0100, 0x00);//STREAM OFF    
+	write_cmos_sensor(0x0103, 0x01);//SW reset
+	//write_cmos_sensor(0x0101, 0x01); 		
+	write_cmos_sensor(0x030E, 0x01); 		  
+	write_cmos_sensor(0x0202, 0x09); //0x0202, 0x09		
+	write_cmos_sensor(0x0203, 0xcc);//(0x0203, 0xcc)
+	//PLL Setting
+	write_cmos_sensor(0x0301, 0x05); 		
+	write_cmos_sensor(0x0303, 0x01); 		
+	write_cmos_sensor(0x0305, 0x06); 		
+	write_cmos_sensor(0x0309, 0x05); 		
+	write_cmos_sensor(0x030B, 0x01); 		
+	write_cmos_sensor(0x030C, 0x00); 		
+	write_cmos_sensor(0x030D, 0xA2); //(0x030D, 0xA2)
+	write_cmos_sensor(0x030E, 0x01);
+
+	write_cmos_sensor(0x0340, 0x09);//(0x0340, 0x09)
+	write_cmos_sensor(0x0341, 0xD0); 		
+	write_cmos_sensor(0x0342, 0x0D); 	   
+	write_cmos_sensor(0x0343, 0x70);//(0x0343, 0x0D) 		
+	write_cmos_sensor(0x0344, 0x00); 		
+	write_cmos_sensor(0x0345, 0x00); 		
+	write_cmos_sensor(0x0346, 0x00); 		
+	write_cmos_sensor(0x0347, 0x00);// (0x0347, 0x00)		
+	write_cmos_sensor(0x0348, 0x0C); 	   
+	write_cmos_sensor(0x0349, 0xCF); 		
+	write_cmos_sensor(0x034A, 0x09);// (0x034A, 0x09)		
+	write_cmos_sensor(0x034B, 0x9F);//(0x034B, 0x9F) 		
+	write_cmos_sensor(0x034C, 0x06); 		
+	write_cmos_sensor(0x034D, 0x68); 		
+	write_cmos_sensor(0x034E, 0x04); 		
+	write_cmos_sensor(0x034F, 0xD0);//(0x034F, 0xD0) 		
+	write_cmos_sensor(0x0383, 0x01); 		
+	write_cmos_sensor(0x0387, 0x01); 	   
+	write_cmos_sensor(0x0390, 0x01); 		
+	write_cmos_sensor(0x0401, 0x00); 		
+	write_cmos_sensor(0x0405, 0x10); 		
+	write_cmos_sensor(0x3020, 0x10); 		
+	write_cmos_sensor(0x3041, 0x15); 		
+	write_cmos_sensor(0x3042, 0x87); 		
+	write_cmos_sensor(0x3089, 0x4F); 		
+	write_cmos_sensor(0x3309, 0x9A); 		
+	write_cmos_sensor(0x3344, 0x57);//(0x3344, 0x57) 		
+	write_cmos_sensor(0x3345, 0x1F); 		
+	write_cmos_sensor(0x3362, 0x0A); 		
+	write_cmos_sensor(0x3363, 0x0A); 		
+	write_cmos_sensor(0x3364, 0x00); 	   
+	write_cmos_sensor(0x3368, 0x18); 		
+	write_cmos_sensor(0x3369, 0x00); 		
+	write_cmos_sensor(0x3370, 0x77);// (0x3370, 0x77)			
+	write_cmos_sensor(0x3371, 0x2F);//(0x3371, 0x2F) 			
+	write_cmos_sensor(0x3372, 0x4F); 			
+	write_cmos_sensor(0x3373, 0x2F); 			
+	write_cmos_sensor(0x3374, 0x2F); 			
+	write_cmos_sensor(0x3375, 0x37); 			
+	write_cmos_sensor(0x3376, 0x9F); 			
+	write_cmos_sensor(0x3377, 0x37); 			
+	write_cmos_sensor(0x33C8, 0x00); 			
+	write_cmos_sensor(0x33D4, 0x06); 			
+	write_cmos_sensor(0x33D5, 0x68); 			
+	write_cmos_sensor(0x33D6, 0x04); 			
+	write_cmos_sensor(0x33D7, 0xD0); 			
+	write_cmos_sensor(0x4100, 0x0E); 			
+	write_cmos_sensor(0x4108, 0x01); 			
+	write_cmos_sensor(0x4109, 0x7C);
+	write_cmos_sensor(0x3302, 0x01);
+	write_cmos_sensor(0x0104, 0x00);//group
+	write_cmos_sensor(0x0100, 0x01);//STREAM ON
+}	/*	sensor_init  */
+
+
+static void preview_setting(void)
+{
+	//5.1.2 FQPreview 1640x1232 30fps 24M MCLK 4lane 256Mbps/lane
+	LOG_INF("E\n");
+	write_cmos_sensor(0x41C0, 0x01);
+	write_cmos_sensor(0x0104, 0x01);//group
+	write_cmos_sensor(0x0100, 0x00);//STREAM OFF 
+	//write_cmos_sensor(0x0101, 0x00); 
+	//write_cmos_sensor(0x0103, 0x01);//SW reset		 		   
+	write_cmos_sensor(0x0202, 0x09); //0x0202, 0x09		 
+	write_cmos_sensor(0x0203, 0xAD);//(0x0203, 0xcc)
+	//PLL setting
+	write_cmos_sensor(0x0301, 0x05); 		 
+	write_cmos_sensor(0x0303, 0x01); 		 
+	write_cmos_sensor(0x0305, 0x06); 		 
+	write_cmos_sensor(0x0309, 0x05); 		 
+	write_cmos_sensor(0x030B, 0x01); 		 
+	write_cmos_sensor(0x030C, 0x00); 		 
+	write_cmos_sensor(0x030D, 0xA0); //(0x030D, 0xA2)
+	write_cmos_sensor(0x030E, 0x01);
+	
+	write_cmos_sensor(0x0340, 0x09);//(0x0340, 0x09)
+	write_cmos_sensor(0x0341, 0xB1); 		 
+	write_cmos_sensor(0x0342, 0x0D); 		
+	write_cmos_sensor(0x0343, 0x70);//(0x0343, 0x0D) 		 
+	write_cmos_sensor(0x0344, 0x00); 		 
+	write_cmos_sensor(0x0345, 0x00); 		 
+	write_cmos_sensor(0x0346, 0x00); 		 
+	write_cmos_sensor(0x0347, 0x00);// (0x0347, 0x00)		 
+	write_cmos_sensor(0x0348, 0x0C); 		
+	write_cmos_sensor(0x0349, 0xCF); 		 
+	write_cmos_sensor(0x034A, 0x09);// (0x034A, 0x09)		 
+	write_cmos_sensor(0x034B, 0x9F);//(0x034B, 0x9F) 		 
+	write_cmos_sensor(0x034C, 0x06); 		 
+	write_cmos_sensor(0x034D, 0x68); 		 
+	write_cmos_sensor(0x034E, 0x04); 		 
+	write_cmos_sensor(0x034F, 0xD0);//(0x034F, 0xD0)		 
+	write_cmos_sensor(0x0383, 0x01); 		 
+	write_cmos_sensor(0x0387, 0x01); 		
+	write_cmos_sensor(0x0390, 0x01); 		 
+	write_cmos_sensor(0x0401, 0x00); 		 
+	write_cmos_sensor(0x0405, 0x10); 		 
+	write_cmos_sensor(0x3020, 0x10); 		 
+	write_cmos_sensor(0x3041, 0x15); 		 
+	write_cmos_sensor(0x3042, 0x87); 		 
+	write_cmos_sensor(0x3089, 0x4F); 		 
+	write_cmos_sensor(0x3309, 0x9A); 		 
+	write_cmos_sensor(0x3344, 0x57);//(0x3344, 0x57)		 
+	write_cmos_sensor(0x3345, 0x1F); 		 
+	write_cmos_sensor(0x3362, 0x0A); 		 
+	write_cmos_sensor(0x3363, 0x0A); 		 
+	write_cmos_sensor(0x3364, 0x00); 		
+	write_cmos_sensor(0x3368, 0x18); 		 
+	write_cmos_sensor(0x3369, 0x00); 		 
+	write_cmos_sensor(0x3370, 0x77);// (0x3370, 0x77)		 	 
+	write_cmos_sensor(0x3371, 0x2F);//(0x3371, 0x2F)             
+	write_cmos_sensor(0x3372, 0x4F);             
+	write_cmos_sensor(0x3373, 0x2F);             
+	write_cmos_sensor(0x3374, 0x2F);             
+	write_cmos_sensor(0x3375, 0x37);             
+	write_cmos_sensor(0x3376, 0x9F);             
+	write_cmos_sensor(0x3377, 0x37);             
+	write_cmos_sensor(0x33C8, 0x00);             
+	write_cmos_sensor(0x33D4, 0x06);             
+	write_cmos_sensor(0x33D5, 0x68);             
+	write_cmos_sensor(0x33D6, 0x04);             
+	write_cmos_sensor(0x33D7, 0xD0);             
+	write_cmos_sensor(0x4100, 0x0E);             
+	write_cmos_sensor(0x4108, 0x01);             
+	write_cmos_sensor(0x4109, 0x7C);
+	write_cmos_sensor(0x0104, 0x00);//group
+	write_cmos_sensor(0x0100, 0x01);//STREAM ON	
+// The register only need to enable 1 time.     
+}	/*	preview_setting  */
+
+static void capture_setting(kal_uint16 currefps)
+{
+	LOG_INF("E! currefps:%d\n",currefps);
+	if (currefps == 240) 
+	{ //24fps for PIP //@@full_132PCLK_24.75
+	 //5.1.2 FQPreview 3280x2464 30fps 24M MCLK 4lane 204.8Mbps/lane
+		write_cmos_sensor(0x41C0, 0x01);
+		write_cmos_sensor(0x0104, 0x01);//group
+		write_cmos_sensor(0x0100, 0x00);//STREAM OFF 
+		//write_cmos_sensor(0x0101, 0x00); 
+		//write_cmos_sensor(0x0103, 0x01);//SW reset		 		   
+		write_cmos_sensor(0x0202, 0x09); //0x0202, 0x09		 
+		write_cmos_sensor(0x0203, 0xAD);//(0x0203, 0xcc)
+		//PLL setting
+		write_cmos_sensor(0x0301, 0x05); 		 
+		write_cmos_sensor(0x0303, 0x01); 		 
+		write_cmos_sensor(0x0305, 0x06); 		 
+		write_cmos_sensor(0x0309, 0x05); 		 
+		write_cmos_sensor(0x030B, 0x01); 		 
+		write_cmos_sensor(0x030C, 0x00); 		 
+		write_cmos_sensor(0x030D, 0x80); //(0x030D, 0xA2)
+		write_cmos_sensor(0x030E, 0x01);
+		
+		write_cmos_sensor(0x0340, 0x09);//(0x0340, 0x09)
+		write_cmos_sensor(0x0341, 0xB1); 		 
+		write_cmos_sensor(0x0342, 0x0D); 		
+		write_cmos_sensor(0x0343, 0x70);//(0x0343, 0x0D) 		 
+		write_cmos_sensor(0x0344, 0x00); 		 
+		write_cmos_sensor(0x0345, 0x00); 		 
+		write_cmos_sensor(0x0346, 0x00); 		 
+		write_cmos_sensor(0x0347, 0x00);// (0x0347, 0x00)		 
+		write_cmos_sensor(0x0348, 0x0C); 		
+		write_cmos_sensor(0x0349, 0xCF); 		 
+		write_cmos_sensor(0x034A, 0x09);// (0x034A, 0x09)		 
+		write_cmos_sensor(0x034B, 0x9F);//(0x034B, 0x9F) 		 
+		write_cmos_sensor(0x034C, 0x0C); 		 
+		write_cmos_sensor(0x034D, 0xD0); 		 
+		write_cmos_sensor(0x034E, 0x09); 		 
+		write_cmos_sensor(0x034F, 0xA0);//(0x034F, 0xD0)		 
+		write_cmos_sensor(0x0383, 0x01); 		 
+		write_cmos_sensor(0x0387, 0x01); 		
+		write_cmos_sensor(0x0390, 0x00); 		 
+		write_cmos_sensor(0x0401, 0x00); 		 
+		write_cmos_sensor(0x0405, 0x10); 		 
+		write_cmos_sensor(0x3020, 0x10); 		 
+		write_cmos_sensor(0x3041, 0x15); 		 
+		write_cmos_sensor(0x3042, 0x87); 		 
+		write_cmos_sensor(0x3089, 0x4F); 		 
+		write_cmos_sensor(0x3309, 0x9A); 		 
+		write_cmos_sensor(0x3344, 0x4F);//(0x3344, 0x57)		 
+		write_cmos_sensor(0x3345, 0x1F); 		 
+		write_cmos_sensor(0x3362, 0x0A); 		 
+		write_cmos_sensor(0x3363, 0x0A); 		 
+		write_cmos_sensor(0x3364, 0x00); 		
+		write_cmos_sensor(0x3368, 0x18); 		 
+		write_cmos_sensor(0x3369, 0x00); 		 
+		write_cmos_sensor(0x3370, 0x6F);// (0x3370, 0x77)		 	 
+		write_cmos_sensor(0x3371, 0x27);//(0x3371, 0x2F)             
+		write_cmos_sensor(0x3372, 0x47);             
+		write_cmos_sensor(0x3373, 0x27);             
+		write_cmos_sensor(0x3374, 0x27);             
+		write_cmos_sensor(0x3375, 0x27);             
+		write_cmos_sensor(0x3376, 0x8F);             
+		write_cmos_sensor(0x3377, 0x37);             
+		write_cmos_sensor(0x33C8, 0x00);             
+		write_cmos_sensor(0x33D4, 0x0C);             
+		write_cmos_sensor(0x33D5, 0xD0);             
+		write_cmos_sensor(0x33D6, 0x09);             
+		write_cmos_sensor(0x33D7, 0xA0);             
+		write_cmos_sensor(0x4100, 0x0E);             
+		write_cmos_sensor(0x4108, 0x01);             
+		write_cmos_sensor(0x4109, 0x7C);
+		write_cmos_sensor(0x3302, 0x01);
+		write_cmos_sensor(0x0104, 0x00);//group
+		write_cmos_sensor(0x0100, 0x01);//STREAM ON
+	}
+	else if(currefps == 150) 
+	{ //D1 15fps for PIP //@@full_132PCLK_24.75
+	 
+		write_cmos_sensor(0x41C0, 0x01);
+		write_cmos_sensor(0x0104, 0x01);//group
+		write_cmos_sensor(0x0100, 0x00);//STREAM OFF 
+		//write_cmos_sensor(0x0101, 0x00); 
+		//write_cmos_sensor(0x0103, 0x01);//SW reset		 		   
+		write_cmos_sensor(0x0202, 0x7C); //0x0202, 0x09		 
+		write_cmos_sensor(0x0203, 0x7C);//(0x0203, 0xcc)
+		//PLL setting
+		write_cmos_sensor(0x0301, 0x2F); 		 
+		write_cmos_sensor(0x0303, 0x2F); 		 
+		write_cmos_sensor(0x0305, 0x2F); 		 
+		write_cmos_sensor(0x0309, 0x9F); 		 
+		write_cmos_sensor(0x030B, 0x37); 		 
+		write_cmos_sensor(0x030C, 0x4F); 		 
+		write_cmos_sensor(0x030D, 0x4F); //(0x030D, 0xA2)
+		write_cmos_sensor(0x030E, 0x01);
+		
+		write_cmos_sensor(0x0340, 0x0A);//(0x0340, 0x09)
+		write_cmos_sensor(0x0341, 0x4C); 		 
+		write_cmos_sensor(0x0342, 0x0D); 		
+		write_cmos_sensor(0x0343, 0x70);//(0x0343, 0x0D) 		 
+		write_cmos_sensor(0x0344, 0x00); 		 
+		write_cmos_sensor(0x0345, 0x00); 		 
+		write_cmos_sensor(0x0346, 0x00); 		 
+		write_cmos_sensor(0x0347, 0x00);// (0x0347, 0x00)		 
+		write_cmos_sensor(0x0348, 0x0C); 		
+		write_cmos_sensor(0x0349, 0xCF); 		 
+		write_cmos_sensor(0x034A, 0x09);// (0x034A, 0x09)		 
+		write_cmos_sensor(0x034B, 0x9F);//(0x034B, 0x9F) 		 
+		write_cmos_sensor(0x034C, 0x0C); 		 
+		write_cmos_sensor(0x034D, 0xD0); 		 
+		write_cmos_sensor(0x034E, 0x09); 		 
+		write_cmos_sensor(0x034F, 0xA0);//(0x034F, 0xD0)		 
+		write_cmos_sensor(0x0383, 0x01); 		 
+		write_cmos_sensor(0x0387, 0x01); 		
+		write_cmos_sensor(0x0390, 0x00); 		 
+		write_cmos_sensor(0x0401, 0x00); 		 
+		write_cmos_sensor(0x0405, 0x10); 		 
+		write_cmos_sensor(0x3020, 0x10); 		 
+		write_cmos_sensor(0x3041, 0x15); 		 
+		write_cmos_sensor(0x3042, 0x87); 		 
+		write_cmos_sensor(0x3089, 0x4F); 		 
+		write_cmos_sensor(0x3309, 0x9A); 		 
+		write_cmos_sensor(0x3344, 0x37);//(0x3344, 0x57)		 
+		write_cmos_sensor(0x3345, 0x1F); 		 
+		write_cmos_sensor(0x3362, 0x0A); 		 
+		write_cmos_sensor(0x3363, 0x0A); 		 
+		write_cmos_sensor(0x3364, 0x00); 		
+		write_cmos_sensor(0x3368, 0x18); 		 
+		write_cmos_sensor(0x3369, 0x00); 		 
+		write_cmos_sensor(0x3370, 0x5F);// (0x3370, 0x77)		 	 
+		write_cmos_sensor(0x3371, 0x17);//(0x3371, 0x2F)             
+		write_cmos_sensor(0x3372, 0x3F);             
+		write_cmos_sensor(0x3373, 0x1F);             
+		write_cmos_sensor(0x3374, 0x1F);             
+		write_cmos_sensor(0x3375, 0x17);             
+		write_cmos_sensor(0x3376, 0x5F);             
+		write_cmos_sensor(0x3377, 0x27);             
+		write_cmos_sensor(0x33C8, 0x00);             
+		write_cmos_sensor(0x33D4, 0x0C);             
+		write_cmos_sensor(0x33D5, 0xD0);             
+		write_cmos_sensor(0x33D6, 0x09);             
+		write_cmos_sensor(0x33D7, 0xA0);             
+		write_cmos_sensor(0x4100, 0x0E);             
+		write_cmos_sensor(0x4108, 0x01);             
+		write_cmos_sensor(0x4109, 0x7C);
+		write_cmos_sensor(0x3302, 0x01);
+		write_cmos_sensor(0x0104, 0x00);//group
+		write_cmos_sensor(0x0100, 0x01);//STREAM ON
+	}
+	else
+	{   //30fps		
+		//30fps for Normal capture & ZSD
+		//5.1.2 FQPreview 3280x2464 30fps 24M MCLK 4lane 256Mbps/lane
+	    write_cmos_sensor(0x41C0, 0x01);
+		write_cmos_sensor(0x0104, 0x01);//group
+		write_cmos_sensor(0x0100, 0x00);//STREAM OFF 
+		//write_cmos_sensor(0x0101, 0x00); 
+		//write_cmos_sensor(0x0103, 0x01);//SW reset		 		   
+		write_cmos_sensor(0x0202, 0x09); //0x0202, 0x09		 
+		write_cmos_sensor(0x0203, 0xAD);//(0x0203, 0xcc)
+		//PLL setting
+		write_cmos_sensor(0x0301, 0x05); 		 
+		write_cmos_sensor(0x0303, 0x01); 		 
+		write_cmos_sensor(0x0305, 0x06); 		 
+		write_cmos_sensor(0x0309, 0x05); 		 
+		write_cmos_sensor(0x030B, 0x01); 		 
+		write_cmos_sensor(0x030C, 0x00); 		 
+		write_cmos_sensor(0x030D, 0xA0); //(0x030D, 0xA2)
+		write_cmos_sensor(0x030E, 0x01);
+		
+		write_cmos_sensor(0x0340, 0x09);//(0x0340, 0x09)
+		write_cmos_sensor(0x0341, 0xB1); 		 
+		write_cmos_sensor(0x0342, 0x0D); 		
+		write_cmos_sensor(0x0343, 0x70);//(0x0343, 0x0D) 		 
+		write_cmos_sensor(0x0344, 0x00); 		 
+		write_cmos_sensor(0x0345, 0x00); 		 
+		write_cmos_sensor(0x0346, 0x00); 		 
+		write_cmos_sensor(0x0347, 0x00);// (0x0347, 0x00)		 
+		write_cmos_sensor(0x0348, 0x0C); 		
+		write_cmos_sensor(0x0349, 0xCF); 		 
+		write_cmos_sensor(0x034A, 0x09);// (0x034A, 0x09)		 
+		write_cmos_sensor(0x034B, 0x9F);//(0x034B, 0x9F) 		 
+		write_cmos_sensor(0x034C, 0x0C); 		 
+		write_cmos_sensor(0x034D, 0xD0); 		 
+		write_cmos_sensor(0x034E, 0x09); 		 
+		write_cmos_sensor(0x034F, 0xA0);//(0x034F, 0xD0)		 
+		write_cmos_sensor(0x0383, 0x01); 		 
+		write_cmos_sensor(0x0387, 0x01); 		
+		write_cmos_sensor(0x0390, 0x00); 		 
+		write_cmos_sensor(0x0401, 0x00); 		 
+		write_cmos_sensor(0x0405, 0x10); 		 
+		write_cmos_sensor(0x3020, 0x10); 		 
+		write_cmos_sensor(0x3041, 0x15); 		 
+		write_cmos_sensor(0x3042, 0x87); 		 
+		write_cmos_sensor(0x3089, 0x4F); 		 
+		write_cmos_sensor(0x3309, 0x9A); 		 
+		write_cmos_sensor(0x3344, 0x57);//(0x3344, 0x57)		 
+		write_cmos_sensor(0x3345, 0x1F); 		 
+		write_cmos_sensor(0x3362, 0x0A); 		 
+		write_cmos_sensor(0x3363, 0x0A); 		 
+		write_cmos_sensor(0x3364, 0x00); 		
+		write_cmos_sensor(0x3368, 0x18); 		 
+		write_cmos_sensor(0x3369, 0x00); 		 
+		write_cmos_sensor(0x3370, 0x77);// (0x3370, 0x77)		 	 
+		write_cmos_sensor(0x3371, 0x2F);//(0x3371, 0x2F)             
+		write_cmos_sensor(0x3372, 0x4F);             
+		write_cmos_sensor(0x3373, 0x2F);             
+		write_cmos_sensor(0x3374, 0x2F);             
+		write_cmos_sensor(0x3375, 0x37);             
+		write_cmos_sensor(0x3376, 0x9F);             
+		write_cmos_sensor(0x3377, 0x37);             
+		write_cmos_sensor(0x33C8, 0x00);             
+		write_cmos_sensor(0x33D4, 0x0C);             
+		write_cmos_sensor(0x33D5, 0xD0);             
+		write_cmos_sensor(0x33D6, 0x09);             
+		write_cmos_sensor(0x33D7, 0xA0);             
+		write_cmos_sensor(0x4100, 0x0E);             
+		write_cmos_sensor(0x4108, 0x01);             
+		write_cmos_sensor(0x4109, 0x7C);
+		write_cmos_sensor(0x3302, 0x01);
+		write_cmos_sensor(0x0104, 0x00);//group
+		write_cmos_sensor(0x0100, 0x01);//STREAM ON		
+	}	
+}
+
+static void normal_video_setting(kal_uint16 currefps)
+{		
+		//30fps for Normal capture & ZSD
+		//5.1.2 FQPreview 3280x2464 30fps 24M MCLK 4lane 256Mbps/lane
+		LOG_INF("E! currefps:%d\n",currefps);
+	    write_cmos_sensor(0x41C0, 0x01);
+		write_cmos_sensor(0x0104, 0x01);//group
+		write_cmos_sensor(0x0100, 0x00);//STREAM OFF 
+		//write_cmos_sensor(0x0101, 0x00); 
+		//write_cmos_sensor(0x0103, 0x01);//SW reset		 		   
+		write_cmos_sensor(0x0202, 0x09); //0x0202, 0x09		 
+		write_cmos_sensor(0x0203, 0xAD);//(0x0203, 0xcc)
+		//PLL setting
+		write_cmos_sensor(0x0301, 0x05); 		 
+		write_cmos_sensor(0x0303, 0x01); 		 
+		write_cmos_sensor(0x0305, 0x06); 		 
+		write_cmos_sensor(0x0309, 0x05); 		 
+		write_cmos_sensor(0x030B, 0x01); 		 
+		write_cmos_sensor(0x030C, 0x00); 		 
+		write_cmos_sensor(0x030D, 0xA0); //(0x030D, 0xA2)
+		write_cmos_sensor(0x030E, 0x01);
+		
+		write_cmos_sensor(0x0340, 0x09);//(0x0340, 0x09)
+		write_cmos_sensor(0x0341, 0xB1); 		 
+		write_cmos_sensor(0x0342, 0x0D); 		
+		write_cmos_sensor(0x0343, 0x70);//(0x0343, 0x0D) 		 
+		write_cmos_sensor(0x0344, 0x00); 		 
+		write_cmos_sensor(0x0345, 0x00); 		 
+		write_cmos_sensor(0x0346, 0x00); 		 
+		write_cmos_sensor(0x0347, 0x00);// (0x0347, 0x00)		 
+		write_cmos_sensor(0x0348, 0x0C); 		
+		write_cmos_sensor(0x0349, 0xCF); 		 
+		write_cmos_sensor(0x034A, 0x09);// (0x034A, 0x09)		 
+		write_cmos_sensor(0x034B, 0x9F);//(0x034B, 0x9F) 		 
+		write_cmos_sensor(0x034C, 0x0C); 		 
+		write_cmos_sensor(0x034D, 0xD0); 		 
+		write_cmos_sensor(0x034E, 0x09); 		 
+		write_cmos_sensor(0x034F, 0xA0);//(0x034F, 0xD0)		 
+		write_cmos_sensor(0x0383, 0x01); 		 
+		write_cmos_sensor(0x0387, 0x01); 		
+		write_cmos_sensor(0x0390, 0x00); 		 
+		write_cmos_sensor(0x0401, 0x00); 		 
+		write_cmos_sensor(0x0405, 0x10); 		 
+		write_cmos_sensor(0x3020, 0x10); 		 
+		write_cmos_sensor(0x3041, 0x15); 		 
+		write_cmos_sensor(0x3042, 0x87); 		 
+		write_cmos_sensor(0x3089, 0x4F); 		 
+		write_cmos_sensor(0x3309, 0x9A); 		 
+		write_cmos_sensor(0x3344, 0x57);//(0x3344, 0x57)		 
+		write_cmos_sensor(0x3345, 0x1F); 		 
+		write_cmos_sensor(0x3362, 0x0A); 		 
+		write_cmos_sensor(0x3363, 0x0A); 		 
+		write_cmos_sensor(0x3364, 0x00); 		
+		write_cmos_sensor(0x3368, 0x18); 		 
+		write_cmos_sensor(0x3369, 0x00); 		 
+		write_cmos_sensor(0x3370, 0x77);// (0x3370, 0x77)		 	 
+		write_cmos_sensor(0x3371, 0x2F);//(0x3371, 0x2F)             
+		write_cmos_sensor(0x3372, 0x4F);             
+		write_cmos_sensor(0x3373, 0x2F);             
+		write_cmos_sensor(0x3374, 0x2F);             
+		write_cmos_sensor(0x3375, 0x37);             
+		write_cmos_sensor(0x3376, 0x9F);             
+		write_cmos_sensor(0x3377, 0x37);             
+		write_cmos_sensor(0x33C8, 0x00);             
+		write_cmos_sensor(0x33D4, 0x0C);             
+		write_cmos_sensor(0x33D5, 0xD0);             
+		write_cmos_sensor(0x33D6, 0x09);             
+		write_cmos_sensor(0x33D7, 0xA0);             
+		write_cmos_sensor(0x4100, 0x0E);             
+		write_cmos_sensor(0x4108, 0x01);             
+		write_cmos_sensor(0x4109, 0x7C);
+		write_cmos_sensor(0x3302, 0x01);
+		write_cmos_sensor(0x0104, 0x00);//group
+		write_cmos_sensor(0x0100, 0x01);//STREAM ON		
+}
+static void hs_video_setting()
+{
+	//5.1.2hs_video 1288x800 60fps 24M MCLK 4lane 256Mbps/lane
+	LOG_INF("E\n");
+	write_cmos_sensor(0x41C0, 0x01);
+	write_cmos_sensor(0x0104, 0x01);//group
+	write_cmos_sensor(0x0100, 0x00);//STREAM OFF 
+	//write_cmos_sensor(0x0101, 0x00); 
+	//write_cmos_sensor(0x0103, 0x01);//SW reset		 		   
+	write_cmos_sensor(0x0202, 0x02); //0x0202, 0x09		 
+	write_cmos_sensor(0x0203, 0x68);//(0x0203, 0xcc)
+	//PLL setting
+	write_cmos_sensor(0x0301, 0x05); 		 
+	write_cmos_sensor(0x0303, 0x01); 		 
+	write_cmos_sensor(0x0305, 0x06); 		 
+	write_cmos_sensor(0x0309, 0x05); 		 
+	write_cmos_sensor(0x030B, 0x01); 		 
+	write_cmos_sensor(0x030C, 0x00); 		 
+	write_cmos_sensor(0x030D, 0xA0); //(0x030D, 0xA2)
+	write_cmos_sensor(0x030E, 0x01);	
+	write_cmos_sensor(0x0340, 0x02);//(0x0340, 0x09)
+	write_cmos_sensor(0x0341, 0x6c); 		 
+	write_cmos_sensor(0x0342, 0x0D); 		
+	write_cmos_sensor(0x0343, 0x70);//(0x0343, 0x0D) 		 
+	write_cmos_sensor(0x0344, 0x00); 		 
+	write_cmos_sensor(0x0345, 0x28); 		 
+	write_cmos_sensor(0x0346, 0x00); 		 
+	write_cmos_sensor(0x0347, 0x20);// (0x0347, 0x00)		 
+	write_cmos_sensor(0x0348, 0x0C); 		
+	write_cmos_sensor(0x0349, 0xA7); 		 
+	write_cmos_sensor(0x034A, 0x09);// (0x034A, 0x09)		 
+	write_cmos_sensor(0x034B, 0x7F);//(0x034B, 0x9F) 		 
+	write_cmos_sensor(0x034C, 0x02); 		 
+	write_cmos_sensor(0x034D, 0x80); 		 
+	write_cmos_sensor(0x034E, 0x01); 		 
+	write_cmos_sensor(0x034F, 0xE0);//(0x034F, 0xD0)		 
+	write_cmos_sensor(0x0383, 0x01); 		 
+	write_cmos_sensor(0x0387, 0x01); 		
+	write_cmos_sensor(0x0390, 0x02); 		 
+	write_cmos_sensor(0x0401, 0x02); 		 
+	write_cmos_sensor(0x0405, 0x14); 		 
+	write_cmos_sensor(0x3020, 0x10); 		 
+	write_cmos_sensor(0x3041, 0x15); 		 
+	write_cmos_sensor(0x3042, 0x87); 		 
+	write_cmos_sensor(0x3089, 0x4F); 		 
+	write_cmos_sensor(0x3309, 0x9A); 		 
+	write_cmos_sensor(0x3344, 0x57);//(0x3344, 0x57)		 
+	write_cmos_sensor(0x3345, 0x1F); 		 
+	write_cmos_sensor(0x3362, 0x0A); 		 
+	write_cmos_sensor(0x3363, 0x0A); 		 
+	write_cmos_sensor(0x3364, 0x00); 		
+	write_cmos_sensor(0x3368, 0x18); 		 
+	write_cmos_sensor(0x3369, 0x00); 		 
+	write_cmos_sensor(0x3370, 0x77);// (0x3370, 0x77)		 	 
+	write_cmos_sensor(0x3371, 0x2F);//(0x3371, 0x2F)             
+	write_cmos_sensor(0x3372, 0x4F);             
+	write_cmos_sensor(0x3373, 0x2F);             
+	write_cmos_sensor(0x3374, 0x2F);             
+	write_cmos_sensor(0x3375, 0x37);             
+	write_cmos_sensor(0x3376, 0x9F);             
+	write_cmos_sensor(0x3377, 0x37);             
+	write_cmos_sensor(0x33C8, 0x00);             
+	write_cmos_sensor(0x33D4, 0x03);             
+	write_cmos_sensor(0x33D5, 0x20);             
+	write_cmos_sensor(0x33D6, 0x02);             
+	write_cmos_sensor(0x33D7, 0x58);             
+	write_cmos_sensor(0x4100, 0x0E);             
+	write_cmos_sensor(0x4108, 0x01);             
+	write_cmos_sensor(0x4109, 0x7C);
+	write_cmos_sensor(0x0104, 0x00);//group
+	write_cmos_sensor(0x0100, 0x01);//STREAM ON	
+}
+
+static void slim_video_setting()
+{
+	//5.1.2hs_video 1288x800 30fps 24M MCLK 4lane 160Mbps/lane
+	LOG_INF("E\n");
+	write_cmos_sensor(0x41C0, 0x01);
+	write_cmos_sensor(0x0104, 0x01);//group
+	write_cmos_sensor(0x0100, 0x00);//STREAM OFF 
+	//write_cmos_sensor(0x0101, 0x00); 
+	//write_cmos_sensor(0x0103, 0x01);//SW reset		 		   
+	write_cmos_sensor(0x0202, 0x06); //0x0202, 0x09		 
+	write_cmos_sensor(0x0203, 0x0A);//(0x0203, 0xcc)
+	//PLL setting
+	write_cmos_sensor(0x0301, 0x05); 		 
+	write_cmos_sensor(0x0303, 0x01); 		 
+	write_cmos_sensor(0x0305, 0x06); 		 
+	write_cmos_sensor(0x0309, 0x05); 		 
+	write_cmos_sensor(0x030B, 0x01); 		 
+	write_cmos_sensor(0x030C, 0x00); 		 
+	write_cmos_sensor(0x030D, 0x64); //(0x030D, 0xA2)
+	write_cmos_sensor(0x030E, 0x01);	
+	write_cmos_sensor(0x0340, 0x06);//(0x0340, 0x09)
+	write_cmos_sensor(0x0341, 0x0E); 		 
+	write_cmos_sensor(0x0342, 0x0D); 		
+	write_cmos_sensor(0x0343, 0x70);//(0x0343, 0x0D) 		 
+	write_cmos_sensor(0x0344, 0x00); 		 
+	write_cmos_sensor(0x0345, 0x1E); 		 
+	write_cmos_sensor(0x0346, 0x00); 		 
+	write_cmos_sensor(0x0347, 0xE8);// (0x0347, 0x00)		 
+	write_cmos_sensor(0x0348, 0x0C); 		
+	write_cmos_sensor(0x0349, 0xB1); 		 
+	write_cmos_sensor(0x034A, 0x08);// (0x034A, 0x09)		 
+	write_cmos_sensor(0x034B, 0xB7);//(0x034B, 0x9F) 		 
+	write_cmos_sensor(0x034C, 0x05); 		 
+	write_cmos_sensor(0x034D, 0x08); 		 
+	write_cmos_sensor(0x034E, 0x03); 		 
+	write_cmos_sensor(0x034F, 0x20);//(0x034F, 0xD0)		 
+	write_cmos_sensor(0x0383, 0x01); 		 
+	write_cmos_sensor(0x0387, 0x01); 		
+	write_cmos_sensor(0x0390, 0x01); 		 
+	write_cmos_sensor(0x0401, 0x02); 		 
+	write_cmos_sensor(0x0405, 0x14); 		 
+	write_cmos_sensor(0x3020, 0x10); 		 
+	write_cmos_sensor(0x3041, 0x15); 		 
+	write_cmos_sensor(0x3042, 0x87); 		 
+	write_cmos_sensor(0x3089, 0x4F); 		 
+	write_cmos_sensor(0x3309, 0x9A); 		 
+	write_cmos_sensor(0x3344, 0x3F);//(0x3344, 0x57)		 
+	write_cmos_sensor(0x3345, 0x1F); 		 
+	write_cmos_sensor(0x3362, 0x0A); 		 
+	write_cmos_sensor(0x3363, 0x0A); 		 
+	write_cmos_sensor(0x3364, 0x00); 		
+	write_cmos_sensor(0x3368, 0x18); 		 
+	write_cmos_sensor(0x3369, 0x00); 		 
+	write_cmos_sensor(0x3370, 0x67);// (0x3370, 0x77)		 	 
+	write_cmos_sensor(0x3371, 0x17);//(0x3371, 0x2F)             
+	write_cmos_sensor(0x3372, 0x47);             
+	write_cmos_sensor(0x3373, 0x1F);             
+	write_cmos_sensor(0x3374, 0x1F);             
+	write_cmos_sensor(0x3375, 0x17);             
+	write_cmos_sensor(0x3376, 0x77);             
+	write_cmos_sensor(0x3377, 0x27);             
+	write_cmos_sensor(0x33C8, 0x00);             
+	write_cmos_sensor(0x33D4, 0x06);             
+	write_cmos_sensor(0x33D5, 0x4A);             
+	write_cmos_sensor(0x33D6, 0x03);             
+	write_cmos_sensor(0x33D7, 0xE8);             
+	write_cmos_sensor(0x4100, 0x0E);             
+	write_cmos_sensor(0x4108, 0x01);             
+	write_cmos_sensor(0x4109, 0x7C);
+	write_cmos_sensor(0x0104, 0x00);//group
+	write_cmos_sensor(0x0100, 0x01);//STREAM ON
+}
+
+static kal_uint32 set_test_pattern_mode(kal_bool enable)
+{
+    LOG_INF("enable: %d\n", enable);
+    if(enable) 
+	{   // enable color bar
+		//test_pattern_flag=TRUE;
+        write_cmos_sensor(0x30D8, 0x10);  // color bar test pattern
+        write_cmos_sensor(0x0600, 0x00);  // color bar test pattern
+        write_cmos_sensor(0x0601, 0x02);  // color bar test pattern 
+    } 
+	else 
+	{   
+		//test_pattern_flag=FALSE;
+        write_cmos_sensor(0x30D8, 0x00);  // disable color bar test pattern
+    }
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.test_pattern = enable;
+    spin_unlock(&imgsensor_drv_lock);
+	LOG_INF("[IMX179MIPI] exit IMX179MIPISetTestPatternMode function \n");
+    return ERROR_NONE;
+}
+
+/*************************************************************************
+* FUNCTION
+*	get_imgsensor_id
+*
+* DESCRIPTION
+*	This function get the sensor ID 
+*
+* PARAMETERS
+*	*sensorID : return the sensor ID 
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 get_imgsensor_id(UINT32 *sensor_id) 
+{
+	kal_uint8 i = 0;
+	kal_uint8 retry = 2;
+	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
+	while (imgsensor_info.i2c_addr_table[i] != 0xff) {
+		spin_lock(&imgsensor_drv_lock);
+		imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
+		spin_unlock(&imgsensor_drv_lock);
+		do {
+            *sensor_id = return_sensor_id();
+			if (*sensor_id == imgsensor_info.sensor_id) {				
+				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);	  
+				return ERROR_NONE;
+			}	
+			LOG_INF("Read sensor id fail, id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
+			retry--;
+		} while(retry > 0);
+		i++;
+		retry = 2;
+	}
+	if (*sensor_id != imgsensor_info.sensor_id) {
+		// if Sensor ID is not correct, Must set *sensor_id to 0xFFFFFFFF 
+		*sensor_id = 0xFFFFFFFF;
+		return ERROR_SENSOR_CONNECT_FAIL;
+	}
+	return ERROR_NONE;
+}
+
+
+/*************************************************************************
+* FUNCTION
+*	open
+*
+* DESCRIPTION
+*	This function initialize the registers of CMOS sensor
+*
+* PARAMETERS
+*	None
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 open(void)
+{
+	//const kal_uint8 i2c_addr[] = {IMGSENSOR_WRITE_ID_1, IMGSENSOR_WRITE_ID_2};
+	kal_uint8 iTemp,i = 0;
+	kal_uint8 retry = 2;
+	kal_uint32 sensor_id = 0; 
+	LOG_1;	
+	LOG_2;
+	
+	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
+	while (imgsensor_info.i2c_addr_table[i] != 0xff) {
+		spin_lock(&imgsensor_drv_lock);
+		imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
+		spin_unlock(&imgsensor_drv_lock);
+		do {
+            sensor_id = return_sensor_id();
+			if (sensor_id == imgsensor_info.sensor_id) {				
+				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);	  
+				break;
+			}	
+			LOG_INF("Read sensor id fail, id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
+			retry--;
+		} while(retry > 0);
+		i++;
+		if (sensor_id == imgsensor_info.sensor_id)
+			break;
+		retry = 2;
+	}		 
+	if (imgsensor_info.sensor_id != sensor_id)
+		return ERROR_SENSOR_CONNECT_FAIL;
+	
+	/* initail sequence write in  */
+	sensor_init();
+	
+	iTemp = read_cmos_sensor(0x0101);
+	iTemp&= ~0x03; //Clear the mirror and flip bits.
+	write_cmos_sensor_8(0x0101, iTemp | 0x03); //Set mirror and flip
+
+	spin_lock(&imgsensor_drv_lock);
+
+	imgsensor.autoflicker_en= KAL_FALSE;
+	imgsensor.sensor_mode = IMGSENSOR_MODE_INIT;
+	imgsensor.pclk = imgsensor_info.pre.pclk;
+	imgsensor.frame_length = imgsensor_info.pre.framelength;
+	imgsensor.line_length = imgsensor_info.pre.linelength;
+	imgsensor.min_frame_length = imgsensor_info.pre.framelength;
+	imgsensor.dummy_pixel = 0;
+	imgsensor.dummy_line = 0;
+	imgsensor.ihdr_en = KAL_FALSE;
+	imgsensor.test_pattern = KAL_FALSE;
+	imgsensor.current_fps = imgsensor_info.pre.max_framerate;
+	spin_unlock(&imgsensor_drv_lock);
+
+	return ERROR_NONE;
+}	/*	open  */
+
+
+
+/*************************************************************************
+* FUNCTION
+*	close
+*
+* DESCRIPTION
+*	
+*
+* PARAMETERS
+*	None
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 close(void)
+{
+	LOG_INF("E\n");
+
+	/*No Need to implement this function*/ 
+	
+	return ERROR_NONE;
+}	/*	close  */
+
+
+/*************************************************************************
+* FUNCTION
+* preview
+*
+* DESCRIPTION
+*	This function start the sensor preview.
+*
+* PARAMETERS
+*	*image_window : address pointer of pixel numbers in one period of HSYNC
+*  *sensor_config_data : address pointer of line numbers in one period of VSYNC
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("E\n");
+
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.sensor_mode = IMGSENSOR_MODE_PREVIEW;
+	imgsensor.pclk = imgsensor_info.pre.pclk;
+	//imgsensor.video_mode = KAL_FALSE;
+	imgsensor.line_length = imgsensor_info.pre.linelength;
+	imgsensor.frame_length = imgsensor_info.pre.framelength; 
+	imgsensor.min_frame_length = imgsensor_info.pre.framelength;
+	imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	preview_setting();
+	set_mirror_flip(sensor_config_data->SensorImageMirror);
+	return ERROR_NONE;
+}	/*	preview   */
+
+/*************************************************************************
+* FUNCTION
+*	capture
+*
+* DESCRIPTION
+*	This function setup the CMOS sensor in capture MY_OUTPUT mode
+*
+* PARAMETERS
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                          MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+	
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_CAPTURE;
+    if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {//PIP capture: 24fps for less than 13M, 20fps for 16M,15fps for 20M
+        imgsensor.pclk = imgsensor_info.cap1.pclk;
+        imgsensor.line_length = imgsensor_info.cap1.linelength;
+        imgsensor.frame_length = imgsensor_info.cap1.framelength;
+        imgsensor.min_frame_length = imgsensor_info.cap1.framelength;
+        imgsensor.autoflicker_en = KAL_FALSE;
+    } else {
+        if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
+            LOG_INF("Warning: current_fps %d fps is not support, so use cap's setting: %d fps!\n",imgsensor.current_fps,imgsensor_info.cap.max_framerate/10);
+        imgsensor.pclk = imgsensor_info.cap.pclk;
+        imgsensor.line_length = imgsensor_info.cap.linelength;
+        imgsensor.frame_length = imgsensor_info.cap.framelength;
+        imgsensor.min_frame_length = imgsensor_info.cap.framelength;
+        imgsensor.autoflicker_en = KAL_FALSE;
+    }
+    spin_unlock(&imgsensor_drv_lock);
+    capture_setting(imgsensor.current_fps);
+	if(imgsensor.test_pattern == KAL_TRUE)
+	{
+		set_test_pattern_mode(TRUE);
+		spin_lock(&imgsensor_drv_lock);
+		imgsensor.test_pattern = KAL_FALSE;
+		spin_unlock(&imgsensor_drv_lock);
+	}
+
+	set_mirror_flip(sensor_config_data->SensorImageMirror);
+    return ERROR_NONE;
+}    /* capture() */
+static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("E\n");
+	
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.sensor_mode = IMGSENSOR_MODE_VIDEO;
+	imgsensor.pclk = imgsensor_info.normal_video.pclk;
+	imgsensor.line_length = imgsensor_info.normal_video.linelength;
+	imgsensor.frame_length = imgsensor_info.normal_video.framelength;  
+	imgsensor.min_frame_length = imgsensor_info.normal_video.framelength;
+	//imgsensor.current_fps = 300;
+	imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	normal_video_setting(imgsensor.current_fps);
+	set_mirror_flip(sensor_config_data->SensorImageMirror);
+	
+	return ERROR_NONE;
+}	/*	normal_video   */
+
+static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("E\n");
+	
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.sensor_mode = IMGSENSOR_MODE_HIGH_SPEED_VIDEO;
+	imgsensor.pclk = imgsensor_info.hs_video.pclk;
+	//imgsensor.video_mode = KAL_TRUE;
+	imgsensor.line_length = imgsensor_info.hs_video.linelength;
+	imgsensor.frame_length = imgsensor_info.hs_video.framelength; 
+	imgsensor.min_frame_length = imgsensor_info.hs_video.framelength;
+	imgsensor.dummy_line = 0;
+	imgsensor.dummy_pixel = 0;
+	//imgsensor.current_fps = 300;
+	imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	hs_video_setting();
+	set_mirror_flip(sensor_config_data->SensorImageMirror);
+	return ERROR_NONE;
+}	/*	hs_video   */
+
+static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("E\n");
+	
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.sensor_mode = IMGSENSOR_MODE_SLIM_VIDEO;
+	imgsensor.pclk = imgsensor_info.slim_video.pclk;
+	//imgsensor.video_mode = KAL_TRUE;
+	imgsensor.line_length = imgsensor_info.slim_video.linelength;
+	imgsensor.frame_length = imgsensor_info.slim_video.framelength; 
+	imgsensor.min_frame_length = imgsensor_info.slim_video.framelength;
+	imgsensor.dummy_line = 0;
+	imgsensor.dummy_pixel = 0;
+	//imgsensor.current_fps = 300;
+	imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	slim_video_setting();
+    return ERROR_NONE;
+}   /*  slim_video   */
+	
+/*************************************************************************
+* FUNCTION
+* Custom1
+*
+* DESCRIPTION
+*   This function start the sensor Custom1.
+*
+* PARAMETERS
+*   *image_window : address pointer of pixel numbers in one period of HSYNC
+*  *sensor_config_data : address pointer of line numbers in one period of VSYNC
+*
+* RETURNS
+*   None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 Custom1(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_CUSTOM1;
+    imgsensor.pclk = imgsensor_info.custom1.pclk;
+    //imgsensor.video_mode = KAL_FALSE;
+    imgsensor.line_length = imgsensor_info.custom1.linelength;
+    imgsensor.frame_length = imgsensor_info.custom1.framelength; 
+    imgsensor.min_frame_length = imgsensor_info.custom1.framelength;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    preview_setting();
+    return ERROR_NONE;
+}   /*  Custom1   */
+
+static kal_uint32 Custom2(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_CUSTOM2;
+    imgsensor.pclk = imgsensor_info.custom2.pclk;
+    //imgsensor.video_mode = KAL_FALSE;
+    imgsensor.line_length = imgsensor_info.custom2.linelength;
+    imgsensor.frame_length = imgsensor_info.custom2.framelength; 
+    imgsensor.min_frame_length = imgsensor_info.custom2.framelength;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    preview_setting();
+    return ERROR_NONE;
+}   /*  Custom2   */
+
+static kal_uint32 Custom3(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_CUSTOM3;
+    imgsensor.pclk = imgsensor_info.custom3.pclk;
+    //imgsensor.video_mode = KAL_FALSE;
+    imgsensor.line_length = imgsensor_info.custom3.linelength;
+    imgsensor.frame_length = imgsensor_info.custom3.framelength; 
+    imgsensor.min_frame_length = imgsensor_info.custom3.framelength;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    preview_setting();
+    return ERROR_NONE;
+}   /*  Custom3   */
+
+static kal_uint32 Custom4(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_CUSTOM4;
+    imgsensor.pclk = imgsensor_info.custom4.pclk;
+    //imgsensor.video_mode = KAL_FALSE;
+    imgsensor.line_length = imgsensor_info.custom4.linelength;
+    imgsensor.frame_length = imgsensor_info.custom4.framelength; 
+    imgsensor.min_frame_length = imgsensor_info.custom4.framelength;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    preview_setting();
+    return ERROR_NONE;
+}   /*  Custom4   */
+
+
+static kal_uint32 Custom5(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_CUSTOM5;
+    imgsensor.pclk = imgsensor_info.custom5.pclk;
+    //imgsensor.video_mode = KAL_FALSE;
+    imgsensor.line_length = imgsensor_info.custom5.linelength;
+    imgsensor.frame_length = imgsensor_info.custom5.framelength; 
+    imgsensor.min_frame_length = imgsensor_info.custom5.framelength;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    preview_setting();
+    return ERROR_NONE;
+}   /*  Custom5   */
+static kal_uint32 get_resolution(MSDK_SENSOR_RESOLUTION_INFO_STRUCT *sensor_resolution)
+{
+	LOG_INF("E\n");
+	sensor_resolution->SensorFullWidth = imgsensor_info.cap.grabwindow_width;
+	sensor_resolution->SensorFullHeight = imgsensor_info.cap.grabwindow_height;
+	
+	sensor_resolution->SensorPreviewWidth = imgsensor_info.pre.grabwindow_width;
+	sensor_resolution->SensorPreviewHeight = imgsensor_info.pre.grabwindow_height;
+
+	sensor_resolution->SensorVideoWidth = imgsensor_info.normal_video.grabwindow_width;
+	sensor_resolution->SensorVideoHeight = imgsensor_info.normal_video.grabwindow_height;		
+
+	
+	sensor_resolution->SensorHighSpeedVideoWidth	 = imgsensor_info.hs_video.grabwindow_width;
+	sensor_resolution->SensorHighSpeedVideoHeight	 = imgsensor_info.hs_video.grabwindow_height;
+	
+	sensor_resolution->SensorSlimVideoWidth	 = imgsensor_info.slim_video.grabwindow_width;
+	sensor_resolution->SensorSlimVideoHeight	 = imgsensor_info.slim_video.grabwindow_height;
+    sensor_resolution->SensorCustom1Width  = imgsensor_info.custom1.grabwindow_width;
+    sensor_resolution->SensorCustom1Height     = imgsensor_info.custom1.grabwindow_height;
+
+    sensor_resolution->SensorCustom2Width  = imgsensor_info.custom2.grabwindow_width;
+    sensor_resolution->SensorCustom2Height     = imgsensor_info.custom2.grabwindow_height;
+
+    sensor_resolution->SensorCustom3Width  = imgsensor_info.custom3.grabwindow_width;
+    sensor_resolution->SensorCustom3Height     = imgsensor_info.custom3.grabwindow_height;
+
+    sensor_resolution->SensorCustom4Width  = imgsensor_info.custom4.grabwindow_width;
+    sensor_resolution->SensorCustom4Height     = imgsensor_info.custom4.grabwindow_height;
+
+    sensor_resolution->SensorCustom5Width  = imgsensor_info.custom5.grabwindow_width;
+    sensor_resolution->SensorCustom5Height     = imgsensor_info.custom5.grabwindow_height;
+	return ERROR_NONE;
+}	/*	get_resolution	*/
+
+static kal_uint32 get_info(MSDK_SCENARIO_ID_ENUM scenario_id,
+					  MSDK_SENSOR_INFO_STRUCT *sensor_info,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("scenario_id = %d\n", scenario_id);
+
+	
+	//sensor_info->SensorVideoFrameRate = imgsensor_info.normal_video.max_framerate/10; /* not use */
+	//sensor_info->SensorStillCaptureFrameRate= imgsensor_info.cap.max_framerate/10; /* not use */
+	//imgsensor_info->SensorWebCamCaptureFrameRate= imgsensor_info.v.max_framerate; /* not use */
+
+	sensor_info->SensorClockPolarity = SENSOR_CLOCK_POLARITY_LOW;
+	sensor_info->SensorClockFallingPolarity = SENSOR_CLOCK_POLARITY_LOW; /* not use */
+	sensor_info->SensorHsyncPolarity = SENSOR_CLOCK_POLARITY_LOW; // inverse with datasheet
+	sensor_info->SensorVsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
+	sensor_info->SensorInterruptDelayLines = 1; /* not use */
+	sensor_info->SensorResetActiveHigh = FALSE; /* not use */
+	sensor_info->SensorResetDelayCount = 5; /* not use */
+
+	sensor_info->SensroInterfaceType = imgsensor_info.sensor_interface_type;
+	sensor_info->MIPIsensorType = imgsensor_info.mipi_sensor_type;
+	sensor_info->SettleDelayMode = imgsensor_info.mipi_settle_delay_mode;
+	sensor_info->SensorOutputDataFormat = imgsensor_info.sensor_output_dataformat;
+
+	sensor_info->CaptureDelayFrame = imgsensor_info.cap_delay_frame; 
+	sensor_info->PreviewDelayFrame = imgsensor_info.pre_delay_frame; 
+	sensor_info->VideoDelayFrame = imgsensor_info.video_delay_frame;
+	sensor_info->HighSpeedVideoDelayFrame = imgsensor_info.hs_video_delay_frame;
+	sensor_info->SlimVideoDelayFrame = imgsensor_info.slim_video_delay_frame;
+    sensor_info->SlimVideoDelayFrame = imgsensor_info.slim_video_delay_frame;
+    sensor_info->Custom1DelayFrame = imgsensor_info.custom1_delay_frame; 
+    sensor_info->Custom2DelayFrame = imgsensor_info.custom2_delay_frame; 
+    sensor_info->Custom3DelayFrame = imgsensor_info.custom3_delay_frame; 
+    sensor_info->Custom4DelayFrame = imgsensor_info.custom4_delay_frame; 
+    sensor_info->Custom5DelayFrame = imgsensor_info.custom5_delay_frame; 
+
+	sensor_info->SensorMasterClockSwitch = 0; /* not use */
+	sensor_info->SensorDrivingCurrent = imgsensor_info.isp_driving_current;
+	
+	sensor_info->AEShutDelayFrame = imgsensor_info.ae_shut_delay_frame; 		 /* The frame of setting shutter default 0 for TG int */
+	sensor_info->AESensorGainDelayFrame = imgsensor_info.ae_sensor_gain_delay_frame;	/* The frame of setting sensor gain */
+	sensor_info->AEISPGainDelayFrame = imgsensor_info.ae_ispGain_delay_frame;	
+	sensor_info->IHDR_Support = imgsensor_info.ihdr_support;
+	sensor_info->IHDR_LE_FirstLine = imgsensor_info.ihdr_le_firstline;
+	sensor_info->SensorModeNum = imgsensor_info.sensor_mode_num;
+	
+	sensor_info->SensorMIPILaneNumber = imgsensor_info.mipi_lane_num; 
+	sensor_info->SensorClockFreq = imgsensor_info.mclk;
+	sensor_info->SensorClockDividCount = 5; /* not use */
+	sensor_info->SensorClockRisingCount = 0;
+	sensor_info->SensorClockFallingCount = 2; /* not use */
+	sensor_info->SensorPixelClockCount = 3; /* not use */
+	sensor_info->SensorDataLatchCount = 2; /* not use */
+	
+	sensor_info->MIPIDataLowPwr2HighSpeedTermDelayCount = 0; 
+	sensor_info->MIPICLKLowPwr2HighSpeedTermDelayCount = 0;
+	sensor_info->SensorWidthSampling = 0;  // 0 is default 1x
+	sensor_info->SensorHightSampling = 0;	// 0 is default 1x 
+	sensor_info->SensorPacketECCOrder = 1;
+
+	switch (scenario_id) {
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+			sensor_info->SensorGrabStartX = imgsensor_info.pre.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;		
+			
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
+			
+			break;
+		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+			sensor_info->SensorGrabStartX = imgsensor_info.cap.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.cap.starty;
+				  
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.cap.mipi_data_lp2hs_settle_dc; 
+
+			break;	 
+		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+			
+			sensor_info->SensorGrabStartX = imgsensor_info.normal_video.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.normal_video.starty;
+	   
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.normal_video.mipi_data_lp2hs_settle_dc; 
+
+			break;	  
+		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:			
+			sensor_info->SensorGrabStartX = imgsensor_info.hs_video.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.hs_video.starty;
+				  
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.hs_video.mipi_data_lp2hs_settle_dc; 
+
+			break;
+		case MSDK_SCENARIO_ID_SLIM_VIDEO:
+			sensor_info->SensorGrabStartX = imgsensor_info.slim_video.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.slim_video.starty;
+				  
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.slim_video.mipi_data_lp2hs_settle_dc; 
+
+			break;
+        case MSDK_SCENARIO_ID_CUSTOM1:
+            sensor_info->SensorGrabStartX = imgsensor_info.custom1.startx; 
+            sensor_info->SensorGrabStartY = imgsensor_info.custom1.starty;   
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.custom1.mipi_data_lp2hs_settle_dc; 
+
+            break;
+        case MSDK_SCENARIO_ID_CUSTOM2:
+            sensor_info->SensorGrabStartX = imgsensor_info.custom2.startx; 
+            sensor_info->SensorGrabStartY = imgsensor_info.custom2.starty;   
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.custom1.mipi_data_lp2hs_settle_dc; 
+
+            break;
+        case MSDK_SCENARIO_ID_CUSTOM3:
+            sensor_info->SensorGrabStartX = imgsensor_info.custom3.startx; 
+            sensor_info->SensorGrabStartY = imgsensor_info.custom3.starty;   
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.custom1.mipi_data_lp2hs_settle_dc; 
+
+            break;
+        case MSDK_SCENARIO_ID_CUSTOM4:
+            sensor_info->SensorGrabStartX = imgsensor_info.custom4.startx; 
+            sensor_info->SensorGrabStartY = imgsensor_info.custom4.starty;   
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.custom1.mipi_data_lp2hs_settle_dc; 
+
+            break;
+        case MSDK_SCENARIO_ID_CUSTOM5:
+            sensor_info->SensorGrabStartX = imgsensor_info.custom5.startx; 
+            sensor_info->SensorGrabStartY = imgsensor_info.custom5.starty;   
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.custom1.mipi_data_lp2hs_settle_dc; 
+
+            break;
+		default:			
+			sensor_info->SensorGrabStartX = imgsensor_info.pre.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;		
+			
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
+			break;
+	}
+	
+	return ERROR_NONE;
+}	/*	get_info  */
+
+
+static kal_uint32 control(MSDK_SCENARIO_ID_ENUM scenario_id, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("scenario_id = %d\n", scenario_id);
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.current_scenario_id = scenario_id;
+	spin_unlock(&imgsensor_drv_lock);
+	switch (scenario_id) {
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+			preview(image_window, sensor_config_data);
+			break;
+		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+			capture(image_window, sensor_config_data);
+			break;	
+		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+			normal_video(image_window, sensor_config_data);
+			break;	  
+		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+			hs_video(image_window, sensor_config_data);
+			break;
+		case MSDK_SCENARIO_ID_SLIM_VIDEO:
+			slim_video(image_window, sensor_config_data);
+			break;	  
+        case MSDK_SCENARIO_ID_CUSTOM1:
+            Custom1(image_window, sensor_config_data); // Custom1
+            break;
+        case MSDK_SCENARIO_ID_CUSTOM2:
+            Custom2(image_window, sensor_config_data); // Custom1
+            break;
+        case MSDK_SCENARIO_ID_CUSTOM3:
+            Custom3(image_window, sensor_config_data); // Custom1
+            break;
+        case MSDK_SCENARIO_ID_CUSTOM4:
+            Custom4(image_window, sensor_config_data); // Custom1
+            break;
+        case MSDK_SCENARIO_ID_CUSTOM5:
+            Custom5(image_window, sensor_config_data); // Custom1
+            break;
+		default:
+			LOG_INF("Error ScenarioId setting");
+			preview(image_window, sensor_config_data);
+			return ERROR_INVALID_SCENARIO_ID;
+	}
+	return ERROR_NONE;
+}	/* control() */
+
+
+
+static kal_uint32 set_video_mode(UINT16 framerate)
+{
+	LOG_INF("framerate = %d\n ", framerate);
+	// SetVideoMode Function should fix framerate
+	if (framerate == 0)
+		// Dynamic frame rate
+		return ERROR_NONE;
+	spin_lock(&imgsensor_drv_lock);
+	if ((framerate == 300) && (imgsensor.autoflicker_en == KAL_TRUE))
+		imgsensor.current_fps = 296;
+	else if ((framerate == 150) && (imgsensor.autoflicker_en == KAL_TRUE))
+		imgsensor.current_fps = 146;
+	else
+		imgsensor.current_fps = framerate;
+	spin_unlock(&imgsensor_drv_lock);
+	set_max_framerate(imgsensor.current_fps,1);
+	return ERROR_NONE;
+}
+
+static kal_uint32 set_auto_flicker_mode(kal_bool enable, UINT16 framerate)
+{
+	LOG_INF("enable = %d, framerate = %d \n", enable, framerate);
+	spin_lock(&imgsensor_drv_lock);
+	if (enable) //enable auto flicker	  
+		imgsensor.autoflicker_en = KAL_TRUE;
+	else //Cancel Auto flick
+		imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	return ERROR_NONE;
+}
+
+
+static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 framerate) 
+{
+	kal_uint32 frame_length; 
+	LOG_INF("scenario_id = %d, framerate = %d\n", scenario_id, framerate);
+
+	switch (scenario_id) {
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+			frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength):0;
+			imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			//set_dummy();			
+			break;			
+		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+			if(framerate == 0)
+				return ERROR_NONE;
+			frame_length = imgsensor_info.normal_video.pclk / framerate * 10 / imgsensor_info.normal_video.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = (frame_length > imgsensor_info.normal_video.framelength) ? (frame_length - imgsensor_info.normal_video.framelength):0;			
+			imgsensor.frame_length = imgsensor_info.normal_video.framelength + imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			//set_dummy();			
+			break;
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+        	  if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {
+                frame_length = imgsensor_info.cap1.pclk / framerate * 10 / imgsensor_info.cap1.linelength;
+                spin_lock(&imgsensor_drv_lock);
+		            imgsensor.dummy_line = (frame_length > imgsensor_info.cap1.framelength) ? (frame_length - imgsensor_info.cap1.framelength) : 0;
+		            imgsensor.frame_length = imgsensor_info.cap1.framelength + imgsensor.dummy_line;
+		            imgsensor.min_frame_length = imgsensor.frame_length;
+		            spin_unlock(&imgsensor_drv_lock);
+            } else {
+        		    if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
+                    LOG_INF("Warning: current_fps %d fps is not support, so use cap's setting: %d fps!\n",framerate,imgsensor_info.cap.max_framerate/10);
+                frame_length = imgsensor_info.cap.pclk / framerate * 10 / imgsensor_info.cap.linelength;
+                spin_lock(&imgsensor_drv_lock);
+		            imgsensor.dummy_line = (frame_length > imgsensor_info.cap.framelength) ? (frame_length - imgsensor_info.cap.framelength) : 0;
+		            imgsensor.frame_length = imgsensor_info.cap.framelength + imgsensor.dummy_line;
+		            imgsensor.min_frame_length = imgsensor.frame_length;
+		            spin_unlock(&imgsensor_drv_lock);
+            }
+			//set_dummy();			
+			break;	
+		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+			frame_length = imgsensor_info.hs_video.pclk / framerate * 10 / imgsensor_info.hs_video.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = (frame_length > imgsensor_info.hs_video.framelength) ? (frame_length - imgsensor_info.hs_video.framelength) : 0;
+			imgsensor.frame_length = imgsensor_info.hs_video.framelength + imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			//set_dummy();			
+			break;
+		case MSDK_SCENARIO_ID_SLIM_VIDEO:
+			frame_length = imgsensor_info.slim_video.pclk / framerate * 10 / imgsensor_info.slim_video.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = (frame_length > imgsensor_info.slim_video.framelength) ? (frame_length - imgsensor_info.slim_video.framelength): 0;
+			imgsensor.frame_length = imgsensor_info.slim_video.framelength + imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			//set_dummy();			
+        case MSDK_SCENARIO_ID_CUSTOM1:
+            frame_length = imgsensor_info.custom1.pclk / framerate * 10 / imgsensor_info.custom1.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.custom1.framelength) ? (frame_length - imgsensor_info.custom1.framelength) : 0;
+            if (imgsensor.dummy_line < 0)
+                imgsensor.dummy_line = 0;
+            imgsensor.frame_length = imgsensor_info.custom1.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            //set_dummy();            
+            break;
+        case MSDK_SCENARIO_ID_CUSTOM2:
+            frame_length = imgsensor_info.custom2.pclk / framerate * 10 / imgsensor_info.custom2.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.custom2.framelength) ? (frame_length - imgsensor_info.custom2.framelength) : 0;
+            if (imgsensor.dummy_line < 0)
+                imgsensor.dummy_line = 0;
+            imgsensor.frame_length = imgsensor_info.custom2.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            //set_dummy();            
+            break; 
+        case MSDK_SCENARIO_ID_CUSTOM3:
+            frame_length = imgsensor_info.custom3.pclk / framerate * 10 / imgsensor_info.custom3.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.custom3.framelength) ? (frame_length - imgsensor_info.custom3.framelength) : 0;
+            if (imgsensor.dummy_line < 0)
+                imgsensor.dummy_line = 0;
+            imgsensor.frame_length = imgsensor_info.custom3.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            //set_dummy();            
+            break; 
+        case MSDK_SCENARIO_ID_CUSTOM4:
+            frame_length = imgsensor_info.custom4.pclk / framerate * 10 / imgsensor_info.custom4.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.custom4.framelength) ? (frame_length - imgsensor_info.custom4.framelength) : 0;
+            if (imgsensor.dummy_line < 0)
+                imgsensor.dummy_line = 0;
+            imgsensor.frame_length = imgsensor_info.custom4.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            //set_dummy();            
+            break; 
+        case MSDK_SCENARIO_ID_CUSTOM5:
+            frame_length = imgsensor_info.custom5.pclk / framerate * 10 / imgsensor_info.custom5.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.custom5.framelength) ? (frame_length - imgsensor_info.custom5.framelength) : 0;
+            if (imgsensor.dummy_line < 0)
+                imgsensor.dummy_line = 0;
+            imgsensor.frame_length = imgsensor_info.custom1.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            //set_dummy();            
+			break;		
+		default:  //coding with  preview scenario by default
+			frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
+			imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			//set_dummy();	
+			LOG_INF("error scenario_id = %d, we use preview scenario \n", scenario_id);
+			break;
+	}	
+	return ERROR_NONE;
+}
+
+
+static kal_uint32 get_default_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 *framerate) 
+{
+	LOG_INF("scenario_id = %d\n", scenario_id);
+
+	switch (scenario_id) {
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+			*framerate = imgsensor_info.pre.max_framerate;
+			break;
+		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+			*framerate = imgsensor_info.normal_video.max_framerate;
+			break;
+		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+			*framerate = imgsensor_info.cap.max_framerate;
+			break;		
+		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+			*framerate = imgsensor_info.hs_video.max_framerate;
+			break;
+		case MSDK_SCENARIO_ID_SLIM_VIDEO: 
+			*framerate = imgsensor_info.slim_video.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_CUSTOM1:
+            *framerate = imgsensor_info.custom1.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_CUSTOM2:
+            *framerate = imgsensor_info.custom2.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_CUSTOM3:
+            *framerate = imgsensor_info.custom3.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_CUSTOM4:
+            *framerate = imgsensor_info.custom4.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_CUSTOM5:
+            *framerate = imgsensor_info.custom5.max_framerate;
+            break;
+        default:
+            break;
+    }
+
+    return ERROR_NONE;
+}
+
+static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
+							 UINT8 *feature_para,UINT32 *feature_para_len)
+{
+	UINT16 *feature_return_para_16=(UINT16 *) feature_para;
+	UINT16 *feature_data_16=(UINT16 *) feature_para;
+	UINT32 *feature_return_para_32=(UINT32 *) feature_para;
+	UINT32 *feature_data_32=(UINT32 *) feature_para;
+    unsigned long long *feature_data=(unsigned long long *) feature_para;
+	
+	SENSOR_WINSIZE_INFO_STRUCT *wininfo;	
+	MSDK_SENSOR_REG_INFO_STRUCT *sensor_reg_data=(MSDK_SENSOR_REG_INFO_STRUCT *) feature_para;
+ 
+	LOG_INF("feature_id = %d\n", feature_id);
+	switch (feature_id) {
+		case SENSOR_FEATURE_GET_PERIOD:
+			*feature_return_para_16++ = imgsensor.line_length;
+			*feature_return_para_16 = imgsensor.frame_length;
+			*feature_para_len=4;
+			break;
+		case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:	 
+			LOG_INF("feature_Control imgsensor.pclk = %d,imgsensor.current_fps = %d\n", imgsensor.pclk,imgsensor.current_fps);
+			*feature_return_para_32 = imgsensor.pclk;
+			*feature_para_len=4;
+			break;		   
+		case SENSOR_FEATURE_SET_ESHUTTER:
+            set_shutter(*feature_data);
+			break;
+		case SENSOR_FEATURE_SET_NIGHTMODE:
+            night_mode((BOOL) *feature_data);
+			break;
+		case SENSOR_FEATURE_SET_GAIN:		
+            set_gain((UINT16) *feature_data);
+			break;
+		case SENSOR_FEATURE_SET_FLASHLIGHT:
+			break;
+		case SENSOR_FEATURE_SET_ISP_MASTER_CLOCK_FREQ:
+			break;
+		case SENSOR_FEATURE_SET_REGISTER:
+			write_cmos_sensor(sensor_reg_data->RegAddr, sensor_reg_data->RegData);
+			break;
+		case SENSOR_FEATURE_GET_REGISTER:
+			sensor_reg_data->RegData = read_cmos_sensor(sensor_reg_data->RegAddr);
+			break;
+		case SENSOR_FEATURE_GET_LENS_DRIVER_ID:
+			// get the lens driver ID from EEPROM or just return LENS_DRIVER_ID_DO_NOT_CARE
+			// if EEPROM does not exist in camera module.
+			*feature_return_para_32=LENS_DRIVER_ID_DO_NOT_CARE;
+			*feature_para_len=4;
+			break;
+		case SENSOR_FEATURE_SET_VIDEO_MODE:
+            set_video_mode(*feature_data);
+			break; 
+		case SENSOR_FEATURE_CHECK_SENSOR_ID:
+			get_imgsensor_id(feature_return_para_32); 
+			break; 
+		case SENSOR_FEATURE_SET_AUTO_FLICKER_MODE:
+			set_auto_flicker_mode((BOOL)*feature_data_16,*(feature_data_16+1));
+			break;
+		case SENSOR_FEATURE_SET_MAX_FRAME_RATE_BY_SCENARIO:
+            set_max_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data, *(feature_data+1));
+			break;
+		case SENSOR_FEATURE_GET_DEFAULT_FRAME_RATE_BY_SCENARIO:
+            get_default_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*(feature_data), (MUINT32 *)(uintptr_t)(*(feature_data+1)));
+			break;
+		case SENSOR_FEATURE_SET_TEST_PATTERN:
+            set_test_pattern_mode((BOOL)*feature_data);
+			break;
+		case SENSOR_FEATURE_GET_TEST_PATTERN_CHECKSUM_VALUE: //for factory mode auto testing			 
+			*feature_return_para_32 = imgsensor_info.checksum_value;
+			*feature_para_len=4;							 
+			break;				
+		case SENSOR_FEATURE_SET_FRAMERATE:
+            LOG_INF("current fps :%d\n", (UINT32)*feature_data);
+			spin_lock(&imgsensor_drv_lock);
+            imgsensor.current_fps = *feature_data;
+			spin_unlock(&imgsensor_drv_lock);		
+			break;
+		case SENSOR_FEATURE_SET_HDR:
+            LOG_INF("ihdr enable :%d\n", (BOOL)*feature_data);
+			spin_lock(&imgsensor_drv_lock);
+            imgsensor.ihdr_en = (BOOL)*feature_data;
+			spin_unlock(&imgsensor_drv_lock);		
+			break;
+		case SENSOR_FEATURE_GET_CROP_INFO:
+            LOG_INF("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n", (UINT32)*feature_data);
+            wininfo = (SENSOR_WINSIZE_INFO_STRUCT *)(uintptr_t)(*(feature_data+1));
+		
+			switch (*feature_data_32) {
+				case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[1],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+					break;	  
+				case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[2],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+					break;
+				case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[3],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+					break;
+				case MSDK_SCENARIO_ID_SLIM_VIDEO:
+					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[4],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+					break;
+				case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+				default:
+					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[0],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+					break;
+			}
+            break;
+		case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
+			//LOG_INF("SENSOR_SET_SENSOR_IHDR is no support");
+			//LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",(UINT16)*feature_data_32,(UINT16)*(feature_data_32+1),(UINT16)*(feature_data_32+2)); 
+			//ihdr_write_shutter_gain((UINT16)*feature_data_32,(UINT16)*(feature_data_32+1),(UINT16)*(feature_data_32+2));	
+			break;
+		default:
+			break;
+	}
+  
+	return ERROR_NONE;
+}	/*	feature_control()  */
+
+static SENSOR_FUNCTION_STRUCT sensor_func = {
+	open,
+	get_info,
+	get_resolution,
+	feature_control,
+	control,
+	close
+};
+
+UINT32 IMX179_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
+{
+	/* To Do : Check Sensor status here */
+	if (pfFunc!=NULL)
+		*pfFunc=&sensor_func;
+	return ERROR_NONE;
+}	/*	OV5693_MIPI_RAW_SensorInit	*/
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/imx179_mipi_raw_4lane/imx179mipiraw_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx179_mipi_raw_4lane/imx179mipiraw_Sensor.h
new file mode 100755
index 0000000..abb8f59
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx179_mipi_raw_4lane/imx179mipiraw_Sensor.h
@@ -0,0 +1,178 @@
+/*****************************************************************************
+*  Copyright Statement:
+*  --------------------
+*  This software is protected by Copyright and the information contained
+*  herein is confidential. The software may not be copied and the information
+*  contained herein may not be used or disclosed except with the written
+*  permission of MediaTek Inc. (C) 2008
+*
+*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
+*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
+*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
+*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
+*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
+*
+*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
+*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
+*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+*
+*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
+*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
+*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
+*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
+*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
+*
+*****************************************************************************/
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *   imx179mipiraw_sensor.h
+ *
+ * Project:
+ * --------
+ *   YUSU
+ *
+ * Description:
+ * ------------
+ *   Header file of Sensor driver
+ *
+ *
+ * Author:
+
+ *============================================================================
+ ****************************************************************************/
+#ifndef _IMX179mipi_SENSOR_H
+#define _IMX179mipi_SENSOR_H
+
+
+typedef enum{
+	IMGSENSOR_MODE_INIT,
+	IMGSENSOR_MODE_PREVIEW,
+	IMGSENSOR_MODE_CAPTURE,
+	IMGSENSOR_MODE_VIDEO,
+	IMGSENSOR_MODE_HIGH_SPEED_VIDEO,
+	IMGSENSOR_MODE_SLIM_VIDEO,
+    IMGSENSOR_MODE_CUSTOM1,
+    IMGSENSOR_MODE_CUSTOM2,
+    IMGSENSOR_MODE_CUSTOM3,
+    IMGSENSOR_MODE_CUSTOM4,
+    IMGSENSOR_MODE_CUSTOM5,
+} IMGSENSOR_MODE;
+
+typedef struct imgsensor_mode_struct {
+	kal_uint32 pclk;				//record different mode's pclk
+	kal_uint32 linelength;			//record different mode's linelength
+	kal_uint32 framelength;			//record different mode's framelength
+
+	kal_uint8 startx;				//record different mode's startx of grabwindow
+	kal_uint8 starty;				//record different mode's startx of grabwindow
+
+	kal_uint16 grabwindow_width;	//record different mode's width of grabwindow
+	kal_uint16 grabwindow_height;	//record different mode's height of grabwindow
+
+	/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
+	kal_uint8 mipi_data_lp2hs_settle_dc;
+
+	/*	 following for GetDefaultFramerateByScenario()	*/
+	kal_uint16 max_framerate;
+	
+} imgsensor_mode_struct;
+
+/* SENSOR PRIVATE STRUCT FOR VARIABLES*/
+typedef struct imgsensor_struct {
+	kal_uint8 mirror;				//mirrorflip information
+
+	kal_uint8 sensor_mode;			//record IMGSENSOR_MODE enum value
+
+	kal_uint32 shutter;				//current shutter
+	kal_uint16 gain;				//current gain
+	
+	kal_uint32 pclk;				//current pclk
+
+	kal_uint32 frame_length;		//current framelength
+	kal_uint32 line_length;			//current linelength
+
+	kal_uint32 min_frame_length;	//current min  framelength to max framerate
+	kal_uint16 dummy_pixel;			//current dummypixel
+	kal_uint16 dummy_line;			//current dummline
+	
+	kal_uint16 current_fps;			//current max fps
+	kal_bool   autoflicker_en;		//record autoflicker enable or disable
+	kal_bool test_pattern;			//record test pattern mode or not
+	MSDK_SCENARIO_ID_ENUM current_scenario_id;//current scenario id
+	kal_uint8  ihdr_en;				//ihdr enable or disable
+	
+	kal_uint8 i2c_write_id;			//record current sensor's i2c write id
+} imgsensor_struct;
+
+/* SENSOR PRIVATE STRUCT FOR CONSTANT*/
+typedef struct imgsensor_info_struct { 
+    kal_uint32 sensor_id;           //record sensor id defined in Kd_imgsensor.h
+	kal_uint32 checksum_value;		//checksum value for Camera Auto Test
+	imgsensor_mode_struct pre;		//preview scenario relative information
+	imgsensor_mode_struct cap;		//capture scenario relative information
+	imgsensor_mode_struct cap1;		//capture for PIP 24fps relative information
+	imgsensor_mode_struct normal_video;//normal video  scenario relative information
+	imgsensor_mode_struct hs_video;	//high speed video scenario relative information
+    imgsensor_mode_struct slim_video;   //slim video for VT scenario relative information
+    imgsensor_mode_struct custom1;      //custom1 scenario relative information
+    imgsensor_mode_struct custom2;      //custom2 scenario relative information
+    imgsensor_mode_struct custom3;      //custom3 scenario relative information
+    imgsensor_mode_struct custom4;      //custom4 scenario relative information
+    imgsensor_mode_struct custom5;      //custom5 scenario relative information
+	
+	kal_uint8  ae_shut_delay_frame;	//shutter delay frame for AE cycle
+	kal_uint8  ae_sensor_gain_delay_frame;	//sensor gain delay frame for AE cycle
+	kal_uint8  ae_ispGain_delay_frame;	//isp gain delay frame for AE cycle
+	kal_uint8  ihdr_support;		//1, support; 0,not support
+	kal_uint8  ihdr_le_firstline;	//1,le first ; 0, se first
+	kal_uint8  sensor_mode_num;		//support sensor mode num
+	
+	kal_uint8  cap_delay_frame;		//enter capture delay frame num
+	kal_uint8  pre_delay_frame;		//enter preview delay frame num
+	kal_uint8  video_delay_frame;	//enter video delay frame num
+	kal_uint8  hs_video_delay_frame;	//enter high speed video  delay frame num
+	kal_uint8  slim_video_delay_frame;	//enter slim video delay frame num
+    kal_uint8  custom1_delay_frame;     //enter custom1 delay frame num
+    kal_uint8  custom2_delay_frame;     //enter custom1 delay frame num
+    kal_uint8  custom3_delay_frame;     //enter custom1 delay frame num
+    kal_uint8  custom4_delay_frame;     //enter custom1 delay frame num
+    kal_uint8  custom5_delay_frame;     //enter custom1 delay frame num
+  
+	kal_uint8  margin;				//sensor framelength & shutter margin 
+	kal_uint32 min_shutter;			//min shutter
+	kal_uint32 max_frame_length;	//max framelength by sensor register's limitation
+
+	kal_uint8  isp_driving_current;	//mclk driving current
+	kal_uint8  sensor_interface_type;//sensor_interface_type
+    kal_uint8  mipi_sensor_type; //0,MIPI_OPHY_NCSI2; 1,MIPI_OPHY_CSI2, default is NCSI2, don't modify this para
+    kal_uint8  mipi_settle_delay_mode; //0, high speed signal auto detect; 1, use settle delay,unit is ns, default is auto detect, don't modify this para
+	kal_uint8  sensor_output_dataformat;
+	kal_uint8  mclk;				//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
+	
+	kal_uint8  mipi_lane_num;		//mipi lane num
+	kal_uint8  i2c_addr_table[5];	//record sensor support all write id addr, only supprt 4must end with 0xff
+    kal_uint32  i2c_speed;     //i2c speed
+} imgsensor_info_struct;
+
+/* SENSOR READ/WRITE ID */
+//#define IMGSENSOR_WRITE_ID_1 (0x6c)
+//#define IMGSENSOR_READ_ID_1  (0x6d)
+//#define IMGSENSOR_WRITE_ID_2 (0x20)
+//#define IMGSENSOR_READ_ID_2  (0x21)
+
+extern int iReadRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u8 * a_pRecvData, u16 a_sizeRecvData, u16 i2cId);
+extern int iWriteRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u16 i2cId);
+extern void kdSetI2CSpeed(u16 i2cSpeed);
+
+#endif 
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/imx219_mipi_raw/imx219mipiraw_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx219_mipi_raw/imx219mipiraw_Sensor.c
index 8027bda..cb51955 100644
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/imx219_mipi_raw/imx219mipiraw_Sensor.c
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx219_mipi_raw/imx219mipiraw_Sensor.c
@@ -216,7 +216,11 @@ static imgsensor_info_struct imgsensor_info = {
 	.sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,//sensor_interface_type
 	.mipi_sensor_type = MIPI_OPHY_NCSI2, //0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2
 	.mipi_settle_delay_mode = 1,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
+#ifdef VANZO_IMGSENSOR_IMX219_ROTATION
+	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_B,//sensor output first pixel color
+#else
 	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_R,//sensor output first pixel color
+#endif
 	.mclk = 24,//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
 	.mipi_lane_num = SENSOR_MIPI_4_LANE,//mipi lane num
 	.i2c_addr_table = {0x21, 0x20, 0xff},//record sensor support all write id addr, only supprt 4must end with 0xff
@@ -225,7 +229,11 @@ static imgsensor_info_struct imgsensor_info = {
 
 
 static imgsensor_struct imgsensor = {
+#ifdef VANZO_IMGSENSOR_IMX219_ROTATION
 	.mirror = IMAGE_NORMAL,				//mirrorflip information
+#else
+	.mirror = IMAGE_HV_MIRROR,				//mirrorflip information
+#endif
 	.sensor_mode = IMGSENSOR_MODE_INIT, //IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
 	.shutter = 0x3D0,					//current shutter
 	.gain = 0x100,						//current gain
@@ -585,7 +593,7 @@ static kal_uint16 gain2reg(const kal_uint16 gain)
 * GLOBALS AFFECTED
 *
 *************************************************************************/
-UINT16 iPreGain = 0;
+static UINT16 iPreGain = 0;
 static kal_uint16 set_gain(kal_uint16 gain)
 {
 	kal_uint16 reg_gain;
@@ -638,7 +646,7 @@ static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gai
 }
 
 
-#if 0
+#if 1
 static void set_mirror_flip(kal_uint8 image_mirror)
 {
 	LOG_INF("image_mirror = %d\n", image_mirror);
@@ -1089,7 +1097,7 @@ static void slim_video_setting(void)
 	}
 }
 //
-kal_uint8  test_pattern_flag=0;
+static kal_uint8  test_pattern_flag=0;
 
 static kal_uint32 set_test_pattern_mode(kal_bool enable)
 {
@@ -1288,7 +1296,7 @@ static kal_uint32 open(void)
 
 	/* initail sequence write in  */
 	sensor_init();
-
+    set_mirror_flip(imgsensor.mirror);
 	iPreGain = 0;
 
 	spin_lock(&imgsensor_drv_lock);
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/kd_sensorlist.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/kd_sensorlist.c
old mode 100644
new mode 100755
index fe5208c..0ebddf6
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/kd_sensorlist.c
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/kd_sensorlist.c
@@ -41,18 +41,6 @@
 
 #include <mach/mt_chip.h>
 
-#ifdef CONFIG_HCT_DEVICE_INFO_SUPPORT
-//#include "hct_devices.h"
-extern int hct_set_camera_device_used(char * module_name, int pdata);
-typedef enum 
-{ 
-    DEVICE_SUPPORTED = 0,        
-    DEVICE_USED = 1,
-}campatible_type;
-
-#endif
-
-
 /* Camera information */
 #define PROC_CAMERA_INFO "driver/camera_info"
 #define camera_info_size 128
@@ -149,7 +137,7 @@ inline static void KD_IMGSENSOR_PROFILE(char *tag) {}
 *
 ********************************************************************************/
 extern int kdCISModulePowerOn(CAMERA_DUAL_CAMERA_SENSOR_ENUM SensorIdx, char *currSensorName, BOOL On, char *mode_name);
-//extern void checkPowerBeforClose( char* mode_name);
+extern void checkPowerBeforClose( char* mode_name);
 /* extern ssize_t strobe_VDIrq(void);  //cotta : add for high current solution */
 
 /*******************************************************************************
@@ -189,8 +177,7 @@ static u32 gI2CBusNum = SUPPORT_I2C_BUS_NUM1;
 static DEFINE_MUTEX(kdCam_Mutex);
 static BOOL bSesnorVsyncFlag = FALSE;
 static ACDK_KD_SENSOR_SYNC_STRUCT g_NewSensorExpGain = {128, 128, 128, 128, 1000, 640, 0xFF, 0xFF, 0xFF, 0};
-char g_MainSensorName[32] = KDIMGSENSOR_NOSENSOR;
-char g_SubSensorName[32] = KDIMGSENSOR_NOSENSOR;
+
 
 extern MULTI_SENSOR_FUNCTION_STRUCT2 kd_MultiSensorFunc;
 static MULTI_SENSOR_FUNCTION_STRUCT2 *g_pSensorFunc = &kd_MultiSensorFunc;
@@ -1404,30 +1391,28 @@ inline static int adopt_CAMERA_HW_CheckIsAlive(void)
 
             PK_DBG(" Sensor found ID = 0x%x\n", sensorID);
             snprintf(mtk_ccm_name,sizeof(mtk_ccm_name),"%s CAM[%d]:%s;",mtk_ccm_name,g_invokeSocketIdx[i],g_invokeSensorNameStr[i]);
-            #ifdef CONFIG_HCT_DEVICE_INFO_SUPPORT
-            hct_set_camera_device_used(g_invokeSensorNameStr[i], (int)g_invokeSocketIdx[i]);
-            #endif
             err = ERROR_NONE;
-					if (DUAL_CAMERA_MAIN_SENSOR == g_invokeSocketIdx[i])
-					{
-						if(0==strcmp(g_MainSensorName,KDIMGSENSOR_NOSENSOR))
-						{
-							memcpy((char*)g_MainSensorName,(char*)g_invokeSensorNameStr[i],sizeof(g_invokeSensorNameStr[i]));  
-						}
-					}
-					else
-					{
-						if(0==strcmp(g_SubSensorName,KDIMGSENSOR_NOSENSOR))
-						{
-							memcpy((char*)g_SubSensorName,(char*)g_invokeSensorNameStr[i],sizeof(g_invokeSensorNameStr[i]));  
-						}
-	
-					}
         }
         if (ERROR_NONE != err)
         {
             PK_DBG("ERROR:adopt_CAMERA_HW_CheckIsAlive(), No imgsensor alive\n");
         }
+/* Vanzo:maxiaojun on: Mon, 26 Aug 2013 17:04:18 +0800
+ * board device name support.
+ */
+#ifdef VANZO_DEVICE_NAME_SUPPORT
+        {
+          extern void v_set_dev_name(int id, char *name);
+          if(ERROR_NONE == err){
+            if(DUAL_CAMERA_MAIN_SENSOR==g_invokeSocketIdx[i]){
+              v_set_dev_name(3, (char *)g_invokeSensorNameStr[i]);
+            }else if(DUAL_CAMERA_SUB_SENSOR==g_invokeSocketIdx[i]){
+              v_set_dev_name(4, (char *)g_invokeSensorNameStr[i]);
+            }
+          }
+        }
+#endif
+// End of Vanzo:maxiaojun
         }
     }
     }
@@ -2170,7 +2155,6 @@ inline static int kdSetSensorGpio(int *pBuf)
 #ifndef GPIO_CMPCLK_M_CMCSK
     #define GPIO_CMPCLK_M_CMCSK   GPIO_MODE_02
 #endif
-
     int ret = 0;
     IMGSENSOR_GPIO_STRUCT *pSensorgpio = (IMGSENSOR_GPIO_STRUCT *)pBuf;
 
@@ -2777,7 +2761,7 @@ static int CAMERA_HW_Release(struct inode *a_pstInode, struct file *a_pstFile)
     atomic_dec(&g_CamDrvOpenCnt);
 //	PK_DBG("[CAMERA_HW_Release] g_CamDrvOpenCnt %d\n",g_CamDrvOpenCnt);
 	//if (atomic_read(&g_CamDrvOpenCnt) == 0)
-//	checkPowerBeforClose( CAMERA_HW_DRVNAME1);
+	checkPowerBeforClose( CAMERA_HW_DRVNAME1);
 
     return 0;
 }
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/kd_sensorlist.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/kd_sensorlist.h
old mode 100644
new mode 100755
index 88343f3..584d013
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/kd_sensorlist.h
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/kd_sensorlist.h
@@ -2,26 +2,25 @@
 //export funtions
 /*IMX*/
 UINT32 IMX220_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
+UINT32 IMX145_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 IMX219_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 IMX214_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 IMX175_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 IMX145_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 IMX179_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
+UINT32 IMX175_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
+UINT32 IMX164_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 IMX132_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 IMX135_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 IMX105_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 IMX073_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 IMX164_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
+UINT32 IMX166_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 /*OV*/
 UINT32 OV16825MIPISensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 SP2508_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 OV13850_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 OV12830_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 OV9760MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 OV9740_MIPI_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 OV9726_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT * pfFunc);
 UINT32 OV9726MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT * pfFunc);
-UINT32 OV8856_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 OV8865_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 OV8858_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 OV8830SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
@@ -49,15 +48,16 @@ UINT32 OV2680MIPISensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 OV2659_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 OV2655_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 OV2650SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 S5K5E2YA_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 /*S5K*/
+UINT32 S5K3M2_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 S5K2P8_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 S5K3H2YX_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 S5K3H7Y_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 S5K4H5YC_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 S5K4H5YX_2LANE_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 S5K5E2YA_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 S5K4E2GX_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
+UINT32 S5K5E2YA_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
+UINT32 S5K5E2YASUB_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 S5K5CAGX_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 S5K4E1GA_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 S5K4ECGX_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
@@ -65,6 +65,7 @@ UINT32 S5K4ECGX_MIPI_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 S5K4ECGX_MIPI_JPG_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 S5K8AAYX_MIPI_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 S5K8AAYX_PVI_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
+UINT32 S5K3H5XA_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 /*HI*/
 UINT32 HI841_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 HI707_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
@@ -88,26 +89,28 @@ UINT32 MT9V114_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 MT9D115MIPISensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 MT9V115_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 /*GC*/
-UINT32 GC5004MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 GC5005MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 GC5024MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
+UINT32 GC2235_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 GC2755_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 GC2355_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 GC2355_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 GC2235_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 GC2155MIPI_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 GC2145MIPI_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 GC2145_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 GC2035_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 GC0330_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 GC0329_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 GC0313MIPI_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 GC0310_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 GC2145MIPI_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 GC0312_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
+UINT32 GC0310MAIN_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
+UINT32 GC2155MIPI_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
+UINT32 GC0409MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
+UINT32 GC5004MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
+UINT32 GC5024MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 /*SP*/
 UINT32 SP0A19_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-
+UINT32 SP0A20_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
+UINT32 SP2508_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
+UINT32 SP5409MIPISensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
+UINT32 SP5409SUBMIPISensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
+UINT32 SP8408_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 /*A*/
 UINT32 A5141_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 A5142_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
@@ -128,13 +131,6 @@ UINT32 T4KA7_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 /*Others*/
 UINT32 ISX012_MIPI_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
 UINT32 T8EV5_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 S5K3H7YX_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 HM5040MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 HM8131MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-
-UINT32 OV5693_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 SP8408_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 JX507MIPISensorInit( PSENSOR_FUNCTION_STRUCT *pfFunc);
 
 //! Add Sensor Init function here
 //! Note:
@@ -148,21 +144,24 @@ ACDK_KD_SENSOR_INIT_FUNCTION_STRUCT kdSensorList[MAX_NUM_OF_SUPPORT_SENSOR+1] =
 #if defined(IMX220_MIPI_RAW)
     {IMX220_SENSOR_ID, SENSOR_DRVNAME_IMX220_MIPI_RAW, IMX220_MIPI_RAW_SensorInit},
 #endif
+#if defined(IMX145_MIPI_RAW)
+    {IMX145_SENSOR_ID, SENSOR_DRVNAME_IMX145_MIPI_RAW, IMX145_MIPI_RAW_SensorInit},
+#endif
 #if defined(IMX219_MIPI_RAW)
     {IMX219_SENSOR_ID, SENSOR_DRVNAME_IMX219_MIPI_RAW, IMX219_MIPI_RAW_SensorInit},
 #endif
 #if defined(IMX214_MIPI_RAW)
     {IMX214_SENSOR_ID, SENSOR_DRVNAME_IMX214_MIPI_RAW, IMX214_MIPI_RAW_SensorInit},
 #endif
-#if defined(IMX175_MIPI_RAW)
-    {IMX175_SENSOR_ID, SENSOR_DRVNAME_IMX175_MIPI_RAW,IMX175_MIPI_RAW_SensorInit},
-#endif
-#if defined(IMX145_MIPI_RAW)
-    {IMX145_SENSOR_ID, SENSOR_DRVNAME_IMX145_MIPI_RAW,IMX145_MIPI_RAW_SensorInit},
-#endif
 #if defined(IMX179_MIPI_RAW)
     {IMX179_SENSOR_ID, SENSOR_DRVNAME_IMX179_MIPI_RAW,IMX179_MIPI_RAW_SensorInit},
 #endif
+#if defined(IMX179_MIPI_RAW_4LANE)
+    {IMX179_SENSOR_ID, SENSOR_DRVNAME_IMX179_MIPI_RAW_4LANE,IMX179_MIPI_RAW_SensorInit},
+#endif
+#if defined(IMX164_MIPI_RAW)
+    {IMX164_SENSOR_ID, SENSOR_DRVNAME_IMX164_MIPI_RAW,IMX164_MIPI_RAW_SensorInit},
+#endif
 #if defined(IMX132_MIPI_RAW)
     {IMX132MIPI_SENSOR_ID, SENSOR_DRVNAME_IMX132_MIPI_RAW, IMX132_MIPI_RAW_SensorInit},
 #endif
@@ -175,6 +174,10 @@ ACDK_KD_SENSOR_INIT_FUNCTION_STRUCT kdSensorList[MAX_NUM_OF_SUPPORT_SENSOR+1] =
 #if defined(IMX073_MIPI_RAW)
     {IMX073_SENSOR_ID, SENSOR_DRVNAME_IMX073_MIPI_RAW, IMX073_MIPI_RAW_SensorInit},
 #endif
+#if defined(IMX166_MIPI_RAW)
+	{IMX166_SENSOR_ID, SENSOR_DRVNAME_IMX166_MIPI_RAW, IMX166_MIPI_RAW_SensorInit},
+#endif
+
 /*OV (OmniVision)*/
 #if defined(OV16825_MIPI_RAW)
     {OV16825MIPI_SENSOR_ID, SENSOR_DRVNAME_OV16825_MIPI_RAW, OV16825MIPISensorInit},
@@ -200,30 +203,21 @@ ACDK_KD_SENSOR_INIT_FUNCTION_STRUCT kdSensorList[MAX_NUM_OF_SUPPORT_SENSOR+1] =
 #if defined(OV8865_MIPI_RAW)
     {OV8865_SENSOR_ID, SENSOR_DRVNAME_OV8865_MIPI_RAW,OV8865_MIPI_RAW_SensorInit},
 #endif
-#if defined(S5K3H7YX_MIPI_RAW)
-    {S5K3H7YX_SENSOR_ID, SENSOR_DRVNAME_S5K3H7YX_MIPI_RAW, S5K3H7YX_MIPI_RAW_SensorInit},
-#endif
-#if defined(OV8856_MIPI_RAW)
-    {OV8856_SENSOR_ID, SENSOR_DRVNAME_OV8856_MIPI_RAW,OV8856_MIPI_RAW_SensorInit},
-#endif
 #if defined(OV8858_MIPI_RAW)
     {OV8858_SENSOR_ID, SENSOR_DRVNAME_OV8858_MIPI_RAW,OV8858_MIPI_RAW_SensorInit},
 #endif
-
-#if defined(OV8858R2A_MIPI_RAW)
-    {OV8858_SENSOR_ID, SENSOR_DRVNAME_OV8858_MIPI_RAW,OV8858_MIPI_RAW_SensorInit}, 
-#endif
 #if defined(OV8830_RAW)
     {OV8830_SENSOR_ID, SENSOR_DRVNAME_OV8830_RAW, OV8830SensorInit},
 #endif
-
 #if defined(OV8825_MIPI_RAW)
     {OV8825_SENSOR_ID, SENSOR_DRVNAME_OV8825_MIPI_RAW, OV8825_MIPI_RAW_SensorInit},
 #endif
 #if defined(OV7675_YUV)
     {OV7675_SENSOR_ID, SENSOR_DRVNAME_OV7675_YUV, OV7675_YUV_SensorInit},
 #endif
-
+#if defined(OV5693_MIPI_RAW)
+    {OV5693_SENSOR_ID, SENSOR_DRVNAME_OV5693_MIPI_RAW, OV5693_MIPI_RAW_SensorInit},
+#endif
 #if defined(OV5670_MIPI_RAW)
     {OV5670MIPI_SENSOR_ID, SENSOR_DRVNAME_OV5670_MIPI_RAW, OV5670_MIPI_RAW_SensorInit},
 #endif
@@ -288,6 +282,9 @@ ACDK_KD_SENSOR_INIT_FUNCTION_STRUCT kdSensorList[MAX_NUM_OF_SUPPORT_SENSOR+1] =
     {OV2650_SENSOR_ID, SENSOR_DRVNAME_OV2650_RAW,OV2650SensorInit},
 #endif
 /*S5K*/
+#if defined(S5K3M2_MIPI_RAW)
+    {S5K3M2_SENSOR_ID, SENSOR_DRVNAME_S5K3M2_MIPI_RAW, S5K3M2_MIPI_RAW_SensorInit},
+#endif
 #if defined(S5K2P8_MIPI_RAW)
     {S5K2P8_SENSOR_ID, SENSOR_DRVNAME_S5K2P8_MIPI_RAW, S5K2P8_MIPI_RAW_SensorInit},
 #endif
@@ -303,9 +300,15 @@ ACDK_KD_SENSOR_INIT_FUNCTION_STRUCT kdSensorList[MAX_NUM_OF_SUPPORT_SENSOR+1] =
 #if defined(S5K4H5YX_2LANE_MIPI_RAW)
     {S5K4H5YX_2LANE_SENSOR_ID, SENSOR_DRVNAME_S5K4H5YX_2LANE_MIPI_RAW, S5K4H5YX_2LANE_MIPI_RAW_SensorInit},
 #endif
+#if defined(S5K4E2GX_MIPI_RAW)
+    {S5K4E2GX_SENSOR_ID, SENSOR_DRVNAME_S5K4E2GX_MIPI_RAW, S5K4E2GX_MIPI_RAW_SensorInit}, 
+#endif
 #if defined(S5K5E2YA_MIPI_RAW)
     {S5K5E2YA_SENSOR_ID, SENSOR_DRVNAME_S5K5E2YA_MIPI_RAW, S5K5E2YA_MIPI_RAW_SensorInit},
 #endif
+#if defined(S5K5E2YASUB_MIPI_RAW)
+    {S5K5E2YASUB_SENSOR_ID, SENSOR_DRVNAME_S5K5E2YASUB_MIPI_RAW, S5K5E2YASUB_MIPI_RAW_SensorInit},
+#endif
 #if defined(S5K5CAGX_YUV)
     {S5K5CAGX_SENSOR_ID, SENSOR_DRVNAME_S5K5CAGX_YUV, S5K5CAGX_YUV_SensorInit},
 #endif
@@ -327,6 +330,9 @@ ACDK_KD_SENSOR_INIT_FUNCTION_STRUCT kdSensorList[MAX_NUM_OF_SUPPORT_SENSOR+1] =
 #if defined(S5K8AAYX_YUV)
     {S5K8AAYX_MIPI_SENSOR_ID, SENSOR_DRVNAME_S5K8AAYX_YUV, S5K8AAYX_PVI_YUV_SensorInit},
 #endif
+#if defined(S5K3H5XA_MIPI_RAW)
+    {S5K3H5XA_SENSOR_ID, SENSOR_DRVNAME_S5K3H5XA_MIPI_RAW, S5K3H5XA_MIPI_RAW_SensorInit},
+#endif
 /*HI*/
 #if defined(HI841_MIPI_RAW)
     {HI841_SENSOR_ID, SENSOR_DRVNAME_HI841_MIPI_RAW,HI841_MIPI_RAW_SensorInit},
@@ -390,36 +396,25 @@ ACDK_KD_SENSOR_INIT_FUNCTION_STRUCT kdSensorList[MAX_NUM_OF_SUPPORT_SENSOR+1] =
   {MT9V115_SENSOR_ID,SENSOR_DRVNAME_MT9V115_YUV,MT9V115_YUV_SensorInit},
 #endif
 /*GC*/
-#if defined(GC5004_MIPI_RAW)
-	{GC5004MIPI_SENSOR_ID, SENSOR_DRVNAME_GC5004MIPI_RAW, GC5004MIPI_RAW_SensorInit},
-#endif
-#if defined(GC5005_MIPI_RAW)
-       {GC5005MIPI_SENSOR_ID, SENSOR_DRVNAME_GC5005MIPI_RAW, GC5005MIPI_RAW_SensorInit},
-#endif
-#if defined(GC2755_MIPI_RAW)
-    {GC2755_SENSOR_ID, SENSOR_DRVNAME_GC2755_MIPI_RAW,GC2755_MIPI_RAW_SensorInit},
-#endif
 #if defined(GC2355_MIPI_RAW)
     {GC2355_SENSOR_ID, SENSOR_DRVNAME_GC2355_MIPI_RAW,GC2355_MIPI_RAW_SensorInit},
 #endif
-#if defined(GC2355_RAW)
-    {GC2355_SENSOR_ID, SENSOR_DRVNAME_GC2355_RAW,GC2355_RAW_SensorInit},
-#endif
 #if defined(GC2235_RAW)
     {GC2235_SENSOR_ID, SENSOR_DRVNAME_GC2235_RAW, GC2235_RAW_SensorInit},
 #endif
-#if defined(GC2145_MIPI_YUV)
-    {GC2145_SENSOR_ID, SENSOR_DRVNAME_GC2145_MIPI_YUV, GC2145MIPI_YUV_SensorInit},
-#endif
-#if defined(GC2155_MIPI_YUV)
-    {GC2155MIPI_SENSOR_ID, SENSOR_DRVNAME_GC2155_MIPI_YUV, GC2155MIPI_YUV_SensorInit}, 
-#endif
-#if defined(GC2145_YUV)
-    {GC2145_SENSOR_ID, SENSOR_DRVNAME_GC2145_YUV, GC2145_YUV_SensorInit}, 
+#if defined(GC2235_MIPI_RAW)
+    {GC2235MIPI_SENSOR_ID, SENSOR_DRVNAME_GC2235_MIPI_RAW, GC2235_MIPI_RAW_SensorInit},
 #endif
 #if defined(GC2035_YUV)
     {GC2035_SENSOR_ID, SENSOR_DRVNAME_GC2035_YUV, GC2035_YUV_SensorInit},
 #endif
+#if defined(GC2145_MIPI_YUV)
+    {GC2145_SENSOR_ID, SENSOR_DRVNAME_GC2145_MIPI_YUV, GC2145MIPI_YUV_SensorInit},
+#endif
+
+#if defined(GC2155MIPI_YUV)
+    {GC2155MIPI_SENSOR_ID,SENSOR_DRVNAME_GC2155_MIPI_YUV,GC2155MIPI_YUV_SensorInit},
+#endif
 #if defined(GC0330_YUV)
     {GC0330_SENSOR_ID, SENSOR_DRVNAME_GC0330_YUV, GC0330_YUV_SensorInit},
 #endif
@@ -432,15 +427,42 @@ ACDK_KD_SENSOR_INIT_FUNCTION_STRUCT kdSensorList[MAX_NUM_OF_SUPPORT_SENSOR+1] =
 #if defined(GC0310_MIPI_YUV)
     {GC0310_SENSOR_ID, SENSOR_DRVNAME_GC0310_MIPI_YUV,GC0310_YUV_SensorInit},
 #endif
+#if defined(GC0310MAIN_MIPI_YUV)
+    {GC0310MAIN_SENSOR_ID, SENSOR_DRVNAME_GC0310MAIN_MIPI_YUV,GC0310MAIN_YUV_SensorInit},
+#endif
 #if defined(GC0310_YUV)
     {GC0310_SENSOR_ID, SENSOR_DRVNAME_GC0310_YUV,GC0310_YUV_SensorInit},
 #endif
-#if defined(GC0312_YUV)
-    {GC0312_SENSOR_ID, SENSOR_DRVNAME_GC0312_YUV, GC0312_YUV_SensorInit}, 
+#if defined(GC2755_MIPI_RAW)
+    {GC2755_SENSOR_ID,SENSOR_DRVNAME_GC2755_MIPI_RAW, GC2755_MIPI_RAW_SensorInit},
+#endif
+#if defined(GC0409_MIPI_RAW)
+    {GC0409_SENSOR_ID, SENSOR_DRVNAME_GC0409MIPI_RAW,GC0409MIPI_RAW_SensorInit},
+#endif
+#if defined(GC5004_MIPI_RAW)
+    {GC5004MIPI_SENSOR_ID, SENSOR_DRVNAME_GC5004_MIPI_RAW, GC5004MIPI_RAW_SensorInit},
+#endif
+#if defined(GC5024_MIPI_RAW)
+    {GC5024MIPI_SENSOR_ID, SENSOR_DRVNAME_GC5024_MIPI_RAW, GC5024MIPI_RAW_SensorInit},
 #endif
 /*SP*/
 #if defined(SP0A19_YUV)
-    {SP0A19_SENSOR_ID, SENSOR_DRVNAME_SP0A19_YUV, SP0A19_YUV_SensorInit}, 
+    {SP0A19_YUV_SENSOR_ID, SENSOR_DRVNAME_SP0A19_YUV, SP0A19_YUV_SensorInit},
+#endif
+#if defined(SP0A20_YUV)
+    {SP0A20_SENSOR_ID, SENSOR_DRVNAME_SP0A20_YUV, SP0A20_YUV_SensorInit},
+#endif
+#if defined(SP2508_MIPI_RAW)
+    {SP2508_SENSOR_ID, SENSOR_DRVNAME_SP2508_MIPI_RAW, SP2508_MIPI_RAW_SensorInit},
+#endif
+#if defined(SP5409_MIPI_RAW)
+    {SP5409MIPI_SENSOR_ID, SENSOR_DRVNAME_SP5409_MIPI_RAW, SP5409MIPISensorInit},
+#endif
+#if defined(SP5409SUB_MIPI_RAW)
+    {SP5409SUBMIPI_SENSOR_ID, SENSOR_DRVNAME_SP5409SUB_MIPI_RAW, SP5409SUBMIPISensorInit},
+#endif
+#if defined(SP8408_MIPI_RAW)
+    {SP8408MIPI_SENSOR_ID, SENSOR_DRVNAME_SP8408_MIPI_RAW, SP8408_MIPI_RAW_SensorInit},
 #endif
 /*A*/
 #if defined(A5141_MIPI_RAW)
@@ -490,38 +512,6 @@ ACDK_KD_SENSOR_INIT_FUNCTION_STRUCT kdSensorList[MAX_NUM_OF_SUPPORT_SENSOR+1] =
 #if defined(IMX135_MIPI_RAW_5MP)
     {IMX135_SENSOR_ID, SENSOR_DRVNAME_IMX135_MIPI_RAW_5MP, IMX135_MIPI_RAW_SensorInit},
 #endif
-#if defined(SP2508_MIPI_RAW)
-    {SP2508MIPI_SENSOR_ID, SENSOR_DRVNAME_SP2508_MIPI_RAW,SP2508_MIPI_RAW_SensorInit},
-#endif
-
-#if defined(HM5040_MIPI_RAW)
-    {HM5040_SENSOR_ID, SENSOR_DRVNAME_HM5040_MIPI_RAW,HM5040MIPI_RAW_SensorInit},
-#endif
-
-#if defined(HM8131_MIPI_RAW)
-    {HM8131MIPI_SENSOR_ID, SENSOR_DRVNAME_HM8131_MIPI_RAW,HM8131MIPI_RAW_SensorInit},
-#endif
-
-#if defined(OV5693_MIPI_RAW)
-    {OV5693MIPI_SENSOR_ID, SENSOR_DRVNAME_OV5693_MIPI_RAW, OV5693_MIPI_RAW_SensorInit},
-#endif
-
-#if defined(IMX164_MIPI_RAW)
-    {IMX164_SENSOR_ID, SENSOR_DRVNAME_IMX164_MIPI_RAW,IMX164_MIPI_RAW_SensorInit},
-#endif
-#if defined(S5K4E2GX_MIPI_RAW)
-    {S5K4E2GX_SENSOR_ID, SENSOR_DRVNAME_S5K4E2GX_MIPI_RAW, S5K4E2GX_MIPI_RAW_SensorInit},
-#endif
-
-#if defined(GC5024_MIPI_RAW)
-	{GC5024MIPI_SENSOR_ID, SENSOR_DRVNAME_GC5024MIPI_RAW, GC5024MIPI_RAW_SensorInit},
-#endif
-#if defined(JX507_MIPI_RAW)
-    {JX507MIPI_SENSOR_ID, SENSOR_DRVNAME_JX507_MIPI_RAW,JX507MIPISensorInit},
-#endif
-#if defined(SP8408_MIPI_RAW)
-    {SP8408MIPI_SENSOR_ID, SENSOR_DRVNAME_SP8408_MIPI_RAW,SP8408_MIPI_RAW_SensorInit},
-#endif
 /*  ADD sensor driver before this line */
     {0,{0},NULL}, //end of list
 };
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/ov2680_mipi_raw/ov2680mipi_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/ov2680_mipi_raw/ov2680mipi_Sensor.c
old mode 100644
new mode 100755
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/ov2680_mipi_raw/ov2680mipi_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/ov2680_mipi_raw/ov2680mipi_Sensor.h
old mode 100644
new mode 100755
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/ov5648_mipi_raw/ov5648mipi_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/ov5648_mipi_raw/ov5648mipi_Sensor.c
index 10cac67..2205236 100755
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/ov5648_mipi_raw/ov5648mipi_Sensor.c
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/ov5648_mipi_raw/ov5648mipi_Sensor.c
@@ -149,7 +149,11 @@ static imgsensor_info_struct imgsensor_info = {
 
 
 static imgsensor_struct imgsensor = {
+#ifdef VANZO_IMGSENSOR_OV5648_ROTATION
+    .mirror = IMAGE_HV_MIRROR,                //mirrorflip information
+#else
     .mirror = IMAGE_NORMAL,                //mirrorflip information
+#endif
     .sensor_mode = IMGSENSOR_MODE_INIT, //IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
     .shutter = 0x3D0,                    //current shutter
     .gain = 0x100,                        //current gain
@@ -378,7 +382,6 @@ static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gai
     //LOG_INF("le:0x%x, se:0x%x, gain:0x%x\n",le,se,gain);
 }
 
-#if 0
 static void set_mirror_flip(kal_uint8 image_mirror)
 {
     LOG_INF("image_mirror = %d\n", image_mirror);
@@ -394,7 +397,6 @@ static void set_mirror_flip(kal_uint8 image_mirror)
        *   ISP and Sensor flip or mirror register bit should be the same!!
        *
        ********************************************************/
-
     switch (image_mirror) {
         case IMAGE_NORMAL:
             write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x00));
@@ -417,7 +419,6 @@ static void set_mirror_flip(kal_uint8 image_mirror)
     }
 
 }
-#endif
 
 /*************************************************************************
 * FUNCTION
@@ -1267,7 +1268,7 @@ static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
     imgsensor.autoflicker_en = KAL_FALSE;
     spin_unlock(&imgsensor_drv_lock);
     preview_setting();
-    //set_mirror_flip(sensor_config_data->SensorImageMirror);
+    set_mirror_flip(imgsensor.mirror);
     return ERROR_NONE;
 }    /*    preview   */
 
@@ -1310,7 +1311,7 @@ static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
     }
     spin_unlock(&imgsensor_drv_lock);
     capture_setting(imgsensor.current_fps);
-    //set_mirror_flip(sensor_config_data->SensorImageMirror);
+    set_mirror_flip(imgsensor.mirror);
     return ERROR_NONE;
 }    /* capture() */
 static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
@@ -1328,7 +1329,7 @@ static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
     imgsensor.autoflicker_en = KAL_FALSE;
     spin_unlock(&imgsensor_drv_lock);
     normal_video_setting(imgsensor.current_fps);
-    //set_mirror_flip(sensor_config_data->SensorImageMirror);
+    set_mirror_flip(imgsensor.mirror);
     return ERROR_NONE;
 }    /*    normal_video   */
 
@@ -1349,7 +1350,7 @@ static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
     imgsensor.autoflicker_en = KAL_FALSE;
     spin_unlock(&imgsensor_drv_lock);
     hs_video_setting();
-    //set_mirror_flip(sensor_config_data->SensorImageMirror);
+    set_mirror_flip(imgsensor.mirror);
     return ERROR_NONE;
 }    /*    hs_video   */
 
@@ -1369,7 +1370,7 @@ static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
     imgsensor.autoflicker_en = KAL_FALSE;
     spin_unlock(&imgsensor_drv_lock);
     slim_video_setting();
-    //set_mirror_flip(sensor_config_data->SensorImageMirror);
+    set_mirror_flip(imgsensor.mirror);
 
     return ERROR_NONE;
 }    /*    slim_video     */
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/ov5648_mipi_raw/ov5648mipi_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/ov5648_mipi_raw/ov5648mipi_Sensor.h
old mode 100755
new mode 100644
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/ov5670_mipi_raw/ov5670mipi_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/ov5670_mipi_raw/ov5670mipi_Sensor.c
index 06576bc..31ccf2e 100644
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/ov5670_mipi_raw/ov5670mipi_Sensor.c
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/ov5670_mipi_raw/ov5670mipi_Sensor.c
@@ -37,11 +37,15 @@
 #include "ov5670mipi_Sensor.h"
 
 #define PFX "ov5670_camera_sensor"
+//#define LOG_WRN(format, args...) xlog_printk(ANDROID_LOG_WARN ,PFX, "[%S] " format, __FUNCTION__, ##args)
+//#defineLOG_INF(format, args...) xlog_printk(ANDROID_LOG_INFO ,PFX, "[%s] " format, __FUNCTION__, ##args)
+//#define LOG_DBG(format, args...) xlog_printk(ANDROID_LOG_DEBUG ,PFX, "[%S] " format, __FUNCTION__, ##args)
 #define LOG_INF(format, args...)	xlog_printk(ANDROID_LOG_INFO   , PFX, "[%s] " format, __FUNCTION__, ##args)
 
 static DEFINE_SPINLOCK(imgsensor_drv_lock);
 
 
+
 static imgsensor_info_struct imgsensor_info = { 
 	.sensor_id = OV5670MIPI_SENSOR_ID,		//record sensor id defined in Kd_imgsensor.h
 	
@@ -56,7 +60,7 @@ static imgsensor_info_struct imgsensor_info = {
 		.grabwindow_width = 1280,		//record different mode's width of grabwindow
 		.grabwindow_height = 960,		//record different mode's height of grabwindow
 		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
-		.mipi_data_lp2hs_settle_dc = 65,//unit , ns
+		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
 		/*	 following for GetDefaultFramerateByScenario()	*/
 		.max_framerate = 300,	
 	},
@@ -68,7 +72,7 @@ static imgsensor_info_struct imgsensor_info = {
 		.starty = 0,
 		.grabwindow_width = 2560,
 		.grabwindow_height = 1920,
-		.mipi_data_lp2hs_settle_dc = 65,//unit , ns
+		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
 		.max_framerate = 300,
 	},
 	.cap1 = {							//capture for PIP 24fps relative information, capture1 mode must use same framelength, linelength with Capture mode for shutter calculate
@@ -79,7 +83,7 @@ static imgsensor_info_struct imgsensor_info = {
 		.starty = 0,
 		.grabwindow_width = 2560,
 		.grabwindow_height = 1920,
-		.mipi_data_lp2hs_settle_dc = 65,//unit , ns
+		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
 		.max_framerate = 150,	//less than 13M(include 13M),cap1 max framerate is 24fps,16M max framerate is 20fps, 20M max framerate is 15fps  
 	},
 	.normal_video = {
@@ -90,7 +94,7 @@ static imgsensor_info_struct imgsensor_info = {
 		.starty = 0,
 		.grabwindow_width = 1280,
 		.grabwindow_height = 960,
-		.mipi_data_lp2hs_settle_dc = 65,//unit , ns
+		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
 		.max_framerate = 300,
 	},
 	.hs_video = {
@@ -101,7 +105,7 @@ static imgsensor_info_struct imgsensor_info = {
 		.starty = 0,
 		.grabwindow_width = 640,
 		.grabwindow_height = 480,
-		.mipi_data_lp2hs_settle_dc = 65,//unit , ns
+		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
 		.max_framerate = 1200,
 	},
 	.slim_video = {
@@ -112,7 +116,7 @@ static imgsensor_info_struct imgsensor_info = {
 		.starty = 0,
 		.grabwindow_width = 1280,
 		.grabwindow_height = 960,
-		.mipi_data_lp2hs_settle_dc = 65,//unit , ns
+		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
 		.max_framerate = 300,
 	},
 	.margin = 4,			//sensor framelength & shutter margin
@@ -134,7 +138,7 @@ static imgsensor_info_struct imgsensor_info = {
 	.isp_driving_current = ISP_DRIVING_8MA, //mclk driving current
     .sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,//sensor_interface_type
     .mipi_sensor_type = MIPI_OPHY_NCSI2, //0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2
-    .mipi_settle_delay_mode = 1,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
+    .mipi_settle_delay_mode = MIPI_SETTLEDELAY_AUTO,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
 	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_Gb,//sensor output first pixel color
 	.mclk = 24,//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
 	.mipi_lane_num = SENSOR_MIPI_2_LANE,//mipi lane num
@@ -143,7 +147,11 @@ static imgsensor_info_struct imgsensor_info = {
 
 
 static imgsensor_struct imgsensor = {
+#ifdef VANZO_SUB_CAM_ROTATION
+	.mirror = IMAGE_HV_MIRROR,
+#else
 	.mirror = IMAGE_NORMAL,				//mirrorflip information
+#endif
 	.sensor_mode = IMGSENSOR_MODE_INIT, //IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
 	.shutter = 0x4C00,					//current shutter
 	.gain = 0x0200,						//current gain
@@ -183,6 +191,7 @@ static void write_cmos_sensor(kal_uint32 addr, kal_uint32 para)
 	iWriteRegI2C(pu_send_cmd, 3, imgsensor.i2c_write_id);
 }
 
+
 static void set_dummy()
 {
 	LOG_INF("dummyline = %d, dummypixels = %d \n", imgsensor.dummy_line, imgsensor.dummy_pixel);
@@ -249,9 +258,7 @@ static void write_shutter(kal_uint16 shutter)
 	spin_unlock(&imgsensor_drv_lock);
 	shutter = (shutter < imgsensor_info.min_shutter) ? imgsensor_info.min_shutter : shutter;
 	shutter = (shutter > (imgsensor_info.max_frame_length - imgsensor_info.margin)) ? (imgsensor_info.max_frame_length - imgsensor_info.margin) : shutter;
-
-    // Framelength should be an even number
-    shutter = (shutter >> 1) << 1;
+	shutter = (shutter>>1)<<1;
 	
 	if (imgsensor.autoflicker_en) { 
 		realtime_fps = imgsensor.pclk / imgsensor.line_length * 10 / imgsensor.frame_length;
@@ -405,7 +412,9 @@ static kal_uint16 set_gain(kal_uint16 gain)
 static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gain)
 {
 	LOG_INF("le:0x%x, se:0x%x, gain:0x%x\n",le,se,gain);
+
 	write_cmos_sensor(0x3820, 0x81);   //enable ihdr
+ 	
 	if (imgsensor.ihdr_en) {
 		
 		spin_lock(&imgsensor_drv_lock);
@@ -797,7 +806,6 @@ static void sensor_init(void)
 	//;added					 
 //	write_cmos_sensor(0x3d85, 0x17); 
 //	write_cmos_sensor(0x3655, 0x20); 
-								   
 	write_cmos_sensor(0x0100, 0x01); //;01							   
 
 
@@ -813,7 +821,8 @@ static void preview_setting(void)
 	//;;102 3601	157c														  
 	//;;PCLK=HTS*VTS*fps=0x68c*0x7fd*30=1676*2045*30=102.85M					  
 																			  
-	write_cmos_sensor(0x0100, 0x00);  // 	
+	write_cmos_sensor(0x0100, 0x00);  // 
+
 	write_cmos_sensor(0x0303, 0x00); 
 	
 	write_cmos_sensor(0x3501, 0x73);  // 							  
@@ -863,7 +872,7 @@ static void capture_setting(kal_uint16 currefps)
 	LOG_INF("OV5670CaptureSetting_2lane enter! currefps:%d\n",currefps);
 	if (currefps == 150) { //15fps for PIP
 		write_cmos_sensor(0x0100, 0x00); 
-		
+
 		write_cmos_sensor(0x0303, 0x01); 
 		write_cmos_sensor(0x3501, 0x73); //long exposure
 		write_cmos_sensor(0x3502, 0x00);  //long exposure
@@ -905,7 +914,7 @@ static void capture_setting(kal_uint16 currefps)
 		
 	} else{ // for 30fps need ti update
 		write_cmos_sensor(0x0100, 0x00); 
-		
+
 		write_cmos_sensor(0x0303, 0x00); 
 		write_cmos_sensor(0x3501, 0x73); //long exposure
 		write_cmos_sensor(0x3502, 0x00);  //long exposure
@@ -961,7 +970,7 @@ static void normal_video_setting(kal_uint16 currefps)
 	//;;102 3601	157c														  
 	//;;PCLK=HTS*VTS*fps=0x68c*0x7fd*30=1676*2045*30=102.85M					  
 																			  
-	write_cmos_sensor(0x0100, 0x00);  // 	
+	write_cmos_sensor(0x0100, 0x00);  // 
 	write_cmos_sensor(0x0303, 0x00); 
 	
 	write_cmos_sensor(0x3501, 0x73);  // 							  
@@ -993,6 +1002,7 @@ static void normal_video_setting(kal_uint16 currefps)
 	write_cmos_sensor(0x4601, 0x81);  // 							  
 	write_cmos_sensor(0x4017, 0x10);  //; threshold = 4LSB for Binning 
 	write_cmos_sensor(0x4837, 0x13);
+	
 	write_cmos_sensor(0x400a, 0x02);  //;							  
 	write_cmos_sensor(0x400b, 0x00);  //;	
 	
@@ -1005,6 +1015,7 @@ static void hs_video_setting()
 //VGA 120fps
 	write_cmos_sensor(0x0100,0x00);
 	write_cmos_sensor(0x0303, 0x00); 
+
 	write_cmos_sensor(0x3501,0x1f);
 	write_cmos_sensor(0x3502,0x00);
 	write_cmos_sensor(0x3508,0x07);
@@ -1038,43 +1049,7 @@ static void hs_video_setting()
 	write_cmos_sensor(0x400b,0x00);
 	write_cmos_sensor(0x0100,0x01);
 
-	
-				//@@1080_60fps_800Mbps/lane
-/*
-		//;;99 1920 1080
-		//;;102 3601  1770
-		//;;PCLK=HTS*VTS*fps=0x574*0x4cb*60=1396*1227*60=102.85M
-		write_cmos_sensor(0x0100, 0x00); //
-		write_cmos_sensor(0x3501, 0x45); //
-		write_cmos_sensor(0x3502, 0x00); //
-		write_cmos_sensor(0x3508, 0x02); //
-		write_cmos_sensor(0x3509, 0x80); //
-		write_cmos_sensor(0x366e, 0x10); //
-		write_cmos_sensor(0x370b, 0x05); //; reduce code for 1080p format only
-		write_cmos_sensor(0x3808, 0x07); // H output size : 0x780= 1920
-		write_cmos_sensor(0x3809, 0x80); //
-		write_cmos_sensor(0x380a, 0x04); //  V output size: 0x438 =1080
-		write_cmos_sensor(0x380b, 0x38); //
-		write_cmos_sensor(0x380c, ((imgsensor_info.hs_video.linelength >> 8) & 0xFF)); // hts
-		write_cmos_sensor(0x380d, (imgsensor_info.hs_video.linelength & 0xFF)); 	   // hts
-		write_cmos_sensor(0x380e, ((imgsensor_info.hs_video.framelength >> 8) & 0xFF));  // vts 
-		write_cmos_sensor(0x380f, (imgsensor_info.hs_video.framelength & 0xFF));		 // vts 
-		write_cmos_sensor(0x3814, 0x01); //
-		write_cmos_sensor(0x3820, 0x80); //
-		write_cmos_sensor(0x3821, 0x46); //
-		write_cmos_sensor(0x382a, 0x01); //
-		write_cmos_sensor(0x3845, 0x00); //
-		write_cmos_sensor(0x4009, 0x0d); //
-		write_cmos_sensor(0x4502, 0x40); //
-		write_cmos_sensor(0x4508, 0xaa); //
-		write_cmos_sensor(0x4509, 0xaa); //
-		write_cmos_sensor(0x4600, 0x00); //
-		write_cmos_sensor(0x4601, 0xc0); //
-		write_cmos_sensor(0x4017, 0x08); // ; threshold= 2LSB for full size
-		write_cmos_sensor(0x400a, 0x01); //; blc dark limit to 354 code
-		write_cmos_sensor(0x400b, 0x62); //; blc dark limit to 354 code
-		write_cmos_sensor(0x0100, 0x01); //
-*/
+
 }
 
 
@@ -1088,6 +1063,7 @@ static void slim_video_setting()
 	//;;PCLK=HTS*VTS*fps=0x68c*0x7fd*30=1676*2045*30=102.85M					  
 																			  
 	write_cmos_sensor(0x0100, 0x00);  //	
+
 	write_cmos_sensor(0x0303, 0x00); 
 	
 	write_cmos_sensor(0x3501, 0x73);  //							  
@@ -1240,6 +1216,7 @@ static kal_uint32 open(void)
 	imgsensor.test_pattern = KAL_FALSE;
 	imgsensor.current_fps = imgsensor_info.pre.max_framerate;
 	spin_unlock(&imgsensor_drv_lock);
+	
 
 	return ERROR_NONE;
 }	/*	open  */
@@ -1304,6 +1281,9 @@ static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 	imgsensor.autoflicker_en = KAL_FALSE;
 	spin_unlock(&imgsensor_drv_lock);
 	preview_setting();
+	if(strncmp(VANZO_SUB_CAM_ROTATION, "180", 3)==0){
+		set_mirror_flip(imgsensor.mirror);
+	}
 	return ERROR_NONE;
 }	/*	preview   */
 
@@ -1347,8 +1327,10 @@ static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 	spin_unlock(&imgsensor_drv_lock);
 
 	capture_setting(imgsensor.current_fps); 
-	
-	
+		
+	if(strncmp(VANZO_SUB_CAM_ROTATION, "180", 3)==0){
+		set_mirror_flip(imgsensor.mirror);
+	}
 	return ERROR_NONE;
 }	/* capture() */
 static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
@@ -1366,8 +1348,9 @@ static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 	imgsensor.autoflicker_en = KAL_FALSE;
 	spin_unlock(&imgsensor_drv_lock);
 	normal_video_setting(imgsensor.current_fps);
-	
-	
+	if(strncmp(VANZO_SUB_CAM_ROTATION, "180", 3)==0){
+		set_mirror_flip(imgsensor.mirror);
+	}
 	return ERROR_NONE;
 }	/*	normal_video   */
 
@@ -1388,7 +1371,9 @@ static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 	imgsensor.autoflicker_en = KAL_FALSE;
 	spin_unlock(&imgsensor_drv_lock);
 	hs_video_setting();
-	
+	if(strncmp(VANZO_SUB_CAM_ROTATION, "180", 3)==0){
+		set_mirror_flip(imgsensor.mirror);
+	}
 	return ERROR_NONE;
 }	/*	hs_video   */
 
@@ -1408,7 +1393,9 @@ static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 	imgsensor.autoflicker_en = KAL_FALSE;
 	spin_unlock(&imgsensor_drv_lock);
 	slim_video_setting();
-	
+	if(strncmp(VANZO_SUB_CAM_ROTATION, "180", 3)==0){
+		set_mirror_flip(imgsensor.mirror);
+	}
 	return ERROR_NONE;
 }	/*	slim_video	 */
 
@@ -1618,7 +1605,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
 			imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
 			imgsensor.min_frame_length = imgsensor.frame_length;
 			spin_unlock(&imgsensor_drv_lock);
-			//set_dummy();			
+            //set_dummy();
 			break;			
 		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
 			if(framerate == 0)
@@ -1629,7 +1616,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
 			imgsensor.frame_length = imgsensor_info.normal_video.framelength + imgsensor.dummy_line;
 			imgsensor.min_frame_length = imgsensor.frame_length;
 			spin_unlock(&imgsensor_drv_lock);
-			//set_dummy();			
+            //set_dummy();
 			break;
 		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:		
         	  if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {
@@ -1649,7 +1636,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
 			imgsensor.min_frame_length = imgsensor.frame_length;
 			spin_unlock(&imgsensor_drv_lock);
             }
-			//set_dummy();			
+            //set_dummy();
 			break;	
 		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
 			frame_length = imgsensor_info.hs_video.pclk / framerate * 10 / imgsensor_info.hs_video.linelength;
@@ -1658,7 +1645,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
 			imgsensor.frame_length = imgsensor_info.hs_video.framelength + imgsensor.dummy_line;
 			imgsensor.min_frame_length = imgsensor.frame_length;
 			spin_unlock(&imgsensor_drv_lock);
-			//set_dummy();			
+            //set_dummy();
 			break;
 		case MSDK_SCENARIO_ID_SLIM_VIDEO:
 			frame_length = imgsensor_info.slim_video.pclk / framerate * 10 / imgsensor_info.slim_video.linelength;
@@ -1667,7 +1654,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
 			imgsensor.frame_length = imgsensor_info.slim_video.framelength + imgsensor.dummy_line;
 			imgsensor.min_frame_length = imgsensor.frame_length;
 			spin_unlock(&imgsensor_drv_lock);
-			//set_dummy();	
+            //set_dummy();
 			break;		
 		default:  //coding with  preview scenario by default
 			frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
@@ -1676,7 +1663,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
 			imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
 			imgsensor.min_frame_length = imgsensor.frame_length;
 			spin_unlock(&imgsensor_drv_lock);
-			//set_dummy();	
+            //set_dummy();
 			LOG_INF("error scenario_id = %d, we use preview scenario \n", scenario_id);
 			break;
 	}	
@@ -1737,7 +1724,7 @@ static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
 	UINT16 *feature_data_16=(UINT16 *) feature_para;
 	UINT32 *feature_return_para_32=(UINT32 *) feature_para;
 	UINT32 *feature_data_32=(UINT32 *) feature_para;
-    unsigned long long *feature_data=(unsigned long long *) feature_para;
+	unsigned long long *feature_data = (unsigned long long*)feature_para;
 	unsigned long long *feature_return_data = (unsigned long long*)feature_para;
 	
 	SENSOR_WINSIZE_INFO_STRUCT *wininfo;	
@@ -1758,7 +1745,7 @@ static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
             set_shutter(*feature_data);
 			break;
 		case SENSOR_FEATURE_SET_NIGHTMODE:
-            night_mode((BOOL) *feature_data);
+			night_mode((BOOL) *feature_data);
 			break;
 		case SENSOR_FEATURE_SET_GAIN:		
             set_gain((UINT16) *feature_data);
@@ -1815,9 +1802,8 @@ static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
 			break;
 		case SENSOR_FEATURE_GET_CROP_INFO:
             LOG_INF("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n", *feature_data);
-
             wininfo = (SENSOR_WINSIZE_INFO_STRUCT *)(uintptr_t)(*(feature_data+1));
-
+		
 			switch (*feature_data_32) {
 				case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
 					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[1],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/ov5693_mipi_raw/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6735m/ov5693_mipi_raw/Makefile
old mode 100755
new mode 100644
index 0a2f236..914e9c0
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/ov5693_mipi_raw/Makefile
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/ov5693_mipi_raw/Makefile
@@ -1,2 +1,5 @@
+
 include $(srctree)/drivers/misc/mediatek/Makefile.custom
-obj-y += ov5693mipiraw_Sensor.o
+
+obj-y += ov5693mipi_Sensor.o
+
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/ov5693_mipi_raw/ov5693mipi_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/ov5693_mipi_raw/ov5693mipi_Sensor.c
new file mode 100644
index 0000000..5bc70d8
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/ov5693_mipi_raw/ov5693mipi_Sensor.c
@@ -0,0 +1,1821 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *     OV5693mipi_Sensor.c
+ *
+ * Project:
+ * --------
+ *     ALPS
+ *
+ * Description:
+ * ------------
+ *     Source code of Sensor driver
+ *
+ *
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *============================================================================
+ ****************************************************************************/
+
+#include <linux/videodev2.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <asm/atomic.h>
+//#include <asm/system.h>
+#include <linux/xlog.h>
+
+#include "kd_camera_hw.h"
+#include "kd_imgsensor.h"
+#include "kd_imgsensor_define.h"
+#include "kd_imgsensor_errcode.h"
+
+#include "ov5693mipi_Sensor.h"
+
+/****************************Modify Following Strings for Debug****************************/
+#define PFX "OV5693_camera_sensor"
+#define LOG_1 LOG_INF("OV5693,MIPI 2LANE\n")
+#define LOG_2 LOG_INF("preview 1280*960@30fps,864Mbps/lane; video 1280*960@30fps,864Mbps/lane; capture 5M@30fps,864Mbps/lane\n")
+/****************************   Modify end    *******************************************/
+
+#define LOG_INF(format, args...)    xlog_printk(ANDROID_LOG_INFO   , PFX, "[%s] " format, __FUNCTION__, ##args)
+
+static DEFINE_SPINLOCK(imgsensor_drv_lock);
+
+
+static imgsensor_info_struct imgsensor_info = {
+    .sensor_id = OV5693_SENSOR_ID,        //record sensor id defined in Kd_imgsensor.h
+
+    .checksum_value = 0xf7375923,        //checksum value for Camera Auto Test
+
+    .pre = {
+        .pclk = 160000000,                //record different mode's pclk
+        .linelength = 2688,                //record different mode's linelength
+        .framelength = 1984,            //record different mode's framelength
+        .startx = 2,                    //record different mode's startx of grabwindow
+        .starty = 2,                    //record different mode's starty of grabwindow
+        .grabwindow_width = 2560,        //record different mode's width of grabwindow
+        .grabwindow_height = 1920,        //record different mode's height of grabwindow
+        /*     following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario    */
+        .mipi_data_lp2hs_settle_dc = 85,//unit , ns
+        /*     following for GetDefaultFramerateByScenario()    */
+        .max_framerate = 300,
+    },
+    .cap = {
+        .pclk = 160000000,
+        .linelength = 2688,
+        .framelength = 1984,
+        .startx = 2,
+        .starty = 2,
+        .grabwindow_width = 2560,
+        .grabwindow_height = 1920,
+        .mipi_data_lp2hs_settle_dc = 85,//unit , ns
+        .max_framerate = 300,
+    },
+    .cap1 = {                            //capture for PIP 24fps relative information, capture1 mode must use same framelength, linelength with Capture mode for shutter calculate
+        .pclk = 132000000,
+        .linelength = 2688,
+        .framelength = 1984,
+        .startx = 2,
+        .starty = 2,
+        .grabwindow_width = 2560,
+        .grabwindow_height = 1920,
+        .mipi_data_lp2hs_settle_dc = 85,//unit , ns
+        .max_framerate = 240,    //less than 13M(include 13M),cap1 max framerate is 24fps,16M max framerate is 20fps, 20M max framerate is 15fps
+    },
+    .normal_video = {
+        .pclk = 160000000,
+        .linelength = 2688,
+        .framelength = 1984,
+        .startx = 2,
+        .starty = 2,
+        .grabwindow_width = 2560,
+        .grabwindow_height = 1920,
+        .mipi_data_lp2hs_settle_dc = 85,//unit , ns
+        .max_framerate = 300,
+    },
+    .hs_video = {
+        .pclk = 160000000,
+        .linelength = 1752,
+        .framelength = 760,
+        .startx = 0,
+        .starty = 0,
+        .grabwindow_width = 1280,
+        .grabwindow_height = 720,
+        .mipi_data_lp2hs_settle_dc = 85,//unit , ns
+        .max_framerate = 1200,
+    },
+    .slim_video = {
+        .pclk = 160000000,
+        .linelength = 3504,
+        .framelength = 1520,
+        .startx = 0,
+        .starty = 0,
+        .grabwindow_width = 1280,
+        .grabwindow_height = 720,
+        .mipi_data_lp2hs_settle_dc = 85,//unit , ns
+        .max_framerate = 300,
+    },
+    .margin = 4,            //sensor framelength & shutter margin
+    .min_shutter = 1,        //min shutter
+    .max_frame_length = 0x7fff,//max framelength by sensor register's limitation
+    .ae_shut_delay_frame = 0,    //shutter delay frame for AE cycle, 2 frame with ispGain_delay-shut_delay=2-0=2
+    .ae_sensor_gain_delay_frame = 0,//sensor gain delay frame for AE cycle,2 frame with ispGain_delay-sensor_gain_delay=2-0=2
+    .ae_ispGain_delay_frame = 2,//isp gain delay frame for AE cycle
+    .ihdr_support = 0,      //1, support; 0,not support
+    .ihdr_le_firstline = 0,  //1,le first ; 0, se first
+    .sensor_mode_num = 5,      //support sensor mode num
+
+    .cap_delay_frame = 3,        //enter capture delay frame num
+    .pre_delay_frame = 3,         //enter preview delay frame num
+    .video_delay_frame = 3,        //enter video delay frame num
+    .hs_video_delay_frame = 3,    //enter high speed video  delay frame num
+    .slim_video_delay_frame = 3,//enter slim video delay frame num
+
+    .isp_driving_current = ISP_DRIVING_6MA, //mclk driving current
+    .sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,//sensor_interface_type
+    .mipi_sensor_type = MIPI_OPHY_NCSI2, //0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2
+    .mipi_settle_delay_mode = MIPI_SETTLEDELAY_AUTO,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
+    .sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_B,//sensor output first pixel color
+    .mclk = 24,//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
+    .mipi_lane_num = SENSOR_MIPI_2_LANE,//mipi lane num
+    .i2c_addr_table = {0x6c, 0xff},
+    .i2c_speed = 300,
+};
+
+
+static imgsensor_struct imgsensor = {
+    .mirror = IMAGE_NORMAL,                //mirrorflip information
+    .sensor_mode = IMGSENSOR_MODE_INIT, //IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
+    .shutter = 0x3D0,                    //current shutter
+    .gain = 0x100,                        //current gain
+    .dummy_pixel = 0,                    //current dummypixel
+    .dummy_line = 0,                    //current dummyline
+    .current_fps = 300,  //full size current fps : 24fps for PIP, 30fps for Normal or ZSD
+    .autoflicker_en = KAL_FALSE,  //auto flicker enable: KAL_FALSE for disable auto flicker, KAL_TRUE for enable auto flicker
+    .test_pattern = KAL_FALSE,        //test pattern mode or not. KAL_FALSE for in test pattern mode, KAL_TRUE for normal output
+    .current_scenario_id = MSDK_SCENARIO_ID_CAMERA_PREVIEW,//current scenario id
+    .ihdr_en = 0, //sensor need support LE, SE with HDR feature
+    .i2c_write_id = 0x6c,//record current sensor's i2c write id
+};
+
+
+/* Sensor output window information */
+static SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[5]=
+{{ 2624, 1956,     16,    6, 2592, 1944, 2592, 1944, 0000, 0000, 2592, 1944,      2,    2, 2560, 1920}, // Preview
+ { 2624, 1956,     16,    6, 2592, 1944, 2592, 1944, 0000, 0000, 2592, 1944,      2,    2, 2560, 1920}, // capture
+ { 2624, 1956,     16,    6, 2592, 1944, 2592, 1944, 0000, 0000, 2592, 1944,      3,    3, 2560, 1920}, // video
+ { 2624, 1956,      2,  250, 2608, 1460, 1280,  720, 0000, 0000, 1280,  720,      0,    0, 1280,  720}, //hight speed video
+ { 2624, 1956,      8,  246, 2608, 1460, 1280,  720, 0000, 0000, 1280,  720,      0,    0, 1280,  720}};// slim video
+
+
+static kal_uint16 read_cmos_sensor(kal_uint32 addr)
+{
+    kal_uint16 get_byte=0;
+	char pu_send_cmd[2] = {(char)(addr >> 8), (char)(addr & 0xFF) };
+
+	kdSetI2CSpeed(imgsensor_info.i2c_speed); // Add this func to set i2c speed by each sensor
+
+    iReadRegI2C(pu_send_cmd, 2, (u8*)&get_byte, 1, imgsensor.i2c_write_id);
+
+    return get_byte;
+}
+
+static void write_cmos_sensor(kal_uint32 addr, kal_uint32 para)
+{
+    char pu_send_cmd[3] = {(char)(addr >> 8), (char)(addr & 0xFF), (char)(para & 0xFF)};
+
+	kdSetI2CSpeed(imgsensor_info.i2c_speed); // Add this func to set i2c speed by each sensor
+
+    iWriteRegI2C(pu_send_cmd, 3, imgsensor.i2c_write_id);
+}
+
+static void set_dummy()
+{
+    LOG_INF("dummyline = %d, dummypixels = %d \n", imgsensor.dummy_line, imgsensor.dummy_pixel);
+    /* you can set dummy by imgsensor.dummy_line and imgsensor.dummy_pixel, or you can set dummy by imgsensor.frame_length and imgsensor.line_length */
+    write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
+    write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
+    write_cmos_sensor(0x380c, imgsensor.line_length >> 8);
+    write_cmos_sensor(0x380d, imgsensor.line_length & 0xFF);
+
+}    /*    set_dummy  */
+
+static kal_uint32 return_sensor_id()
+{
+    return ((read_cmos_sensor(0x300A) << 8) | read_cmos_sensor(0x300B));
+}
+static void set_max_framerate(UINT16 framerate,kal_bool min_framelength_en)
+{
+    //kal_int16 dummy_line;
+    kal_uint32 frame_length = imgsensor.frame_length;
+    //unsigned long flags;
+
+    LOG_INF("framerate = %d, min framelength should enable? \n", framerate,min_framelength_en);
+
+    frame_length = imgsensor.pclk / framerate * 10 / imgsensor.line_length;
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.frame_length = (frame_length > imgsensor.min_frame_length) ? frame_length : imgsensor.min_frame_length;
+    imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
+    //dummy_line = frame_length - imgsensor.min_frame_length;
+    //if (dummy_line < 0)
+        //imgsensor.dummy_line = 0;
+    //else
+        //imgsensor.dummy_line = dummy_line;
+    //imgsensor.frame_length = frame_length + imgsensor.dummy_line;
+    if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+    {
+        imgsensor.frame_length = imgsensor_info.max_frame_length;
+        imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
+    }
+    if (min_framelength_en)
+        imgsensor.min_frame_length = imgsensor.frame_length;
+    spin_unlock(&imgsensor_drv_lock);
+    set_dummy();
+}    /*    set_max_framerate  */
+
+
+
+/*************************************************************************
+* FUNCTION
+*    set_shutter
+*
+* DESCRIPTION
+*    This function set e-shutter of sensor to change exposure time.
+*
+* PARAMETERS
+*    iShutter : exposured lines
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static void set_shutter(kal_uint16 shutter)
+{
+    unsigned long flags;
+    kal_uint16 realtime_fps = 0;
+    kal_uint32 frame_length = 0;
+    spin_lock_irqsave(&imgsensor_drv_lock, flags);
+    imgsensor.shutter = shutter;
+    spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
+
+    //write_shutter(shutter);
+    /* 0x3500, 0x3501, 0x3502 will increase VBLANK to get exposure larger than frame exposure */
+    /* AE doesn't update sensor gain at capture mode, thus extra exposure lines must be updated here. */
+
+    // OV Recommend Solution
+    // if shutter bigger than frame_length, should extend frame length first
+    spin_lock(&imgsensor_drv_lock);
+    if (shutter > imgsensor.min_frame_length - imgsensor_info.margin)
+        imgsensor.frame_length = shutter + imgsensor_info.margin;
+    else
+        imgsensor.frame_length = imgsensor.min_frame_length;
+    if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+        imgsensor.frame_length = imgsensor_info.max_frame_length;
+    spin_unlock(&imgsensor_drv_lock);
+    shutter = (shutter < imgsensor_info.min_shutter) ? imgsensor_info.min_shutter : shutter;
+    shutter = (shutter > (imgsensor_info.max_frame_length - imgsensor_info.margin)) ? (imgsensor_info.max_frame_length - imgsensor_info.margin) : shutter;
+
+    // Framelength should be an even number
+    //shutter = (shutter >> 1) << 1;
+    //imgsensor.frame_length = (imgsensor.frame_length >> 1) << 1;
+    if (imgsensor.autoflicker_en) {
+        realtime_fps = imgsensor.pclk / imgsensor.line_length * 10 / imgsensor.frame_length;
+        if(realtime_fps >= 297 && realtime_fps <= 305)
+            set_max_framerate(296,0);
+        else if(realtime_fps >= 147 && realtime_fps <= 150)
+            set_max_framerate(146,0);
+        else {
+            // Extend frame length
+            write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
+            write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
+        }
+    } else {
+        // Extend frame length
+        write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
+        write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
+    }
+
+    // Update Shutter
+    write_cmos_sensor(0x3502, (shutter << 4) & 0xFF);
+    write_cmos_sensor(0x3501, (shutter >> 4) & 0xFF);
+    write_cmos_sensor(0x3500, (shutter >> 12) & 0x0F);
+    LOG_INF("Exit! shutter =%d, framelength =%d\n", shutter,imgsensor.frame_length);
+
+}    /*    set_shutter */
+
+
+
+static kal_uint16 gain2reg(const kal_uint16 gain)
+{
+    kal_uint16 reg_gain = 0x0000;
+
+    reg_gain = ((gain / BASEGAIN) << 4) + ((gain % BASEGAIN) * 16 / BASEGAIN);
+    reg_gain = reg_gain & 0xFFFF;
+    return (kal_uint16)reg_gain;
+}
+
+/*************************************************************************
+* FUNCTION
+*    set_gain
+*
+* DESCRIPTION
+*    This function is to set global gain to sensor.
+*
+* PARAMETERS
+*    iGain : sensor global gain(base: 0x40)
+*
+* RETURNS
+*    the actually gain set to sensor.
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint16 set_gain(kal_uint16 gain)
+{
+    kal_uint16 reg_gain;
+
+    /* 0x350A[0:1], 0x350B[0:7] AGC real gain */
+    /* [0:3] = N meams N /16 X    */
+    /* [4:9] = M meams M X         */
+    /* Total gain = M + N /16 X   */
+
+    //
+    if (gain < BASEGAIN || gain > 32 * BASEGAIN) {
+        LOG_INF("Error gain setting");
+
+        if (gain < BASEGAIN)
+            gain = BASEGAIN;
+        else if (gain > 32 * BASEGAIN)
+            gain = 32 * BASEGAIN;
+    }
+
+    reg_gain = gain2reg(gain);
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.gain = reg_gain;
+    spin_unlock(&imgsensor_drv_lock);
+    LOG_INF("gain = %d , reg_gain = 0x%x\n ", gain, reg_gain);
+
+    write_cmos_sensor(0x350a, reg_gain >> 8);
+    write_cmos_sensor(0x350b, reg_gain & 0xFF);
+
+    return gain;
+}    /*    set_gain  */
+
+static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gain)
+{
+    LOG_INF("le:0x%x, se:0x%x, gain:0x%x\n",le,se,gain);
+    if (imgsensor.ihdr_en) {
+
+        spin_lock(&imgsensor_drv_lock);
+        if (le > imgsensor.min_frame_length - imgsensor_info.margin)
+            imgsensor.frame_length = le + imgsensor_info.margin;
+        else
+            imgsensor.frame_length = imgsensor.min_frame_length;
+        if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+            imgsensor.frame_length = imgsensor_info.max_frame_length;
+        spin_unlock(&imgsensor_drv_lock);
+        if (le < imgsensor_info.min_shutter) le = imgsensor_info.min_shutter;
+        if (se < imgsensor_info.min_shutter) se = imgsensor_info.min_shutter;
+
+
+        // Extend frame length first
+        write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
+        write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
+
+        write_cmos_sensor(0x3502, (le << 4) & 0xFF);
+        write_cmos_sensor(0x3501, (le >> 4) & 0xFF);
+        write_cmos_sensor(0x3500, (le >> 12) & 0x0F);
+
+        write_cmos_sensor(0x3508, (se << 4) & 0xFF);
+        write_cmos_sensor(0x3507, (se >> 4) & 0xFF);
+        write_cmos_sensor(0x3506, (se >> 12) & 0x0F);
+
+        set_gain(gain);
+    }
+
+}
+
+
+
+static void set_mirror_flip(kal_uint8 image_mirror)
+{
+    LOG_INF("image_mirror = %d\n", image_mirror);
+
+    /********************************************************
+       *
+       *   0x3820[2] ISP Vertical flip
+       *   0x3820[1] Sensor Vertical flip
+       *
+       *   0x3821[2] ISP Horizontal mirror
+       *   0x3821[1] Sensor Horizontal mirror
+       *
+       *   ISP and Sensor flip or mirror register bit should be the same!!
+       *
+       ********************************************************/
+
+    switch (image_mirror) {
+        case IMAGE_NORMAL:
+            write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x00));
+            write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x06));
+            break;
+        case IMAGE_H_MIRROR:
+            write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x00));
+            write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x00));
+            break;
+        case IMAGE_V_MIRROR:
+            write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x06));
+            write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x06));
+            break;
+        case IMAGE_HV_MIRROR:
+            write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x06));
+            write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x00));
+            break;
+        default:
+            LOG_INF("Error image_mirror setting\n");
+    }
+
+}
+
+/*************************************************************************
+* FUNCTION
+*    night_mode
+*
+* DESCRIPTION
+*    This function night mode of sensor.
+*
+* PARAMETERS
+*    bEnable: KAL_TRUE -> enable night mode, otherwise, disable night mode
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static void night_mode(kal_bool enable)
+{
+/*No Need to implement this function*/
+}    /*    night_mode    */
+
+static void sensor_init(void)
+{
+    LOG_INF("E\n");
+
+   /*****************************************************************************
+    0x3098[0:1] pll3_prediv
+    pll3_prediv_map[] = {2, 3, 4, 6} 
+    
+    0x3099[0:4] pll3_multiplier
+    pll3_multiplier
+    
+    0x309C[0] pll3_rdiv
+    pll3_rdiv + 1
+    
+    0x309A[0:3] pll3_sys_div
+    pll3_sys_div + 1
+    
+    0x309B[0:1] pll3_div
+    pll3_div[] = {2, 2, 4, 5}
+    
+    VCO = XVCLK * 2 / pll3_prediv * pll3_multiplier * pll3_rdiv
+    sysclk = VCO * 2 * 2 / pll3_sys_div / pll3_div
+
+    XVCLK = 24 MHZ
+    0x3098, 0x03
+    0x3099, 0x1e
+    0x309a, 0x02
+    0x309b, 0x01
+    0x309c, 0x00
+
+
+    VCO = 24 * 2 / 6 * 31 * 1
+    sysclk = VCO * 2  * 2 / 3 / 2
+    sysclk = 160 MHZ
+    */
+
+    write_cmos_sensor(0x0103,0x01);  // Software Reset
+
+    write_cmos_sensor(0x3001,0x0a);  // FSIN output, FREX input
+    write_cmos_sensor(0x3002,0x80);  // Vsync output, Href, Frex, strobe, fsin, ilpwm input
+    write_cmos_sensor(0x3006,0x00);  // output value of GPIO
+    
+    write_cmos_sensor(0x3011,0x21);  //MIPI 2 lane enable
+    write_cmos_sensor(0x3012,0x09);  //MIPI 10-bit
+    write_cmos_sensor(0x3013,0x10);  //Drive 1x
+    write_cmos_sensor(0x3014,0x00);
+    write_cmos_sensor(0x3015,0x08);  //MIPI on
+    write_cmos_sensor(0x3016,0xf0);
+    write_cmos_sensor(0x3017,0xf0);
+    write_cmos_sensor(0x3018,0xf0);
+    write_cmos_sensor(0x301b,0xb4);
+    write_cmos_sensor(0x301d,0x02);
+    write_cmos_sensor(0x3021,0x00);  //internal regulator on
+    write_cmos_sensor(0x3022,0x01);
+    write_cmos_sensor(0x3028,0x44);
+    write_cmos_sensor(0x3098,0x03);  //PLL
+    write_cmos_sensor(0x3099,0x1e);  //PLL
+    write_cmos_sensor(0x309a,0x02);  //PLL
+    write_cmos_sensor(0x309b,0x01);  //PLL
+    write_cmos_sensor(0x309c,0x00);  //PLL
+    write_cmos_sensor(0x30a0,0xd2);
+    write_cmos_sensor(0x30a2,0x01);
+    write_cmos_sensor(0x30b2,0x00);
+    write_cmos_sensor(0x30b3,0x64);  //PLL 50 64 6c 6a->64 modify by yan 5/15
+    write_cmos_sensor(0x30b4,0x03);  //PLL
+    write_cmos_sensor(0x30b5,0x04);  //PLL
+    write_cmos_sensor(0x30b6,0x01);  //PLL
+    write_cmos_sensor(0x3104,0x21);  //sclk from dac_pll
+    write_cmos_sensor(0x3106,0x00);  //sclk_sel from pll_clk
+    write_cmos_sensor(0x3400,0x04);  //MWB R H
+    write_cmos_sensor(0x3401,0x00);  //MWB R L
+    write_cmos_sensor(0x3402,0x04);  //MWB G H
+    write_cmos_sensor(0x3403,0x00);  //MWB G L
+    write_cmos_sensor(0x3404,0x04);  //MWB B H
+    write_cmos_sensor(0x3405,0x00);  //MWB B L
+    write_cmos_sensor(0x3406,0x01);  //MWB gain enable
+    write_cmos_sensor(0x3500,0x00);  //exposure HH
+    write_cmos_sensor(0x3501,0x3d);  //exposure H   3d
+    write_cmos_sensor(0x3502,0x00);  //exposure L
+    write_cmos_sensor(0x3503,0x07);  //gain 1 frame latch, VTS manual, AGC manual, AEC manual
+    write_cmos_sensor(0x3504,0x00);  //manual gain H
+    write_cmos_sensor(0x3505,0x00);  //manual gain L
+    write_cmos_sensor(0x3506,0x00);  //short exposure HH
+    write_cmos_sensor(0x3507,0x02);  //short exposure H
+    write_cmos_sensor(0x3508,0x00);  //short exposure L
+    write_cmos_sensor(0x3509,0x10);  //use real ggain
+    write_cmos_sensor(0x350a,0x00);  //gain H 
+    write_cmos_sensor(0x350b,0x40);  //gain L
+    write_cmos_sensor(0x3600,0xbc);  //(20140110)
+    write_cmos_sensor(0x3601,0x0a);  //analog
+    write_cmos_sensor(0x3602,0x38);
+    write_cmos_sensor(0x3612,0x80);
+    write_cmos_sensor(0x3620,0x44);  //0x54 (20140110)
+    write_cmos_sensor(0x3621,0xb5);  //0xc7 (20140110)
+    write_cmos_sensor(0x3622,0x0c);  //0x0f (20140110)
+
+    write_cmos_sensor(0x3625,0x10);
+    write_cmos_sensor(0x3630,0x55);
+    write_cmos_sensor(0x3631,0xf4);
+    write_cmos_sensor(0x3632,0x00);
+    write_cmos_sensor(0x3633,0x34);
+    write_cmos_sensor(0x3634,0x02);
+    write_cmos_sensor(0x364d,0x0d);
+    write_cmos_sensor(0x364f,0xdd);
+    write_cmos_sensor(0x3660,0x04);
+    write_cmos_sensor(0x3662,0x10);
+    write_cmos_sensor(0x3663,0xf1);
+    write_cmos_sensor(0x3665,0x00);
+    write_cmos_sensor(0x3666,0x20);
+    write_cmos_sensor(0x3667,0x00);
+    write_cmos_sensor(0x366a,0x80);
+    write_cmos_sensor(0x3680,0xe0);
+    write_cmos_sensor(0x3681,0x00);  //analog
+    write_cmos_sensor(0x3700,0x42);  //sensor control
+    write_cmos_sensor(0x3701,0x14);
+    write_cmos_sensor(0x3702,0xa0);
+    write_cmos_sensor(0x3703,0xd8);
+    write_cmos_sensor(0x3704,0x78);
+    write_cmos_sensor(0x3705,0x02);
+    write_cmos_sensor(0x3708,0xe6);  //e6 //e2
+    write_cmos_sensor(0x3709,0xc7);  //c7 //c3
+    write_cmos_sensor(0x370a,0x00);
+    write_cmos_sensor(0x370b,0x20);
+    write_cmos_sensor(0x370c,0x0c);
+    write_cmos_sensor(0x370d,0x11);
+    write_cmos_sensor(0x370e,0x00);
+    write_cmos_sensor(0x370f,0x40);
+    write_cmos_sensor(0x3710,0x00);
+    write_cmos_sensor(0x371a,0x1c);
+    write_cmos_sensor(0x371b,0x05);
+    write_cmos_sensor(0x371c,0x01);
+    write_cmos_sensor(0x371e,0xa1);
+    write_cmos_sensor(0x371f,0x0c);
+    write_cmos_sensor(0x3721,0x00);
+    write_cmos_sensor(0x3724,0x10);
+    write_cmos_sensor(0x3726,0x00);
+    write_cmos_sensor(0x372a,0x01);
+    write_cmos_sensor(0x3730,0x10);
+    write_cmos_sensor(0x3738,0x22);
+    write_cmos_sensor(0x3739,0xe5);
+    write_cmos_sensor(0x373a,0x50);
+    write_cmos_sensor(0x373b,0x02);
+    write_cmos_sensor(0x373c,0x41);
+    write_cmos_sensor(0x373f,0x02);
+    write_cmos_sensor(0x3740,0x42);
+    write_cmos_sensor(0x3741,0x02);
+    write_cmos_sensor(0x3742,0x18);
+    write_cmos_sensor(0x3743,0x01);
+    write_cmos_sensor(0x3744,0x02);
+    write_cmos_sensor(0x3747,0x10);
+    write_cmos_sensor(0x374c,0x04);
+    write_cmos_sensor(0x3751,0xf0);
+    write_cmos_sensor(0x3752,0x00);
+    write_cmos_sensor(0x3753,0x00);
+    write_cmos_sensor(0x3754,0xc0);
+    write_cmos_sensor(0x3755,0x00);
+    write_cmos_sensor(0x3756,0x1a);
+    write_cmos_sensor(0x3758,0x00);
+    write_cmos_sensor(0x3759,0x0f);
+    write_cmos_sensor(0x376b,0x44);
+    write_cmos_sensor(0x375c,0x04);
+    write_cmos_sensor(0x3774,0x10);
+    write_cmos_sensor(0x3776,0x00);
+    write_cmos_sensor(0x377f,0x08);  //sensor control
+    write_cmos_sensor(0x3780,0x22);  //PSRAM control
+    write_cmos_sensor(0x3781,0x0c);
+    write_cmos_sensor(0x3784,0x2c);
+    write_cmos_sensor(0x3785,0x1e);
+    write_cmos_sensor(0x378f,0xf5);
+    write_cmos_sensor(0x3791,0xb0);
+    write_cmos_sensor(0x3795,0x00);
+    write_cmos_sensor(0x3796,0x64);
+    write_cmos_sensor(0x3797,0x11);
+    write_cmos_sensor(0x3798,0x30);
+    write_cmos_sensor(0x3799,0x41);
+    write_cmos_sensor(0x379a,0x07);
+    write_cmos_sensor(0x379b,0xb0);
+    write_cmos_sensor(0x379c,0x0c);  //PSRAM control                       
+    write_cmos_sensor(0x37c5,0x00);  //sensor FREX exp HH                  
+    write_cmos_sensor(0x37c6,0x00);  //sensor FREX exp H                   
+    write_cmos_sensor(0x37c7,0x00);  //sensor FREX exp L                   
+    write_cmos_sensor(0x37c9,0x00);  //strobe Width HH                     
+    write_cmos_sensor(0x37ca,0x00);  //strobe Width H                      
+    write_cmos_sensor(0x37cb,0x00);  //strobe Width L                      
+    write_cmos_sensor(0x37de,0x00);  //sensor FREX PCHG Width H            
+    write_cmos_sensor(0x37df,0x00);  //sensor FREX PCHG Width L
+    
+    write_cmos_sensor(0x3800,0x00);  //X start H                           
+    write_cmos_sensor(0x3801,0x00);  //X start L                           
+    write_cmos_sensor(0x3802,0x00);  //Y start H                           
+    write_cmos_sensor(0x3803,0x00);  //Y start L                           
+    write_cmos_sensor(0x3804,0x0a);  //X end H                             
+    write_cmos_sensor(0x3805,0x3f);  //X end L                             
+    write_cmos_sensor(0x3806,0x07);  //Y end H                             
+    write_cmos_sensor(0x3807,0xa3);  //Y end L                             
+    write_cmos_sensor(0x3808,0x05);  //X output size H  2592             //05  0a
+    write_cmos_sensor(0x3809,0x10);  //X output size L                       //10  20
+    write_cmos_sensor(0x380a,0x03);  //Y output size H  1944             //03  07
+    write_cmos_sensor(0x380b,0xcc);  //Y output size L                       //cc   98
+    write_cmos_sensor(0x380c,0x0a);  //HTS H  2688                             
+    write_cmos_sensor(0x380d,0x80);  //HTS H                               
+    write_cmos_sensor(0x380e,0x07);  //HTS L  1984                           //05
+    write_cmos_sensor(0x380f,0xc0);  //HTS L                                     //d0
+    
+    write_cmos_sensor(0x3810,0x00);  //timing ISP x win H                  
+    write_cmos_sensor(0x3811,0x08);  //timing ISP x win L     //02             
+    write_cmos_sensor(0x3812,0x00);  //timing ISP y win H                  
+    write_cmos_sensor(0x3813,0x02);  //timing ISP y win L                  
+    write_cmos_sensor(0x3814,0x31);  //timing x inc                                        //31  11
+    write_cmos_sensor(0x3815,0x31);  //timing y ing                                        //31  11
+
+    /********************************************************
+       *
+       *   0x3820[2] ISP Vertical flip
+       *   0x3820[1] Sensor Vertical flip
+       *
+       *   0x3821[2] ISP Horizontal mirror
+       *   0x3821[1] Sensor Horizontal mirror
+       *
+       *   ISP and Sensor flip or mirror register bit should be the same!!
+       *
+       ********************************************************/
+    write_cmos_sensor(0x3820,0x04);  //v fast bin on, v flip off, v bin off           //04  00
+    write_cmos_sensor(0x3821,0x1f);  //hsync on, mirror on, hbin on              //1f   1e
+    
+    write_cmos_sensor(0x3823,0x00);
+    write_cmos_sensor(0x3824,0x00);
+    write_cmos_sensor(0x3825,0x00);
+    write_cmos_sensor(0x3826,0x00);
+    write_cmos_sensor(0x3827,0x00);
+    write_cmos_sensor(0x382a,0x04);
+    write_cmos_sensor(0x3a04,0x06);
+    write_cmos_sensor(0x3a05,0x14);
+    write_cmos_sensor(0x3a06,0x00);
+    write_cmos_sensor(0x3a07,0xfe);
+    write_cmos_sensor(0x3b00,0x00);  //strobe off          
+    write_cmos_sensor(0x3b02,0x00);  //strobe dummy line H     
+    write_cmos_sensor(0x3b03,0x00);  //strobe dummy line L     
+    write_cmos_sensor(0x3b04,0x00);  //strobe at next frame    
+    write_cmos_sensor(0x3b05,0x00);  //strobe pulse width      
+    write_cmos_sensor(0x3e07,0x20);
+    write_cmos_sensor(0x4000,0x08);
+    write_cmos_sensor(0x4001,0x04);  //BLC start line                                                                         
+    write_cmos_sensor(0x4002,0x45);  //BLC auto enable, do 5 frames                                                           
+    write_cmos_sensor(0x4004,0x08);  //8 black lines                                                                          
+    write_cmos_sensor(0x4005,0x18);  //don't output black line, apply one channel offset to all, BLC triggered by gain change,
+    write_cmos_sensor(0x4006,0x20);  //ZLINE COEF                                                                             
+    write_cmos_sensor(0x4008,0x24);                                                                                       
+    write_cmos_sensor(0x4009,0x40);  //black level target                                                                     
+    write_cmos_sensor(0x400c,0x00);  //BLC man level0 H                                                                       
+    write_cmos_sensor(0x400d,0x00);  //BLC man level0 L                                                                       
+    write_cmos_sensor(0x4058,0x00);                                                                                         
+    write_cmos_sensor(0x404e,0x37);  //BLC maximum black level                                                                
+    write_cmos_sensor(0x404f,0x8f);  //BLC stable range                                                                       
+    write_cmos_sensor(0x4058,0x00);                                                                                     
+    write_cmos_sensor(0x4101,0xb2);                                                                                   
+    write_cmos_sensor(0x4303,0x00);  //test pattern off                                                                       
+    write_cmos_sensor(0x4304,0x08);  //test pattern option                                                                    
+    write_cmos_sensor(0x4307,0x30);                                                                                       
+    write_cmos_sensor(0x4311,0x04);  //Vsync width H                                                                          
+    write_cmos_sensor(0x4315,0x01);  //Vsync width L                                                                          
+    write_cmos_sensor(0x4511,0x05);                                                                                      
+    write_cmos_sensor(0x4512,0x01); 
+
+    write_cmos_sensor(0x4800,0x24);  // MIPI line sync enable non-continue mode, no ls,le
+    
+    write_cmos_sensor(0x4806,0x00);                                                                                      
+    write_cmos_sensor(0x4816,0x52);  //embedded line data type                                                                
+    write_cmos_sensor(0x481f,0x30);  //max clk_prepare                                                                        
+    write_cmos_sensor(0x4826,0x2c);  //hs prepare min                                                                         
+    write_cmos_sensor(0x4831,0x64);  //UI hs prepare     
+    write_cmos_sensor(0x4d00,0x04);  //temprature sensor 
+    write_cmos_sensor(0x4d01,0x71);                 
+    write_cmos_sensor(0x4d02,0xfd);                  
+    write_cmos_sensor(0x4d03,0xf5);                  
+    write_cmos_sensor(0x4d04,0x0c);                  
+    write_cmos_sensor(0x4d05,0xcc);  //temperature sensor
+    write_cmos_sensor(0x4837,0x0a);  //MIPI global timing  //0d 0a 09->0a modify by yan 5/15
+    write_cmos_sensor(0x5000,0x06);  //BPC on, WPC on    
+    write_cmos_sensor(0x5001,0x01);  //MWB on            
+    write_cmos_sensor(0x5002,0x00);  //scal off          
+    write_cmos_sensor(0x5003,0x20);
+    write_cmos_sensor(0x5046,0x0a);  //SOF auto mode 
+    write_cmos_sensor(0x5013,0x00);            
+    write_cmos_sensor(0x5046,0x0a);  //SOF auto mode 
+
+    //update DPC
+    write_cmos_sensor(0x5780,0xfc); //DPC
+    write_cmos_sensor(0x5781,0x13);
+    write_cmos_sensor(0x5782,0x03);
+    write_cmos_sensor(0x5786,0x20);
+    write_cmos_sensor(0x5787,0x40);
+    write_cmos_sensor(0x5788,0x08);
+    write_cmos_sensor(0x5789,0x08);
+    write_cmos_sensor(0x578a,0x02);
+    write_cmos_sensor(0x578b,0x01);
+    write_cmos_sensor(0x578c,0x01);
+    write_cmos_sensor(0x578d,0x0c);
+    write_cmos_sensor(0x578e,0x02);
+    write_cmos_sensor(0x578f,0x01);
+    write_cmos_sensor(0x5790,0x01);
+    write_cmos_sensor(0x5791,0xff);  //DPC             
+
+    write_cmos_sensor(0x5842,0x01);  //LENC BR Hscale H
+    write_cmos_sensor(0x5843,0x2b);  //LENC BR Hscale L
+    write_cmos_sensor(0x5844,0x01);  //LENC BR Vscale H
+    write_cmos_sensor(0x5845,0x92);  //LENC BR Vscale L
+    write_cmos_sensor(0x5846,0x01);  //LENC G Hscale H 
+    write_cmos_sensor(0x5847,0x8f);  //LENC G Hscale L 
+    write_cmos_sensor(0x5848,0x01);  //LENC G Vscale H 
+    write_cmos_sensor(0x5849,0x0c);  //LENC G Vscale L 
+    write_cmos_sensor(0x5e00,0x00);  //test pattern off
+    write_cmos_sensor(0x5e10,0x0c);
+    //write_cmos_sensor(0x0100,0x01);  //wake up
+}    /*    sensor_init  */
+
+
+static void preview_setting(void)
+{
+    //5.1.2 FQPreview 1296x972 30fps 24M MCLK 2lane 864Mbps/lane
+    write_cmos_sensor(0x0100,0x00);  //software sleep
+    //mDELAY(30);
+    write_cmos_sensor(0x3098,0x03);  //PLL
+    write_cmos_sensor(0x3099,0x1e);  //PLL
+    write_cmos_sensor(0x309a,0x02);  //PLL
+
+    write_cmos_sensor(0x3708,0xe6);  //sensor control
+    write_cmos_sensor(0x3709,0xc7);  //sensor control
+    write_cmos_sensor(0x3803,0x00);  //timing Y start L
+    write_cmos_sensor(0x3806,0x07);  //timing Y end H
+    write_cmos_sensor(0x3807,0xa3);  //timing Y end L
+    
+    write_cmos_sensor(0x3808,0x05);  //X output size H  1296
+    write_cmos_sensor(0x3809,0x10);  //X output size L
+    write_cmos_sensor(0x380a,0x03);  //Y output size H  972
+    write_cmos_sensor(0x380b,0xcc);  //Y output size L
+    
+    //write_cmos_sensor(0x380c,0x0a);  //HTS H  2688
+    //write_cmos_sensor(0x380d,0x80);  //HTS L
+    //write_cmos_sensor(0x380e,0x07);  //VTS H  1984
+    //write_cmos_sensor(0x380f,0xc0);  //VTS L
+    write_cmos_sensor(0x380c, ((imgsensor_info.pre.linelength >> 8) & 0xFF)); // hts = 2688
+    write_cmos_sensor(0x380d, (imgsensor_info.pre.linelength & 0xFF));       // hts
+    write_cmos_sensor(0x380e, ((imgsensor_info.pre.framelength >> 8) & 0xFF));    // vts = 1984
+    write_cmos_sensor(0x380f, (imgsensor_info.pre.framelength & 0xFF));         // vts
+    
+    write_cmos_sensor(0x3810,0x00);  //timing ISP x win H
+    write_cmos_sensor(0x3811,0x08);  //timing ISP x win L
+    write_cmos_sensor(0x3812,0x00);  //timing ISP y win H
+    write_cmos_sensor(0x3813,0x02);  //timing ISP y win L
+    write_cmos_sensor(0x3814,0x31);  //timing X inc
+    write_cmos_sensor(0x3815,0x31);  //timing Y inc
+
+    /********************************************************
+       *
+       *   0x3820[2] ISP Vertical flip
+       *   0x3820[1] Sensor Vertical flip
+       *
+       *   0x3821[2] ISP Horizontal mirror
+       *   0x3821[1] Sensor Horizontal mirror
+       *
+       *   ISP and Sensor flip or mirror register bit should be the same!!
+       *
+       ********************************************************/    
+    write_cmos_sensor(0x3820,0x04);  //v fast bin on, v flip off, v bin off
+    write_cmos_sensor(0x3821,0x1f);  //hsync on, mirror on, hbin on
+    if (imgsensor.ihdr_en) {
+
+    } else {
+    
+    }
+    write_cmos_sensor(0x3a04,0x06);
+    write_cmos_sensor(0x3a05,0x14);
+    write_cmos_sensor(0x4837,0x0a);//;0a
+    write_cmos_sensor(0x5002,0x00);  //scale off
+
+    write_cmos_sensor(0x0100,0x01);  //wake up   
+}    /*    preview_setting  */
+
+static void capture_setting(kal_uint16 currefps)
+{
+    LOG_INF("E! currefps:%d\n",currefps);
+    if (currefps == 240) { //24fps for PIP
+        //@@full_132PCLK_24.75
+        write_cmos_sensor(0x0100,0x00);
+        write_cmos_sensor(0x30b3,0x58);//;64
+        write_cmos_sensor(0x3098, 0x02);
+        write_cmos_sensor(0x3099, 0x16);
+        write_cmos_sensor(0x309a, 0x03);
+        write_cmos_sensor(0x3708, 0xe2);
+        write_cmos_sensor(0x3709, 0xc3);
+        write_cmos_sensor(0x3803, 0x00);
+        write_cmos_sensor(0x3806, 0x07);
+        write_cmos_sensor(0x3807, 0xa3);
+        write_cmos_sensor(0x3808, 0x0a);
+        write_cmos_sensor(0x3809, 0x20);
+        write_cmos_sensor(0x380a, 0x07);
+        write_cmos_sensor(0x380b, 0x98);
+        write_cmos_sensor(0x380c, ((imgsensor_info.cap1.linelength >> 8) & 0xFF)); // hts = 2688
+        write_cmos_sensor(0x380d, (imgsensor_info.cap1.linelength & 0xFF));        // hts
+        write_cmos_sensor(0x380e, ((imgsensor_info.cap1.framelength >> 8) & 0xFF));  // vts = 1984
+        write_cmos_sensor(0x380f, (imgsensor_info.cap1.framelength & 0xFF));         // vts
+        write_cmos_sensor(0x3810, 0x00);
+        write_cmos_sensor(0x3811, 0x10);
+        write_cmos_sensor(0x3812, 0x00);
+        write_cmos_sensor(0x3813, 0x06);
+        write_cmos_sensor(0x3814, 0x11);
+        write_cmos_sensor(0x3815, 0x11);
+        write_cmos_sensor(0x3820, 0x00);
+        write_cmos_sensor(0x3821, 0x1e);
+        write_cmos_sensor(0x3a04, 0x06);
+        write_cmos_sensor(0x3a05, 0x14);
+        write_cmos_sensor(0x4837,0x0b);//;0a
+        write_cmos_sensor(0x5002, 0x00);
+        write_cmos_sensor(0x0100, 0x01);
+    } else {   //30fps            //30fps for Normal capture & ZSD
+    //5.1.3 Capture 2592x1944 30fps 24M MCLK 2lane 864Mbps/lane
+    write_cmos_sensor(0x0100,0x00);  //software sleep
+        //mDELAY(30);
+        write_cmos_sensor(0x30b3,0x6a);
+        write_cmos_sensor(0x3098,0x03);  //PLL
+        write_cmos_sensor(0x3099,0x1e);  //PLL
+        write_cmos_sensor(0x309a,0x02);  //PLL
+    write_cmos_sensor(0x3708,0xe2);  //sensor control
+    write_cmos_sensor(0x3709,0xc3);  //sensor control
+    write_cmos_sensor(0x3803,0x00);  //timing Y start L
+    write_cmos_sensor(0x3806,0x07);  //timing Y end H
+    write_cmos_sensor(0x3807,0xa3);  //timing Y end L
+    
+    write_cmos_sensor(0x3808,0x0a);  //X output size H  2592
+    write_cmos_sensor(0x3809,0x20);  //X output size L
+    write_cmos_sensor(0x380a,0x07);  //Y output size H  1944
+    write_cmos_sensor(0x380b,0x98);  //Y output size L
+    
+    //write_cmos_sensor(0x380c,0x0a);  //HTS H 2688
+    //write_cmos_sensor(0x380d,0x80);  //HTS L
+    //write_cmos_sensor(0x380e,0x07);  //VTS H 1984
+    //write_cmos_sensor(0x380f,0xc0);  //VTS L
+
+    write_cmos_sensor(0x380c, ((imgsensor_info.cap.linelength >> 8) & 0xFF)); // hts = 2688
+    write_cmos_sensor(0x380d, (imgsensor_info.cap.linelength & 0xFF));       // hts
+    write_cmos_sensor(0x380e, ((imgsensor_info.cap.framelength >> 8) & 0xFF));    // vts = 1984
+    write_cmos_sensor(0x380f, (imgsensor_info.cap.framelength & 0xFF));         // vts
+    
+
+    write_cmos_sensor(0x3810,0x00);  //timing ISP x win H
+    write_cmos_sensor(0x3811,0x10);  //timing ISP x win L
+    write_cmos_sensor(0x3812,0x00);  //timing ISP y win H
+    write_cmos_sensor(0x3813,0x06);  //timing ISP y win L
+    write_cmos_sensor(0x3814,0x11);  //timing X inc
+    write_cmos_sensor(0x3815,0x11);  //timing Y inc
+
+    /********************************************************
+       *
+       *   0x3820[2] ISP Vertical flip
+       *   0x3820[1] Sensor Vertical flip
+       *
+       *   0x3821[2] ISP Horizontal mirror
+       *   0x3821[1] Sensor Horizontal mirror
+       *
+       *   ISP and Sensor flip or mirror register bit should be the same!!
+       *
+       ********************************************************/
+    write_cmos_sensor(0x3820,0x00);  //v fast vbin on, flip off, v bin on
+        if (imgsensor.ihdr_en) {
+
+    } else {
+    
+    }
+        write_cmos_sensor(0x3821,0x1e);  //hsync on, h mirror on, h bin on
+    write_cmos_sensor(0x3a04,0x06);
+    write_cmos_sensor(0x3a05,0x14);
+        write_cmos_sensor(0x4837,0x09);
+    write_cmos_sensor(0x5002,0x00);  //scale off
+    
+    write_cmos_sensor(0x0100,0x01);  //wake up
+
+    }
+
+}
+
+static void normal_video_setting(kal_uint16 currefps)
+{
+    LOG_INF("E! currefps:%d\n",currefps);
+    
+    //5.1.3 Video 2592x1944 30fps 24M MCLK 2lane 864Mbps/lane
+    write_cmos_sensor(0x0100,0x00);  //software sleep
+    //mDELAY(30);
+    write_cmos_sensor(0x30b3,0x6a);
+    write_cmos_sensor(0x3098,0x03);  //PLL
+    write_cmos_sensor(0x3099,0x1e);  //PLL
+    write_cmos_sensor(0x309a,0x02);  //PLL
+    write_cmos_sensor(0x3708,0xe2);  //sensor control
+    write_cmos_sensor(0x3709,0xc3);  //sensor control
+    write_cmos_sensor(0x3803,0x00);  //timing Y start L
+    write_cmos_sensor(0x3806,0x07);  //timing Y end H
+    write_cmos_sensor(0x3807,0xa3);  //timing Y end L
+
+    write_cmos_sensor(0x3808,0x0a);  //X output size H  2592
+    write_cmos_sensor(0x3809,0x20);  //X output size L
+    write_cmos_sensor(0x380a,0x07);  //Y output size H  1944
+    write_cmos_sensor(0x380b,0x98);  //Y output size L
+
+    //write_cmos_sensor(0x380c,0x0a);  //HTS H 2688
+    //write_cmos_sensor(0x380d,0x80);  //HTS L
+    //write_cmos_sensor(0x380e,0x07);  //VTS H 1984
+    //write_cmos_sensor(0x380f,0xc0);  //VTS L
+
+    write_cmos_sensor(0x380c, ((imgsensor_info.normal_video.linelength >> 8) & 0xFF)); // hts = 2688
+    write_cmos_sensor(0x380d, (imgsensor_info.normal_video.linelength & 0xFF));        // hts
+    write_cmos_sensor(0x380e, ((imgsensor_info.normal_video.framelength >> 8) & 0xFF));  // vts = 1984
+    write_cmos_sensor(0x380f, (imgsensor_info.normal_video.framelength & 0xFF));         // vts
+
+
+    write_cmos_sensor(0x3810,0x00);  //timing ISP x win H
+    write_cmos_sensor(0x3811,0x10);  //timing ISP x win L
+    write_cmos_sensor(0x3812,0x00);  //timing ISP y win H
+    write_cmos_sensor(0x3813,0x06);  //timing ISP y win L
+    write_cmos_sensor(0x3814,0x11);  //timing X inc
+    write_cmos_sensor(0x3815,0x11);  //timing Y inc
+
+    /********************************************************
+       *
+       *   0x3820[2] ISP Vertical flip
+       *   0x3820[1] Sensor Vertical flip
+       *
+       *   0x3821[2] ISP Horizontal mirror
+       *   0x3821[1] Sensor Horizontal mirror
+       *
+       *   ISP and Sensor flip or mirror register bit should be the same!!
+       *
+       ********************************************************/
+    write_cmos_sensor(0x3820,0x00);  //v fast vbin on, flip off, v bin on
+    write_cmos_sensor(0x4837,0x09);
+    if (imgsensor.ihdr_en) {
+    } else {
+    }
+    write_cmos_sensor(0x5002,0x00);  //scale off
+
+    write_cmos_sensor(0x0100,0x01);  //wake up
+
+}
+static void hs_video_setting()
+{
+    LOG_INF("E\n");
+
+    //@@720p_160PCLK_120fps_800Mbps
+    write_cmos_sensor(0x0100,0x00);
+    write_cmos_sensor(0x30b3,0x64);
+    write_cmos_sensor(0x3098,0x03);
+    write_cmos_sensor(0x3099,0x1e);
+    write_cmos_sensor(0x309a,0x02);
+    write_cmos_sensor(0x3708,0xe6);
+    write_cmos_sensor(0x3709,0xc7);
+    write_cmos_sensor(0x3803,0xf4);
+    write_cmos_sensor(0x3806,0x06);
+    write_cmos_sensor(0x3807,0xab);
+    write_cmos_sensor(0x3808,0x05);
+    write_cmos_sensor(0x3809,0x00);
+    write_cmos_sensor(0x380a,0x02);
+    write_cmos_sensor(0x380b,0xd0);
+    write_cmos_sensor(0x380c, ((imgsensor_info.hs_video.linelength >> 8) & 0xFF)); // hts = 2688
+    write_cmos_sensor(0x380d, (imgsensor_info.hs_video.linelength & 0xFF));        // hts
+    write_cmos_sensor(0x380e, ((imgsensor_info.hs_video.framelength >> 8) & 0xFF));  // vts = 1984
+    write_cmos_sensor(0x380f, (imgsensor_info.hs_video.framelength & 0xFF));         // vts
+    write_cmos_sensor(0x3810,0x00);
+    write_cmos_sensor(0x3811,0x10);
+    write_cmos_sensor(0x3812,0x00);
+    write_cmos_sensor(0x3813,0x02);
+    write_cmos_sensor(0x3814,0x31);
+    write_cmos_sensor(0x3815,0x31);
+    write_cmos_sensor(0x3820,0x04);
+    write_cmos_sensor(0x3821,0x1f);
+    write_cmos_sensor(0x3a04,0x06);
+    write_cmos_sensor(0x3a05,0x14);
+    write_cmos_sensor(0x4837,0x0a);
+    if (imgsensor.ihdr_en) {
+    } else {
+    }
+    write_cmos_sensor(0x5002,0x00);
+    write_cmos_sensor(0x0100,0x01);
+}
+
+static void slim_video_setting()
+{
+    LOG_INF("E\n");
+    //@@video_720p_30fps_800Mbps
+    write_cmos_sensor(0x0100,0x00);
+    write_cmos_sensor(0x30b3,0x64);
+    write_cmos_sensor(0x3098,0x03);
+    write_cmos_sensor(0x3099,0x1e);
+    write_cmos_sensor(0x309a,0x02);
+    write_cmos_sensor(0x3708,0xe6);
+    write_cmos_sensor(0x3709,0xc3);
+    write_cmos_sensor(0x3803,0xf4);
+    write_cmos_sensor(0x3806,0x06);
+    write_cmos_sensor(0x3807,0xab);
+    write_cmos_sensor(0x3808,0x05);
+    write_cmos_sensor(0x3809,0x00);
+    write_cmos_sensor(0x380a,0x02);
+    write_cmos_sensor(0x380b,0xd0);
+    write_cmos_sensor(0x380c, ((imgsensor_info.slim_video.linelength >> 8) & 0xFF)); // hts = 2688
+    write_cmos_sensor(0x380d, (imgsensor_info.slim_video.linelength & 0xFF));        // hts
+    write_cmos_sensor(0x380e, ((imgsensor_info.slim_video.framelength >> 8) & 0xFF));  // vts = 1984
+    write_cmos_sensor(0x380f, (imgsensor_info.slim_video.framelength & 0xFF));         // vts
+    write_cmos_sensor(0x3810,0x00);
+    write_cmos_sensor(0x3811,0x08);
+    write_cmos_sensor(0x3812,0x00);
+    write_cmos_sensor(0x3813,0x02);
+    write_cmos_sensor(0x3814,0x31);
+    write_cmos_sensor(0x3815,0x31);
+    write_cmos_sensor(0x3820,0x01);
+    write_cmos_sensor(0x3821,0x1f);
+    write_cmos_sensor(0x3a04,0x06);
+    write_cmos_sensor(0x3a05,0x14);
+    write_cmos_sensor(0x4837,0x0a);
+    if (imgsensor.ihdr_en) {
+    } else {
+    }
+    write_cmos_sensor(0x5002,0x00);
+    write_cmos_sensor(0x0100,0x01);
+}
+
+static kal_uint32 set_test_pattern_mode(kal_bool enable)
+{
+    LOG_INF("enable: %d\n", enable);
+
+    if (enable) {
+        // 0x5E00[8]: 1 enable,  0 disable
+        // 0x5E00[1:0]; 00 Color bar, 01 Random Data, 10 Square, 11 BLACK
+        write_cmos_sensor(0x5E00, 0x80);
+    } else {
+        // 0x5E00[8]: 1 enable,  0 disable
+        // 0x5E00[1:0]; 00 Color bar, 01 Random Data, 10 Square, 11 BLACK
+        write_cmos_sensor(0x5E00, 0x00);
+    }
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.test_pattern = enable;
+    spin_unlock(&imgsensor_drv_lock);
+    return ERROR_NONE;
+}
+
+/*************************************************************************
+* FUNCTION
+*    get_imgsensor_id
+*
+* DESCRIPTION
+*    This function get the sensor ID
+*
+* PARAMETERS
+*    *sensorID : return the sensor ID
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 get_imgsensor_id(UINT32 *sensor_id)
+{
+    kal_uint8 i = 0;
+    kal_uint8 retry = 2;
+    //sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
+    while (imgsensor_info.i2c_addr_table[i] != 0xff) {
+        spin_lock(&imgsensor_drv_lock);
+        imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
+        spin_unlock(&imgsensor_drv_lock);
+        do {
+            *sensor_id = return_sensor_id();
+            if (*sensor_id == imgsensor_info.sensor_id) {
+                LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
+                return ERROR_NONE;
+            }
+            LOG_INF("Read sensor id fail, write id: 0x%x, id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
+            retry--;
+        } while(retry > 0);
+        i++;
+        retry = 2;
+    }
+    if (*sensor_id != imgsensor_info.sensor_id) {
+        // if Sensor ID is not correct, Must set *sensor_id to 0xFFFFFFFF
+        *sensor_id = 0xFFFFFFFF;
+        return ERROR_SENSOR_CONNECT_FAIL;
+    }
+    return ERROR_NONE;
+}
+
+
+/*************************************************************************
+* FUNCTION
+*    open
+*
+* DESCRIPTION
+*    This function initialize the registers of CMOS sensor
+*
+* PARAMETERS
+*    None
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 open(void)
+{
+    kal_uint8 i = 0;
+    kal_uint8 retry = 2;
+    kal_uint32 sensor_id = 0;
+    LOG_1;
+    LOG_2;
+    //sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
+    while (imgsensor_info.i2c_addr_table[i] != 0xff) {
+        spin_lock(&imgsensor_drv_lock);
+        imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
+        spin_unlock(&imgsensor_drv_lock);
+        do {
+            sensor_id = return_sensor_id();
+            if (sensor_id == imgsensor_info.sensor_id) {
+                LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
+                break;
+            }
+            LOG_INF("Read sensor id fail, write id: 0x%x, id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
+            retry--;
+        } while(retry > 0);
+        i++;
+        if (sensor_id == imgsensor_info.sensor_id)
+            break;
+        retry = 2;
+    }
+    if (imgsensor_info.sensor_id != sensor_id)
+        return ERROR_SENSOR_CONNECT_FAIL;
+
+    /* initail sequence write in  */
+    sensor_init();
+
+    spin_lock(&imgsensor_drv_lock);
+
+    imgsensor.autoflicker_en= KAL_FALSE;
+    imgsensor.sensor_mode = IMGSENSOR_MODE_INIT;
+    imgsensor.pclk = imgsensor_info.pre.pclk;
+    imgsensor.frame_length = imgsensor_info.pre.framelength;
+    imgsensor.line_length = imgsensor_info.pre.linelength;
+    imgsensor.min_frame_length = imgsensor_info.pre.framelength;
+    imgsensor.dummy_pixel = 0;
+    imgsensor.dummy_line = 0;
+    imgsensor.ihdr_en = 0;
+    imgsensor.test_pattern = KAL_FALSE;
+    imgsensor.current_fps = imgsensor_info.pre.max_framerate;
+    spin_unlock(&imgsensor_drv_lock);
+
+    return ERROR_NONE;
+}    /*    open  */
+
+
+
+/*************************************************************************
+* FUNCTION
+*    close
+*
+* DESCRIPTION
+*
+*
+* PARAMETERS
+*    None
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 close(void)
+{
+    LOG_INF("E\n");
+
+    /*No Need to implement this function*/
+
+    return ERROR_NONE;
+}    /*    close  */
+
+
+/*************************************************************************
+* FUNCTION
+* preview
+*
+* DESCRIPTION
+*    This function start the sensor preview.
+*
+* PARAMETERS
+*    *image_window : address pointer of pixel numbers in one period of HSYNC
+*  *sensor_config_data : address pointer of line numbers in one period of VSYNC
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_PREVIEW;
+    imgsensor.pclk = imgsensor_info.pre.pclk;
+    //imgsensor.video_mode = KAL_FALSE;
+    imgsensor.line_length = imgsensor_info.pre.linelength;
+    imgsensor.frame_length = imgsensor_info.pre.framelength;
+    imgsensor.min_frame_length = imgsensor_info.pre.framelength;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    //preview_setting();
+    capture_setting(imgsensor.current_fps);
+    //set_mirror_flip(sensor_config_data->SensorImageMirror);
+    return ERROR_NONE;
+}    /*    preview   */
+
+/*************************************************************************
+* FUNCTION
+*    capture
+*
+* DESCRIPTION
+*    This function setup the CMOS sensor in capture MY_OUTPUT mode
+*
+* PARAMETERS
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                          MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_CAPTURE;
+    if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {//PIP capture: 24fps for less than 13M, 20fps for 16M,15fps for 20M
+        imgsensor.pclk = imgsensor_info.cap1.pclk;
+        imgsensor.line_length = imgsensor_info.cap1.linelength;
+        imgsensor.frame_length = imgsensor_info.cap1.framelength;
+        imgsensor.min_frame_length = imgsensor_info.cap1.framelength;
+        imgsensor.autoflicker_en = KAL_FALSE;
+    } else {
+        if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
+            LOG_INF("Warning: current_fps %d fps is not support, so use cap's setting: %d fps!\n",imgsensor.current_fps,imgsensor_info.cap.max_framerate/10);
+        imgsensor.pclk = imgsensor_info.cap.pclk;
+        imgsensor.line_length = imgsensor_info.cap.linelength;
+        imgsensor.frame_length = imgsensor_info.cap.framelength;
+        imgsensor.min_frame_length = imgsensor_info.cap.framelength;
+        imgsensor.autoflicker_en = KAL_FALSE;
+    }
+    spin_unlock(&imgsensor_drv_lock);
+    capture_setting(imgsensor.current_fps);
+    //set_mirror_flip(sensor_config_data->SensorImageMirror);
+    return ERROR_NONE;
+}    /* capture() */
+static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_VIDEO;
+    imgsensor.pclk = imgsensor_info.normal_video.pclk;
+    imgsensor.line_length = imgsensor_info.normal_video.linelength;
+    imgsensor.frame_length = imgsensor_info.normal_video.framelength;
+    imgsensor.min_frame_length = imgsensor_info.normal_video.framelength;
+    //imgsensor.current_fps = 300;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    normal_video_setting(imgsensor.current_fps);
+    //set_mirror_flip(sensor_config_data->SensorImageMirror);
+    return ERROR_NONE;
+}    /*    normal_video   */
+
+static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_HIGH_SPEED_VIDEO;
+    imgsensor.pclk = imgsensor_info.hs_video.pclk;
+    //imgsensor.video_mode = KAL_TRUE;
+    imgsensor.line_length = imgsensor_info.hs_video.linelength;
+    imgsensor.frame_length = imgsensor_info.hs_video.framelength;
+    imgsensor.min_frame_length = imgsensor_info.hs_video.framelength;
+    imgsensor.dummy_line = 0;
+    imgsensor.dummy_pixel = 0;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    hs_video_setting();
+    //set_mirror_flip(sensor_config_data->SensorImageMirror);
+    return ERROR_NONE;
+}    /*    hs_video   */
+
+static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_SLIM_VIDEO;
+    imgsensor.pclk = imgsensor_info.slim_video.pclk;
+    imgsensor.line_length = imgsensor_info.slim_video.linelength;
+    imgsensor.frame_length = imgsensor_info.slim_video.framelength;
+    imgsensor.min_frame_length = imgsensor_info.slim_video.framelength;
+    imgsensor.dummy_line = 0;
+    imgsensor.dummy_pixel = 0;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    slim_video_setting();
+    //set_mirror_flip(sensor_config_data->SensorImageMirror);
+
+    return ERROR_NONE;
+}    /*    slim_video     */
+
+
+
+static kal_uint32 get_resolution(MSDK_SENSOR_RESOLUTION_INFO_STRUCT *sensor_resolution)
+{
+    LOG_INF("E\n");
+    sensor_resolution->SensorFullWidth = imgsensor_info.cap.grabwindow_width;
+    sensor_resolution->SensorFullHeight = imgsensor_info.cap.grabwindow_height;
+
+    sensor_resolution->SensorPreviewWidth = imgsensor_info.cap.grabwindow_width;//imgsensor_info.pre.grabwindow_width;
+    sensor_resolution->SensorPreviewHeight = imgsensor_info.cap.grabwindow_height;//imgsensor_info.pre.grabwindow_height;
+
+    sensor_resolution->SensorVideoWidth = imgsensor_info.normal_video.grabwindow_width;
+    sensor_resolution->SensorVideoHeight = imgsensor_info.normal_video.grabwindow_height;
+
+
+    sensor_resolution->SensorHighSpeedVideoWidth     = imgsensor_info.hs_video.grabwindow_width;
+    sensor_resolution->SensorHighSpeedVideoHeight     = imgsensor_info.hs_video.grabwindow_height;
+
+    sensor_resolution->SensorSlimVideoWidth     = imgsensor_info.slim_video.grabwindow_width;
+    sensor_resolution->SensorSlimVideoHeight     = imgsensor_info.slim_video.grabwindow_height;
+    return ERROR_NONE;
+}    /*    get_resolution    */
+
+static kal_uint32 get_info(MSDK_SCENARIO_ID_ENUM scenario_id,
+                      MSDK_SENSOR_INFO_STRUCT *sensor_info,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("scenario_id = %d\n", scenario_id);
+
+
+    //sensor_info->SensorVideoFrameRate = imgsensor_info.normal_video.max_framerate/10; /* not use */
+    //sensor_info->SensorStillCaptureFrameRate= imgsensor_info.cap.max_framerate/10; /* not use */
+    //imgsensor_info->SensorWebCamCaptureFrameRate= imgsensor_info.v.max_framerate; /* not use */
+
+    sensor_info->SensorClockPolarity = SENSOR_CLOCK_POLARITY_LOW;
+    sensor_info->SensorClockFallingPolarity = SENSOR_CLOCK_POLARITY_LOW; /* not use */
+    sensor_info->SensorHsyncPolarity = SENSOR_CLOCK_POLARITY_LOW; // inverse with datasheet
+    sensor_info->SensorVsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
+    sensor_info->SensorInterruptDelayLines = 4; /* not use */
+    sensor_info->SensorResetActiveHigh = FALSE; /* not use */
+    sensor_info->SensorResetDelayCount = 5; /* not use */
+
+    sensor_info->SensroInterfaceType = imgsensor_info.sensor_interface_type;
+    sensor_info->MIPIsensorType = imgsensor_info.mipi_sensor_type;
+    sensor_info->SettleDelayMode = imgsensor_info.mipi_settle_delay_mode;
+    sensor_info->SensorOutputDataFormat = imgsensor_info.sensor_output_dataformat;
+
+    sensor_info->CaptureDelayFrame = imgsensor_info.cap_delay_frame;
+    sensor_info->PreviewDelayFrame = imgsensor_info.pre_delay_frame;
+    sensor_info->VideoDelayFrame = imgsensor_info.video_delay_frame;
+    sensor_info->HighSpeedVideoDelayFrame = imgsensor_info.hs_video_delay_frame;
+    sensor_info->SlimVideoDelayFrame = imgsensor_info.slim_video_delay_frame;
+
+    sensor_info->SensorMasterClockSwitch = 0; /* not use */
+    sensor_info->SensorDrivingCurrent = imgsensor_info.isp_driving_current;
+
+    sensor_info->AEShutDelayFrame = imgsensor_info.ae_shut_delay_frame;          /* The frame of setting shutter default 0 for TG int */
+    sensor_info->AESensorGainDelayFrame = imgsensor_info.ae_sensor_gain_delay_frame;    /* The frame of setting sensor gain */
+    sensor_info->AEISPGainDelayFrame = imgsensor_info.ae_ispGain_delay_frame;
+    sensor_info->IHDR_Support = imgsensor_info.ihdr_support;
+    sensor_info->IHDR_LE_FirstLine = imgsensor_info.ihdr_le_firstline;
+    sensor_info->SensorModeNum = imgsensor_info.sensor_mode_num;
+
+    sensor_info->SensorMIPILaneNumber = imgsensor_info.mipi_lane_num;
+    sensor_info->SensorClockFreq = imgsensor_info.mclk;
+    sensor_info->SensorClockDividCount = 3; /* not use */
+    sensor_info->SensorClockRisingCount = 0;
+    sensor_info->SensorClockFallingCount = 2; /* not use */
+    sensor_info->SensorPixelClockCount = 3; /* not use */
+    sensor_info->SensorDataLatchCount = 2; /* not use */
+
+    sensor_info->MIPIDataLowPwr2HighSpeedTermDelayCount = 0;
+    sensor_info->MIPICLKLowPwr2HighSpeedTermDelayCount = 0;
+    sensor_info->SensorWidthSampling = 0;  // 0 is default 1x
+    sensor_info->SensorHightSampling = 0;    // 0 is default 1x
+    sensor_info->SensorPacketECCOrder = 1;
+
+    switch (scenario_id) {
+        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+            sensor_info->SensorGrabStartX = imgsensor_info.pre.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
+
+            break;
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+            sensor_info->SensorGrabStartX = imgsensor_info.cap.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.cap.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.cap.mipi_data_lp2hs_settle_dc;
+
+            break;
+        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+
+            sensor_info->SensorGrabStartX = imgsensor_info.normal_video.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.normal_video.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.normal_video.mipi_data_lp2hs_settle_dc;
+
+            break;
+        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+            sensor_info->SensorGrabStartX = imgsensor_info.hs_video.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.hs_video.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.hs_video.mipi_data_lp2hs_settle_dc;
+
+            break;
+        case MSDK_SCENARIO_ID_SLIM_VIDEO:
+            sensor_info->SensorGrabStartX = imgsensor_info.slim_video.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.slim_video.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.slim_video.mipi_data_lp2hs_settle_dc;
+
+            break;
+        default:
+            sensor_info->SensorGrabStartX = imgsensor_info.pre.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
+            break;
+    }
+
+    return ERROR_NONE;
+}    /*    get_info  */
+
+
+static kal_uint32 control(MSDK_SCENARIO_ID_ENUM scenario_id, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("scenario_id = %d\n", scenario_id);
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.current_scenario_id = scenario_id;
+    spin_unlock(&imgsensor_drv_lock);
+    switch (scenario_id) {
+        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+            preview(image_window, sensor_config_data);
+            break;
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+            capture(image_window, sensor_config_data);
+            break;
+        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+            normal_video(image_window, sensor_config_data);
+            break;
+        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+            hs_video(image_window, sensor_config_data);
+            break;
+        case MSDK_SCENARIO_ID_SLIM_VIDEO:
+            slim_video(image_window, sensor_config_data);
+            break;
+        default:
+            LOG_INF("Error ScenarioId setting");
+            preview(image_window, sensor_config_data);
+            return ERROR_INVALID_SCENARIO_ID;
+    }
+    return ERROR_NONE;
+}    /* control() */
+
+
+
+static kal_uint32 set_video_mode(UINT16 framerate)
+{//This Function not used after ROME
+    LOG_INF("framerate = %d\n ", framerate);
+    // SetVideoMode Function should fix framerate
+    if (framerate == 0)
+        // Dynamic frame rate
+        return ERROR_NONE;
+    spin_lock(&imgsensor_drv_lock);
+    if ((framerate == 300) && (imgsensor.autoflicker_en == KAL_TRUE))
+        imgsensor.current_fps = 296;
+    else if ((framerate == 150) && (imgsensor.autoflicker_en == KAL_TRUE))
+        imgsensor.current_fps = 146;
+    else
+        imgsensor.current_fps = framerate;
+    spin_unlock(&imgsensor_drv_lock);
+    set_max_framerate(imgsensor.current_fps,1);
+
+    return ERROR_NONE;
+}
+
+static kal_uint32 set_auto_flicker_mode(kal_bool enable, UINT16 framerate)
+{
+    LOG_INF("enable = %d, framerate = %d \n", enable, framerate);
+    spin_lock(&imgsensor_drv_lock);
+    if (enable) //enable auto flicker
+        imgsensor.autoflicker_en = KAL_TRUE;
+    else //Cancel Auto flick
+        imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    return ERROR_NONE;
+}
+
+
+static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 framerate)
+{
+    kal_uint32 frame_length;
+
+    LOG_INF("scenario_id = %d, framerate = %d\n", scenario_id, framerate);
+
+    switch (scenario_id) {
+        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+            frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            //set_dummy();
+            break;
+        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+            if(framerate == 0)
+                return ERROR_NONE;
+            frame_length = imgsensor_info.normal_video.pclk / framerate * 10 / imgsensor_info.normal_video.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.normal_video.framelength) ? (frame_length - imgsensor_info.normal_video.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.normal_video.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            //set_dummy();
+            break;
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+        	  if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {
+                frame_length = imgsensor_info.cap1.pclk / framerate * 10 / imgsensor_info.cap1.linelength;
+                spin_lock(&imgsensor_drv_lock);
+		            imgsensor.dummy_line = (frame_length > imgsensor_info.cap1.framelength) ? (frame_length - imgsensor_info.cap1.framelength) : 0;
+		            imgsensor.frame_length = imgsensor_info.cap1.framelength + imgsensor.dummy_line;
+		            imgsensor.min_frame_length = imgsensor.frame_length;
+		            spin_unlock(&imgsensor_drv_lock);
+            } else {
+        		    if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
+                    LOG_INF("Warning: current_fps %d fps is not support, so use cap's setting: %d fps!\n",framerate,imgsensor_info.cap.max_framerate/10);
+            frame_length = imgsensor_info.cap.pclk / framerate * 10 / imgsensor_info.cap.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.cap.framelength) ? (frame_length - imgsensor_info.cap.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.cap.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            }
+            //set_dummy();
+            break;
+        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+            frame_length = imgsensor_info.hs_video.pclk / framerate * 10 / imgsensor_info.hs_video.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.hs_video.framelength) ? (frame_length - imgsensor_info.hs_video.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.hs_video.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            //set_dummy();
+            break;
+        case MSDK_SCENARIO_ID_SLIM_VIDEO:
+            frame_length = imgsensor_info.slim_video.pclk / framerate * 10 / imgsensor_info.slim_video.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.slim_video.framelength) ? (frame_length - imgsensor_info.slim_video.framelength): 0;
+            imgsensor.frame_length = imgsensor_info.slim_video.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            //set_dummy();
+            break;
+        default:  //coding with  preview scenario by default
+            frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            //set_dummy();
+            LOG_INF("error scenario_id = %d, we use preview scenario \n", scenario_id);
+            break;
+    }
+    return ERROR_NONE;
+}
+
+
+static kal_uint32 get_default_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 *framerate)
+{
+    LOG_INF("scenario_id = %d\n", scenario_id);
+
+    switch (scenario_id) {
+        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+            *framerate = imgsensor_info.pre.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+            *framerate = imgsensor_info.normal_video.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+            *framerate = imgsensor_info.cap.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+            *framerate = imgsensor_info.hs_video.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_SLIM_VIDEO:
+            *framerate = imgsensor_info.slim_video.max_framerate;
+            break;
+        default:
+            break;
+    }
+
+    return ERROR_NONE;
+}
+
+
+
+static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
+                             UINT8 *feature_para,UINT32 *feature_para_len)
+{
+    UINT16 *feature_return_para_16=(UINT16 *) feature_para;
+    UINT16 *feature_data_16=(UINT16 *) feature_para;
+    UINT32 *feature_return_para_32=(UINT32 *) feature_para;
+    UINT32 *feature_data_32=(UINT32 *) feature_para;
+    unsigned long long *feature_data=(unsigned long long *) feature_para;
+	unsigned long long *feature_return_data = (unsigned long long*)feature_para;
+    SENSOR_WINSIZE_INFO_STRUCT *wininfo;
+    MSDK_SENSOR_REG_INFO_STRUCT *sensor_reg_data=(MSDK_SENSOR_REG_INFO_STRUCT *) feature_para;
+
+    LOG_INF("feature_id = %d\n", feature_id);
+    switch (feature_id) {
+        case SENSOR_FEATURE_GET_PERIOD:
+            *feature_return_para_16++ = imgsensor.line_length;
+            *feature_return_para_16 = imgsensor.frame_length;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:
+            *feature_return_para_32 = imgsensor.pclk;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_SET_ESHUTTER:
+            set_shutter(*feature_data);
+            break;
+        case SENSOR_FEATURE_SET_NIGHTMODE:
+            night_mode((BOOL) *feature_data);
+            break;
+        case SENSOR_FEATURE_SET_GAIN:
+            set_gain((UINT16) *feature_data);
+            break;
+        case SENSOR_FEATURE_SET_FLASHLIGHT:
+            break;
+        case SENSOR_FEATURE_SET_ISP_MASTER_CLOCK_FREQ:
+            break;
+        case SENSOR_FEATURE_SET_REGISTER:
+            write_cmos_sensor(sensor_reg_data->RegAddr, sensor_reg_data->RegData);
+            break;
+        case SENSOR_FEATURE_GET_REGISTER:
+            sensor_reg_data->RegData = read_cmos_sensor(sensor_reg_data->RegAddr);
+            break;
+        case SENSOR_FEATURE_GET_LENS_DRIVER_ID:
+            // get the lens driver ID from EEPROM or just return LENS_DRIVER_ID_DO_NOT_CARE
+            // if EEPROM does not exist in camera module.
+            *feature_return_para_32=LENS_DRIVER_ID_DO_NOT_CARE;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_SET_VIDEO_MODE:
+            set_video_mode(*feature_data_16);
+            break;
+        case SENSOR_FEATURE_CHECK_SENSOR_ID:
+            get_imgsensor_id(feature_return_para_32);
+            break;
+        case SENSOR_FEATURE_SET_AUTO_FLICKER_MODE:
+            set_auto_flicker_mode((BOOL)*feature_data_16,*(feature_data_16+1));
+            break;
+        case SENSOR_FEATURE_SET_MAX_FRAME_RATE_BY_SCENARIO:
+            set_max_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data, *(feature_data+1));
+            break;
+        case SENSOR_FEATURE_GET_DEFAULT_FRAME_RATE_BY_SCENARIO:
+            get_default_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data, (MUINT32 *)(uintptr_t)(*(feature_data+1)));
+            break;
+        case SENSOR_FEATURE_SET_TEST_PATTERN:
+            set_test_pattern_mode((BOOL)*feature_data);
+            break;
+        case SENSOR_FEATURE_GET_TEST_PATTERN_CHECKSUM_VALUE: //for factory mode auto testing
+            *feature_return_para_32 = imgsensor_info.checksum_value;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_SET_FRAMERATE:
+            LOG_INF("current fps :%d\n", *feature_data);
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.current_fps = *feature_data;
+            spin_unlock(&imgsensor_drv_lock);
+            break;
+        case SENSOR_FEATURE_SET_HDR:
+            LOG_INF("ihdr enable :%d\n", *feature_data);
+            spin_lock(&imgsensor_drv_lock);
+			imgsensor.ihdr_en = *feature_data;
+            spin_unlock(&imgsensor_drv_lock);
+            break;
+        case SENSOR_FEATURE_GET_CROP_INFO:
+            LOG_INF("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n", *feature_data);
+            wininfo = (SENSOR_WINSIZE_INFO_STRUCT *)(uintptr_t)(*(feature_data+1));
+
+            switch (*feature_data_32) {
+                case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[1],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[2],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[3],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_SLIM_VIDEO:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[4],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+                default:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[0],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+            }
+            break;
+        case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
+            LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",*feature_data,*(feature_data+1),*(feature_data+2));
+            ihdr_write_shutter_gain(*feature_data,*(feature_data+1),*(feature_data+2));
+            break;
+        default:
+            break;
+    }
+
+    return ERROR_NONE;
+}    /*    feature_control()  */
+
+static SENSOR_FUNCTION_STRUCT sensor_func = {
+    open,
+    get_info,
+    get_resolution,
+    feature_control,
+    control,
+    close
+};
+
+UINT32 OV5693_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
+{
+    /* To Do : Check Sensor status here */
+    if (pfFunc!=NULL)
+        *pfFunc=&sensor_func;
+    return ERROR_NONE;
+}    /*    OV5693_MIPI_RAW_SensorInit    */
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/ov5693_mipi_raw/ov5693mipi_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/ov5693_mipi_raw/ov5693mipi_Sensor.h
new file mode 100644
index 0000000..41dad2d
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/ov5693_mipi_raw/ov5693mipi_Sensor.h
@@ -0,0 +1,119 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *     OV5693mipi_Sensor.h
+ *
+ * Project:
+ * --------
+ *     ALPS
+ *
+ * Description:
+ * ------------
+ *     CMOS sensor header file
+ *
+ ****************************************************************************/
+#ifndef _OV5693MIPI_SENSOR_H
+#define _OV5693MIPI_SENSOR_H
+
+
+typedef enum{
+    IMGSENSOR_MODE_INIT,
+    IMGSENSOR_MODE_PREVIEW,
+    IMGSENSOR_MODE_CAPTURE,
+    IMGSENSOR_MODE_VIDEO,
+    IMGSENSOR_MODE_HIGH_SPEED_VIDEO,
+    IMGSENSOR_MODE_SLIM_VIDEO,
+} IMGSENSOR_MODE;
+
+typedef struct imgsensor_mode_struct {
+    kal_uint32 pclk;                //record different mode's pclk
+    kal_uint32 linelength;            //record different mode's linelength
+    kal_uint32 framelength;            //record different mode's framelength
+
+    kal_uint8 startx;                //record different mode's startx of grabwindow
+    kal_uint8 starty;                //record different mode's startx of grabwindow
+
+    kal_uint16 grabwindow_width;    //record different mode's width of grabwindow
+    kal_uint16 grabwindow_height;    //record different mode's height of grabwindow
+
+    /*     following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario    */
+    kal_uint8 mipi_data_lp2hs_settle_dc;
+
+    /*     following for GetDefaultFramerateByScenario()    */
+    kal_uint16 max_framerate;
+
+} imgsensor_mode_struct;
+
+/* SENSOR PRIVATE STRUCT FOR VARIABLES*/
+typedef struct imgsensor_struct {
+    kal_uint8 mirror;                //mirrorflip information
+
+    kal_uint8 sensor_mode;            //record IMGSENSOR_MODE enum value
+
+    kal_uint32 shutter;                //current shutter
+    kal_uint16 gain;                //current gain
+
+    kal_uint32 pclk;                //current pclk
+
+    kal_uint32 frame_length;        //current framelength
+    kal_uint32 line_length;            //current linelength
+
+    kal_uint32 min_frame_length;    //current min  framelength to max framerate
+    kal_uint16 dummy_pixel;            //current dummypixel
+    kal_uint16 dummy_line;            //current dummline
+
+    kal_uint16 current_fps;            //current max fps
+    kal_bool   autoflicker_en;        //record autoflicker enable or disable
+    kal_bool test_pattern;            //record test pattern mode or not
+    MSDK_SCENARIO_ID_ENUM current_scenario_id;//current scenario id
+    kal_uint8  ihdr_en;                //ihdr enable or disable
+
+    kal_uint8 i2c_write_id;            //record current sensor's i2c write id
+} imgsensor_struct;
+
+/* SENSOR PRIVATE STRUCT FOR CONSTANT*/
+typedef struct imgsensor_info_struct {
+    kal_uint32 sensor_id;            //record sensor id defined in Kd_imgsensor.h
+    kal_uint32 checksum_value;        //checksum value for Camera Auto Test
+    imgsensor_mode_struct pre;        //preview scenario relative information
+    imgsensor_mode_struct cap;        //capture scenario relative information
+    imgsensor_mode_struct cap1;        //capture for PIP 24fps relative information, capture1 mode must use same framelength, linelength with Capture mode for shutter calculate
+    imgsensor_mode_struct normal_video;//normal video  scenario relative information
+    imgsensor_mode_struct hs_video;    //high speed video scenario relative information
+    imgsensor_mode_struct slim_video;    //slim video for VT scenario relative information
+
+    kal_uint8  ae_shut_delay_frame;    //shutter delay frame for AE cycle
+    kal_uint8  ae_sensor_gain_delay_frame;    //sensor gain delay frame for AE cycle
+    kal_uint8  ae_ispGain_delay_frame;    //isp gain delay frame for AE cycle
+    kal_uint8  ihdr_support;        //1, support; 0,not support
+    kal_uint8  ihdr_le_firstline;    //1,le first ; 0, se first
+    kal_uint8  sensor_mode_num;        //support sensor mode num
+
+    kal_uint8  cap_delay_frame;        //enter capture delay frame num
+    kal_uint8  pre_delay_frame;        //enter preview delay frame num
+    kal_uint8  video_delay_frame;    //enter video delay frame num
+    kal_uint8  hs_video_delay_frame;    //enter high speed video  delay frame num
+    kal_uint8  slim_video_delay_frame;    //enter slim video delay frame num
+
+    kal_uint8  margin;                //sensor framelength & shutter margin
+    kal_uint32 min_shutter;            //min shutter
+    kal_uint32 max_frame_length;    //max framelength by sensor register's limitation
+
+    kal_uint8  isp_driving_current;    //mclk driving current
+    kal_uint8  sensor_interface_type;//sensor_interface_type
+    kal_uint8  mipi_sensor_type; //0,MIPI_OPHY_NCSI2; 1,MIPI_OPHY_CSI2, default is NCSI2, don't modify this para
+    kal_uint8  mipi_settle_delay_mode; //0, high speed signal auto detect; 1, use settle delay,unit is ns, default is auto detect, don't modify this para
+    kal_uint8  sensor_output_dataformat;//sensor output first pixel color
+    kal_uint8  mclk;                //mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
+
+    kal_uint8  mipi_lane_num;        //mipi lane num
+    kal_uint8  i2c_addr_table[5];    //record sensor support all write id addr, only supprt 4must end with 0xff
+    kal_uint32  i2c_speed;     //i2c speed
+} imgsensor_info_struct;
+
+extern int iReadRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u8 * a_pRecvData, u16 a_sizeRecvData, u16 i2cId);
+extern int iWriteRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u16 i2cId);
+extern void kdSetI2CSpeed(u16 i2cSpeed);
+
+#endif
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/ov8858_mipi_raw/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6735m/ov8858_mipi_raw/Makefile
old mode 100755
new mode 100644
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/ov8858_mipi_raw/ov8858mipiraw_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/ov8858_mipi_raw/ov8858mipiraw_Sensor.c
old mode 100755
new mode 100644
index ca828e8..1bbc5bf
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/ov8858_mipi_raw/ov8858mipiraw_Sensor.c
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/ov8858_mipi_raw/ov8858mipiraw_Sensor.c
@@ -149,15 +149,23 @@ static imgsensor_info_struct imgsensor_info = {
 	
 	.isp_driving_current = ISP_DRIVING_8MA, //mclk driving current
 	.sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,//sensor_interface_type
+#ifdef VANZO_IMGSENSOR_OV8858_ROTATION
 	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_Gb,//sensor output first pixel color
+#else
+	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_B,//sensor output first pixel color
+#endif
 	.mclk = 24,//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
 	.mipi_lane_num = SENSOR_MIPI_4_LANE,//mipi lane num
-	.i2c_addr_table = {0x42, 0x20,0x6C,0xff},//record sensor support all write id addr, only supprt 4must end with 0xff
+	.i2c_addr_table = {0x42, 0xff},//record sensor support all write id addr, only supprt 4must end with 0xff
 };
 
 
 static imgsensor_struct imgsensor = {
-	.mirror = IMAGE_HV_MIRROR,//IMAGE_NORMAL,				//mirrorflip information
+#ifdef VANZO_IMGSENSOR_OV8858_ROTATION
+	.mirror = IMAGE_HV_MIRROR,
+#else
+	.mirror = IMAGE_NORMAL,				//mirrorflip information
+#endif
 	.sensor_mode = IMGSENSOR_MODE_INIT, //IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
 	.shutter = 0x4C00,					//current shutter
 	.gain = 0x200,						//current gain
@@ -174,11 +182,11 @@ static imgsensor_struct imgsensor = {
 
 /* Sensor output window information*/
 static SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[5] =	 
-{{ 3296, 2480,	  12,	12, 3272, 2456, 3264, 2452,   4,	2, 1632, 1224,	 0, 0, 1632, 1224}, // Preview 
- { 3296, 2480,	  12,	12, 3272, 2456, 3264, 2452,   4,	2, 3264, 2448,	 0, 0, 3264, 2448}, // capture 
- { 3296, 2480,	  12,	12, 3272, 2456, 3264, 2452,   4,	2, 3264, 2448,	 0, 0, 3264, 2448}, // video 
- { 3296, 2480,	  12,	12, 3272, 2456,  640,  480,   4,	2,  640,  480,	 0, 0,  640,  480}, //hight speed video 
- { 3296, 2480,	  12,	12, 3272, 2456, 3264, 2452,   4,	2, 1632, 1224,	 0, 0, 1632, 1224}};// slim video 
+{{ 3296, 2480,	  12,	12, 3272, 2456, 1636, 1228,   0,	0, 1632, 1224,	 0, 0, 1632, 1224}, // Preview 
+ { 3296, 2480,	  12,	12, 3272, 2456, 3264, 2452,   0,	0, 3264, 2448,	 0, 0, 3264, 2448}, // capture 
+ { 3296, 2480,	  12,	12, 3272, 2456, 3264, 2452,   0,	0, 3264, 2448,	 0, 0, 3264, 2448}, // video 
+ { 3296, 2480,	  12,	12, 3272, 2456,  640,  480,   0,	0,  640,  480,	 0, 0,  640,  480}, //hight speed video 
+ { 3296, 2480,	  12,	12, 3272, 2456, 3264, 2452,   0,	0, 1632, 1224,	 0, 0, 1632, 1224}};// slim video 
 
 static kal_uint16 read_cmos_sensor(kal_uint32 addr)
 {
@@ -1522,7 +1530,7 @@ otp_ptr = &otp_struct_obj;
 int read_otp(struct otp_struct *otp_ptr)
 {
 	int otp_flag, addr, temp, i;
-	//set 0x5002[3] to \A1\B00\A1\B1
+	//set 0x5002[3] to 0
 	int temp1;
 	temp1 = read_cmos_sensor(0x5002);
 	write_cmos_sensor(0x5002, (0x00 & 0x08) | (temp1 & (~0x08)));
@@ -1614,7 +1622,7 @@ int read_otp(struct otp_struct *otp_ptr)
 	for(i=0x7010;i<=0x720a;i++) {
 		write_cmos_sensor(i,0); // clear OTP buffer, recommended use continuous write to accelarate
 	}
-	//set 0x5002[3] to \A1\B01\A1\B1
+	//set 0x5002[3] to 1
 	temp1 = read_cmos_sensor(0x5002);
 	write_cmos_sensor(0x5002, (0x08 & 0x08) | (temp1 & (~0x08)));
 	return (*otp_ptr).flag;
@@ -1816,8 +1824,8 @@ static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 	imgsensor.autoflicker_en = KAL_FALSE;
 	spin_unlock(&imgsensor_drv_lock);
 	preview_setting();
-	set_mirror_flip(imgsensor.mirror);
 	mdelay(10);
+	set_mirror_flip(imgsensor.mirror);
 	return ERROR_NONE;
 }	/*	preview   */
 
@@ -1860,8 +1868,8 @@ static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 	spin_unlock(&imgsensor_drv_lock);
 
 	capture_setting(imgsensor.current_fps); 
-	set_mirror_flip(imgsensor.mirror);
 	mdelay(10);
+	set_mirror_flip(imgsensor.mirror);
 
 	#if 0
 	if(imgsensor.test_pattern == KAL_TRUE)
@@ -1890,8 +1898,8 @@ static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 	imgsensor.autoflicker_en = KAL_FALSE;
 	spin_unlock(&imgsensor_drv_lock);
 	capture_setting(imgsensor.current_fps);
-	set_mirror_flip(imgsensor.mirror);
 	mdelay(10);
+	set_mirror_flip(imgsensor.mirror);
 	
 	
 	return ERROR_NONE;
@@ -1915,8 +1923,8 @@ static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 	imgsensor.autoflicker_en = KAL_FALSE;
 	spin_unlock(&imgsensor_drv_lock);
 	hs_video_setting();
-	set_mirror_flip(imgsensor.mirror);
 	mdelay(10);
+	set_mirror_flip(imgsensor.mirror);
 	
 	return ERROR_NONE;
 }	/*	hs_video   */
@@ -1939,8 +1947,8 @@ static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 	imgsensor.autoflicker_en = KAL_FALSE;
 	spin_unlock(&imgsensor_drv_lock);
 	slim_video_setting();
-	set_mirror_flip(imgsensor.mirror);
 	mdelay(10);
+	set_mirror_flip(imgsensor.mirror);
 	
 	return ERROR_NONE;
 }	/*	slim_video	 */
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/ov8858_mipi_raw/ov8858mipiraw_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/ov8858_mipi_raw/ov8858mipiraw_Sensor.h
old mode 100755
new mode 100644
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/ov8865_mipi_raw/ov8865mipiraw_CameraCustomized.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/ov8865_mipi_raw/ov8865mipiraw_CameraCustomized.h
old mode 100755
new mode 100644
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/ov8865_mipi_raw/ov8865mipiraw_Camera_Sensor_para.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/ov8865_mipi_raw/ov8865mipiraw_Camera_Sensor_para.h
old mode 100755
new mode 100644
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/ov8865_mipi_raw/ov8865mipiraw_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/ov8865_mipi_raw/ov8865mipiraw_Sensor.c
old mode 100644
new mode 100755
index 26c2bf1..5efdb85
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/ov8865_mipi_raw/ov8865mipiraw_Sensor.c
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/ov8865_mipi_raw/ov8865mipiraw_Sensor.c
@@ -11,11 +11,11 @@
  * Description:
  * ------------
  *	 Source code of Sensor driver
- 
- *nick <<PengtaoFan>>.modify at: 2015-02-02   19:12:15
- *    nick :R8865 driver full size  R3767 need modifyto R3767=0x1e 
+ 
+ *nick <<PengtaoFan>>.modify at: 2015-02-02   19:12:15
+ *    nick :R8865 driver full size  R3767 need modifyto R3767=0x1e 
  *
- *	PengtaoFan
+ *	PengtaoFan
  * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
  *============================================================================
  ****************************************************************************/
@@ -38,7 +38,7 @@
 
 #include "ov8865mipiraw_Sensor.h"
 
-#define PFX "OV8865"
+#define PFX "OV8865"
 //#define LOG_WRN(format, args...) xlog_printk(ANDROID_LOG_WARN ,PFX, "[%S] " format, __FUNCTION__, ##args)
 //#defineLOG_INF(format, args...) xlog_printk(ANDROID_LOG_INFO ,PFX, "[%s] " format, __FUNCTION__, ##args)
 //#define LOG_DBG(format, args...) xlog_printk(ANDROID_LOG_DEBUG ,PFX, "[%S] " format, __FUNCTION__, ##args)
@@ -49,12 +49,12 @@ static DEFINE_SPINLOCK(imgsensor_drv_lock);
 static imgsensor_info_struct imgsensor_info = { 
 	.sensor_id = OV8865_SENSOR_ID,
 	
-	.checksum_value = 0xfdd9c02a,
+	.checksum_value = 0xfdd9c02a,
 	
 	.pre = {
 		.pclk = 74400000,									//record different mode's pclk
 		.linelength = 1923,  /*[actually 1923*2]	*/			//record different mode's linelength
-		.framelength = 1280, //1248 =>1280 ,increase vblank time	//record different mode's framelength
+		.framelength = 1280, //1248 =>1280 ,increase vblank time	//record different mode's framelength
 		.startx = 0,										//record different mode's startx of grabwindow
 		.starty = 0,										//record different mode's starty of grabwindow
 		.grabwindow_width = 1632,							//record different mode's width of grabwindow
@@ -64,21 +64,21 @@ static imgsensor_info_struct imgsensor_info = {
 		/*	 following for GetDefaultFramerateByScenario()	*/
 		.max_framerate = 300,	
 	},
-	.cap = {//30fps 74.4M bps/lane
-		.pclk = 148800000,//this value just for calculate shutter
-		.linelength = 1944,  /*[actually 2008*2]	*/	
-	    .framelength = 2550,
+	.cap = {//30fps 74.4M bps/lane
+		.pclk = 148800000,//this value just for calculate shutter
+		.linelength = 1944,  /*[actually 2008*2]	*/	
+	    .framelength = 2550,
 		.startx = 0,
 		.starty = 0,
 		.grabwindow_width = 3264,
 		.grabwindow_height = 2448,
 		.mipi_data_lp2hs_settle_dc = 23,
-		.max_framerate = 300,
+		.max_framerate = 300,
 	},
 	.cap1 = {//24fps 600M bps/lane
-		.pclk = 120000000,//this value just for calculate shutter
-		.linelength = 1944,  /*[actually 2008*2]	*/	
-		.framelength = 4080,//modify for 15fps at mt6735 //2550,
+		.pclk = 120000000,//this value just for calculate shutter
+		.linelength = 1944,  /*[actually 2008*2]	*/	
+		.framelength = 4080,//modify for 15fps at mt6735 //2550,
 		.startx = 0,
 		.starty = 0,
 		.grabwindow_width = 3264,
@@ -87,31 +87,31 @@ static imgsensor_info_struct imgsensor_info = {
 		.max_framerate = 150,	//less than 13M(include 13M),cap1 max framerate is 24fps,16M max framerate is 20fps, 20M max framerate is 15fps  
 	},
 	.normal_video = {
-		.pclk = 148800000,
-		.linelength = 2582,       /*[actually 2582*2]	*/	
-		.framelength = 1908,
+		.pclk = 148800000,
+		.linelength = 2582,       /*[actually 2582*2]	*/	
+		.framelength = 1908,
 		.startx = 0,
 		.starty = 0,
-		.grabwindow_width = 3264,
-		.grabwindow_height = 1836,
+		.grabwindow_width = 3264,
+		.grabwindow_height = 1836,
 		.mipi_data_lp2hs_settle_dc = 23,
 		.max_framerate = 300,
 	},
-	.hs_video = {
+	.hs_video = {
 		.pclk = 74400000,
-		.linelength = 1153, /*[actually 1153*2]	*/	
-		.framelength = 537,
+		.linelength = 1153, /*[actually 1153*2]	*/	
+		.framelength = 537,
 		.startx = 0,
 		.starty = 0,
-		.grabwindow_width = 640,
-		.grabwindow_height = 480,
+		.grabwindow_width = 640,
+		.grabwindow_height = 480,
 		.mipi_data_lp2hs_settle_dc = 23,
-		.max_framerate = 1200,
+		.max_framerate = 1200,
 	},
 	.slim_video = { //equal preview setting
 		.pclk = 74400000,
 		.linelength = 1923,  /*[actually 1923*2]	*/			//record different mode's linelength
-		.framelength = 1280,								//record different mode's framelength
+		.framelength = 1280,								//record different mode's framelength
 		.startx = 0,										//record different mode's startx of grabwindow
 		.starty = 0,										//record different mode's starty of grabwindow
 		.grabwindow_width = 1632,							//record different mode's width of grabwindow
@@ -128,7 +128,7 @@ static imgsensor_info_struct imgsensor_info = {
 	.ae_ispGain_delay_frame = 2,
 	.ihdr_support = 0,	  //1, support; 0,not support
 	.ihdr_le_firstline = 0,  //1,le first ; 0, se first
-	.sensor_mode_num = 5,	  
+	.sensor_mode_num = 5,	  
 	
 	.cap_delay_frame = 2, 
 	.pre_delay_frame = 2, 
@@ -138,19 +138,23 @@ static imgsensor_info_struct imgsensor_info = {
 	
 	.isp_driving_current = ISP_DRIVING_6MA,
 	.sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,
-	.mipi_sensor_type = MIPI_OPHY_NCSI2,//0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2
-	.mipi_settle_delay_mode = MIPI_SETTLEDELAY_AUTO,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
+	.mipi_sensor_type = MIPI_OPHY_NCSI2,//0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2
+	.mipi_settle_delay_mode = MIPI_SETTLEDELAY_AUTO,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
 	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_B,
 	.mclk = 24,
 	.mipi_lane_num = SENSOR_MIPI_4_LANE,
-	.i2c_addr_table = {0x6C,0x42,0xff},
+	.i2c_addr_table = {0x20,0x6c,0xff},
 };
 
 
 
 
 static imgsensor_struct imgsensor = {
-	.mirror = IMAGE_NORMAL,				//mirrorflip information
+#ifdef VANZO_IMGSENSOR_OV8865_ROTATION
+	.mirror = IMAGE_HV_MIRROR,//IMAGE_HV_MIRROR,				//mirrorflip information
+#else
+	.mirror = IMAGE_NORMAL,//IMAGE_HV_MIRROR,				//mirrorflip information
+#endif
 	.sensor_mode = IMGSENSOR_MODE_INIT, //IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
 	.shutter = 0x3D0,					//current shutter
 	.gain = 0x100,						//current gain
@@ -161,17 +165,17 @@ static imgsensor_struct imgsensor = {
 	.test_pattern = KAL_FALSE,		//test pattern mode or not. 
 	.current_scenario_id = MSDK_SCENARIO_ID_CAMERA_PREVIEW,//current scenario id
 	.ihdr_en = 0, //sensor need support LE, SE with HDR feature
-	.i2c_write_id = 0x6C,
+	.i2c_write_id = 0x20,
 };
 
 
 /* Sensor output window information */
-static SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[5] =	 
-{{ 3264, 2448, 0, 0, 3264, 2448,    1632,1224,0,0,  1632,1224,	  0,0,1632,1224}, // Preview 
- { 3264, 2448, 0, 0, 3264, 2448, 	3264,2448,0,0,  3264,2448,	  0,0,3264,2448}, // capture
- { 3264, 2448, 0, 0, 3264, 2448, 	3264,2448,0,306,3264,1836,	  0,0,3264,1836},// video 
- { 3264, 2448, 0, 0, 3264, 2448, 	3264,2448,0,0,  640, 480,	  0,0,640 ,480},//hight speed video  
- { 3264, 2448, 0, 0, 3264, 2448, 	1632,1224,0,0,  1632,1224,	  0,0,1632,1224}};// slim video 
+static SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[5] =	 
+{{ 3264, 2448, 0, 0, 3264, 2448,    1632,1224,0,0,  1632,1224,	  0,0,1632,1224}, // Preview 
+ { 3264, 2448, 0, 0, 3264, 2448, 	3264,2448,0,0,  3264,2448,	  0,0,3264,2448}, // capture
+ { 3264, 2448, 0, 0, 3264, 2448, 	3264,2448,0,306,3264,1836,	  0,0,3264,1836},// video 
+ { 3264, 2448, 0, 0, 3264, 2448, 	3264,2448,0,0,  640, 480,	  0,0,640 ,480},//hight speed video  
+ { 3264, 2448, 0, 0, 3264, 2448, 	1632,1224,0,0,  1632,1224,	  0,0,1632,1224}};// slim video 
 
 
 static kal_uint16 read_cmos_sensor(kal_uint32 addr)
@@ -179,15 +183,15 @@ static kal_uint16 read_cmos_sensor(kal_uint32 addr)
 	kal_uint16 get_byte=0;
 
 	char pu_send_cmd[2] = {(char)(addr >> 8), (char)(addr & 0xFF) };
-	iReadRegI2C(pu_send_cmd, 2, (u8*)&get_byte, 1, imgsensor.i2c_write_id);
-
+	iReadRegI2C(pu_send_cmd, 2, (u8*)&get_byte, 1, imgsensor.i2c_write_id);
+
 	return get_byte;
 }
 
 static void write_cmos_sensor(kal_uint32 addr, kal_uint32 para)
 {
-	char pu_send_cmd[3] = {(char)(addr >> 8), (char)(addr & 0xFF), (char)(para & 0xFF)};
-	iWriteRegI2C(pu_send_cmd, 3, imgsensor.i2c_write_id);
+	char pu_send_cmd[3] = {(char)(addr >> 8), (char)(addr & 0xFF), (char)(para & 0xFF)};
+	iWriteRegI2C(pu_send_cmd, 3, imgsensor.i2c_write_id);
 }
 
 static void set_dummy()
@@ -233,22 +237,22 @@ static void set_max_framerate(UINT16 framerate,kal_bool min_framelength_en)
 }	/*	set_max_framerate  */
 
 
-static void set_shutter(kal_uint16 shutter)
+static void set_shutter(kal_uint16 shutter)
 {
-    unsigned long flags;
-    kal_uint16 realtime_fps = 0;
-    kal_uint32 frame_length = 0;
-    spin_lock_irqsave(&imgsensor_drv_lock, flags);
-    imgsensor.shutter = shutter;
-    spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
-
-
-    spin_lock(&imgsensor_drv_lock);
-    if (shutter > imgsensor.min_frame_length - imgsensor_info.margin)
-        imgsensor.frame_length = shutter + imgsensor_info.margin;
-    else
-        imgsensor.frame_length = imgsensor.min_frame_length;
-    if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+    unsigned long flags;
+    kal_uint16 realtime_fps = 0;
+    kal_uint32 frame_length = 0;
+    spin_lock_irqsave(&imgsensor_drv_lock, flags);
+    imgsensor.shutter = shutter;
+    spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
+
+
+    spin_lock(&imgsensor_drv_lock);
+    if (shutter > imgsensor.min_frame_length - imgsensor_info.margin)
+        imgsensor.frame_length = shutter + imgsensor_info.margin;
+    else
+        imgsensor.frame_length = imgsensor.min_frame_length;
+    if (imgsensor.frame_length > imgsensor_info.max_frame_length)
 		imgsensor.frame_length = imgsensor_info.max_frame_length;
 	spin_unlock(&imgsensor_drv_lock);
 
@@ -261,25 +265,25 @@ static void set_shutter(kal_uint16 shutter)
 		if(realtime_fps >= 297 && realtime_fps <= 305)
 			set_max_framerate(296,0);
 		else if(realtime_fps >= 147 && realtime_fps <= 150)
-            set_max_framerate(146,0);
-        else {
-        // Extend frame length
-        write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
-        write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
-        }
-    } else {
-        // Extend frame length
-        write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
-        write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
-    }
-
-    // Update Shutter
-    write_cmos_sensor(0x3502, (shutter << 4) & 0xFF);
-    write_cmos_sensor(0x3501, (shutter >> 4) & 0xFF);
-    write_cmos_sensor(0x3500, (shutter >> 12) & 0x0F);
-    LOG_INF("Exit! shutter =%d, framelength =%d\n", shutter,imgsensor.frame_length);
-
-}
+            set_max_framerate(146,0);
+        else {
+        // Extend frame length
+        write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
+        write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
+        }
+    } else {
+        // Extend frame length
+        write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
+        write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
+    }
+
+    // Update Shutter
+    write_cmos_sensor(0x3502, (shutter << 4) & 0xFF);
+    write_cmos_sensor(0x3501, (shutter >> 4) & 0xFF);
+    write_cmos_sensor(0x3500, (shutter >> 12) & 0x0F);
+    LOG_INF("Exit! shutter =%d, framelength =%d\n", shutter,imgsensor.frame_length);
+
+}
 
 
 static kal_uint16 gain2reg(const kal_uint16 gain)
@@ -333,8 +337,8 @@ static kal_uint16 set_gain(kal_uint16 gain)
 	spin_unlock(&imgsensor_drv_lock);
 	LOG_INF("gain = %d , reg_gain = 0x%x\n ", gain, reg_gain);
 
-	write_cmos_sensor(0x3508,(reg_gain>>8));
-	write_cmos_sensor(0x3509,(reg_gain&0xff));
+	write_cmos_sensor(0x3508,(reg_gain>>8));
+	write_cmos_sensor(0x3509,(reg_gain&0xff));
 	
 	return gain;
 }	/*	set_gain  */
@@ -377,18 +381,18 @@ static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gai
 }
 
 
-#if 0
+#if 1
 static void set_mirror_flip(kal_uint8 image_mirror)
 {
 
 	kal_int16 mirror=0,flip=0;
-
-	LOG_INF("image_mirror = %d\n", image_mirror);
+
+	LOG_INF("image_mirror = %d\n", image_mirror);
 	
-	mirror= OV8865_read_cmos_sensor(0x3820);
-	flip  = OV8865_read_cmos_sensor(0x3821);
-
-    switch (imgMirror)
+	mirror= read_cmos_sensor(0x3820);
+	flip  = read_cmos_sensor(0x3821);
+
+    switch (image_mirror)
     {
         case IMAGE_H_MIRROR://IMAGE_NORMAL:
             write_cmos_sensor(0x3820, (mirror & (0xF9)));//Set normal
@@ -446,7 +450,7 @@ static void sensor_init(void)
 	write_cmos_sensor(0x3638,0xff);// ; analog control
 
 	write_cmos_sensor(0x0302,0x1f);// ; PLL
-
+
 	write_cmos_sensor(0x0303,0x00);// ; PLL
 	write_cmos_sensor(0x0304,0x03);// ; PLL
 	write_cmos_sensor(0x030d,0x1f);// ; PLL	  ;1e
@@ -455,7 +459,7 @@ static void sensor_init(void)
 	write_cmos_sensor(0x0312,0x01);// ; PLL
 	write_cmos_sensor(0x031e,0x0c);// ; PLL
 	write_cmos_sensor(0x3015,0x01);// ; clock Div
-	write_cmos_sensor(0x3018,0x72);// ; MIPI 4 lane
+	write_cmos_sensor(0x3018,0x72);// ; MIPI 4 lane
 	write_cmos_sensor(0x3020,0x93);// ; clock normal, pclk/1
 	write_cmos_sensor(0x3022,0x01);// ; pd_mini enable when rst_sync
 	write_cmos_sensor(0x3031,0x0a);// ; 10-bit
@@ -480,9 +484,9 @@ static void sensor_init(void)
 	write_cmos_sensor(0x360c,0xdd);//
 	write_cmos_sensor(0x360e,0x0c);//
 	write_cmos_sensor(0x3610,0x07);//
-
-	write_cmos_sensor(0x3612,0x86);//AM24  power save ov_Revise
-	write_cmos_sensor(0x3613,0x58);//AM24
+
+	write_cmos_sensor(0x3612,0x86);//AM24  power save ov_Revise
+	write_cmos_sensor(0x3613,0x58);//AM24
 	write_cmos_sensor(0x3614,0x28);//
 	write_cmos_sensor(0x3617,0x40);//
 	write_cmos_sensor(0x3618,0x5a);//
@@ -493,35 +497,35 @@ static void sensor_init(void)
 	write_cmos_sensor(0x3633,0x10);//
 	write_cmos_sensor(0x3634,0x10);//
 	write_cmos_sensor(0x3635,0x10);//
-	write_cmos_sensor(0x3636,0x10);//AM24
+	write_cmos_sensor(0x3636,0x10);//AM24
 	write_cmos_sensor(0x3641,0x55);// ; MIPI settings
 	write_cmos_sensor(0x3646,0x86);// ; MIPI settings
 	write_cmos_sensor(0x3647,0x27);// ; MIPI settings
 	write_cmos_sensor(0x364a,0x1b);// ; MIPI settings
-
-
-	//write_cmos_sensor(0x3500,0x00);// ; exposurre HH
-	//write_cmos_sensor(0x3501,0x4c);// ; expouere H
-	//write_cmos_sensor(0x3502,0x00);// ; exposure L
-
-
+
+
+	//write_cmos_sensor(0x3500,0x00);// ; exposurre HH
+	//write_cmos_sensor(0x3501,0x4c);// ; expouere H
+	//write_cmos_sensor(0x3502,0x00);// ; exposure L
+
+
 	write_cmos_sensor(0x3503,0x00);// ; gain no delay, exposure no delay
-
+
 	write_cmos_sensor(0x3508,0x02);// ; gain H
 	write_cmos_sensor(0x3509,0x00);// ; gain L
-
-	write_cmos_sensor(0x3700,0x24);// ; sensor control AM24
+
+	write_cmos_sensor(0x3700,0x24);// ; sensor control AM24
 	write_cmos_sensor(0x3701,0x0c);//
 	write_cmos_sensor(0x3702,0x28);//
 	write_cmos_sensor(0x3703,0x19);//
 	write_cmos_sensor(0x3704,0x14);//
 	write_cmos_sensor(0x3705,0x00);//
-	write_cmos_sensor(0x3706,0x38);//AM24
+	write_cmos_sensor(0x3706,0x38);//AM24
 	write_cmos_sensor(0x3707,0x04);//
 	write_cmos_sensor(0x3708,0x24);//
 	write_cmos_sensor(0x3709,0x40);//
 	write_cmos_sensor(0x370a,0x00);//
-	write_cmos_sensor(0x370b,0xb8);//AM24
+	write_cmos_sensor(0x370b,0xb8);//AM24
 	write_cmos_sensor(0x370c,0x04);//
 	write_cmos_sensor(0x3718,0x12);//
 	write_cmos_sensor(0x3719,0x31);//
@@ -557,15 +561,15 @@ static void sensor_init(void)
 	write_cmos_sensor(0x3759,0x4c);//
 	write_cmos_sensor(0x375a,0x06);//
 	write_cmos_sensor(0x375b,0x13);//
-	write_cmos_sensor(0x375c,0x40);//am26
+	write_cmos_sensor(0x375c,0x40);//am26
 	write_cmos_sensor(0x375d,0x02);//
 	write_cmos_sensor(0x375e,0x00);//
 	write_cmos_sensor(0x375f,0x14);//
-	write_cmos_sensor(0x3767,0x1c);//am26
+	write_cmos_sensor(0x3767,0x1c);//am26
 	write_cmos_sensor(0x3768,0x04);//
 	write_cmos_sensor(0x3769,0x20);//
-	write_cmos_sensor(0x376c,0xc0);//am26
-	write_cmos_sensor(0x376d,0xc0);//am26
+	write_cmos_sensor(0x376c,0xc0);//am26
+	write_cmos_sensor(0x376d,0xc0);//am26
 	write_cmos_sensor(0x376a,0x08);//
 	write_cmos_sensor(0x3761,0x00);//
 	write_cmos_sensor(0x3762,0x00);//
@@ -585,8 +589,8 @@ static void sensor_init(void)
 	write_cmos_sensor(0x37a5,0x08);//
 	write_cmos_sensor(0x37a6,0x00);//
 	write_cmos_sensor(0x37a7,0x44);//
-	write_cmos_sensor(0x37a8,0x58);//AM24
-	write_cmos_sensor(0x37a9,0x58);//AM24
+	write_cmos_sensor(0x37a8,0x58);//AM24
+	write_cmos_sensor(0x37a9,0x58);//AM24
 	write_cmos_sensor(0x3760,0x00);//
 	write_cmos_sensor(0x376f,0x01);//
 	write_cmos_sensor(0x37aa,0x44);//
@@ -605,28 +609,28 @@ static void sensor_init(void)
 	write_cmos_sensor(0x37b7,0x00);//
 	write_cmos_sensor(0x37b8,0x00);//
 	write_cmos_sensor(0x37b9,0xff);// ; sensor control
-
+
 	write_cmos_sensor(0x3800,0x00);// ; X start H
 	write_cmos_sensor(0x3801,0x0c);// ; X start L
-
+
 	write_cmos_sensor(0x3802,0x00);// ; Y start H
 	write_cmos_sensor(0x3803,0x0c);// ; Y start L
-
+
 	write_cmos_sensor(0x3804,0x0c);// ; X end H
 	write_cmos_sensor(0x3805,0xd3);// ; X end L
 	write_cmos_sensor(0x3806,0x09);// ; Y end H
 	write_cmos_sensor(0x3807,0xa3);// ; Y end L
-
+
 	write_cmos_sensor(0x3808,0x06);// ; X output size H
 	write_cmos_sensor(0x3809,0x60);// ; X output size L
 	write_cmos_sensor(0x380a,0x04);// ; Y output size H
 	write_cmos_sensor(0x380b,0xc8);// ; Y output size L
-
+
 	write_cmos_sensor(0x380c,0x07);// ; HTS H
 	write_cmos_sensor(0x380d,0x83);// ; HTS L
 	write_cmos_sensor(0x380e,0x04);// ; VTS H
 	write_cmos_sensor(0x380f,0xe0);// ; VTS L
-
+
 	write_cmos_sensor(0x3810,0x00);// ; ISP X win H
 	write_cmos_sensor(0x3811,0x04);// ; ISP X win L
 	write_cmos_sensor(0x3813,0x04);// ; ISP Y win L
@@ -642,7 +646,7 @@ static void sensor_init(void)
 	write_cmos_sensor(0x3841,0xff);// ; auto size
 	write_cmos_sensor(0x3846,0x88);// ; Y/X boundary pixel numbber for auto size mode
 
-
+
 	//3d85/3d8c/3d8d  for otp auto load at power on
 	write_cmos_sensor(0x3d85,0x06);//AM24a
 	write_cmos_sensor(0x3d8c,0x75);//AM24a
@@ -650,14 +654,14 @@ static void sensor_init(void)
 
 
 	write_cmos_sensor(0x3f08,0x0b);//
-
+
 	write_cmos_sensor(0x4000,0xf1);// ; our range trig en, format chg en, gan chg en, exp chg en, median en
 	write_cmos_sensor(0x4001,0x14);// ; left 32 column, final BLC offset limitation enable
 	write_cmos_sensor(0x4005,0x10);// ; BLC target
 
 	write_cmos_sensor(0x4006,0x04);// ;revise for ZSD ON/OFF unstable,MTK
 	write_cmos_sensor(0x4007,0x04);// ; 
-
+
 	write_cmos_sensor(0x400b,0x0c);// ; start line =0, offset limitation en, cut range function en
 	write_cmos_sensor(0x400d,0x10);// ; offset trigger threshold
 	write_cmos_sensor(0x401b,0x00);//
@@ -687,10 +691,10 @@ static void sensor_init(void)
 	write_cmos_sensor(0x4503,0x10);//
 	write_cmos_sensor(0x4601,0x74);// ; V FIFO control
 	write_cmos_sensor(0x481f,0x32);// ; clk_prepare_min
-
+
 	write_cmos_sensor(0x4837,0x16);// ; clock period
-
-
+
+
 	write_cmos_sensor(0x4850,0x10);// ; lane select
 	write_cmos_sensor(0x4851,0x32);// ; lane select
 	write_cmos_sensor(0x4b00,0x2a);// ; LVDS settings
@@ -701,10 +705,10 @@ static void sensor_init(void)
 	write_cmos_sensor(0x4d03,0xff);// ; temperature sensor
 	write_cmos_sensor(0x4d04,0xff);// ; temperature sensor
 	write_cmos_sensor(0x4d05,0xff);// ; temperature sensor
-
+
 	write_cmos_sensor(0x5000,0x96);// ; LENC on, MWB on, BPC on, WPC on
 	write_cmos_sensor(0x5001,0x01);// ; BLC on
-
+
 	write_cmos_sensor(0x5002,0x08);// ; vario pixel off
 	write_cmos_sensor(0x5901,0x00);//
 	write_cmos_sensor(0x5e00,0x00);// ; test pattern off
@@ -780,38 +784,38 @@ static void sensor_init(void)
 	write_cmos_sensor(0x5b03,0xff);// 
 	write_cmos_sensor(0x5b05,0x6c);// 
 	//write_cmos_sensor(0x4800,0x5c);// ; mipi gate:lens start/end
-
+
 }
-
-	/*	sensor_init  */
-
+
+	/*	sensor_init  */
+
 
 static void preview_setting(void)
 {
 	LOG_INF("Enter\n");
 
 	write_cmos_sensor(0x0100,0x00);//; software standby
-	
-	write_cmos_sensor(0x0302,0x1f);// ; PLL
-	write_cmos_sensor(0x030d,0x1f);// ; PLL	  ;1e
+	
+	write_cmos_sensor(0x0302,0x1f);// ; PLL
+	write_cmos_sensor(0x030d,0x1f);// ; PLL	  ;1e
 	write_cmos_sensor(0x030f,0x09);//; PLL
-	write_cmos_sensor(0x3018,0x72);//
+	write_cmos_sensor(0x3018,0x72);//
 	write_cmos_sensor(0x3106,0x01);//
 	
 	//write_cmos_sensor(0x3501,0x28);//; expouere H
 	//write_cmos_sensor(0x3502,0x90);//; exposure L
 	
-	write_cmos_sensor(0x3700,0x24);//; sensor control  AM24
+	write_cmos_sensor(0x3700,0x24);//; sensor control  AM24
 	write_cmos_sensor(0x3701,0x0c);//
 	write_cmos_sensor(0x3702,0x28);//
 	write_cmos_sensor(0x3703,0x19);//
 	write_cmos_sensor(0x3704,0x14);//
-	write_cmos_sensor(0x3706,0x38);//AM24
+	write_cmos_sensor(0x3706,0x38);//AM24
 	write_cmos_sensor(0x3707,0x04);//
 	write_cmos_sensor(0x3708,0x24);//
 	write_cmos_sensor(0x3709,0x40);//
 	write_cmos_sensor(0x370a,0x00);//
-	write_cmos_sensor(0x370b,0xb8);//AM24
+	write_cmos_sensor(0x370b,0xb8);//AM24
 	write_cmos_sensor(0x370c,0x04);//
 	write_cmos_sensor(0x3718,0x12);//
 	write_cmos_sensor(0x3712,0x42);//
@@ -840,7 +844,7 @@ static void preview_setting(void)
 	write_cmos_sensor(0x373e,0x03);//
 	write_cmos_sensor(0x375a,0x06);//
 	write_cmos_sensor(0x375b,0x13);//
-	write_cmos_sensor(0x375c,0x40);// am26
+	write_cmos_sensor(0x375c,0x40);// am26
 	write_cmos_sensor(0x375d,0x02);//
 	write_cmos_sensor(0x375f,0x14);//
 	write_cmos_sensor(0x3767,0x1c);//am26
@@ -858,8 +862,8 @@ static void preview_setting(void)
 	write_cmos_sensor(0x37a3,0x01);//
 	write_cmos_sensor(0x37a5,0x08);//
 	write_cmos_sensor(0x37a7,0x44);//
-	write_cmos_sensor(0x37a8,0x58);//AM24
-	write_cmos_sensor(0x37a9,0x58);//AM24
+	write_cmos_sensor(0x37a8,0x58);//AM24
+	write_cmos_sensor(0x37a9,0x58);//AM24
 	write_cmos_sensor(0x37aa,0x44);//
 	write_cmos_sensor(0x37ab,0x2e);//
 	write_cmos_sensor(0x37ac,0x2e);//
@@ -870,9 +874,9 @@ static void preview_setting(void)
 	write_cmos_sensor(0x37b4,0x42);//
 	write_cmos_sensor(0x37b5,0x33);//
 
-	write_cmos_sensor(0x3808,0x06);//; X output size H	active 
+	write_cmos_sensor(0x3808,0x06);//; X output size H	active 
 	write_cmos_sensor(0x3809,0x60);//; X output size L  (0x3809,0x60)
-	write_cmos_sensor(0x380a,0x04);//; Y output size H	active 
+	write_cmos_sensor(0x380a,0x04);//; Y output size H	active 
 	write_cmos_sensor(0x380b,0xc8);//; Y output size L (0x380b,0xc8)
 
 	write_cmos_sensor(0x380c,((imgsensor_info.pre.linelength >> 8) & 0xFF));//; HTS H
@@ -902,376 +906,376 @@ static void preview_setting(void)
 	write_cmos_sensor(0x4026,0x04);//; anchor right end H
 	write_cmos_sensor(0x4027,0x5f);//; anchor right end L
 	write_cmos_sensor(0x402a,0x04);//; top black line start
-	write_cmos_sensor(0x402b,0x04);//am26
+	write_cmos_sensor(0x402b,0x04);//am26
 	write_cmos_sensor(0x402c,0x02);//; bottom zero line start
 	write_cmos_sensor(0x402d,0x02);//; bottom zero line number
 	write_cmos_sensor(0x402e,0x08);//; bottom black line start
 	write_cmos_sensor(0x4500,0x40);//; ADC sync control
 	write_cmos_sensor(0x4601,0x74);//; V FIFO control
-	
-	write_cmos_sensor(0x4837,0x16);// ; clock period 
-	
+	
+	write_cmos_sensor(0x4837,0x16);// ; clock period 
+	
 	write_cmos_sensor(0x5002,0x08);//; vario pixel off
 	write_cmos_sensor(0x5901,0x00);//
-
-	//mdelay(100);
+
+	//mdelay(100);
 	write_cmos_sensor(0x0100,0x01);//; wake up, streaming
 }	/*	preview_setting  */
 
 static void capture_setting(kal_uint16 currefps)
 {
 	LOG_INF("Enter! currefps:%d\n",currefps);
-
-	if(currefps == 150)
-	{
-		write_cmos_sensor(0x0100,0x00);
-
-		write_cmos_sensor(0x0302,0x19);// 
-		write_cmos_sensor(0x030d,0x1e);// 
-		write_cmos_sensor(0x030f,0x05);// ; PLL
-		
-		write_cmos_sensor(0x3018,0x72);//
-		write_cmos_sensor(0x3106,0x01);//
-		
-		//write_cmos_sensor(0x3501,0x8f);// ; expouere H
-		//write_cmos_sensor(0x3502,0xa0);// ; exposure L
-		
-		write_cmos_sensor(0x3700,0x48);// ; sensor control	AM24
-		write_cmos_sensor(0x3701,0x18);//
-		write_cmos_sensor(0x3702,0x50);//
-		write_cmos_sensor(0x3703,0x32);//
-		write_cmos_sensor(0x3704,0x28);//
-		write_cmos_sensor(0x3706,0x70);//AM24
-		write_cmos_sensor(0x3707,0x08);//
-		write_cmos_sensor(0x3708,0x48);//
-		write_cmos_sensor(0x3709,0x80);//
-		write_cmos_sensor(0x370a,0x01);//
-		write_cmos_sensor(0x370b,0x70);//AM24
-		write_cmos_sensor(0x370c,0x07);//
-		write_cmos_sensor(0x3718,0x14);//
-		write_cmos_sensor(0x3712,0x44);//
-		write_cmos_sensor(0x371e,0x31);//
-		write_cmos_sensor(0x371f,0x7f);//
-		write_cmos_sensor(0x3720,0x0a);//
-		write_cmos_sensor(0x3721,0x0a);//
-		write_cmos_sensor(0x3724,0x04);//
-		write_cmos_sensor(0x3725,0x04);//
-		write_cmos_sensor(0x3726,0x0c);//
-		write_cmos_sensor(0x3728,0x0a);//
-		write_cmos_sensor(0x3729,0x03);//
-		write_cmos_sensor(0x372a,0x06);//
-		write_cmos_sensor(0x372b,0xa6);//
-		write_cmos_sensor(0x372c,0xa6);//
-		write_cmos_sensor(0x372d,0xa6);//
-		write_cmos_sensor(0x372e,0x0c);//
-		write_cmos_sensor(0x372f,0x20);//
-		write_cmos_sensor(0x3730,0x02);//
-		write_cmos_sensor(0x3731,0x0c);//
-		write_cmos_sensor(0x3732,0x28);//
-		write_cmos_sensor(0x3736,0x30);//
-		write_cmos_sensor(0x373a,0x04);//
-		write_cmos_sensor(0x373b,0x18);//
-		write_cmos_sensor(0x373c,0x14);//
-		write_cmos_sensor(0x373e,0x06);//
-		write_cmos_sensor(0x375a,0x0c);//
-		write_cmos_sensor(0x375b,0x26);//
-		write_cmos_sensor(0x375c,0x40);//am26
-		write_cmos_sensor(0x375d,0x04);//
-		write_cmos_sensor(0x375f,0x28);//
-		write_cmos_sensor(0x3767,0x1e);//0x04
-		write_cmos_sensor(0x3769,0x20);//
-		write_cmos_sensor(0x376c,0xc0);//am26
-		write_cmos_sensor(0x376d,0xc0);//am26
-		write_cmos_sensor(0x3772,0x46);//
-		write_cmos_sensor(0x3773,0x04);//
-		write_cmos_sensor(0x3774,0x2c);//
-		write_cmos_sensor(0x3775,0x13);//
-		write_cmos_sensor(0x3776,0x10);//
-		write_cmos_sensor(0x37a0,0x88);//
-		write_cmos_sensor(0x37a1,0x7a);//
-		write_cmos_sensor(0x37a2,0x7a);//
-		write_cmos_sensor(0x37a3,0x02);//
-		write_cmos_sensor(0x37a5,0x09);//
-		write_cmos_sensor(0x37a7,0x88);//
-		write_cmos_sensor(0x37a8,0xb0);//AM24
-		write_cmos_sensor(0x37a9,0xb0);//AM24
-		write_cmos_sensor(0x37aa,0x88);//
-		write_cmos_sensor(0x37ab,0x5c);//
-		write_cmos_sensor(0x37ac,0x5c);//
-		write_cmos_sensor(0x37ad,0x55);//
-		write_cmos_sensor(0x37ae,0x19);//
-		write_cmos_sensor(0x37af,0x19);//
-		write_cmos_sensor(0x37b3,0x84);//
-		write_cmos_sensor(0x37b4,0x84);//
-		write_cmos_sensor(0x37b5,0x66);//
-
-		write_cmos_sensor(0x3808,0x0c);// ; X output size H
-		write_cmos_sensor(0x3809,0xc0);// ; X output size L (0x3809,0xc0)
-		write_cmos_sensor(0x380a,0x09);// ; Y output size H
-		write_cmos_sensor(0x380b,0x90);// ; Y output size L (0x380b,0x90)
-		
-		write_cmos_sensor(0x380c,((imgsensor_info.cap1.linelength >> 8) & 0xFF));// ; HTS H //30fps
-		write_cmos_sensor(0x380d,(imgsensor_info.cap1.linelength & 0xFF));// ; HTS L 
-		write_cmos_sensor(0x380e,((imgsensor_info.cap1.framelength >> 8) & 0xFF));//; VTS H
-		write_cmos_sensor(0x380f,(imgsensor_info.cap1.framelength & 0xFF));//; VTS L
-		
-		write_cmos_sensor(0x3813,0x02);// ; ISP Y win L
-		write_cmos_sensor(0x3814,0x01);// ; X inc odd
-		write_cmos_sensor(0x3821,0x46);// ; hsync_en_o, fst_vbin, mirror on
-		write_cmos_sensor(0x382a,0x01);// ; Y inc odd
-		write_cmos_sensor(0x382b,0x01);// ; Y inc even
-		write_cmos_sensor(0x3830,0x04);// ; ablc_use_num[5:1]
-		write_cmos_sensor(0x3836,0x01);// ; zline_use_num[5:1]
-		write_cmos_sensor(0x3846,0x48);// ; Y/X boundary pixel numbber for auto size mode
-		write_cmos_sensor(0x3f08,0x16);//
-		
-		write_cmos_sensor(0x4000,0xf1);//; our range trig en, format chg en, gan chg en, exp chg en, median en
-		
-		write_cmos_sensor(0x4001,0x04);// ; left 32 column, final BLC offset limitation enable
-		write_cmos_sensor(0x4020,0x02);// ; anchor left start H
-		write_cmos_sensor(0x4021,0x40);// ; anchor left start L
-		write_cmos_sensor(0x4022,0x03);// ; anchor left end H
-		write_cmos_sensor(0x4023,0x3f);// ; anchor left end L
-		write_cmos_sensor(0x4024,0x07);// ; anchor right start H
-		write_cmos_sensor(0x4025,0xc0);// ; anchor right start L
-		write_cmos_sensor(0x4026,0x08);// ; anchor right end H
-		write_cmos_sensor(0x4027,0xbf);// ; anchor right end L
-		write_cmos_sensor(0x402a,0x04);// ; top black line start
-		write_cmos_sensor(0x402b,0x04);//am26
-		write_cmos_sensor(0x402c,0x02);// ; bottom zero line start	
-		write_cmos_sensor(0x402d,0x02);// ; bottom zero line number
-		write_cmos_sensor(0x402e,0x08);// ; bottom black line start
-		write_cmos_sensor(0x4500,0x68);// ; ADC sync control
-		write_cmos_sensor(0x4601,0x10);// ; V FIFO control
-		write_cmos_sensor(0x4837,0x1a);// ; clock period
-		write_cmos_sensor(0x5002,0x08);// ; vario pixel off
-		write_cmos_sensor(0x5901,0x00);//
-		
-		write_cmos_sensor(0x0100,0x01);//; wake up, streaming
-	}
-	else//normal capture
-	{
-		write_cmos_sensor(0x0100,0x00);
-		
-		write_cmos_sensor(0x0302,0x1f);// ; PLL
-		write_cmos_sensor(0x030d,0x1f);// ; PLL	  ;1e
-		write_cmos_sensor(0x030f,0x04);// ; PLL
-		write_cmos_sensor(0x3018,0x72);//
-		write_cmos_sensor(0x3106,0x01);//
-		
-		//write_cmos_sensor(0x3501,0x8f);// ; expouere H
-		//write_cmos_sensor(0x3502,0xa0);// ; exposure L
-		
-		write_cmos_sensor(0x3700,0x48);// ; sensor control  AM24
-		write_cmos_sensor(0x3701,0x18);//
-		write_cmos_sensor(0x3702,0x50);//
-		write_cmos_sensor(0x3703,0x32);//
-		write_cmos_sensor(0x3704,0x28);//
-		write_cmos_sensor(0x3706,0x70);//AM24
-		write_cmos_sensor(0x3707,0x08);//
-		write_cmos_sensor(0x3708,0x48);//
-		write_cmos_sensor(0x3709,0x80);//
-		write_cmos_sensor(0x370a,0x01);//
-		write_cmos_sensor(0x370b,0x70);//AM24
-		write_cmos_sensor(0x370c,0x07);//
-		write_cmos_sensor(0x3718,0x14);//
-		write_cmos_sensor(0x3712,0x44);//
-		write_cmos_sensor(0x371e,0x31);//
-		write_cmos_sensor(0x371f,0x7f);//
-		write_cmos_sensor(0x3720,0x0a);//
-		write_cmos_sensor(0x3721,0x0a);//
-		write_cmos_sensor(0x3724,0x04);//
-		write_cmos_sensor(0x3725,0x04);//
-		write_cmos_sensor(0x3726,0x0c);//
-		write_cmos_sensor(0x3728,0x0a);//
-		write_cmos_sensor(0x3729,0x03);//
-		write_cmos_sensor(0x372a,0x06);//
-		write_cmos_sensor(0x372b,0xa6);//
-		write_cmos_sensor(0x372c,0xa6);//
-		write_cmos_sensor(0x372d,0xa6);//
-		write_cmos_sensor(0x372e,0x0c);//
-		write_cmos_sensor(0x372f,0x20);//
-		write_cmos_sensor(0x3730,0x02);//
-		write_cmos_sensor(0x3731,0x0c);//
-		write_cmos_sensor(0x3732,0x28);//
-		write_cmos_sensor(0x3736,0x30);//
-		write_cmos_sensor(0x373a,0x04);//
-		write_cmos_sensor(0x373b,0x18);//
-		write_cmos_sensor(0x373c,0x14);//
-		write_cmos_sensor(0x373e,0x06);//
-		write_cmos_sensor(0x375a,0x0c);//
-		write_cmos_sensor(0x375b,0x26);//
-		write_cmos_sensor(0x375c,0x40);//am26
-		write_cmos_sensor(0x375d,0x04);//
-		write_cmos_sensor(0x375f,0x28);//
-		write_cmos_sensor(0x3767,0x1e);//0x04
-		write_cmos_sensor(0x3769,0x20);//
-		write_cmos_sensor(0x376c,0xc0);//am26
-		write_cmos_sensor(0x376d,0xc0);//am26
-		write_cmos_sensor(0x3772,0x46);//
-		write_cmos_sensor(0x3773,0x04);//
-		write_cmos_sensor(0x3774,0x2c);//
-		write_cmos_sensor(0x3775,0x13);//
-		write_cmos_sensor(0x3776,0x10);//
-		write_cmos_sensor(0x37a0,0x88);//
-		write_cmos_sensor(0x37a1,0x7a);//
-		write_cmos_sensor(0x37a2,0x7a);//
-		write_cmos_sensor(0x37a3,0x02);//
-		write_cmos_sensor(0x37a5,0x09);//
-		write_cmos_sensor(0x37a7,0x88);//
-		write_cmos_sensor(0x37a8,0xb0);//AM24
-		write_cmos_sensor(0x37a9,0xb0);//AM24
-		write_cmos_sensor(0x37aa,0x88);//
-		write_cmos_sensor(0x37ab,0x5c);//
-		write_cmos_sensor(0x37ac,0x5c);//
-		write_cmos_sensor(0x37ad,0x55);//
-		write_cmos_sensor(0x37ae,0x19);//
-		write_cmos_sensor(0x37af,0x19);//
-		write_cmos_sensor(0x37b3,0x84);//
-		write_cmos_sensor(0x37b4,0x84);//
-		write_cmos_sensor(0x37b5,0x66);//
-
-		write_cmos_sensor(0x3808,0x0c);// ; X output size H
-		write_cmos_sensor(0x3809,0xc0);// ; X output size L (0x3809,0xc0)
-		write_cmos_sensor(0x380a,0x09);// ; Y output size H
-		write_cmos_sensor(0x380b,0x90);// ; Y output size L (0x380b,0x90)
-		
-		write_cmos_sensor(0x380c,((imgsensor_info.cap.linelength >> 8) & 0xFF));// ; HTS H //30fps
-		write_cmos_sensor(0x380d,(imgsensor_info.cap.linelength & 0xFF));// ; HTS L 
-		write_cmos_sensor(0x380e,((imgsensor_info.cap.framelength >> 8) & 0xFF));//; VTS H
-		write_cmos_sensor(0x380f,(imgsensor_info.cap.framelength & 0xFF));//; VTS L
-		
-		write_cmos_sensor(0x3813,0x02);// ; ISP Y win L
-		write_cmos_sensor(0x3814,0x01);// ; X inc odd
-		write_cmos_sensor(0x3821,0x46);// ; hsync_en_o, fst_vbin, mirror on
-		write_cmos_sensor(0x382a,0x01);// ; Y inc odd
-		write_cmos_sensor(0x382b,0x01);// ; Y inc even
-		write_cmos_sensor(0x3830,0x04);// ; ablc_use_num[5:1]
-		write_cmos_sensor(0x3836,0x01);// ; zline_use_num[5:1]
-		write_cmos_sensor(0x3846,0x48);// ; Y/X boundary pixel numbber for auto size mode
-		write_cmos_sensor(0x3f08,0x16);//
-		
-		write_cmos_sensor(0x4000,0xf1);//; our range trig en, format chg en, gan chg en, exp chg en, median en
-		
-		write_cmos_sensor(0x4001,0x04);// ; left 32 column, final BLC offset limitation enable
-		write_cmos_sensor(0x4020,0x02);// ; anchor left start H
-		write_cmos_sensor(0x4021,0x40);// ; anchor left start L
-		write_cmos_sensor(0x4022,0x03);// ; anchor left end H
-		write_cmos_sensor(0x4023,0x3f);// ; anchor left end L
-		write_cmos_sensor(0x4024,0x07);// ; anchor right start H
-		write_cmos_sensor(0x4025,0xc0);// ; anchor right start L
-		write_cmos_sensor(0x4026,0x08);// ; anchor right end H
-		write_cmos_sensor(0x4027,0xbf);// ; anchor right end L
-		write_cmos_sensor(0x402a,0x04);// ; top black line start
-		write_cmos_sensor(0x402b,0x04);//am26
-		write_cmos_sensor(0x402c,0x02);// ; bottom zero line start  
-		write_cmos_sensor(0x402d,0x02);// ; bottom zero line number
-		write_cmos_sensor(0x402e,0x08);// ; bottom black line start
-		write_cmos_sensor(0x4500,0x68);// ; ADC sync control
-		write_cmos_sensor(0x4601,0x10);// ; V FIFO control
-		write_cmos_sensor(0x4837,0x16);// ; clock period
-		write_cmos_sensor(0x5002,0x08);// ; vario pixel off
-		write_cmos_sensor(0x5901,0x00);//
-		
-		write_cmos_sensor(0x0100,0x01);//; wake up, streaming
-	    }
-}	
-	
-		
-static void normal_video_setting(kal_uint16 currefps)
-{
-	LOG_INF("Enter! currefps:%d\n",currefps);
+
+	if(currefps == 150)
+	{
+		write_cmos_sensor(0x0100,0x00);
+
+		write_cmos_sensor(0x0302,0x19);// 
+		write_cmos_sensor(0x030d,0x1e);// 
+		write_cmos_sensor(0x030f,0x05);// ; PLL
+		
+		write_cmos_sensor(0x3018,0x72);//
+		write_cmos_sensor(0x3106,0x01);//
+		
+		//write_cmos_sensor(0x3501,0x8f);// ; expouere H
+		//write_cmos_sensor(0x3502,0xa0);// ; exposure L
+		
+		write_cmos_sensor(0x3700,0x48);// ; sensor control	AM24
+		write_cmos_sensor(0x3701,0x18);//
+		write_cmos_sensor(0x3702,0x50);//
+		write_cmos_sensor(0x3703,0x32);//
+		write_cmos_sensor(0x3704,0x28);//
+		write_cmos_sensor(0x3706,0x70);//AM24
+		write_cmos_sensor(0x3707,0x08);//
+		write_cmos_sensor(0x3708,0x48);//
+		write_cmos_sensor(0x3709,0x80);//
+		write_cmos_sensor(0x370a,0x01);//
+		write_cmos_sensor(0x370b,0x70);//AM24
+		write_cmos_sensor(0x370c,0x07);//
+		write_cmos_sensor(0x3718,0x14);//
+		write_cmos_sensor(0x3712,0x44);//
+		write_cmos_sensor(0x371e,0x31);//
+		write_cmos_sensor(0x371f,0x7f);//
+		write_cmos_sensor(0x3720,0x0a);//
+		write_cmos_sensor(0x3721,0x0a);//
+		write_cmos_sensor(0x3724,0x04);//
+		write_cmos_sensor(0x3725,0x04);//
+		write_cmos_sensor(0x3726,0x0c);//
+		write_cmos_sensor(0x3728,0x0a);//
+		write_cmos_sensor(0x3729,0x03);//
+		write_cmos_sensor(0x372a,0x06);//
+		write_cmos_sensor(0x372b,0xa6);//
+		write_cmos_sensor(0x372c,0xa6);//
+		write_cmos_sensor(0x372d,0xa6);//
+		write_cmos_sensor(0x372e,0x0c);//
+		write_cmos_sensor(0x372f,0x20);//
+		write_cmos_sensor(0x3730,0x02);//
+		write_cmos_sensor(0x3731,0x0c);//
+		write_cmos_sensor(0x3732,0x28);//
+		write_cmos_sensor(0x3736,0x30);//
+		write_cmos_sensor(0x373a,0x04);//
+		write_cmos_sensor(0x373b,0x18);//
+		write_cmos_sensor(0x373c,0x14);//
+		write_cmos_sensor(0x373e,0x06);//
+		write_cmos_sensor(0x375a,0x0c);//
+		write_cmos_sensor(0x375b,0x26);//
+		write_cmos_sensor(0x375c,0x40);//am26
+		write_cmos_sensor(0x375d,0x04);//
+		write_cmos_sensor(0x375f,0x28);//
+		write_cmos_sensor(0x3767,0x1e);//0x04
+		write_cmos_sensor(0x3769,0x20);//
+		write_cmos_sensor(0x376c,0xc0);//am26
+		write_cmos_sensor(0x376d,0xc0);//am26
+		write_cmos_sensor(0x3772,0x46);//
+		write_cmos_sensor(0x3773,0x04);//
+		write_cmos_sensor(0x3774,0x2c);//
+		write_cmos_sensor(0x3775,0x13);//
+		write_cmos_sensor(0x3776,0x10);//
+		write_cmos_sensor(0x37a0,0x88);//
+		write_cmos_sensor(0x37a1,0x7a);//
+		write_cmos_sensor(0x37a2,0x7a);//
+		write_cmos_sensor(0x37a3,0x02);//
+		write_cmos_sensor(0x37a5,0x09);//
+		write_cmos_sensor(0x37a7,0x88);//
+		write_cmos_sensor(0x37a8,0xb0);//AM24
+		write_cmos_sensor(0x37a9,0xb0);//AM24
+		write_cmos_sensor(0x37aa,0x88);//
+		write_cmos_sensor(0x37ab,0x5c);//
+		write_cmos_sensor(0x37ac,0x5c);//
+		write_cmos_sensor(0x37ad,0x55);//
+		write_cmos_sensor(0x37ae,0x19);//
+		write_cmos_sensor(0x37af,0x19);//
+		write_cmos_sensor(0x37b3,0x84);//
+		write_cmos_sensor(0x37b4,0x84);//
+		write_cmos_sensor(0x37b5,0x66);//
+
+		write_cmos_sensor(0x3808,0x0c);// ; X output size H
+		write_cmos_sensor(0x3809,0xc0);// ; X output size L (0x3809,0xc0)
+		write_cmos_sensor(0x380a,0x09);// ; Y output size H
+		write_cmos_sensor(0x380b,0x90);// ; Y output size L (0x380b,0x90)
+		
+		write_cmos_sensor(0x380c,((imgsensor_info.cap1.linelength >> 8) & 0xFF));// ; HTS H //30fps
+		write_cmos_sensor(0x380d,(imgsensor_info.cap1.linelength & 0xFF));// ; HTS L 
+		write_cmos_sensor(0x380e,((imgsensor_info.cap1.framelength >> 8) & 0xFF));//; VTS H
+		write_cmos_sensor(0x380f,(imgsensor_info.cap1.framelength & 0xFF));//; VTS L
+		
+		write_cmos_sensor(0x3813,0x02);// ; ISP Y win L
+		write_cmos_sensor(0x3814,0x01);// ; X inc odd
+		write_cmos_sensor(0x3821,0x46);// ; hsync_en_o, fst_vbin, mirror on
+		write_cmos_sensor(0x382a,0x01);// ; Y inc odd
+		write_cmos_sensor(0x382b,0x01);// ; Y inc even
+		write_cmos_sensor(0x3830,0x04);// ; ablc_use_num[5:1]
+		write_cmos_sensor(0x3836,0x01);// ; zline_use_num[5:1]
+		write_cmos_sensor(0x3846,0x48);// ; Y/X boundary pixel numbber for auto size mode
+		write_cmos_sensor(0x3f08,0x16);//
+		
+		write_cmos_sensor(0x4000,0xf1);//; our range trig en, format chg en, gan chg en, exp chg en, median en
+		
+		write_cmos_sensor(0x4001,0x04);// ; left 32 column, final BLC offset limitation enable
+		write_cmos_sensor(0x4020,0x02);// ; anchor left start H
+		write_cmos_sensor(0x4021,0x40);// ; anchor left start L
+		write_cmos_sensor(0x4022,0x03);// ; anchor left end H
+		write_cmos_sensor(0x4023,0x3f);// ; anchor left end L
+		write_cmos_sensor(0x4024,0x07);// ; anchor right start H
+		write_cmos_sensor(0x4025,0xc0);// ; anchor right start L
+		write_cmos_sensor(0x4026,0x08);// ; anchor right end H
+		write_cmos_sensor(0x4027,0xbf);// ; anchor right end L
+		write_cmos_sensor(0x402a,0x04);// ; top black line start
+		write_cmos_sensor(0x402b,0x04);//am26
+		write_cmos_sensor(0x402c,0x02);// ; bottom zero line start	
+		write_cmos_sensor(0x402d,0x02);// ; bottom zero line number
+		write_cmos_sensor(0x402e,0x08);// ; bottom black line start
+		write_cmos_sensor(0x4500,0x68);// ; ADC sync control
+		write_cmos_sensor(0x4601,0x10);// ; V FIFO control
+		write_cmos_sensor(0x4837,0x1a);// ; clock period
+		write_cmos_sensor(0x5002,0x08);// ; vario pixel off
+		write_cmos_sensor(0x5901,0x00);//
+		
+		write_cmos_sensor(0x0100,0x01);//; wake up, streaming
+	}
+	else//normal capture
+	{
+		write_cmos_sensor(0x0100,0x00);
+		
+		write_cmos_sensor(0x0302,0x1f);// ; PLL
+		write_cmos_sensor(0x030d,0x1f);// ; PLL	  ;1e
+		write_cmos_sensor(0x030f,0x04);// ; PLL
+		write_cmos_sensor(0x3018,0x72);//
+		write_cmos_sensor(0x3106,0x01);//
+		
+		//write_cmos_sensor(0x3501,0x8f);// ; expouere H
+		//write_cmos_sensor(0x3502,0xa0);// ; exposure L
+		
+		write_cmos_sensor(0x3700,0x48);// ; sensor control  AM24
+		write_cmos_sensor(0x3701,0x18);//
+		write_cmos_sensor(0x3702,0x50);//
+		write_cmos_sensor(0x3703,0x32);//
+		write_cmos_sensor(0x3704,0x28);//
+		write_cmos_sensor(0x3706,0x70);//AM24
+		write_cmos_sensor(0x3707,0x08);//
+		write_cmos_sensor(0x3708,0x48);//
+		write_cmos_sensor(0x3709,0x80);//
+		write_cmos_sensor(0x370a,0x01);//
+		write_cmos_sensor(0x370b,0x70);//AM24
+		write_cmos_sensor(0x370c,0x07);//
+		write_cmos_sensor(0x3718,0x14);//
+		write_cmos_sensor(0x3712,0x44);//
+		write_cmos_sensor(0x371e,0x31);//
+		write_cmos_sensor(0x371f,0x7f);//
+		write_cmos_sensor(0x3720,0x0a);//
+		write_cmos_sensor(0x3721,0x0a);//
+		write_cmos_sensor(0x3724,0x04);//
+		write_cmos_sensor(0x3725,0x04);//
+		write_cmos_sensor(0x3726,0x0c);//
+		write_cmos_sensor(0x3728,0x0a);//
+		write_cmos_sensor(0x3729,0x03);//
+		write_cmos_sensor(0x372a,0x06);//
+		write_cmos_sensor(0x372b,0xa6);//
+		write_cmos_sensor(0x372c,0xa6);//
+		write_cmos_sensor(0x372d,0xa6);//
+		write_cmos_sensor(0x372e,0x0c);//
+		write_cmos_sensor(0x372f,0x20);//
+		write_cmos_sensor(0x3730,0x02);//
+		write_cmos_sensor(0x3731,0x0c);//
+		write_cmos_sensor(0x3732,0x28);//
+		write_cmos_sensor(0x3736,0x30);//
+		write_cmos_sensor(0x373a,0x04);//
+		write_cmos_sensor(0x373b,0x18);//
+		write_cmos_sensor(0x373c,0x14);//
+		write_cmos_sensor(0x373e,0x06);//
+		write_cmos_sensor(0x375a,0x0c);//
+		write_cmos_sensor(0x375b,0x26);//
+		write_cmos_sensor(0x375c,0x40);//am26
+		write_cmos_sensor(0x375d,0x04);//
+		write_cmos_sensor(0x375f,0x28);//
+		write_cmos_sensor(0x3767,0x1e);//0x04
+		write_cmos_sensor(0x3769,0x20);//
+		write_cmos_sensor(0x376c,0xc0);//am26
+		write_cmos_sensor(0x376d,0xc0);//am26
+		write_cmos_sensor(0x3772,0x46);//
+		write_cmos_sensor(0x3773,0x04);//
+		write_cmos_sensor(0x3774,0x2c);//
+		write_cmos_sensor(0x3775,0x13);//
+		write_cmos_sensor(0x3776,0x10);//
+		write_cmos_sensor(0x37a0,0x88);//
+		write_cmos_sensor(0x37a1,0x7a);//
+		write_cmos_sensor(0x37a2,0x7a);//
+		write_cmos_sensor(0x37a3,0x02);//
+		write_cmos_sensor(0x37a5,0x09);//
+		write_cmos_sensor(0x37a7,0x88);//
+		write_cmos_sensor(0x37a8,0xb0);//AM24
+		write_cmos_sensor(0x37a9,0xb0);//AM24
+		write_cmos_sensor(0x37aa,0x88);//
+		write_cmos_sensor(0x37ab,0x5c);//
+		write_cmos_sensor(0x37ac,0x5c);//
+		write_cmos_sensor(0x37ad,0x55);//
+		write_cmos_sensor(0x37ae,0x19);//
+		write_cmos_sensor(0x37af,0x19);//
+		write_cmos_sensor(0x37b3,0x84);//
+		write_cmos_sensor(0x37b4,0x84);//
+		write_cmos_sensor(0x37b5,0x66);//
+
+		write_cmos_sensor(0x3808,0x0c);// ; X output size H
+		write_cmos_sensor(0x3809,0xc0);// ; X output size L (0x3809,0xc0)
+		write_cmos_sensor(0x380a,0x09);// ; Y output size H
+		write_cmos_sensor(0x380b,0x90);// ; Y output size L (0x380b,0x90)
+		
+		write_cmos_sensor(0x380c,((imgsensor_info.cap.linelength >> 8) & 0xFF));// ; HTS H //30fps
+		write_cmos_sensor(0x380d,(imgsensor_info.cap.linelength & 0xFF));// ; HTS L 
+		write_cmos_sensor(0x380e,((imgsensor_info.cap.framelength >> 8) & 0xFF));//; VTS H
+		write_cmos_sensor(0x380f,(imgsensor_info.cap.framelength & 0xFF));//; VTS L
+		
+		write_cmos_sensor(0x3813,0x02);// ; ISP Y win L
+		write_cmos_sensor(0x3814,0x01);// ; X inc odd
+		write_cmos_sensor(0x3821,0x46);// ; hsync_en_o, fst_vbin, mirror on
+		write_cmos_sensor(0x382a,0x01);// ; Y inc odd
+		write_cmos_sensor(0x382b,0x01);// ; Y inc even
+		write_cmos_sensor(0x3830,0x04);// ; ablc_use_num[5:1]
+		write_cmos_sensor(0x3836,0x01);// ; zline_use_num[5:1]
+		write_cmos_sensor(0x3846,0x48);// ; Y/X boundary pixel numbber for auto size mode
+		write_cmos_sensor(0x3f08,0x16);//
+		
+		write_cmos_sensor(0x4000,0xf1);//; our range trig en, format chg en, gan chg en, exp chg en, median en
+		
+		write_cmos_sensor(0x4001,0x04);// ; left 32 column, final BLC offset limitation enable
+		write_cmos_sensor(0x4020,0x02);// ; anchor left start H
+		write_cmos_sensor(0x4021,0x40);// ; anchor left start L
+		write_cmos_sensor(0x4022,0x03);// ; anchor left end H
+		write_cmos_sensor(0x4023,0x3f);// ; anchor left end L
+		write_cmos_sensor(0x4024,0x07);// ; anchor right start H
+		write_cmos_sensor(0x4025,0xc0);// ; anchor right start L
+		write_cmos_sensor(0x4026,0x08);// ; anchor right end H
+		write_cmos_sensor(0x4027,0xbf);// ; anchor right end L
+		write_cmos_sensor(0x402a,0x04);// ; top black line start
+		write_cmos_sensor(0x402b,0x04);//am26
+		write_cmos_sensor(0x402c,0x02);// ; bottom zero line start  
+		write_cmos_sensor(0x402d,0x02);// ; bottom zero line number
+		write_cmos_sensor(0x402e,0x08);// ; bottom black line start
+		write_cmos_sensor(0x4500,0x68);// ; ADC sync control
+		write_cmos_sensor(0x4601,0x10);// ; V FIFO control
+		write_cmos_sensor(0x4837,0x16);// ; clock period
+		write_cmos_sensor(0x5002,0x08);// ; vario pixel off
+		write_cmos_sensor(0x5901,0x00);//
+		
+		write_cmos_sensor(0x0100,0x01);//; wake up, streaming
+	    }
+}	
+	
+		
+static void normal_video_setting(kal_uint16 currefps)
+{
+	LOG_INF("Enter! currefps:%d\n",currefps);
 
 	write_cmos_sensor(0x0100,0x00);
 
-	write_cmos_sensor(0x0302,0x1f);// ; PLL
+	write_cmos_sensor(0x0302,0x1f);// ; PLL
 	write_cmos_sensor(0x030d,0x1f);// ; PLL	  ;1e
 	write_cmos_sensor(0x030f,0x04);// ; PLL
-	write_cmos_sensor(0x3018,0x72);//
-	write_cmos_sensor(0x3106,0x01);//
-
-	//write_cmos_sensor(0x3501,0x8f);//; expouere H
-	//write_cmos_sensor(0x3502,0xa0);// ; exposure L
-
-	write_cmos_sensor(0x3700,0x48);// ; sensor control AM24
-	write_cmos_sensor(0x3701,0x18);//
-	write_cmos_sensor(0x3702,0x50);//
-	write_cmos_sensor(0x3703,0x32);//
-	write_cmos_sensor(0x3704,0x28);//
-	write_cmos_sensor(0x3706,0x70);//AM24
-	write_cmos_sensor(0x3707,0x08);//
-	write_cmos_sensor(0x3708,0x48);//
-	write_cmos_sensor(0x3709,0x80);//
-	write_cmos_sensor(0x370a,0x01);//
-	write_cmos_sensor(0x370b,0x70);//AM24
-	write_cmos_sensor(0x370c,0x07);//
-	write_cmos_sensor(0x3718,0x14);//
-	write_cmos_sensor(0x3712,0x44);//
-	write_cmos_sensor(0x371e,0x31);//
-	write_cmos_sensor(0x371f,0x7f);//
-	write_cmos_sensor(0x3720,0x0a);//
-	write_cmos_sensor(0x3721,0x0a);//
-	write_cmos_sensor(0x3724,0x04);//
-	write_cmos_sensor(0x3725,0x04);//
-	write_cmos_sensor(0x3726,0x0c);//
-	write_cmos_sensor(0x3728,0x0a);//
-	write_cmos_sensor(0x3729,0x03);//
-	write_cmos_sensor(0x372a,0x06);//
-	write_cmos_sensor(0x372b,0xa6);//
-	write_cmos_sensor(0x372c,0xa6);//
-	write_cmos_sensor(0x372d,0xa6);//
-	write_cmos_sensor(0x372e,0x0c);//
-	write_cmos_sensor(0x372f,0x20);//
-	write_cmos_sensor(0x3730,0x02);//
-	write_cmos_sensor(0x3731,0x0c);//
-	write_cmos_sensor(0x3732,0x28);//
-	write_cmos_sensor(0x3736,0x30);//
-	write_cmos_sensor(0x373a,0x04);//
-	write_cmos_sensor(0x373b,0x18);//
-	write_cmos_sensor(0x373c,0x14);//
-	write_cmos_sensor(0x373e,0x06);//
-	write_cmos_sensor(0x375a,0x0c);//
-	write_cmos_sensor(0x375b,0x26);//
-	write_cmos_sensor(0x375c,0x40);// am26
-	write_cmos_sensor(0x375d,0x04);//
-	write_cmos_sensor(0x375f,0x28);//
-	write_cmos_sensor(0x3767,0x1e);//
+	write_cmos_sensor(0x3018,0x72);//
+	write_cmos_sensor(0x3106,0x01);//
+
+	//write_cmos_sensor(0x3501,0x8f);//; expouere H
+	//write_cmos_sensor(0x3502,0xa0);// ; exposure L
+
+	write_cmos_sensor(0x3700,0x48);// ; sensor control AM24
+	write_cmos_sensor(0x3701,0x18);//
+	write_cmos_sensor(0x3702,0x50);//
+	write_cmos_sensor(0x3703,0x32);//
+	write_cmos_sensor(0x3704,0x28);//
+	write_cmos_sensor(0x3706,0x70);//AM24
+	write_cmos_sensor(0x3707,0x08);//
+	write_cmos_sensor(0x3708,0x48);//
+	write_cmos_sensor(0x3709,0x80);//
+	write_cmos_sensor(0x370a,0x01);//
+	write_cmos_sensor(0x370b,0x70);//AM24
+	write_cmos_sensor(0x370c,0x07);//
+	write_cmos_sensor(0x3718,0x14);//
+	write_cmos_sensor(0x3712,0x44);//
+	write_cmos_sensor(0x371e,0x31);//
+	write_cmos_sensor(0x371f,0x7f);//
+	write_cmos_sensor(0x3720,0x0a);//
+	write_cmos_sensor(0x3721,0x0a);//
+	write_cmos_sensor(0x3724,0x04);//
+	write_cmos_sensor(0x3725,0x04);//
+	write_cmos_sensor(0x3726,0x0c);//
+	write_cmos_sensor(0x3728,0x0a);//
+	write_cmos_sensor(0x3729,0x03);//
+	write_cmos_sensor(0x372a,0x06);//
+	write_cmos_sensor(0x372b,0xa6);//
+	write_cmos_sensor(0x372c,0xa6);//
+	write_cmos_sensor(0x372d,0xa6);//
+	write_cmos_sensor(0x372e,0x0c);//
+	write_cmos_sensor(0x372f,0x20);//
+	write_cmos_sensor(0x3730,0x02);//
+	write_cmos_sensor(0x3731,0x0c);//
+	write_cmos_sensor(0x3732,0x28);//
+	write_cmos_sensor(0x3736,0x30);//
+	write_cmos_sensor(0x373a,0x04);//
+	write_cmos_sensor(0x373b,0x18);//
+	write_cmos_sensor(0x373c,0x14);//
+	write_cmos_sensor(0x373e,0x06);//
+	write_cmos_sensor(0x375a,0x0c);//
+	write_cmos_sensor(0x375b,0x26);//
+	write_cmos_sensor(0x375c,0x40);// am26
+	write_cmos_sensor(0x375d,0x04);//
+	write_cmos_sensor(0x375f,0x28);//
+	write_cmos_sensor(0x3767,0x1e);//
 	write_cmos_sensor(0x3769,0x20);//
-	write_cmos_sensor(0x376c,0xc0);// am26
-	write_cmos_sensor(0x376d,0xc0);// am26
-	write_cmos_sensor(0x3772,0x46);//
-	write_cmos_sensor(0x3773,0x04);//
-	write_cmos_sensor(0x3774,0x2c);//
-	write_cmos_sensor(0x3775,0x13);//
-	write_cmos_sensor(0x3776,0x10);//
-	write_cmos_sensor(0x37a0,0x88);//
-	write_cmos_sensor(0x37a1,0x7a);//
-	write_cmos_sensor(0x37a2,0x7a);//
+	write_cmos_sensor(0x376c,0xc0);// am26
+	write_cmos_sensor(0x376d,0xc0);// am26
+	write_cmos_sensor(0x3772,0x46);//
+	write_cmos_sensor(0x3773,0x04);//
+	write_cmos_sensor(0x3774,0x2c);//
+	write_cmos_sensor(0x3775,0x13);//
+	write_cmos_sensor(0x3776,0x10);//
+	write_cmos_sensor(0x37a0,0x88);//
+	write_cmos_sensor(0x37a1,0x7a);//
+	write_cmos_sensor(0x37a2,0x7a);//
 	write_cmos_sensor(0x37a3,0x02);//
 	write_cmos_sensor(0x37a5,0x09);//
-	write_cmos_sensor(0x37a7,0x88);//
-	write_cmos_sensor(0x37a8,0xb0);//AM24
-	write_cmos_sensor(0x37a9,0xb0);//AM24
-	write_cmos_sensor(0x37aa,0x88);//
-	write_cmos_sensor(0x37ab,0x5c);//
-	write_cmos_sensor(0x37ac,0x5c);//
-	write_cmos_sensor(0x37ad,0x55);//
-	write_cmos_sensor(0x37ae,0x19);//
-	write_cmos_sensor(0x37af,0x19);//
-	write_cmos_sensor(0x37b3,0x84);//
-	write_cmos_sensor(0x37b4,0x84);//
-	write_cmos_sensor(0x37b5,0x66);//
+	write_cmos_sensor(0x37a7,0x88);//
+	write_cmos_sensor(0x37a8,0xb0);//AM24
+	write_cmos_sensor(0x37a9,0xb0);//AM24
+	write_cmos_sensor(0x37aa,0x88);//
+	write_cmos_sensor(0x37ab,0x5c);//
+	write_cmos_sensor(0x37ac,0x5c);//
+	write_cmos_sensor(0x37ad,0x55);//
+	write_cmos_sensor(0x37ae,0x19);//
+	write_cmos_sensor(0x37af,0x19);//
+	write_cmos_sensor(0x37b3,0x84);//
+	write_cmos_sensor(0x37b4,0x84);//
+	write_cmos_sensor(0x37b5,0x66);//
 
 	write_cmos_sensor(0x3808,0x0c);// ; X output size H
-	write_cmos_sensor(0x3809,0xc0);// ; X output size L	(0x3809,0xc0)
-	write_cmos_sensor(0x380a,0x07);// ; Y output size H
-	//write_cmos_sensor(0x380b,0x30);// ; Y output size L  (0x380b,0x2c)
-	write_cmos_sensor(0x380b,0x2c);// ; Y output size L	(0x380b,0x2c)
-
-	write_cmos_sensor(0x380c,((imgsensor_info.normal_video.linelength >> 8) & 0xFF));// ; HTS H
-	write_cmos_sensor(0x380d,(imgsensor_info.normal_video.linelength & 0xFF));// ; HTS L
-	write_cmos_sensor(0x380e,((imgsensor_info.normal_video.framelength >> 8) & 0xFF));// ; VTS H
-	write_cmos_sensor(0x380f,(imgsensor_info.normal_video.framelength & 0xFF));// ; VTS L
+	write_cmos_sensor(0x3809,0xc0);// ; X output size L	(0x3809,0xc0)
+	write_cmos_sensor(0x380a,0x07);// ; Y output size H
+	//write_cmos_sensor(0x380b,0x30);// ; Y output size L  (0x380b,0x2c)
+	write_cmos_sensor(0x380b,0x2c);// ; Y output size L	(0x380b,0x2c)
+
+	write_cmos_sensor(0x380c,((imgsensor_info.normal_video.linelength >> 8) & 0xFF));// ; HTS H
+	write_cmos_sensor(0x380d,(imgsensor_info.normal_video.linelength & 0xFF));// ; HTS L
+	write_cmos_sensor(0x380e,((imgsensor_info.normal_video.framelength >> 8) & 0xFF));// ; VTS H
+	write_cmos_sensor(0x380f,(imgsensor_info.normal_video.framelength & 0xFF));// ; VTS L
 
 	write_cmos_sensor(0x3813,0x02);// ; ISP Y win L
 	write_cmos_sensor(0x3814,0x01);// ; X inc odd
@@ -1281,10 +1285,10 @@ static void normal_video_setting(kal_uint16 currefps)
 	write_cmos_sensor(0x3830,0x04);// ; ablc_use_num[5:1]
 	write_cmos_sensor(0x3836,0x01);// ; zline_use_num[5:1]
 	write_cmos_sensor(0x3846,0x48);// ; Y/X boundary pixel numbber for auto size mode
-	write_cmos_sensor(0x3f08,0x16);//
-
+	write_cmos_sensor(0x3f08,0x16);//
+
 	write_cmos_sensor(0x4000,0xf1);//; our range trig en, format chg en, gan chg en, exp chg en, median en
-
+
 	write_cmos_sensor(0x4001,0x04);// ; left 32 column, final BLC offset limitation enable
 	write_cmos_sensor(0x4020,0x02);// ; anchor left start H
 	write_cmos_sensor(0x4021,0x40);// ; anchor left start L
@@ -1296,47 +1300,47 @@ static void normal_video_setting(kal_uint16 currefps)
 	write_cmos_sensor(0x4027,0xbf);// ; anchor right end L
 	write_cmos_sensor(0x402a,0x04);// ; top black line start
 	write_cmos_sensor(0x402b,0x04);//am26
-	write_cmos_sensor(0x402c,0x02);// ; bottom zero line start
+	write_cmos_sensor(0x402c,0x02);// ; bottom zero line start
 	write_cmos_sensor(0x402d,0x02);// ; bottom zero line number
 	write_cmos_sensor(0x402e,0x08);// ; bottom black line start
 	write_cmos_sensor(0x4500,0x68);// ; ADC sync control
 	write_cmos_sensor(0x4601,0x10);// ; V FIFO control
-	
-	write_cmos_sensor(0x4837,0x16);// ; clock period
+	
+	write_cmos_sensor(0x4837,0x16);// ; clock period
 	write_cmos_sensor(0x5002,0x08);// ; vario pixel off
 	write_cmos_sensor(0x5901,0x00);//
 
 	write_cmos_sensor(0x0100,0x01);//; wake up, streaming
 }
-
+
 
 
 static void hs_video_setting()
 {
-	LOG_INF("Enter!\n");
-
-	write_cmos_sensor(0x0100,0x00);// ; software standby
-	
-	write_cmos_sensor(0x0302,0x1f);//;
-	write_cmos_sensor(0x030d,0x1f);//;
-	write_cmos_sensor(0x030f,0x09);//
-	write_cmos_sensor(0x3018,0x72);//
+	LOG_INF("Enter!\n");
+
+	write_cmos_sensor(0x0100,0x00);// ; software standby
+	
+	write_cmos_sensor(0x0302,0x1f);//;
+	write_cmos_sensor(0x030d,0x1f);//;
+	write_cmos_sensor(0x030f,0x09);//
+	write_cmos_sensor(0x3018,0x72);//
 	write_cmos_sensor(0x3106,0x01);//
 	
-	//write_cmos_sensor(0x3501,0x1e);//
-	//write_cmos_sensor(0x3502,0x70);//
+	//write_cmos_sensor(0x3501,0x1e);//
+	//write_cmos_sensor(0x3502,0x70);//
 	
-	write_cmos_sensor(0x3700,0x24);//
+	write_cmos_sensor(0x3700,0x24);//
 	write_cmos_sensor(0x3701,0x0c);//
 	write_cmos_sensor(0x3702,0x28);//
 	write_cmos_sensor(0x3703,0x19);//
 	write_cmos_sensor(0x3704,0x14);//
-	write_cmos_sensor(0x3706,0x38);//
+	write_cmos_sensor(0x3706,0x38);//
 	write_cmos_sensor(0x3707,0x04);//
 	write_cmos_sensor(0x3708,0x24);//
 	write_cmos_sensor(0x3709,0x40);//
 	write_cmos_sensor(0x370a,0x00);//
-	write_cmos_sensor(0x370b,0xb8);//
+	write_cmos_sensor(0x370b,0xb8);//
 	write_cmos_sensor(0x370c,0x04);//
 	write_cmos_sensor(0x3718,0x12);//
 	write_cmos_sensor(0x3712,0x42);//
@@ -1367,7 +1371,7 @@ static void hs_video_setting()
 	write_cmos_sensor(0x375b,0x13);//
 	write_cmos_sensor(0x375d,0x02);//
 	write_cmos_sensor(0x375f,0x14);//
-	write_cmos_sensor(0x3767,0x18);//
+	write_cmos_sensor(0x3767,0x18);//
 	write_cmos_sensor(0x3769,0x20);//
 	write_cmos_sensor(0x3772,0x23);//
 	write_cmos_sensor(0x3773,0x02);//
@@ -1392,77 +1396,77 @@ static void hs_video_setting()
 	write_cmos_sensor(0x37b4,0x42);//
 	write_cmos_sensor(0x37b5,0x33);//
 	
-	write_cmos_sensor(0x3808,0x02);////640
-	write_cmos_sensor(0x3809,0x80);//
-	write_cmos_sensor(0x380a,0x01);//480
-	write_cmos_sensor(0x380b,0xe0);//
+	write_cmos_sensor(0x3808,0x02);////640
+	write_cmos_sensor(0x3809,0x80);//
+	write_cmos_sensor(0x380a,0x01);//480
+	write_cmos_sensor(0x380b,0xe0);//
 	
-	write_cmos_sensor(0x380c,((imgsensor_info.hs_video.linelength >> 8) & 0xFF));// ; HTS H
-	write_cmos_sensor(0x380d,(imgsensor_info.hs_video.linelength & 0xFF));// ; HTS L
-	write_cmos_sensor(0x380e,((imgsensor_info.hs_video.framelength >> 8) & 0xFF));// ; VTS H
-	write_cmos_sensor(0x380f,(imgsensor_info.hs_video.framelength & 0xFF));// ; VTS L
+	write_cmos_sensor(0x380c,((imgsensor_info.hs_video.linelength >> 8) & 0xFF));// ; HTS H
+	write_cmos_sensor(0x380d,(imgsensor_info.hs_video.linelength & 0xFF));// ; HTS L
+	write_cmos_sensor(0x380e,((imgsensor_info.hs_video.framelength >> 8) & 0xFF));// ; VTS H
+	write_cmos_sensor(0x380f,(imgsensor_info.hs_video.framelength & 0xFF));// ; VTS L
 	
-	write_cmos_sensor(0x3813,0x04);//
-	write_cmos_sensor(0x3814,0x03);//
-	write_cmos_sensor(0x3821,0x6f);//
-	write_cmos_sensor(0x382a,0x05);//
-	write_cmos_sensor(0x382b,0x03);//
-	write_cmos_sensor(0x3830,0x08);//
-	write_cmos_sensor(0x3836,0x02);//
-	write_cmos_sensor(0x3846,0x88);//
-	write_cmos_sensor(0x3f08,0x0b);//
-	write_cmos_sensor(0x4000,0xf1);// 
-	write_cmos_sensor(0x4001,0x14);//
-	write_cmos_sensor(0x4020,0x01);//
-	write_cmos_sensor(0x4021,0x20);//
-	write_cmos_sensor(0x4022,0x01);//
-	write_cmos_sensor(0x4023,0x9f);//
-	write_cmos_sensor(0x4024,0x03);//
-	write_cmos_sensor(0x4025,0xe0);//
-	write_cmos_sensor(0x4026,0x04);//
-	write_cmos_sensor(0x4027,0x5f);//
-	write_cmos_sensor(0x402a,0x02);//
-	write_cmos_sensor(0x402b,0x02);//
-	write_cmos_sensor(0x402c,0x00);//
-	write_cmos_sensor(0x402d,0x00);//
-	write_cmos_sensor(0x402e,0x04);//
-	write_cmos_sensor(0x4500,0x40);//
-	write_cmos_sensor(0x4601,0x50);//
-	write_cmos_sensor(0x4837,0x15);//
-	write_cmos_sensor(0x5002,0x0c);//
-	write_cmos_sensor(0x5901,0x04);//
+	write_cmos_sensor(0x3813,0x04);//
+	write_cmos_sensor(0x3814,0x03);//
+	write_cmos_sensor(0x3821,0x6f);//
+	write_cmos_sensor(0x382a,0x05);//
+	write_cmos_sensor(0x382b,0x03);//
+	write_cmos_sensor(0x3830,0x08);//
+	write_cmos_sensor(0x3836,0x02);//
+	write_cmos_sensor(0x3846,0x88);//
+	write_cmos_sensor(0x3f08,0x0b);//
+	write_cmos_sensor(0x4000,0xf1);// 
+	write_cmos_sensor(0x4001,0x14);//
+	write_cmos_sensor(0x4020,0x01);//
+	write_cmos_sensor(0x4021,0x20);//
+	write_cmos_sensor(0x4022,0x01);//
+	write_cmos_sensor(0x4023,0x9f);//
+	write_cmos_sensor(0x4024,0x03);//
+	write_cmos_sensor(0x4025,0xe0);//
+	write_cmos_sensor(0x4026,0x04);//
+	write_cmos_sensor(0x4027,0x5f);//
+	write_cmos_sensor(0x402a,0x02);//
+	write_cmos_sensor(0x402b,0x02);//
+	write_cmos_sensor(0x402c,0x00);//
+	write_cmos_sensor(0x402d,0x00);//
+	write_cmos_sensor(0x402e,0x04);//
+	write_cmos_sensor(0x4500,0x40);//
+	write_cmos_sensor(0x4601,0x50);//
+	write_cmos_sensor(0x4837,0x15);//
+	write_cmos_sensor(0x5002,0x0c);//
+	write_cmos_sensor(0x5901,0x04);//
 	
-	write_cmos_sensor(0x0100,0x01);// ; wake up, streaming
+	write_cmos_sensor(0x0100,0x01);// ; wake up, streaming
 }
 
 
 
 static void slim_video_setting()
 {
-	LOG_INF("Enter!\n");
+	LOG_INF("Enter!\n");
 
 	write_cmos_sensor(0x0100,0x00);//; software standby
-	
-	write_cmos_sensor(0x0302,0x1f);// ; PLL
-	write_cmos_sensor(0x030d,0x1f);// ; PLL   ;1e
+	
+	write_cmos_sensor(0x0302,0x1f);// ; PLL
+	write_cmos_sensor(0x030d,0x1f);// ; PLL   ;1e
 	write_cmos_sensor(0x030f,0x09);//; PLL
-	write_cmos_sensor(0x3018,0x72);//
+	write_cmos_sensor(0x3018,0x72);//
 	write_cmos_sensor(0x3106,0x01);//
 	
 	//write_cmos_sensor(0x3501,0x28);//; expouere H
 	//write_cmos_sensor(0x3502,0x90);//; exposure L
 	
-	write_cmos_sensor(0x3700,0x24);//; sensor control  AM24
+	write_cmos_sensor(0x3700,0x24);//; sensor control  AM24
 	write_cmos_sensor(0x3701,0x0c);//
 	write_cmos_sensor(0x3702,0x28);//
 	write_cmos_sensor(0x3703,0x19);//
 	write_cmos_sensor(0x3704,0x14);//
-	write_cmos_sensor(0x3706,0x38);//AM24
+	write_cmos_sensor(0x3706,0x38);//AM24
 	write_cmos_sensor(0x3707,0x04);//
 	write_cmos_sensor(0x3708,0x24);//
 	write_cmos_sensor(0x3709,0x40);//
 	write_cmos_sensor(0x370a,0x00);//
-	write_cmos_sensor(0x370b,0xb8);//AM24
+	write_cmos_sensor(0x370b,0xb8);//AM24
 	write_cmos_sensor(0x370c,0x04);//
 	write_cmos_sensor(0x3718,0x12);//
 	write_cmos_sensor(0x3712,0x42);//
@@ -1491,7 +1495,7 @@ static void slim_video_setting()
 	write_cmos_sensor(0x373e,0x03);//
 	write_cmos_sensor(0x375a,0x06);//
 	write_cmos_sensor(0x375b,0x13);//
-	write_cmos_sensor(0x375c,0x40);// am26
+	write_cmos_sensor(0x375c,0x40);// am26
 	write_cmos_sensor(0x375d,0x02);//
 	write_cmos_sensor(0x375f,0x14);//
 	write_cmos_sensor(0x3767,0x1c);//am26
@@ -1509,8 +1513,8 @@ static void slim_video_setting()
 	write_cmos_sensor(0x37a3,0x01);//
 	write_cmos_sensor(0x37a5,0x08);//
 	write_cmos_sensor(0x37a7,0x44);//
-	write_cmos_sensor(0x37a8,0x58);//AM24
-	write_cmos_sensor(0x37a9,0x58);//AM24
+	write_cmos_sensor(0x37a8,0x58);//AM24
+	write_cmos_sensor(0x37a9,0x58);//AM24
 	write_cmos_sensor(0x37aa,0x44);//
 	write_cmos_sensor(0x37ab,0x2e);//
 	write_cmos_sensor(0x37ac,0x2e);//
@@ -1521,16 +1525,16 @@ static void slim_video_setting()
 	write_cmos_sensor(0x37b4,0x42);//
 	write_cmos_sensor(0x37b5,0x33);//
 
-	write_cmos_sensor(0x3808,0x06);//; X output size H	active 
+	write_cmos_sensor(0x3808,0x06);//; X output size H	active 
 	write_cmos_sensor(0x3809,0x60);//; X output size L	(0x3809,0x60)
-	write_cmos_sensor(0x380a,0x04);//; Y output size H	active 
+	write_cmos_sensor(0x380a,0x04);//; Y output size H	active 
 	write_cmos_sensor(0x380b,0xc8);//; Y output size L (0x380b,0xc8)
 
-	write_cmos_sensor(0x380c,((imgsensor_info.slim_video.linelength >> 8) & 0xFF));// ; HTS H
-	write_cmos_sensor(0x380d,(imgsensor_info.slim_video.linelength & 0xFF));// ; HTS L
-	write_cmos_sensor(0x380e,((imgsensor_info.slim_video.framelength >> 8) & 0xFF));// ; VTS H
-	write_cmos_sensor(0x380f,(imgsensor_info.slim_video.framelength & 0xFF));// ; VTS L
-
+	write_cmos_sensor(0x380c,((imgsensor_info.slim_video.linelength >> 8) & 0xFF));// ; HTS H
+	write_cmos_sensor(0x380d,(imgsensor_info.slim_video.linelength & 0xFF));// ; HTS L
+	write_cmos_sensor(0x380e,((imgsensor_info.slim_video.framelength >> 8) & 0xFF));// ; VTS H
+	write_cmos_sensor(0x380f,(imgsensor_info.slim_video.framelength & 0xFF));// ; VTS L
+
 	write_cmos_sensor(0x3813,0x04);//; ISP Y win L
 	write_cmos_sensor(0x3814,0x03);//; X inc odd
 	write_cmos_sensor(0x3821,0x67);//; hsync_en_o, fst_vbin, mirror on
@@ -1553,20 +1557,20 @@ static void slim_video_setting()
 	write_cmos_sensor(0x4026,0x04);//; anchor right end H
 	write_cmos_sensor(0x4027,0x5f);//; anchor right end L
 	write_cmos_sensor(0x402a,0x04);//; top black line start
-	write_cmos_sensor(0x402b,0x04);//am26
+	write_cmos_sensor(0x402b,0x04);//am26
 	write_cmos_sensor(0x402c,0x02);//; bottom zero line start
 	write_cmos_sensor(0x402d,0x02);//; bottom zero line number
 	write_cmos_sensor(0x402e,0x08);//; bottom black line start
 	write_cmos_sensor(0x4500,0x40);//; ADC sync control
 	write_cmos_sensor(0x4601,0x74);//; V FIFO control
-	
-	write_cmos_sensor(0x4837,0x16);// ; clock period
-	
+	
+	write_cmos_sensor(0x4837,0x16);// ; clock period
+	
 	write_cmos_sensor(0x5002,0x08);//; vario pixel off
 	write_cmos_sensor(0x5901,0x00);//
-
+
 	write_cmos_sensor(0x0100,0x01);//; wake up, streaming
-
+
 }
 
 /*************************************************************************
@@ -1604,7 +1608,7 @@ static kal_uint32 get_imgsensor_id(UINT32 *sensor_id)
 				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);	  
 				return ERROR_NONE;
 			}	
-			LOG_INF("Read sensor id fail, write id: 0x%x, id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
+			LOG_INF("Read sensor id fail, write id: 0x%x, id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
 			retry--;
 		} while(retry > 0);
 		
@@ -1641,8 +1645,8 @@ static kal_uint32 open(void)
 	kal_uint8 i = 0;
 	kal_uint8 retry = 2;
 	kal_uint16 sensor_id = 0; 
-	LOG_INF("PLATFORM:MT6595,MIPI 4LANE\n");
-	LOG_INF("preview/normal video/capture 30fps\n");
+	LOG_INF("PLATFORM:MT6595,MIPI 4LANE\n");
+	LOG_INF("preview/normal video/capture 30fps\n");
 	LOG_INF("...\n");
 
 	
@@ -1659,7 +1663,7 @@ static kal_uint32 open(void)
 				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);	  
 				break;
 			}	
-			LOG_INF("Read sensor id fail, write id: 0x%x, id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
+			LOG_INF("Read sensor id fail, write id: 0x%x, id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
 			retry--;
 		} while(retry > 0);
 		
@@ -1690,15 +1694,6 @@ static kal_uint32 open(void)
 	imgsensor.test_pattern = KAL_FALSE;
 	spin_unlock(&imgsensor_drv_lock);
 
-#ifdef CONFIG_HCT_AF_POWER_ON_NOISE
-         //AF_VCC
-        if(TRUE != hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,"ov8865_sensor"))
-        {
-             LOG_INF("s5k3h7_sensor af poweron failed: \n");
-        }
-    
-                mdelay(5);
-#endif
 	return ERROR_NONE;
 }	/*	open  */
 
@@ -1723,13 +1718,7 @@ static kal_uint32 open(void)
 static kal_uint32 close(void)
 {
 	LOG_INF("E\n");
-#ifdef CONFIG_HCT_AF_POWER_ON_NOISE
-        if(TRUE != hwPowerDown(CAMERA_POWER_VCAM_AF, "ov8865_sensor"))
-        {
-             LOG_INF("down s5k3h7_sensor af powerdown failed: \n");
-        }
-        
-#endif
+
 	/*No Need to implement this function*/ 
 	
 	return ERROR_NONE;
@@ -1768,7 +1757,7 @@ static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 	imgsensor.autoflicker_en = KAL_FALSE;
 	spin_unlock(&imgsensor_drv_lock);
 	preview_setting();
-
+    set_mirror_flip(imgsensor.mirror);
 	return ERROR_NONE;
 }	/*	preview   */
 
@@ -1793,7 +1782,7 @@ static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 	LOG_INF("E\n");
 	spin_lock(&imgsensor_drv_lock);
 	imgsensor.sensor_mode = IMGSENSOR_MODE_CAPTURE;
-	if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {//PIP capture: 24fps for less than 13M, 20fps for 16M,15fps for 20M
+	if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {//PIP capture: 24fps for less than 13M, 20fps for 16M,15fps for 20M
 		imgsensor.pclk = imgsensor_info.cap1.pclk;
 		imgsensor.line_length = imgsensor_info.cap1.linelength;
 		imgsensor.frame_length = imgsensor_info.cap1.framelength;  
@@ -1801,7 +1790,7 @@ static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 		imgsensor.autoflicker_en = KAL_FALSE;
 	} else {
 		if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
-			LOG_INF("Warning: current_fps %d fps is not support, so use cap's setting: %d fps!\n",imgsensor.current_fps,imgsensor_info.cap.max_framerate/10);
+			LOG_INF("Warning: current_fps %d fps is not support, so use cap's setting: %d fps!\n",imgsensor.current_fps,imgsensor_info.cap.max_framerate/10);
 		
 		imgsensor.pclk = imgsensor_info.cap.pclk;
 		imgsensor.line_length = imgsensor_info.cap.linelength;
@@ -1816,10 +1805,10 @@ static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 	if(imgsensor.test_pattern == KAL_TRUE)
 	{
 		write_cmos_sensor(0x5E00,0x80);
-		mdelay(40);
+		mdelay(40);
 		
 	}
-
+    set_mirror_flip(imgsensor.mirror);
 	return ERROR_NONE;
 }	/* capture() */
 static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
@@ -1837,7 +1826,7 @@ static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 	imgsensor.autoflicker_en = KAL_FALSE;
 	spin_unlock(&imgsensor_drv_lock);
 	normal_video_setting(imgsensor.current_fps);
-	
+	set_mirror_flip(imgsensor.mirror);
 	return ERROR_NONE;
 }	/*	normal_video   */
 
@@ -1859,14 +1848,14 @@ static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 	imgsensor.autoflicker_en = KAL_FALSE;
 	spin_unlock(&imgsensor_drv_lock);
 	hs_video_setting();
-	
+	set_mirror_flip(imgsensor.mirror);
 	return ERROR_NONE;
 }	/*	hs_video   */
 
 static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
 {
-	LOG_INF("E \n");
+	LOG_INF("E \n");
 	
 	spin_lock(&imgsensor_drv_lock);
 	imgsensor.sensor_mode = IMGSENSOR_MODE_SLIM_VIDEO;
@@ -1880,7 +1869,7 @@ static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 	imgsensor.autoflicker_en = KAL_FALSE;
 	spin_unlock(&imgsensor_drv_lock);
 	slim_video_setting();
-	
+	set_mirror_flip(imgsensor.mirror);
 	return ERROR_NONE;
 }	/*	slim_video	 */
 
@@ -2087,7 +2076,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
 			imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
 			imgsensor.min_frame_length = imgsensor.frame_length;
 			spin_unlock(&imgsensor_drv_lock);
-			//set_dummy();			
+			//set_dummy();			
 			break;			
 		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
 			if(framerate == 0)
@@ -2098,27 +2087,27 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
 			imgsensor.frame_length = imgsensor_info.normal_video.framelength + imgsensor.dummy_line;
 			imgsensor.min_frame_length = imgsensor.frame_length;
 			spin_unlock(&imgsensor_drv_lock);
-			//set_dummy();			
+			//set_dummy();			
 			break;
 		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:		
-        	  if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {
-                frame_length = imgsensor_info.cap1.pclk / framerate * 10 / imgsensor_info.cap1.linelength;
-                spin_lock(&imgsensor_drv_lock);
-		            imgsensor.dummy_line = (frame_length > imgsensor_info.cap1.framelength) ? (frame_length - imgsensor_info.cap1.framelength) : 0;
-		            imgsensor.frame_length = imgsensor_info.cap1.framelength + imgsensor.dummy_line;
-		            imgsensor.min_frame_length = imgsensor.frame_length;
-		            spin_unlock(&imgsensor_drv_lock);
-            } else {
-        		    if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
-                    LOG_INF("Warning: current_fps %d fps is not support, so use cap's setting: %d fps!\n",framerate,imgsensor_info.cap.max_framerate/10);
-                frame_length = imgsensor_info.cap.pclk / framerate * 10 / imgsensor_info.cap.linelength;
-                spin_lock(&imgsensor_drv_lock);
-		            imgsensor.dummy_line = (frame_length > imgsensor_info.cap.framelength) ? (frame_length - imgsensor_info.cap.framelength) : 0;
-		            imgsensor.frame_length = imgsensor_info.cap.framelength + imgsensor.dummy_line;
-		            imgsensor.min_frame_length = imgsensor.frame_length;
-		            spin_unlock(&imgsensor_drv_lock);
-            }
-			//set_dummy();			
+        	  if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {
+                frame_length = imgsensor_info.cap1.pclk / framerate * 10 / imgsensor_info.cap1.linelength;
+                spin_lock(&imgsensor_drv_lock);
+		            imgsensor.dummy_line = (frame_length > imgsensor_info.cap1.framelength) ? (frame_length - imgsensor_info.cap1.framelength) : 0;
+		            imgsensor.frame_length = imgsensor_info.cap1.framelength + imgsensor.dummy_line;
+		            imgsensor.min_frame_length = imgsensor.frame_length;
+		            spin_unlock(&imgsensor_drv_lock);
+            } else {
+        		    if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
+                    LOG_INF("Warning: current_fps %d fps is not support, so use cap's setting: %d fps!\n",framerate,imgsensor_info.cap.max_framerate/10);
+                frame_length = imgsensor_info.cap.pclk / framerate * 10 / imgsensor_info.cap.linelength;
+                spin_lock(&imgsensor_drv_lock);
+		            imgsensor.dummy_line = (frame_length > imgsensor_info.cap.framelength) ? (frame_length - imgsensor_info.cap.framelength) : 0;
+		            imgsensor.frame_length = imgsensor_info.cap.framelength + imgsensor.dummy_line;
+		            imgsensor.min_frame_length = imgsensor.frame_length;
+		            spin_unlock(&imgsensor_drv_lock);
+            }
+			//set_dummy();			
 			break;	
 		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
 			frame_length = imgsensor_info.hs_video.pclk / framerate * 10 / imgsensor_info.hs_video.linelength;
@@ -2127,7 +2116,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
 			imgsensor.frame_length = imgsensor_info.hs_video.framelength + imgsensor.dummy_line;
 			imgsensor.min_frame_length = imgsensor.frame_length;
 			spin_unlock(&imgsensor_drv_lock);
-			//set_dummy();			
+			//set_dummy();			
 			break;
 		case MSDK_SCENARIO_ID_SLIM_VIDEO:
 			frame_length = imgsensor_info.slim_video.pclk / framerate * 10 / imgsensor_info.slim_video.linelength;
@@ -2136,7 +2125,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
 			imgsensor.frame_length = imgsensor_info.slim_video.framelength + imgsensor.dummy_line;
 			imgsensor.min_frame_length = imgsensor.frame_length;
 			spin_unlock(&imgsensor_drv_lock);
-			//set_dummy();	
+			//set_dummy();	
 			break;		
 		default:  //coding with  preview scenario by default
 			frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
@@ -2145,7 +2134,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
 			imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
 			imgsensor.min_frame_length = imgsensor.frame_length;
 			spin_unlock(&imgsensor_drv_lock);
-			//set_dummy();	
+			//set_dummy();	
 			LOG_INF("error scenario_id = %d, we use preview scenario \n", scenario_id);
 			break;
 	}	
@@ -2193,14 +2182,14 @@ static kal_uint32 set_test_pattern_mode(kal_bool enable)
     {
 		write_cmos_sensor(0x5000,0x16);// ; LENC off, MWB on, BPC on, WPC on
 		write_cmos_sensor(0x5E00,0x80);
-		mdelay(40);
+		mdelay(40);
 		
     }
 	else
 	{
 		write_cmos_sensor(0x5000,0x96);// ; LENC on, MWB on, BPC on, WPC on
 		write_cmos_sensor(0x5E00,0x00);
-		mdelay(40);
+		mdelay(40);
 	}
 
 	return ERROR_NONE;
@@ -2278,7 +2267,7 @@ static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
             *feature_para_len=4;
             break;
         case SENSOR_FEATURE_SET_FRAMERATE:
-            LOG_INF("current fps :%d\n", (UINT32)*feature_data);
+            LOG_INF("current fps :%d\n", (UINT32)*feature_data);
             spin_lock(&imgsensor_drv_lock);
             imgsensor.current_fps = *feature_data;
             spin_unlock(&imgsensor_drv_lock);
@@ -2290,7 +2279,7 @@ static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
             spin_unlock(&imgsensor_drv_lock);
             break;
         case SENSOR_FEATURE_GET_CROP_INFO:
-            LOG_INF("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n", (UINT32)*feature_data);
+            LOG_INF("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n", (UINT32)*feature_data);
 
             wininfo = (SENSOR_WINSIZE_INFO_STRUCT *)(uintptr_t)(*(feature_data+1));
 
@@ -2312,9 +2301,9 @@ static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
                     memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[0],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
                     break;
             }
-        case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
-            LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",(UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
-            ihdr_write_shutter_gain((UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
+        case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
+            LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",(UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
+            ihdr_write_shutter_gain((UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
             break;
         default:
             break;
@@ -2322,7 +2311,7 @@ static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
 
     return ERROR_NONE;
 }    /*    feature_control()  */
-
+
 
 static SENSOR_FUNCTION_STRUCT sensor_func = {
 	open,
@@ -2339,4 +2328,4 @@ UINT32 OV8865_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
 	if (pfFunc!=NULL)
 		*pfFunc=&sensor_func;
 	return ERROR_NONE;
-}	/*	OV8865_MIPI_RAW_SensorInit	*/
+}	/*	OV8865_MIPI_RAW_SensorInit	*/
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/ov9760_mipi_raw/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6735m/ov9760_mipi_raw/Makefile
old mode 100644
new mode 100755
index 641b063..75ef8c9
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/ov9760_mipi_raw/Makefile
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/ov9760_mipi_raw/Makefile
@@ -1,4 +1,4 @@
 include $(srctree)/drivers/misc/mediatek/Makefile.custom
-obj-y += ov9760mipiraw_Sensor.o
 
+obj-y += ov9760mipiraw_Sensor.o
 
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/ov9760_mipi_raw/ov9760mipiraw_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/ov9760_mipi_raw/ov9760mipiraw_Sensor.c
old mode 100644
new mode 100755
index ae829a4..fe076a0
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/ov9760_mipi_raw/ov9760mipiraw_Sensor.c
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/ov9760_mipi_raw/ov9760mipiraw_Sensor.c
@@ -26,7 +26,7 @@
 #include <linux/uaccess.h>
 #include <linux/fs.h>
 #include <asm/atomic.h>
-#include <asm/system.h>
+//#include <asm/system.h>
 #include <linux/xlog.h>
 
 #include "kd_camera_hw.h"
@@ -42,7 +42,7 @@
 #define LOG_1 LOG_INF("OV9760,MIPI 1LANE\n")
 #define LOG_2 LOG_INF("preview 1470*1100@30fps,256Mbps/lane\n")
 /****************************   Modify end    *******************************************/
-#define LOG_INF(format, args...)	xlog_printk(ANDROID_LOG_INFO   , PFX, "[%s] " format, __FUNCTION__, ##args)
+#define LOG_INF(format, args...)	pr_debug(PFX "[%s] " format, __FUNCTION__, ##args)
 
 static DEFINE_SPINLOCK(imgsensor_drv_lock);
 static kal_uint8  test_pattern_flag=0;
@@ -50,10 +50,9 @@ static kal_uint8  test_pattern_flag=0;
 #define MIPI_SETTLEDELAY_AUTO     0
 #define MIPI_SETTLEDELAY_MANNUAL  1
 
-#define BIRD_OV9760_HV_MIRROR
 
 static imgsensor_info_struct imgsensor_info = { 
-	.sensor_id = OV9760MIPI_SENSOR_ID,
+	.sensor_id = OV9760MIPI_SENSOR_ID,//OV9760MIPI_SENSOR_ID
 	
 	.checksum_value = 0x1ec5153d,
 	
@@ -145,11 +144,7 @@ static imgsensor_info_struct imgsensor_info = {
 	.sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,//sensor_interface_type
     .mipi_sensor_type = MIPI_OPHY_NCSI2, //0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2
     .mipi_settle_delay_mode = MIPI_SETTLEDELAY_AUTO,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
-#if defined(BIRD_OV9760_HV_MIRROR) 
 	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_B,//sensor output first pixel color
-#else	
-	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_R,
-#endif	
 	.mclk = 24,//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
 	.mipi_lane_num = SENSOR_MIPI_1_LANE,//mipi lane num
 	.i2c_addr_table = {0x6c, 0x20, 0xff},//record sensor support all write id addr, only supprt 4must end with 0xff
@@ -945,7 +940,7 @@ static void normal_video_setting(kal_uint16 currefps)
 static void hs_video_setting()
 {
 	write_cmos_sensor(0x0103, 0x01); //;S/W reset
-	//Sleep(10); 									//;insert 10ms delay here
+	mdelay(10); 									//;insert 10ms delay here
 	write_cmos_sensor(0x0340, 0x04); //;VTS
 	write_cmos_sensor(0x0341, 0x7C); //";VTS, 03/05/2012"
 	write_cmos_sensor(0x0342, 0x06); //";HTS, 03/05/2012"  0x06
@@ -1109,6 +1104,7 @@ static kal_uint32 get_imgsensor_id(UINT32 *sensor_id)
 		spin_unlock(&imgsensor_drv_lock);
 		do {
             *sensor_id = return_sensor_id();
+		printk("**************sensor_id=%x\n",*sensor_id);
 			if (*sensor_id == imgsensor_info.sensor_id) {				
 				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);	  
 				return ERROR_NONE;
@@ -1258,10 +1254,10 @@ static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 	imgsensor.autoflicker_en = KAL_FALSE;
 	spin_unlock(&imgsensor_drv_lock);
 	preview_setting();
-#if defined(BIRD_OV9760_HV_MIRROR)   
-	set_mirror_flip(IMAGE_H_MIRROR);
+#if !defined(VANZO_IMGSENSOR_OV9760_ROTATION) 
+	set_mirror_flip(IMAGE_HV_MIRROR);
 #else	
-	set_mirror_flip(IMAGE_NORMAL);
+	set_mirror_flip(IMAGE_V_MIRROR);
 #endif
 	return ERROR_NONE;
 }	/*	preview   */
@@ -1313,10 +1309,10 @@ static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 		spin_unlock(&imgsensor_drv_lock);
 	}
 
-#if defined(BIRD_OV9760_HV_MIRROR)   
-		set_mirror_flip(IMAGE_H_MIRROR);
+#if !defined(VANZO_IMGSENSOR_OV9760_ROTATION) 
+		set_mirror_flip(IMAGE_HV_MIRROR);
 #else	
-		set_mirror_flip(IMAGE_NORMAL);
+		set_mirror_flip(IMAGE_V_MIRROR);
 #endif
     return ERROR_NONE;
 }    /* capture() */
@@ -1335,11 +1331,7 @@ static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 	imgsensor.autoflicker_en = KAL_FALSE;
 	spin_unlock(&imgsensor_drv_lock);
 	normal_video_setting(imgsensor.current_fps);
-#if defined(BIRD_OV9760_HV_MIRROR)   
-		set_mirror_flip(IMAGE_H_MIRROR);
-#else	
-		set_mirror_flip(IMAGE_NORMAL);
-#endif
+	set_mirror_flip(IMAGE_V_MIRROR);
 	
 	return ERROR_NONE;
 }	/*	normal_video   */
@@ -1362,11 +1354,7 @@ static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 	imgsensor.autoflicker_en = KAL_FALSE;
 	spin_unlock(&imgsensor_drv_lock);
 	hs_video_setting();
-#if defined(BIRD_OV9760_HV_MIRROR)   
-		set_mirror_flip(IMAGE_H_MIRROR);
-#else	
-		set_mirror_flip(IMAGE_NORMAL);
-#endif
+	set_mirror_flip(IMAGE_V_MIRROR);
 	return ERROR_NONE;
 }	/*	hs_video   */
 
@@ -1389,11 +1377,7 @@ static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 	spin_unlock(&imgsensor_drv_lock);
 	slim_video_setting();
 
-#if defined(BIRD_OV9760_HV_MIRROR)   
-		set_mirror_flip(IMAGE_H_MIRROR);
-#else	
-		set_mirror_flip(IMAGE_NORMAL);
-#endif
+	set_mirror_flip(IMAGE_V_MIRROR);
 
 	
 	return ERROR_NONE;
@@ -1703,7 +1687,8 @@ static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
 	UINT16 *feature_data_16=(UINT16 *) feature_para;
 	UINT32 *feature_return_para_32=(UINT32 *) feature_para;
 	UINT32 *feature_data_32=(UINT32 *) feature_para;
-    unsigned long long *feature_data=(unsigned long long *) feature_para;
+	unsigned long long *feature_data=(unsigned long long *) feature_para;
+    unsigned long long *feature_return_para=(unsigned long long *) feature_para;
 
 	SENSOR_WINSIZE_INFO_STRUCT *wininfo;	
 	MSDK_SENSOR_REG_INFO_STRUCT *sensor_reg_data=(MSDK_SENSOR_REG_INFO_STRUCT *) feature_para;
@@ -1715,19 +1700,19 @@ static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
 			*feature_return_para_16 = imgsensor.frame_length;
 			*feature_para_len=4;
 			break;
-		case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:
-            LOG_INF("feature_Control imgsensor.pclk = %d,imgsensor.current_fps = %d\n", imgsensor.pclk,imgsensor.current_fps);
+		case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:	 
+			LOG_INF("feature_Control imgsensor.pclk = %d,imgsensor.current_fps = %d\n", imgsensor.pclk,imgsensor.current_fps);
 			*feature_return_para_32 = imgsensor.pclk;
 			*feature_para_len=4;
-			break;
+			break;		   
 		case SENSOR_FEATURE_SET_ESHUTTER:
-            set_shutter(*feature_data);
+			set_shutter(*feature_data);
 			break;
 		case SENSOR_FEATURE_SET_NIGHTMODE:
-            night_mode((BOOL) *feature_data);
+			night_mode((BOOL) *feature_data);
 			break;
-		case SENSOR_FEATURE_SET_GAIN:
-            set_gain((UINT16) *feature_data);
+		case SENSOR_FEATURE_SET_GAIN:		
+			set_gain((UINT16) *feature_data);
 			break;
 		case SENSOR_FEATURE_SET_FLASHLIGHT:
 			break;
@@ -1746,43 +1731,43 @@ static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
 			*feature_para_len=4;
 			break;
 		case SENSOR_FEATURE_SET_VIDEO_MODE:
-            set_video_mode(*feature_data);
-			break;
+			set_video_mode(*feature_data);
+			break; 
 		case SENSOR_FEATURE_CHECK_SENSOR_ID:
-			get_imgsensor_id(feature_return_para_32);
-			break;
+			get_imgsensor_id(feature_return_para_32); 
+			break; 
 		case SENSOR_FEATURE_SET_AUTO_FLICKER_MODE:
 			set_auto_flicker_mode((BOOL)*feature_data_16,*(feature_data_16+1));
 			break;
 		case SENSOR_FEATURE_SET_MAX_FRAME_RATE_BY_SCENARIO:
-            set_max_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data, *(feature_data+1));
+			set_max_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data, *(feature_data+1));
 			break;
 		case SENSOR_FEATURE_GET_DEFAULT_FRAME_RATE_BY_SCENARIO:
-            get_default_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*(feature_data), (MUINT32 *)(uintptr_t)(*(feature_data+1)));
+			get_default_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data, (MUINT32 *)(uintptr_t)(*(feature_data+1)));
 			break;
 		case SENSOR_FEATURE_SET_TEST_PATTERN:
-            set_test_pattern_mode((BOOL)*feature_data);
+			set_test_pattern_mode((BOOL)*feature_data);
 			break;
-		case SENSOR_FEATURE_GET_TEST_PATTERN_CHECKSUM_VALUE: //for factory mode auto testing
+		case SENSOR_FEATURE_GET_TEST_PATTERN_CHECKSUM_VALUE: //for factory mode auto testing			 
 			*feature_return_para_32 = imgsensor_info.checksum_value;
-			*feature_para_len=4;
-			break;
+			*feature_para_len=4;							 
+			break;				
 		case SENSOR_FEATURE_SET_FRAMERATE:
-            LOG_INF("current fps :%d\n", (UINT32)*feature_data);
+			LOG_INF("current fps :%d\n",  (UINT32)*feature_data);
 			spin_lock(&imgsensor_drv_lock);
-            imgsensor.current_fps = *feature_data;
-			spin_unlock(&imgsensor_drv_lock);
+			imgsensor.current_fps = *feature_data;
+			spin_unlock(&imgsensor_drv_lock);		
 			break;
 		case SENSOR_FEATURE_SET_HDR:
-            LOG_INF("ihdr enable :%d\n", (BOOL)*feature_data);
+			LOG_INF("ihdr enable :%d\n", (BOOL)*feature_data);
 			spin_lock(&imgsensor_drv_lock);
-			imgsensor.ihdr_en = *feature_data;
-			spin_unlock(&imgsensor_drv_lock);
+			imgsensor.ihdr_en = (bool)*feature_data;
+			spin_unlock(&imgsensor_drv_lock);		
 			break;
 		case SENSOR_FEATURE_GET_CROP_INFO:
-            LOG_INF("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n", (UINT32)*feature_data);
-            wininfo = (SENSOR_WINSIZE_INFO_STRUCT *)(uintptr_t)(*(feature_data+1));
-
+			LOG_INF("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n", (UINT32)*feature_data);
+			wininfo = (SENSOR_WINSIZE_INFO_STRUCT *)(uintptr_t)(*(feature_data+1));
+		
 			switch (*feature_data_32) {
 				case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
 					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[1],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
@@ -1801,9 +1786,11 @@ static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
 					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[0],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
 					break;
 			}
+            break;
 		case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
-            LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",(UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
-            ihdr_write_shutter_gain((UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
+			LOG_INF("SENSOR_SET_SENSOR_IHDR is no support");
+			//LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",(UINT16)*feature_data_32,(UINT16)*(feature_data_32+1),(UINT16)*(feature_data_32+2)); 
+			//ihdr_write_shutter_gain((UINT16)*feature_data_32,(UINT16)*(feature_data_32+1),(UINT16)*(feature_data_32+2));	
 			break;
 		default:
 			break;
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/ov9760_mipi_raw/ov9760mipiraw_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/ov9760_mipi_raw/ov9760mipiraw_Sensor.h
old mode 100644
new mode 100755
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k3h5xa_mipi_raw/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k3h5xa_mipi_raw/Makefile
new file mode 100755
index 0000000..38b5488
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k3h5xa_mipi_raw/Makefile
@@ -0,0 +1,3 @@
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+obj-y += s5k3h5xamipiraw_Sensor.o
+
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k3h5xa_mipi_raw/s5k3h5xamipiraw_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k3h5xa_mipi_raw/s5k3h5xamipiraw_Sensor.c
new file mode 100755
index 0000000..e984f81
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k3h5xa_mipi_raw/s5k3h5xamipiraw_Sensor.c
@@ -0,0 +1,1672 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *	 S5K3H5XAmipi_Sensor.c
+ *
+ * Project:
+ * --------
+ *	 ALPS
+ *
+ * Description:
+ * ------------
+ *	 Source code of Sensor driver
+ *
+ *
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *============================================================================
+ ****************************************************************************/
+
+#include <linux/videodev2.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <asm/atomic.h>
+//#include <asm/system.h>
+#include <linux/xlog.h>
+
+#include "kd_camera_hw.h"
+#include "kd_imgsensor.h"
+#include "kd_imgsensor_define.h"
+#include "kd_imgsensor_errcode.h"
+
+#include "s5k3h5xamipiraw_Sensor.h"
+
+#define PFX "S5K3H5XA_camera_sensor"
+#define LOG_INF(format, args...)	xlog_printk(ANDROID_LOG_INFO   , PFX, "[%s] " format, __FUNCTION__, ##args)
+extern int iReadReg(u16 a_u2Addr , u8 * a_puBuff , u16 i2cId);//add by hhl
+extern int iWriteReg(u16 a_u2Addr , u32 a_u4Data , u32 a_u4Bytes , u16 i2cId);//add by hhl
+//#define write_cmos_sensor(addr, para) iWriteReg((u16) addr , (u32) para , 1, imgsensor.i2c_write_id)//add by hhl
+static DEFINE_SPINLOCK(imgsensor_drv_lock);
+
+
+static imgsensor_info_struct imgsensor_info = { 
+	.sensor_id = S5K3H5XA_SENSOR_ID,
+	
+	.checksum_value = 0x82256eb5,
+	
+	.pre = {
+		.pclk = 280000000,
+		.linelength = 3688,
+		.framelength = 2530,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 1600,		//record different mode's width of grabwindow
+		.grabwindow_height = 1200,		//record different mode's height of grabwindow
+		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
+		.mipi_data_lp2hs_settle_dc = 85,
+		/*	 following for GetDefaultFramerateByScenario()	*/
+		.max_framerate = 300,	
+	},
+	.cap = {
+		.pclk = 280000000,
+		.linelength = 3688,
+		.framelength = 2530,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 3264,
+		.grabwindow_height = 2448,
+		.mipi_data_lp2hs_settle_dc = 85,
+		.max_framerate = 300,
+	},
+	.cap1 = {
+		.pclk = 280000000,
+		.linelength = 7376,
+		.framelength = 2530,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 3264,
+		.grabwindow_height = 2448,
+		.mipi_data_lp2hs_settle_dc = 85,
+		.max_framerate = 150,
+	},
+	.normal_video = {
+		.pclk = 280000000,
+		.linelength = 3688,
+		.framelength = 2530,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 3264,
+		.grabwindow_height = 2448,
+		.mipi_data_lp2hs_settle_dc = 85,
+		.max_framerate = 300,
+	},
+	.hs_video = {
+		.pclk = 280000000,
+		.linelength = 3688,
+		.framelength = 632,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 800,
+		.grabwindow_height = 600,
+		.mipi_data_lp2hs_settle_dc = 85,
+		.max_framerate = 1200,
+	},
+	.slim_video = {
+		.pclk = 280000000,
+		.linelength = 3688,
+		.framelength = 2530,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 1280,
+		.grabwindow_height = 720,
+		.mipi_data_lp2hs_settle_dc = 85,
+		.max_framerate = 300,
+	},
+	.margin = 16,
+	.min_shutter = 3,
+	.max_frame_length = 0xffff,
+	.ae_shut_delay_frame = 0,
+	.ae_sensor_gain_delay_frame = 0,
+	.ae_ispGain_delay_frame = 2,
+	.ihdr_support = 0,	  //1, support; 0,not support
+	.ihdr_le_firstline = 0,  //1,le first ; 0, se first
+	.sensor_mode_num = 5,	  //support sensor mode num
+	
+	.cap_delay_frame = 3, 
+	.pre_delay_frame = 3, 
+	.video_delay_frame = 3,
+	.hs_video_delay_frame = 3,
+	.slim_video_delay_frame = 3,
+	
+	.isp_driving_current = ISP_DRIVING_8MA,
+	.sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,
+    .mipi_sensor_type = MIPI_OPHY_NCSI2, //0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2
+    .mipi_settle_delay_mode = MIPI_SETTLEDELAY_AUTO,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
+	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_Gr,
+	.mclk = 24,
+	.mipi_lane_num = SENSOR_MIPI_4_LANE,
+	.i2c_addr_table = {0x20},
+    .i2c_speed = 300, 
+};
+
+
+static imgsensor_struct imgsensor = {
+	.mirror = IMAGE_NORMAL,				//mirrorflip information
+	.sensor_mode = IMGSENSOR_MODE_INIT, //IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
+	.shutter = 0x3D0,					//current shutter
+	.gain = 0x100,						//current gain
+	.dummy_pixel = 0,					//current dummypixel
+	.dummy_line = 0,					//current dummyline
+    .current_fps = 30,  //full size current fps : 24fps for PIP, 30fps for Normal or ZSD
+    .autoflicker_en = KAL_FALSE,  //auto flicker enable: KAL_FALSE for disable auto flicker, KAL_TRUE for enable auto flicker
+	.test_pattern = KAL_FALSE,		//test pattern mode or not. KAL_TRUE for in test pattern mode, KAL_FALSE for normal output
+	.current_scenario_id = MSDK_SCENARIO_ID_CAMERA_PREVIEW,//current scenario id
+	.ihdr_en = 0, //sensor need support LE, SE with HDR feature
+	.i2c_write_id = 0x20,
+};
+
+
+/* Sensor output window information */
+static SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[5] =	 
+{{ 3280, 2464,	  8,	  8,   3264, 2448, 1632, 1224, 0000, 0000, 1632, 1224,	0,	0, 1600, 1200}, // Preview 
+ { 3280, 2464,	  8,	  8,   3264, 2448, 3264, 2448, 0000, 0000, 3264, 2448,	0,	0, 3264, 2448}, // capture 
+ { 3280, 2464,	  8,	  8,   3264, 2448, 3264, 2448, 0000, 0000, 3264, 2448,	0,	0, 3264, 2448}, // video 
+ { 3280, 2464,	  8,    8,   3264, 2448,  816,  612, 0000, 0000,  816,  612,	0,	0,  800,  600}, //hight speed video 
+ { 3280, 2464,	  360,  512, 2560, 1440, 1280,  720, 0000, 0000, 1280,  720,	0,	0, 1280,  720}};// slim video 
+
+
+static kal_uint16 read_cmos_sensor(kal_uint32 addr)
+{
+	kal_uint16 get_byte=0;
+    iReadReg((u16) addr ,(u8*)&get_byte,imgsensor.i2c_write_id);
+    return get_byte;
+}
+
+static void write_cmos_sensor(kal_uint16 addr, kal_uint16 para)
+{
+    char pusendcmd[4] = {(char)(addr >> 8) , (char)(addr & 0xFF) ,(char)(para >> 8),(char)(para & 0xFF)};
+    iWriteRegI2C(pusendcmd , 4, imgsensor.i2c_write_id);
+}
+
+static void write_cmos_sensor_8(kal_uint16 addr, kal_uint8 para)
+{
+    char pusendcmd[4] = {(char)(addr >> 8) , (char)(addr & 0xFF) ,(char)(para & 0xFF)};
+    iWriteRegI2C(pusendcmd , 3, imgsensor.i2c_write_id);
+}
+
+static void set_dummy()
+{
+	LOG_INF("dummyline = %d, dummypixels = %d \n", imgsensor.dummy_line, imgsensor.dummy_pixel);
+    write_cmos_sensor_8(0x0104, 0x01); 
+    write_cmos_sensor(0x0340, imgsensor.frame_length);
+    write_cmos_sensor(0x0342, imgsensor.line_length);
+    write_cmos_sensor_8(0x0104, 0x00); 
+}
+		
+
+static void set_max_framerate(UINT16 framerate,kal_bool min_framelength_en)
+{
+	kal_int16 dummy_line;
+	kal_uint32 frame_length = imgsensor.frame_length;
+	//unsigned long flags;
+
+	LOG_INF("framerate = %d, min_framelength_en=%d\n", framerate,min_framelength_en);
+	frame_length = imgsensor.pclk / framerate * 10 / imgsensor.line_length;
+	LOG_INF("frame_length =%d\n", frame_length);
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.frame_length = (frame_length > imgsensor.min_frame_length) ? frame_length : imgsensor.min_frame_length; 
+	imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
+	//dummy_line = frame_length - imgsensor.min_frame_length;
+	//if (dummy_line < 0)
+		//imgsensor.dummy_line = 0;
+	//else
+		//imgsensor.dummy_line = dummy_line;
+	//imgsensor.frame_length = frame_length + imgsensor.dummy_line;
+	if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+	{
+		imgsensor.frame_length = imgsensor_info.max_frame_length;
+		imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
+	}
+	if (min_framelength_en)
+		imgsensor.min_frame_length = imgsensor.frame_length;
+	spin_unlock(&imgsensor_drv_lock);
+	set_dummy();
+}	/*	set_max_framerate  */
+
+
+static void write_shutter(kal_uint16 shutter)
+	{
+		kal_uint16 realtime_fps = 0;
+		kal_uint32 frame_length = 0;
+	
+		if(imgsensor.sensor_mode == IMGSENSOR_MODE_HIGH_SPEED_VIDEO)
+		{
+			if(shutter > imgsensor.min_frame_length - imgsensor_info.margin)
+				shutter = imgsensor.min_frame_length - imgsensor_info.margin;
+    write_cmos_sensor_8(0x0104, 0x01); 
+    write_cmos_sensor(0x0340, imgsensor.frame_length);
+    write_cmos_sensor(0x0202, shutter);
+    write_cmos_sensor_8(0x0104, 0x00); 
+			LOG_INF("shutter =%d, framelength =%d\n", shutter,imgsensor.frame_length);
+			return;
+		}
+		spin_lock(&imgsensor_drv_lock);
+		if (shutter > imgsensor.min_frame_length - imgsensor_info.margin)
+			{
+			imgsensor.frame_length = shutter + imgsensor_info.margin;
+			}
+		else
+			{
+			imgsensor.frame_length = imgsensor.min_frame_length;
+			}
+		if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+			{
+			imgsensor.frame_length = imgsensor_info.max_frame_length;
+			}
+		spin_unlock(&imgsensor_drv_lock);
+		if (shutter < imgsensor_info.min_shutter) 
+			shutter = imgsensor_info.min_shutter;
+		
+		if (imgsensor.autoflicker_en == KAL_TRUE) { 
+			realtime_fps = imgsensor.pclk / imgsensor.line_length * 10 / imgsensor.frame_length;
+			if(realtime_fps >= 297 && realtime_fps <= 305)
+			{
+				set_max_framerate(296,0);
+				//set_dummy();
+			}
+			else if(realtime_fps >= 147 && realtime_fps <= 150)
+			{
+				set_max_framerate(146,0);	
+				//set_dummy();
+			}
+			else{
+    write_cmos_sensor_8(0x0104, 0x01); 
+    write_cmos_sensor(0x0340, imgsensor.frame_length);
+    write_cmos_sensor_8(0x0104, 0x00); 
+			}
+		} else {
+			// Extend frame length
+    write_cmos_sensor_8(0x0104, 0x01); 
+    write_cmos_sensor(0x0340, imgsensor.frame_length);
+    write_cmos_sensor_8(0x0104, 0x00); 
+		}
+	
+		// Update Shutter
+    write_cmos_sensor_8(0x0104, 0x01); 
+    write_cmos_sensor(0x0202, shutter);
+    write_cmos_sensor_8(0x0104, 0x00); 
+ 		LOG_INF("realtime_fps =%d\n", realtime_fps);
+		LOG_INF("shutter =%d, framelength =%d\n", shutter,imgsensor.frame_length);
+	
+		//LOG_INF("frame_length = %d ", frame_length);
+		
+	}
+
+
+
+
+/*************************************************************************
+* FUNCTION
+*	set_shutter
+*
+* DESCRIPTION
+*	This function set e-shutter of sensor to change exposure time.
+*
+* PARAMETERS
+*	iShutter : exposured lines
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static void set_shutter(kal_uint16 shutter)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&imgsensor_drv_lock, flags);
+	imgsensor.shutter = shutter;
+	spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
+	write_shutter(shutter);
+}	/*	set_shutter */
+
+
+
+static kal_uint16 gain2reg(const kal_uint16 gain)
+{
+}
+
+/*************************************************************************
+* FUNCTION
+*	set_gain
+*
+* DESCRIPTION
+*	This function is to set global gain to sensor.
+*
+* PARAMETERS
+*	iGain : sensor global gain(base: 0x40)
+*
+* RETURNS
+*	the actually gain set to sensor.
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint16 set_gain(kal_uint16 gain)
+{
+	gain = gain / 2;
+	
+	 write_cmos_sensor_8(0x0104, 0x01);
+	 write_cmos_sensor_8(0x0204,(gain>>8));
+	 write_cmos_sensor_8(0x0205,(gain&0xff));
+	 write_cmos_sensor_8(0x0104, 0x00);
+}   /*  S5K3H5XAMIPI_SetGain  */
+
+static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gain)
+{
+	LOG_INF("le:0x%x, se:0x%x, gain:0x%x\n",le,se,gain);
+
+}
+
+
+
+static void set_mirror_flip(kal_uint8 image_mirror)
+{
+	LOG_INF("image_mirror = %d\n", image_mirror);
+
+	/********************************************************
+	   *
+	   *   0x3820[2] ISP Vertical flip
+	   *   0x3820[1] Sensor Vertical flip
+	   *
+	   *   0x3821[2] ISP Horizontal mirror
+	   *   0x3821[1] Sensor Horizontal mirror
+	   *
+	   *   ISP and Sensor flip or mirror register bit should be the same!!
+	   *
+	   ********************************************************/
+	
+	switch (image_mirror)
+    {
+        case IMAGE_NORMAL: //B
+            write_cmos_sensor_8(0x0101, 0x00);	//Set normal
+            break;
+        case IMAGE_V_MIRROR: //Gr X
+            write_cmos_sensor_8(0x0101, 0x01);	//Set flip
+            break;
+        case IMAGE_H_MIRROR: //Gb
+            write_cmos_sensor_8(0x0101, 0x02);	//Set mirror
+            break;
+        case IMAGE_HV_MIRROR: //R
+            write_cmos_sensor_8(0x0101, 0x03);	//Set mirror and flip
+            break;
+    }
+
+}
+
+/*************************************************************************
+* FUNCTION
+*	night_mode
+*
+* DESCRIPTION
+*	This function night mode of sensor.
+*
+* PARAMETERS
+*	bEnable: KAL_TRUE -> enable night mode, otherwise, disable night mode
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static void night_mode(kal_bool enable)
+{
+/*No Need to implement this function*/ 
+}	/*	night_mode	*/
+
+static void sensor_init(void)
+{
+  write_cmos_sensor(0xFCFC, 0xD000);
+  write_cmos_sensor(0x6010, 0x0001);
+  mdelay(10);
+  write_cmos_sensor(0x6028, 0x7000);
+  write_cmos_sensor(0x602a, 0x1870);
+  write_cmos_sensor(0x6F12, 0x2DE9);
+  write_cmos_sensor(0x6F12, 0xF84F);
+  write_cmos_sensor(0x6F12, 0x9FE5);
+  write_cmos_sensor(0x6F12, 0x6081);
+  write_cmos_sensor(0x6F12, 0xA0E1);
+  write_cmos_sensor(0x6F12, 0x0090);
+  write_cmos_sensor(0x6F12, 0x98E5);
+  write_cmos_sensor(0x6F12, 0x00A0);
+  write_cmos_sensor(0x6F12, 0x9FE5);
+  write_cmos_sensor(0x6F12, 0x5071);
+  write_cmos_sensor(0x6F12, 0x9FE5);
+  write_cmos_sensor(0x6F12, 0x5401);
+  write_cmos_sensor(0x6F12, 0xD7E1);
+  write_cmos_sensor(0x6F12, 0xBE5E);
+  write_cmos_sensor(0x6F12, 0xD0E1);
+  write_cmos_sensor(0x6F12, 0xBC03);
+  write_cmos_sensor(0x6F12, 0xDAE5);
+  write_cmos_sensor(0x6F12, 0x9D10);
+  write_cmos_sensor(0x6F12, 0xDAE5);
+  write_cmos_sensor(0x6F12, 0x9FB0);
+  write_cmos_sensor(0x6F12, 0x40E0);
+  write_cmos_sensor(0x6F12, 0x0100);
+  write_cmos_sensor(0x6F12, 0x00E0);
+  write_cmos_sensor(0x6F12, 0x9500);
+  write_cmos_sensor(0x6F12, 0x55E1);
+  write_cmos_sensor(0x6F12, 0x0B00);
+  write_cmos_sensor(0x6F12, 0xA0E1);
+  write_cmos_sensor(0x6F12, 0x2005);
+  write_cmos_sensor(0x6F12, 0x002A);
+  write_cmos_sensor(0x6F12, 0x1B00);
+  write_cmos_sensor(0x6F12, 0x5BE1);
+  write_cmos_sensor(0x6F12, 0x0000);
+  write_cmos_sensor(0x6F12, 0x008A);
+  write_cmos_sensor(0x6F12, 0x0B00);
+  write_cmos_sensor(0x6F12, 0xA0E3);
+  write_cmos_sensor(0x6F12, 0x0040);
+  write_cmos_sensor(0x6F12, 0xC7E1);
+  write_cmos_sensor(0x6F12, 0xBEBE);
+  write_cmos_sensor(0x6F12, 0x87E0);
+  write_cmos_sensor(0x6F12, 0x0461);
+  write_cmos_sensor(0x6F12, 0x96E5);
+  write_cmos_sensor(0x6F12, 0xF800);
+  write_cmos_sensor(0x6F12, 0xA0E1);
+  write_cmos_sensor(0x6F12, 0x0B10);
+  write_cmos_sensor(0x6F12, 0x00E0);
+  write_cmos_sensor(0x6F12, 0x9500);
+  write_cmos_sensor(0x6F12, 0x00EB);
+  write_cmos_sensor(0x6F12, 0x4800);
+  write_cmos_sensor(0x6F12, 0x84E2);
+  write_cmos_sensor(0x6F12, 0x0140);
+  write_cmos_sensor(0x6F12, 0x54E3);
+  write_cmos_sensor(0x6F12, 0x0400);
+  write_cmos_sensor(0x6F12, 0x86E5);
+  write_cmos_sensor(0x6F12, 0xF800);
+  write_cmos_sensor(0x6F12, 0xFF3A);
+  write_cmos_sensor(0x6F12, 0xF6FF);
+  write_cmos_sensor(0x6F12, 0x00EA);
+  write_cmos_sensor(0x6F12, 0x0D00);
+  write_cmos_sensor(0x6F12, 0xDAE5);
+  write_cmos_sensor(0x6F12, 0x9E00);
+  write_cmos_sensor(0x6F12, 0x50E1);
+  write_cmos_sensor(0x6F12, 0x0500);
+  write_cmos_sensor(0x6F12, 0x002A);
+  write_cmos_sensor(0x6F12, 0x0A00);
+  write_cmos_sensor(0x6F12, 0xA0E3);
+  write_cmos_sensor(0x6F12, 0x0040);
+  write_cmos_sensor(0x6F12, 0xC7E1);
+  write_cmos_sensor(0x6F12, 0xBE0E);
+  write_cmos_sensor(0x6F12, 0x87E0);
+  write_cmos_sensor(0x6F12, 0x0461);
+  write_cmos_sensor(0x6F12, 0x96E5);
+  write_cmos_sensor(0x6F12, 0xF800);
+  write_cmos_sensor(0x6F12, 0xDAE5);
+  write_cmos_sensor(0x6F12, 0x9E10);
+  write_cmos_sensor(0x6F12, 0x00E0);
+  write_cmos_sensor(0x6F12, 0x9500);
+  write_cmos_sensor(0x6F12, 0x00EB);
+  write_cmos_sensor(0x6F12, 0x3900);
+  write_cmos_sensor(0x6F12, 0x84E2);
+  write_cmos_sensor(0x6F12, 0x0140);
+  write_cmos_sensor(0x6F12, 0x54E3);
+  write_cmos_sensor(0x6F12, 0x0400);
+  write_cmos_sensor(0x6F12, 0x86E5);
+  write_cmos_sensor(0x6F12, 0xF800);
+  write_cmos_sensor(0x6F12, 0xFF3A);
+  write_cmos_sensor(0x6F12, 0xF6FF);
+  write_cmos_sensor(0x6F12, 0x9FE5);
+  write_cmos_sensor(0x6F12, 0xC000);
+  write_cmos_sensor(0x6F12, 0x87E2);
+  write_cmos_sensor(0x6F12, 0xC830);
+  write_cmos_sensor(0x6F12, 0x8DE5);
+  write_cmos_sensor(0x6F12, 0x0030);
+  write_cmos_sensor(0x6F12, 0xD0E5);
+  write_cmos_sensor(0x6F12, 0xB920);
+  write_cmos_sensor(0x6F12, 0xD0E1);
+  write_cmos_sensor(0x6F12, 0xB618);
+  write_cmos_sensor(0x6F12, 0x9FE5);
+  write_cmos_sensor(0x6F12, 0xB000);
+  write_cmos_sensor(0x6F12, 0xA0E1);
+  write_cmos_sensor(0x6F12, 0x0930);
+  write_cmos_sensor(0x6F12, 0x90E5);
+  write_cmos_sensor(0x6F12, 0x28C0);
+  write_cmos_sensor(0x6F12, 0x87E2);
+  write_cmos_sensor(0x6F12, 0xE800);
+  write_cmos_sensor(0x6F12, 0xA0E1);
+  write_cmos_sensor(0x6F12, 0x0FE0);
+  write_cmos_sensor(0x6F12, 0x2FE1);
+  write_cmos_sensor(0x6F12, 0x1CFF);
+  write_cmos_sensor(0x6F12, 0x50E3);
+  write_cmos_sensor(0x6F12, 0x0000);
+  write_cmos_sensor(0x6F12, 0x001B);
+  write_cmos_sensor(0x6F12, 0x2A00);
+  write_cmos_sensor(0x6F12, 0x9FE5);
+  write_cmos_sensor(0x6F12, 0x9400);
+  write_cmos_sensor(0x6F12, 0x98E5);
+  write_cmos_sensor(0x6F12, 0x0010);
+  write_cmos_sensor(0x6F12, 0xD0E1);
+  write_cmos_sensor(0x6F12, 0xBA05);
+  write_cmos_sensor(0x6F12, 0xD1E5);
+  write_cmos_sensor(0x6F12, 0x9C10);
+  write_cmos_sensor(0x6F12, 0x9FE5);
+  write_cmos_sensor(0x6F12, 0x8830);
+  write_cmos_sensor(0x6F12, 0x50E1);
+  write_cmos_sensor(0x6F12, 0x0100);
+  write_cmos_sensor(0x6F12, 0xA0E3);
+  write_cmos_sensor(0x6F12, 0x0000);
+  write_cmos_sensor(0x6F12, 0x002A);
+  write_cmos_sensor(0x6F12, 0x1300);
+  write_cmos_sensor(0x6F12, 0x00EA);
+  write_cmos_sensor(0x6F12, 0x0500);
+  write_cmos_sensor(0x6F12, 0xD1E1);
+  write_cmos_sensor(0x6F12, 0xB210);
+  write_cmos_sensor(0x6F12, 0x82E2);
+  write_cmos_sensor(0x6F12, 0x0D22);
+  write_cmos_sensor(0x6F12, 0xC2E1);
+  write_cmos_sensor(0x6F12, 0xB010);
+  write_cmos_sensor(0x6F12, 0x80E2);
+  write_cmos_sensor(0x6F12, 0x0100);
+  write_cmos_sensor(0x6F12, 0x50E3);
+  write_cmos_sensor(0x6F12, 0x1400);
+  write_cmos_sensor(0x6F12, 0x00AA);
+  write_cmos_sensor(0x6F12, 0x0400);
+  write_cmos_sensor(0x6F12, 0x80E0);
+  write_cmos_sensor(0x6F12, 0x8010);
+  write_cmos_sensor(0x6F12, 0x83E0);
+  write_cmos_sensor(0x6F12, 0x8110);
+  write_cmos_sensor(0x6F12, 0xD1E1);
+  write_cmos_sensor(0x6F12, 0xB020);
+  write_cmos_sensor(0x6F12, 0x52E3);
+  write_cmos_sensor(0x6F12, 0x0000);
+  write_cmos_sensor(0x6F12, 0xFF1A);
+  write_cmos_sensor(0x6F12, 0xF4FF);
+  write_cmos_sensor(0x6F12, 0xBDE8);
+  write_cmos_sensor(0x6F12, 0xF84F);
+  write_cmos_sensor(0x6F12, 0x2FE1);
+  write_cmos_sensor(0x6F12, 0x1EFF);
+  write_cmos_sensor(0x6F12, 0xD1E1);
+  write_cmos_sensor(0x6F12, 0xB410);
+  write_cmos_sensor(0x6F12, 0x82E2);
+  write_cmos_sensor(0x6F12, 0x0D22);
+  write_cmos_sensor(0x6F12, 0xC2E1);
+  write_cmos_sensor(0x6F12, 0xB010);
+  write_cmos_sensor(0x6F12, 0x80E2);
+  write_cmos_sensor(0x6F12, 0x0100);
+  write_cmos_sensor(0x6F12, 0x50E3);
+  write_cmos_sensor(0x6F12, 0x1400);
+  write_cmos_sensor(0x6F12, 0xFFAA);
+  write_cmos_sensor(0x6F12, 0xF7FF);
+  write_cmos_sensor(0x6F12, 0x80E0);
+  write_cmos_sensor(0x6F12, 0x8010);
+  write_cmos_sensor(0x6F12, 0x83E0);
+  write_cmos_sensor(0x6F12, 0x8110);
+  write_cmos_sensor(0x6F12, 0xD1E1);
+  write_cmos_sensor(0x6F12, 0xB020);
+  write_cmos_sensor(0x6F12, 0x52E3);
+  write_cmos_sensor(0x6F12, 0x0000);
+  write_cmos_sensor(0x6F12, 0xFF1A);
+  write_cmos_sensor(0x6F12, 0xF4FF);
+  write_cmos_sensor(0x6F12, 0xFFEA);
+  write_cmos_sensor(0x6F12, 0xF1FF);
+  write_cmos_sensor(0x6F12, 0x0070);
+  write_cmos_sensor(0x6F12, 0x7014);
+  write_cmos_sensor(0x6F12, 0x0070);
+  write_cmos_sensor(0x6F12, 0x0000);
+  write_cmos_sensor(0x6F12, 0x0070);
+  write_cmos_sensor(0x6F12, 0x800C);
+  write_cmos_sensor(0x6F12, 0x0070);
+  write_cmos_sensor(0x6F12, 0x3013);
+  write_cmos_sensor(0x6F12, 0x0070);
+  write_cmos_sensor(0x6F12, 0xF804);
+  write_cmos_sensor(0x6F12, 0x0070);
+  write_cmos_sensor(0x6F12, 0x7015);
+  write_cmos_sensor(0x6F12, 0x0070);
+  write_cmos_sensor(0x6F12, 0x002D);
+  write_cmos_sensor(0x6F12, 0x1FE5);
+  write_cmos_sensor(0x6F12, 0x04F0);
+  write_cmos_sensor(0x6F12, 0x0000);
+  write_cmos_sensor(0x6F12, 0x20E1);
+  write_cmos_sensor(0x6F12, 0x1FE5);
+  write_cmos_sensor(0x6F12, 0x04F0);
+  write_cmos_sensor(0x6F12, 0x0000);
+  write_cmos_sensor(0x6F12, 0x641C);
+  write_cmos_sensor(0x6028, 0xD000);
+  write_cmos_sensor(0x3902, 0x0002);
+  write_cmos_sensor(0x3158, 0x0215);
+  write_cmos_sensor(0x32B4, 0xF4B6);
+  write_cmos_sensor(0x32B6, 0xF466);
+  write_cmos_sensor(0x32B8, 0xF456);
+  write_cmos_sensor(0x32BA, 0xF45E);
+  write_cmos_sensor_8(0x32BC, 0x10);
+  write_cmos_sensor_8(0x32BD, 0x00);
+  write_cmos_sensor_8(0x32BE, 0x00);
+  write_cmos_sensor(0x3338, 0x0214);
+  write_cmos_sensor(0x6218, 0xF1D0);
+  write_cmos_sensor(0x6214, 0xF9F0);
+  write_cmos_sensor(0x6226, 0x0001);
+  write_cmos_sensor(0xF446, 0x0029);
+  write_cmos_sensor(0xF448, 0x001D);
+  write_cmos_sensor(0xF440, 0x0071);
+  write_cmos_sensor(0xF42E, 0x00C1);
+  write_cmos_sensor(0xF42A, 0x0802);
+  write_cmos_sensor(0xB0C8, 0x0044);
+  write_cmos_sensor(0x6226, 0x0000);
+  write_cmos_sensor(0x6218, 0xF9F0);
+  write_cmos_sensor(0x34A2, 0x00D6);
+  write_cmos_sensor(0x34B2, 0x01FA);
+  write_cmos_sensor(0x34CA, 0x00D6);
+  write_cmos_sensor(0x34DA, 0x01FA);
+  write_cmos_sensor(0x3522, 0x00D6);
+  write_cmos_sensor(0x3532, 0x01FA);
+  write_cmos_sensor(0x3254, 0x79D3);
+  write_cmos_sensor(0x3256, 0x79D3);
+  write_cmos_sensor(0x3258, 0x79D3);
+  write_cmos_sensor(0x325A, 0x79D3);
+  write_cmos_sensor(0x325C, 0x79D3);
+  write_cmos_sensor(0x325E, 0x79D3);
+  write_cmos_sensor(0x357A, 0x00BD);
+  write_cmos_sensor(0x32F6, 0x1110);
+  write_cmos_sensor_8(0x012C, 0x60);
+  write_cmos_sensor_8(0x012D, 0x4F);
+  write_cmos_sensor_8(0x012E, 0x2F);
+  write_cmos_sensor_8(0x012F, 0x40);
+  write_cmos_sensor(0x6028, 0x7000);
+  write_cmos_sensor(0x602A, 0x2D00);
+  write_cmos_sensor(0x6F12, 0x30F4);
+  write_cmos_sensor(0x6F12, 0xD370);
+  write_cmos_sensor(0x6F12, 0xD379);
+  write_cmos_sensor(0x6F12, 0x12F4);
+  write_cmos_sensor(0x6F12, 0x0500);
+  write_cmos_sensor(0x6F12, 0x0100);
+  write_cmos_sensor(0x6F12, 0x4638);
+  write_cmos_sensor(0x6F12, 0x0007);
+  write_cmos_sensor(0x6F12, 0xF004);
+  write_cmos_sensor(0x6F12, 0x5038);
+  write_cmos_sensor(0x6F12, 0x0000);
+  write_cmos_sensor(0x6F12, 0x1002);
+  write_cmos_sensor(0x6F12, 0xF838);
+  write_cmos_sensor(0x6F12, 0xFAFF);
+  write_cmos_sensor(0x6F12, 0x0000);
+  write_cmos_sensor(0x6F12, 0x4C38);
+  write_cmos_sensor(0x6F12, 0x7805);
+  write_cmos_sensor(0x6F12, 0x9C04);
+  write_cmos_sensor(0x6F12, 0x78F4);
+  write_cmos_sensor(0x6F12, 0x0700);
+  write_cmos_sensor(0x6F12, 0x0700);
+  write_cmos_sensor(0x6F12, 0x9AF4);
+  write_cmos_sensor(0x6F12, 0x3100);
+  write_cmos_sensor(0x6F12, 0x3100);
+  write_cmos_sensor(0x6F12, 0x36F4);
+  write_cmos_sensor(0x6F12, 0x0600);
+  write_cmos_sensor(0x6F12, 0x0600);
+  write_cmos_sensor(0x6F12, 0x0000);
+  write_cmos_sensor(0x6028, 0xD000);
+  write_cmos_sensor(0x6226, 0x0001);
+  write_cmos_sensor(0x6100, 0x0003);
+  write_cmos_sensor(0x6110, 0x1CA0);
+  write_cmos_sensor(0x6112, 0x1CA4);
+  write_cmos_sensor(0x6150, 0x172C);
+  write_cmos_sensor(0x6152, 0x1730);
+  write_cmos_sensor(0x6028, 0x7000);
+  write_cmos_sensor(0x602A, 0x172C);
+  write_cmos_sensor(0x6F12, 0x1FE5);
+  write_cmos_sensor(0x6F12, 0x04F0);
+  write_cmos_sensor(0x6F12, 0x0070);
+  write_cmos_sensor(0x6F12, 0x7018);
+  write_cmos_sensor(0x6028, 0xD000);
+  write_cmos_sensor(0x6226, 0x0000);	  	    
+	  mdelay(5);
+}   /*  S5K3H5XAMIPI_Sensor_Init  */
+
+
+static void preview_setting(void)
+{ 
+	write_cmos_sensor_8(0x0100, 0x00);
+	mdelay(10);
+  write_cmos_sensor_8(0x0101, 0x00);
+  write_cmos_sensor(0x0112, 0x0A0A);
+  write_cmos_sensor_8(0x0114, 0x03);
+  write_cmos_sensor_8(0x0120, 0x00);
+  write_cmos_sensor(0x0200, 0x0BEF);
+  write_cmos_sensor(0x0202, 0x09D9);
+  write_cmos_sensor(0x0204, 0x0020);
+  write_cmos_sensor(0x0300, 0x0002);
+  write_cmos_sensor(0x0302, 0x0001);
+  write_cmos_sensor(0x0304, 0x0006);
+  write_cmos_sensor(0x0306, 0x008C);
+  write_cmos_sensor(0x0308, 0x0008);
+  write_cmos_sensor(0x030A, 0x0001);
+  write_cmos_sensor(0x030C, 0x0006);
+  write_cmos_sensor(0x030E, 0x00A5);
+  write_cmos_sensor(0x0340, 0x09E2);
+  write_cmos_sensor(0x0342, 0x0E68);
+  write_cmos_sensor(0x32CE, 0x0094);
+  write_cmos_sensor(0x32D0, 0x0024);
+  write_cmos_sensor(0x0344, 0x0008);
+  write_cmos_sensor(0x0346, 0x0008);
+  write_cmos_sensor(0x0348, 0x0CC7);
+  write_cmos_sensor(0x034A, 0x0997);
+  write_cmos_sensor(0x034C, 0x0660);
+  write_cmos_sensor(0x034E, 0x04C8);
+  write_cmos_sensor(0x0380, 0x0001);
+  write_cmos_sensor(0x0382, 0x0001);
+  write_cmos_sensor(0x0384, 0x0001);
+  write_cmos_sensor(0x0386, 0x0003);
+  write_cmos_sensor_8(0x0900, 0x01);
+  write_cmos_sensor_8(0x0901, 0x12);
+  write_cmos_sensor_8(0x0902, 0x01);
+  write_cmos_sensor_8(0x3011, 0x02);
+  write_cmos_sensor_8(0x3293, 0x00);
+  write_cmos_sensor_8(0x0100, 0x01);
+}   /*  S5K3H5XAMIPI_Capture_Setting  */
+
+static void capture_setting(kal_uint16 currefps)
+{
+	LOG_INF("yy_07\n");
+	write_cmos_sensor_8(0x0100, 0x00);
+	mdelay(10);
+  write_cmos_sensor_8(0x0101, 0x00);
+  write_cmos_sensor(0x0112, 0x0A0A);
+  write_cmos_sensor_8(0x0114, 0x03);
+  write_cmos_sensor_8(0x0120, 0x00);
+  write_cmos_sensor(0x0200, 0x0BEF);
+  write_cmos_sensor(0x0202, 0x09D9);
+  write_cmos_sensor(0x0204, 0x0020);
+  write_cmos_sensor(0x0300, 0x0002);
+  write_cmos_sensor(0x0302, 0x0001);
+  write_cmos_sensor(0x0304, 0x0006);
+  write_cmos_sensor(0x0306, 0x008C);
+  write_cmos_sensor(0x0308, 0x0008);
+  write_cmos_sensor(0x030A, 0x0001);
+  write_cmos_sensor(0x030C, 0x0006);
+  write_cmos_sensor(0x030E, 0x00A5);
+  write_cmos_sensor(0x0340, 0x09E2);
+  write_cmos_sensor(0x0342, 0x0E68);
+  write_cmos_sensor(0x32CE, 0x0094);
+  write_cmos_sensor(0x32D0, 0x0024);
+  write_cmos_sensor(0x0344, 0x0008);
+  write_cmos_sensor(0x0346, 0x0008);
+  write_cmos_sensor(0x0348, 0x0CC7);
+  write_cmos_sensor(0x034A, 0x0997);
+  write_cmos_sensor(0x034C, 0x0CC0);
+  write_cmos_sensor(0x034E, 0x0990);
+  write_cmos_sensor(0x0380, 0x0001);
+  write_cmos_sensor(0x0382, 0x0001);
+  write_cmos_sensor(0x0384, 0x0001);
+  write_cmos_sensor(0x0386, 0x0001);
+  write_cmos_sensor_8(0x0900, 0x01);
+  write_cmos_sensor_8(0x0901, 0x11);
+  write_cmos_sensor_8(0x0902, 0x01);
+  write_cmos_sensor_8(0x3011, 0x01);
+  write_cmos_sensor_8(0x3293, 0x00);
+  write_cmos_sensor_8(0x0100, 0x01);
+  mdelay(30);
+}
+static void normal_video_setting(kal_uint16 currefps)
+{ 
+	write_cmos_sensor_8(0x0100, 0x00);
+	mdelay(10);
+  write_cmos_sensor_8(0x0101, 0x00);
+  write_cmos_sensor(0x0112, 0x0A0A);
+  write_cmos_sensor_8(0x0114, 0x03);
+  write_cmos_sensor_8(0x0120, 0x00);
+  write_cmos_sensor(0x0200, 0x0BEF);
+  write_cmos_sensor(0x0202, 0x09D9);
+  write_cmos_sensor(0x0204, 0x0020);
+  write_cmos_sensor(0x0300, 0x0002);
+  write_cmos_sensor(0x0302, 0x0001);
+  write_cmos_sensor(0x0304, 0x0006);
+  write_cmos_sensor(0x0306, 0x008C);
+  write_cmos_sensor(0x0308, 0x0008);
+  write_cmos_sensor(0x030A, 0x0001);
+  write_cmos_sensor(0x030C, 0x0006);
+  write_cmos_sensor(0x030E, 0x00A5);
+  write_cmos_sensor(0x0340, 0x09E2);
+  write_cmos_sensor(0x0342, 0x0E68);
+  write_cmos_sensor(0x32CE, 0x0094);
+  write_cmos_sensor(0x32D0, 0x0024);
+  write_cmos_sensor(0x0344, 0x0008);
+  write_cmos_sensor(0x0346, 0x0008);
+  write_cmos_sensor(0x0348, 0x0CC7);
+  write_cmos_sensor(0x034A, 0x0997);
+  write_cmos_sensor(0x034C, 0x0CC0);
+  write_cmos_sensor(0x034E, 0x0990);
+  write_cmos_sensor(0x0380, 0x0001);
+  write_cmos_sensor(0x0382, 0x0001);
+  write_cmos_sensor(0x0384, 0x0001);
+  write_cmos_sensor(0x0386, 0x0001);
+  write_cmos_sensor_8(0x0900, 0x01);
+  write_cmos_sensor_8(0x0901, 0x11);
+  write_cmos_sensor_8(0x0902, 0x01);
+  write_cmos_sensor_8(0x3011, 0x01);
+  write_cmos_sensor_8(0x3293, 0x00);
+  write_cmos_sensor_8(0x0100, 0x01);
+  mdelay(30);
+}
+static void hs_video_setting() 
+{
+	write_cmos_sensor_8(0x0100, 0x00);
+	mdelay(10);
+  write_cmos_sensor_8(0x0101, 0x00);
+  write_cmos_sensor(0x0112, 0x0A0A);
+  write_cmos_sensor_8(0x0114, 0x03);
+  write_cmos_sensor_8(0x0120, 0x00);
+  write_cmos_sensor(0x0200, 0x0BEF);
+  write_cmos_sensor(0x0202, 0x09D9);
+  write_cmos_sensor(0x0204, 0x0020);
+  write_cmos_sensor(0x0300, 0x0002);
+  write_cmos_sensor(0x0302, 0x0001);
+  write_cmos_sensor(0x0304, 0x0006);
+  write_cmos_sensor(0x0306, 0x008C);
+  write_cmos_sensor(0x0308, 0x0008);
+  write_cmos_sensor(0x030A, 0x0001);
+  write_cmos_sensor(0x030C, 0x0006);
+  write_cmos_sensor(0x030E, 0x00A5);
+  write_cmos_sensor(0x0340, 0x0278);
+  write_cmos_sensor(0x0342, 0x0E68);
+  write_cmos_sensor(0x32CE, 0x0094);
+  write_cmos_sensor(0x32D0, 0x0024);
+  write_cmos_sensor(0x0344, 0x0008);
+  write_cmos_sensor(0x0346, 0x0008);
+  write_cmos_sensor(0x0348, 0x0CC7);
+  write_cmos_sensor(0x034A, 0x0997);
+  write_cmos_sensor(0x034C, 0x0330);
+  write_cmos_sensor(0x034E, 0x0264);
+  write_cmos_sensor(0x0380, 0x0001);
+  write_cmos_sensor(0x0382, 0x0001);
+  write_cmos_sensor(0x0384, 0x0001);
+  write_cmos_sensor(0x0386, 0x0003);
+  write_cmos_sensor_8(0x0900, 0x01);
+  write_cmos_sensor_8(0x0901, 0x14);
+  write_cmos_sensor_8(0x0902, 0x01);
+  write_cmos_sensor_8(0x3011, 0x04);
+  write_cmos_sensor_8(0x3293, 0x00);
+  write_cmos_sensor_8(0x0100, 0x01);
+}
+
+static void slim_video_setting()
+{
+	write_cmos_sensor_8(0x0100, 0x00);
+	mdelay(10);
+  write_cmos_sensor_8(0x0101, 0x00);
+  write_cmos_sensor(0x0112, 0x0A0A);
+  write_cmos_sensor_8(0x0114, 0x03);
+  write_cmos_sensor_8(0x0120, 0x00);
+  write_cmos_sensor(0x0200, 0x0BEF);
+  write_cmos_sensor(0x0202, 0x09D9);
+  write_cmos_sensor(0x0204, 0x0020);
+  write_cmos_sensor(0x0300, 0x0002);
+  write_cmos_sensor(0x0302, 0x0001);
+  write_cmos_sensor(0x0304, 0x0006);
+  write_cmos_sensor(0x0306, 0x008C);
+  write_cmos_sensor(0x0308, 0x0008);
+  write_cmos_sensor(0x030A, 0x0001);
+  write_cmos_sensor(0x030C, 0x0006);
+  write_cmos_sensor(0x030E, 0x00A5);
+  write_cmos_sensor(0x0340, 0x09E2);
+  write_cmos_sensor(0x0342, 0x0E68);
+  write_cmos_sensor(0x32CE, 0x0094);
+  write_cmos_sensor(0x32D0, 0x0024);
+  write_cmos_sensor(0x0344, 0x0168);
+  write_cmos_sensor(0x0346, 0x0200);
+  write_cmos_sensor(0x0348, 0x0B67);
+  write_cmos_sensor(0x034A, 0x079F);
+  write_cmos_sensor(0x034C, 0x0500);
+  write_cmos_sensor(0x034E, 0x02D0);
+  write_cmos_sensor(0x0380, 0x0001);
+  write_cmos_sensor(0x0382, 0x0001);
+  write_cmos_sensor(0x0384, 0x0001);
+  write_cmos_sensor(0x0386, 0x0003);
+  write_cmos_sensor_8(0x0900, 0x01);
+  write_cmos_sensor_8(0x0901, 0x12);
+  write_cmos_sensor_8(0x0902, 0x01);
+  write_cmos_sensor_8(0x3011, 0x02);
+  write_cmos_sensor_8(0x3293, 0x00);
+  write_cmos_sensor_8(0x0100, 0x01);
+}
+
+
+/*************************************************************************
+* FUNCTION
+*	get_imgsensor_id
+*
+* DESCRIPTION
+*	This function get the sensor ID 
+*
+* PARAMETERS
+*	*sensorID : return the sensor ID 
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 get_imgsensor_id(UINT32 *sensor_id) 
+{
+	kal_uint8 i = 0;
+    int  retry = 1;
+	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
+	//while (imgsensor_info.i2c_addr_table[i] != 0xff) {
+		spin_lock(&imgsensor_drv_lock);
+		imgsensor.i2c_write_id = 0x20;//imgsensor_info.i2c_addr_table[i];
+		spin_unlock(&imgsensor_drv_lock);
+		do {
+			*sensor_id = ((read_cmos_sensor(0x0000) << 8) | read_cmos_sensor(0x0001));
+			if (*sensor_id == imgsensor_info.sensor_id) {				
+				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);	  
+				break;
+			}	
+			LOG_INF("Read sensor id fail, id: 0x%x,0x%x\n", imgsensor.i2c_write_id,*sensor_id);
+			retry--;
+		} while(retry > 0);
+		//i++;
+		//retry = 2;
+//	}
+	if (*sensor_id != imgsensor_info.sensor_id) {
+		// if Sensor ID is not correct, Must set *sensor_id to 0xFFFFFFFF 
+		*sensor_id = 0xFFFFFFFF;
+		return ERROR_SENSOR_CONNECT_FAIL;
+	}
+	return ERROR_NONE;
+}
+
+
+
+/*************************************************************************
+* FUNCTION
+*	open
+*
+* DESCRIPTION
+*	This function initialize the registers of CMOS sensor
+*
+* PARAMETERS
+*	None
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 open(void)
+{
+	//const kal_uint8 i2c_addr[] = {IMGSENSOR_WRITE_ID_1, IMGSENSOR_WRITE_ID_2};
+	kal_uint8 i = 0;
+	kal_uint8 retry = 1;
+	kal_uint16 sensor_id = 0; 
+	LOG_INF("PLATFORM:MT6595,MIPI 2LANE\n");
+	LOG_INF("preview 1280*960@30fps,864Mbps/lane; video 1280*960@30fps,864Mbps/lane; capture 5M@30fps,864Mbps/lane\n");
+	
+	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
+	//while (imgsensor_info.i2c_addr_table[i] != 0xff) {
+		spin_lock(&imgsensor_drv_lock);
+		imgsensor.i2c_write_id = 0x20;//imgsensor_info.i2c_addr_table[i];
+		spin_unlock(&imgsensor_drv_lock);
+		do {
+			sensor_id = ((read_cmos_sensor(0x0000) << 8) | read_cmos_sensor(0x0001));
+			if (sensor_id == imgsensor_info.sensor_id) {				
+				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x,0x%x\n", imgsensor.i2c_write_id,sensor_id);	  
+				break;
+			}	
+			LOG_INF("Read sensor id fail, id: 0x%x,0x%x\n", imgsensor.i2c_write_id,sensor_id);
+			retry--;
+		} while(retry > 0);
+		//i++;
+		//if (sensor_id == imgsensor_info.sensor_id)
+		//	break;
+		//retry = 2;
+	//}		 
+	if (imgsensor_info.sensor_id != sensor_id)
+		return ERROR_SENSOR_CONNECT_FAIL;
+
+	
+
+
+	
+	/* initail sequence write in  */
+	sensor_init();
+
+	spin_lock(&imgsensor_drv_lock);
+
+	imgsensor.autoflicker_en= KAL_FALSE;
+	imgsensor.sensor_mode = IMGSENSOR_MODE_INIT;
+	imgsensor.shutter = 0x3D0;
+	imgsensor.gain = 0x100;
+	imgsensor.pclk = imgsensor_info.pre.pclk;
+	imgsensor.frame_length = imgsensor_info.pre.framelength;
+	imgsensor.line_length = imgsensor_info.pre.linelength;
+	imgsensor.min_frame_length = imgsensor_info.pre.framelength;
+	imgsensor.dummy_pixel = 0;
+	imgsensor.dummy_line = 0;
+	imgsensor.ihdr_en = 0;
+	imgsensor.test_pattern = KAL_FALSE;
+	imgsensor.current_fps = imgsensor_info.pre.max_framerate;
+	spin_unlock(&imgsensor_drv_lock);
+	return ERROR_NONE;
+}	/*	open  */
+
+
+
+/*************************************************************************
+* FUNCTION
+*	close
+*
+* DESCRIPTION
+*	
+*
+* PARAMETERS
+*	None
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 close(void)
+{
+	LOG_INF("E\n");
+
+	/*No Need to implement this function*/ 
+	
+	return ERROR_NONE;
+}	/*	close  */
+
+
+/*************************************************************************
+* FUNCTION
+* preview
+*
+* DESCRIPTION
+*	This function start the sensor preview.
+*
+* PARAMETERS
+*	*image_window : address pointer of pixel numbers in one period of HSYNC
+*  *sensor_config_data : address pointer of line numbers in one period of VSYNC
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("E\n");
+
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.sensor_mode = IMGSENSOR_MODE_PREVIEW;
+	imgsensor.pclk = imgsensor_info.pre.pclk;
+	//imgsensor.video_mode = KAL_FALSE;
+	imgsensor.line_length = imgsensor_info.pre.linelength;
+	imgsensor.frame_length = imgsensor_info.pre.framelength; 
+	imgsensor.min_frame_length = imgsensor_info.pre.framelength;
+	imgsensor.current_fps = imgsensor.current_fps;
+	//imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	preview_setting();
+	return ERROR_NONE;
+}   /*  S5K3H5XAMIPIPreview   */
+
+/*************************************************************************
+* FUNCTION
+*	capture
+*
+* DESCRIPTION
+*	This function setup the CMOS sensor in capture MY_OUTPUT mode
+*
+* PARAMETERS
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+						  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("E\n");
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.sensor_mode = IMGSENSOR_MODE_CAPTURE;
+	LOG_INF("yy_01\n");
+	LOG_INF("yy_current_fps=%x\n",imgsensor.current_fps);
+	if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {//PIP capture: 24fps for less than 13M, 20fps for 16M,15fps for 20M
+	LOG_INF("yy_02\n");
+		imgsensor.pclk = imgsensor_info.cap1.pclk;
+		imgsensor.line_length = imgsensor_info.cap1.linelength;
+		imgsensor.frame_length = imgsensor_info.cap1.framelength;  
+		imgsensor.min_frame_length = imgsensor_info.cap1.framelength;
+	LOG_INF("yy_03\n");
+		//imgsensor.autoflicker_en = KAL_FALSE;
+	} else {
+		if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
+			LOG_INF("Warning: current_fps %d fps is not support, so use cap1's setting: %d fps!\n",imgsensor_info.cap1.max_framerate/10);
+		imgsensor.pclk = imgsensor_info.cap.pclk;
+		imgsensor.line_length = imgsensor_info.cap.linelength;
+		imgsensor.frame_length = imgsensor_info.cap.framelength;  
+		imgsensor.min_frame_length = imgsensor_info.cap.framelength;
+	LOG_INF("yy_04\n");
+		//imgsensor.autoflicker_en = KAL_FALSE;
+	}
+
+	LOG_INF("yy_05\n");
+	spin_unlock(&imgsensor_drv_lock);
+
+	LOG_INF("yy_06\n");
+	capture_setting(imgsensor.current_fps); 
+	LOG_INF("yy_09\n");
+	
+	return ERROR_NONE;
+}	/* capture() */
+static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("E\n");
+	
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.sensor_mode = IMGSENSOR_MODE_VIDEO;
+	imgsensor.pclk = imgsensor_info.normal_video.pclk;
+	imgsensor.line_length = imgsensor_info.normal_video.linelength;
+	imgsensor.frame_length = imgsensor_info.normal_video.framelength;  
+	imgsensor.min_frame_length = imgsensor_info.normal_video.framelength;
+	//imgsensor.current_fps = 300;
+	//imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	normal_video_setting(imgsensor.current_fps);
+	return ERROR_NONE;
+}   /*  S5K3H5XAMIPIPreview   */
+
+static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("E\n");
+	
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.sensor_mode = IMGSENSOR_MODE_HIGH_SPEED_VIDEO;
+	imgsensor.pclk = imgsensor_info.hs_video.pclk;
+	//imgsensor.video_mode = KAL_TRUE;
+	imgsensor.line_length = imgsensor_info.hs_video.linelength;
+	imgsensor.frame_length = imgsensor_info.hs_video.framelength; 
+	imgsensor.min_frame_length = imgsensor_info.hs_video.framelength;
+	imgsensor.dummy_line = 0;
+	imgsensor.dummy_pixel = 0;
+	//imgsensor.current_fps = 300;
+	imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	hs_video_setting();
+	return ERROR_NONE;
+}   /*  S5K3H5XAMIPIPreview   */
+
+static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("E\n");
+	
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.sensor_mode = IMGSENSOR_MODE_SLIM_VIDEO;
+	imgsensor.pclk = imgsensor_info.slim_video.pclk;
+	//imgsensor.video_mode = KAL_TRUE;
+	imgsensor.line_length = imgsensor_info.slim_video.linelength;
+	imgsensor.frame_length = imgsensor_info.slim_video.framelength; 
+	imgsensor.min_frame_length = imgsensor_info.slim_video.framelength;
+	imgsensor.dummy_line = 0;
+	imgsensor.dummy_pixel = 0;
+	//imgsensor.current_fps = 300;
+	imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	slim_video_setting();
+	return ERROR_NONE;
+}   /*  S5K3H5XAMIPIPreview   */
+
+
+
+static kal_uint32 get_resolution(MSDK_SENSOR_RESOLUTION_INFO_STRUCT *sensor_resolution)
+{
+	LOG_INF("E\n");
+	sensor_resolution->SensorFullWidth = imgsensor_info.cap.grabwindow_width;
+	sensor_resolution->SensorFullHeight = imgsensor_info.cap.grabwindow_height;
+	
+	sensor_resolution->SensorPreviewWidth = imgsensor_info.pre.grabwindow_width;
+	sensor_resolution->SensorPreviewHeight = imgsensor_info.pre.grabwindow_height;
+
+	sensor_resolution->SensorVideoWidth = imgsensor_info.normal_video.grabwindow_width;
+	sensor_resolution->SensorVideoHeight = imgsensor_info.normal_video.grabwindow_height;		
+
+	
+	sensor_resolution->SensorHighSpeedVideoWidth	 = imgsensor_info.hs_video.grabwindow_width;
+	sensor_resolution->SensorHighSpeedVideoHeight	 = imgsensor_info.hs_video.grabwindow_height;
+	
+  sensor_resolution->SensorSlimVideoWidth	 = imgsensor_info.slim_video.grabwindow_width;
+	sensor_resolution->SensorSlimVideoHeight	 = imgsensor_info.slim_video.grabwindow_height;
+	return ERROR_NONE;
+}	/*	get_resolution	*/
+
+static kal_uint32 get_info(MSDK_SCENARIO_ID_ENUM scenario_id,
+					  MSDK_SENSOR_INFO_STRUCT *sensor_info,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("scenario_id = %d\n", scenario_id);
+
+	
+	//sensor_info->SensorVideoFrameRate = imgsensor_info.normal_video.max_framerate/10; /* not use */
+	//sensor_info->SensorStillCaptureFrameRate= imgsensor_info.cap.max_framerate/10; /* not use */
+	//imgsensor_info->SensorWebCamCaptureFrameRate= imgsensor_info.v.max_framerate; /* not use */
+
+	sensor_info->SensorClockPolarity = SENSOR_CLOCK_POLARITY_LOW;
+	sensor_info->SensorClockFallingPolarity = SENSOR_CLOCK_POLARITY_LOW; /* not use */
+	sensor_info->SensorHsyncPolarity = SENSOR_CLOCK_POLARITY_LOW; // inverse with datasheet
+	sensor_info->SensorVsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
+	sensor_info->SensorInterruptDelayLines = 4; /* not use */
+	sensor_info->SensorResetActiveHigh = FALSE; /* not use */
+	sensor_info->SensorResetDelayCount = 5; /* not use */
+
+	sensor_info->SensroInterfaceType = imgsensor_info.sensor_interface_type;
+    sensor_info->MIPIsensorType = imgsensor_info.mipi_sensor_type;
+    sensor_info->SettleDelayMode = imgsensor_info.mipi_settle_delay_mode;
+	sensor_info->SensorOutputDataFormat = imgsensor_info.sensor_output_dataformat;
+
+	sensor_info->CaptureDelayFrame = imgsensor_info.cap_delay_frame; 
+	sensor_info->PreviewDelayFrame = imgsensor_info.pre_delay_frame; 
+	sensor_info->VideoDelayFrame = imgsensor_info.video_delay_frame;
+    sensor_info->HighSpeedVideoDelayFrame = imgsensor_info.hs_video_delay_frame;
+    sensor_info->SlimVideoDelayFrame = imgsensor_info.slim_video_delay_frame;
+
+	sensor_info->SensorMasterClockSwitch = 0; /* not use */
+	sensor_info->SensorDrivingCurrent = imgsensor_info.isp_driving_current;
+	
+	sensor_info->AEShutDelayFrame = imgsensor_info.ae_shut_delay_frame; 		 /* The frame of setting shutter default 0 for TG int */
+	sensor_info->AESensorGainDelayFrame = imgsensor_info.ae_sensor_gain_delay_frame;	/* The frame of setting sensor gain */
+	sensor_info->AEISPGainDelayFrame = imgsensor_info.ae_ispGain_delay_frame;	
+	sensor_info->IHDR_Support = imgsensor_info.ihdr_support;
+	sensor_info->IHDR_LE_FirstLine = imgsensor_info.ihdr_le_firstline;
+	sensor_info->SensorModeNum = imgsensor_info.sensor_mode_num;
+	
+	sensor_info->SensorMIPILaneNumber = imgsensor_info.mipi_lane_num; 
+	sensor_info->SensorClockFreq = imgsensor_info.mclk;
+	sensor_info->SensorClockDividCount = 3; /* not use */
+	sensor_info->SensorClockRisingCount = 0;
+	sensor_info->SensorClockFallingCount = 2; /* not use */
+	sensor_info->SensorPixelClockCount = 3; /* not use */
+	sensor_info->SensorDataLatchCount = 2; /* not use */
+	
+	sensor_info->MIPIDataLowPwr2HighSpeedTermDelayCount = 0; 
+	sensor_info->MIPICLKLowPwr2HighSpeedTermDelayCount = 0;
+	sensor_info->SensorWidthSampling = 0;  // 0 is default 1x
+	sensor_info->SensorHightSampling = 0;	// 0 is default 1x 
+	sensor_info->SensorPacketECCOrder = 1;
+
+	switch (scenario_id) {
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+			sensor_info->SensorGrabStartX = imgsensor_info.pre.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;		
+			
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
+			
+			break;
+		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+			sensor_info->SensorGrabStartX = imgsensor_info.cap.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.cap.starty;
+				  
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.cap.mipi_data_lp2hs_settle_dc; 
+
+			break;	 
+		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+			
+			sensor_info->SensorGrabStartX = imgsensor_info.normal_video.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.normal_video.starty;
+	   
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.normal_video.mipi_data_lp2hs_settle_dc; 
+
+			break;	  
+		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:			
+			sensor_info->SensorGrabStartX = imgsensor_info.hs_video.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.hs_video.starty;
+				  
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.hs_video.mipi_data_lp2hs_settle_dc; 
+
+			break;
+		case MSDK_SCENARIO_ID_SLIM_VIDEO:
+			sensor_info->SensorGrabStartX = imgsensor_info.slim_video.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.slim_video.starty;
+				  
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.slim_video.mipi_data_lp2hs_settle_dc; 
+
+			break;
+		default:			
+			sensor_info->SensorGrabStartX = imgsensor_info.pre.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;		
+			
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
+			break;
+	}
+	
+	return ERROR_NONE;
+}	/*	get_info  */
+
+
+static kal_uint32 control(MSDK_SCENARIO_ID_ENUM scenario_id, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("scenario_id = %d\n", scenario_id);
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.current_scenario_id = scenario_id;
+	spin_unlock(&imgsensor_drv_lock);
+	switch (scenario_id) {
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+			preview(image_window, sensor_config_data);
+			break;
+		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+			capture(image_window, sensor_config_data);
+			break;	
+		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+			normal_video(image_window, sensor_config_data);
+			break;	  
+		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+			hs_video(image_window, sensor_config_data);
+			break;
+		case MSDK_SCENARIO_ID_SLIM_VIDEO:
+			slim_video(image_window, sensor_config_data);
+			break;	  
+		default:
+			LOG_INF("Error ScenarioId setting");
+			preview(image_window, sensor_config_data);
+			return ERROR_INVALID_SCENARIO_ID;
+	}
+	return ERROR_NONE;
+}	/* control() */
+
+
+
+static kal_uint32 set_video_mode(UINT16 framerate)
+	{
+		LOG_INF("framerate = %d\n ", framerate);
+		// SetVideoMode Function should fix framerate
+		if (framerate == 0)
+			// Dynamic frame rate
+			return ERROR_NONE;
+		spin_lock(&imgsensor_drv_lock);
+		if ((framerate == 300) && (imgsensor.autoflicker_en == KAL_TRUE))
+			imgsensor.current_fps = 296;
+		else if ((framerate == 150) && (imgsensor.autoflicker_en == KAL_TRUE))
+			imgsensor.current_fps = 146;
+		else
+			imgsensor.current_fps = framerate;
+		spin_unlock(&imgsensor_drv_lock);
+		set_max_framerate(imgsensor.current_fps,1);
+	
+		return ERROR_NONE;
+	}
+
+
+static kal_uint32 set_auto_flicker_mode(kal_bool enable, UINT16 framerate)
+{
+	LOG_INF("enable = %d, framerate = %d \n", enable, framerate);
+	spin_lock(&imgsensor_drv_lock);
+	if (enable) //enable auto flicker	  
+		imgsensor.autoflicker_en = KAL_TRUE;
+	else //Cancel Auto flick
+		imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	return ERROR_NONE;
+}
+
+
+static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 framerate) 
+{
+	kal_int16 dummyLine;
+	kal_uint32 lineLength,frameHeight;
+  
+	LOG_INF("scenario_id = %d, framerate = %d\n", scenario_id, framerate);
+				if(framerate == 0)
+				return ERROR_NONE;
+	switch (scenario_id) {
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+			frameHeight = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = frameHeight - imgsensor_info.pre.framelength;
+			if (imgsensor.dummy_line < 0)
+				imgsensor.dummy_line = 0;
+			imgsensor.frame_length =imgsensor_info.pre.framelength + imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			//set_dummy();			
+			break;			
+		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+			if(framerate == 0)
+				return ERROR_NONE;
+			frameHeight = imgsensor_info.normal_video.pclk / framerate * 10 / imgsensor_info.normal_video.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = frameHeight - imgsensor_info.normal_video.framelength;
+			if (imgsensor.dummy_line < 0)
+				imgsensor.dummy_line = 0;			
+			imgsensor.frame_length = imgsensor_info.normal_video.framelength + imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+
+			//set_dummy();			
+			break;
+		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+		//case MSDK_SCENARIO_ID_CAMERA_ZSD:			
+			frameHeight = imgsensor_info.cap.pclk / framerate * 10 / imgsensor_info.cap.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = frameHeight - imgsensor_info.cap.framelength;
+			if (imgsensor.dummy_line < 0)
+				imgsensor.dummy_line = 0;
+			imgsensor.frame_length =imgsensor_info.cap.framelength + imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			//set_dummy();			
+			break;	
+		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+			frameHeight = imgsensor_info.hs_video.pclk / framerate * 10 / imgsensor_info.hs_video.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = frameHeight - imgsensor_info.hs_video.framelength;
+			if (imgsensor.dummy_line < 0)
+				imgsensor.dummy_line = 0;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			//set_dummy();			
+			break;
+		case MSDK_SCENARIO_ID_SLIM_VIDEO:
+			frameHeight = imgsensor_info.slim_video.pclk / framerate * 10 / imgsensor_info.slim_video.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = frameHeight - imgsensor_info.slim_video.framelength;
+			if (imgsensor.dummy_line < 0)
+				imgsensor.dummy_line = 0;			
+			imgsensor.frame_length =imgsensor_info.hs_video.framelength + imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			//set_dummy();			
+		default:  //coding with  preview scenario by default
+			frameHeight = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = frameHeight - imgsensor_info.pre.framelength;
+			if (imgsensor.dummy_line < 0)
+				imgsensor.dummy_line = 0;
+			imgsensor.frame_length =imgsensor_info.pre.framelength + imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			//set_dummy();	
+			LOG_INF("error scenario_id = %d, we use preview scenario \n", scenario_id);
+			break;
+	}	
+	return ERROR_NONE;
+}
+
+
+static kal_uint32 get_default_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 *framerate) 
+{
+	LOG_INF("scenario_id = %d\n", scenario_id);
+
+	switch (scenario_id) {
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+			*framerate = imgsensor_info.pre.max_framerate;
+			break;
+		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+			*framerate = imgsensor_info.normal_video.max_framerate;
+			break;
+		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+			*framerate = imgsensor_info.cap.max_framerate;
+			break;		
+		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+			*framerate = imgsensor_info.hs_video.max_framerate;
+			break;
+		case MSDK_SCENARIO_ID_SLIM_VIDEO: 
+			*framerate = imgsensor_info.slim_video.max_framerate;
+			break;
+		default:
+			break;
+	}
+
+	return ERROR_NONE;
+}
+
+static kal_uint32 set_test_pattern_mode(kal_bool enable)
+{
+	LOG_INF("enable: %d\n", enable);
+
+	if(enable) 	 
+		write_cmos_sensor(0x0601, 0x02);
+	else		  
+		write_cmos_sensor(0x0601, 0x00);  
+
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.test_pattern = enable;
+	spin_unlock(&imgsensor_drv_lock);
+	return ERROR_NONE;
+}
+
+static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
+							 UINT8 *feature_para,UINT32 *feature_para_len)
+{
+	UINT16 *feature_return_para_16=(UINT16 *) feature_para;
+	UINT16 *feature_data_16=(UINT16 *) feature_para;
+	UINT32 *feature_return_para_32=(UINT32 *) feature_para;
+	UINT32 *feature_data_32=(UINT32 *) feature_para;
+	unsigned long long *feature_data=(unsigned long long *) feature_para;
+	unsigned long long *feature_return_para=(unsigned long long *) feature_para;
+	SENSOR_WINSIZE_INFO_STRUCT *wininfo;	
+	MSDK_SENSOR_REG_INFO_STRUCT *sensor_reg_data=(MSDK_SENSOR_REG_INFO_STRUCT *) feature_para;
+ 
+	//LOG_INF("feature_id = %d\n", feature_id);
+	switch (feature_id) {
+		case SENSOR_FEATURE_GET_PERIOD:
+			*feature_return_para_16++ = imgsensor.line_length;
+			*feature_return_para_16 = imgsensor.frame_length;
+			*feature_para_len=4;
+			break;
+		case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:	 
+			*feature_return_para_32 = imgsensor.pclk;
+			*feature_para_len=4;
+			break;		   
+		case SENSOR_FEATURE_SET_ESHUTTER:
+			set_shutter(*feature_data);
+			break;
+		case SENSOR_FEATURE_SET_NIGHTMODE:
+			night_mode((BOOL) *feature_data);
+			break;
+		case SENSOR_FEATURE_SET_GAIN:		
+			set_gain((UINT16) *feature_data);
+			break;
+		case SENSOR_FEATURE_SET_FLASHLIGHT:
+			break;
+		case SENSOR_FEATURE_SET_ISP_MASTER_CLOCK_FREQ:
+			break;
+		case SENSOR_FEATURE_SET_REGISTER:
+			write_cmos_sensor(sensor_reg_data->RegAddr, sensor_reg_data->RegData);
+			break;
+		case SENSOR_FEATURE_GET_REGISTER:
+			sensor_reg_data->RegData = read_cmos_sensor(sensor_reg_data->RegAddr);
+			break;
+		case SENSOR_FEATURE_GET_LENS_DRIVER_ID:
+			// get the lens driver ID from EEPROM or just return LENS_DRIVER_ID_DO_NOT_CARE
+			// if EEPROM does not exist in camera module.
+			*feature_return_para_32=LENS_DRIVER_ID_DO_NOT_CARE;
+			*feature_para_len=4;
+			break;
+		case SENSOR_FEATURE_SET_VIDEO_MODE:
+			set_video_mode(*feature_data);
+			break; 
+		case SENSOR_FEATURE_CHECK_SENSOR_ID:
+			get_imgsensor_id(feature_return_para_32); 
+			break; 
+		case SENSOR_FEATURE_SET_AUTO_FLICKER_MODE:
+			set_auto_flicker_mode((BOOL)*feature_data_16,*(feature_data_16+1));
+			break;
+		case SENSOR_FEATURE_SET_MAX_FRAME_RATE_BY_SCENARIO:
+            set_max_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data, *(feature_data+1));
+			break;
+		case SENSOR_FEATURE_GET_DEFAULT_FRAME_RATE_BY_SCENARIO:
+			get_default_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*(feature_data), (MUINT32 *)(uintptr_t)(*(feature_data+1)));
+			//get_default_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data_32, (MUINT32 *)(*(feature_data_32+1)));
+			break;
+		case SENSOR_FEATURE_SET_TEST_PATTERN:
+			set_test_pattern_mode((BOOL)*feature_data);
+			break;
+		case SENSOR_FEATURE_GET_TEST_PATTERN_CHECKSUM_VALUE: //for factory mode auto testing			 
+			*feature_return_para_32 = imgsensor_info.checksum_value;
+			*feature_para_len=4;							 
+			break;				
+		case SENSOR_FEATURE_SET_FRAMERATE:
+            LOG_INF("current fps :%d\n", (UINT32)*feature_data);
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.current_fps = *feature_data;
+			spin_unlock(&imgsensor_drv_lock);		
+			break;
+//		case SENSOR_FEATURE_SET_HDR:
+	//		LOG_INF("ihdr enable :%d\n", *feature_data_16);
+	//		spin_lock(&imgsensor_drv_lock);
+//			imgsensor.ihdr_en = *feature_data_16;
+	//		spin_unlock(&imgsensor_drv_lock);		
+//			break;
+		case SENSOR_FEATURE_GET_CROP_INFO:
+			//LOG_INF("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n", *feature_data_32);
+			//wininfo = (SENSOR_WINSIZE_INFO_STRUCT *)(*(feature_data_32+1));
+			wininfo = (SENSOR_WINSIZE_INFO_STRUCT *)(uintptr_t)(*(feature_data+1));
+			switch (*feature_data_32) {
+				case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[1],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+					break;	  
+				case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[2],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+					break;
+				case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[3],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+					break;
+				case MSDK_SCENARIO_ID_SLIM_VIDEO:
+					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[4],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+					break;
+				case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+				default:
+					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[0],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+					break;
+			}
+		case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
+            LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",(UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
+            ihdr_write_shutter_gain((UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
+			break;
+		default:
+			break;
+	}
+  
+	return ERROR_NONE;
+}	/*	feature_control()  */
+
+static SENSOR_FUNCTION_STRUCT sensor_func = {
+	open,
+	get_info,
+	get_resolution,
+	feature_control,
+	control,
+	close
+};
+
+UINT32 S5K3H5XA_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
+{
+	/* To Do : Check Sensor status here */
+	if (pfFunc!=NULL)
+		*pfFunc=&sensor_func;
+	return ERROR_NONE;
+}	/*	S5K3H5XA_MIPI_RAW_SensorInit	*/
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k3h5xa_mipi_raw/s5k3h5xamipiraw_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k3h5xa_mipi_raw/s5k3h5xamipiraw_Sensor.h
new file mode 100755
index 0000000..91af2be
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k3h5xa_mipi_raw/s5k3h5xamipiraw_Sensor.h
@@ -0,0 +1,123 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *	 S5K3H5XAmipi_Sensor.h
+ *
+ * Project:
+ * --------
+ *	 ALPS
+ *
+ * Description:
+ * ------------
+ *	 CMOS sensor header file
+ *
+ ****************************************************************************/
+#ifndef _S5K3H5XAMIPI_SENSOR_H
+#define _S5K3H5XAMIPI_SENSOR_H
+
+
+typedef enum{
+	IMGSENSOR_MODE_INIT,
+	IMGSENSOR_MODE_PREVIEW,
+	IMGSENSOR_MODE_CAPTURE,
+	IMGSENSOR_MODE_VIDEO,
+	IMGSENSOR_MODE_HIGH_SPEED_VIDEO,
+	IMGSENSOR_MODE_SLIM_VIDEO,
+} IMGSENSOR_MODE;
+
+typedef struct imgsensor_mode_struct {
+	kal_uint32 pclk;				//record different mode's pclk
+	kal_uint32 linelength;			//record different mode's linelength
+	kal_uint32 framelength;			//record different mode's framelength
+
+	kal_uint8 startx;				//record different mode's startx of grabwindow
+	kal_uint8 starty;				//record different mode's startx of grabwindow
+
+	kal_uint16 grabwindow_width;	//record different mode's width of grabwindow
+	kal_uint16 grabwindow_height;	//record different mode's height of grabwindow
+
+	/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
+	kal_uint8 mipi_data_lp2hs_settle_dc;
+
+	/*	 following for GetDefaultFramerateByScenario()	*/
+	kal_uint16 max_framerate;
+	
+} imgsensor_mode_struct;
+
+/* SENSOR PRIVATE STRUCT FOR VARIABLES*/
+typedef struct imgsensor_struct {
+	kal_uint8 mirror;				//mirrorflip information
+
+	kal_uint8 sensor_mode;			//record IMGSENSOR_MODE enum value
+
+	kal_uint32 shutter;				//current shutter
+	kal_uint16 gain;				//current gain
+	
+	kal_uint32 pclk;				//current pclk
+
+	kal_uint32 frame_length;		//current framelength
+	kal_uint32 line_length;			//current linelength
+
+	kal_uint32 min_frame_length;	//current min  framelength to max framerate
+	kal_uint16 dummy_pixel;			//current dummypixel
+	kal_uint16 dummy_line;			//current dummline
+	kal_uint16 current_fps;			//current max fps
+	kal_bool   autoflicker_en;		//record autoflicker enable or disable
+	kal_bool test_pattern;			//record test pattern mode or not
+	MSDK_SCENARIO_ID_ENUM current_scenario_id;//current scenario id
+	kal_uint8  ihdr_en;				//ihdr enable or disable
+	
+	kal_uint8 i2c_write_id;			//record current sensor's i2c write id
+} imgsensor_struct;
+
+/* SENSOR PRIVATE STRUCT FOR CONSTANT*/
+typedef struct imgsensor_info_struct { 
+	kal_uint16 sensor_id;			//record sensor id defined in Kd_imgsensor.h
+	kal_uint32 checksum_value;		//checksum value for Camera Auto Test
+	imgsensor_mode_struct pre;		//preview scenario relative information
+	imgsensor_mode_struct cap;		//capture scenario relative information
+	imgsensor_mode_struct cap1;		//capture for PIP 24fps relative information
+	imgsensor_mode_struct normal_video;//normal video  scenario relative information
+	imgsensor_mode_struct hs_video;	//high speed video scenario relative information
+	imgsensor_mode_struct slim_video;	//slim video for VT scenario relative information
+	
+	kal_uint8  ae_shut_delay_frame;	//shutter delay frame for AE cycle
+	kal_uint8  ae_sensor_gain_delay_frame;	//sensor gain delay frame for AE cycle
+	kal_uint8  ae_ispGain_delay_frame;	//isp gain delay frame for AE cycle
+	kal_uint8  ihdr_support;		//1, support; 0,not support
+	kal_uint8  ihdr_le_firstline;	//1,le first ; 0, se first
+	kal_uint8  sensor_mode_num;		//support sensor mode num
+	
+	kal_uint8  cap_delay_frame;		//enter capture delay frame num
+	kal_uint8  pre_delay_frame;		//enter preview delay frame num
+	kal_uint8  video_delay_frame;	//enter video delay frame num
+	kal_uint8  hs_video_delay_frame;	//enter high speed video  delay frame num
+	kal_uint8  slim_video_delay_frame;	//enter slim video delay frame num
+  
+	kal_uint8  margin;				//sensor framelength & shutter margin 
+	kal_uint32 min_shutter;			//min shutter
+	kal_uint32 max_frame_length;	//max framelength by sensor register's limitation
+
+	kal_uint8  isp_driving_current;	//mclk driving current
+	kal_uint8  sensor_interface_type;//sensor_interface_type
+	kal_uint8  mipi_sensor_type; //0,MIPI_OPHY_NCSI2; 1,MIPI_OPHY_CSI2, default is NCSI2, don't modify this para
+	kal_uint8  mipi_settle_delay_mode; //0, high speed signal auto detect; 1, use settle delay,unit is ns, default is auto detect, don't modify this para
+	kal_uint8  sensor_output_dataformat;
+	kal_uint8  mclk;				//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
+	
+	kal_uint8  mipi_lane_num;		//mipi lane num
+	kal_uint8  i2c_addr_table[5];	//record sensor support all write id addr, only supprt 4must end with 0xff
+    kal_uint32  i2c_speed;							//khz
+} imgsensor_info_struct;
+
+/* SENSOR READ/WRITE ID */
+//#define IMGSENSOR_WRITE_ID_1 (0x6c)
+//#define IMGSENSOR_READ_ID_1  (0x6d)
+//#define IMGSENSOR_WRITE_ID_2 (0x20)
+//#define IMGSENSOR_READ_ID_2  (0x21)
+
+extern int iReadRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u8 * a_pRecvData, u16 a_sizeRecvData, u16 i2cId);
+extern int iWriteRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u16 i2cId);
+
+#endif 
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k4e2gx_mipi_raw/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k4e2gx_mipi_raw/Makefile
index 76747ac..ed7a1d4 100755
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k4e2gx_mipi_raw/Makefile
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k4e2gx_mipi_raw/Makefile
@@ -1,4 +1,4 @@
 include $(srctree)/drivers/misc/mediatek/Makefile.custom
-
 obj-y += s5k4e2gxmipiraw_Sensor.o
 
+
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k4e2gx_mipi_raw/s5k4e2gxmipiraw_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k4e2gx_mipi_raw/s5k4e2gxmipiraw_Sensor.c
old mode 100644
new mode 100755
index 78c6d5f..595c834
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k4e2gx_mipi_raw/s5k4e2gxmipiraw_Sensor.c
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k4e2gx_mipi_raw/s5k4e2gxmipiraw_Sensor.c
@@ -65,7 +65,7 @@ static imgsensor_info_struct imgsensor_info = {
 		.starty = 0,					//record different mode's starty of grabwindow
 		.grabwindow_width = 1304,		//record different mode's width of grabwindow
 		.grabwindow_height = 980,		//record different mode's height of grabwindow
-		.mipi_data_lp2hs_settle_dc = 28,
+		.mipi_data_lp2hs_settle_dc = 13,
 		.max_framerate = 290,	
 	},
 	.cap = {
@@ -76,7 +76,7 @@ static imgsensor_info_struct imgsensor_info = {
 		.starty = 0,
 		.grabwindow_width = 2608,
 		.grabwindow_height = 1960,
-		.mipi_data_lp2hs_settle_dc = 28,
+		.mipi_data_lp2hs_settle_dc = 13,
 		.max_framerate = 140,
 	},
 	.cap1 = {
@@ -87,7 +87,7 @@ static imgsensor_info_struct imgsensor_info = {
 		.starty = 0,
 		.grabwindow_width = 2608,
 		.grabwindow_height = 1960,
-		.mipi_data_lp2hs_settle_dc = 28,
+		.mipi_data_lp2hs_settle_dc = 13,
 		.max_framerate = 140,	
 	},
 	.normal_video = {
@@ -98,7 +98,7 @@ static imgsensor_info_struct imgsensor_info = {
 		.starty = 0,
 		.grabwindow_width = 2608,
 		.grabwindow_height = 1960,
-		.mipi_data_lp2hs_settle_dc = 28,
+		.mipi_data_lp2hs_settle_dc = 13,
 		.max_framerate = 140,
 	},
 	.hs_video = {
@@ -109,7 +109,7 @@ static imgsensor_info_struct imgsensor_info = {
 		.starty = 0,
 		.grabwindow_width = 1304,
 		.grabwindow_height = 980,
-		.mipi_data_lp2hs_settle_dc = 28,
+		.mipi_data_lp2hs_settle_dc = 13,
 		.max_framerate = 290,
 	},
 	.slim_video = {
@@ -120,7 +120,7 @@ static imgsensor_info_struct imgsensor_info = {
 		.starty = 0,
 		.grabwindow_width = 1304,
 		.grabwindow_height = 980,
-		.mipi_data_lp2hs_settle_dc = 28,
+		.mipi_data_lp2hs_settle_dc = 13,
 		.max_framerate = 290,
 	},
 	.margin = 16,
@@ -139,7 +139,7 @@ static imgsensor_info_struct imgsensor_info = {
 	.hs_video_delay_frame = 3,
 	.slim_video_delay_frame = 3,
 	
-	.isp_driving_current = ISP_DRIVING_6MA,
+	.isp_driving_current = ISP_DRIVING_8MA,
 	.sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,
 	.mipi_sensor_type = MIPI_OPHY_NCSI2, //0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2
 	.mipi_settle_delay_mode = MIPI_SETTLEDELAY_AUTO,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
@@ -201,11 +201,12 @@ static void write_cmos_sensor_8(kal_uint16 addr, kal_uint8 para)
 static void set_dummy()
 {
 	LOG_INF("dummyline = %d, dummypixels = %d \n", imgsensor.dummy_line, imgsensor.dummy_pixel);
-
+  write_cmos_sensor(0x0104, 0x01);
 	write_cmos_sensor(0x0340, imgsensor.frame_length >> 8);
 	write_cmos_sensor(0x0341, imgsensor.frame_length & 0xFF);	  
 	write_cmos_sensor(0x0342, imgsensor.line_length >> 8);
 	write_cmos_sensor(0x0343, imgsensor.line_length & 0xFF);
+	write_cmos_sensor(0x0104, 0x00);
   
 }	/*	set_dummy  */
 
@@ -275,20 +276,24 @@ static void write_shutter(kal_uint16 shutter)
 			set_max_framerate(146,0);	
 		else {
 		// Extend frame length
+		write_cmos_sensor(0x0104, 0x01);
 		write_cmos_sensor(0x0340, imgsensor.frame_length >> 8);
 		write_cmos_sensor(0x0341, imgsensor.frame_length & 0xFF);
+		write_cmos_sensor(0x0104, 0x00);
 		}
 	} else {
 		// Extend frame length
+		write_cmos_sensor(0x0104, 0x01);
 		write_cmos_sensor(0x0340, imgsensor.frame_length >> 8);
 		write_cmos_sensor(0x0341, imgsensor.frame_length & 0xFF);
+		write_cmos_sensor(0x0104, 0x00);
 	}
 
 	// Update Shutter
-	//write_cmos_sensor(0x0104, 0x01);   //group hold
+	write_cmos_sensor(0x0104, 0x01);   //group hold
 	write_cmos_sensor(0x0202, shutter >> 8);
 	write_cmos_sensor(0x0203, shutter & 0xFF);	
-	//write_cmos_sensor(0x0104, 0x00);   //group hold
+	write_cmos_sensor(0x0104, 0x00);   //group hold
 	
 	LOG_INF("shutter =%d, framelength =%d\n", shutter,imgsensor.frame_length);
 
@@ -365,10 +370,10 @@ static kal_uint16 set_gain(kal_uint16 gain)
 	spin_unlock(&imgsensor_drv_lock);
 	LOG_INF("gain = %d , reg_gain = 0x%x\n ", gain, reg_gain);
 
-	//write_cmos_sensor(0x0104, 0x01);   //group hold
+	write_cmos_sensor(0x0104, 0x01);   //group hold
 	write_cmos_sensor(0x0204, reg_gain >> 8);
 	write_cmos_sensor(0x0205, reg_gain & 0xFF);  
-	//write_cmos_sensor(0x0104, 0x00);
+	write_cmos_sensor(0x0104, 0x00);
 	
 	return gain;
 }	/*	set_gain  */
@@ -471,10 +476,134 @@ static void night_mode(kal_bool enable)
 static void sensor_init(void)
 {
 	LOG_INF("E\n");
+/*                                                                        
+  write_cmos_sensor(0x0103, 0x01);
+  write_cmos_sensor(0x0100, 0x00);
+  write_cmos_sensor(0x0111, 0x02);
+  write_cmos_sensor(0x0304, 0x00);
+  write_cmos_sensor(0x0305, 0x06);
+  write_cmos_sensor(0x0306, 0x00);
+  write_cmos_sensor(0x0307, 0xCC);
+  write_cmos_sensor(0x0820, 0x03);
+  write_cmos_sensor(0x0821, 0x30);
+  write_cmos_sensor(0x0301, 0x0a);
+  write_cmos_sensor(0x0303, 0x01);
+  write_cmos_sensor(0x0309, 0x0a);
+  write_cmos_sensor(0x030b, 0x01);
+  write_cmos_sensor(0x3000, 0x07);
+  write_cmos_sensor(0x3001, 0x05);
+  write_cmos_sensor(0x3002, 0x0B);
+  write_cmos_sensor(0x3003, 0x0F);
+  write_cmos_sensor(0x3004, 0x3C);
+  write_cmos_sensor(0x3005, 0x08);
+  write_cmos_sensor(0x3006, 0x44);
+  write_cmos_sensor(0x3007, 0x01);
+  write_cmos_sensor(0x3008, 0x44);
+  write_cmos_sensor(0x3009, 0x44);
+  write_cmos_sensor(0x300A, 0x2D);
+  write_cmos_sensor(0x300B, 0x17);
+  write_cmos_sensor(0x300C, 0x01);
+  write_cmos_sensor(0x300D, 0x02);
+  write_cmos_sensor(0x307E, 0x02);
+  write_cmos_sensor(0x307F, 0x8C);
+  write_cmos_sensor(0x300E, 0xA8);
+  write_cmos_sensor(0x300F, 0x02);
+  write_cmos_sensor(0x3010, 0xA0);
+  write_cmos_sensor(0x3011, 0x7E);
+  write_cmos_sensor(0x3156, 0xE0);
+  write_cmos_sensor(0x3016, 0x33);
+  write_cmos_sensor(0x3017, 0x84);
+  write_cmos_sensor(0x3018, 0x24);
+  write_cmos_sensor(0x301C, 0xD4);
+  write_cmos_sensor(0x3020, 0x02);
+  write_cmos_sensor(0x301B, 0x05);
+  write_cmos_sensor(0x3053, 0xDF);
+  write_cmos_sensor(0x3062, 0x04);
+  write_cmos_sensor(0x3063, 0x38);
+  write_cmos_sensor(0x3054, 0x00);
+  write_cmos_sensor(0x3150, 0x02);
+  write_cmos_sensor(0x3151, 0x00);
+  write_cmos_sensor(0x3152, 0x02);
+  write_cmos_sensor(0x3153, 0x00);
+  write_cmos_sensor(0x3159, 0x1D);
+  write_cmos_sensor(0x315A, 0xB0);
+  write_cmos_sensor(0x315b, 0x02);
+  write_cmos_sensor(0x315c, 0x00);
+  write_cmos_sensor(0x3073, 0x03);
+  write_cmos_sensor(0x3074, 0x00);
+  write_cmos_sensor(0x3075, 0x30);
+  write_cmos_sensor(0x3090, 0x50);
+  write_cmos_sensor(0x3092, 0x08);
+  write_cmos_sensor(0x3093, 0x08);
+  write_cmos_sensor(0x3024, 0x10);
+  write_cmos_sensor(0x3025, 0x02);
+  write_cmos_sensor(0x3028, 0x00);
+  write_cmos_sensor(0x301d, 0x20);
+  write_cmos_sensor(0x305C, 0x02);
+  write_cmos_sensor(0x305D, 0x02);
+  write_cmos_sensor(0x305E, 0x03);
+  write_cmos_sensor(0x305F, 0x03);
+  write_cmos_sensor(0x3095, 0x0A);
+  write_cmos_sensor(0x3022, 0x15);
+  write_cmos_sensor(0x3027, 0xd1);
+  write_cmos_sensor(0x3084, 0x02);
+  write_cmos_sensor(0x301A, 0x97);
+  write_cmos_sensor(0x0202, 0x03);
+  write_cmos_sensor(0x0203, 0xF0);
+  write_cmos_sensor(0x0204, 0x02);
+  write_cmos_sensor(0x0205, 0x00);
+  write_cmos_sensor(0x3091, 0x00);
+  write_cmos_sensor(0x0b00, 0x00);
+  write_cmos_sensor(0x0b05, 0x01);
+  write_cmos_sensor(0x0b06, 0x01);
+  write_cmos_sensor(0x0b08, 0x01);
+  write_cmos_sensor(0x0b07, 0xEF);
+  write_cmos_sensor(0x3411, 0x02);
+  write_cmos_sensor(0x3412, 0x02);
+  write_cmos_sensor(0x3413, 0x00);
+  write_cmos_sensor(0x3414, 0x00);
+  write_cmos_sensor(0x3415, 0x00);
+  write_cmos_sensor(0x3416, 0x00);
+  write_cmos_sensor(0x3441, 0x0A);
+  write_cmos_sensor(0x3442, 0x0A);
+  write_cmos_sensor(0x3444, 0x40);
+  write_cmos_sensor(0x3446, 0x40);
+  write_cmos_sensor(0x3448, 0x01);
+  write_cmos_sensor(0x3449, 0x00);
+  write_cmos_sensor(0x344d, 0x20);
+  write_cmos_sensor(0x344E, 0x01);
+  write_cmos_sensor(0x3456, 0x05);
+  write_cmos_sensor(0x3459, 0x20);
+  write_cmos_sensor(0x345B, 0x20);
+  write_cmos_sensor(0x30A9, 0x02);
+  write_cmos_sensor(0x300E, 0xEB);
+  write_cmos_sensor(0x0387, 0x03);
+  write_cmos_sensor(0x0380, 0x00);
+  write_cmos_sensor(0x0381, 0x01);
+  write_cmos_sensor(0x0382, 0x00);
+  write_cmos_sensor(0x0383, 0x01);
+  write_cmos_sensor(0x0384, 0x00);
+  write_cmos_sensor(0x0385, 0x01);
+  write_cmos_sensor(0x0386, 0x00);
+  write_cmos_sensor(0x0387, 0x03);
+  write_cmos_sensor(0x034C, 0x05);
+  write_cmos_sensor(0x034D, 0x18);
+  write_cmos_sensor(0x034E, 0x03);
+  write_cmos_sensor(0x034F, 0xd4);
+  write_cmos_sensor(0x0340, 0x03);
+  write_cmos_sensor(0x0341, 0xF5);
+  write_cmos_sensor(0x0342, 0x0A);
+  write_cmos_sensor(0x0343, 0xB4);
+  write_cmos_sensor(0x3115, 0x05);
+  write_cmos_sensor(0x3118, 0x1b);
+  write_cmos_sensor(0x0100, 0x01); 
+  mdelay(20); */
 }	/*	sensor_init  */
+
+
 static void preview_setting(void)
 {
-                                                                        
+                                                               
   write_cmos_sensor(0x0103, 0x01);
   mdelay(20);
   write_cmos_sensor(0x0100, 0x00);
@@ -597,14 +726,14 @@ static void preview_setting(void)
   write_cmos_sensor(0x3115, 0x05);
   write_cmos_sensor(0x3118, 0x1b);
   write_cmos_sensor(0x0100, 0x01); 
-  mdelay(20);
-
-}	/*	sensor_init  */
-
+  mdelay(20);                                                                         
+	 
+}	/*	preview_setting  */
 
 static void capture_setting(kal_uint16 currefps)
 {
 	LOG_INF("E! currefps:%d\n",currefps);
+
   write_cmos_sensor(0x0103, 0x01);
   mdelay(20);
   write_cmos_sensor(0x0100, 0x00);
@@ -726,15 +855,14 @@ static void capture_setting(kal_uint16 currefps)
   write_cmos_sensor(0x034F, 0xA8);
   write_cmos_sensor(0x3115, 0x05);
   write_cmos_sensor(0x3118, 0x1b);
-  write_cmos_sensor(0x0100, 0x01); 
-  mdelay(20);                                                                         
-	 
-}	/*	preview_setting  */
+  write_cmos_sensor(0x0100, 0x01);
+  mdelay(20);
+}
 
 static void normal_video_setting(kal_uint16 currefps)
 {
 	LOG_INF("E! currefps:%d\n",currefps);
-
+	
   write_cmos_sensor(0x0103, 0x01);
   mdelay(20);
   write_cmos_sensor(0x0100, 0x00);
@@ -858,12 +986,12 @@ static void normal_video_setting(kal_uint16 currefps)
   write_cmos_sensor(0x3118, 0x1b);
   write_cmos_sensor(0x0100, 0x01);
   mdelay(20);
+		
 }
-
 static void hs_video_setting()
 {
 	LOG_INF("E\n");         
-	
+	//VGA 120fps
   write_cmos_sensor(0x0103, 0x01);
   mdelay(20);
   write_cmos_sensor(0x0100, 0x00);
@@ -985,14 +1113,15 @@ static void hs_video_setting()
   write_cmos_sensor(0x0343, 0xB4);
   write_cmos_sensor(0x3115, 0x05);
   write_cmos_sensor(0x3118, 0x1b);
-  write_cmos_sensor(0x0100, 0x01);
+  write_cmos_sensor(0x0100, 0x01); 
   mdelay(20);
-		
+
 }
+
 static void slim_video_setting()
 {
-	LOG_INF("E\n");         
-	//VGA 120fps
+	LOG_INF("E\n");
+
   write_cmos_sensor(0x0103, 0x01);
   mdelay(20);
   write_cmos_sensor(0x0100, 0x00);
@@ -1100,9 +1229,6 @@ static void slim_video_setting()
   write_cmos_sensor(0x0381, 0x01);
   write_cmos_sensor(0x0382, 0x00);
   write_cmos_sensor(0x0383, 0x03);
-
-
-
   write_cmos_sensor(0x0384, 0x00);
   write_cmos_sensor(0x0385, 0x01);
   write_cmos_sensor(0x0386, 0x00);
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k4e2gx_mipi_raw/s5k4e2gxmipiraw_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k4e2gx_mipi_raw/s5k4e2gxmipiraw_Sensor.h
old mode 100644
new mode 100755
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k4h5yc_mipi_raw/s5k4h5ycmipiraw_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k4h5yc_mipi_raw/s5k4h5ycmipiraw_Sensor.c
index 5ec9333..81e23b5 100644
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k4h5yc_mipi_raw/s5k4h5ycmipiraw_Sensor.c
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k4h5yc_mipi_raw/s5k4h5ycmipiraw_Sensor.c
@@ -55,10 +55,10 @@ static imgsensor_info_struct imgsensor_info = {
 		.framelength = 2512,
 		.startx = 0,
 		.starty = 0,
-		.grabwindow_width = 1600,		//record different mode's width of grabwindow
-		.grabwindow_height = 1200,		//record different mode's height of grabwindow
+		.grabwindow_width = 1632,		//record different mode's width of grabwindow
+		.grabwindow_height = 1224,		//record different mode's height of grabwindow
 		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
-		.mipi_data_lp2hs_settle_dc = 65,
+		.mipi_data_lp2hs_settle_dc = 14,
 		/*	 following for GetDefaultFramerateByScenario()	*/
 		.max_framerate = 300,	
 	},
@@ -68,9 +68,9 @@ static imgsensor_info_struct imgsensor_info = {
 		.framelength = 2512,
 		.startx = 0,
 		.starty = 0,
-		.grabwindow_width = 3280,
-		.grabwindow_height = 2464,
-		.mipi_data_lp2hs_settle_dc = 65,
+		.grabwindow_width = 3264,//3200,
+		.grabwindow_height = 2448,//2400,
+		.mipi_data_lp2hs_settle_dc = 14,
 		.max_framerate = 300,
 	},
 	.cap1 = {
@@ -79,9 +79,9 @@ static imgsensor_info_struct imgsensor_info = {
 		.framelength = 2530,
 		.startx = 0,
 		.starty = 0,
-		.grabwindow_width = 3280,
-		.grabwindow_height = 2464,
-		.mipi_data_lp2hs_settle_dc = 65,
+		.grabwindow_width = 3264,
+		.grabwindow_height = 2448,
+		.mipi_data_lp2hs_settle_dc = 14,
 		.max_framerate = 150,
 	},
 	.normal_video = {
@@ -90,9 +90,9 @@ static imgsensor_info_struct imgsensor_info = {
 		.framelength = 2512,
 		.startx = 0,
 		.starty = 0,
-		.grabwindow_width = 3200,
-		.grabwindow_height = 2400,
-		.mipi_data_lp2hs_settle_dc = 65,
+		.grabwindow_width = 3264,
+		.grabwindow_height = 2448,
+		.mipi_data_lp2hs_settle_dc = 14,
 		.max_framerate = 300,
 	},
 	.hs_video = {
@@ -103,7 +103,7 @@ static imgsensor_info_struct imgsensor_info = {
 		.starty = 0,
 		.grabwindow_width = 820,
 		.grabwindow_height = 616,
-		.mipi_data_lp2hs_settle_dc = 65,
+		.mipi_data_lp2hs_settle_dc = 14,
 		.max_framerate = 1200,
 	},
 	.slim_video = {
@@ -116,7 +116,7 @@ static imgsensor_info_struct imgsensor_info = {
 		//.grabwindow_height = 1200,		//record different mode's height of grabwindow
 		.grabwindow_width = 1280,
 		.grabwindow_height = 720,
-		.mipi_data_lp2hs_settle_dc = 65,
+		.mipi_data_lp2hs_settle_dc = 14,
 		.max_framerate = 300,
 	},
 	.margin = 16,
@@ -138,11 +138,11 @@ static imgsensor_info_struct imgsensor_info = {
 	.isp_driving_current = ISP_DRIVING_8MA,
 	.sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,
     .mipi_sensor_type = MIPI_OPHY_NCSI2, //0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2
-    .mipi_settle_delay_mode = 1,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
+    .mipi_settle_delay_mode = MIPI_SETTLEDELAY_AUTO,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
 	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_Gr,
 	.mclk = 24,
 	.mipi_lane_num = SENSOR_MIPI_4_LANE,
-	.i2c_addr_table = {0x20,0x30,0xff},
+	.i2c_addr_table = {0x20},
     .i2c_speed = 300, 
 };
 
@@ -440,7 +440,6 @@ static void sensor_init(void)
 static void preview_setting(void)
 { 
 		write_cmos_sensor(0x0100,0x00);
-		mdelay(60);
 		write_cmos_sensor(0x0101,0x00);
 		write_cmos_sensor(0x0204,0x00);
 		write_cmos_sensor(0x0205,0x20);
@@ -494,7 +493,7 @@ static void preview_setting(void)
 		write_cmos_sensor(0x3500,0x0C);
 		write_cmos_sensor(0x3C1A,0xA8);
 		write_cmos_sensor(0x3B29,0x01);//Caval 140613
-		write_cmos_sensor(0x3300,0x01);//Caval 140613			//20150309
+		write_cmos_sensor(0x3300,0x01);//Caval 140613	,20150526,01:lsc off		//20150309
 		write_cmos_sensor(0x3000,0x07);
 		write_cmos_sensor(0x3001,0x05);
 		write_cmos_sensor(0x3002,0x03);
@@ -566,9 +565,7 @@ static void preview_setting(void)
 		write_cmos_sensor(0x3216,0x21);
 		write_cmos_sensor(0x3217,0x02);
 		write_cmos_sensor(0x3218,0x21);
-		mdelay(60);
 		write_cmos_sensor(0x0100,0x01);
-		mdelay(60);
 	}   /*  S5K4H5YCMIPI_Capture_Setting  */
 
 static void capture_setting(kal_uint16 currefps)
@@ -576,7 +573,6 @@ static void capture_setting(kal_uint16 currefps)
     if (currefps == 150) 
 	{
 			write_cmos_sensor(0x0100, 0x00);
-			mdelay(50);
 			write_cmos_sensor(0x0101, 0x00);
 			write_cmos_sensor(0x0204, 0x00);
 			write_cmos_sensor(0x0205, 0x20);
@@ -698,14 +694,11 @@ static void capture_setting(kal_uint16 currefps)
 			write_cmos_sensor(0x3216, 0x21);
 			write_cmos_sensor(0x3217, 0x02);
 			write_cmos_sensor(0x3218, 0x21);
-			mdelay(60);
 			write_cmos_sensor(0x0100, 0x01);
-			mdelay(60);
 	}
 	else
 	{ 
 		write_cmos_sensor(0x0100,0x00);
-		mdelay(60);
 		write_cmos_sensor(0x0101,0x00);
 		write_cmos_sensor(0x0204,0x00);
 		write_cmos_sensor(0x0205,0x20);
@@ -883,15 +876,12 @@ static void capture_setting(kal_uint16 currefps)
 	write_cmos_sensor(0x3216,0x21);    // adc_offset_ms_even1 (LSB) 				   
 	write_cmos_sensor(0x3217,0x02);    // adc_offset_ms_odd1 (MSB)					   
 	write_cmos_sensor(0x3218,0x21);    // adc_offset_ms_odd1 (LSB)
-    mdelay(60);
 		write_cmos_sensor(0x0100,0x01);
-	mdelay(60);
 	}
 }
 static void normal_video_setting(kal_uint16 currefps)
 	{ 
 			LOG_INF("E! currefps:%d\n",currefps);
-			mdelay(50);
 			write_cmos_sensor(0x0100,0x00);
 			write_cmos_sensor(0x0101,0x00);
 			write_cmos_sensor(0x0204,0x00);
@@ -940,7 +930,7 @@ static void normal_video_setting(kal_uint16 currefps)
 		write_cmos_sensor(0x3500,0x0C);
 		write_cmos_sensor(0x3C1A,0xA8);
 	write_cmos_sensor(0x3B29,0x01); 	 // OTP enable
-		write_cmos_sensor(0x3300,0x01);//Caval 140613			//20150309	
+		write_cmos_sensor(0x3300,0x01);//Caval 140613		20150526,01:lsc off	//20150309	
 		write_cmos_sensor(0x3000,0x07);
 		write_cmos_sensor(0x3001,0x05);
 		write_cmos_sensor(0x3002,0x03);
@@ -1012,9 +1002,7 @@ static void normal_video_setting(kal_uint16 currefps)
 		write_cmos_sensor(0x3216,0x21);
 		write_cmos_sensor(0x3217,0x02);
 		write_cmos_sensor(0x3218,0x21);
-		mdelay(50);
 			write_cmos_sensor(0x0100,0x01);
-			mdelay(60);
 		}
 static void hs_video_setting() 
 {              LOG_INF("E//VGA 120fps");
@@ -1032,7 +1020,6 @@ static void hs_video_setting()
 			//$MIPI[Width:820,Height:616,Format:Raw10,Lane:4,ErrorCheck:0,PolarityData:0,PolarityClock:0,Buffer:4]
 
 			write_cmos_sensor(0x0100,0x00);       //Stream Off	[0]mode_select                                        
-			mdelay(50);
 			write_cmos_sensor(0x0101,0x00);       //Image  orientation	image_orientation ([0] mirror en, [1] flip en)
 			                       
 			write_cmos_sensor(0x0204,0x00);       //Analog Gain	analogue_gain_code_global H                         
@@ -1177,9 +1164,8 @@ static void hs_video_setting()
 			write_cmos_sensor(0x3216,0x21);
 			write_cmos_sensor(0x3217,0x02);
 			write_cmos_sensor(0x3218,0x21);
-			 mdelay(50);                 
+			                  
 			write_cmos_sensor(0x0100,0x01);
-			mdelay(60);
 	}
 
 static void slim_video_setting()
@@ -1203,7 +1189,7 @@ static void slim_video_setting()
 		
 		// Streaming off -----------------------------------
 		write_cmos_sensor(0x0100,0x00); 	//	[0] mode_select
-		mdelay(50);
+		
 		//Image  Orientation -------------------------------
 		write_cmos_sensor(0x0101,0x00); 	//	[1:0]	image_orientation ([0] mirror en, [1] flip en)
 		
@@ -1355,11 +1341,10 @@ static void slim_video_setting()
 		write_cmos_sensor(0x3217,0x02);    // adc_offset_ms_odd1 (MSB)					   
 		write_cmos_sensor(0x3218,0x21);    // adc_offset_ms_odd1 (LSB)
 		write_cmos_sensor(0x3B29,0x01); 	 // OTP enable
-		mdelay(50);
+		
 		
 		//Straming On -----------------------------------
 		write_cmos_sensor(0x0100,0x01);    // Streaming On
-		mdelay(60);
 		
 		}
 
@@ -1383,28 +1368,28 @@ static void slim_video_setting()
 static kal_uint32 get_imgsensor_id(UINT32 *sensor_id) 
 {
 	kal_uint8 i = 0;
-    int  retry = 2;
+    int  retry = 1;
 	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
-	while (imgsensor_info.i2c_addr_table[i] != 0xff) {
+	//while (imgsensor_info.i2c_addr_table[i] != 0xff) {
 		spin_lock(&imgsensor_drv_lock);
-		imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
+		imgsensor.i2c_write_id = 0x20;//imgsensor_info.i2c_addr_table[i];
 		spin_unlock(&imgsensor_drv_lock);
 		do {
 			*sensor_id = ((read_cmos_sensor(0x0000) << 8) | read_cmos_sensor(0x0001));
 			if (*sensor_id == imgsensor_info.sensor_id) {				
 				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);	  
-				return ERROR_NONE;
+				break;
 			}	
 			LOG_INF("Read sensor id fail, id: 0x%x,0x%x\n", imgsensor.i2c_write_id,*sensor_id);
 			retry--;
 		} while(retry > 0);
-		i++;
-		retry = 2;
-	}
+		//i++;
+		//retry = 2;
+//	}
 	if (*sensor_id != imgsensor_info.sensor_id) {
 		// if Sensor ID is not correct, Must set *sensor_id to 0xFFFFFFFF 
 		*sensor_id = 0xFFFFFFFF;
-		return ERROR_SENSOR_CONNECT_FAIL;
+		return ERROR_NONE;
 	}
 	return ERROR_NONE;
 }
@@ -1431,30 +1416,30 @@ static kal_uint32 open(void)
 {
 	//const kal_uint8 i2c_addr[] = {IMGSENSOR_WRITE_ID_1, IMGSENSOR_WRITE_ID_2};
 	kal_uint8 i = 0;
-	kal_uint8 retry = 2;
+	kal_uint8 retry = 1;
 	kal_uint16 sensor_id = 0; 
-	LOG_INF("PLATFORM:MT6595,MIPI 2LANE\n");
+	LOG_INF("PLATFORM:MT6735,MIPI 4LANE\n");
 	LOG_INF("preview 1280*960@30fps,864Mbps/lane; video 1280*960@30fps,864Mbps/lane; capture 5M@30fps,864Mbps/lane\n");
 	
 	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
-	while (imgsensor_info.i2c_addr_table[i] != 0xff) {
+	//while (imgsensor_info.i2c_addr_table[i] != 0xff) {
 		spin_lock(&imgsensor_drv_lock);
-		imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
+		imgsensor.i2c_write_id = 0x20;//imgsensor_info.i2c_addr_table[i];
 		spin_unlock(&imgsensor_drv_lock);
 		do {
 			sensor_id = ((read_cmos_sensor(0x0000) << 8) | read_cmos_sensor(0x0001));
 			if (sensor_id == imgsensor_info.sensor_id) {				
-				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x,0x%x\n", imgsensor.i2c_write_id,sensor_id);	  
+				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);	  
 				break;
 			}	
 			LOG_INF("Read sensor id fail, id: 0x%x,0x%x\n", imgsensor.i2c_write_id,sensor_id);
 			retry--;
 		} while(retry > 0);
-		i++;
-		if (sensor_id == imgsensor_info.sensor_id)
-			break;
-		retry = 2;
-	}		 
+		//i++;
+		//if (sensor_id == imgsensor_info.sensor_id)
+		//	break;
+		//retry = 2;
+	//}		 
 	if (imgsensor_info.sensor_id != sensor_id)
 		return ERROR_SENSOR_CONNECT_FAIL;
 
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k4h5yc_mipi_raw/s5k4h5ycmipiraw_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k4h5yc_mipi_raw/s5k4h5ycmipiraw_Sensor.h
old mode 100755
new mode 100644
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k5e2ya_mipi_raw/s5k5e2yamipiraw_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k5e2ya_mipi_raw/s5k5e2yamipiraw_Sensor.c
old mode 100644
new mode 100755
index 161aade..33a8957
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k5e2ya_mipi_raw/s5k5e2yamipiraw_Sensor.c
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k5e2ya_mipi_raw/s5k5e2yamipiraw_Sensor.c
@@ -145,7 +145,11 @@ static imgsensor_info_struct imgsensor_info = {
 	.sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,
 	.mipi_sensor_type = MIPI_OPHY_NCSI2, //0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2
 	.mipi_settle_delay_mode = MIPI_SETTLEDELAY_AUTO,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
+#ifdef VANZO_CAM_S5K5E2_RATION_180	
+	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_Gb,
+#else
 	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_Gr,
+#endif
 	.mclk = 24,
 	.mipi_lane_num = SENSOR_MIPI_2_LANE,
 	.i2c_addr_table = {0x20, 0x6c, 0xff},
@@ -1150,13 +1154,11 @@ static kal_uint32 get_imgsensor_id(UINT32 *sensor_id)
 		spin_unlock(&imgsensor_drv_lock);
 		do {
 			*sensor_id = return_sensor_id();
-			if(*sensor_id == 0x55a0)
-				*sensor_id = imgsensor_info.sensor_id;
 			if (*sensor_id == imgsensor_info.sensor_id) {				
 				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);	  
 				return ERROR_NONE;
 			}	
-			LOG_INF("Read sensor id fail, id: 0x%x, 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
+			LOG_INF("Read sensor id fail, id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
 			retry--;
 		} while(retry > 0);
 		i++;
@@ -1202,8 +1204,6 @@ static kal_uint32 open(void)
 		spin_unlock(&imgsensor_drv_lock);
 		do {
 			sensor_id = return_sensor_id();
-			if(sensor_id == 0x55a0)
-				sensor_id = imgsensor_info.sensor_id;
 			if (sensor_id == imgsensor_info.sensor_id) {				
 				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);	  
 				break;
@@ -1302,6 +1302,9 @@ static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 	imgsensor.autoflicker_en = KAL_FALSE;
 	spin_unlock(&imgsensor_drv_lock);
 	preview_setting();
+#ifdef VANZO_CAM_S5K5E2_RATION_180
+	set_mirror_flip(IMAGE_HV_MIRROR);
+#endif
 	return ERROR_NONE;
 }	/*	preview   */
 
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k5e2yasub_mipi_raw/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k5e2yasub_mipi_raw/Makefile
new file mode 100755
index 0000000..f276688
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k5e2yasub_mipi_raw/Makefile
@@ -0,0 +1,4 @@
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+
+obj-y += s5k5e2yasubmipiraw_Sensor.o
+
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k5e2yasub_mipi_raw/s5k5e2yasubmipiraw_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k5e2yasub_mipi_raw/s5k5e2yasubmipiraw_Sensor.c
new file mode 100755
index 0000000..ea43d95
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k5e2yasub_mipi_raw/s5k5e2yasubmipiraw_Sensor.c
@@ -0,0 +1,1868 @@
+/* *****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *	 s5k5e2yasubmipi_Sensor.c
+ *
+ * Project:
+ * --------
+ *	 ALPS
+ *
+ * Description:
+ * ------------
+ *	 Source code of Sensor driver
+ *
+ *
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *============================================================================
+ ****************************************************************************/
+
+#include <linux/videodev2.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <asm/atomic.h>
+//#include <asm/system.h>
+#include <linux/xlog.h>
+
+#include "kd_camera_hw.h"
+#include "kd_imgsensor.h"
+#include "kd_imgsensor_define.h"
+#include "kd_imgsensor_errcode.h"
+
+#include "s5k5e2yasubmipiraw_Sensor.h"
+
+/****************************Modify following Strings for debug****************************/
+#define PFX "s5k5e2ya_camera_sensor"
+#define LOG_1 LOG_INF("s5k5e2yasub,MIPI 2LANE\n")
+#define LOG_2 LOG_INF("preview 1280*960@30fps,864Mbps/lane; video 1280*960@30fps,864Mbps/lane; capture 5M@30fps,864Mbps/lane\n")
+/****************************   Modify end    *******************************************/
+#define LOG_INF(format, args...)	xlog_printk(ANDROID_LOG_INFO   , PFX, "[%s] " format, __FUNCTION__, ##args)
+
+static DEFINE_SPINLOCK(imgsensor_drv_lock);
+
+#define MIPI_SETTLEDELAY_AUTO     0
+#define MIPI_SETTLEDELAY_MANNUAL  1
+
+
+//#define CAPTURE_24FPS
+
+
+static imgsensor_info_struct imgsensor_info = { 
+	.sensor_id = S5K5E2YASUB_SENSOR_ID,
+	
+	.checksum_value = 0x87e356d9,
+	
+	.pre = {
+		.pclk = 179200000,				//record different mode's pclk
+		.linelength = 2950,				//record different mode's linelength
+		.framelength = 2000,			//record different mode's framelength
+		.startx = 0,					//record different mode's startx of grabwindow
+		.starty = 0,					//record different mode's starty of grabwindow
+		.grabwindow_width = 1280,		//record different mode's width of grabwindow
+		.grabwindow_height = 960,		//record different mode's height of grabwindow
+		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
+		.mipi_data_lp2hs_settle_dc = 23,
+		/*	 following for GetDefaultFramerateByScenario()	*/
+		.max_framerate = 300,	
+	},
+	.cap = {
+		.pclk = 179200000,
+		.linelength = 2950,
+		.framelength = 2025,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 2560,
+		.grabwindow_height = 1920,
+		.mipi_data_lp2hs_settle_dc = 23,
+		.max_framerate = 300,
+	},
+	.cap1 = {
+		.pclk = 89616000,
+		.linelength = 2950,
+		.framelength = 2025,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 2560,
+		.grabwindow_height = 1920,
+		.mipi_data_lp2hs_settle_dc = 23,
+		.max_framerate = 150,	
+	},
+	.normal_video = {
+		.pclk = 179200000,
+		.linelength = 2950,
+		.framelength = 2000,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 2560,
+		.grabwindow_height = 1440,
+		.mipi_data_lp2hs_settle_dc = 23,
+		.max_framerate = 300,
+	},
+	.hs_video = {
+		.pclk = 179200000,
+		.linelength = 2950,
+		.framelength = 506,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 640,
+		.grabwindow_height = 480,
+		.mipi_data_lp2hs_settle_dc = 23,
+		.max_framerate = 1200,
+	},
+	.slim_video = {
+		.pclk = 179200000,
+		.linelength = 2950,
+		.framelength = 2000,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 1280,
+		.grabwindow_height = 720,
+		.mipi_data_lp2hs_settle_dc = 23,
+		.max_framerate = 300,
+	},
+	.margin = 4,
+	.min_shutter = 1,
+	.max_frame_length = 0xffff,
+	.ae_shut_delay_frame = 0,
+	.ae_sensor_gain_delay_frame = 1,
+	.ae_ispGain_delay_frame = 2,
+	.ihdr_support = 0,	  //1, support; 0,not support
+	.ihdr_le_firstline = 0,  //1,le first ; 0, se first
+	.sensor_mode_num = 5,	  //support sensor mode num
+	
+	.cap_delay_frame = 3, 
+	.pre_delay_frame = 3, 
+	.video_delay_frame = 3,
+	.hs_video_delay_frame = 3,
+	.slim_video_delay_frame = 3,
+	
+	.isp_driving_current = ISP_DRIVING_6MA,
+	.sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,
+	.mipi_sensor_type = MIPI_OPHY_NCSI2, //0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2
+	.mipi_settle_delay_mode = MIPI_SETTLEDELAY_AUTO,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
+	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_Gr,
+	.mclk = 24,
+	.mipi_lane_num = SENSOR_MIPI_2_LANE,
+	.i2c_addr_table = {0x20, 0x6c, 0xff},
+};
+
+
+static imgsensor_struct imgsensor = {
+	.mirror = IMAGE_NORMAL,				//mirrorflip information
+	.sensor_mode = IMGSENSOR_MODE_INIT, //IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
+	.shutter = 0x3D0,					//current shutter
+	.gain = 0x100,						//current gain
+	.dummy_pixel = 0,					//current dummypixel
+	.dummy_line = 0,					//current dummyline
+	.current_fps = 0,  //full size current fps : 24fps for PIP, 30fps for Normal or ZSD
+	.autoflicker_en = KAL_FALSE,  //auto flicker enable: KAL_FALSE for disable auto flicker, KAL_TRUE for enable auto flicker
+	.test_pattern = KAL_FALSE,		//test pattern mode or not. KAL_FALSE for in test pattern mode, KAL_TRUE for normal output
+	.current_scenario_id = MSDK_SCENARIO_ID_CAMERA_PREVIEW,//current scenario id
+	.ihdr_en = 0, //sensor need support LE, SE with HDR feature
+	.i2c_write_id = 0x20,
+};
+
+
+/* Sensor output window information */
+static SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[5] =	 
+{{ 2576, 1936,	  8,	8, 2560, 1920, 1280,  960, 0000, 0000, 1280,  960,	  0,	0, 1280,  960}, // Preview 
+ { 2576, 1936,	  8,	8, 2560, 1920, 2560, 1920, 0000, 0000, 2560, 1920,	  0,	0, 2560, 1920}, // capture 
+ { 2576, 1936,	  8,  248, 2560, 1440, 2560, 1440, 0000, 0000, 2560, 1440,	  0,	0, 2560, 1440}, // video 
+ { 2576, 1936,	  8,    8, 2560, 1440,  640,  480, 0000, 0000,  640,  480,	  0,	0,  640,  480}, //hight speed video 
+ { 2576, 1936,	  8,  248, 2560, 1440, 1280,  720, 0000, 0000, 1280,  720,	  0,	0, 1280,  720}};// slim video 
+
+
+static kal_uint16 read_cmos_sensor(kal_uint32 addr)
+{
+	kal_uint16 get_byte=0;
+
+	char pu_send_cmd[2] = {(char)(addr >> 8), (char)(addr & 0xFF) };
+	iReadRegI2C(pu_send_cmd, 2, (u8*)&get_byte, 1, imgsensor.i2c_write_id);
+
+	return get_byte;
+}
+
+static void write_cmos_sensor(kal_uint32 addr, kal_uint32 para)
+{
+	char pu_send_cmd[3] = {(char)(addr >> 8), (char)(addr & 0xFF), (char)(para & 0xFF)};
+	iWriteRegI2C(pu_send_cmd, 3, imgsensor.i2c_write_id);
+}
+
+static void write_cmos_sensor_8(kal_uint16 addr, kal_uint8 para)
+{
+    char pusendcmd[4] = {(char)(addr >> 8) , (char)(addr & 0xFF) ,(char)(para & 0xFF)};
+    iWriteRegI2C(pusendcmd , 3, imgsensor.i2c_write_id);
+}
+
+
+static void set_dummy()
+{
+	LOG_INF("dummyline = %d, dummypixels = %d \n", imgsensor.dummy_line, imgsensor.dummy_pixel);
+
+	write_cmos_sensor(0x0340, imgsensor.frame_length >> 8);
+	write_cmos_sensor(0x0341, imgsensor.frame_length & 0xFF);	  
+	write_cmos_sensor(0x0342, imgsensor.line_length >> 8);
+	write_cmos_sensor(0x0343, imgsensor.line_length & 0xFF);
+  
+}	/*	set_dummy  */
+
+static kal_uint32 return_sensor_id()
+{
+	return ((read_cmos_sensor(0x0000) << 8) | read_cmos_sensor(0x0001)) + 1;
+	
+}
+
+
+static void set_max_framerate(UINT16 framerate,kal_bool min_framelength_en)
+{
+	kal_int16 dummy_line;
+	kal_uint32 frame_length = imgsensor.frame_length;
+	//unsigned long flags;
+
+	LOG_INF("framerate = %d, min framelength should enable? \n", framerate,min_framelength_en);
+   
+	frame_length = imgsensor.pclk / framerate * 10 / imgsensor.line_length;
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.frame_length = (frame_length > imgsensor.min_frame_length) ? frame_length : imgsensor.min_frame_length; 
+	imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
+	//dummy_line = frame_length - imgsensor.min_frame_length;
+	//if (dummy_line < 0)
+		//imgsensor.dummy_line = 0;
+	//else
+		//imgsensor.dummy_line = dummy_line;
+	//imgsensor.frame_length = frame_length + imgsensor.dummy_line;
+	if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+	{
+		imgsensor.frame_length = imgsensor_info.max_frame_length;
+		imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
+	}
+	if (min_framelength_en)
+		imgsensor.min_frame_length = imgsensor.frame_length;
+	spin_unlock(&imgsensor_drv_lock);
+	set_dummy();
+}	/*	set_max_framerate  */
+
+
+static void write_shutter(kal_uint16 shutter)
+{
+	kal_uint16 realtime_fps = 0;
+	kal_uint32 frame_length = 0;
+	   
+	/* 0x3500, 0x3501, 0x3502 will increase VBLANK to get exposure larger than frame exposure */
+	/* AE doesn't update sensor gain at capture mode, thus extra exposure lines must be updated here. */
+	
+	// OV Recommend Solution
+	// if shutter bigger than frame_length, should extend frame length first
+	spin_lock(&imgsensor_drv_lock);
+	if (shutter > imgsensor.min_frame_length - imgsensor_info.margin)		
+		imgsensor.frame_length = shutter + imgsensor_info.margin;
+	else
+		imgsensor.frame_length = imgsensor.min_frame_length;
+	if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+		imgsensor.frame_length = imgsensor_info.max_frame_length;
+	spin_unlock(&imgsensor_drv_lock);
+	shutter = (shutter < imgsensor_info.min_shutter) ? imgsensor_info.min_shutter : shutter;
+	shutter = (shutter > (imgsensor_info.max_frame_length - imgsensor_info.margin)) ? (imgsensor_info.max_frame_length - imgsensor_info.margin) : shutter;
+	
+	if (imgsensor.autoflicker_en) { 
+		realtime_fps = imgsensor.pclk / imgsensor.line_length * 10 / imgsensor.frame_length;
+		if(realtime_fps >= 297 && realtime_fps <= 305)
+			set_max_framerate(296,0);
+		else if(realtime_fps >= 147 && realtime_fps <= 150)
+			set_max_framerate(146,0);	
+		else {
+		// Extend frame length
+		write_cmos_sensor(0x0340, imgsensor.frame_length >> 8);
+		write_cmos_sensor(0x0341, imgsensor.frame_length & 0xFF);
+		}
+	} else {
+		// Extend frame length
+		write_cmos_sensor(0x0340, imgsensor.frame_length >> 8);
+		write_cmos_sensor(0x0341, imgsensor.frame_length & 0xFF);
+	}
+
+	// Update Shutter
+	//write_cmos_sensor(0x0104, 0x01);   //group hold
+	write_cmos_sensor(0x0202, shutter >> 8);
+	write_cmos_sensor(0x0203, shutter & 0xFF);	
+	//write_cmos_sensor(0x0104, 0x00);   //group hold
+	
+	LOG_INF("shutter =%d, framelength =%d\n", shutter,imgsensor.frame_length);
+
+	//LOG_INF("frame_length = %d ", frame_length);
+	
+}	/*	write_shutter  */
+
+
+
+/*************************************************************************
+* FUNCTION
+*	set_shutter
+*
+* DESCRIPTION
+*	This function set e-shutter of sensor to change exposure time.
+*
+* PARAMETERS
+*	iShutter : exposured lines
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static void set_shutter(kal_uint16 shutter)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&imgsensor_drv_lock, flags);
+	imgsensor.shutter = shutter;
+	spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
+	
+	write_shutter(shutter);
+}	/*	set_shutter */
+
+
+
+static kal_uint16 gain2reg(const kal_uint16 gain)
+{
+	return gain>>1;
+}
+
+/*************************************************************************
+* FUNCTION
+*	set_gain
+*
+* DESCRIPTION
+*	This function is to set global gain to sensor.
+*
+* PARAMETERS
+*	iGain : sensor global gain(base: 0x40)
+*
+* RETURNS
+*	the actually gain set to sensor.
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint16 set_gain(kal_uint16 gain)
+{
+	kal_uint16 reg_gain;
+
+	/* 0x350A[0:1], 0x350B[0:7] AGC real gain */
+	/* [0:3] = N meams N /16 X	*/
+	/* [4:9] = M meams M X		 */
+	/* Total gain = M + N /16 X   */
+
+	//
+	
+ 
+	reg_gain = gain>>1;
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.gain = reg_gain; 
+	spin_unlock(&imgsensor_drv_lock);
+	LOG_INF("gain = %d , reg_gain = 0x%x\n ", gain, reg_gain);
+
+	//write_cmos_sensor(0x0104, 0x01);   //group hold
+	write_cmos_sensor(0x0204, reg_gain >> 8);
+	write_cmos_sensor(0x0205, reg_gain & 0xFF);  
+	//write_cmos_sensor(0x0104, 0x00);
+	
+	return gain;
+}	/*	set_gain  */
+
+
+
+//defined but not used
+static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gain)
+{
+	LOG_INF("le:0x%x, se:0x%x, gain:0x%x\n",le,se,gain);
+	if (imgsensor.ihdr_en) {
+		
+		spin_lock(&imgsensor_drv_lock);
+			if (le > imgsensor.min_frame_length - imgsensor_info.margin)		
+				imgsensor.frame_length = le + imgsensor_info.margin;
+			else
+				imgsensor.frame_length = imgsensor.min_frame_length;
+			if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+				imgsensor.frame_length = imgsensor_info.max_frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			if (le < imgsensor_info.min_shutter) le = imgsensor_info.min_shutter;
+			if (se < imgsensor_info.min_shutter) se = imgsensor_info.min_shutter;
+			
+			
+				// Extend frame length first
+				write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
+				write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
+
+		write_cmos_sensor(0x3502, (le << 4) & 0xFF);
+		write_cmos_sensor(0x3501, (le >> 4) & 0xFF);	 
+		write_cmos_sensor(0x3500, (le >> 12) & 0x0F);
+		
+		write_cmos_sensor(0x3508, (se << 4) & 0xFF); 
+		write_cmos_sensor(0x3507, (se >> 4) & 0xFF);
+		write_cmos_sensor(0x3506, (se >> 12) & 0x0F); 
+
+		set_gain(gain);
+	}
+
+}
+
+
+
+static void set_mirror_flip(kal_uint8 image_mirror)
+{
+	LOG_INF("image_mirror = %d\n", image_mirror);
+
+	/********************************************************
+	   *
+	   *   0x3820[2] ISP Vertical flip
+	   *   0x3820[1] Sensor Vertical flip
+	   *
+	   *   0x3821[2] ISP Horizontal mirror
+	   *   0x3821[1] Sensor Horizontal mirror
+	   *
+	   *   ISP and Sensor flip or mirror register bit should be the same!!
+	   *
+	   ********************************************************/
+	
+	switch (image_mirror) {
+		case IMAGE_NORMAL:
+			write_cmos_sensor(0x0101,0x00);
+			break;
+		case IMAGE_H_MIRROR:
+			write_cmos_sensor(0x0101,0x01);
+			break;
+		case IMAGE_V_MIRROR:
+			write_cmos_sensor(0x0101,0x02);		
+			break;
+		case IMAGE_HV_MIRROR:
+			write_cmos_sensor(0x0101,0x03);
+			break;
+		default:
+			LOG_INF("Error image_mirror setting\n");
+	}
+
+}
+
+/*************************************************************************
+* FUNCTION
+*	night_mode
+*
+* DESCRIPTION
+*	This function night mode of sensor.
+*
+* PARAMETERS
+*	bEnable: KAL_TRUE -> enable night mode, otherwise, disable night mode
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static void night_mode(kal_bool enable)
+{
+/*No Need to implement this function*/ 
+}	/*	night_mode	*/
+
+static void sensor_init(void)
+{
+	LOG_INF("E\n");
+
+   // +++++++++++++++++++++++++++//                                                               
+	// Reset for operation                                                                         
+	write_cmos_sensor(0x0100,0x00); //stream off
+	
+	// Clock Setting
+	write_cmos_sensor(0x3000,0x04);       //   ct_ld_start                                    
+	write_cmos_sensor(0x3002,0x03);       //   ct_sl_start                                    
+	write_cmos_sensor(0x3003,0x04);       //   ct_sl_margin                                   
+	write_cmos_sensor(0x3004,0x02);       //   ct_rx_start                                    
+	write_cmos_sensor(0x3005,0x00);       //   ct_rx_margin (MSB)                             
+	write_cmos_sensor(0x3006,0x10);       //   ct_rx_margin (LSB)                             
+	write_cmos_sensor(0x3007,0x03);       //   ct_tx_start                                    
+	write_cmos_sensor(0x3008,0x55);       //   ct_tx_width                                    
+	write_cmos_sensor(0x3039,0x00);       //   cintc1_margin (10 --> 00)                      
+	write_cmos_sensor(0x303A,0x00);       //   cintc2_margin (10 --> 00)                      
+	write_cmos_sensor(0x303B,0x00);       //   offs_sh                                        
+	write_cmos_sensor(0x3009,0x05);       //   ct_srx_margin                                  
+	write_cmos_sensor(0x300A,0x55);       //   ct_stx_width                                   
+	write_cmos_sensor(0x300B,0x38);       //   ct_dstx_width                                  
+	write_cmos_sensor(0x300C,0x10);       //   ct_stx2dstx                                    
+	write_cmos_sensor(0x3012,0x05);       //   ct_cds_start                                   
+	write_cmos_sensor(0x3013,0x00);       //   ct_s1s_start                                   
+	write_cmos_sensor(0x3014,0x22);       //   ct_s1s_end                                     
+	write_cmos_sensor(0x300E,0x79);       //   ct_s3_width                                    
+	write_cmos_sensor(0x3010,0x68);       //   ct_s4_width                                    
+	write_cmos_sensor(0x3019,0x03);       //   ct_s4d_start                                   
+	write_cmos_sensor(0x301A,0x00);       //   ct_pbr_start                                   
+	write_cmos_sensor(0x301B,0x06);       //   ct_pbr_width                                   
+	write_cmos_sensor(0x301C,0x00);       //   ct_pbs_start                                   
+	write_cmos_sensor(0x301D,0x22);       //   ct_pbs_width                                   
+	write_cmos_sensor(0x301E,0x00);       //   ct_pbr_ob_start                                
+	write_cmos_sensor(0x301F,0x10);       //   ct_pbr_ob_width                                
+	write_cmos_sensor(0x3020,0x00);       //   ct_pbs_ob_start                                
+	write_cmos_sensor(0x3021,0x00);       //   ct_pbs_ob_width                                
+	write_cmos_sensor(0x3022,0x0A);       //   ct_cds_lim_start                               
+	write_cmos_sensor(0x3023,0x1E);       //   ct_crs_start                                   
+	write_cmos_sensor(0x3024,0x00);       //   ct_lp_hblk_cds_start (MSB)                     
+	write_cmos_sensor(0x3025,0x00);       //   ct_lp_hblk_cds_start (LSB)                     
+	write_cmos_sensor(0x3026,0x00);       //   ct_lp_hblk_cds_end (MSB)                       
+	write_cmos_sensor(0x3027,0x00);       //   ct_lp_hblk_cds_end (LSB)                       
+	write_cmos_sensor(0x3028,0x1A);       //   ct_rmp_off_start                               
+	write_cmos_sensor(0x3015,0x00);       //   ct_rmp_rst_start (MSB)                         
+	write_cmos_sensor(0x3016,0x84);       //   ct_rmp_rst_start (LSB)                         
+	write_cmos_sensor(0x3017,0x00);       //   ct_rmp_sig_start (MSB)                         
+	write_cmos_sensor(0x3018,0xA0);       //   ct_rmp_sig_start (LSB)                         
+	write_cmos_sensor(0x302B,0x10);       //   ct_cnt_margin                                  
+	write_cmos_sensor(0x302C,0x0A);       //   ct_rmp_per                                     
+	write_cmos_sensor(0x302D,0x06);       //   ct_cnt_ms_margin1                              
+	write_cmos_sensor(0x302E,0x05);       //   ct_cnt_ms_margin2                              
+	write_cmos_sensor(0x302F,0x0E);       //   rst_mx                                         
+	write_cmos_sensor(0x3030,0x2F);       //   sig_mx                                         
+	write_cmos_sensor(0x3031,0x08);       //   ct_latch_start                                 
+	write_cmos_sensor(0x3032,0x05);       //   ct_latch_width                                 
+	write_cmos_sensor(0x3033,0x09);       //   ct_hold_start                                  
+	write_cmos_sensor(0x3034,0x05);       //   ct_hold_width                                  
+	write_cmos_sensor(0x3035,0x00);       //   ct_lp_hblk_dbs_start (MSB)                     
+	write_cmos_sensor(0x3036,0x00);       //   ct_lp_hblk_dbs_start (LSB)                     
+	write_cmos_sensor(0x3037,0x00);       //   ct_lp_hblk_dbs_end (MSB)                       
+	write_cmos_sensor(0x3038,0x00);       //   ct_lp_hblk_dbs_end (LSB)                       
+	write_cmos_sensor(0x3088,0x06);       //   ct_lat_lsb_offset_start1                       
+	write_cmos_sensor(0x308A,0x08);       //   ct_lat_lsb_offset_end1                         
+	write_cmos_sensor(0x308C,0x05);       //   ct_lat_lsb_offset_start2                       
+	write_cmos_sensor(0x308E,0x07);       //   ct_lat_lsb_offset_end2                         
+	write_cmos_sensor(0x3090,0x06);       //   ct_conv_en_offset_start1                       
+	write_cmos_sensor(0x3092,0x08);       //   ct_conv_en_offset_end1                         
+	write_cmos_sensor(0x3094,0x05);       //   ct_conv_en_offset_start2                       
+	write_cmos_sensor(0x3096,0x21);       //   ct_conv_en_offset_end2                         
+	write_cmos_sensor(0x3099,0x0E);       //  cds_option ([3]:crs switch disable, s3,s4 streng
+	write_cmos_sensor(0x3070,0x10);       //  comp1_bias (default:77)                         
+	write_cmos_sensor(0x3085,0x11);       //  comp1_bias (gain1~4)                            
+	write_cmos_sensor(0x3086,0x01);       //  comp1_bias (gain4~8) modified 813               
+                         
+	write_cmos_sensor(0x3064,0x00);       //  Multiple sampling(gainx8,x16)                   
+	write_cmos_sensor(0x3062,0x08);       //  off_rst                                         
+	write_cmos_sensor(0x3061,0x11);       //  dbr_tune_rd (default :08)                       
+	write_cmos_sensor(0x307B,0x20);       //  dbr_tune_rgsl (default :08)                     
+	write_cmos_sensor(0x3068,0x00);       //  RMP BP bias sampling                            
+	write_cmos_sensor(0x3074,0x00);       //  Pixel bias sampling [2]:Default L               
+	write_cmos_sensor(0x307D,0x00);       //  VREF sampling [1]                               
+	write_cmos_sensor(0x3045,0x01);       //  ct_opt_l1_start                                 
+	write_cmos_sensor(0x3046,0x05);       //  ct_opt_l1_width                                 
+	write_cmos_sensor(0x3047,0x78);                                               
+	write_cmos_sensor(0x307F,0xB1);       // RDV_OPTION[5:4], RG default high                 
+	write_cmos_sensor(0x3098,0x01);       // CDS_OPTION[16] SPLA-II enable                    
+	write_cmos_sensor(0x305C,0xF6);       // lob_extension[6]                                 
+	write_cmos_sensor(0x306B,0x10);                                                 
+	write_cmos_sensor(0x3063,0x27);       //  ADC_SAT 490mV --> 610mV                         
+	write_cmos_sensor(0x3400,0x01);       //  GAS bypass                                      
+	write_cmos_sensor(0x3235,0x49);       //  L/F-ADLC on                                     
+	write_cmos_sensor(0x3233,0x00);       //  D-pedestal L/F ADLC off (1FC0h)                 
+	write_cmos_sensor(0x3234,0x00);                                                 
+	write_cmos_sensor(0x3300,0x0C);       // BPC bypass                                       
+                             
+	write_cmos_sensor(0x3203,0x45);       // ADC_OFFSET_EVEN                                  
+	write_cmos_sensor(0x3205,0x4D);       // ADC_OFFSET_ODD                                   
+	write_cmos_sensor(0x320B,0x40);       // ADC_DEFAULT                                      
+	write_cmos_sensor(0x320C,0x06);       // ADC_MAX                                          
+	write_cmos_sensor(0x320D,0xC0);  
+
+	write_cmos_sensor(0x3929,0x07);       //set mipi non-continue mode
+ 	
+	// streaming ON
+	write_cmos_sensor(0x0100,0x01); 
+}	/*	sensor_init  */
+
+
+static void preview_setting(void)
+{
+	// +++++++++++++++++++++++++++//                                                               
+	// Reset for operation                                                                         
+	write_cmos_sensor(0x0100,0x00); //stream off
+	
+	// Clock Setting
+	write_cmos_sensor(0x0305,0x06); //PLLP (def:5)
+	write_cmos_sensor(0x0306,0x00);
+	write_cmos_sensor(0x0307,0xE0); //PLLM (def:CCh 204d --> B3h 179d)
+	write_cmos_sensor(0x3C1F,0x00); //PLLS 
+	
+	write_cmos_sensor(0x0820,0x03); // requested link bit rate mbps : (def:3D3h 979d --> 35Bh 859d)
+	write_cmos_sensor(0x0821,0x80); 
+	write_cmos_sensor(0x3C1C,0x58); //dbr_div
+	
+	write_cmos_sensor(0x0114,0x01);  //Lane mode
+	
+	// Size Setting
+	write_cmos_sensor(0x0340,0x07); // frame_length_lines : def. 990d (--> 3C8 Mimnimum 22 lines)
+	write_cmos_sensor(0x0341,0xD0);
+	write_cmos_sensor(0x0342,0x0B); // line_length_pck : def. 2900d 
+	write_cmos_sensor(0x0343,0x86);
+	
+	write_cmos_sensor(0x0344,0x00); // x_addr_start
+	write_cmos_sensor(0x0345,0x08); 
+	write_cmos_sensor(0x0346,0x00); // y_addr_start
+	write_cmos_sensor(0x0347,0x08); 
+	write_cmos_sensor(0x0348,0x0A); // x_addr_end : def. 2575d  
+	write_cmos_sensor(0x0349,0x07); 
+	write_cmos_sensor(0x034A,0x07); // y_addr_end : def. 1936d
+	write_cmos_sensor(0x034B,0x87); 
+	write_cmos_sensor(0x034C,0x05); // x_output size : def. 1288d
+	write_cmos_sensor(0x034D,0x00); 
+	write_cmos_sensor(0x034E,0x03); // y_output size : def. 968d
+	write_cmos_sensor(0x034F,0xC0); 
+	
+	
+	//Digital Binning
+	write_cmos_sensor(0x0900,0x01);	//2x2 Binning
+	write_cmos_sensor(0x0901,0x22);
+	write_cmos_sensor(0x0383,0x01);
+	write_cmos_sensor(0x0387,0x03);
+	
+	//Integration time	
+	write_cmos_sensor(0x0202,0x02);  // coarse integration
+	write_cmos_sensor(0x0203,0x00);
+	write_cmos_sensor(0x0200,0x04);  // fine integration (AA8h --> AC4h)
+	write_cmos_sensor(0x0201,0x98);
+	
+	write_cmos_sensor(0x3407,0x00);
+	write_cmos_sensor(0x3408,0x00);
+	write_cmos_sensor(0x3409,0x00);
+	write_cmos_sensor(0x340A,0x00);
+	write_cmos_sensor(0x340B,0x00);
+	write_cmos_sensor(0x340C,0x00);
+	write_cmos_sensor(0x340D,0x00);
+	write_cmos_sensor(0x340E,0x00);
+	write_cmos_sensor(0x3401,0x50);
+	write_cmos_sensor(0x3402,0x3C);
+	write_cmos_sensor(0x3403,0x03);
+	write_cmos_sensor(0x3404,0x33);
+	write_cmos_sensor(0x3405,0x04);
+	write_cmos_sensor(0x3406,0x44);
+	write_cmos_sensor(0x3458,0x03);
+	write_cmos_sensor(0x3459,0x33);
+	write_cmos_sensor(0x345A,0x04);
+	write_cmos_sensor(0x345B,0x44);
+	write_cmos_sensor(0x3400,0x01);
+	
+	// streaming ON
+	write_cmos_sensor(0x0100,0x01); 	 
+}	/*	preview_setting  */
+
+static void capture_setting(kal_uint16 currefps)
+{
+	LOG_INF("E! currefps:%d\n",currefps);
+	if (currefps == 150) { //15fps for PIP
+	// +++++++++++++++++++++++++++//                                                               
+	// Reset for operation                                                                         
+	write_cmos_sensor(0x0100,0x00); //stream off
+
+	
+	// Clock Setting
+	write_cmos_sensor(0x0305,0x06); //PLLP (def:5)
+	write_cmos_sensor(0x0306,0x00);
+	write_cmos_sensor(0x0307,0xDA); //PLLM (def:CCh 204d --> B3h 179d)
+	write_cmos_sensor(0x3C1F,0x01); //PLLS 
+	
+	//S30CCC0 //dphy_band_ctrl
+	
+	write_cmos_sensor(0x0820,0x01); // requested link bit rate mbps : (def:3D3h 979d --> 35Bh 859d)
+	write_cmos_sensor(0x0821,0xB4); 
+	write_cmos_sensor(0x3C1C,0x54); //dbr_div
+	
+	write_cmos_sensor(0x0114,0x01);  //Lane mode
+	
+	// Size Setting
+	write_cmos_sensor(0x0340,0x07); // frame_length_lines : def. 1962d (7C2 --> 7A6 Mimnimum 22 lines)
+	write_cmos_sensor(0x0341,0xE9);
+	write_cmos_sensor(0x0342,0x0B); // line_length_pck : def. 2900d 
+	write_cmos_sensor(0x0343,0x86);
+	
+	write_cmos_sensor(0x0344,0x00); // x_addr_start
+	write_cmos_sensor(0x0345,0x08); 
+	write_cmos_sensor(0x0346,0x00); // y_addr_start
+	write_cmos_sensor(0x0347,0x08); 
+	write_cmos_sensor(0x0348,0x0A); // x_addr_end : def. 2575d  
+	write_cmos_sensor(0x0349,0x07); 
+	write_cmos_sensor(0x034A,0x07); // y_addr_end : def. 1936d
+	write_cmos_sensor(0x034B,0x87); 
+	write_cmos_sensor(0x034C,0x0A); // x_output size : def. 2560d 
+	write_cmos_sensor(0x034D,0x00); 
+	write_cmos_sensor(0x034E,0x07); // y_output size : def. 1920d
+	write_cmos_sensor(0x034F,0x80); 
+	
+	//Digital Binning(default)
+	write_cmos_sensor(0x0900,0x00);	//0x0 Binning
+	write_cmos_sensor(0x0901,0x20);
+	write_cmos_sensor(0x0383,0x01);
+	write_cmos_sensor(0x0387,0x01);
+	
+	
+	//Integration time	
+	write_cmos_sensor(0x0202,0x02);  // coarse integration
+	write_cmos_sensor(0x0203,0x00);
+	write_cmos_sensor(0x0200,0x04);  // fine integration (AA8h --> AC4h)
+	write_cmos_sensor(0x0201,0x98);
+	
+	write_cmos_sensor(0x3407,0x00);
+	write_cmos_sensor(0x3408,0x00);
+	write_cmos_sensor(0x3409,0x00);
+	write_cmos_sensor(0x340A,0x00);
+	write_cmos_sensor(0x340B,0x00);
+	write_cmos_sensor(0x340C,0x00);
+	write_cmos_sensor(0x340D,0x00);
+	write_cmos_sensor(0x340E,0x00);
+	write_cmos_sensor(0x3401,0x50);
+	write_cmos_sensor(0x3402,0x3C);
+	write_cmos_sensor(0x3403,0x03);
+	write_cmos_sensor(0x3404,0x33);
+	write_cmos_sensor(0x3405,0x04);
+	write_cmos_sensor(0x3406,0x44);
+	write_cmos_sensor(0x3458,0x03);
+	write_cmos_sensor(0x3459,0x33);
+	write_cmos_sensor(0x345A,0x04);
+	write_cmos_sensor(0x345B,0x44);
+	write_cmos_sensor(0x3400,0x01);
+	
+	// streaming ON
+	write_cmos_sensor(0x0100,0x01); 
+	}
+	else{// Reset for operation     30fps for normal capture                                                                    
+	write_cmos_sensor(0x0100,0x00); //stream off
+	mdelay(40);
+	
+	// Clock Setting
+	write_cmos_sensor(0x0305,0x06); //PLLP (def:5)
+	write_cmos_sensor(0x0306,0x00);
+	write_cmos_sensor(0x0307,0xE0); //PLLM (def:CCh 204d --> B3h 179d)
+	write_cmos_sensor(0x3C1F,0x00); //PLLS 
+	
+	//S3CC0 //dphy_band_ctrl
+	
+	write_cmos_sensor(0x0820,0x03); // requested link bit rate mbps : (def:3D3h 979d --> 35Bh 859d)
+	write_cmos_sensor(0x0821,0x80); 
+	write_cmos_sensor(0x3C1C,0x58); //dbr_div
+	
+	write_cmos_sensor(0x0114,0x01);  //Lane mode
+	
+	// Size Setting
+	write_cmos_sensor(0x0340,0x07); // frame_length_lines : def. 1962d (7C2 --> 7A6 Mimnimum 22 lines)
+	write_cmos_sensor(0x0341,0xE9);
+	write_cmos_sensor(0x0342,0x0B); // line_length_pck : def. 2900d 
+	write_cmos_sensor(0x0343,0x86);
+	
+	write_cmos_sensor(0x0344,0x00); // x_addr_start
+	write_cmos_sensor(0x0345,0x08); 
+	write_cmos_sensor(0x0346,0x00); // y_addr_start
+	write_cmos_sensor(0x0347,0x08); 
+	write_cmos_sensor(0x0348,0x0A); // x_addr_end : def. 2575d  
+	write_cmos_sensor(0x0349,0x07); 
+	write_cmos_sensor(0x034A,0x07); // y_addr_end : def. 1936d
+	write_cmos_sensor(0x034B,0x87); 
+	write_cmos_sensor(0x034C,0x0A); // x_output size : def. 2560d 
+	write_cmos_sensor(0x034D,0x00); 
+	write_cmos_sensor(0x034E,0x07); // y_output size : def. 1920d
+	write_cmos_sensor(0x034F,0x80); 
+	
+	//Digital Binning(default)
+	write_cmos_sensor(0x0900,0x00);	//0x0 Binning
+	write_cmos_sensor(0x0901,0x20);
+	write_cmos_sensor(0x0383,0x01);
+	write_cmos_sensor(0x0387,0x01);
+	
+	
+	//Integration time	
+	write_cmos_sensor(0x0202,0x02);  // coarse integration
+	write_cmos_sensor(0x0203,0x00);
+	write_cmos_sensor(0x0200,0x04);  // fine integration (AA8h --> AC4h)
+	write_cmos_sensor(0x0201,0x98);
+
+	write_cmos_sensor(0x3407,0x00);
+	write_cmos_sensor(0x3408,0x00);
+	write_cmos_sensor(0x3409,0x00);
+	write_cmos_sensor(0x340A,0x00);
+	write_cmos_sensor(0x340B,0x00);
+	write_cmos_sensor(0x340C,0x00);
+	write_cmos_sensor(0x340D,0x00);
+	write_cmos_sensor(0x340E,0x00);
+	write_cmos_sensor(0x3401,0x50);
+	write_cmos_sensor(0x3402,0x3C);
+	write_cmos_sensor(0x3403,0x03);
+	write_cmos_sensor(0x3404,0x33);
+	write_cmos_sensor(0x3405,0x04);
+	write_cmos_sensor(0x3406,0x44);
+	write_cmos_sensor(0x3458,0x03);
+	write_cmos_sensor(0x3459,0x33);
+	write_cmos_sensor(0x345A,0x04);
+	write_cmos_sensor(0x345B,0x44);
+	write_cmos_sensor(0x3400,0x01);
+
+	// streaming ON
+	write_cmos_sensor(0x0100,0x01); 
+	}
+}
+
+static void normal_video_setting(kal_uint16 currefps)
+{
+	LOG_INF("E! currefps:%d\n",currefps);
+	
+	//5.1.3 Video 2592x1944 30fps 24M MCLK 2lane 864Mbps/lane
+	// +++++++++++++++++++++++++++//                                                               
+// Reset for operation                                                                         
+	write_cmos_sensor(0x0100,0x00); //stream off
+
+	
+	// Clock Setting
+	write_cmos_sensor(0x0305,0x06); //PLLP (def:5)
+	write_cmos_sensor(0x0306,0x00);
+	write_cmos_sensor(0x0307,0xE0); //PLLM (def:CCh 204d --> B3h 179d)
+	write_cmos_sensor(0x3C1F,0x00); //PLLS 
+	
+	//S30C0 //dphy_band_ctrl
+	
+	write_cmos_sensor(0x0820,0x03); // requested link bit rate mbps : (def:3D3h 979d --> 35Bh 859d)
+	write_cmos_sensor(0x0821,0x80); 
+	write_cmos_sensor(0x3C1C,0x58); //dbr_div
+	
+	write_cmos_sensor(0x0114,0x01);  //Lane mode   
+	
+	// Size Setting
+	write_cmos_sensor(0x0340,0x07); // frame_length_lines : def. 1962d (7C2 --> 7A6 Mimnimum 22 lines)
+	write_cmos_sensor(0x0341,0xD0);
+	write_cmos_sensor(0x0342,0x0B); // line_length_pck : def. 2900d 
+	write_cmos_sensor(0x0343,0x86);
+
+	write_cmos_sensor(0x0344,0x00); // x_addr_start
+	write_cmos_sensor(0x0345,0x08); 
+	write_cmos_sensor(0x0346,0x00); // y_addr_start
+	write_cmos_sensor(0x0347,0xF8); 
+	write_cmos_sensor(0x0348,0x0A); // x_addr_end : def. 2575d  
+	write_cmos_sensor(0x0349,0x07); 
+	write_cmos_sensor(0x034A,0x06); // y_addr_end : def. 1936d
+	write_cmos_sensor(0x034B,0x97); 
+	write_cmos_sensor(0x034C,0x0A); // x_output size : def. 2560d 
+	write_cmos_sensor(0x034D,0x00); 
+	write_cmos_sensor(0x034E,0x05); // y_output size : def. 1920d
+	write_cmos_sensor(0x034F,0xA0); 
+	
+	//Digital Binning(default)
+	write_cmos_sensor(0x0900,0x00);	//0x0 Binning
+	write_cmos_sensor(0x0901,0x20);
+	write_cmos_sensor(0x0383,0x01);
+	write_cmos_sensor(0x0387,0x01);
+
+	
+	//Integration time	
+	write_cmos_sensor(0x0202,0x02);  // coarse integration
+	write_cmos_sensor(0x0203,0x00);
+	write_cmos_sensor(0x0200,0x04);  // fine integration (AA8h --> AC4h)
+	write_cmos_sensor(0x0201,0x98);
+
+	write_cmos_sensor(0x3407,0x00);
+	write_cmos_sensor(0x3408,0x00);
+	write_cmos_sensor(0x3409,0x00);
+	write_cmos_sensor(0x340A,0x00);
+	write_cmos_sensor(0x340B,0x27);
+	write_cmos_sensor(0x340C,0x01);
+	write_cmos_sensor(0x340D,0xA3);
+	write_cmos_sensor(0x340E,0x9E);
+	write_cmos_sensor(0x3401,0x50);
+	write_cmos_sensor(0x3402,0x3C);
+	write_cmos_sensor(0x3403,0x03);
+	write_cmos_sensor(0x3404,0x33);
+	write_cmos_sensor(0x3405,0x04);
+	write_cmos_sensor(0x3406,0x44);
+	write_cmos_sensor(0x3458,0x03);
+	write_cmos_sensor(0x3459,0x33);
+	write_cmos_sensor(0x345A,0x04);
+	write_cmos_sensor(0x345B,0x44);
+	write_cmos_sensor(0x3400,0x01);
+	
+	// streaming ON
+	write_cmos_sensor(0x0100,0x01); 
+		
+}
+static void hs_video_setting()
+{
+	LOG_INF("E\n");         
+	//VGA 120fps
+
+	write_cmos_sensor(0x0100,0x00); //stream off
+	write_cmos_sensor(0x0136,0x18);
+	write_cmos_sensor(0x0137,0x00);
+	// Clock Setting
+	write_cmos_sensor(0x0305,0x06); //PLLP (def:5)
+	write_cmos_sensor(0x0306,0x00);
+	write_cmos_sensor(0x0307,0xE0); //PLLM (def:CCh 204d --> B3h 179d)
+	write_cmos_sensor(0x3C1F,0x00); //PLLS 
+	
+	//S30CCC0 //dphy_band_ctrl
+	
+	write_cmos_sensor(0x0820,0x03); // requested link bit rate mbps : (def:3D3h 979d --> 35Bh 859d)
+	write_cmos_sensor(0x0821,0x80); 
+	write_cmos_sensor(0x3C1C,0x58); //dbr_div
+	
+	write_cmos_sensor(0x0114,0x01);  //Lane mode
+	
+	// Size Setting
+	write_cmos_sensor(0x0340,0x01); // frame_length_lines : def. 1962d (7C2 --> 7A6 Mimnimum 22 lines)
+	write_cmos_sensor(0x0341,0xFA);
+	write_cmos_sensor(0x0342,0x0B); // line_length_pck : def. 2900d 
+	write_cmos_sensor(0x0343,0x86);
+	
+	write_cmos_sensor(0x0344,0x00); // x_addr_start
+	write_cmos_sensor(0x0345,0x08); 
+	write_cmos_sensor(0x0346,0x00); // y_addr_start
+	write_cmos_sensor(0x0347,0x08); 
+	write_cmos_sensor(0x0348,0x0A); // x_addr_end : def.   
+	write_cmos_sensor(0x0349,0x07); 
+	write_cmos_sensor(0x034A,0x07); // y_addr_end : def.
+	write_cmos_sensor(0x034B,0x87); 
+	write_cmos_sensor(0x034C,0x02); // x_output size : def. 640d 
+	write_cmos_sensor(0x034D,0x80); 
+	write_cmos_sensor(0x034E,0x01); // y_output size : def. 480d
+	write_cmos_sensor(0x034F,0xE0); 
+	
+	//Digital Binning(default)
+	write_cmos_sensor(0x0900,0x01); //0x0 Binning
+	write_cmos_sensor(0x0901,0x44);
+	write_cmos_sensor(0x0383,0x03);
+	write_cmos_sensor(0x0387,0x07);
+	
+	
+	//Integration time	
+	write_cmos_sensor(0x0204,0x00);
+	write_cmos_sensor(0x0205,0x20);
+	write_cmos_sensor(0x0202,0x01);  // coarse integration
+	write_cmos_sensor(0x0203,0x00);
+	write_cmos_sensor(0x0200,0x04);  // fine integration (AA8h --> AC4h)
+	write_cmos_sensor(0x0201,0x98);
+	
+	write_cmos_sensor(0x3407,0x00);
+	write_cmos_sensor(0x3408,0x00);
+	write_cmos_sensor(0x3409,0x00);
+	write_cmos_sensor(0x340A,0x00);
+	write_cmos_sensor(0x340B,0x00);
+	write_cmos_sensor(0x340C,0x00);
+	write_cmos_sensor(0x340D,0x00);
+	write_cmos_sensor(0x340E,0x00);
+	write_cmos_sensor(0x3401,0x50);
+	write_cmos_sensor(0x3402,0x3C);
+	write_cmos_sensor(0x3403,0x03);
+	write_cmos_sensor(0x3404,0x33);
+	write_cmos_sensor(0x3405,0x04);
+	write_cmos_sensor(0x3406,0x44);
+	write_cmos_sensor(0x3458,0x03);
+	write_cmos_sensor(0x3459,0x33);
+	write_cmos_sensor(0x345A,0x04);
+	write_cmos_sensor(0x345B,0x44);
+	write_cmos_sensor(0x3400,0x00);
+	
+	// streaming ON
+	write_cmos_sensor(0x0100,0x01); 
+
+
+
+	//full size 60fps
+/*
+	// +++++++++++++++++++++++++++//                                                               
+	// Reset for operation                                                                         
+	write_cmos_sensor(0x0100,0x00); //stream off
+	
+	// Clock Setting
+	write_cmos_sensor(0x0305,0x05); //PLLP (def:5)
+	write_cmos_sensor(0x0306,0x00);
+	write_cmos_sensor(0x0307,0xCA); //PLLM (def:CCh 204d --> B3h 179d)
+	write_cmos_sensor(0x3C1F,0x00); //PLLS 
+	
+	//S30CCC0 //dphy_band_ctrl
+	
+	write_cmos_sensor(0x0820,0x03); // requested link bit rate mbps : (def:3D3h 979d --> 35Bh 859d)
+	write_cmos_sensor(0x0821,0xC9); 
+	write_cmos_sensor(0x3C1C,0x59); //dbr_div
+	
+	write_cmos_sensor(0x0114,0x01);  //Lane mode
+	
+	// Size Setting
+	write_cmos_sensor(0x0340,0x04); // frame_length_lines : def. 1962d (7C2 --> 7A6 Mimnimum 22 lines)
+	write_cmos_sensor(0x0341,0x4F);
+	write_cmos_sensor(0x0342,0x0B); // line_length_pck : def. 2900d 
+	write_cmos_sensor(0x0343,0x86);
+	
+	write_cmos_sensor(0x0344,0x01); // x_addr_start
+	write_cmos_sensor(0x0345,0x40); 
+	write_cmos_sensor(0x0346,0x01); // y_addr_start
+	write_cmos_sensor(0x0347,0xA4); 
+	write_cmos_sensor(0x0348,0x08); // x_addr_end : def. 2575d  
+	write_cmos_sensor(0x0349,0xBF); 
+	write_cmos_sensor(0x034A,0x05); // y_addr_end : def. 1936d
+	write_cmos_sensor(0x034B,0xDB); 
+	write_cmos_sensor(0x034C,0x07); // x_output size : def. 2560d 
+	write_cmos_sensor(0x034D,0x80); 
+	write_cmos_sensor(0x034E,0x04); // y_output size : def. 1920d
+	write_cmos_sensor(0x034F,0x38); 
+	
+	//Digital Binning(default)
+	write_cmos_sensor(0x0900,0x00);	//0x0 Binning
+	write_cmos_sensor(0x0901,0x20);
+	write_cmos_sensor(0x0387,0x01);
+	
+	
+	//Integration time	
+	write_cmos_sensor(0x0202,0x02);  // coarse integration
+	write_cmos_sensor(0x0203,0x00);
+	write_cmos_sensor(0x0200,0x04);  // fine integration (AA8h --> AC4h)
+	write_cmos_sensor(0x0201,0x98);
+	
+	write_cmos_sensor(0x3407,0x4C);
+	write_cmos_sensor(0x3408,0x01);
+	write_cmos_sensor(0x3409,0xF3);
+	write_cmos_sensor(0x340A,0x24);
+	write_cmos_sensor(0x340B,0x1A);
+	write_cmos_sensor(0x340C,0x03);
+	write_cmos_sensor(0x340D,0x6E);
+	write_cmos_sensor(0x340E,0xE8);
+	write_cmos_sensor(0x3401,0x50);
+	write_cmos_sensor(0x3402,0x3C);
+	write_cmos_sensor(0x3403,0x03);
+	write_cmos_sensor(0x3404,0x33);
+	write_cmos_sensor(0x3405,0x04);
+	write_cmos_sensor(0x3406,0x44);
+	write_cmos_sensor(0x3458,0x03);
+	write_cmos_sensor(0x3459,0x33);
+	write_cmos_sensor(0x345A,0x04);
+	write_cmos_sensor(0x345B,0x44);
+	write_cmos_sensor(0x3400,0x01);
+	
+	// streaming ON
+	write_cmos_sensor(0x0100,0x01); 
+*/
+}
+
+static void slim_video_setting()
+{
+	LOG_INF("E\n");
+	// +++++++++++++++++++++++++++//                                                               
+// Reset for operation                                                                         
+	write_cmos_sensor(0x0100,0x00); //stream off
+	
+	// Clock Setting
+	write_cmos_sensor(0x0305,0x06); //PLLP (def:5)
+	write_cmos_sensor(0x0306,0x00);
+	write_cmos_sensor(0x0307,0xE0); //PLLM (def:CCh 204d --> B3h 179d)
+	write_cmos_sensor(0x3C1F,0x00); //PLLS 
+	
+	//S30CCC0 //dphy_band_ctrl
+	
+	write_cmos_sensor(0x0820,0x03); // requested link bit rate mbps : (def:3D3h 979d --> 35Bh 859d)
+	write_cmos_sensor(0x0821,0x80); 
+	write_cmos_sensor(0x3C1C,0x58); //dbr_div
+	
+	write_cmos_sensor(0x0114,0x01);  //Lane mode
+	
+	// Size Setting
+	write_cmos_sensor(0x0340,0x07); // frame_length_lines : def. 1962d (7C2 --> 7A6 Mimnimum 22 lines)
+	write_cmos_sensor(0x0341,0xD0);
+	write_cmos_sensor(0x0342,0x0B); // line_length_pck : def. 2900d 
+	write_cmos_sensor(0x0343,0x86);
+	
+	write_cmos_sensor(0x0344,0x00); // x_addr_start
+	write_cmos_sensor(0x0345,0x08); 
+	write_cmos_sensor(0x0346,0x00); // y_addr_start
+	write_cmos_sensor(0x0347,0xF8); 
+	write_cmos_sensor(0x0348,0x0A); // x_addr_end : def. 2575d  
+	write_cmos_sensor(0x0349,0x07); 
+	write_cmos_sensor(0x034A,0x06); // y_addr_end : def. 1936d
+	write_cmos_sensor(0x034B,0x97); 
+	write_cmos_sensor(0x034C,0x05); // x_output size : def. 2560d 
+	write_cmos_sensor(0x034D,0x00); 
+	write_cmos_sensor(0x034E,0x02); // y_output size : def. 1920d
+	write_cmos_sensor(0x034F,0xD0); 
+	
+	//Digital Binning(default)
+	write_cmos_sensor(0x0900,0x01);	//2x2 Binning
+	write_cmos_sensor(0x0901,0x22);
+	write_cmos_sensor(0x0383,0x01);
+	write_cmos_sensor(0x0387,0x03);
+	
+	
+	//Integration time	
+	write_cmos_sensor(0x0202,0x02);  // coarse integration
+	write_cmos_sensor(0x0203,0x00);
+	write_cmos_sensor(0x0200,0x04);  // fine integration (AA8h --> AC4h)
+	write_cmos_sensor(0x0201,0x98);
+	
+	write_cmos_sensor(0x3407,0x00);
+	write_cmos_sensor(0x3408,0x00);
+	write_cmos_sensor(0x3409,0x00);
+	write_cmos_sensor(0x340A,0x00);
+	write_cmos_sensor(0x340B,0x00);
+	write_cmos_sensor(0x340C,0x02);
+	write_cmos_sensor(0x340D,0x00);
+	write_cmos_sensor(0x340E,0x00);
+	write_cmos_sensor(0x3401,0x50);
+	write_cmos_sensor(0x3402,0x3C);
+	write_cmos_sensor(0x3403,0x03);
+	write_cmos_sensor(0x3404,0x33);
+	write_cmos_sensor(0x3405,0x04);
+	write_cmos_sensor(0x3406,0x44);
+	write_cmos_sensor(0x3458,0x03);
+	write_cmos_sensor(0x3459,0x33);
+	write_cmos_sensor(0x345A,0x04);
+	write_cmos_sensor(0x345B,0x44);
+	write_cmos_sensor(0x3400,0x01);
+	
+	// streaming ON
+	write_cmos_sensor(0x0100,0x01); 
+
+}
+
+
+/*************************************************************************
+* FUNCTION
+*	get_imgsensor_id
+*
+* DESCRIPTION
+*	This function get the sensor ID 
+*
+* PARAMETERS
+*	*sensorID : return the sensor ID 
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 get_imgsensor_id(UINT32 *sensor_id) 
+{
+	kal_uint8 i = 0;
+	kal_uint8 retry = 2;
+	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
+	while (imgsensor_info.i2c_addr_table[i] != 0xff) {
+		spin_lock(&imgsensor_drv_lock);
+		imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
+		spin_unlock(&imgsensor_drv_lock);
+		do {
+			*sensor_id = return_sensor_id();
+			if (*sensor_id == imgsensor_info.sensor_id) {				
+				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);	  
+				return ERROR_NONE;
+			}	
+			LOG_INF("Read sensor id fail, id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
+			retry--;
+		} while(retry > 0);
+		i++;
+		retry = 2;
+	}
+	if (*sensor_id != imgsensor_info.sensor_id) {
+		// if Sensor ID is not correct, Must set *sensor_id to 0xFFFFFFFF 
+		*sensor_id = 0xFFFFFFFF;
+		return ERROR_SENSOR_CONNECT_FAIL;
+	}
+	return ERROR_NONE;
+}
+
+
+/*************************************************************************
+* FUNCTION
+*	open
+*
+* DESCRIPTION
+*	This function initialize the registers of CMOS sensor
+*
+* PARAMETERS
+*	None
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 open(void)
+{
+	//const kal_uint8 i2c_addr[] = {IMGSENSOR_WRITE_ID_1, IMGSENSOR_WRITE_ID_2};
+	kal_uint8 i = 0;
+	kal_uint8 retry = 2;
+	kal_uint32 sensor_id = 0; 
+	LOG_1;
+	LOG_2;
+	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
+	while (imgsensor_info.i2c_addr_table[i] != 0xff) {
+		spin_lock(&imgsensor_drv_lock);
+		imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
+		spin_unlock(&imgsensor_drv_lock);
+		do {
+			sensor_id = return_sensor_id();
+			if (sensor_id == imgsensor_info.sensor_id) {				
+				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);	  
+				break;
+			}	
+			LOG_INF("Read sensor id fail, id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
+			retry--;
+		} while(retry > 0);
+		i++;
+		if (sensor_id == imgsensor_info.sensor_id)
+			break;
+		retry = 2;
+	}		 
+	if (imgsensor_info.sensor_id != sensor_id)
+		return ERROR_SENSOR_CONNECT_FAIL;
+	
+	/* initail sequence write in  */
+	sensor_init();
+
+	spin_lock(&imgsensor_drv_lock);
+
+	imgsensor.autoflicker_en= KAL_FALSE;
+	imgsensor.sensor_mode = IMGSENSOR_MODE_INIT;
+	imgsensor.shutter = 0x3D0;
+	imgsensor.gain = 0x100;
+	imgsensor.pclk = imgsensor_info.pre.pclk;
+	imgsensor.frame_length = imgsensor_info.pre.framelength;
+	imgsensor.line_length = imgsensor_info.pre.linelength;
+	imgsensor.min_frame_length = imgsensor_info.pre.framelength;
+	imgsensor.dummy_pixel = 0;
+	imgsensor.dummy_line = 0;
+	imgsensor.ihdr_en = 0;
+	imgsensor.test_pattern = KAL_FALSE;
+	imgsensor.current_fps = imgsensor_info.pre.max_framerate;
+	spin_unlock(&imgsensor_drv_lock);
+
+	return ERROR_NONE;
+}	/*	open  */
+
+
+
+/*************************************************************************
+* FUNCTION
+*	close
+*
+* DESCRIPTION
+*	
+*
+* PARAMETERS
+*	None
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 close(void)
+{
+	LOG_INF("E\n");
+
+	/*No Need to implement this function*/ 
+	
+	return ERROR_NONE;
+}	/*	close  */
+
+
+/*************************************************************************
+* FUNCTION
+* preview
+*
+* DESCRIPTION
+*	This function start the sensor preview.
+*
+* PARAMETERS
+*	*image_window : address pointer of pixel numbers in one period of HSYNC
+*  *sensor_config_data : address pointer of line numbers in one period of VSYNC
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("E\n");
+
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.sensor_mode = IMGSENSOR_MODE_PREVIEW;
+	imgsensor.pclk = imgsensor_info.pre.pclk;
+	//imgsensor.video_mode = KAL_FALSE;
+	imgsensor.line_length = imgsensor_info.pre.linelength;
+	imgsensor.frame_length = imgsensor_info.pre.framelength; 
+	imgsensor.min_frame_length = imgsensor_info.pre.framelength;
+	imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	preview_setting();
+	if(0 == strncmp(VANZO_MAIN_CAM_ROTATION, "180", 3)){
+			set_mirror_flip(IMAGE_HV_MIRROR);
+	}
+
+	return ERROR_NONE;
+}	/*	preview   */
+
+/*************************************************************************
+* FUNCTION
+*	capture
+*
+* DESCRIPTION
+*	This function setup the CMOS sensor in capture MY_OUTPUT mode
+*
+* PARAMETERS
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+						  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("E\n");
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.sensor_mode = IMGSENSOR_MODE_CAPTURE;
+	if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {//PIP capture: 24fps for less than 13M, 20fps for 16M,15fps for 20M
+		imgsensor.pclk = imgsensor_info.cap1.pclk;
+		imgsensor.line_length = imgsensor_info.cap1.linelength;
+		imgsensor.frame_length = imgsensor_info.cap1.framelength;  
+		imgsensor.min_frame_length = imgsensor_info.cap1.framelength;
+		imgsensor.autoflicker_en = KAL_FALSE;
+	} else {
+		if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
+			LOG_INF("Warning: current_fps %d fps is not support, so use cap1's setting: %d fps!\n",imgsensor_info.cap1.max_framerate/10);
+		imgsensor.pclk = imgsensor_info.cap.pclk;
+		imgsensor.line_length = imgsensor_info.cap.linelength;
+		imgsensor.frame_length = imgsensor_info.cap.framelength;  
+		imgsensor.min_frame_length = imgsensor_info.cap.framelength;
+		imgsensor.autoflicker_en = KAL_FALSE;
+	}
+	spin_unlock(&imgsensor_drv_lock);
+
+	capture_setting(imgsensor.current_fps); 
+	
+	
+	return ERROR_NONE;
+}	/* capture() */
+static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("E\n");
+	
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.sensor_mode = IMGSENSOR_MODE_VIDEO;
+	imgsensor.pclk = imgsensor_info.normal_video.pclk;
+	imgsensor.line_length = imgsensor_info.normal_video.linelength;
+	imgsensor.frame_length = imgsensor_info.normal_video.framelength;  
+	imgsensor.min_frame_length = imgsensor_info.normal_video.framelength;
+	//imgsensor.current_fps = 300;
+	imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	normal_video_setting(imgsensor.current_fps);
+	
+	
+	return ERROR_NONE;
+}	/*	normal_video   */
+
+static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("E\n");
+	
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.sensor_mode = IMGSENSOR_MODE_HIGH_SPEED_VIDEO;
+	imgsensor.pclk = imgsensor_info.hs_video.pclk;
+	//imgsensor.video_mode = KAL_TRUE;
+	imgsensor.line_length = imgsensor_info.hs_video.linelength;
+	imgsensor.frame_length = imgsensor_info.hs_video.framelength; 
+	imgsensor.min_frame_length = imgsensor_info.hs_video.framelength;
+	imgsensor.dummy_line = 0;
+	imgsensor.dummy_pixel = 0;
+	imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	hs_video_setting();
+	
+	return ERROR_NONE;
+}	/*	hs_video   */
+
+static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("E\n");
+	
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.sensor_mode = IMGSENSOR_MODE_SLIM_VIDEO;
+	imgsensor.pclk = imgsensor_info.slim_video.pclk;
+	imgsensor.line_length = imgsensor_info.slim_video.linelength;
+	imgsensor.frame_length = imgsensor_info.slim_video.framelength; 
+	imgsensor.min_frame_length = imgsensor_info.slim_video.framelength;
+	imgsensor.dummy_line = 0;
+	imgsensor.dummy_pixel = 0;
+	imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	slim_video_setting();
+	
+	return ERROR_NONE;
+}	/*	slim_video	 */
+
+
+
+static kal_uint32 get_resolution(MSDK_SENSOR_RESOLUTION_INFO_STRUCT *sensor_resolution)
+{
+	LOG_INF("E\n");
+	sensor_resolution->SensorFullWidth = imgsensor_info.cap.grabwindow_width;
+	sensor_resolution->SensorFullHeight = imgsensor_info.cap.grabwindow_height;
+	
+	sensor_resolution->SensorPreviewWidth = imgsensor_info.pre.grabwindow_width;
+	sensor_resolution->SensorPreviewHeight = imgsensor_info.pre.grabwindow_height;
+
+	sensor_resolution->SensorVideoWidth = imgsensor_info.normal_video.grabwindow_width;
+	sensor_resolution->SensorVideoHeight = imgsensor_info.normal_video.grabwindow_height;		
+
+	
+	sensor_resolution->SensorHighSpeedVideoWidth	 = imgsensor_info.hs_video.grabwindow_width;
+	sensor_resolution->SensorHighSpeedVideoHeight	 = imgsensor_info.hs_video.grabwindow_height;
+	
+	sensor_resolution->SensorSlimVideoWidth	 = imgsensor_info.slim_video.grabwindow_width;
+	sensor_resolution->SensorSlimVideoHeight	 = imgsensor_info.slim_video.grabwindow_height;
+	return ERROR_NONE;
+}	/*	get_resolution	*/
+
+static kal_uint32 get_info(MSDK_SCENARIO_ID_ENUM scenario_id,
+					  MSDK_SENSOR_INFO_STRUCT *sensor_info,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("scenario_id = %d\n", scenario_id);
+
+	
+	//sensor_info->SensorVideoFrameRate = imgsensor_info.normal_video.max_framerate/10; /* not use */
+	//sensor_info->SensorStillCaptureFrameRate= imgsensor_info.cap.max_framerate/10; /* not use */
+	//imgsensor_info->SensorWebCamCaptureFrameRate= imgsensor_info.v.max_framerate; /* not use */
+
+	sensor_info->SensorClockPolarity = SENSOR_CLOCK_POLARITY_LOW;
+	sensor_info->SensorClockFallingPolarity = SENSOR_CLOCK_POLARITY_LOW; /* not use */
+	sensor_info->SensorHsyncPolarity = SENSOR_CLOCK_POLARITY_LOW; // inverse with datasheet
+	sensor_info->SensorVsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
+	sensor_info->SensorInterruptDelayLines = 4; /* not use */
+	sensor_info->SensorResetActiveHigh = FALSE; /* not use */
+	sensor_info->SensorResetDelayCount = 5; /* not use */
+
+	sensor_info->SensroInterfaceType = imgsensor_info.sensor_interface_type;
+	sensor_info->MIPIsensorType = imgsensor_info.mipi_sensor_type;
+	sensor_info->SettleDelayMode = imgsensor_info.mipi_settle_delay_mode;
+	sensor_info->SensorOutputDataFormat = imgsensor_info.sensor_output_dataformat;
+
+	sensor_info->CaptureDelayFrame = imgsensor_info.cap_delay_frame; 
+	sensor_info->PreviewDelayFrame = imgsensor_info.pre_delay_frame; 
+	sensor_info->VideoDelayFrame = imgsensor_info.video_delay_frame;
+	sensor_info->HighSpeedVideoDelayFrame = imgsensor_info.hs_video_delay_frame;
+	sensor_info->SlimVideoDelayFrame = imgsensor_info.slim_video_delay_frame;
+
+	sensor_info->SensorMasterClockSwitch = 0; /* not use */
+	sensor_info->SensorDrivingCurrent = imgsensor_info.isp_driving_current;
+	
+	sensor_info->AEShutDelayFrame = imgsensor_info.ae_shut_delay_frame; 		 /* The frame of setting shutter default 0 for TG int */
+	sensor_info->AESensorGainDelayFrame = imgsensor_info.ae_sensor_gain_delay_frame;	/* The frame of setting sensor gain */
+	sensor_info->AEISPGainDelayFrame = imgsensor_info.ae_ispGain_delay_frame;	
+	sensor_info->IHDR_Support = imgsensor_info.ihdr_support;
+	sensor_info->IHDR_LE_FirstLine = imgsensor_info.ihdr_le_firstline;
+	sensor_info->SensorModeNum = imgsensor_info.sensor_mode_num;
+	
+	sensor_info->SensorMIPILaneNumber = imgsensor_info.mipi_lane_num; 
+	sensor_info->SensorClockFreq = imgsensor_info.mclk;
+	sensor_info->SensorClockDividCount = 3; /* not use */
+	sensor_info->SensorClockRisingCount = 0;
+	sensor_info->SensorClockFallingCount = 2; /* not use */
+	sensor_info->SensorPixelClockCount = 3; /* not use */
+	sensor_info->SensorDataLatchCount = 2; /* not use */
+	
+	sensor_info->MIPIDataLowPwr2HighSpeedTermDelayCount = 0; 
+	sensor_info->MIPICLKLowPwr2HighSpeedTermDelayCount = 0;
+	sensor_info->SensorWidthSampling = 0;  // 0 is default 1x
+	sensor_info->SensorHightSampling = 0;	// 0 is default 1x 
+	sensor_info->SensorPacketECCOrder = 1;
+
+	switch (scenario_id) {
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+			sensor_info->SensorGrabStartX = imgsensor_info.pre.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;		
+			
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
+			
+			break;
+		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+			sensor_info->SensorGrabStartX = imgsensor_info.cap.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.cap.starty;
+				  
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.cap.mipi_data_lp2hs_settle_dc; 
+
+			break;	 
+		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+			
+			sensor_info->SensorGrabStartX = imgsensor_info.normal_video.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.normal_video.starty;
+	   
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.normal_video.mipi_data_lp2hs_settle_dc; 
+
+			break;	  
+		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:			
+			sensor_info->SensorGrabStartX = imgsensor_info.hs_video.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.hs_video.starty;
+				  
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.hs_video.mipi_data_lp2hs_settle_dc; 
+
+			break;
+		case MSDK_SCENARIO_ID_SLIM_VIDEO:
+			sensor_info->SensorGrabStartX = imgsensor_info.slim_video.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.slim_video.starty;
+				  
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.slim_video.mipi_data_lp2hs_settle_dc; 
+
+			break;
+		default:			
+			sensor_info->SensorGrabStartX = imgsensor_info.pre.startx; 
+			sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;		
+			
+			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
+			break;
+	}
+	
+	return ERROR_NONE;
+}	/*	get_info  */
+
+
+static kal_uint32 control(MSDK_SCENARIO_ID_ENUM scenario_id, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+	LOG_INF("scenario_id = %d\n", scenario_id);
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.current_scenario_id = scenario_id;
+	spin_unlock(&imgsensor_drv_lock);
+	switch (scenario_id) {
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+			preview(image_window, sensor_config_data);
+			break;
+		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+			capture(image_window, sensor_config_data);
+			break;	
+		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+			normal_video(image_window, sensor_config_data);
+			break;	  
+		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+			hs_video(image_window, sensor_config_data);
+			break;
+		case MSDK_SCENARIO_ID_SLIM_VIDEO:
+			slim_video(image_window, sensor_config_data);
+			break;	  
+		default:
+			LOG_INF("Error ScenarioId setting");
+			preview(image_window, sensor_config_data);
+			return ERROR_INVALID_SCENARIO_ID;
+	}
+	return ERROR_NONE;
+}	/* control() */
+
+
+
+static kal_uint32 set_video_mode(UINT16 framerate)
+{
+	LOG_INF("framerate = %d\n ", framerate);
+	// SetVideoMode Function should fix framerate
+	if (framerate == 0)
+		// Dynamic frame rate
+		return ERROR_NONE;
+	spin_lock(&imgsensor_drv_lock);
+	if ((framerate == 300) && (imgsensor.autoflicker_en == KAL_TRUE))
+		imgsensor.current_fps = 296;
+	else if ((framerate == 150) && (imgsensor.autoflicker_en == KAL_TRUE))
+		imgsensor.current_fps = 146;
+	else
+		imgsensor.current_fps = framerate;
+	spin_unlock(&imgsensor_drv_lock);
+	set_max_framerate(imgsensor.current_fps,1);
+
+	return ERROR_NONE;
+}
+
+static kal_uint32 set_auto_flicker_mode(kal_bool enable, UINT16 framerate)
+{
+	LOG_INF("enable = %d, framerate = %d \n", enable, framerate);
+	spin_lock(&imgsensor_drv_lock);
+	if (enable) //enable auto flicker	  
+		imgsensor.autoflicker_en = KAL_TRUE;
+	else //Cancel Auto flick
+		imgsensor.autoflicker_en = KAL_FALSE;
+	spin_unlock(&imgsensor_drv_lock);
+	return ERROR_NONE;
+}
+
+
+static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 framerate) 
+{
+	kal_uint32 frame_length;
+  
+	LOG_INF("scenario_id = %d, framerate = %d\n", scenario_id, framerate);
+
+	switch (scenario_id) {
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+			frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
+			imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			//set_dummy();
+			break;			
+		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+			if(framerate == 0)
+				return ERROR_NONE;
+			frame_length = imgsensor_info.normal_video.pclk / framerate * 10 / imgsensor_info.normal_video.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = (frame_length > imgsensor_info.normal_video.framelength) ? (frame_length - imgsensor_info.normal_video.framelength) : 0;			
+			imgsensor.frame_length = imgsensor_info.normal_video.framelength + imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			//set_dummy();
+			break;
+		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+        	  if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {
+                frame_length = imgsensor_info.cap1.pclk / framerate * 10 / imgsensor_info.cap1.linelength;
+                spin_lock(&imgsensor_drv_lock);
+		            imgsensor.dummy_line = (frame_length > imgsensor_info.cap1.framelength) ? (frame_length - imgsensor_info.cap1.framelength) : 0;
+		            imgsensor.frame_length = imgsensor_info.cap1.framelength + imgsensor.dummy_line;
+		            imgsensor.min_frame_length = imgsensor.frame_length;
+		            spin_unlock(&imgsensor_drv_lock);
+            } else {
+        		    if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
+                    LOG_INF("Warning: current_fps %d fps is not support, so use cap's setting: %d fps!\n",framerate,imgsensor_info.cap.max_framerate/10);
+			frame_length = imgsensor_info.cap.pclk / framerate * 10 / imgsensor_info.cap.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = (frame_length > imgsensor_info.cap.framelength) ? (frame_length - imgsensor_info.cap.framelength) : 0;
+			imgsensor.frame_length = imgsensor_info.cap.framelength + imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+            }
+			//set_dummy();
+			break;	
+		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+			frame_length = imgsensor_info.hs_video.pclk / framerate * 10 / imgsensor_info.hs_video.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = (frame_length > imgsensor_info.hs_video.framelength) ? (frame_length - imgsensor_info.hs_video.framelength) : 0;
+			imgsensor.frame_length = imgsensor_info.hs_video.framelength + imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			//set_dummy();
+			break;
+		case MSDK_SCENARIO_ID_SLIM_VIDEO:
+			frame_length = imgsensor_info.slim_video.pclk / framerate * 10 / imgsensor_info.slim_video.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = (frame_length > imgsensor_info.slim_video.framelength) ? (frame_length - imgsensor_info.slim_video.framelength): 0;	
+			imgsensor.frame_length = imgsensor_info.slim_video.framelength + imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			//set_dummy();
+			break;		
+		default:  //coding with  preview scenario by default
+			frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
+			spin_lock(&imgsensor_drv_lock);
+			imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
+			imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
+			imgsensor.min_frame_length = imgsensor.frame_length;
+			spin_unlock(&imgsensor_drv_lock);
+			//set_dummy();
+			LOG_INF("error scenario_id = %d, we use preview scenario \n", scenario_id);
+			break;
+	}	
+	return ERROR_NONE;
+}
+
+
+static kal_uint32 get_default_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 *framerate) 
+{
+	LOG_INF("scenario_id = %d\n", scenario_id);
+
+	switch (scenario_id) {
+		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+			*framerate = imgsensor_info.pre.max_framerate;
+			break;
+		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+			*framerate = imgsensor_info.normal_video.max_framerate;
+			break;
+		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+			*framerate = imgsensor_info.cap.max_framerate;
+			break;		
+		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+			*framerate = imgsensor_info.hs_video.max_framerate;
+			break;
+		case MSDK_SCENARIO_ID_SLIM_VIDEO: 
+			*framerate = imgsensor_info.slim_video.max_framerate;
+			break;
+		default:
+			break;
+	}
+
+	return ERROR_NONE;
+}
+
+static kal_uint32 set_test_pattern_mode(kal_bool enable)
+{
+	LOG_INF("enable: %d\n", enable);
+
+	if (enable) {
+		// 0x5E00[8]: 1 enable,  0 disable
+		// 0x5E00[1:0]; 00 Color bar, 01 Random Data, 10 Square, 11 BLACK
+		write_cmos_sensor(0x0601, 0x01);
+	} else {
+		// 0x5E00[8]: 1 enable,  0 disable
+		// 0x5E00[1:0]; 00 Color bar, 01 Random Data, 10 Square, 11 BLACK
+		write_cmos_sensor(0x0601, 0x00);
+	}	 
+	write_cmos_sensor(0x3200, 0x00);
+	spin_lock(&imgsensor_drv_lock);
+	imgsensor.test_pattern = enable;
+	spin_unlock(&imgsensor_drv_lock);
+	return ERROR_NONE;
+}
+
+static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
+							 UINT8 *feature_para,UINT32 *feature_para_len)
+{
+	UINT16 *feature_return_para_16=(UINT16 *) feature_para;
+	UINT16 *feature_data_16=(UINT16 *) feature_para;
+	UINT32 *feature_return_para_32=(UINT32 *) feature_para;
+	UINT32 *feature_data_32=(UINT32 *) feature_para;
+    unsigned long long *feature_data=(unsigned long long *) feature_para;
+    unsigned long long *feature_return_para=(unsigned long long *) feature_para;
+
+	SENSOR_WINSIZE_INFO_STRUCT *wininfo;	
+	MSDK_SENSOR_REG_INFO_STRUCT *sensor_reg_data=(MSDK_SENSOR_REG_INFO_STRUCT *) feature_para;
+ 
+	LOG_INF("feature_id = %d", feature_id);
+	switch (feature_id) {
+		case SENSOR_FEATURE_GET_PERIOD:
+			*feature_return_para_16++ = imgsensor.line_length;
+			*feature_return_para_16 = imgsensor.frame_length;
+			*feature_para_len=4;
+			break;
+		case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:
+            LOG_INF("feature_Control imgsensor.pclk = %d,imgsensor.current_fps = %d\n", imgsensor.pclk,imgsensor.current_fps);
+			*feature_return_para_32 = imgsensor.pclk;
+			*feature_para_len=4;
+			break;
+		case SENSOR_FEATURE_SET_ESHUTTER:
+            set_shutter(*feature_data);
+			break;
+		case SENSOR_FEATURE_SET_NIGHTMODE:
+			break;
+		case SENSOR_FEATURE_SET_GAIN:
+            set_gain((UINT16) *feature_data);
+			break;
+		case SENSOR_FEATURE_SET_FLASHLIGHT:
+			break;
+		case SENSOR_FEATURE_SET_ISP_MASTER_CLOCK_FREQ:
+			break;
+		case SENSOR_FEATURE_SET_REGISTER:
+			if((sensor_reg_data->RegData>>8)>0)
+			   write_cmos_sensor(sensor_reg_data->RegAddr, sensor_reg_data->RegData);
+			else
+				write_cmos_sensor_8(sensor_reg_data->RegAddr, sensor_reg_data->RegData);
+			break;
+		case SENSOR_FEATURE_GET_REGISTER:
+			sensor_reg_data->RegData = read_cmos_sensor(sensor_reg_data->RegAddr);
+			break;
+		case SENSOR_FEATURE_GET_LENS_DRIVER_ID:
+			// get the lens driver ID from EEPROM or just return LENS_DRIVER_ID_DO_NOT_CARE
+			// if EEPROM does not exist in camera module.
+			*feature_return_para_32=LENS_DRIVER_ID_DO_NOT_CARE;
+			*feature_para_len=4;
+			break;
+		case SENSOR_FEATURE_SET_VIDEO_MODE:
+            set_video_mode(*feature_data);
+			break;
+		case SENSOR_FEATURE_CHECK_SENSOR_ID:
+			get_imgsensor_id(feature_return_para_32);
+			break;
+		case SENSOR_FEATURE_SET_AUTO_FLICKER_MODE:
+			set_auto_flicker_mode((BOOL)*feature_data_16,*(feature_data_16+1));
+			break;
+		case SENSOR_FEATURE_SET_MAX_FRAME_RATE_BY_SCENARIO:
+            set_max_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data, *(feature_data+1));
+			break;
+		case SENSOR_FEATURE_GET_DEFAULT_FRAME_RATE_BY_SCENARIO:
+            get_default_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*(feature_data), (MUINT32 *)(uintptr_t)(*(feature_data+1)));
+			break;
+		case SENSOR_FEATURE_SET_TEST_PATTERN:
+            set_test_pattern_mode((BOOL)*feature_data);
+			break;
+		case SENSOR_FEATURE_GET_TEST_PATTERN_CHECKSUM_VALUE: //for factory mode auto testing
+			*feature_return_para_32 = imgsensor_info.checksum_value;
+			*feature_para_len=4;
+			break;
+		case SENSOR_FEATURE_SET_FRAMERATE:
+            LOG_INF("current fps :%d\n", *feature_data);
+			spin_lock(&imgsensor_drv_lock);
+            imgsensor.current_fps = *feature_data;
+			spin_unlock(&imgsensor_drv_lock);
+			break;
+		case SENSOR_FEATURE_SET_HDR:
+			//LOG_INF("ihdr enable :%d\n", (BOOL)*feature_data_16);
+			LOG_INF("Warning! Not Support IHDR Feature");
+			spin_lock(&imgsensor_drv_lock);
+			//imgsensor.ihdr_en = (BOOL)*feature_data_16;
+            imgsensor.ihdr_en = KAL_FALSE;
+			spin_unlock(&imgsensor_drv_lock);
+			break;
+		case SENSOR_FEATURE_GET_CROP_INFO:
+            LOG_INF("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n", *feature_data);
+            wininfo = (SENSOR_WINSIZE_INFO_STRUCT *)(uintptr_t)(*(feature_data+1));
+
+			switch (*feature_data_32) {
+				case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[1],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+					break;
+				case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[2],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+					break;
+				case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[3],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+					break;
+				case MSDK_SCENARIO_ID_SLIM_VIDEO:
+					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[4],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+					break;
+				case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+				default:
+					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[0],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+					break;
+			}
+            break;
+		case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
+            LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",(UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
+            ihdr_write_shutter_gain((UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
+			break;
+		default:
+			break;
+	}
+  
+	return ERROR_NONE;
+}	/*	feature_control()  */
+
+static SENSOR_FUNCTION_STRUCT sensor_func = {
+	open,
+	get_info,
+	get_resolution,
+	feature_control,
+	control,
+	close
+};
+
+UINT32 S5K5E2YASUB_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
+{
+	/* To Do : Check Sensor status here */
+	if (pfFunc!=NULL)
+		*pfFunc=&sensor_func;
+	return ERROR_NONE;
+}	/*	OV5693_MIPI_RAW_SensorInit	*/
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k5e2yasub_mipi_raw/s5k5e2yasubmipiraw_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k5e2yasub_mipi_raw/s5k5e2yasubmipiraw_Sensor.h
new file mode 100755
index 0000000..6434690
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k5e2yasub_mipi_raw/s5k5e2yasubmipiraw_Sensor.h
@@ -0,0 +1,129 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *	 OV5693mipi_Sensor.h
+ *
+ * Project:
+ * --------
+ *	 ALPS
+ *
+ * Description:
+ * ------------
+ *	 CMOS sensor header file
+ *
+ ****************************************************************************/
+#ifndef _S5K5E2YAMIPI_SENSOR_H
+#define _S5K5E2YAMIPI_SENSOR_H
+
+
+typedef enum{
+	IMGSENSOR_MODE_INIT,
+	IMGSENSOR_MODE_PREVIEW,
+	IMGSENSOR_MODE_CAPTURE,
+	IMGSENSOR_MODE_VIDEO,
+	IMGSENSOR_MODE_HIGH_SPEED_VIDEO,
+	IMGSENSOR_MODE_SLIM_VIDEO,
+} IMGSENSOR_MODE;
+
+typedef struct imgsensor_mode_struct {
+	kal_uint32 pclk;				//record different mode's pclk
+	kal_uint32 linelength;			//record different mode's linelength
+	kal_uint32 framelength;			//record different mode's framelength
+
+	kal_uint8 startx;				//record different mode's startx of grabwindow
+	kal_uint8 starty;				//record different mode's startx of grabwindow
+
+	kal_uint16 grabwindow_width;	//record different mode's width of grabwindow
+	kal_uint16 grabwindow_height;	//record different mode's height of grabwindow
+
+	/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
+	kal_uint8 mipi_data_lp2hs_settle_dc;
+
+	/*	 following for GetDefaultFramerateByScenario()	*/
+	kal_uint16 max_framerate;
+	
+} imgsensor_mode_struct;
+
+/* SENSOR PRIVATE STRUCT FOR VARIABLES*/
+typedef struct imgsensor_struct {
+	kal_uint8 mirror;				//mirrorflip information
+
+	kal_uint8 sensor_mode;			//record IMGSENSOR_MODE enum value
+
+	kal_uint32 shutter;				//current shutter
+	kal_uint16 gain;				//current gain
+	
+	kal_uint32 pclk;				//current pclk
+
+	kal_uint32 frame_length;		//current framelength
+	kal_uint32 line_length;			//current linelength
+
+	kal_uint32 min_frame_length;	//current min  framelength to max framerate
+	kal_uint16 dummy_pixel;			//current dummypixel
+	kal_uint16 dummy_line;			//current dummline
+	
+	kal_uint16 current_fps;			//current max fps
+	kal_bool   autoflicker_en;		//record autoflicker enable or disable
+	kal_bool test_pattern;			//record test pattern mode or not
+	MSDK_SCENARIO_ID_ENUM current_scenario_id;//current scenario id
+	kal_uint8  ihdr_en;				//ihdr enable or disable
+	
+	kal_uint8 i2c_write_id;			//record current sensor's i2c write id
+    kal_uint8 update_sensor_otp_awb;          // Update sensor awb from otp or not
+    kal_uint8 update_sensor_otp_lsc;          // Update sensor lsc from otp or not
+} imgsensor_struct;
+
+/* SENSOR PRIVATE STRUCT FOR CONSTANT*/
+typedef struct imgsensor_info_struct { 
+	kal_uint32 sensor_id;			//record sensor id defined in Kd_imgsensor.h
+	kal_uint32 checksum_value;		//checksum value for Camera Auto Test
+	imgsensor_mode_struct pre;		//preview scenario relative information
+	imgsensor_mode_struct cap;		//capture scenario relative information
+	imgsensor_mode_struct cap1;		//capture for PIP 24fps relative information, capture1 mode must use same framelength, linelength with Capture mode for shutter calculate
+	imgsensor_mode_struct normal_video;//normal video  scenario relative information
+	imgsensor_mode_struct hs_video;	//high speed video scenario relative information
+	imgsensor_mode_struct slim_video;	//slim video for VT scenario relative information
+
+	
+	kal_uint8  ae_shut_delay_frame;	//shutter delay frame for AE cycle
+	kal_uint8  ae_sensor_gain_delay_frame;	//sensor gain delay frame for AE cycle
+	kal_uint8  ae_ispGain_delay_frame;	//isp gain delay frame for AE cycle
+	kal_uint8  ihdr_support;		//1, support; 0,not support
+	kal_uint8  ihdr_le_firstline;	//1,le first ; 0, se first
+	kal_uint8  sensor_mode_num;		//support sensor mode num
+	
+	kal_uint8  cap_delay_frame;		//enter capture delay frame num
+	kal_uint8  pre_delay_frame;		//enter preview delay frame num
+	kal_uint8  video_delay_frame;	//enter video delay frame num
+	kal_uint8  hs_video_delay_frame;	//enter high speed video  delay frame num
+	kal_uint8  slim_video_delay_frame;	//enter slim video delay frame num
+
+  
+	kal_uint8  margin;				//sensor framelength & shutter margin 
+	kal_uint32 min_shutter;			//min shutter
+	kal_uint32 max_frame_length;	//max framelength by sensor register's limitation
+
+	kal_uint8  isp_driving_current;	//mclk driving current
+	kal_uint8  sensor_interface_type;//sensor_interface_type
+	kal_uint8  mipi_sensor_type; //0,MIPI_OPHY_NCSI2; 1,MIPI_OPHY_CSI2, default is NCSI2, don't modify this para
+	kal_uint8  mipi_settle_delay_mode; //0, high speed signal auto detect; 1, use settle delay,unit is ns, default is auto detect, don't modify this para
+	kal_uint8  sensor_output_dataformat;//sensor output first pixel color
+	kal_uint8  mclk;				//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
+	
+	kal_uint8  mipi_lane_num;		//mipi lane num
+	kal_uint8  i2c_addr_table[5];	//record sensor support all write id addr, only supprt 4must end with 0xff
+
+} imgsensor_info_struct;
+
+/* SENSOR READ/WRITE ID */
+//#define IMGSENSOR_WRITE_ID_1 (0x6c)
+//#define IMGSENSOR_READ_ID_1  (0x6d)
+//#define IMGSENSOR_WRITE_ID_2 (0x20)
+//#define IMGSENSOR_READ_ID_2  (0x21)
+
+extern int iReadRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u8 * a_pRecvData, u16 a_sizeRecvData, u16 i2cId);
+extern int iWriteRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u16 i2cId);
+extern void kdSetI2CSpeed(u16 i2cSpeed);
+
+#endif 
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/sp0a20_yuv/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6735m/sp0a20_yuv/Makefile
new file mode 100644
index 0000000..de9f51d
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/sp0a20_yuv/Makefile
@@ -0,0 +1,4 @@
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+
+obj-y += sp0a20_yuv_Sensor.o
+
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/sp0a20_yuv/sp0a20_yuv_CameraCustomized.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/sp0a20_yuv/sp0a20_yuv_CameraCustomized.h
new file mode 100644
index 0000000..309db8d
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/sp0a20_yuv/sp0a20_yuv_CameraCustomized.h
@@ -0,0 +1,204 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*****************************************************************************
+*  Copyright Statement:
+*  --------------------
+*  This software is protected by Copyright and the information contained
+*  herein is confidential. The software may not be copied and the information
+*  contained herein may not be used or disclosed except with the written
+*  permission of MediaTek Inc. (C) 2008
+*
+*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
+*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
+*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
+*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
+*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
+*
+*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
+*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
+*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+*
+*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
+*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
+*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
+*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
+*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
+*
+*****************************************************************************/
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *   sensor.h
+ *
+ * Project:
+ * --------
+ *   DUMA
+ *
+ * Description:
+ * ------------
+ *   Header file of camera customized parameters.
+ *
+ *
+ * Author:
+ * -------
+ *   PC Huang (MTK02204)
+ *
+ *============================================================================
+ *             HISTORY
+ * Below this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *------------------------------------------------------------------------------
+ * $Revision:$
+ * $Modtime:$
+ * $Log:$
+ *
+ * Feb 9 2010 mtk80461
+ * [DUMA00154355] JPeg Orientation feature check in
+ *
+ *
+ * Oct 27 2009 mtk02204
+ * [DUMA00015869] [Camera Driver] Modifiy camera related drivers for dual/backup sensor/lens drivers.
+ *
+ *
+ * Sep 24 2009 mtk02204
+ * [DUMA00134387] [LTK][GW616][Camera]4040 Camera:Camera Quality Test failed.
+ *
+ *
+ * Jul 8 2009 mtk02204
+ * [DUMA00008051] [Camera Driver] Add drivers for camera high ISO binning mode.
+ *
+ *
+ * Jul 8 2009 mtk02204
+ * [DUMA00008051] [Camera Driver] Add drivers for camera high ISO binning mode.
+ *
+ *
+ * Jul 7 2009 mtk02204
+ * [DUMA00008051] [Camera Driver] Add drivers for camera high ISO binning mode.
+ *
+ *
+ * Jun 6 2009 mtk02204
+ * [DUMA00119628] MTK camera_recorded video only contain audio but no video with Jean effect
+ *
+ *
+ * Apr 10 2009 mtk02204
+ * [DUMA00004178] [Camera] Check in for MTK camera integration
+ *
+ *
+ * Mar 13 2009 mtk02204
+ * [DUMA00001084] First Check in of MT6516 multimedia drivers
+ *
+ *
+ * Mar 2 2009 mtk02204
+ * [DUMA00001084] First Check in of MT6516 multimedia drivers
+ *
+ *
+ * Feb 6 2009 mtk02204
+ * [DUMA00001084] First Check in of MT6516 multimedia drivers
+ *
+ *
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *============================================================================
+ ****************************************************************************/
+
+#ifndef __CAMERA_CUSTOMIZED_H
+#define __CAMERA_CUSTOMIZED_H
+
+// the angle between handset and sensor placement in clockwise, should be one of 0, 90, 270
+#define MAIN_SENSOR_ORIENTATION_ANGLE	90	// 90
+#define SUB_SENSOR_ORIENTATION_ANGLE	0		// do not care if the sub sensor does not exist
+
+
+// First, we think you hold the cell phone vertical.
+// Second, we suppose the direction of upward is 0
+// Third, it is 90, 180, 270 in clockwise
+// here we define the main sensor and sub sensor angles to deal with the jpeg orientation
+#define MAIN_SENSOR_TO_PHONE_ANGLE	0
+#define SUB_SENSOR_TO_PHONE_ANGLE	0
+
+
+#define CAM_SIZE_QVGA_WIDTH 	320
+#define CAM_SIZE_QVGA_HEIGHT 	240
+#define CAM_SIZE_VGA_WIDTH 		640
+#define CAM_SIZE_VGA_HEIGHT 	480
+#define CAM_SIZE_05M_WIDTH 		800
+#define CAM_SIZE_05M_HEIGHT 	600
+#define CAM_SIZE_1M_WIDTH 		1280
+#define CAM_SIZE_1M_HEIGHT 		960
+#define CAM_SIZE_2M_WIDTH 		1600
+#define CAM_SIZE_2M_HEIGHT 		1200
+#define CAM_SIZE_3M_WIDTH 		2048
+#define CAM_SIZE_3M_HEIGHT 		1536
+#define CAM_SIZE_5M_WIDTH 		2592
+#define CAM_SIZE_5M_HEIGHT 		1944
+
+// for main sensor
+#define MAIN_NUM_OF_PREVIEW_RESOLUTION 3
+#define MAIN_NUM_OF_VIDEO_RESOLUTION 4
+#define MAIN_NUM_OF_STILL_RESOLUTION 7
+#define MAIN_VIDEO_RESOLUTION_PROFILE		{{176,144},{320,240},{640,480},{720,480}}
+#define MAIN_PREVIEW_RESOLUTION_PROFILE	{{232,174},{320,240},{240,320}}
+#define MAIN_STILL_RESOLUTION_PROFILE		{{CAM_SIZE_QVGA_WIDTH,CAM_SIZE_QVGA_HEIGHT}, \
+									 {CAM_SIZE_VGA_WIDTH,CAM_SIZE_VGA_HEIGHT}, \
+							//		 {CAM_SIZE_05M_WIDTH,CAM_SIZE_05M_HEIGHT}, \
+							//		 {CAM_SIZE_1M_WIDTH,CAM_SIZE_1M_HEIGHT}, \
+							//		 {CAM_SIZE_2M_WIDTH,CAM_SIZE_2M_HEIGHT}, \
+							//		 {CAM_SIZE_3M_WIDTH,CAM_SIZE_3M_HEIGHT}, \
+							//		 {CAM_SIZE_5M_WIDTH,CAM_SIZE_5M_HEIGHT}}
+
+// if sub sensor does not exist, set all the parameters as 0
+#define SUB_NUM_OF_PREVIEW_RESOLUTION 0
+#define SUB_NUM_OF_VIDEO_RESOLUTION 0
+#define SUB_NUM_OF_STILL_RESOLUTION 0
+#define SUB_VIDEO_RESOLUTION_PROFILE		{{0,0}}
+#define SUB_PREVIEW_RESOLUTION_PROFILE		{{0,0}}
+#define SUB_STILL_RESOLUTION_PROFILE		{{0,0}}
+
+//#define NUM_OF_PREVIEW_RESOLUTION 	max(MAIN_NUM_OF_PREVIEW_RESOLUTION,SUB_NUM_OF_PREVIEW_RESOLUTION)
+//#define NUM_OF_VIDEO_RESOLUTION 	max(MAIN_NUM_OF_VIDEO_RESOLUTION,SUB_NUM_OF_VIDEO_RESOLUTION)
+//#define NUM_OF_STILL_RESOLUTION 	max(MAIN_NUM_OF_STILL_RESOLUTION,SUB_NUM_OF_STILL_RESOLUTION)
+
+#define NUM_OF_VIDEO_STREAM_BUFF	8	// Maximun is 8
+#endif
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/sp0a20_yuv/sp0a20_yuv_Camera_Sensor_para.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/sp0a20_yuv/sp0a20_yuv_Camera_Sensor_para.h
new file mode 100644
index 0000000..dc3e3d4
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/sp0a20_yuv/sp0a20_yuv_Camera_Sensor_para.h
@@ -0,0 +1,170 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*****************************************************************************
+*  Copyright Statement:
+*  --------------------
+*  This software is protected by Copyright and the information contained
+*  herein is confidential. The software may not be copied and the information
+*  contained herein may not be used or disclosed except with the written
+*  permission of MediaTek Inc. (C) 2008
+*
+*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
+*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
+*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
+*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
+*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
+*
+*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
+*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
+*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+*
+*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
+*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
+*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
+*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
+*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
+*
+*****************************************************************************/
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *   camera_sensor_para.h
+ *
+ * Project:
+ * --------
+ *   DUMA
+ *
+ * Description:
+ * ------------
+ *   Header file of Sensor tuning parameters that should be generated by CCT
+ *
+ *
+ * Author:
+ * -------
+ *
+ *============================================================================
+ *             HISTORY
+ * Below this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *------------------------------------------------------------------------------
+ * $Revision:$
+ * $Modtime:$
+ * $Log:$
+ *
+ * Mar 4 2010 mtk70508
+ * [DUMA00154792] Sensor driver
+ * 
+ *
+ * Feb 24 2010 mtk01118
+ * [DUMA00025869] [Camera][YUV I/F & Query feature] check in camera code
+ * 
+ *
+ * Apr 7 2009 mtk02204
+ * [DUMA00004012] [Camera] Restructure and rename camera related custom folders and folder name of came
+ * 
+ *
+ * Feb 24 2009 mtk02204
+ * [DUMA00001084] First Check in of MT6516 multimedia drivers
+ * 
+ *
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *============================================================================
+ ****************************************************************************/
+/* SENSOR FULL SIZE */
+#ifndef __CAMERA_SENSOR_PARA_H
+#define __CAMERA_SENSOR_PARA_H
+
+#define CAMERA_SENSOR_REG_DEFAULT_VALUE  \
+		/* ARRAY: SENSOR.reg[11] */\
+		{\
+			/* STRUCT: SENSOR.reg[0] */\
+			{\
+				/* SENSOR.reg[0].addr */ 0x00000304, /* SENSOR.reg[0].para */ 0x00000000\
+			},\
+			/* STRUCT: SENSOR.reg[1] */\
+			{\
+				/* SENSOR.reg[1].addr */ 0x00000305, /* SENSOR.reg[1].para */ 0x0000000D\
+			},\
+			/* STRUCT: SENSOR.reg[2] */\
+			{\
+				/* SENSOR.reg[2].addr */ 0x00000306, /* SENSOR.reg[2].para */ 0x00000000\
+			},\
+			/* STRUCT: SENSOR.reg[3] */\
+			{\
+				/* SENSOR.reg[3].addr */ 0x00000307, /* SENSOR.reg[3].para */ 0x000000C0\
+			},\
+			/* STRUCT: SENSOR.reg[4] */\
+			{\
+				/* SENSOR.reg[4].addr */ 0x00000300, /* SENSOR.reg[4].para */ 0x00000000\
+			},\
+			/* STRUCT: SENSOR.reg[5] */\
+			{\
+				/* SENSOR.reg[5].addr */ 0x00000301, /* SENSOR.reg[5].para */ 0x00000004\
+			},\
+			/* STRUCT: SENSOR.reg[6] */\
+			{\
+				/* SENSOR.reg[6].addr */ 0x0000030A, /* SENSOR.reg[6].para */ 0x00000000\
+			},\
+			/* STRUCT: SENSOR.reg[7] */\
+			{\
+				/* SENSOR.reg[7].addr */ 0x0000030B, /* SENSOR.reg[7].para */ 0x00000002\
+			},\
+			/* STRUCT: SENSOR.reg[8] */\
+			{\
+				/* SENSOR.reg[8].addr */ 0x00000308, /* SENSOR.reg[8].para */ 0x00000000\
+			},\
+			/* STRUCT: SENSOR.reg[9] */\
+			{\
+				/* SENSOR.reg[9].addr */ 0x00000309, /* SENSOR.reg[9].para */ 0x00000008\
+			},\
+			/* STRUCT: SENSOR.reg[10] */\
+			{\
+				/* SENSOR.reg[10].addr */ 0xFFFFFFFF, /* SENSOR.reg[10].para */ 0x00000001\
+			}\
+		}
+
+#define CAMERA_SENSOR_CCT_DEFAULT_VALUE {{ 0xFFFFFFFF, 0x08 } ,{ 0x0209, 0x0008 } ,{ 0x0207, 0x0008 } ,{ 0x020D, 0x0008 } ,{ 0x020B, 0x0008 }}
+#endif /* __CAMERA_SENSOR_PARA_H */
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/sp0a20_yuv/sp0a20_yuv_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/sp0a20_yuv/sp0a20_yuv_Sensor.c
new file mode 100644
index 0000000..7a3e90e
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/sp0a20_yuv/sp0a20_yuv_Sensor.c
@@ -0,0 +1,2123 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *   SP0A20yuv_Sensor.c
+ *
+ * Project:
+ * --------
+ *   MAUI
+ *
+ * Description:
+ * ------------
+ *   Image sensor driver function
+ *   V1.2.3
+ *
+ * Author:
+ * -------
+ *   Leo
+ *
+ *=============================================================
+ *             HISTORY
+ * Below this line, this part is controlled by GCoreinc. DO NOT MODIFY!!
+ *------------------------------------------------------------------------------
+ * $Log$
+ * 2012.02.29  kill bugs
+ *
+ *
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by GCoreinc. DO NOT MODIFY!!
+ *=============================================================
+ ******************************************************************************/
+#include <linux/videodev2.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <asm/atomic.h>
+
+#include "kd_camera_hw.h"
+#include "kd_imgsensor.h"
+#include "kd_imgsensor_define.h"
+#include "kd_imgsensor_errcode.h"
+#include "kd_camera_feature.h"
+
+#include "sp0a20_yuv_Sensor.h"
+#include "sp0a20_yuv_Camera_Sensor_para.h"
+#include "sp0a20_yuv_CameraCustomized.h"
+
+#define SP0A20YUV_DEBUG
+
+#ifdef SP0A20YUV_DEBUG
+#define SENSORDB printk
+#else
+#define SENSORDB(x,...)
+#endif
+kal_bool   SP0A20_TST_PATTEN = KAL_FALSE;  //wxl
+//#define DEBUG_SENSOR_SP0A20//T_flash Tuning
+#define SP0A20_TEST_PATTERN_CHECKSUM (0xaf010c1c)
+
+#ifdef SLT_DEVINFO_CMM 
+#include  <linux/dev_info.h>
+static struct devinfo_struct *s_DEVINFO_ccm;   //suppose 10 max lcm device 
+#endif
+
+extern int iReadRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u8 * a_pRecvData, u16 a_sizeRecvData, u16 i2cId);
+extern int iWriteRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u16 i2cId);
+static struct SP0A20_Sensor_Struct SP0A20_Sensor_Driver;
+kal_uint8 isBanding = 0; // 0: 50hz  1:60hz
+
+kal_uint16 SP0A20_write_cmos_sensor(kal_uint8 addr, kal_uint8 para)
+{
+    char puSendCmd[2] = {(char)(addr & 0xFF) , (char)(para & 0xFF)};
+	
+	iWriteRegI2C(puSendCmd , 2, SP0A20_WRITE_ID);
+
+}
+
+kal_uint16 SP0A20_read_cmos_sensor(kal_uint8 addr)
+{
+	kal_uint16 get_byte=0;
+    char puSendCmd = { (char)(addr & 0xFF) };
+	iReadRegI2C(&puSendCmd , 1, (u8*)&get_byte, 1, SP0A20_WRITE_ID);
+	
+    return get_byte;
+}
+
+
+#ifdef DEBUG_SENSOR_SP0A20
+#define SP0A20_OP_CODE_INI		0x00		/* Initial value. */
+#define SP0A20_OP_CODE_REG		0x01		/* Register */
+#define SP0A20_OP_CODE_DLY		0x02		/* Delay */
+#define SP0A20_OP_CODE_END	0x03		/* End of initial setting. */
+	kal_uint16 fromsd;
+
+typedef struct
+{
+	u16 init_reg;
+	u16 init_val;	/* Save the register value and delay tick */
+	u8 op_code;		/* 0 - Initial value, 1 - Register, 2 - Delay, 3 - End of setting. */
+} SP0A20_initial_set_struct;
+
+SP0A20_initial_set_struct SP0A20_Init_Reg[5000];
+
+static u32 strtol(const char *nptr, u8 base)
+{
+
+	printk("SP0A20___%s____\n",__func__); 
+
+	u8 ret;
+	if(!nptr || (base!=16 && base!=10 && base!=8))
+	{
+		printk("SP0A20 %s(): NULL pointer input\n", __FUNCTION__);
+		return -1;
+	}
+	for(ret=0; *nptr; nptr++)
+	{
+		if((base==16 && *nptr>='A' && *nptr<='F') || 
+				(base==16 && *nptr>='a' && *nptr<='f') || 
+				(base>=10 && *nptr>='0' && *nptr<='9') ||
+				(base>=8 && *nptr>='0' && *nptr<='7') )
+		{
+			ret *= base;
+			if(base==16 && *nptr>='A' && *nptr<='F')
+				ret += *nptr-'A'+10;
+			else if(base==16 && *nptr>='a' && *nptr<='f')
+				ret += *nptr-'a'+10;
+			else if(base>=10 && *nptr>='0' && *nptr<='9')
+				ret += *nptr-'0';
+			else if(base>=8 && *nptr>='0' && *nptr<='7')
+				ret += *nptr-'0';
+		}
+		else
+			return ret;
+	}
+	return ret;
+}
+
+static u8 SP0A20_Initialize_from_T_Flash()
+{
+	//FS_HANDLE fp = -1;				/* Default, no file opened. */
+	//u8 *data_buff = NULL;
+	u8 *curr_ptr = NULL;
+	u32 file_size = 0;
+	//u32 bytes_read = 0;
+	u32 i = 0, j = 0;
+	u8 func_ind[4] = {0};	/* REG or DLY */
+
+
+	struct file *fp; 
+	mm_segment_t fs; 
+	loff_t pos = 0; 
+	static u8 data_buff[10*1024] ;
+
+    fp = filp_open("/mnt/sdcard/sp0a20_sd", O_RDONLY , 0); 
+    if (IS_ERR(fp)) { 
+        printk("create file error\n");  
+		return -1; 
+	} 
+	fs = get_fs(); 
+	set_fs(KERNEL_DS); 
+
+	file_size = vfs_llseek(fp, 0, SEEK_END);
+	vfs_read(fp, data_buff, file_size, &pos); 
+	//printk("%s %d %d\n", buf,iFileLen,pos); 
+	filp_close(fp, NULL); 
+	set_fs(fs);
+
+	/* Start parse the setting witch read from t-flash. */
+	curr_ptr = data_buff;
+	while (curr_ptr < (data_buff + file_size))
+	{
+		while ((*curr_ptr == ' ') || (*curr_ptr == '\t'))/* Skip the Space & TAB */
+			curr_ptr++;				
+
+		if (((*curr_ptr) == '/') && ((*(curr_ptr + 1)) == '*'))
+		{
+			while (!(((*curr_ptr) == '*') && ((*(curr_ptr + 1)) == '/')))
+			{
+				curr_ptr++;		/* Skip block comment code. */
+			}
+
+			while (!((*curr_ptr == 0x0D) && (*(curr_ptr+1) == 0x0A)))
+			{
+				curr_ptr++;
+			}
+
+			curr_ptr += 2;						/* Skip the enter line */
+
+			continue ;
+		}
+
+		if (((*curr_ptr) == '/') || ((*curr_ptr) == '{') || ((*curr_ptr) == '}'))		/* Comment line, skip it. */
+		{
+			while (!((*curr_ptr == 0x0D) && (*(curr_ptr+1) == 0x0A)))
+			{
+				curr_ptr++;
+			}
+
+			curr_ptr += 2;						/* Skip the enter line */
+
+			continue ;
+		}
+		/* This just content one enter line. */
+		if (((*curr_ptr) == 0x0D) && ((*(curr_ptr + 1)) == 0x0A))
+		{
+			curr_ptr += 2;
+			continue ;
+		}
+		//printk(" curr_ptr1 = %s\n",curr_ptr);
+		memcpy(func_ind, curr_ptr, 3);
+
+
+		if (strcmp((const char *)func_ind, "REG") == 0)		/* REG */
+		{
+			curr_ptr += 6;				/* Skip "REG(0x" or "DLY(" */
+			SP0A20_Init_Reg[i].op_code = SP0A20_OP_CODE_REG;
+
+			SP0A20_Init_Reg[i].init_reg = strtol((const char *)curr_ptr, 16);
+			curr_ptr += 5;	/* Skip "00, 0x" */
+
+			SP0A20_Init_Reg[i].init_val = strtol((const char *)curr_ptr, 16);
+			curr_ptr += 4;	/* Skip "00);" */
+
+		}
+		else									/* DLY */
+		{
+			/* Need add delay for this setting. */ 
+			curr_ptr += 4;	
+			SP0A20_Init_Reg[i].op_code = SP0A20_OP_CODE_DLY;
+
+			SP0A20_Init_Reg[i].init_reg = 0xFF;
+			SP0A20_Init_Reg[i].init_val = strtol((const char *)curr_ptr,  10);	/* Get the delay ticks, the delay should less then 50 */
+		}
+		i++;
+
+
+		/* Skip to next line directly. */
+		while (!((*curr_ptr == 0x0D) && (*(curr_ptr+1) == 0x0A)))
+		{
+			curr_ptr++;
+		}
+		curr_ptr += 2;
+	}
+
+	/* (0xFFFF, 0xFFFF) means the end of initial setting. */
+	SP0A20_Init_Reg[i].op_code = SP0A20_OP_CODE_END;
+	SP0A20_Init_Reg[i].init_reg = 0xFF;
+	SP0A20_Init_Reg[i].init_val = 0xFF;
+	i++;
+	//for (j=0; j<i; j++)
+		//printk(" %x  ==  %x\n",SP0A20_Init_Reg[j].init_reg, SP0A20_Init_Reg[j].init_val);
+
+	/* Start apply the initial setting to sensor. */
+#if 1
+	for (j=0; j<i; j++)
+	{
+		if (SP0A20_Init_Reg[j].op_code == SP0A20_OP_CODE_END)	/* End of the setting. */
+		{
+			break ;
+		}
+		else if (SP0A20_Init_Reg[j].op_code == SP0A20_OP_CODE_DLY)
+		{
+			msleep(SP0A20_Init_Reg[j].init_val);		/* Delay */
+		}
+		else if (SP0A20_Init_Reg[j].op_code == SP0A20_OP_CODE_REG)
+		{
+			SP0A20_write_cmos_sensor(SP0A20_Init_Reg[j].init_reg, SP0A20_Init_Reg[j].init_val);
+		}
+		else
+		{
+			printk("REG ERROR!\n");
+		}
+	}
+#endif
+
+	return 1;	
+}
+
+#endif
+
+/*******************************************************************************
+ * // Adapter for Winmo typedef
+ ********************************************************************************/
+#define WINMO_USE 0
+
+#define Sleep(ms) mdelay(ms)
+#define RETAILMSG(x,...)
+#define TEXT
+
+kal_bool   SP0A20_MPEG4_encode_mode = KAL_FALSE;
+kal_uint16 SP0A20_dummy_pixels = 0, SP0A20_dummy_lines = 0;
+kal_bool   SP0A20_MODE_CAPTURE = KAL_FALSE;
+kal_bool   SP0A20_NIGHT_MODE = KAL_FALSE;
+
+kal_uint32 SP0A20_isp_master_clock;
+static kal_uint32 SP0A20_g_fPV_PCLK = 24;
+
+kal_uint8 SP0A20_sensor_write_I2C_address = SP0A20_WRITE_ID;
+kal_uint8 SP0A20_sensor_read_I2C_address = SP0A20_READ_ID;
+
+UINT8 SP0A20PixelClockDivider=0;
+
+MSDK_SENSOR_CONFIG_STRUCT SP0A20SensorConfigData;
+
+/*************************************************************************
+ * FUNCTION
+ *	SP0A20_SetShutter
+ *
+ * DESCRIPTION
+ *	This function set e-shutter of SP0A20 to change exposure time.
+ *
+ * PARAMETERS
+ *   iShutter : exposured lines
+ *
+ * RETURNS
+ *	None
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+void SP0A20_Set_Shutter(kal_uint16 iShutter)
+{
+} /* Set_SP0A20_Shutter */
+
+
+/*************************************************************************
+ * FUNCTION
+ *	SP0A20_read_Shutter
+ *
+ * DESCRIPTION
+ *	This function read e-shutter of SP0A20 .
+ *
+ * PARAMETERS
+ *  None
+ *
+ * RETURNS
+ *	None
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+kal_uint16 SP0A20_Read_Shutter(void)
+{
+    	kal_uint8 temp_reg1, temp_reg2;
+	kal_uint16 shutter;
+
+	temp_reg1 = SP0A20_read_cmos_sensor(0x04);
+	temp_reg2 = SP0A20_read_cmos_sensor(0x03);
+
+	shutter = (temp_reg1 & 0xFF) | (temp_reg2 << 8);
+
+	return shutter;
+} /* SP0A20_read_shutter */
+
+
+/*************************************************************************
+ * FUNCTION
+ *	SP0A20_write_reg
+ *
+ * DESCRIPTION
+ *	This function set the register of SP0A20.
+ *
+ * PARAMETERS
+ *	addr : the register index of SP0A20
+ *  para : setting parameter of the specified register of SP0A20
+ *
+ * RETURNS
+ *	None
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+void SP0A20_write_reg(kal_uint32 addr, kal_uint32 para)
+{
+	SP0A20_write_cmos_sensor(addr, para);
+} /* SP0A20_write_reg() */
+
+
+/*************************************************************************
+ * FUNCTION
+ *	SP0A20_read_cmos_sensor
+ *
+ * DESCRIPTION
+ *	This function read parameter of specified register from SP0A20.
+ *
+ * PARAMETERS
+ *	addr : the register index of SP0A20
+ *
+ * RETURNS
+ *	the data that read from SP0A20
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+kal_uint32 SP0A20_read_reg(kal_uint32 addr)
+{
+	return SP0A20_read_cmos_sensor(addr);
+} /* OV7670_read_reg() */
+
+
+/*************************************************************************
+* FUNCTION
+*	SP0A20_awb_enable
+*
+* DESCRIPTION
+*	This function enable or disable the awb (Auto White Balance).
+*
+* PARAMETERS
+*	1. kal_bool : KAL_TRUE - enable awb, KAL_FALSE - disable awb.
+*
+* RETURNS
+*	kal_bool : It means set awb right or not.
+*
+*************************************************************************/
+static void SP0A20_awb_enable(kal_bool enalbe)
+{	 
+	kal_uint16 temp_AWB_reg = 0;
+
+	temp_AWB_reg = SP0A20_read_cmos_sensor(0x42);
+	
+	if (enalbe)
+	{
+		SP0A20_write_cmos_sensor(0x42, (temp_AWB_reg |0x02));
+	}
+	else
+	{
+		SP0A20_write_cmos_sensor(0x42, (temp_AWB_reg & (~0x02)));
+	}
+
+}
+
+
+/*************************************************************************
+ * FUNCTION
+ *	SP0A20_config_window
+ *
+ * DESCRIPTION
+ *	This function config the hardware window of SP0A20 for getting specified
+ *  data of that window.
+ *
+ * PARAMETERS
+ *	start_x : start column of the interested window
+ *  start_y : start row of the interested window
+ *  width  : column widht of the itnerested window
+ *  height : row depth of the itnerested window
+ *
+ * RETURNS
+ *	the data that read from SP0A20
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+void SP0A20_config_window(kal_uint16 startx, kal_uint16 starty, kal_uint16 width, kal_uint16 height)
+{
+} /* SP0A20_config_window */
+
+
+/*************************************************************************
+ * FUNCTION
+ *	SP0A20_SetGain
+ *
+ * DESCRIPTION
+ *	This function is to set global gain to sensor.
+ *
+ * PARAMETERS
+ *   iGain : sensor global gain(base: 0x40)
+ *
+ * RETURNS
+ *	the actually gain set to sensor.
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+kal_uint16 SP0A20_SetGain(kal_uint16 iGain)
+{
+	return iGain;
+}
+
+
+/*************************************************************************
+ * FUNCTION
+ *	SP0A20_NightMode
+ *
+ * DESCRIPTION
+ *	This function night mode of SP0A20.
+ *
+ * PARAMETERS
+ *	bEnable: KAL_TRUE -> enable night mode, otherwise, disable night mode
+ *
+ * RETURNS
+ *	None
+ *
+ * GLOBALS AFFECTED   ///070312101020  
+ *
+ *************************************************************************/
+static void SP0A20_night_mode(kal_bool bEnable)
+{
+    if(SP0A20_TST_PATTEN==KAL_TRUE)
+		return;
+	if (!SP0A20_Sensor_Driver.MODE_CAPTURE) { 
+		if(bEnable)//night mode
+		{ 
+			SP0A20_Sensor_Driver.bNight_mode = KAL_TRUE;
+			SP0A20_write_cmos_sensor(0xfd,0x01);
+			SP0A20_write_cmos_sensor(0xcd,0x20);
+			SP0A20_write_cmos_sensor(0xce,0x1f);
+
+			if(SP0A20_Sensor_Driver.MPEG4_encode_mode == KAL_TRUE)
+			{
+				if(isBanding== 0)
+				{
+					printk("video 50Hz night\n");	
+#if 0
+					//Video record night 24M 50hz 10.02-10fps maxgain				                     
+					SP0A20_write_cmos_sensor(0xfd , 0x00);
+					SP0A20_write_cmos_sensor(0x03 , 0x01);
+					SP0A20_write_cmos_sensor(0x04 , 0x2c);
+					SP0A20_write_cmos_sensor(0x05 , 0x00);
+					SP0A20_write_cmos_sensor(0x06 , 0x00);
+					SP0A20_write_cmos_sensor(0x07 , 0x00);
+					SP0A20_write_cmos_sensor(0x08 , 0x00);
+					SP0A20_write_cmos_sensor(0x09 , 0x06);
+					SP0A20_write_cmos_sensor(0x0a , 0x14);
+					SP0A20_write_cmos_sensor(0xfd , 0x01);
+					SP0A20_write_cmos_sensor(0xf0 , 0x00);
+					SP0A20_write_cmos_sensor(0xf7 , 0x32);
+					SP0A20_write_cmos_sensor(0x02 , 0x0a);
+					SP0A20_write_cmos_sensor(0x03 , 0x01);
+					SP0A20_write_cmos_sensor(0x06 , 0x32);
+					SP0A20_write_cmos_sensor(0x07 , 0x00);
+					SP0A20_write_cmos_sensor(0x08 , 0x01);
+					SP0A20_write_cmos_sensor(0x09 , 0x00);
+					SP0A20_write_cmos_sensor(0xfd , 0x02);
+					SP0A20_write_cmos_sensor(0xbe , 0xf4);
+					SP0A20_write_cmos_sensor(0xbf , 0x01);
+					SP0A20_write_cmos_sensor(0xd0 , 0xf4);
+					SP0A20_write_cmos_sensor(0xd1 , 0x01);
+#else//Video record night 24M 50hz 12-12fps maxgain	
+					SP0A20_write_cmos_sensor(0xfd,0x00);
+					SP0A20_write_cmos_sensor(0x03,0x01);
+					SP0A20_write_cmos_sensor(0x04,0x68);
+					SP0A20_write_cmos_sensor(0x05,0x00);
+					SP0A20_write_cmos_sensor(0x06,0x00);
+					SP0A20_write_cmos_sensor(0x07,0x00);
+					SP0A20_write_cmos_sensor(0x08,0x00);
+					SP0A20_write_cmos_sensor(0x09,0x04);
+					SP0A20_write_cmos_sensor(0x0a,0x84);
+					SP0A20_write_cmos_sensor(0xfd,0x01);
+					SP0A20_write_cmos_sensor(0xf0,0x00);
+					SP0A20_write_cmos_sensor(0xf7,0x3c);
+					SP0A20_write_cmos_sensor(0x02,0x08);
+					SP0A20_write_cmos_sensor(0x03,0x01);
+					SP0A20_write_cmos_sensor(0x06,0x3c);
+					SP0A20_write_cmos_sensor(0x07,0x00);
+					SP0A20_write_cmos_sensor(0x08,0x01);
+					SP0A20_write_cmos_sensor(0x09,0x00);
+					SP0A20_write_cmos_sensor(0xfd,0x02);
+					SP0A20_write_cmos_sensor(0xbe,0xe0);
+					SP0A20_write_cmos_sensor(0xbf,0x01);
+					SP0A20_write_cmos_sensor(0xd0,0xe0);
+					SP0A20_write_cmos_sensor(0xd1,0x01);
+#endif
+
+					//dbg_print(" video 50Hz night\r\n");
+				}
+				else if(isBanding == 1)
+				{
+					//Video record night 24M 60Hz 10-10FPS maxgain:
+					SP0A20_write_cmos_sensor(0xfd,0x00);
+					SP0A20_write_cmos_sensor(0x03,0x01);
+					SP0A20_write_cmos_sensor(0x04,0x2c);
+					SP0A20_write_cmos_sensor(0x05,0x00);
+					SP0A20_write_cmos_sensor(0x06,0x00);
+					SP0A20_write_cmos_sensor(0x07,0x00);
+					SP0A20_write_cmos_sensor(0x08,0x00);
+					SP0A20_write_cmos_sensor(0x09,0x04);
+					SP0A20_write_cmos_sensor(0x0a,0x84);
+					SP0A20_write_cmos_sensor(0xfd,0x01);
+					SP0A20_write_cmos_sensor(0xf0,0x00);
+					SP0A20_write_cmos_sensor(0xf7,0x32);
+					SP0A20_write_cmos_sensor(0x02,0x0a);
+					SP0A20_write_cmos_sensor(0x03,0x01);
+					SP0A20_write_cmos_sensor(0x06,0x32);
+					SP0A20_write_cmos_sensor(0x07,0x00);
+					SP0A20_write_cmos_sensor(0x08,0x01);
+					SP0A20_write_cmos_sensor(0x09,0x00);
+					SP0A20_write_cmos_sensor(0xfd,0x02);
+					SP0A20_write_cmos_sensor(0xbe,0xf4);
+					SP0A20_write_cmos_sensor(0xbf,0x01);
+					SP0A20_write_cmos_sensor(0xd0,0xf4);
+					SP0A20_write_cmos_sensor(0xd1,0x01);
+
+
+					printk(" video 60Hz night\r\n");
+				}
+			}	
+			else 
+			{
+				//	dbg_print(" SP0A20_banding=%x\r\n",SP0A20_banding);
+				if(isBanding== 0)
+				{
+					//capture preview night 24M 50hz 10-10fps maxgain:	 
+						SP0A20_write_cmos_sensor(0xfd , 0x00);
+					SP0A20_write_cmos_sensor(0x03 , 0x01);
+					SP0A20_write_cmos_sensor(0x04 , 0x68);
+					SP0A20_write_cmos_sensor(0x05 , 0x00);
+					SP0A20_write_cmos_sensor(0x06 , 0x00);
+					SP0A20_write_cmos_sensor(0x07 , 0x00);
+					SP0A20_write_cmos_sensor(0x08 , 0x00);
+					SP0A20_write_cmos_sensor(0x09 , 0x04);
+					SP0A20_write_cmos_sensor(0x0a , 0x84);
+					SP0A20_write_cmos_sensor(0xfd , 0x01);
+					SP0A20_write_cmos_sensor(0xf0 , 0x00);
+					SP0A20_write_cmos_sensor(0xf7 , 0x3c);
+					SP0A20_write_cmos_sensor(0x02 , 0x10);
+					SP0A20_write_cmos_sensor(0x03 , 0x01);
+					SP0A20_write_cmos_sensor(0x06 , 0x3c);
+					SP0A20_write_cmos_sensor(0x07 , 0x00);
+					SP0A20_write_cmos_sensor(0x08 , 0x01);
+					SP0A20_write_cmos_sensor(0x09 , 0x00);
+					SP0A20_write_cmos_sensor(0xfd , 0x02);
+					SP0A20_write_cmos_sensor(0xbe , 0xc0);
+					SP0A20_write_cmos_sensor(0xbf , 0x03);
+					SP0A20_write_cmos_sensor(0xd0 , 0xc0);
+					SP0A20_write_cmos_sensor(0xd1 , 0x03);
+
+					printk(" priview 50Hz night\r\n");	
+				}  
+				else if(isBanding== 1)
+				{
+					//capture preview night 24M 60hz 10-10FPS maxgain:
+					SP0A20_write_cmos_sensor(0xfd , 0x00);
+					SP0A20_write_cmos_sensor(0x03 , 0x00);
+					SP0A20_write_cmos_sensor(0x04 , 0xfc);
+					SP0A20_write_cmos_sensor(0x05 , 0x00);
+					SP0A20_write_cmos_sensor(0x06 , 0x00);
+					SP0A20_write_cmos_sensor(0x07 , 0x00);
+					SP0A20_write_cmos_sensor(0x08 , 0x00);
+					SP0A20_write_cmos_sensor(0x09 , 0x06);
+					SP0A20_write_cmos_sensor(0x0a , 0x01);
+					SP0A20_write_cmos_sensor(0xfd , 0x01);
+					SP0A20_write_cmos_sensor(0xf0 , 0x00);
+					SP0A20_write_cmos_sensor(0xf7 , 0x2a);
+					SP0A20_write_cmos_sensor(0x02 , 0x0c);
+					SP0A20_write_cmos_sensor(0x03 , 0x01);
+					SP0A20_write_cmos_sensor(0x06 , 0x2a);
+					SP0A20_write_cmos_sensor(0x07 , 0x00);
+					SP0A20_write_cmos_sensor(0x08 , 0x01);
+					SP0A20_write_cmos_sensor(0x09 , 0x00);
+					SP0A20_write_cmos_sensor(0xfd , 0x02);
+					SP0A20_write_cmos_sensor(0xbe , 0xf8);
+					SP0A20_write_cmos_sensor(0xbf , 0x01);
+					SP0A20_write_cmos_sensor(0xd0 , 0xf8);
+					SP0A20_write_cmos_sensor(0xd1 , 0x01);
+
+					printk(" priview 60Hz night\r\n");	
+				}
+			} 		
+		}
+		else    // daylight mode
+		{
+			SP0A20_Sensor_Driver.bNight_mode = KAL_FALSE;
+			SP0A20_write_cmos_sensor(0xfd,0x01);
+			SP0A20_write_cmos_sensor(0xcd,0x10);
+			SP0A20_write_cmos_sensor(0xce,0x1f);  
+			if(SP0A20_Sensor_Driver.MPEG4_encode_mode == KAL_TRUE)
+			{
+				//dbg_print(" SP0A20_banding=%x\r\n",SP0A20_banding);
+				if(isBanding== 0)
+				{
+					//Video record daylight 24M 50hz 12-12FPS maxgain:                     
+					SP0A20_write_cmos_sensor(0xfd , 0x00);
+					SP0A20_write_cmos_sensor(0x03 , 0x01);
+					SP0A20_write_cmos_sensor(0x04 , 0x68);
+					SP0A20_write_cmos_sensor(0x05 , 0x00);
+					SP0A20_write_cmos_sensor(0x06 , 0x00);
+					SP0A20_write_cmos_sensor(0x07 , 0x00);
+					SP0A20_write_cmos_sensor(0x08 , 0x00);
+					SP0A20_write_cmos_sensor(0x09 , 0x04);
+					SP0A20_write_cmos_sensor(0x0a , 0x84);
+					SP0A20_write_cmos_sensor(0xfd , 0x01);
+					SP0A20_write_cmos_sensor(0xf0 , 0x00);
+					SP0A20_write_cmos_sensor(0xf7 , 0x3c);
+					SP0A20_write_cmos_sensor(0x02 , 0x08);
+					SP0A20_write_cmos_sensor(0x03 , 0x01);
+					SP0A20_write_cmos_sensor(0x06 , 0x3c);
+					SP0A20_write_cmos_sensor(0x07 , 0x00);
+					SP0A20_write_cmos_sensor(0x08 , 0x01);
+					SP0A20_write_cmos_sensor(0x09 , 0x00);
+					SP0A20_write_cmos_sensor(0xfd , 0x02);
+					SP0A20_write_cmos_sensor(0xbe , 0xe0);
+					SP0A20_write_cmos_sensor(0xbf , 0x01);
+					SP0A20_write_cmos_sensor(0xd0 , 0xe0);
+					SP0A20_write_cmos_sensor(0xd1 , 0x01);
+
+					printk(" video 50Hz normal\r\n");				
+				}
+				else if(isBanding == 1)
+				{
+					//Video record daylight 24M 60Hz 12-12FPS maxgain:
+					SP0A20_write_cmos_sensor(0xfd , 0x00);
+					SP0A20_write_cmos_sensor(0x03 , 0x01);
+					SP0A20_write_cmos_sensor(0x04 , 0x2c);
+					SP0A20_write_cmos_sensor(0x05 , 0x00);
+					SP0A20_write_cmos_sensor(0x06 , 0x00);
+					SP0A20_write_cmos_sensor(0x07 , 0x00);
+					SP0A20_write_cmos_sensor(0x08 , 0x00);
+					SP0A20_write_cmos_sensor(0x09 , 0x04);
+					SP0A20_write_cmos_sensor(0x0a , 0x84);
+					SP0A20_write_cmos_sensor(0xfd , 0x01);
+					SP0A20_write_cmos_sensor(0xf0 , 0x00);
+					SP0A20_write_cmos_sensor(0xf7 , 0x32);
+					SP0A20_write_cmos_sensor(0x02 , 0x0a);
+					SP0A20_write_cmos_sensor(0x03 , 0x01);
+					SP0A20_write_cmos_sensor(0x06 , 0x32);
+					SP0A20_write_cmos_sensor(0x07 , 0x00);
+					SP0A20_write_cmos_sensor(0x08 , 0x01);
+					SP0A20_write_cmos_sensor(0x09 , 0x00);
+					SP0A20_write_cmos_sensor(0xfd , 0x02);
+					SP0A20_write_cmos_sensor(0xbe , 0xf4);
+					SP0A20_write_cmos_sensor(0xbf , 0x01);
+					SP0A20_write_cmos_sensor(0xd0 , 0xf4);
+					SP0A20_write_cmos_sensor(0xd1 , 0x01);
+					printk(" video 60Hz normal\r\n");	
+				}
+			}
+			else 
+			{
+				if(isBanding== 0)
+				{	
+					//capture preview daylight 24M 50hz 12-8FPS maxgain:   
+					SP0A20_write_cmos_sensor(0xfd,0x00);
+					SP0A20_write_cmos_sensor(0x03,0x01);
+					SP0A20_write_cmos_sensor(0x04,0x68);
+					SP0A20_write_cmos_sensor(0x05,0x00);
+					SP0A20_write_cmos_sensor(0x06,0x00);
+					SP0A20_write_cmos_sensor(0x07,0x00);
+					SP0A20_write_cmos_sensor(0x08,0x00);
+					SP0A20_write_cmos_sensor(0x09,0x04);
+					SP0A20_write_cmos_sensor(0x0a,0x84);
+					SP0A20_write_cmos_sensor(0xfd,0x01);
+					SP0A20_write_cmos_sensor(0xf0,0x00);
+					SP0A20_write_cmos_sensor(0xf7,0x3c);
+					SP0A20_write_cmos_sensor(0x02,0x0c);
+					SP0A20_write_cmos_sensor(0x03,0x01);
+					SP0A20_write_cmos_sensor(0x06,0x3c);
+					SP0A20_write_cmos_sensor(0x07,0x00);
+					SP0A20_write_cmos_sensor(0x08,0x01);
+					SP0A20_write_cmos_sensor(0x09,0x00);
+					SP0A20_write_cmos_sensor(0xfd,0x02);
+					SP0A20_write_cmos_sensor(0xbe,0xd0);
+					SP0A20_write_cmos_sensor(0xbf,0x02);
+					SP0A20_write_cmos_sensor(0xd0,0xd0);
+					SP0A20_write_cmos_sensor(0xd1,0x02);
+					
+					printk(" priview 50Hz normal\r\n");
+				}
+				else if(isBanding== 1)
+				{
+					//capture preview daylight 24M 60hz 8-12FPS maxgain:
+					SP0A20_write_cmos_sensor(0xfd , 0x00);
+					SP0A20_write_cmos_sensor(0x03 , 0x01);
+					SP0A20_write_cmos_sensor(0x04 , 0x2c);
+					SP0A20_write_cmos_sensor(0x05 , 0x00);
+					SP0A20_write_cmos_sensor(0x06 , 0x00);
+					SP0A20_write_cmos_sensor(0x07 , 0x00);
+					SP0A20_write_cmos_sensor(0x08 , 0x00);
+					SP0A20_write_cmos_sensor(0x09 , 0x04);
+					SP0A20_write_cmos_sensor(0x0a , 0x84);
+					SP0A20_write_cmos_sensor(0xfd , 0x01);
+					SP0A20_write_cmos_sensor(0xf0 , 0x00);
+					SP0A20_write_cmos_sensor(0xf7 , 0x32);
+					SP0A20_write_cmos_sensor(0x02 , 0x0f);
+					SP0A20_write_cmos_sensor(0x03 , 0x01);
+					SP0A20_write_cmos_sensor(0x06 , 0x32);
+					SP0A20_write_cmos_sensor(0x07 , 0x00);
+					SP0A20_write_cmos_sensor(0x08 , 0x01);
+					SP0A20_write_cmos_sensor(0x09 , 0x00);
+					SP0A20_write_cmos_sensor(0xfd , 0x02);
+					SP0A20_write_cmos_sensor(0xbe , 0xee);
+					SP0A20_write_cmos_sensor(0xbf , 0x02);
+					SP0A20_write_cmos_sensor(0xd0 , 0xee);
+					SP0A20_write_cmos_sensor(0xd1 , 0x02);
+
+					printk(" priview 60Hz normal\r\n");
+				}
+			}
+
+		}  
+	}
+}	/*	SP0A20_NightMode	*/
+
+/*************************************************************************
+* FUNCTION
+*	SP0A20_Sensor_Init
+*
+* DESCRIPTION
+*	This function apply all of the initial setting to sensor.
+*
+* PARAMETERS
+*	None
+*
+* RETURNS
+*	None
+*
+*************************************************************************/
+void SP0A20_Sensor_Init(void)
+ 
+{
+SP0A20_write_cmos_sensor(0xfd,0x00);
+//SP0A20_write_cmos_sensor(0x36,0x02);
+SP0A20_write_cmos_sensor(0x0c,0x00);
+SP0A20_write_cmos_sensor(0x12,0x02);
+SP0A20_write_cmos_sensor(0x13,0x2f);
+SP0A20_write_cmos_sensor(0x6d,0x32);
+SP0A20_write_cmos_sensor(0x6c,0x32);
+SP0A20_write_cmos_sensor(0x6f,0x33);
+SP0A20_write_cmos_sensor(0x6e,0x34);
+SP0A20_write_cmos_sensor(0xfd,0x00);
+SP0A20_write_cmos_sensor(0x92,0x11);
+SP0A20_write_cmos_sensor(0x99,0x05);
+SP0A20_write_cmos_sensor(0x16,0x38);
+SP0A20_write_cmos_sensor(0x17,0x38);
+SP0A20_write_cmos_sensor(0x70,0x3a);
+SP0A20_write_cmos_sensor(0x14,0x02);
+SP0A20_write_cmos_sensor(0x15,0x20);
+SP0A20_write_cmos_sensor(0x71,0x23);
+SP0A20_write_cmos_sensor(0x69,0x25);
+SP0A20_write_cmos_sensor(0x6a,0x1a);
+SP0A20_write_cmos_sensor(0x72,0x1c);
+SP0A20_write_cmos_sensor(0x75,0x1e);
+SP0A20_write_cmos_sensor(0x73,0x3c);
+SP0A20_write_cmos_sensor(0x74,0x21);
+SP0A20_write_cmos_sensor(0x79,0x00);
+SP0A20_write_cmos_sensor(0x77,0x10);
+SP0A20_write_cmos_sensor(0x1a,0x4d);
+SP0A20_write_cmos_sensor(0x1b,0x27);
+SP0A20_write_cmos_sensor(0x1c,0x07);
+SP0A20_write_cmos_sensor(0x1e,0x15);
+SP0A20_write_cmos_sensor(0x21,0x08);
+SP0A20_write_cmos_sensor(0x22,0x28);
+SP0A20_write_cmos_sensor(0x26,0x66);
+SP0A20_write_cmos_sensor(0x28,0x0b);
+SP0A20_write_cmos_sensor(0x37,0x4a);
+SP0A20_write_cmos_sensor(0xfd,0x02);
+SP0A20_write_cmos_sensor(0x01,0x80);
+
+SP0A20_write_cmos_sensor(0xfd,0x01);
+SP0A20_write_cmos_sensor(0x41,0x00);
+SP0A20_write_cmos_sensor(0x42,0x00);
+SP0A20_write_cmos_sensor(0x43,0x00);
+SP0A20_write_cmos_sensor(0x44,0x00);
+	SP0A20_write_cmos_sensor(0xfd,0x00);
+	SP0A20_write_cmos_sensor(0x03,0x01);
+	SP0A20_write_cmos_sensor(0x04,0x68);
+	SP0A20_write_cmos_sensor(0x05,0x00);
+	SP0A20_write_cmos_sensor(0x06,0x00);
+	SP0A20_write_cmos_sensor(0x07,0x00);
+	SP0A20_write_cmos_sensor(0x08,0x00);
+	SP0A20_write_cmos_sensor(0x09,0x04);
+	SP0A20_write_cmos_sensor(0x0a,0x84);
+	SP0A20_write_cmos_sensor(0xfd,0x01);
+	SP0A20_write_cmos_sensor(0xf0,0x00);
+	SP0A20_write_cmos_sensor(0xf7,0x3c);
+	SP0A20_write_cmos_sensor(0x02,0x0c);
+	SP0A20_write_cmos_sensor(0x03,0x01);
+	SP0A20_write_cmos_sensor(0x06,0x3c);
+	SP0A20_write_cmos_sensor(0x07,0x00);
+	SP0A20_write_cmos_sensor(0x08,0x01);
+	SP0A20_write_cmos_sensor(0x09,0x00);
+	SP0A20_write_cmos_sensor(0xfd,0x02);
+	SP0A20_write_cmos_sensor(0xbe,0xd0);
+	SP0A20_write_cmos_sensor(0xbf,0x02);
+	SP0A20_write_cmos_sensor(0xd0,0xd0);
+	SP0A20_write_cmos_sensor(0xd1,0x02);
+	SP0A20_write_cmos_sensor(0xfd,0x01);
+	SP0A20_write_cmos_sensor(0x5a,0x40);
+	SP0A20_write_cmos_sensor(0xfd,0x02);
+	SP0A20_write_cmos_sensor(0xbc,0x70);
+	SP0A20_write_cmos_sensor(0xbd,0x50);
+SP0A20_write_cmos_sensor(0xb8,0x66);
+SP0A20_write_cmos_sensor(0xb9,0x8f);
+SP0A20_write_cmos_sensor(0xba,0x30);
+SP0A20_write_cmos_sensor(0xbb,0x45);
+
+SP0A20_write_cmos_sensor(0xfd,0x01);
+SP0A20_write_cmos_sensor(0xe0,0x50);
+SP0A20_write_cmos_sensor(0xe1,0x3e);
+SP0A20_write_cmos_sensor(0xe2,0x36);
+SP0A20_write_cmos_sensor(0xe3,0x30);
+SP0A20_write_cmos_sensor(0xe4,0x30);
+SP0A20_write_cmos_sensor(0xe5,0x2e);
+SP0A20_write_cmos_sensor(0xe6,0x2e);
+SP0A20_write_cmos_sensor(0xe7,0x2c);
+SP0A20_write_cmos_sensor(0xe8,0x2c);
+SP0A20_write_cmos_sensor(0xe9,0x2c);
+SP0A20_write_cmos_sensor(0xea,0x2a);
+SP0A20_write_cmos_sensor(0xf3,0x2a);
+SP0A20_write_cmos_sensor(0xf4,0x2a);
+
+SP0A20_write_cmos_sensor(0xfd,0x01);
+SP0A20_write_cmos_sensor(0x04,0xa0);
+SP0A20_write_cmos_sensor(0x05,0x2a);
+SP0A20_write_cmos_sensor(0x0a,0xa0);
+SP0A20_write_cmos_sensor(0x0b,0x2a);
+
+SP0A20_write_cmos_sensor(0xfd,0x01);
+SP0A20_write_cmos_sensor(0xeb,0x7f);
+SP0A20_write_cmos_sensor(0xec,0x7f);
+SP0A20_write_cmos_sensor(0xed,0x05);
+SP0A20_write_cmos_sensor(0xee,0x0a);
+
+SP0A20_write_cmos_sensor(0xfd,0x01);
+SP0A20_write_cmos_sensor(0xf2,0x4d);
+SP0A20_write_cmos_sensor(0xfd,0x02);
+SP0A20_write_cmos_sensor(0x54,0x0a);
+SP0A20_write_cmos_sensor(0x5b,0x05);
+SP0A20_write_cmos_sensor(0x5c,0xa0);
+
+SP0A20_write_cmos_sensor(0xfd,0x01);
+SP0A20_write_cmos_sensor(0x26,0x80);
+SP0A20_write_cmos_sensor(0x27,0x4f);
+SP0A20_write_cmos_sensor(0x28,0x00);
+SP0A20_write_cmos_sensor(0x29,0x20);
+SP0A20_write_cmos_sensor(0x2a,0x00);
+SP0A20_write_cmos_sensor(0x2b,0x03);
+SP0A20_write_cmos_sensor(0x2c,0x00);
+SP0A20_write_cmos_sensor(0x2d,0x20);
+SP0A20_write_cmos_sensor(0x30,0x00);
+SP0A20_write_cmos_sensor(0x31,0x00);
+
+SP0A20_write_cmos_sensor(0xfd,0x01);
+SP0A20_write_cmos_sensor(0xa1,0x3B);
+SP0A20_write_cmos_sensor(0xa2,0x3B);
+SP0A20_write_cmos_sensor(0xa3,0x3B);
+SP0A20_write_cmos_sensor(0xa4,0x3B);
+SP0A20_write_cmos_sensor(0xa5,0x3B);
+SP0A20_write_cmos_sensor(0xa6,0x3B);
+SP0A20_write_cmos_sensor(0xa7,0x3B);
+SP0A20_write_cmos_sensor(0xa8,0x3B);
+SP0A20_write_cmos_sensor(0xa9,0x3B);
+SP0A20_write_cmos_sensor(0xaa,0x3B);
+SP0A20_write_cmos_sensor(0xab,0x3B);
+SP0A20_write_cmos_sensor(0xac,0x3B);
+SP0A20_write_cmos_sensor(0xad,0x0e);
+SP0A20_write_cmos_sensor(0xae,0x08);
+SP0A20_write_cmos_sensor(0xaf,0x0a);
+SP0A20_write_cmos_sensor(0xb0,0x08);
+SP0A20_write_cmos_sensor(0xb1,0x06);
+SP0A20_write_cmos_sensor(0xb2,0x01);
+SP0A20_write_cmos_sensor(0xb3,0x04);
+SP0A20_write_cmos_sensor(0xb4,0x01);
+SP0A20_write_cmos_sensor(0xb5,0x07);
+SP0A20_write_cmos_sensor(0xb6,0x00);
+SP0A20_write_cmos_sensor(0xb7,0x00);
+SP0A20_write_cmos_sensor(0xb8,0x00);
+SP0A20_write_cmos_sensor(0xfd,0x00);
+
+SP0A20_write_cmos_sensor(0xfd,0x02);
+SP0A20_write_cmos_sensor(0x09,0x09);
+SP0A20_write_cmos_sensor(0x0d,0x1a);
+SP0A20_write_cmos_sensor(0x1d,0x03);
+SP0A20_write_cmos_sensor(0x1f,0x04);
+
+SP0A20_write_cmos_sensor(0xfd,0x01);
+SP0A20_write_cmos_sensor(0x32,0x00);
+SP0A20_write_cmos_sensor(0xfd,0x02);
+SP0A20_write_cmos_sensor(0x26,0xbf);
+SP0A20_write_cmos_sensor(0x27,0xa3);
+SP0A20_write_cmos_sensor(0x10,0x00);
+SP0A20_write_cmos_sensor(0x11,0x00);
+SP0A20_write_cmos_sensor(0x1b,0x80);
+SP0A20_write_cmos_sensor(0x1a,0x80);
+SP0A20_write_cmos_sensor(0x18,0x27);
+SP0A20_write_cmos_sensor(0x19,0x26);
+SP0A20_write_cmos_sensor(0x2a,0x01);
+SP0A20_write_cmos_sensor(0x2b,0x10);
+SP0A20_write_cmos_sensor(0x28,0xf8);
+SP0A20_write_cmos_sensor(0x29,0x08);
+
+SP0A20_write_cmos_sensor(0x66,0x4b);
+SP0A20_write_cmos_sensor(0x67,0x6b);
+SP0A20_write_cmos_sensor(0x68,0xcd);
+SP0A20_write_cmos_sensor(0x69,0xe7);
+SP0A20_write_cmos_sensor(0x6a,0xa5);
+
+SP0A20_write_cmos_sensor(0x7c,0x38);
+SP0A20_write_cmos_sensor(0x7d,0x60);
+SP0A20_write_cmos_sensor(0x7e,0xf0);
+SP0A20_write_cmos_sensor(0x7f,0x10);
+SP0A20_write_cmos_sensor(0x80,0xa6);
+
+SP0A20_write_cmos_sensor(0x70,0x2d);
+SP0A20_write_cmos_sensor(0x71,0x4f);
+SP0A20_write_cmos_sensor(0x72,0x1d);
+SP0A20_write_cmos_sensor(0x73,0x37);
+SP0A20_write_cmos_sensor(0x74,0xaa);
+
+SP0A20_write_cmos_sensor(0x6b,0x11);
+SP0A20_write_cmos_sensor(0x6c,0x2d);
+SP0A20_write_cmos_sensor(0x6d,0x22);
+SP0A20_write_cmos_sensor(0x6e,0x43);
+SP0A20_write_cmos_sensor(0x6f,0xaa);
+
+SP0A20_write_cmos_sensor(0x61,0xef);
+SP0A20_write_cmos_sensor(0x62,0x0e);
+SP0A20_write_cmos_sensor(0x63,0x48);
+SP0A20_write_cmos_sensor(0x64,0x6c);
+SP0A20_write_cmos_sensor(0x65,0x6a);
+
+SP0A20_write_cmos_sensor(0x75,0x80);
+SP0A20_write_cmos_sensor(0x76,0x09);
+SP0A20_write_cmos_sensor(0x77,0x02);
+SP0A20_write_cmos_sensor(0x24,0x25);
+SP0A20_write_cmos_sensor(0x0e,0x16);
+SP0A20_write_cmos_sensor(0x3b,0x09);
+SP0A20_write_cmos_sensor(0xfd,0x02);
+SP0A20_write_cmos_sensor(0x08,0x00);
+SP0A20_write_cmos_sensor(0x09,0x06);
+
+SP0A20_write_cmos_sensor(0xfd,0x02);
+SP0A20_write_cmos_sensor(0xde,0x0f);
+SP0A20_write_cmos_sensor(0xd7,0x0a);
+SP0A20_write_cmos_sensor(0xd8,0x0c);
+SP0A20_write_cmos_sensor(0xd9,0x12);
+SP0A20_write_cmos_sensor(0xda,0x18);
+SP0A20_write_cmos_sensor(0xe8,0x20);
+SP0A20_write_cmos_sensor(0xe9,0x20);
+SP0A20_write_cmos_sensor(0xea,0x20);
+SP0A20_write_cmos_sensor(0xeb,0x20);
+SP0A20_write_cmos_sensor(0xec,0x20);
+SP0A20_write_cmos_sensor(0xed,0x20);
+SP0A20_write_cmos_sensor(0xee,0x20);
+SP0A20_write_cmos_sensor(0xef,0x20);
+SP0A20_write_cmos_sensor(0xd3,0x20);
+SP0A20_write_cmos_sensor(0xd4,0x48);
+SP0A20_write_cmos_sensor(0xd5,0x20);
+SP0A20_write_cmos_sensor(0xd6,0x08);
+
+SP0A20_write_cmos_sensor(0xfd,0x01);
+SP0A20_write_cmos_sensor(0xd1,0x20);
+SP0A20_write_cmos_sensor(0xfd,0x02);
+SP0A20_write_cmos_sensor(0xdc,0x05);
+SP0A20_write_cmos_sensor(0x05,0x20);
+
+SP0A20_write_cmos_sensor(0xfd,0x02);
+SP0A20_write_cmos_sensor(0x81,0x00);
+SP0A20_write_cmos_sensor(0xfd,0x01);
+SP0A20_write_cmos_sensor(0xfc,0x00);
+SP0A20_write_cmos_sensor(0x7d,0x05);
+SP0A20_write_cmos_sensor(0x7e,0x05);
+SP0A20_write_cmos_sensor(0x7f,0x09);
+SP0A20_write_cmos_sensor(0x80,0x08);
+
+SP0A20_write_cmos_sensor(0xfd,0x02);
+SP0A20_write_cmos_sensor(0xdd,0x0f);
+SP0A20_write_cmos_sensor(0xfd,0x01);
+SP0A20_write_cmos_sensor(0x86,0x20);
+
+SP0A20_write_cmos_sensor(0x6d,0x12);
+SP0A20_write_cmos_sensor(0x6e,0x1a);
+SP0A20_write_cmos_sensor(0x6f,0x1e);
+SP0A20_write_cmos_sensor(0x70,0x24);
+SP0A20_write_cmos_sensor(0x86,0x20);
+SP0A20_write_cmos_sensor(0x71,0x12);
+SP0A20_write_cmos_sensor(0x72,0x1a);
+SP0A20_write_cmos_sensor(0x73,0x1e);
+SP0A20_write_cmos_sensor(0x74,0x24);
+
+SP0A20_write_cmos_sensor(0x75,0x08);
+SP0A20_write_cmos_sensor(0x76,0x0b);
+SP0A20_write_cmos_sensor(0x77,0x0e);
+SP0A20_write_cmos_sensor(0x78,0x12);
+SP0A20_write_cmos_sensor(0x79,0x25);
+SP0A20_write_cmos_sensor(0x7a,0x23);
+SP0A20_write_cmos_sensor(0x7b,0x22);
+SP0A20_write_cmos_sensor(0x7c,0x00);
+
+SP0A20_write_cmos_sensor(0x81,0x0d);
+SP0A20_write_cmos_sensor(0x82,0x18);
+SP0A20_write_cmos_sensor(0x83,0x28);
+SP0A20_write_cmos_sensor(0x84,0x30);
+
+SP0A20_write_cmos_sensor(0xfd,0x02);
+SP0A20_write_cmos_sensor(0x83,0x14);
+SP0A20_write_cmos_sensor(0x84,0x18);
+SP0A20_write_cmos_sensor(0x86,0x04);
+
+SP0A20_write_cmos_sensor(0xfd,0x01);
+SP0A20_write_cmos_sensor(0x61,0x60);
+SP0A20_write_cmos_sensor(0x62,0x28);
+SP0A20_write_cmos_sensor(0x8a,0x10);
+
+SP0A20_write_cmos_sensor(0xfd,0x01);
+SP0A20_write_cmos_sensor(0x8b,0x00);
+SP0A20_write_cmos_sensor(0x8c,0x09);
+SP0A20_write_cmos_sensor(0x8d,0x13);
+SP0A20_write_cmos_sensor(0x8e,0x1b);
+SP0A20_write_cmos_sensor(0x8f,0x23);
+SP0A20_write_cmos_sensor(0x90,0x32);
+SP0A20_write_cmos_sensor(0x91,0x41);
+SP0A20_write_cmos_sensor(0x92,0x4d);
+SP0A20_write_cmos_sensor(0x93,0x5c);
+SP0A20_write_cmos_sensor(0x94,0x70);
+SP0A20_write_cmos_sensor(0x95,0x84);
+SP0A20_write_cmos_sensor(0x96,0x94);
+SP0A20_write_cmos_sensor(0x97,0xa3);
+SP0A20_write_cmos_sensor(0x98,0xb5);
+SP0A20_write_cmos_sensor(0x99,0xc2);
+SP0A20_write_cmos_sensor(0x9a,0xcf);
+SP0A20_write_cmos_sensor(0x9b,0xd9);
+SP0A20_write_cmos_sensor(0x9c,0xe3);
+SP0A20_write_cmos_sensor(0x9d,0xec);
+SP0A20_write_cmos_sensor(0x9e,0xf4);
+SP0A20_write_cmos_sensor(0x9f,0xfa);
+SP0A20_write_cmos_sensor(0xa0,0xff);
+
+SP0A20_write_cmos_sensor(0xfd,0x02);
+SP0A20_write_cmos_sensor(0x15,0xca);
+SP0A20_write_cmos_sensor(0x16,0x8a);
+
+SP0A20_write_cmos_sensor(0xa0,0x8c);
+SP0A20_write_cmos_sensor(0xa1,0xfa);
+SP0A20_write_cmos_sensor(0xa2,0xfa);
+SP0A20_write_cmos_sensor(0xa3,0xf4);
+SP0A20_write_cmos_sensor(0xa4,0x99);
+SP0A20_write_cmos_sensor(0xa5,0xf4);
+SP0A20_write_cmos_sensor(0xa6,0x06);
+SP0A20_write_cmos_sensor(0xa7,0xc7);
+SP0A20_write_cmos_sensor(0xa8,0xb3);
+SP0A20_write_cmos_sensor(0xa9,0x3c);
+SP0A20_write_cmos_sensor(0xaa,0x33);
+SP0A20_write_cmos_sensor(0xab,0x0c);
+
+SP0A20_write_cmos_sensor(0xac,0x8c);
+SP0A20_write_cmos_sensor(0xad,0x0c);
+SP0A20_write_cmos_sensor(0xae,0xe7);
+SP0A20_write_cmos_sensor(0xaf,0xf1);
+SP0A20_write_cmos_sensor(0xb0,0xa8);
+SP0A20_write_cmos_sensor(0xb1,0xe7);
+SP0A20_write_cmos_sensor(0xb2,0xe7);
+SP0A20_write_cmos_sensor(0xb3,0xcd);
+SP0A20_write_cmos_sensor(0xb4,0xcc);
+SP0A20_write_cmos_sensor(0xb5,0x30);
+SP0A20_write_cmos_sensor(0xb6,0x33);
+SP0A20_write_cmos_sensor(0xb7,0x0f);
+
+SP0A20_write_cmos_sensor(0xfd,0x01);
+SP0A20_write_cmos_sensor(0xd3,0x7A);
+SP0A20_write_cmos_sensor(0xd4,0x7A);
+SP0A20_write_cmos_sensor(0xd5,0x60);
+SP0A20_write_cmos_sensor(0xd6,0x58);
+
+SP0A20_write_cmos_sensor(0xd7,0x7A);
+SP0A20_write_cmos_sensor(0xd8,0x7A);
+SP0A20_write_cmos_sensor(0xd9,0x60);
+SP0A20_write_cmos_sensor(0xda,0x58);
+
+SP0A20_write_cmos_sensor(0xfd,0x01);
+SP0A20_write_cmos_sensor(0xdd,0x30);
+SP0A20_write_cmos_sensor(0xde,0x10);
+SP0A20_write_cmos_sensor(0xdf,0xff);
+SP0A20_write_cmos_sensor(0x00,0x00);
+
+SP0A20_write_cmos_sensor(0xfd,0x01);
+SP0A20_write_cmos_sensor(0xc2,0xaa);
+SP0A20_write_cmos_sensor(0xc3,0x88);
+SP0A20_write_cmos_sensor(0xc4,0x77);
+SP0A20_write_cmos_sensor(0xc5,0x66);
+
+SP0A20_write_cmos_sensor(0xfd,0x01);
+SP0A20_write_cmos_sensor(0xcd,0x10);
+SP0A20_write_cmos_sensor(0xce,0x1f);
+SP0A20_write_cmos_sensor(0xcf,0x30);
+SP0A20_write_cmos_sensor(0xd0,0x45);
+
+SP0A20_write_cmos_sensor(0xfd,0x02);
+SP0A20_write_cmos_sensor(0x31,0x60);
+SP0A20_write_cmos_sensor(0x32,0x60);
+SP0A20_write_cmos_sensor(0x33,0xc0);
+SP0A20_write_cmos_sensor(0x35,0x60);
+SP0A20_write_cmos_sensor(0x36,0x28);
+SP0A20_write_cmos_sensor(0x37,0x13);
+
+SP0A20_write_cmos_sensor(0xfd,0x01);
+SP0A20_write_cmos_sensor(0x0e,0x80);
+SP0A20_write_cmos_sensor(0x0f,0x20);
+SP0A20_write_cmos_sensor(0x10,0x80);
+SP0A20_write_cmos_sensor(0x11,0x80);
+SP0A20_write_cmos_sensor(0x12,0x80);
+SP0A20_write_cmos_sensor(0x13,0x80);
+SP0A20_write_cmos_sensor(0x14,0x90);
+SP0A20_write_cmos_sensor(0x15,0x90);
+SP0A20_write_cmos_sensor(0x16,0x90);
+SP0A20_write_cmos_sensor(0x17,0x90);
+
+SP0A20_write_cmos_sensor(0xfd,0x00);
+SP0A20_write_cmos_sensor(0x31,0x00);
+
+SP0A20_write_cmos_sensor(0xfd,0x01);
+SP0A20_write_cmos_sensor(0x32,0x15);
+SP0A20_write_cmos_sensor(0x33,0xef);
+SP0A20_write_cmos_sensor(0x34,0x07);
+SP0A20_write_cmos_sensor(0xd2,0x01);
+SP0A20_write_cmos_sensor(0xfb,0x25);
+SP0A20_write_cmos_sensor(0xf2,0x49);
+SP0A20_write_cmos_sensor(0x35,0x40);
+SP0A20_write_cmos_sensor(0x5d,0x11);
+}
+
+
+UINT32 SP0A20GetSensorID(UINT32 *sensorID)
+{
+    int  retry = 3; 
+#ifdef SLT_DEVINFO_CMM 
+ 	s_DEVINFO_ccm =(struct devinfo_struct*) kmalloc(sizeof(struct devinfo_struct), GFP_KERNEL);	
+	s_DEVINFO_ccm->device_type = "CCM-S";
+	s_DEVINFO_ccm->device_module = "PCOEJ0003A";//can change if got module id
+	s_DEVINFO_ccm->device_vendor = "Sanlaishi";
+	s_DEVINFO_ccm->device_ic = "SP0A20";
+	s_DEVINFO_ccm->device_version = "SuperPix";
+	s_DEVINFO_ccm->device_info = "30W";
+#endif	
+
+    // check if sensor ID correct
+    do {
+	SP0A20_write_cmos_sensor(0xfd,0x00);
+	*sensorID = SP0A20_read_cmos_sensor(0x02);
+
+		SENSORDB("%s,Read Sensor ID = 0x%04x\n",__func__, *sensorID);
+        if (*sensorID == SP0A20_SENSOR_ID)
+            break; 
+        SENSORDB("Read Sensor ID Fail = 0x%04x\n", *sensorID); 
+        retry--; 
+    } while (retry > 0);
+
+    if (*sensorID != SP0A20_SENSOR_ID) {
+        *sensorID = 0xFFFFFFFF; 
+	#ifdef SLT_DEVINFO_CMM 
+		s_DEVINFO_ccm->device_used = DEVINFO_UNUSED;
+		devinfo_check_add_device(s_DEVINFO_ccm);
+	#endif
+        return ERROR_SENSOR_CONNECT_FAIL;
+    }
+
+#ifdef SLT_DEVINFO_CMM 
+	s_DEVINFO_ccm->device_used = DEVINFO_USED;
+	devinfo_check_add_device(s_DEVINFO_ccm);
+#endif	  
+    return ERROR_NONE;    
+}
+
+
+
+
+/*************************************************************************
+* FUNCTION
+*	SP0A20_Write_More_Registers
+*
+* DESCRIPTION
+*	This function is served for FAE to modify the necessary Init Regs. Do not modify the regs
+*     in init_SP0A20() directly.
+*
+* PARAMETERS
+*	None
+*
+* RETURNS
+*	None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+void SP0A20_Write_More_Registers(void)
+{
+
+}
+
+
+/*************************************************************************
+ * FUNCTION
+ *	SP0A20Open
+ *
+ * DESCRIPTION
+ *	This function initialize the registers of CMOS sensor
+ *
+ * PARAMETERS
+ *	None
+ *
+ * RETURNS
+ *	None
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+UINT32 SP0A20Open(void)
+{
+	volatile signed char i;
+	kal_uint16 sensor_id=0;
+
+	printk("<Jet> Entry SP0A20Open!!!\r\n");
+
+	//Sleep(10);
+
+
+	//  Read sensor ID to adjust I2C is OK?
+	for(i=0;i<3;i++)
+	{
+		//sensor_id = ((SP0A20_read_cmos_sensor(0xf0) << 8) | SP0A20_read_cmos_sensor(0xf1));
+		SP0A20_write_cmos_sensor(0xfd,0x00);
+		sensor_id = SP0A20_read_cmos_sensor(0x02);
+		SENSORDB("%s,Read Sensor ID = 0x%x\n", __func__,sensor_id);
+		if(sensor_id == SP0A20_SENSOR_ID)  
+		{
+			SENSORDB("SP0A20_ Sensor Read ID OK \r\n");
+			break;
+		}
+	}
+	
+	if(sensor_id != SP0A20_SENSOR_ID)  
+	{
+		SENSORDB("SP0A20 Read Sensor ID Fail[open] = 0x%x\n", sensor_id); 
+		return ERROR_SENSOR_CONNECT_FAIL;
+	}
+
+#ifdef DEBUG_SENSOR_SP0A20  
+		struct file *fp; 
+		mm_segment_t fs; 
+		loff_t pos = 0; 
+		static char buf[60*1024] ;
+
+
+	fp = filp_open("/mnt/sdcard/sp0a20_sd", O_RDONLY , 0); 
+
+	if (IS_ERR(fp)) { 
+		 
+		fromsd = 0;   
+		printk("open file error\n");
+	} 
+	else 
+	{
+		fromsd = 1;
+		printk("open file ok\n");
+
+		filp_close(fp, NULL); 
+		set_fs(fs);
+	}
+
+	if(fromsd == 1)
+	{
+		printk("________________from t!\n");
+		SP0A20_Initialize_from_T_Flash();
+	}
+	else
+	{
+		SP0A20_Sensor_Init();
+		SP0A20_Write_More_Registers();//added for FAE to debut
+	}
+#else  
+	//RETAILMSG(1, (TEXT("Sensor Read ID OK \r\n")));
+	// initail sequence write in
+	SP0A20_Sensor_Init();
+	SP0A20_Write_More_Registers();//added for FAE to debut
+#endif
+    return ERROR_NONE;
+} /* SP0A20Open */
+
+
+/*************************************************************************
+ * FUNCTION
+ *	SP0A20Close
+ *
+ * DESCRIPTION
+ *	This function is to turn off sensor module power.
+ *
+ * PARAMETERS
+ *	None
+ *
+ * RETURNS
+ *	None
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+UINT32 SP0A20Close(void)
+{
+    return ERROR_NONE;
+} /* SP0A20Close */
+
+
+/*************************************************************************
+ * FUNCTION
+ * SP0A20Preview
+ *
+ * DESCRIPTION
+ *	This function start the sensor preview.
+ *
+ * PARAMETERS
+ *	*image_window : address pointer of pixel numbers in one period of HSYNC
+ *  *sensor_config_data : address pointer of line numbers in one period of VSYNC
+ *
+ * RETURNS
+ *	None
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+UINT32 SP0A20Preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+        MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+
+{
+    kal_uint32 iTemp;
+    kal_uint16 iStartX = 0, iStartY = 1;
+
+    if(sensor_config_data->SensorOperationMode == MSDK_SENSOR_OPERATION_MODE_VIDEO)		// MPEG4 Encode Mode
+    {
+        RETAILMSG(1, (TEXT("Camera Video preview\r\n")));
+        SP0A20_MPEG4_encode_mode = KAL_TRUE;
+       
+    }
+    else
+    {
+        RETAILMSG(1, (TEXT("Camera preview\r\n")));
+        SP0A20_MPEG4_encode_mode = KAL_FALSE;
+    }
+
+    image_window->GrabStartX= IMAGE_SENSOR_VGA_GRAB_PIXELS;
+    image_window->GrabStartY= IMAGE_SENSOR_VGA_GRAB_LINES;
+    image_window->ExposureWindowWidth = IMAGE_SENSOR_PV_WIDTH;
+    image_window->ExposureWindowHeight =IMAGE_SENSOR_PV_HEIGHT;
+
+    // copy sensor_config_data
+    memcpy(&SP0A20SensorConfigData, sensor_config_data, sizeof(MSDK_SENSOR_CONFIG_STRUCT));
+    return ERROR_NONE;
+} /* SP0A20Preview */
+
+
+/*************************************************************************
+ * FUNCTION
+ *	SP0A20Capture
+ *
+ * DESCRIPTION
+ *	This function setup the CMOS sensor in capture MY_OUTPUT mode
+ *
+ * PARAMETERS
+ *
+ * RETURNS
+ *	None
+ *
+ * GLOBALS AFFECTED
+ *
+ *************************************************************************/
+UINT32 SP0A20Capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+        MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+
+{
+    SP0A20_MODE_CAPTURE=KAL_TRUE;
+
+    image_window->GrabStartX = IMAGE_SENSOR_VGA_GRAB_PIXELS;
+    image_window->GrabStartY = IMAGE_SENSOR_VGA_GRAB_LINES;
+    image_window->ExposureWindowWidth= IMAGE_SENSOR_FULL_WIDTH;
+    image_window->ExposureWindowHeight = IMAGE_SENSOR_FULL_HEIGHT;
+
+    // copy sensor_config_data
+    memcpy(&SP0A20SensorConfigData, sensor_config_data, sizeof(MSDK_SENSOR_CONFIG_STRUCT));
+    return ERROR_NONE;
+} /* SP0A20_Capture() */
+
+static UINT32 SP0A20GetExposureTime(void)
+{
+    UINT8 high_base,low_base,high_exp,low_exp = 0;
+    UINT32 EXP, CLK= 0;
+UINT32 temp1;
+   	SP0A20_write_cmos_sensor(0xfd, 0x00);
+	 
+	high_exp =  SP0A20_read_cmos_sensor(0x03);
+	low_exp = SP0A20_read_cmos_sensor(0x04);
+	
+	SP0A20_write_cmos_sensor(0xfd, 0x01);
+	
+	high_base = SP0A20_read_cmos_sensor(0xf0);
+	
+	low_base = SP0A20_read_cmos_sensor(0xf7);
+	temp1 = (( (( high_exp << 8) | low_exp)) /( (high_base<<8) | low_base));
+	EXP =(( (( high_exp << 8) | low_exp)) /( (high_base<<8) | low_base))* 10 *5000;//return us
+printk("%s,EXP = %d,temp1 = %d\n",__func__,EXP,temp1);
+	return EXP;
+}
+
+void SP0A20GetExifInfo(uintptr_t exifAddr)
+{
+    SENSOR_EXIF_INFO_STRUCT* pExifInfo = (SENSOR_EXIF_INFO_STRUCT*)exifAddr;
+
+	pExifInfo->CapExposureTime = SP0A20GetExposureTime();
+
+}
+
+UINT32 SP0A20GetResolution(MSDK_SENSOR_RESOLUTION_INFO_STRUCT *pSensorResolution)
+{
+    pSensorResolution->SensorFullWidth=IMAGE_SENSOR_FULL_WIDTH;
+    pSensorResolution->SensorFullHeight=IMAGE_SENSOR_FULL_HEIGHT;
+    pSensorResolution->SensorPreviewWidth=IMAGE_SENSOR_PV_WIDTH;
+    pSensorResolution->SensorPreviewHeight=IMAGE_SENSOR_PV_HEIGHT;
+    pSensorResolution->SensorVideoWidth=IMAGE_SENSOR_PV_WIDTH;
+
+    pSensorResolution->SensorVideoHeight=IMAGE_SENSOR_PV_HEIGHT;
+    return ERROR_NONE;
+} /* SP0A20GetResolution() */
+
+
+UINT32 SP0A20GetInfo(MSDK_SCENARIO_ID_ENUM ScenarioId,
+        MSDK_SENSOR_INFO_STRUCT *pSensorInfo,
+        MSDK_SENSOR_CONFIG_STRUCT *pSensorConfigData)
+{
+    pSensorInfo->SensorPreviewResolutionX=IMAGE_SENSOR_PV_WIDTH;
+    pSensorInfo->SensorPreviewResolutionY=IMAGE_SENSOR_PV_HEIGHT;
+    pSensorInfo->SensorFullResolutionX=IMAGE_SENSOR_FULL_WIDTH;
+    pSensorInfo->SensorFullResolutionY=IMAGE_SENSOR_FULL_HEIGHT;
+
+    pSensorInfo->SensorCameraPreviewFrameRate=30;
+    pSensorInfo->SensorVideoFrameRate=30;
+    pSensorInfo->SensorStillCaptureFrameRate=10;
+    pSensorInfo->SensorWebCamCaptureFrameRate=15;
+    pSensorInfo->SensorResetActiveHigh=FALSE;
+    pSensorInfo->SensorResetDelayCount=1;
+    pSensorInfo->SensorOutputDataFormat=SENSOR_OUTPUT_FORMAT_YUYV;
+    pSensorInfo->SensorClockPolarity=SENSOR_CLOCK_POLARITY_LOW;
+    pSensorInfo->SensorClockFallingPolarity=SENSOR_CLOCK_POLARITY_LOW;
+    pSensorInfo->SensorHsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
+    pSensorInfo->SensorVsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
+    pSensorInfo->SensorInterruptDelayLines = 1;
+    pSensorInfo->SensroInterfaceType=SENSOR_INTERFACE_TYPE_MIPI;//MIPI setting
+    pSensorInfo->CaptureDelayFrame = 2;
+    pSensorInfo->PreviewDelayFrame = 1;
+    pSensorInfo->VideoDelayFrame = 4;
+    pSensorInfo->SensorMasterClockSwitch = 0;
+    pSensorInfo->SensorDrivingCurrent = ISP_DRIVING_2MA;
+
+    switch (ScenarioId)
+    {
+    case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+    case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+    case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+    default:
+        pSensorInfo->SensorClockFreq=24;
+        pSensorInfo->SensorClockDividCount= 3;
+        pSensorInfo->SensorClockRisingCount=0;
+        pSensorInfo->SensorClockFallingCount=2;
+        pSensorInfo->SensorPixelClockCount=3;
+        pSensorInfo->SensorDataLatchCount=2;
+        pSensorInfo->SensorGrabStartX = IMAGE_SENSOR_VGA_GRAB_PIXELS;
+        pSensorInfo->SensorGrabStartY = IMAGE_SENSOR_VGA_GRAB_LINES;
+	//MIPI setting
+	pSensorInfo->SensorMIPILaneNumber = SENSOR_MIPI_1_LANE; 	
+	pSensorInfo->MIPIDataLowPwr2HighSpeedTermDelayCount = 0; 
+	pSensorInfo->MIPIDataLowPwr2HighSpeedSettleDelayCount = 14;
+	pSensorInfo->MIPICLKLowPwr2HighSpeedTermDelayCount = 0;
+	pSensorInfo->SensorWidthSampling = 0;  // 0 is default 1x
+	pSensorInfo->SensorHightSampling = 0;	// 0 is default 1x 
+	pSensorInfo->SensorPacketECCOrder = 1;
+
+        break;
+    }
+    SP0A20PixelClockDivider=pSensorInfo->SensorPixelClockCount;
+    memcpy(pSensorConfigData, &SP0A20SensorConfigData, sizeof(MSDK_SENSOR_CONFIG_STRUCT));
+    return ERROR_NONE;
+} /* SP0A20GetInfo() */
+
+
+UINT32 SP0A20Control(MSDK_SCENARIO_ID_ENUM ScenarioId, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *pImageWindow,
+        MSDK_SENSOR_CONFIG_STRUCT *pSensorConfigData)
+{
+	printk("%s,MIPIControl start.\n",__func__);
+    switch (ScenarioId)
+    {
+    case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+    case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+    case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+    default:
+	 SP0A20Preview(pImageWindow, pSensorConfigData);
+        break;
+    }
+
+	printk("%s,MIPIControl end.\n",__func__);
+    return TRUE;
+}	/* SP0A20Control() */
+
+BOOL SP0A20_set_param_wb(UINT16 para)
+{
+	if(SP0A20_TST_PATTEN==KAL_TRUE)
+		return;
+
+	printk("%s,enter, para = %x\n",__func__,para);
+	SP0A20_write_cmos_sensor(0xfd,0x01);
+	SP0A20_write_cmos_sensor(0x36,0x02);
+
+	switch (para)
+	{
+		case AWB_MODE_OFF:
+			printk("%s,AWB_MODE_OFF.\n",__func__);
+			break;
+		
+		case AWB_MODE_AUTO:
+			SP0A20_awb_enable(KAL_TRUE);
+			SP0A20_write_cmos_sensor(0xfd,0x01);
+			SP0A20_write_cmos_sensor(0x32,0x15);
+			SP0A20_write_cmos_sensor(0xfd,0x02);
+			SP0A20_write_cmos_sensor(0x26,0xbf);
+			SP0A20_write_cmos_sensor(0x27,0xa3);
+			SP0A20_write_cmos_sensor(0xfd,0x00);
+			SP0A20_write_cmos_sensor(0xe7,0x03);
+			SP0A20_write_cmos_sensor(0xe7,0x00);
+			break;
+		
+		case AWB_MODE_CLOUDY_DAYLIGHT: //cloudy
+			SP0A20_awb_enable(KAL_FALSE);
+			SP0A20_write_cmos_sensor(0xfd,0x01);	//4200-5000K 								  
+			
+			SP0A20_write_cmos_sensor(0x32,0x05);															
+			SP0A20_write_cmos_sensor(0xfd,0x02);											
+			SP0A20_write_cmos_sensor(0x26,0x95);																
+			SP0A20_write_cmos_sensor(0x27,0xba);																
+			SP0A20_write_cmos_sensor(0xfd,0x00);
+			SP0A20_write_cmos_sensor(0xe7,0x03);
+			SP0A20_write_cmos_sensor(0xe7,0x00);	
+			break;
+		
+		case AWB_MODE_DAYLIGHT: //sunny
+			SP0A20_awb_enable(KAL_FALSE);
+			// SP0A20_reg_WB_auto 
+			SP0A20_write_cmos_sensor(0xfd,0x01);	//2800K~3000K									  
+			SP0A20_write_cmos_sensor(0x32,0x05);															
+			SP0A20_write_cmos_sensor(0xfd,0x02);															
+			SP0A20_write_cmos_sensor(0x26,0x88);																
+			SP0A20_write_cmos_sensor(0x27,0xb0);	//d0																
+			SP0A20_write_cmos_sensor(0xfd,0x00);
+			SP0A20_write_cmos_sensor(0xe7,0x03);
+			SP0A20_write_cmos_sensor(0xe7,0x00);			
+			break;
+		
+		case AWB_MODE_INCANDESCENT: //office
+			SP0A20_awb_enable(KAL_FALSE);
+			// SP0A20_reg_WB_auto 
+			SP0A20_write_cmos_sensor(0xfd,0x01);	//2800K~3000K									  
+			SP0A20_write_cmos_sensor(0x32,0x05);															
+			SP0A20_write_cmos_sensor(0xfd,0x02);															
+			SP0A20_write_cmos_sensor(0x26,0x88);																
+			SP0A20_write_cmos_sensor(0x27,0xd0);																
+			SP0A20_write_cmos_sensor(0xfd,0x00);
+			SP0A20_write_cmos_sensor(0xe7,0x03);
+			SP0A20_write_cmos_sensor(0xe7,0x00);	
+			break;
+		
+		case AWB_MODE_TUNGSTEN: //home
+			SP0A20_awb_enable(KAL_FALSE);
+			SP0A20_write_cmos_sensor(0xfd,0x01);	//4000K 								  
+			SP0A20_write_cmos_sensor(0x32,0x05);															
+			SP0A20_write_cmos_sensor(0xfd,0x02);															
+			SP0A20_write_cmos_sensor(0x26,0xac);																
+			SP0A20_write_cmos_sensor(0x27,0xbe);																
+			SP0A20_write_cmos_sensor(0xfd,0x00);
+			SP0A20_write_cmos_sensor(0xe7,0x03);
+			SP0A20_write_cmos_sensor(0xe7,0x00);
+			break;
+		case AWB_MODE_TWILIGHT:	//5 
+			SP0A20_awb_enable(KAL_FALSE);
+			SP0A20_write_cmos_sensor(0xfd,0x01);	 //7000K									 
+			SP0A20_write_cmos_sensor(0x32,0x05);															
+			SP0A20_write_cmos_sensor(0xfd,0x02);															
+			SP0A20_write_cmos_sensor(0x26,0xdb);																
+			SP0A20_write_cmos_sensor(0x27,0x80);	//70																
+			SP0A20_write_cmos_sensor(0xfd,0x00);
+			SP0A20_write_cmos_sensor(0xe7,0x03);
+			SP0A20_write_cmos_sensor(0xe7,0x00);	
+			break;
+		case AWB_MODE_FLUORESCENT:
+			SP0A20_awb_enable(KAL_FALSE);
+			SP0A20_write_cmos_sensor(0xfd,0x01);	//4200-5000K 								  
+			SP0A20_write_cmos_sensor(0x32,0x05);															
+			SP0A20_write_cmos_sensor(0xfd,0x02);															
+			SP0A20_write_cmos_sensor(0x26,0xbf);	//95															
+			SP0A20_write_cmos_sensor(0x27,0x89);	//ba														
+			SP0A20_write_cmos_sensor(0xfd,0x00);
+			SP0A20_write_cmos_sensor(0xe7,0x03);
+			SP0A20_write_cmos_sensor(0xe7,0x00);	
+	      break;
+		
+		default:
+			return FALSE;
+	}
+
+	SP0A20_write_cmos_sensor(0xfd,0x00);
+	SP0A20_write_cmos_sensor(0xe7,0x03);
+	SP0A20_write_cmos_sensor(0xe7,0x00);
+	Sleep(10);
+
+	SP0A20_write_cmos_sensor(0xfd,0x01);
+	SP0A20_write_cmos_sensor(0x36,0x00);
+
+	printk("%s,exit.\n",__func__);
+	return TRUE;
+} /* SP0A20_set_param_wb */
+
+
+BOOL SP0A20_set_param_effect(UINT16 para)
+{
+	kal_uint32  ret = KAL_TRUE;
+    SENSORDB("%s,para= %d.\n",__func__,para);
+	SP0A20_write_cmos_sensor(0xfd,0x01);
+	SP0A20_write_cmos_sensor(0x36,0x02);
+
+	switch (para)
+	{
+		case MEFFECT_OFF:  
+			SP0A20_write_cmos_sensor(0xfd,0x01);
+			SP0A20_write_cmos_sensor(0x66,0x00);
+			SP0A20_write_cmos_sensor(0x67,0x80);
+			SP0A20_write_cmos_sensor(0x68,0x80);
+			break;
+
+		case  MEFFECT_SOLARIZE: 
+			SP0A20_write_cmos_sensor(0xfd,0x01);
+			SP0A20_write_cmos_sensor(0x66,0x10);
+			SP0A20_write_cmos_sensor(0x67,0x98);
+			SP0A20_write_cmos_sensor(0x68,0x58);                     
+			break;
+		case MEFFECT_SEPIA: 
+			SP0A20_write_cmos_sensor(0xfd,0x01);
+			SP0A20_write_cmos_sensor(0x66,0x10);
+			SP0A20_write_cmos_sensor(0x67,0x98);
+			SP0A20_write_cmos_sensor(0x68,0x58);
+			break;
+		case MEFFECT_NEGATIVE: 
+			SP0A20_write_cmos_sensor(0xfd,0x01);
+			SP0A20_write_cmos_sensor(0x66,0x04);
+			SP0A20_write_cmos_sensor(0x67,0x80);
+			SP0A20_write_cmos_sensor(0x68,0x80);
+			break;
+
+		case MEFFECT_SEPIAGREEN: 
+			SP0A20_write_cmos_sensor(0xfd,0x01);
+			SP0A20_write_cmos_sensor(0x66,0x10);
+			SP0A20_write_cmos_sensor(0x67,0x50);
+			SP0A20_write_cmos_sensor(0x68,0x50);
+			break;
+
+		case MEFFECT_SEPIABLUE:
+			SP0A20_write_cmos_sensor(0xfd,0x01);
+			SP0A20_write_cmos_sensor(0x66,0x10);
+			SP0A20_write_cmos_sensor(0x67,0x50);
+			SP0A20_write_cmos_sensor(0x68,0xc0);
+			break;
+
+		case MEFFECT_MONO: //B&Wdan se
+			SP0A20_write_cmos_sensor(0xfd,0x01);
+			SP0A20_write_cmos_sensor(0x66,0x20);
+			SP0A20_write_cmos_sensor(0x67,0x80);
+			SP0A20_write_cmos_sensor(0x68,0x80);   
+			break;
+
+		default: 
+			return FALSE;
+	}
+
+	SP0A20_write_cmos_sensor(0xfd,0x00);
+	SP0A20_write_cmos_sensor(0xe7,0x03);
+	SP0A20_write_cmos_sensor(0xe7,0x00);
+	Sleep(10);
+	SP0A20_write_cmos_sensor(0xfd,0x01);
+	SP0A20_write_cmos_sensor(0x36,0x00);
+	return ret;
+
+} /* SP0A20_set_param_effect */
+
+
+BOOL SP0A20_set_param_banding(UINT16 para)
+{
+	SP0A20_Sensor_Driver.bBanding_value = para;
+	switch (para)
+	{
+		case AE_FLICKER_MODE_50HZ:
+			isBanding = 0;
+			printk("SP0A20_set_param_banding_50hz\n");
+			//SP0A20_set_banding_for_50Hz();
+			break;
+		case AE_FLICKER_MODE_60HZ:
+			isBanding = 1;
+			printk("SP0A20_set_param_banding_60hz\n");
+			//SP0A20_set_banding_for_60Hz();
+			break;
+		default:
+			return FALSE;
+	}
+
+	return TRUE;
+} /* SP0A20_set_param_banding */
+
+
+BOOL SP0A20_set_param_exposure(UINT16 para)
+{
+
+
+	switch (para)
+	{
+		case AE_EV_COMP_n13:
+			SP0A20_write_cmos_sensor(0xfd, 0x01);
+			SP0A20_write_cmos_sensor(0xdb, 0xc0);
+			break;
+
+		case AE_EV_COMP_n10:
+			SP0A20_write_cmos_sensor(0xfd, 0x01);
+			SP0A20_write_cmos_sensor(0xdb, 0xd0);
+			break;
+
+		case AE_EV_COMP_n07:
+			SP0A20_write_cmos_sensor(0xfd, 0x01);
+			SP0A20_write_cmos_sensor(0xdb, 0xe0);
+			break;
+
+		case AE_EV_COMP_n03:
+			SP0A20_write_cmos_sensor(0xfd, 0x01);
+			SP0A20_write_cmos_sensor(0xdb, 0xf0);
+			break;
+
+		case AE_EV_COMP_00:
+			SP0A20_write_cmos_sensor(0xfd, 0x01);
+			SP0A20_write_cmos_sensor(0xdb, 0x00);//0xfa before
+			break;
+
+
+		case AE_EV_COMP_03:
+			SP0A20_write_cmos_sensor(0xfd, 0x01);
+			SP0A20_write_cmos_sensor(0xdb, 0x10);
+			break;
+
+		case AE_EV_COMP_07:
+			SP0A20_write_cmos_sensor(0xfd, 0x01);
+			SP0A20_write_cmos_sensor(0xdb, 0x20);
+			break;
+
+		case AE_EV_COMP_10:
+			SP0A20_write_cmos_sensor(0xfd, 0x01);
+			SP0A20_write_cmos_sensor(0xdb, 0x30);
+			break;
+
+		case AE_EV_COMP_13:
+			SP0A20_write_cmos_sensor(0xfd, 0x01);
+			SP0A20_write_cmos_sensor(0xdb, 0x40);
+			break;
+
+		default:
+			return FALSE;
+	}
+
+	return TRUE;
+} /* SP0A20_set_param_exposure */
+
+
+
+UINT32 SP0A20YUVSetVideoMode(UINT16 u2FrameRate)    // lanking add
+{
+  
+        SP0A20_MPEG4_encode_mode = KAL_TRUE;
+     if (u2FrameRate == 30)
+   	{
+   	
+   	    /*********video frame ************/
+		
+   	}
+    else if (u2FrameRate == 15)       
+    	{
+    	
+   	    /*********video frame ************/
+		
+    	}
+    else
+   	{
+   	
+            SENSORDB("Wrong Frame Rate"); 
+			
+   	}
+
+      return TRUE;
+
+}
+
+
+kal_uint16 SP0A20SetTestPatternMode(kal_bool bEnable)
+{
+    kal_uint16 temp_tst_reg;
+	SENSORDB("%s, Test pattern enable:%d\n",__func__, bEnable);
+	 
+	if(bEnable)    // enable test pattern output 
+	{
+		SP0A20_TST_PATTEN = KAL_TRUE;
+
+		SP0A20_write_cmos_sensor(0xfd,0x01);	
+		SP0A20_write_cmos_sensor(0x33,0x00);	
+		SP0A20_write_cmos_sensor(0x34,0x00);
+		SP0A20_write_cmos_sensor(0x36,0x02);
+
+		SP0A20_write_cmos_sensor(0xfd,0x00);	
+		SP0A20_write_cmos_sensor(0x1c,0x00);	
+		SP0A20_write_cmos_sensor(0x1d,0x00);
+		SP0A20_write_cmos_sensor(0x0a,0x50);
+
+		SP0A20_write_cmos_sensor(0xfd,0x02);
+		SP0A20_write_cmos_sensor(0xdd,0x00);
+		SP0A20_write_cmos_sensor(0xde,0x00);
+
+		SP0A20_write_cmos_sensor(0xfd,0x01);
+		SP0A20_write_cmos_sensor(0xf2,0x0a);
+		SP0A20_write_cmos_sensor(0xfb,0x00);
+		SP0A20_write_cmos_sensor(0xd2,0x00);
+
+		
+		SP0A20_write_cmos_sensor(0xfd , 0x01);//sat u 
+		SP0A20_write_cmos_sensor(0xd3 , 0x60);//6a
+		SP0A20_write_cmos_sensor(0xd4 , 0x60);//6a
+		SP0A20_write_cmos_sensor(0xd5 , 0x60);//56
+		SP0A20_write_cmos_sensor(0xd6 , 0x60);//44
+		//sat v
+		SP0A20_write_cmos_sensor(0xd7 , 0x60);//6a  
+		SP0A20_write_cmos_sensor(0xd8 , 0x60);//6a  
+		SP0A20_write_cmos_sensor(0xd9 , 0x60);//56  
+		SP0A20_write_cmos_sensor(0xda , 0x60);//44  
+
+
+		SP0A20_write_cmos_sensor(0x10 , 0x80);//ku_outdoor
+		SP0A20_write_cmos_sensor(0x11 , 0x80);//ku_nr
+		SP0A20_write_cmos_sensor(0x12 , 0x80);//ku_dummy
+		SP0A20_write_cmos_sensor(0x13 , 0x80);//ku_low
+		SP0A20_write_cmos_sensor(0x14 , 0x80);//88//kl_outdoor 
+		SP0A20_write_cmos_sensor(0x15 , 0x80);//88//kl_nr      
+		SP0A20_write_cmos_sensor(0x16 , 0x80);//88//kl_dummy    
+		SP0A20_write_cmos_sensor(0x17 , 0x80);//88//kl_low       
+
+		SP0A20_write_cmos_sensor(0x00,0x12);
+		SP0A20_write_cmos_sensor(0x32,0x80);	
+
+		SP0A20_write_cmos_sensor(0xfd,0x02);	
+		SP0A20_write_cmos_sensor(0x26,0x80);
+		SP0A20_write_cmos_sensor(0x27,0x80);
+
+		SP0A20_write_cmos_sensor(0xfd,0x01);	
+		SP0A20_write_cmos_sensor(0x36,0x00);
+
+		Sleep(100);
+	}
+	else        //disable test pattern output 
+	{
+        SP0A20_TST_PATTEN = KAL_FALSE;
+	    Sleep(100);
+		SP0A20_write_cmos_sensor(0xfd,0x01);	
+		Sleep(100);
+		temp_tst_reg =SP0A20_read_cmos_sensor(0x32);	
+		Sleep(100);
+		SP0A20_write_cmos_sensor(0x32, (temp_tst_reg &0x7f));	
+		Sleep(100);
+	}
+               return ERROR_NONE;
+}
+
+
+UINT32 SP0A20YUVSensorSetting(FEATURE_ID iCmd, UINT16 iPara)
+{
+	SENSORDB("%s,para= %d.\n",__func__,iPara);
+#ifdef DEBUG_SENSOR_SP0A20
+		printk("______%s______ Tflash debug \n",__func__);
+		return TRUE;
+#endif
+
+    switch (iCmd) {
+    case FID_AWB_MODE:
+        SP0A20_set_param_wb(iPara);
+        break;
+    case FID_COLOR_EFFECT:
+        SP0A20_set_param_effect(iPara);
+        break;
+    case FID_AE_EV:
+        SP0A20_set_param_exposure(iPara);
+        break;
+    case FID_AE_FLICKER:
+		SP0A20_set_param_banding(iPara);
+		if (SP0A20_Sensor_Driver.bNight_mode == KAL_FALSE){
+			SP0A20_night_mode(FALSE); 
+		}else if (SP0A20_Sensor_Driver.bNight_mode == KAL_TRUE){
+			SP0A20_night_mode(TRUE); 
+		}	
+		break;
+    case FID_SCENE_MODE:
+		SP0A20_night_mode(iPara); 
+		break;
+    default:
+        break;
+    }
+    return TRUE;
+} /* SP0A20YUVSensorSetting */
+
+
+UINT32 SP0A20FeatureControl(MSDK_SENSOR_FEATURE_ENUM FeatureId,
+        UINT8 *pFeaturePara,UINT32 *pFeatureParaLen)
+{
+    UINT16 *pFeatureReturnPara16=(UINT16 *) pFeaturePara;
+    UINT16 *pFeatureData16=(UINT16 *) pFeaturePara;
+    UINT32 *pFeatureReturnPara32=(UINT32 *) pFeaturePara;
+    UINT32 *pFeatureData32=(UINT32 *) pFeaturePara;
+    UINT32 **ppFeatureData=(UINT32 **) pFeaturePara;
+    unsigned long long *feature_data=(unsigned long long *) pFeaturePara;
+    unsigned long long *feature_return_para=(unsigned long long *) pFeaturePara;
+	
+    UINT32 SP0A20SensorRegNumber;
+    UINT32 i;
+    MSDK_SENSOR_CONFIG_STRUCT *pSensorConfigData=(MSDK_SENSOR_CONFIG_STRUCT *) pFeaturePara;
+    MSDK_SENSOR_REG_INFO_STRUCT *pSensorRegData=(MSDK_SENSOR_REG_INFO_STRUCT *) pFeaturePara;
+
+    RETAILMSG(1, (_T("gaiyang SP0A20FeatureControl FeatureId=%d\r\n"), FeatureId));
+
+    switch (FeatureId)
+    {
+    case SENSOR_FEATURE_GET_RESOLUTION:
+        *pFeatureReturnPara16++=IMAGE_SENSOR_FULL_WIDTH;
+        *pFeatureReturnPara16=IMAGE_SENSOR_FULL_HEIGHT;
+        *pFeatureParaLen=4;
+        break;
+    case SENSOR_FEATURE_GET_PERIOD:
+        *pFeatureReturnPara16++=(VGA_PERIOD_PIXEL_NUMS)+SP0A20_dummy_pixels;
+        *pFeatureReturnPara16=(VGA_PERIOD_LINE_NUMS)+SP0A20_dummy_lines;
+        *pFeatureParaLen=4;
+        break;
+    case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:
+        *pFeatureReturnPara32 = SP0A20_g_fPV_PCLK;
+        *pFeatureParaLen=4;
+        break;
+    case SENSOR_FEATURE_SET_ESHUTTER:
+        break;
+    case SENSOR_FEATURE_SET_NIGHTMODE:
+        //SP0A20NightMode((BOOL) *pFeatureData16);
+        break;
+    case SENSOR_FEATURE_SET_GAIN:
+    case SENSOR_FEATURE_SET_FLASHLIGHT:
+        break;
+    case SENSOR_FEATURE_SET_ISP_MASTER_CLOCK_FREQ:
+        SP0A20_isp_master_clock=*pFeatureData32;
+        break;
+    case SENSOR_FEATURE_SET_REGISTER:
+        SP0A20_write_cmos_sensor(pSensorRegData->RegAddr, pSensorRegData->RegData);
+        break;
+    case SENSOR_FEATURE_GET_REGISTER:
+        pSensorRegData->RegData = SP0A20_read_cmos_sensor(pSensorRegData->RegAddr);
+        break;
+    case SENSOR_FEATURE_GET_CONFIG_PARA:
+        memcpy(pSensorConfigData, &SP0A20SensorConfigData, sizeof(MSDK_SENSOR_CONFIG_STRUCT));
+        *pFeatureParaLen=sizeof(MSDK_SENSOR_CONFIG_STRUCT);
+        break;
+    case SENSOR_FEATURE_SET_CCT_REGISTER:
+    case SENSOR_FEATURE_GET_CCT_REGISTER:
+    case SENSOR_FEATURE_SET_ENG_REGISTER:
+    case SENSOR_FEATURE_GET_ENG_REGISTER:
+    case SENSOR_FEATURE_GET_REGISTER_DEFAULT:
+
+    case SENSOR_FEATURE_CAMERA_PARA_TO_SENSOR:
+    case SENSOR_FEATURE_SENSOR_TO_CAMERA_PARA:
+    case SENSOR_FEATURE_GET_GROUP_COUNT:
+    case SENSOR_FEATURE_GET_GROUP_INFO:
+    case SENSOR_FEATURE_GET_ITEM_INFO:
+    case SENSOR_FEATURE_SET_ITEM_INFO:
+    case SENSOR_FEATURE_GET_ENG_INFO:
+        break;
+    case SENSOR_FEATURE_GET_LENS_DRIVER_ID:
+        // get the lens driver ID from EEPROM or just return LENS_DRIVER_ID_DO_NOT_CARE
+        // if EEPROM does not exist in camera module.
+        *pFeatureReturnPara32=LENS_DRIVER_ID_DO_NOT_CARE;
+        *pFeatureParaLen=4;
+        break;
+    case SENSOR_FEATURE_SET_YUV_CMD:
+        SP0A20YUVSensorSetting((FEATURE_ID)*feature_data, *(feature_data+1));
+        break;
+    case SENSOR_FEATURE_SET_VIDEO_MODE:    //  lanking
+	 SP0A20YUVSetVideoMode(*feature_data);
+	 break;
+    case SENSOR_FEATURE_CHECK_SENSOR_ID:
+	SP0A20GetSensorID(pFeatureData32);
+	break;
+    case SENSOR_FEATURE_GET_EXIF_INFO:
+		SP0A20GetExifInfo((uintptr_t)*feature_data);
+		break;
+	case SENSOR_FEATURE_SET_TEST_PATTERN:
+		   SP0A20SetTestPatternMode((BOOL)*feature_data);
+		   break;
+	case SENSOR_FEATURE_GET_TEST_PATTERN_CHECKSUM_VALUE://for factory mode auto testing			   
+		 *pFeatureReturnPara32= SP0A20_TEST_PATTERN_CHECKSUM;
+		 *pFeatureParaLen=4;						   
+		   break;	  
+
+
+    default:
+        break;
+	}
+
+return ERROR_NONE;
+}	/* SP0A20FeatureControl() */
+
+
+SENSOR_FUNCTION_STRUCT	SensorFuncSP0A20YUV=
+{
+	SP0A20Open,
+	SP0A20GetInfo,
+	SP0A20GetResolution,
+	SP0A20FeatureControl,
+	SP0A20Control,
+	SP0A20Close
+};
+
+
+UINT32 SP0A20_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
+{
+	/* To Do : Check Sensor status here */
+	if (pfFunc!=NULL)
+		*pfFunc=&SensorFuncSP0A20YUV;
+	return ERROR_NONE;
+} /* SensorInit() */
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/sp0a20_yuv/sp0a20_yuv_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/sp0a20_yuv/sp0a20_yuv_Sensor.h
new file mode 100644
index 0000000..c2f8c83
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/sp0a20_yuv/sp0a20_yuv_Sensor.h
@@ -0,0 +1,133 @@
+
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *   SP0A20_yuv_Sensor.h
+ *
+ * Project:
+ * --------
+ *   MAUI
+ *
+ * Description:
+ * ------------
+ *   Image sensor driver declare and macro define in the header file.
+ *
+ * Author:
+ * -------
+ *   Mormo
+ *
+ *=============================================================
+ *             HISTORY
+ * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
+ *------------------------------------------------------------------------------
+ * $Log$
+ * 2011/10/25 Firsty Released By Mormo;
+ *
+ *
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
+ *=============================================================
+ ******************************************************************************/
+ 
+#ifndef __SP0A20_SENSOR_H
+#define __SP0A20_SENSOR_H
+
+//#include "image_sensor.h"//get IMAGE_SENSOR_DRVNAME
+#include "kd_imgsensor.h"
+
+    //------------------------Engineer mode---------------------------------
+#define FACTORY_START_ADDR 	0
+#define ENGINEER_START_ADDR	10
+
+    typedef enum group_enum {
+       PRE_GAIN=0,
+	   CMMCLK_CURRENT,
+	   FRAME_RATE_LIMITATION,
+	   REGISTER_EDITOR,
+	   GROUP_TOTAL_NUMS
+    } FACTORY_REGISTER_INDEX;
+
+    typedef enum register_index {
+        SENSOR_BASEGAIN=FACTORY_START_ADDR,
+	      PRE_GAIN_R_INDEX,
+	      PRE_GAIN_Gr_INDEX,
+	      PRE_GAIN_Gb_INDEX,
+	      PRE_GAIN_B_INDEX,
+	      FACTORY_END_ADDR
+    } CCT_REGISTER_INDEX;
+    
+typedef enum engineer_index
+{   
+	CMMCLK_CURRENT_INDEX=ENGINEER_START_ADDR,
+	ENGINEER_END
+} FACTORY_ENGINEER_INDEX; 
+
+//------------------------Engineer mode---------------------------------
+typedef struct {
+    SENSOR_REG_STRUCT Reg[ENGINEER_END];
+    SENSOR_REG_STRUCT CCT[FACTORY_END_ADDR];
+} SENSOR_DATA_STRUCT,*PSENSOR_DATA_STRUCT;
+
+
+
+#define VGA_PERIOD_PIXEL_NUMS						784
+#define VGA_PERIOD_LINE_NUMS						510
+
+#define IMAGE_SENSOR_VGA_GRAB_PIXELS			0
+#define IMAGE_SENSOR_VGA_GRAB_LINES			1
+
+#define IMAGE_SENSOR_VGA_WIDTH					(640)
+#define IMAGE_SENSOR_VGA_HEIGHT					(480)
+
+#define IMAGE_SENSOR_PV_WIDTH					(IMAGE_SENSOR_VGA_WIDTH - 8)
+#define IMAGE_SENSOR_PV_HEIGHT					(IMAGE_SENSOR_VGA_HEIGHT - 6)
+
+#define IMAGE_SENSOR_FULL_WIDTH					(IMAGE_SENSOR_VGA_WIDTH - 8)
+#define IMAGE_SENSOR_FULL_HEIGHT					(IMAGE_SENSOR_VGA_HEIGHT - 6)
+
+#define SP0A20_WRITE_ID							        0x42
+#define SP0A20_READ_ID								0x43
+
+
+struct SP0A20_Sensor_Struct
+{
+	struct i2c_client *i2c_clit;
+	MSDK_SENSOR_CONFIG_STRUCT cfg_data;
+	SENSOR_DATA_STRUCT eng; /* engineer mode */
+	MSDK_SENSOR_ENG_INFO_STRUCT eng_info;
+
+	
+	kal_bool sensor_night_mode;
+	kal_bool MPEG4_encode_mode;
+
+	kal_uint16 dummy_pixels;
+	kal_uint16 dummy_lines;
+	kal_uint16 extra_exposure_lines;
+	kal_uint16 exposure_lines;
+
+	kal_bool MODE_CAPTURE;
+	kal_uint16 iBackupExtraExp;
+
+
+	
+	kal_uint32 fPV_PCLK; //26000000;
+	kal_uint16 iPV_Pixels_Per_Line;
+
+	kal_bool  bNight_mode; // to distinguish night mode or auto mode, default: auto mode setting
+	kal_bool  bBanding_value; // to distinguish between 50HZ and 60HZ.
+	kal_uint8 u8Wb_value;
+	kal_uint8 u8Effect_value;
+	kal_uint8 u8Ev_value;
+};
+
+
+UINT32 SP0A20Open(void);
+UINT32 SP0A20Control(MSDK_SCENARIO_ID_ENUM ScenarioId, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *pImageWindow, MSDK_SENSOR_CONFIG_STRUCT *pSensorConfigData);
+UINT32 SP0A20FeatureControl(MSDK_SENSOR_FEATURE_ENUM FeatureId, UINT8 *pFeaturePara,UINT32 *pFeatureParaLen);
+UINT32 SP0A20GetInfo(MSDK_SCENARIO_ID_ENUM ScenarioId, MSDK_SENSOR_INFO_STRUCT *pSensorInfo, MSDK_SENSOR_CONFIG_STRUCT *pSensorConfigData);
+UINT32 SP0A20GetResolution(MSDK_SENSOR_RESOLUTION_INFO_STRUCT *pSensorResolution);
+UINT32 SP0A20Close(void);
+
+#endif /* __SENSOR_H */
+
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/sp2508_mipi_raw/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6735m/sp2508_mipi_raw/Makefile
index 27db1df..f6e62c5 100755
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/sp2508_mipi_raw/Makefile
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/sp2508_mipi_raw/Makefile
@@ -1,4 +1,4 @@
 include $(srctree)/drivers/misc/mediatek/Makefile.custom
-obj-y += sp2508mipi_Sensor.o
 
+obj-y += sp2508mipiraw_Sensor.o
 
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/sp2508_mipi_raw/sp2508mipiraw_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/sp2508_mipi_raw/sp2508mipiraw_Sensor.c
new file mode 100644
index 0000000..7c34258
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/sp2508_mipi_raw/sp2508mipiraw_Sensor.c
@@ -0,0 +1,1496 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *     SP2508mipi_Sensor.c
+ *
+ * Project:
+ * --------
+ *     ALPS
+ *
+ * Description:
+ * ------------
+ *     Source code of Sensor driver
+ *
+ *
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *============================================================================
+ ****************************************************************************/
+
+#include <linux/videodev2.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <asm/atomic.h>
+#include <linux/xlog.h>
+#include "kd_camera_hw.h"
+#include "kd_imgsensor.h"
+#include "kd_imgsensor_define.h"
+#include "kd_imgsensor_errcode.h"
+#include "sp2508mipiraw_Sensor.h"
+
+#ifdef SLT_DEVINFO_CMM_SP2508 	
+#include  <linux/dev_info.h> 
+static struct devinfo_struct *s_DEVINFO_ccm;   //suppose 10 max lcm device 
+#endif
+
+/****************************Modify Following Strings for Debug****************************/
+#define PFX "SP2508_camera_sensor"
+
+#define LOG_1 LOG_INF("SP2508,MIPI 1LANE\n")
+#define LOG_2 LOG_INF("preview 1600*1200@30fps,864Mbps/lane; video 1600*1200@30fps,864Mbps/lane; capture 2M@30fps,864Mbps/lane\n")
+/****************************   Modify end    *******************************************/
+
+#define LOG_INF(format, args...)    xlog_printk(ANDROID_LOG_INFO   , PFX, "[%s] " format, __FUNCTION__, ##args)
+
+/*****************************************************************************/
+//	T CARD DEBUG
+//	debug by sp_zze 2015-06-03
+/*****************************************************************************/
+//#define DEBUG_SENSOR_SP2508		//for T-card
+#ifdef DEBUG_SENSOR_SP2508	//sp_zze
+#include <asm/uaccess.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+
+#define SP2508_SD_FILE_PATH					"/mnt/sdcard/SP2508_sd"
+#define	SP_I2C_WRITE						write_cmos_sensor
+#define	SP_I2C_READ							read_cmos_sensor
+#define SP_LOG								LOG_INF
+#define SP_DELAY							msleep
+#define U32									kal_uint32
+#define U16									kal_uint16
+#define U8									kal_uint8
+#define DATA_BUFF_SIZE						(25*1024)//25k, must be larger than size of sd file
+
+typedef struct
+{
+	U16 addr;
+	U16 val;
+} SP2508_init_regs_struct;
+
+static kal_uint16 read_cmos_sensor(kal_uint32 addr);
+static void write_cmos_sensor(kal_uint32 addr, kal_uint32 para);
+
+static U8 sp_tolower(U8 c)
+{
+	if (c <= 'Z' && c >= 'A')
+		return (c + 'a' - 'A');
+	
+	return c;
+}
+#define BASE_MAX	36
+static const char digits[] = {"0123456789abcdefghijklmnopqrstuvwxyz"};
+static U32 sp_strtoul(const char *str, char **endptr, U8 base)	//sp_zhangzhaoen
+{
+	const char *sc;
+	const char *s1, *s2;
+	U32 x = 0;
+	
+	for (sc = str; ; sc++) {	// skip space
+		if (!(*sc == ' ' || *sc == '\t'))
+			break;
+	}
+
+	if (base == 1 || base > BASE_MAX) {
+		if (endptr)
+			*endptr = (char *)str;		
+		return 0;
+	} else if (base) {
+		if (base == 16 && *sc == '0' 
+			&& (sc[1] == 'x' || sc[1] == 'X'))
+			sc += 2;
+	} else if (*sc != '0') {
+		base = 10;
+	} else if (sc[1] == 'x' || sc[1] == 'X') {
+		base = 16;
+		sc += 2;
+	} else {
+		base = 8;
+	}
+	
+	for (s1 = sc; *sc == '0'; ++sc)
+		;
+	
+	for (; ; ++sc) {
+		s2 = memchr(digits, sp_tolower(*sc), base);
+		if (s2 == NULL)
+			break;
+
+		x = x * base + (s2 - digits);
+	}
+	if (s1 == sc) {
+		if (endptr)
+			*endptr = (char *)str;		
+		return 0;
+	}
+
+	// DEBUG: when overflow
+	
+	if (endptr)
+		*endptr = (char *)sc;
+	
+	return (x);
+}
+static U32 SP2508_Initialize_from_T_Flash(char *file_path)
+{
+	U8 *curr_ptr = NULL;
+	U8 *tmp = NULL;
+	U32 file_size = 0;
+	U32 regs_total = 0;
+	U8 func_ind[4] = {0};	/* REG or DLY */
+	struct file *fp; 
+	mm_segment_t fs; 
+	loff_t pos = 0; 
+	static U8 data_buff[DATA_BUFF_SIZE];
+	SP2508_init_regs_struct SP2508_reg;
+	
+	fp = filp_open(file_path, O_RDONLY , 0); 
+	if (IS_ERR(fp)) { 
+		SP_LOG("create file error\n"); 
+		return 0; 
+	} 
+	fs = get_fs(); 
+	set_fs(KERNEL_DS); 
+	file_size = vfs_llseek(fp, 0, SEEK_END);
+	vfs_read(fp, data_buff, file_size, &pos); 
+	filp_close(fp, NULL); 
+	set_fs(fs);
+	
+	curr_ptr = data_buff;
+	while (curr_ptr < (data_buff + file_size)) {
+		while ((*curr_ptr == ' ') || (*curr_ptr == '\t'))/* Skip the Space & TAB */
+			curr_ptr++;		
+			
+		if (((*curr_ptr) == '/') && ((*(curr_ptr + 1)) == '*')) {
+			curr_ptr += 2;	//skip '/' and '*'	added by sp_zze
+			
+			while (!(((*curr_ptr) == '*') && ((*(curr_ptr + 1)) == '/'))) {
+				curr_ptr += 2;		/* Skip block comment code. */
+			}
+			while (!((*curr_ptr == 0x0D) && (*(curr_ptr+1) == 0x0A))) {
+				curr_ptr++;
+				
+				if (curr_ptr >= (data_buff + file_size))
+					break;
+			}
+			curr_ptr += 2;						/* Skip the enter line */
+			continue ;
+		}
+		
+		if (((*curr_ptr) == '/') && ((*(curr_ptr + 1)) == '/'))	{	/* Comment line, skip it. */
+			while (!((*curr_ptr == 0x0D) && (*(curr_ptr+1) == 0x0A))) {
+				curr_ptr++;
+				
+				if (curr_ptr >= (data_buff + file_size))
+					break;
+			}
+
+			curr_ptr += 2;						/* Skip the enter line */
+
+			continue ;
+		}
+
+		if (((*curr_ptr) == 0x0D) && ((*(curr_ptr + 1)) == 0x0A)) {
+			curr_ptr += 2;
+			continue ;
+		}
+		
+		memcpy(func_ind, curr_ptr, 3);		
+		if (!strcmp((const char *)func_ind, "REG")) {		/* REG */
+			curr_ptr += 4;				/* Skip "REG{" */
+			SP2508_reg.addr = sp_strtoul((const char *)curr_ptr, &tmp, 16);
+			curr_ptr = tmp;
+			curr_ptr ++;	/* Skip "," */
+			SP2508_reg.val = sp_strtoul((const char *)curr_ptr, &tmp, 16);
+			curr_ptr += 2;	/* Skip "};" */
+			
+			//init
+			SP_I2C_WRITE(SP2508_reg.addr, SP2508_reg.val);
+			regs_total++;
+		} else if (!strcmp((const char *)func_ind, "DLY")) {	/* DLY */
+			curr_ptr += 4;				/* Skip "DLY(" */
+			SP2508_reg.val = sp_strtoul((const char *)curr_ptr, &tmp, 10);
+			curr_ptr = tmp;
+
+			SP_DELAY(SP2508_reg.val);
+		}
+
+		while (!((*curr_ptr == 0x0D) && (*(curr_ptr+1) == 0x0A))) {
+			curr_ptr++;
+			
+			if (curr_ptr >= (data_buff + file_size))
+				break;
+		}
+		curr_ptr += 2;
+	}
+
+	return regs_total;
+}
+static U8 read_from_extern_flash(char *file_path)
+{
+	struct file *fp; 
+
+	fp = filp_open(file_path, O_RDONLY , 0); 
+	if (IS_ERR(fp)) {   
+		SP_LOG("open file error\n");
+		return 0;
+	} else {
+		SP_LOG("open file ok\n");
+		filp_close(fp, NULL); 
+	}
+	
+	return 1;
+}
+
+#define SP2508_OTHER_DEBUG_PATH					"/mnt/sdcard/SP2508_debug"
+static imgsensor_info_struct imgsensor_info;
+static void SP2508_other_debug(char *file_path)	//sp_zze
+{
+	U8 *curr_ptr = NULL;
+	U8 *tmp = NULL;
+	U32 file_size = 0;
+	struct file *fp; 
+	mm_segment_t fs; 
+	loff_t pos = 0; 
+	static U8 data_buff[1024];
+	
+	fp = filp_open(file_path, O_RDONLY , 0); 
+	if (IS_ERR(fp)) { 
+		SP_LOG("create file error\n"); 
+		return; 
+	} 
+	fs = get_fs(); 
+	set_fs(KERNEL_DS); 
+	file_size = vfs_llseek(fp, 0, SEEK_END);
+	vfs_read(fp, data_buff, file_size, &pos); 
+	filp_close(fp, NULL); 
+	set_fs(fs);
+	
+	curr_ptr = data_buff;
+	
+	imgsensor_info.ae_shut_delay_frame = sp_strtoul((const char *)curr_ptr, &tmp, 10);
+	curr_ptr = tmp;
+	curr_ptr ++;	/* Skip "," */
+	imgsensor_info.ae_sensor_gain_delay_frame = sp_strtoul((const char *)curr_ptr, &tmp, 10);
+	curr_ptr = tmp;
+	curr_ptr ++;	/* Skip "," */
+	imgsensor_info.ae_ispGain_delay_frame = sp_strtoul((const char *)curr_ptr, &tmp, 10);
+	//sensor_info->AEShutDelayFrame = imgsensor_info.ae_shut_delay_frame;
+    //sensor_info->AESensorGainDelayFrame = imgsensor_info.ae_sensor_gain_delay_frame;
+    //sensor_info->AEISPGainDelayFrame = imgsensor_info.ae_ispGain_delay_frame;
+	
+	return;
+}
+#endif	//END of T CARD DEBUG
+
+static DEFINE_SPINLOCK(imgsensor_drv_lock);
+
+
+static imgsensor_info_struct imgsensor_info = { 
+    .sensor_id = SP2508_SENSOR_ID,
+    .checksum_value = 0xffd8e112,        //checksum value for Camera Auto Test
+
+    .pre = {
+        .pclk = 30000000,              //record different mode's pclk //21
+        .linelength = 1160,             //record different mode's linelength
+        .framelength = 1241,            //record different mode's framelength
+        .startx = 0,                    //record different mode's startx of grabwindow
+        .starty = 0,                    //record different mode's starty of grabwindow
+		.grabwindow_width = 1600,		//record different mode's width of grabwindow
+		.grabwindow_height = 1200,		//record different mode's height of grabwindow
+        /*   following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario   */
+        .mipi_data_lp2hs_settle_dc = 85,
+        /*   following for GetDefaultFramerateByScenario()  */
+        .max_framerate = 300,   
+    },
+    .cap = {
+        .pclk = 30000000,
+        .linelength = 1160,
+        .framelength = 1241,
+        .startx = 0,
+        .starty = 0,
+		.grabwindow_width = 1600,
+		.grabwindow_height = 1200,
+        .mipi_data_lp2hs_settle_dc = 85,
+        .max_framerate = 300,
+    },
+    .cap1 = {
+        .pclk = 30000000,
+        .linelength = 1160,
+        .framelength = 1241,
+        .startx = 0,
+        .starty = 0,
+		.grabwindow_width = 1600,
+		.grabwindow_height = 1200,
+        .mipi_data_lp2hs_settle_dc = 85,
+        .max_framerate = 300,   
+    },
+    .normal_video = {
+        .pclk = 30000000,
+        .linelength = 1160,
+		.framelength = 1241,
+		.startx = 0,
+		.starty = 0,
+		.grabwindow_width = 1600,
+		.grabwindow_height = 1200,
+        .mipi_data_lp2hs_settle_dc = 85,
+        .max_framerate = 300,
+    },
+    .hs_video = {
+        .pclk = 30000000,
+        .linelength = 1160,
+        .framelength = 1241,
+        .startx = 0,
+        .starty = 0,
+        .grabwindow_width = 1600,
+        .grabwindow_height = 1200,
+        .mipi_data_lp2hs_settle_dc = 85,
+        .max_framerate = 600,
+    },
+    .slim_video = {
+        .pclk = 30000000,
+        .linelength = 1160,
+        .framelength = 1241,
+        .startx = 0,
+        .starty = 0,
+        .grabwindow_width = 1600,
+        .grabwindow_height = 1200,
+        .mipi_data_lp2hs_settle_dc = 85,
+        .max_framerate = 300,
+    },
+    .margin = 4,            //sensor framelength & shutter margin
+    .min_shutter = 7,
+    .max_frame_length = 0xffff,
+    .ae_shut_delay_frame = 0,    //shutter delay frame for AE cycle, 2 frame with ispGain_delay-shut_delay=2-0=2
+    .ae_sensor_gain_delay_frame = 0,//sensor gain delay frame for AE cycle,2 frame with ispGain_delay-sensor_gain_delay=2-0=2
+    .ae_ispGain_delay_frame = 2,//isp gain delay frame for AE cycle
+    .ihdr_support = 0,      //1, support; 0,not support
+    .ihdr_le_firstline = 0,  //1,le first ; 0, se first
+    .sensor_mode_num = 10,      //support sensor mode num
+
+    .cap_delay_frame = 3,        //enter capture delay frame num
+    .pre_delay_frame = 3,         //enter preview delay frame num
+    .video_delay_frame = 5,        //enter video delay frame num
+    .hs_video_delay_frame = 5,    //enter high speed video  delay frame num
+    .slim_video_delay_frame = 5,//enter slim video delay frame num
+
+    .isp_driving_current = ISP_DRIVING_8MA, //mclk driving current
+    .sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,//sensor_interface_type
+    .mipi_sensor_type = MIPI_OPHY_NCSI2, //0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2
+    .mipi_settle_delay_mode = MIPI_SETTLEDELAY_AUTO,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
+    .sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_B,//sensor output first pixel color
+    .mclk = 24,//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
+    .mipi_lane_num = SENSOR_MIPI_1_LANE,//mipi lane num
+    .i2c_addr_table = {0x78, 0x7a, 0xff},//record sensor support all write id addr, only supprt 4must end with 0xff
+};
+
+
+static imgsensor_struct imgsensor = {
+    .mirror = IMAGE_NORMAL,             //mirrorflip information
+    .sensor_mode = IMGSENSOR_MODE_INIT, //IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
+    .shutter = 0x46e,                   //current shutter   // Danbo ??
+    .gain = 0x40,                      //current gain     // Danbo ??
+    .dummy_pixel = 272,                   //current dummypixel
+    .dummy_line = 32,                    //current dummyline
+    .current_fps = 300,  //full size current fps : 24fps for PIP, 30fps for Normal or ZSD
+    .autoflicker_en = KAL_FALSE,  //auto flicker enable: KAL_FALSE for disable auto flicker, KAL_TRUE for enable auto flicker
+    .test_pattern = KAL_FALSE,      //test pattern mode or not. KAL_FALSE for in test pattern mode, KAL_TRUE for normal output
+    .current_scenario_id = MSDK_SCENARIO_ID_CAMERA_PREVIEW,//current scenario id
+    .ihdr_en = 0, //sensor need support LE, SE with HDR feature
+    .i2c_write_id = 0x78,
+};
+
+
+/* Sensor output window information */
+static SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[5] =
+{
+ { 1600, 1200, 0, 0, 1600, 1200, 1600, 1200, 0000, 0000, 1600, 1200, 0, 0, 1600, 1200}, // Preview 2112*1558
+ { 1600, 1200, 0, 0, 1600, 1200, 1600, 1200, 0000, 0000, 1600, 1200, 0, 0, 1600, 1200}, // capture 4206*3128
+ { 1600, 1200, 0, 0, 1600, 1200, 1600, 1200, 0000, 0000, 1600, 1200, 0, 0, 1600, 1200}, // video 
+ { 1600, 1200, 0, 0, 1600, 1200, 1600, 1200, 0000, 0000, 1600, 1200, 0, 0, 1600, 1200}, //hight speed video 
+ { 1600, 1200, 0, 0, 1600, 1200, 1600, 1200, 0000, 0000, 1600, 1200, 0, 0, 1600, 1200}};// slim video
+
+
+
+static kal_uint16 read_cmos_sensor(kal_uint32 addr)
+{
+	kal_uint16 get_byte=0;
+
+	char pu_send_cmd[1] = {(char)(addr & 0xFF) };
+	iReadRegI2C(pu_send_cmd, 1, (u8*)&get_byte, 1, imgsensor.i2c_write_id);
+
+	return get_byte;
+
+}
+
+static void write_cmos_sensor(kal_uint32 addr, kal_uint32 para)
+{
+		char pu_send_cmd[2] = {(char)(addr & 0xFF), (char)(para & 0xFF)};
+		iWriteRegI2C(pu_send_cmd, 2, imgsensor.i2c_write_id);
+}
+
+static void set_dummy()
+{   
+}    /*    set_dummy  */
+
+
+static kal_uint32 return_sensor_id()
+{
+    write_cmos_sensor(0xfd, 0x00);
+	return ((read_cmos_sensor(0x02) << 8) | read_cmos_sensor(0x03));
+}
+static void set_max_framerate(UINT16 framerate,kal_bool min_framelength_en)
+{
+    kal_int16 dummy_line;
+    kal_uint32 frame_length = imgsensor.frame_length;
+
+    LOG_INF("framerate = %d, min framelength should enable? \n", framerate,min_framelength_en);
+
+    frame_length = imgsensor.pclk / framerate * 10 / imgsensor.line_length;
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.frame_length = (frame_length > imgsensor.min_frame_length) ? frame_length : imgsensor.min_frame_length;
+    imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
+    
+    if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+    {
+        imgsensor.frame_length = imgsensor_info.max_frame_length;
+        imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
+    }
+    if (min_framelength_en)
+        imgsensor.min_frame_length = imgsensor.frame_length;
+    spin_unlock(&imgsensor_drv_lock);
+}    /*    set_max_framerate  */
+
+
+
+static void write_shutter(kal_uint16 shutter)
+{  
+        write_cmos_sensor(0xfd, 0x01); 
+        write_cmos_sensor(0x03, (shutter >> 8) & 0xFF);
+        write_cmos_sensor(0x04, shutter  & 0xFF); 
+        write_cmos_sensor(0x01, 0x01); 
+        LOG_INF("shutter =%d, framelength =%d\n", shutter,imgsensor.frame_length);
+
+}   /*  write_shutter  */
+
+
+
+/*************************************************************************
+* FUNCTION
+*    set_shutter
+*
+* DESCRIPTION
+*    This function set e-shutter of sensor to change exposure time.
+*
+* PARAMETERS
+*    iShutter : exposured lines
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static void set_shutter(kal_uint16 shutter)
+{
+    unsigned long flags;
+    if (shutter < 7)
+          shutter = 7; 
+	else if(shutter > 0xffff)
+	   shutter = 0xffff;
+	
+    spin_lock_irqsave(&imgsensor_drv_lock, flags);
+    imgsensor.shutter = shutter;
+    spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
+    
+	write_shutter(shutter);
+
+}    /*    set_shutter */
+
+
+
+static kal_uint16 gain2reg(const kal_uint16 gain)
+{
+	kal_uint16 reg_gain = 0x0000;
+	
+	reg_gain =	(( gain / BASEGAIN) << 4) + (( gain % BASEGAIN)* 16 / BASEGAIN);
+	
+	reg_gain = reg_gain & 0xFFFF;
+	
+	return (kal_uint16)reg_gain;
+
+}
+
+/*************************************************************************
+* FUNCTION
+*    set_gain
+*
+* DESCRIPTION
+*    This function is to set global gain to sensor.
+*
+* PARAMETERS
+*    iGain : sensor global gain(base: 0x40)
+*
+* RETURNS
+*    the actually gain set to sensor.
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint16 set_gain(kal_uint16 gain)
+{ 
+         kal_uint8  iReg;
+
+	    if(gain >= BASEGAIN && gain <= 15*BASEGAIN)
+   	 {   
+   	    	 iReg = 0x10 * gain/BASEGAIN;        //change mtk gain base to aptina gain base
+               iReg+= (gain%BASEGAIN)/(0x10/BASEGAIN);
+						   	
+   	    	 if(iReg<=0x10)
+   	    	 {
+   	    	    	 write_cmos_sensor(0xfd, 0x01);
+   	    	    	 write_cmos_sensor(0x24, 0x10);//0x23
+   	    	    	 write_cmos_sensor(0x01, 0x01);
+                      LOG_INF("SP2508MIPI_SetGain = 16");
+   	    	 }
+   	    	 else if(iReg>= 0xa0)//gpw
+   	    	 {
+   	    	    	 write_cmos_sensor(0xfd, 0x01);
+   	    	    	 write_cmos_sensor(0x24,0xa0);
+   	    	    	 write_cmos_sensor(0x01, 0x01); 
+                      LOG_INF("SP2508MIPI_SetGain = 160"); 
+	        }        	
+   	    	 else
+   	    	 {
+   	    	    	write_cmos_sensor(0xfd, 0x01);
+   	    	    	write_cmos_sensor(0x24, (kal_uint8)iReg);
+   	    	    	write_cmos_sensor(0x01, 0x01);
+			LOG_INF("SP2508MIPI_SetGain = %d",iReg);		 
+	       }	
+   	 }	
+   	 else
+   	    	 LOG_INF("error gain setting");	 
+	 
+        return gain;
+}    /*    set_gain  */
+
+static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gain)
+{
+}
+
+static void set_mirror_flip(kal_uint8 image_mirror)
+{
+	LOG_INF("image_mirror = %d\n", image_mirror);
+       write_cmos_sensor(0xfd,0x01);
+	switch (image_mirror)
+	{
+		case IMAGE_NORMAL://IMAGE_NORMAL:			
+         		write_cmos_sensor(0x3f,0x00);
+			break;
+		case IMAGE_H_MIRROR://IMAGE_H_MIRROR:
+         		write_cmos_sensor(0x3f,0x01);
+			break;
+		case IMAGE_V_MIRROR://IMAGE_V_MIRROR:
+         		write_cmos_sensor(0x3f,0x02);
+			break;
+		case IMAGE_HV_MIRROR://IMAGE_HV_MIRROR:
+         		write_cmos_sensor(0x3f,0x03);
+			break;
+		default:
+         		LOG_INF("Error image_mirror setting\n");
+	}
+}
+
+/*************************************************************************
+* FUNCTION
+*    night_mode
+*
+* DESCRIPTION
+*    This function night mode of sensor.
+*
+* PARAMETERS
+*    bEnable: KAL_TRUE -> enable night mode, otherwise, disable night mode
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static void night_mode(kal_bool enable)
+{
+/*No Need to implement this function*/
+}    /*    night_mode    */
+
+static void sensor_init(void)
+{    
+	LOG_INF("Enter sensor_init.\n");
+	//update by xingdy, 20150309
+	//pll clk 60M
+	//p1:0x2b=0xc4, p1:0x58=0x30, pixel bias 2u
+	//add offset h'20 and  remove the digital gain
+	//T_horizontal=1160, base is h'103, 21fps
+	//add digital gain 1.3x 
+	{
+	write_cmos_sensor(0xfd,0x00);
+	write_cmos_sensor(0x1c,0x03);
+	write_cmos_sensor(0x35,0x20); //pll bias
+	write_cmos_sensor(0x2f,0x08); //pll clk 60M            
+	write_cmos_sensor(0xfd,0x01);
+	write_cmos_sensor(0x03,0x03); //exp time, 3 base
+	write_cmos_sensor(0x04,0x09);
+	write_cmos_sensor(0x06,0x10); //vblank
+	write_cmos_sensor(0x24,0xa0); //pga gain 10x
+	write_cmos_sensor(0x01,0x01); //enable reg write
+	write_cmos_sensor(0x2b,0xc4); //readout vref
+	write_cmos_sensor(0x2e,0x20); //dclk delay
+	write_cmos_sensor(0x79,0x42); //p39 p40
+	write_cmos_sensor(0x85,0x0f); //p51
+	write_cmos_sensor(0x09,0x01); //hblank
+	write_cmos_sensor(0x0a,0x40);
+	write_cmos_sensor(0x21,0xef); //pcp tx 4.05v
+	write_cmos_sensor(0x25,0xf2); //reg dac 2.7v, enable bl_en,vbl 1.4v
+	write_cmos_sensor(0x26,0x00); //vref2 1v, disable ramp driver
+	write_cmos_sensor(0x2a,0xea); //bypass dac res, adc range 0.745, vreg counter 0.9
+	write_cmos_sensor(0x2c,0xf0); //high 8bit, pldo 2.7v
+	write_cmos_sensor(0x8a,0x55); //pixel bias 1uA
+	write_cmos_sensor(0x8b,0x55); 
+	write_cmos_sensor(0x19,0xf3); //icom1 1.7u, icom2 0.6u 
+	write_cmos_sensor(0x11,0x30); //rst num
+	write_cmos_sensor(0xd0,0x01); //disable boost
+	write_cmos_sensor(0xd1,0x01);
+	write_cmos_sensor(0xd2,0xd0);
+	write_cmos_sensor(0x55,0x10);
+	write_cmos_sensor(0x58,0x30);
+	write_cmos_sensor(0x5d,0x15);
+	write_cmos_sensor(0x5e,0x05);
+	write_cmos_sensor(0x64,0x40);
+	write_cmos_sensor(0x65,0x00);
+	write_cmos_sensor(0x66,0x66);
+	write_cmos_sensor(0x67,0x00);
+	write_cmos_sensor(0x68,0x68);
+	write_cmos_sensor(0x72,0x70);
+	write_cmos_sensor(0xfb,0x25);
+	write_cmos_sensor(0xf0,0x00);//offset
+	write_cmos_sensor(0xf1,0x00);
+	write_cmos_sensor(0xf2,0x00);
+	write_cmos_sensor(0xf3,0x00);
+	write_cmos_sensor(0xfd,0x02);//raw data digital gain
+	write_cmos_sensor(0x00,0xb0);
+	write_cmos_sensor(0x01,0xb0);
+	write_cmos_sensor(0x03,0xb0);
+	write_cmos_sensor(0x04,0xb0);
+	write_cmos_sensor(0xfd,0x01);//mipi
+	write_cmos_sensor(0xb3,0x00);
+	write_cmos_sensor(0x93,0x01);
+	write_cmos_sensor(0x9d,0x17);
+	write_cmos_sensor(0xc5,0x01);
+	write_cmos_sensor(0xc6,0x00);
+	write_cmos_sensor(0xb1,0x01);
+	write_cmos_sensor(0x8e,0x06);
+	write_cmos_sensor(0x8f,0x50);
+	write_cmos_sensor(0x90,0x04);
+	write_cmos_sensor(0x91,0xc0);
+	write_cmos_sensor(0x92,0x01);
+	write_cmos_sensor(0xa1,0x05);
+	write_cmos_sensor(0xaa,0x01);
+	write_cmos_sensor(0xac,0x01);
+	}
+ 	 LOG_INF("Exit sensor_init.\n");  
+}    /*    sensor_init  */
+
+static void preview_setting(void)
+{
+}    /*    preview_setting  */
+
+static void capture_setting(kal_uint16 currefps)
+{
+}
+
+static void normal_video_setting(kal_uint16 currefps)
+{
+}
+
+static void hs_video_setting()
+{
+}
+
+static void slim_video_setting()
+{
+}
+
+static kal_uint32 set_test_pattern_mode(kal_bool enable)
+{
+    LOG_INF("enable: %d\n", enable);
+    if(enable)
+    {
+        write_cmos_sensor(0xfd,0x01);
+        write_cmos_sensor(0x0d,0x01);
+    }
+	else
+	{
+        write_cmos_sensor(0xfd,0x01);
+        write_cmos_sensor(0x0d,0x00);
+	}
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.test_pattern = enable;
+    spin_unlock(&imgsensor_drv_lock);
+    return ERROR_NONE;
+}
+
+/*************************************************************************
+* FUNCTION
+*    get_imgsensor_id
+*
+* DESCRIPTION
+*    This function get the sensor ID
+*
+* PARAMETERS
+*    *sensorID : return the sensor ID
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 get_imgsensor_id(UINT32 *sensor_id)
+{
+     kal_uint8 i = 0;
+    kal_uint8 retry = 2;
+#ifdef SLT_DEVINFO_CMM_SP2508 
+ 	s_DEVINFO_ccm =(struct devinfo_struct*) kmalloc(sizeof(struct devinfo_struct), GFP_KERNEL);	
+	s_DEVINFO_ccm->device_type = "CCM-S";
+	s_DEVINFO_ccm->device_module = "PCOFL0001B";//can change if got module id
+	s_DEVINFO_ccm->device_vendor = "Sanlaishi";
+	s_DEVINFO_ccm->device_ic = "SP2508";
+	s_DEVINFO_ccm->device_version = "Superpix";
+	s_DEVINFO_ccm->device_info = "200W";
+#endif
+    //sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
+    while (imgsensor_info.i2c_addr_table[i] != 0xff) {
+        spin_lock(&imgsensor_drv_lock);
+        imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
+        spin_unlock(&imgsensor_drv_lock);
+        do {
+            *sensor_id = return_sensor_id();
+            if (*sensor_id == imgsensor_info.sensor_id) {               
+                LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);      
+			#ifdef SLT_DEVINFO_CMM_SP2508 
+				s_DEVINFO_ccm->device_used = DEVINFO_USED;
+				devinfo_check_add_device(s_DEVINFO_ccm);
+			#endif	     
+                return ERROR_NONE;
+            }   
+            LOG_INF("Read sensor id fail, id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
+            retry--;
+        } while(retry > 0);
+        i++;
+        retry = 2;
+    }
+    if (*sensor_id != imgsensor_info.sensor_id) {
+        // if Sensor ID is not correct, Must set *sensor_id to 0xFFFFFFFF 
+        *sensor_id = 0xFFFFFFFF;
+	#ifdef SLT_DEVINFO_CMM_SP2508 
+		s_DEVINFO_ccm->device_used = DEVINFO_UNUSED;
+		devinfo_check_add_device(s_DEVINFO_ccm);
+	#endif
+        return ERROR_SENSOR_CONNECT_FAIL;
+    }
+    return ERROR_NONE;
+}
+
+
+/*************************************************************************
+* FUNCTION
+*    open
+*
+* DESCRIPTION
+*    This function initialize the registers of CMOS sensor
+*
+* PARAMETERS
+*    None
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 open(void)
+{
+	kal_uint8 i = 0;
+	 kal_uint8 retry = 2;
+	 kal_uint32 sensor_id = 0; 
+	 LOG_1;  
+	 LOG_2;
+	
+	 //sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
+	 while (imgsensor_info.i2c_addr_table[i] != 0xff) {
+		 spin_lock(&imgsensor_drv_lock);
+		 imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
+		 spin_unlock(&imgsensor_drv_lock);
+		 do {
+			 sensor_id = return_sensor_id();
+			 if (sensor_id == imgsensor_info.sensor_id) {				 
+				 LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);   
+				 break;
+			 }	 
+			 LOG_INF("Read sensor id fail, id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
+			 retry--;
+		 } while(retry > 0);
+		 i++;
+		 if (sensor_id == imgsensor_info.sensor_id)
+			 break;
+		 retry = 2;
+	 }		  
+	 if (imgsensor_info.sensor_id != sensor_id)
+		 return ERROR_SENSOR_CONNECT_FAIL;
+	 
+	 /* initail sequence write in  */
+#ifdef DEBUG_SENSOR_SP2508
+	if(read_from_extern_flash(SP2508_SD_FILE_PATH)) {
+		SP_LOG("________________from t!\n");
+		SP2508_Initialize_from_T_Flash(SP2508_SD_FILE_PATH);
+	} else {
+		preview_setting();
+		sensor_init();	
+    } 
+#else  
+	/* initail sequence write in  */
+	sensor_init();
+#endif
+	
+	 spin_lock(&imgsensor_drv_lock);
+	
+	 imgsensor.autoflicker_en= KAL_FALSE;
+	 imgsensor.sensor_mode = IMGSENSOR_MODE_INIT;
+	 imgsensor.pclk = imgsensor_info.pre.pclk;
+	 imgsensor.frame_length = imgsensor_info.pre.framelength;
+	 imgsensor.line_length = imgsensor_info.pre.linelength;
+	 imgsensor.min_frame_length = imgsensor_info.pre.framelength;
+	 imgsensor.dummy_pixel = 0;
+	 imgsensor.dummy_line = 0;
+	 imgsensor.ihdr_en = KAL_FALSE;
+	 imgsensor.test_pattern = KAL_FALSE;
+	 imgsensor.current_fps = imgsensor_info.pre.max_framerate;
+	 spin_unlock(&imgsensor_drv_lock);
+	
+	 return ERROR_NONE;
+
+}    /*    open  */
+
+
+
+/*************************************************************************
+* FUNCTION
+*    close
+*
+* DESCRIPTION
+*
+*
+* PARAMETERS
+*    None
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 close(void)
+{
+    LOG_INF("E\n");
+
+    /*No Need to implement this function*/
+
+    return ERROR_NONE;
+}    /*    close  */
+
+
+/*************************************************************************
+* FUNCTION
+* preview
+*
+* DESCRIPTION
+*    This function start the sensor preview.
+*
+* PARAMETERS
+*    *image_window : address pointer of pixel numbers in one period of HSYNC
+*  *sensor_config_data : address pointer of line numbers in one period of VSYNC
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_PREVIEW;
+    imgsensor.pclk = imgsensor_info.pre.pclk;
+    imgsensor.line_length = imgsensor_info.pre.linelength;
+    imgsensor.frame_length = imgsensor_info.pre.framelength;
+    imgsensor.min_frame_length = imgsensor_info.pre.framelength;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+#ifndef DEBUG_SENSOR_SP2508
+    preview_setting();
+#endif
+
+    return ERROR_NONE;
+}    /*    preview   */
+
+/*************************************************************************
+* FUNCTION
+*    capture
+*
+* DESCRIPTION
+*    This function setup the CMOS sensor in capture MY_OUTPUT mode
+*
+* PARAMETERS
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                          MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_CAPTURE;
+    if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {//PIP capture: 24fps for less than 13M, 20fps for 16M,15fps for 20M
+        imgsensor.pclk = imgsensor_info.cap1.pclk;
+        imgsensor.line_length = imgsensor_info.cap1.linelength;
+        imgsensor.frame_length = imgsensor_info.cap1.framelength;
+        imgsensor.min_frame_length = imgsensor_info.cap1.framelength;
+        imgsensor.autoflicker_en = KAL_FALSE;
+    } else {
+        if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
+            LOG_INF("Warning: current_fps %d fps is not support, so use cap's setting: %d fps!\n",imgsensor.current_fps,imgsensor_info.cap.max_framerate/10);
+        imgsensor.pclk = imgsensor_info.cap.pclk;
+        imgsensor.line_length = imgsensor_info.cap.linelength;
+        imgsensor.frame_length = imgsensor_info.cap.framelength;
+        imgsensor.min_frame_length = imgsensor_info.cap.framelength;
+        imgsensor.autoflicker_en = KAL_FALSE;
+    }
+    spin_unlock(&imgsensor_drv_lock);
+#ifndef DEBUG_SENSOR_SP2508
+    capture_setting(imgsensor.current_fps);
+#endif
+
+    return ERROR_NONE;
+}    /* capture() */
+static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_VIDEO;
+    imgsensor.pclk = imgsensor_info.normal_video.pclk;
+    imgsensor.line_length = imgsensor_info.normal_video.linelength;
+    imgsensor.frame_length = imgsensor_info.normal_video.framelength;
+    imgsensor.min_frame_length = imgsensor_info.normal_video.framelength;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+#ifndef DEBUG_SENSOR_SP2508
+    normal_video_setting(imgsensor.current_fps);
+#endif
+
+    return ERROR_NONE;
+}    /*    normal_video   */
+
+static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_HIGH_SPEED_VIDEO;
+    imgsensor.pclk = imgsensor_info.hs_video.pclk;
+    imgsensor.line_length = imgsensor_info.hs_video.linelength;
+    imgsensor.frame_length = imgsensor_info.hs_video.framelength;
+    imgsensor.min_frame_length = imgsensor_info.hs_video.framelength;
+    imgsensor.dummy_line = 0;
+    imgsensor.dummy_pixel = 0;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+#ifndef DEBUG_SENSOR_SP2508
+    hs_video_setting();
+#endif
+
+    return ERROR_NONE;
+}    /*    hs_video   */
+
+static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_SLIM_VIDEO;
+    imgsensor.pclk = imgsensor_info.slim_video.pclk;
+    imgsensor.line_length = imgsensor_info.slim_video.linelength;
+    imgsensor.frame_length = imgsensor_info.slim_video.framelength;
+    imgsensor.min_frame_length = imgsensor_info.slim_video.framelength;
+    imgsensor.dummy_line = 0;
+    imgsensor.dummy_pixel = 0;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+#ifndef DEBUG_SENSOR_SP2508
+    slim_video_setting();
+#endif
+
+    return ERROR_NONE;
+}    /*    slim_video     */
+
+
+
+static kal_uint32 get_resolution(MSDK_SENSOR_RESOLUTION_INFO_STRUCT *sensor_resolution)
+{
+    LOG_INF("E\n");
+    sensor_resolution->SensorFullWidth = imgsensor_info.cap.grabwindow_width;
+    sensor_resolution->SensorFullHeight = imgsensor_info.cap.grabwindow_height;
+
+    sensor_resolution->SensorPreviewWidth = imgsensor_info.pre.grabwindow_width;
+    sensor_resolution->SensorPreviewHeight = imgsensor_info.pre.grabwindow_height;
+
+    sensor_resolution->SensorVideoWidth = imgsensor_info.normal_video.grabwindow_width;
+    sensor_resolution->SensorVideoHeight = imgsensor_info.normal_video.grabwindow_height;
+
+
+    sensor_resolution->SensorHighSpeedVideoWidth     = imgsensor_info.hs_video.grabwindow_width;
+    sensor_resolution->SensorHighSpeedVideoHeight     = imgsensor_info.hs_video.grabwindow_height;
+
+    sensor_resolution->SensorSlimVideoWidth     = imgsensor_info.slim_video.grabwindow_width;
+    sensor_resolution->SensorSlimVideoHeight     = imgsensor_info.slim_video.grabwindow_height;
+    return ERROR_NONE;
+}    /*    get_resolution    */
+
+static kal_uint32 get_info(MSDK_SCENARIO_ID_ENUM scenario_id,
+                      MSDK_SENSOR_INFO_STRUCT *sensor_info,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("scenario_id = %d\n", scenario_id);
+
+
+#ifdef DEBUG_SENSOR_SP2508
+	if(read_from_extern_flash(SP2508_OTHER_DEBUG_PATH)) {
+		SP_LOG("sp_zze: other debug!\n");
+		SP2508_other_debug(SP2508_OTHER_DEBUG_PATH);
+	}
+#endif
+
+    sensor_info->SensorClockPolarity = SENSOR_CLOCK_POLARITY_LOW;
+    sensor_info->SensorClockFallingPolarity = SENSOR_CLOCK_POLARITY_LOW; /* not use */
+    sensor_info->SensorHsyncPolarity = SENSOR_CLOCK_POLARITY_LOW; // inverse with datasheet
+    sensor_info->SensorVsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
+    sensor_info->SensorInterruptDelayLines = 4; /* not use */
+    sensor_info->SensorResetActiveHigh = FALSE; /* not use */
+    sensor_info->SensorResetDelayCount = 5; /* not use */
+
+    sensor_info->SensroInterfaceType = imgsensor_info.sensor_interface_type;
+    sensor_info->MIPIsensorType = imgsensor_info.mipi_sensor_type;
+    sensor_info->SettleDelayMode = imgsensor_info.mipi_settle_delay_mode;
+    sensor_info->SensorOutputDataFormat = imgsensor_info.sensor_output_dataformat;
+
+    sensor_info->CaptureDelayFrame = imgsensor_info.cap_delay_frame;
+    sensor_info->PreviewDelayFrame = imgsensor_info.pre_delay_frame;
+    sensor_info->VideoDelayFrame = imgsensor_info.video_delay_frame;
+    sensor_info->HighSpeedVideoDelayFrame = imgsensor_info.hs_video_delay_frame;
+    sensor_info->SlimVideoDelayFrame = imgsensor_info.slim_video_delay_frame;
+
+    sensor_info->SensorMasterClockSwitch = 0; /* not use */
+    sensor_info->SensorDrivingCurrent = imgsensor_info.isp_driving_current;
+
+    sensor_info->AEShutDelayFrame = imgsensor_info.ae_shut_delay_frame;          /* The frame of setting shutter default 0 for TG int */
+    sensor_info->AESensorGainDelayFrame = imgsensor_info.ae_sensor_gain_delay_frame;    /* The frame of setting sensor gain */
+    sensor_info->AEISPGainDelayFrame = imgsensor_info.ae_ispGain_delay_frame;
+    sensor_info->IHDR_Support = imgsensor_info.ihdr_support;
+    sensor_info->IHDR_LE_FirstLine = imgsensor_info.ihdr_le_firstline;
+    sensor_info->SensorModeNum = imgsensor_info.sensor_mode_num;
+
+    sensor_info->SensorMIPILaneNumber = imgsensor_info.mipi_lane_num;
+    sensor_info->SensorClockFreq = imgsensor_info.mclk;
+    sensor_info->SensorClockDividCount = 3; /* not use */
+    sensor_info->SensorClockRisingCount = 0;
+    sensor_info->SensorClockFallingCount = 2; /* not use */
+    sensor_info->SensorPixelClockCount = 3; /* not use */
+    sensor_info->SensorDataLatchCount = 2; /* not use */
+
+    sensor_info->MIPIDataLowPwr2HighSpeedTermDelayCount = 0;
+    sensor_info->MIPICLKLowPwr2HighSpeedTermDelayCount = 0;
+    sensor_info->SensorWidthSampling = 0;  // 0 is default 1x
+    sensor_info->SensorHightSampling = 0;    // 0 is default 1x
+    sensor_info->SensorPacketECCOrder = 1;
+
+    switch (scenario_id) {
+        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+            sensor_info->SensorGrabStartX = imgsensor_info.pre.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
+
+            break;
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+            sensor_info->SensorGrabStartX = imgsensor_info.cap.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.cap.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.cap.mipi_data_lp2hs_settle_dc;
+
+            break;
+        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+
+            sensor_info->SensorGrabStartX = imgsensor_info.normal_video.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.normal_video.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.normal_video.mipi_data_lp2hs_settle_dc;
+
+            break;
+        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+            sensor_info->SensorGrabStartX = imgsensor_info.hs_video.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.hs_video.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.hs_video.mipi_data_lp2hs_settle_dc;
+
+            break;
+        case MSDK_SCENARIO_ID_SLIM_VIDEO:
+            sensor_info->SensorGrabStartX = imgsensor_info.slim_video.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.slim_video.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.slim_video.mipi_data_lp2hs_settle_dc;
+
+            break;
+        default:
+            sensor_info->SensorGrabStartX = imgsensor_info.pre.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
+            break;
+    }
+	
+	//SP_LOG("sp_zze: sensor_info->AEShutDelayFrame = %d\n", sensor_info->AEShutDelayFrame);
+	//SP_LOG("sp_zze: sensor_info->AESensorGainDelayFrame = %d\n", sensor_info->AESensorGainDelayFrame);
+	//SP_LOG("sp_zze: sensor_info->AEISPGainDelayFrame = %d\n", sensor_info->AEISPGainDelayFrame);
+
+    return ERROR_NONE;
+}    /*    get_info  */
+
+
+static kal_uint32 control(MSDK_SCENARIO_ID_ENUM scenario_id, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+    LOG_INF("scenario_id = %d\n", scenario_id);
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.current_scenario_id = scenario_id;
+    spin_unlock(&imgsensor_drv_lock);
+    switch (scenario_id) {
+        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+            preview(image_window, sensor_config_data);
+            break;
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+            capture(image_window, sensor_config_data);
+            break;
+        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+            normal_video(image_window, sensor_config_data);
+            break;
+        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+            hs_video(image_window, sensor_config_data);
+            break;
+        case MSDK_SCENARIO_ID_SLIM_VIDEO:
+            slim_video(image_window, sensor_config_data);
+            break;
+        default:
+            LOG_INF("Error ScenarioId setting");
+            preview(image_window, sensor_config_data);
+            return ERROR_INVALID_SCENARIO_ID;
+    }
+    return ERROR_NONE;
+}    /* control() */
+
+
+
+static kal_uint32 set_video_mode(UINT16 framerate)
+{//This Function not used after ROME
+    LOG_INF("framerate = %d\n ", framerate);
+    // SetVideoMode Function should fix framerate
+    if (framerate == 0)
+        // Dynamic frame rate
+        return ERROR_NONE;
+    spin_lock(&imgsensor_drv_lock);
+    if ((framerate == 300) && (imgsensor.autoflicker_en == KAL_TRUE))
+        imgsensor.current_fps = 296;
+    else if ((framerate == 150) && (imgsensor.autoflicker_en == KAL_TRUE))
+        imgsensor.current_fps = 146;
+    else
+        imgsensor.current_fps = framerate;
+    spin_unlock(&imgsensor_drv_lock);
+    set_max_framerate(imgsensor.current_fps,1);
+
+    return ERROR_NONE;
+}
+
+static kal_uint32 set_auto_flicker_mode(kal_bool enable, UINT16 framerate)
+{
+    LOG_INF("enable = %d, framerate = %d \n", enable, framerate);
+    spin_lock(&imgsensor_drv_lock);
+    if (enable) //enable auto flicker
+        imgsensor.autoflicker_en = KAL_TRUE;
+    else //Cancel Auto flick
+        imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    return ERROR_NONE;
+}
+
+
+static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 framerate)
+{
+    kal_uint32 frame_length;
+
+    LOG_INF("scenario_id = %d, framerate = %d\n", scenario_id, framerate);
+
+    switch (scenario_id) {
+        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+            frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            break;
+        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+            if(framerate == 0)
+                return ERROR_NONE;
+            frame_length = imgsensor_info.normal_video.pclk / framerate * 10 / imgsensor_info.normal_video.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.normal_video.framelength) ? (frame_length - imgsensor_info.normal_video.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.normal_video.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            break;
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+        	  if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {
+                frame_length = imgsensor_info.cap1.pclk / framerate * 10 / imgsensor_info.cap1.linelength;
+                spin_lock(&imgsensor_drv_lock);
+		            imgsensor.dummy_line = (frame_length > imgsensor_info.cap1.framelength) ? (frame_length - imgsensor_info.cap1.framelength) : 0;
+		            imgsensor.frame_length = imgsensor_info.cap1.framelength + imgsensor.dummy_line;
+		            imgsensor.min_frame_length = imgsensor.frame_length;
+		            spin_unlock(&imgsensor_drv_lock);
+            } else {
+        		    if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
+                    LOG_INF("Warning: current_fps %d fps is not support, so use cap's setting: %d fps!\n",framerate,imgsensor_info.cap.max_framerate/10);
+                frame_length = imgsensor_info.cap.pclk / framerate * 10 / imgsensor_info.cap.linelength;
+                spin_lock(&imgsensor_drv_lock);
+		            imgsensor.dummy_line = (frame_length > imgsensor_info.cap.framelength) ? (frame_length - imgsensor_info.cap.framelength) : 0;
+		            imgsensor.frame_length = imgsensor_info.cap.framelength + imgsensor.dummy_line;
+		            imgsensor.min_frame_length = imgsensor.frame_length;
+		            spin_unlock(&imgsensor_drv_lock);
+            }
+            break;
+        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+            frame_length = imgsensor_info.hs_video.pclk / framerate * 10 / imgsensor_info.hs_video.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.hs_video.framelength) ? (frame_length - imgsensor_info.hs_video.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.hs_video.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            break;
+        case MSDK_SCENARIO_ID_SLIM_VIDEO:
+            frame_length = imgsensor_info.slim_video.pclk / framerate * 10 / imgsensor_info.slim_video.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.slim_video.framelength) ? (frame_length - imgsensor_info.slim_video.framelength): 0;
+            imgsensor.frame_length = imgsensor_info.slim_video.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            break;
+        default:  //coding with  preview scenario by default
+            frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            LOG_INF("error scenario_id = %d, we use preview scenario \n", scenario_id);
+            break;
+    }
+    return ERROR_NONE;
+}
+
+
+static kal_uint32 get_default_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 *framerate)
+{
+    LOG_INF("scenario_id = %d\n", scenario_id);
+
+    switch (scenario_id) {
+        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+            *framerate = imgsensor_info.pre.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+            *framerate = imgsensor_info.normal_video.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+            *framerate = imgsensor_info.cap.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+            *framerate = imgsensor_info.hs_video.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_SLIM_VIDEO:
+            *framerate = imgsensor_info.slim_video.max_framerate;
+            break;
+        default:
+            break;
+    }
+
+    return ERROR_NONE;
+}
+
+
+
+static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
+                             UINT8 *feature_para,UINT32 *feature_para_len)
+{
+    UINT16 *feature_return_para_16=(UINT16 *) feature_para;
+    UINT16 *feature_data_16=(UINT16 *) feature_para;
+    UINT32 *feature_return_para_32=(UINT32 *) feature_para;
+    UINT32 *feature_data_32=(UINT32 *) feature_para;
+    unsigned long long *feature_data=(unsigned long long *) feature_para;
+    unsigned long long *feature_return_para=(unsigned long long *) feature_para;
+
+    SENSOR_WINSIZE_INFO_STRUCT *wininfo;
+    MSDK_SENSOR_REG_INFO_STRUCT *sensor_reg_data=(MSDK_SENSOR_REG_INFO_STRUCT *) feature_para;
+
+    LOG_INF("feature_id = %d\n", feature_id);
+    switch (feature_id) {
+        case SENSOR_FEATURE_GET_PERIOD:
+            *feature_return_para_16++ = imgsensor.line_length;
+            *feature_return_para_16 = imgsensor.frame_length;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:
+            *feature_return_para_32 = imgsensor.pclk;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_SET_ESHUTTER:
+            set_shutter(*feature_data);
+            break;
+        case SENSOR_FEATURE_SET_NIGHTMODE:
+            night_mode((BOOL) *feature_data);
+            break;
+        case SENSOR_FEATURE_SET_GAIN:
+            set_gain((UINT16) *feature_data);
+            break;
+        case SENSOR_FEATURE_SET_FLASHLIGHT:
+            break;
+        case SENSOR_FEATURE_SET_ISP_MASTER_CLOCK_FREQ:
+            break;
+        case SENSOR_FEATURE_SET_REGISTER:
+            write_cmos_sensor(sensor_reg_data->RegAddr, sensor_reg_data->RegData);
+            break;
+        case SENSOR_FEATURE_GET_REGISTER:
+            sensor_reg_data->RegData = read_cmos_sensor(sensor_reg_data->RegAddr);
+            break;
+        case SENSOR_FEATURE_GET_LENS_DRIVER_ID:
+            // get the lens driver ID from EEPROM or just return LENS_DRIVER_ID_DO_NOT_CARE
+            // if EEPROM does not exist in camera module.
+            *feature_return_para_32=LENS_DRIVER_ID_DO_NOT_CARE;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_SET_VIDEO_MODE:
+            set_video_mode(*feature_data);
+            break;
+        case SENSOR_FEATURE_CHECK_SENSOR_ID:
+            get_imgsensor_id(feature_return_para_32);
+            break;
+        case SENSOR_FEATURE_SET_AUTO_FLICKER_MODE:
+            set_auto_flicker_mode((BOOL)*feature_data_16,*(feature_data_16+1));
+            break;
+        case SENSOR_FEATURE_SET_MAX_FRAME_RATE_BY_SCENARIO:
+            set_max_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data, *(feature_data+1));
+            break;
+        case SENSOR_FEATURE_GET_DEFAULT_FRAME_RATE_BY_SCENARIO:
+            get_default_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*(feature_data), (MUINT32 *)(uintptr_t)(*(feature_data+1)));
+            break;
+        case SENSOR_FEATURE_SET_TEST_PATTERN:
+            set_test_pattern_mode((BOOL)*feature_data);
+            break;
+        case SENSOR_FEATURE_GET_TEST_PATTERN_CHECKSUM_VALUE: //for factory mode auto testing
+            *feature_return_para_32 = imgsensor_info.checksum_value;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_SET_FRAMERATE:
+            LOG_INF("current fps :%d\n", (UINT32)*feature_data);
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.current_fps = *feature_data;
+            spin_unlock(&imgsensor_drv_lock);
+            break;
+        case SENSOR_FEATURE_SET_HDR:
+            LOG_INF("ihdr enable :%d\n", (BOOL)*feature_data);
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.ihdr_en = (BOOL)*feature_data;
+            spin_unlock(&imgsensor_drv_lock);
+            break;
+        case SENSOR_FEATURE_GET_CROP_INFO:
+            LOG_INF("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n", (UINT32)*feature_data);
+
+            wininfo = (SENSOR_WINSIZE_INFO_STRUCT *)(uintptr_t)(*(feature_data+1));
+
+            switch (*feature_data_32) {
+                case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[1],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[2],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[3],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_SLIM_VIDEO:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[4],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+                default:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[0],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+            }
+        case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
+            LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",(UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
+            ihdr_write_shutter_gain((UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
+            break;
+        default:
+            break;
+    }
+
+    return ERROR_NONE;
+}    /*    feature_control()  */
+
+static SENSOR_FUNCTION_STRUCT sensor_func = {
+    open,
+    get_info,
+    get_resolution,
+    feature_control,
+    control,
+    close
+};
+
+UINT32 SP2508_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
+{
+    /* To Do : Check Sensor status here */
+    if (pfFunc!=NULL)
+        *pfFunc=&sensor_func;
+    return ERROR_NONE;
+}    /*    SP2508_MIPI_RAW_SensorInit    */
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/sp2508_mipi_raw/sp2508mipiraw_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/sp2508_mipi_raw/sp2508mipiraw_Sensor.h
new file mode 100644
index 0000000..a9ce1cb
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/sp2508_mipi_raw/sp2508mipiraw_Sensor.h
@@ -0,0 +1,144 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *   IMX135mipi_Sensor.h
+ *
+ * Project:
+ * --------
+ *   ALPS
+ *
+ * Description:
+ * ------------
+ *   CMOS sensor header file
+ *
+ ****************************************************************************/
+#ifndef _SP2508mipi_SENSOR_H
+#define _SP2508mipi_SENSOR_H
+
+
+typedef enum{
+    IMGSENSOR_MODE_INIT,
+    IMGSENSOR_MODE_PREVIEW,
+    IMGSENSOR_MODE_CAPTURE,
+    IMGSENSOR_MODE_VIDEO,
+    IMGSENSOR_MODE_HIGH_SPEED_VIDEO,
+    IMGSENSOR_MODE_SLIM_VIDEO,
+} IMGSENSOR_MODE;
+
+typedef struct imgsensor_mode_struct {
+    kal_uint32 pclk;                //record different mode's pclk
+    kal_uint32 linelength;          //record different mode's linelength
+    kal_uint32 framelength;         //record different mode's framelength
+
+    kal_uint8 startx;               //record different mode's startx of grabwindow
+    kal_uint8 starty;               //record different mode's startx of grabwindow
+
+    kal_uint16 grabwindow_width;    //record different mode's width of grabwindow
+    kal_uint16 grabwindow_height;   //record different mode's height of grabwindow
+
+    /*   following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario   */
+    kal_uint8 mipi_data_lp2hs_settle_dc;
+
+    /*   following for GetDefaultFramerateByScenario()  */
+    kal_uint16 max_framerate;
+    
+} imgsensor_mode_struct;
+
+/* SENSOR PRIVATE STRUCT FOR VARIABLES*/
+typedef struct imgsensor_struct {
+    kal_uint8 mirror;               //mirrorflip information
+
+    kal_uint8 sensor_mode;          //record IMGSENSOR_MODE enum value
+
+    kal_uint32 shutter;             //current shutter
+    kal_uint16 gain;                //current gain
+    
+    kal_uint32 pclk;                //current pclk
+
+    kal_uint32 frame_length;        //current framelength
+    kal_uint32 line_length;         //current linelength
+
+    kal_uint32 min_frame_length;    //current min  framelength to max framerate
+    kal_uint16 dummy_pixel;         //current dummypixel
+    kal_uint16 dummy_line;          //current dummline
+    
+    kal_uint16 current_fps;         //current max fps
+    kal_bool   autoflicker_en;      //record autoflicker enable or disable
+    kal_bool test_pattern;          //record test pattern mode or not
+    MSDK_SCENARIO_ID_ENUM current_scenario_id;//current scenario id
+    kal_uint8  ihdr_en;                //ihdr enable or disable
+
+    kal_uint8 i2c_write_id;            //record current sensor's i2c write id
+} imgsensor_struct;
+
+/* SENSOR PRIVATE STRUCT FOR CONSTANT*/
+typedef struct imgsensor_info_struct { 
+    kal_uint32 sensor_id;           //record sensor id defined in Kd_imgsensor.h
+    kal_uint32 checksum_value;      //checksum value for Camera Auto Test
+    imgsensor_mode_struct pre;      //preview scenario relative information
+    imgsensor_mode_struct cap;      //capture scenario relative information
+    imgsensor_mode_struct cap1;     //capture for PIP 24fps relative information
+    imgsensor_mode_struct normal_video;//normal video  scenario relative information
+    imgsensor_mode_struct hs_video;    //high speed video scenario relative information
+    imgsensor_mode_struct slim_video;    //slim video for VT scenario relative information
+
+    kal_uint8  ae_shut_delay_frame;    //shutter delay frame for AE cycle
+    kal_uint8  ae_sensor_gain_delay_frame;    //sensor gain delay frame for AE cycle
+    kal_uint8  ae_ispGain_delay_frame;    //isp gain delay frame for AE cycle
+    kal_uint8  ihdr_support;        //1, support; 0,not support
+    kal_uint8  ihdr_le_firstline;   //1,le first ; 0, se first
+    kal_uint8  sensor_mode_num;     //support sensor mode num
+    
+    kal_uint8  cap_delay_frame;     //enter capture delay frame num
+    kal_uint8  pre_delay_frame;     //enter preview delay frame num
+    kal_uint8  video_delay_frame;   //enter video delay frame num
+    kal_uint8  hs_video_delay_frame;    //enter high speed video  delay frame num
+    kal_uint8  slim_video_delay_frame;    //enter slim video delay frame num
+
+    kal_uint8  margin;                //sensor framelength & shutter margin
+    kal_uint32 min_shutter;            //min shutter
+    kal_uint32 max_frame_length;    //max framelength by sensor register's limitation
+
+    kal_uint8  isp_driving_current; //mclk driving current
+    kal_uint8  sensor_interface_type;//sensor_interface_type
+    kal_uint8  mipi_sensor_type; //0,MIPI_OPHY_NCSI2; 1,MIPI_OPHY_CSI2, default is NCSI2, don't modify this para
+    kal_uint8  mipi_settle_delay_mode; //0, high speed signal auto detect; 1, use settle delay,unit is ns, default is auto detect, don't modify this para
+    kal_uint8  sensor_output_dataformat;
+    kal_uint8  mclk;                //mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
+
+    kal_uint8  mipi_lane_num;        //mipi lane num
+    kal_uint8  i2c_addr_table[5];    //record sensor support all write id addr, only supprt 4must end with 0xff
+} imgsensor_info_struct;
+
+/* SENSOR READ/WRITE ID */
+//#define IMGSENSOR_WRITE_ID_1 (0x6c)
+//#define IMGSENSOR_READ_ID_1  (0x6d)
+//#define IMGSENSOR_WRITE_ID_2 (0x20)
+//#define IMGSENSOR_READ_ID_2  (0x21)
+
+#define SP2508_VALID_IXEL_NUMS            800
+#define SP2508_VALID_LINE_NUMS            1200
+#define SP2508_DEFAULT_DUMMY_PIXEL_NUMS   0x11c //244 
+#define SP2508_DEFAULT_DUMMY_LINE_NUMS    0x0e //64
+
+#define SP2508_INTERNAL_DUMMY_PIXEL_NUMS  36
+#define SP2508_INTERNAL_DUMMY_LINE_NUMS   32
+
+#define SP2508_VIDEO_PERIOD_PIXEL_NUMS          (1120)
+#define SP2508_VIDEO_PERIOD_LINE_NUMS           (1246)
+#define SP2508_PV_PERIOD_PIXEL_NUMS            (1120)
+#define SP2508_PV_PERIOD_LINE_NUMS             (1246)
+
+#define SP2508_FULL_PERIOD_PIXEL_NUMS          (1120)
+#define SP2508_FULL_PERIOD_LINE_NUMS           (1246)
+
+
+// end
+
+extern int iReadRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u8 * a_pRecvData, u16 a_sizeRecvData, u16 i2cId);
+extern int iWriteRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u16 i2cId);
+extern int iWriteReg(u16 a_u2Addr , u32 a_u4Data , u32 a_u4Bytes , u16 i2cId); 
+
+
+#endif 
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/sp5409_mipi_raw/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6735m/sp5409_mipi_raw/Makefile
index ebde8bc..6978efd 100755
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/sp5409_mipi_raw/Makefile
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/sp5409_mipi_raw/Makefile
@@ -1,4 +1,4 @@
 include $(srctree)/drivers/misc/mediatek/Makefile.custom
-obj-y += sp5409mipi_Sensor.o
 
+obj-y += sp5409mipi_Sensor.o
 
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/sp5409_mipi_raw/sp5409mipi_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/sp5409_mipi_raw/sp5409mipi_Sensor.c
old mode 100644
new mode 100755
index 646a70c..ada886a
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/sp5409_mipi_raw/sp5409mipi_Sensor.c
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/sp5409_mipi_raw/sp5409mipi_Sensor.c
@@ -2,7 +2,7 @@
  *
  * Filename:
  * ---------
- *     sp5409mipi_Sensor.c
+ *     SP5409mipi_Sensor.c
  *
  * Project:
  * --------
@@ -35,7 +35,6 @@
 #include "kd_imgsensor_errcode.h"
 
 #include "sp5409mipi_Sensor.h"
-
 /****************************Modify Following Strings for Debug****************************/
 #define PFX "SP5409_camera_sensor"
 #define LOG_1 LOG_INF("SP5409,MIPI 2LANE\n")
@@ -48,18 +47,18 @@ static DEFINE_SPINLOCK(imgsensor_drv_lock);
 
 
 static imgsensor_info_struct imgsensor_info = {
-    .sensor_id = SP5409MIPI_SENSOR_ID,
-    
+    .sensor_id = 0x5409, //SP5409MIPI_SENSOR_ID,
+
     .checksum_value = 0xf7375923,        //checksum value for Camera Auto Test
-    
+
     .pre = {
         .pclk = 42000000,              //record different mode's pclk
         .linelength = 1772,             //record different mode's linelength
         .framelength = 1970,            //record different mode's framelength
         .startx = 2,                    //record different mode's startx of grabwindow
         .starty = 2,                    //record different mode's starty of grabwindow
-        .grabwindow_width = 2592,//2096,		//record different mode's width of grabwindow
-        .grabwindow_height = 1944,//1552,		//record different mode's height of grabwindow
+        .grabwindow_width = 2592,        //record different mode's width of grabwindow
+        .grabwindow_height = 1944,        //record different mode's height of grabwindow
         /*     following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario    */
         .mipi_data_lp2hs_settle_dc = 85,//unit , ns
         /*     following for GetDefaultFramerateByScenario()    */
@@ -71,8 +70,8 @@ static imgsensor_info_struct imgsensor_info = {
         .framelength = 1970,
         .startx = 4,
         .starty = 4,
-        .grabwindow_width = 2592,//4192,
-        .grabwindow_height = 1944,//3104,
+        .grabwindow_width = 2592,
+        .grabwindow_height = 1944,
         .mipi_data_lp2hs_settle_dc = 85,//unit , ns
         .max_framerate = 300,
     },
@@ -82,8 +81,8 @@ static imgsensor_info_struct imgsensor_info = {
         .framelength = 1970,
         .startx = 2,
         .starty = 2,
-        .grabwindow_width = 2592,//4192,
-        .grabwindow_height = 1944,//3104,
+        .grabwindow_width = 2592,
+        .grabwindow_height = 1944,
         .mipi_data_lp2hs_settle_dc = 85,//unit , ns
         .max_framerate = 300,
     },
@@ -93,8 +92,8 @@ static imgsensor_info_struct imgsensor_info = {
         .framelength = 1970,
         .startx = 2,
         .starty = 2,
-        .grabwindow_width = 2592,//4192,
-        .grabwindow_height = 1944,//3104,
+        .grabwindow_width = 2592,
+        .grabwindow_height = 1944,
         .mipi_data_lp2hs_settle_dc = 85,//unit , ns
         .max_framerate = 300,
     },
@@ -120,22 +119,22 @@ static imgsensor_info_struct imgsensor_info = {
         .mipi_data_lp2hs_settle_dc = 85,//unit , ns
         .max_framerate = 300,
     },
-    .margin = 0,
+    .margin = 0,            //sensor framelength & shutter margin
     .min_shutter = 1,        //min shutter
     .max_frame_length = 0x7fff,//max framelength by sensor register's limitation
     .ae_shut_delay_frame = 0,    //shutter delay frame for AE cycle, 2 frame with ispGain_delay-shut_delay=2-0=2
     .ae_sensor_gain_delay_frame = 0,//sensor gain delay frame for AE cycle,2 frame with ispGain_delay-sensor_gain_delay=2-0=2
     .ae_ispGain_delay_frame = 2,//isp gain delay frame for AE cycle
-    .ihdr_support = 0, //     //1, support; 0,not support
-    .ihdr_le_firstline = 0,//  //1,le first ; 0, se first
+    .ihdr_support = 0,      //1, support; 0,not support
+    .ihdr_le_firstline = 0,  //1,le first ; 0, se first
     .sensor_mode_num = 5,      //support sensor mode num
-    
+
     .cap_delay_frame = 2,
     .pre_delay_frame = 2,
     .video_delay_frame = 2,
     .hs_video_delay_frame = 2,
     .slim_video_delay_frame = 2,
-    
+
     .isp_driving_current = ISP_DRIVING_2MA, //mclk driving current
     .sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,//sensor_interface_type
     .mipi_sensor_type = MIPI_OPHY_NCSI2, //0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2
@@ -143,7 +142,7 @@ static imgsensor_info_struct imgsensor_info = {
     .sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_B,//sensor output first pixel color
     .mclk = 24,//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
     .mipi_lane_num = SENSOR_MIPI_2_LANE,//mipi lane num
-    .i2c_addr_table = {0x78, 0xff},
+    .i2c_addr_table = {0x78, 0x7a,0xff}, //5409H---0x78 /5409---0x7a
     .i2c_speed = 200,
 };
 
@@ -160,52 +159,51 @@ static imgsensor_struct imgsensor = {
     .test_pattern = KAL_FALSE,        //test pattern mode or not. KAL_FALSE for in test pattern mode, KAL_TRUE for normal output
     .current_scenario_id = MSDK_SCENARIO_ID_CAMERA_PREVIEW,//current scenario id
     .ihdr_en = 0, //sensor need support LE, SE with HDR feature
-    .i2c_write_id = 0x78,//record current sensor's i2c write id
+    .i2c_write_id = 0x78,//record current sensor's i2c write id //5409H---0x78 /5409---0x7a
 };
 
 
 /* Sensor output window information */
 static SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[5]=
 {{ 1616, 1216, 1000, 1000, 2592, 1944, 2592, 1944, 0000, 0000, 2592, 1944, 0000, 0000, 2592, 1944}, // Preview 2112*1558
-    { 1616, 1216, 1000, 1000, 2592, 1944, 2592, 1944, 0000, 0000, 2592, 1944, 0000, 0000, 2592, 1944}, // capture 4206*3128
-    { 1616, 1216, 1000, 1000, 2592, 1944, 2592, 1944, 0000, 0000, 2592, 1944, 0000, 0000, 2592, 1944}, // video
-    { 1616, 1216, 1000, 1000, 2592, 1944, 2592, 1944, 0000, 0000, 2592, 1944, 0000, 0000, 1280, 720}, //hight speed video
-    { 1616, 1216, 1000, 1000, 2592, 1944, 2592, 1944, 0000, 0000, 2592, 1944, 0000, 0000, 2592, 1944},// slim video
-}; // slim video
+ { 1616, 1216, 1000, 1000, 2592, 1944, 2592, 1944, 0000, 0000, 2592, 1944, 0000, 0000, 2592, 1944}, // capture 4206*3128
+ { 1616, 1216, 1000, 1000, 2592, 1944, 2592, 1944, 0000, 0000, 2592, 1944, 0000, 0000, 2592, 1944}, // video 
+ { 1616, 1216, 1000, 1000, 2592, 1944, 2592, 1944, 0000, 0000, 2592, 1944, 0000, 0000, 1280, 720}, //hight speed video 
+ { 1616, 1216, 1000, 1000, 2592, 1944, 2592, 1944, 0000, 0000, 2592, 1944, 0000, 0000, 2592, 1944},// slim video
+};
 
 
 static kal_uint16 read_cmos_sensor(kal_uint32 addr)
 {
     kal_uint16 get_byte=0;
-    char pu_send_cmd[1] = {(char)(addr & 0xFF) };
-    
-    kdSetI2CSpeed(imgsensor_info.i2c_speed); // Add this func to set i2c speed by each sensor
-    
+	char pu_send_cmd[1] = { (char)(addr & 0xFF) };
+
+	kdSetI2CSpeed(imgsensor_info.i2c_speed); // Add this func to set i2c speed by each sensor
+
     iReadRegI2C(pu_send_cmd, 1, (u8*)&get_byte, 1, imgsensor.i2c_write_id);
-    
+
     return get_byte;
 }
 
 static void write_cmos_sensor(kal_uint32 addr, kal_uint32 para)
 {
-    char pu_send_cmd[2] = {(char)(addr & 0xFF), (char)(para & 0xFF)};
-    
-    kdSetI2CSpeed(imgsensor_info.i2c_speed); // Add this func to set i2c speed by each sensor
-    
+    char pu_send_cmd[2] = { (char)(addr & 0xFF), (char)(para & 0xFF)};
+
+	kdSetI2CSpeed(imgsensor_info.i2c_speed); // Add this func to set i2c speed by each sensor
+
     iWriteRegI2C(pu_send_cmd, 2, imgsensor.i2c_write_id);
 }
 
 static void set_dummy(void)
 {
-    LOG_INF("dummyline = %d, dummypixels = %d \n", imgsensor.dummy_line, imgsensor.dummy_pixel);
+   // LOG_INF("dummyline = %d, dummypixels = %d \n", imgsensor.dummy_line, imgsensor.dummy_pixel);
     /* you can set dummy by imgsensor.dummy_line and imgsensor.dummy_pixel, or you can set dummy by imgsensor.frame_length and imgsensor.line_length */
 #if 0
-    write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
+    write_cmos_sensor(kal_uint32 addr, kal_uint32 para)(0x380e, imgsensor.frame_length >> 8);
     write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
     write_cmos_sensor(0x380c, imgsensor.line_length >> 8);
     write_cmos_sensor(0x380d, imgsensor.line_length & 0xFF);
 #endif
-    
 }    /*    set_dummy  */
 
 static kal_uint32 return_sensor_id(void)
@@ -216,19 +214,19 @@ static kal_uint32 return_sensor_id(void)
 static void set_max_framerate(UINT16 framerate,kal_bool min_framelength_en)
 {
     kal_uint32 frame_length = imgsensor.frame_length;
-    
-    LOG_INF("framerate = %d, min framelength should enable? \n", framerate,min_framelength_en);
-    
+
+   // LOG_INF("framerate = %d, min framelength should enable? \n", framerate,min_framelength_en);
+
     frame_length = imgsensor.pclk / framerate * 10 / imgsensor.line_length;
-    
+
     spin_lock(&imgsensor_drv_lock);
     imgsensor.frame_length = (frame_length > imgsensor.min_frame_length) ? frame_length : imgsensor.min_frame_length;
     imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
     //dummy_line = frame_length - imgsensor.min_frame_length;
     //if (dummy_line < 0)
-    //imgsensor.dummy_line = 0;
+        //imgsensor.dummy_line = 0;
     //else
-    //imgsensor.dummy_line = dummy_line;
+        //imgsensor.dummy_line = dummy_line;
     //imgsensor.frame_length = frame_length + imgsensor.dummy_line;
     if (imgsensor.frame_length > imgsensor_info.max_frame_length)
     {
@@ -238,7 +236,7 @@ static void set_max_framerate(UINT16 framerate,kal_bool min_framelength_en)
     if (min_framelength_en)
         imgsensor.min_frame_length = imgsensor.frame_length;
     spin_unlock(&imgsensor_drv_lock);
-    
+
     set_dummy();
 }    /*    set_max_framerate  */
 
@@ -246,10 +244,10 @@ static void write_shutter(kal_uint16 shutter)
 {
 #if 0
     kal_uint16 realtime_fps = 0;
-    
+
     /* 0x3500, 0x3501, 0x3502 will increase VBLANK to get exposure larger than frame exposure */
     /* AE doesn't update sensor gain at capture mode, thus extra exposure lines must be updated here. */
-    
+
     // OV Recommend Solution
     // if shutter bigger than frame_length, should extend frame length first
     spin_lock(&imgsensor_drv_lock);
@@ -262,30 +260,36 @@ static void write_shutter(kal_uint16 shutter)
     spin_unlock(&imgsensor_drv_lock);
     shutter = (shutter < imgsensor_info.min_shutter) ? imgsensor_info.min_shutter : shutter;
     shutter = (shutter > (imgsensor_info.max_frame_length - imgsensor_info.margin)) ? (imgsensor_info.max_frame_length - imgsensor_info.margin) : shutter;
-    
+
     // Framelength should be an even number
     shutter = (shutter >> 1) << 1;
     imgsensor.frame_length = (imgsensor.frame_length >> 1) << 1;
-    
+
     if (imgsensor.autoflicker_en) {
         realtime_fps = imgsensor.pclk / imgsensor.line_length * 10 / imgsensor.frame_length;
-        
+
         if(realtime_fps >= 297 && realtime_fps <= 305)
             set_max_framerate(296,0);
         else if(realtime_fps >= 147 && realtime_fps <= 150)
             set_max_framerate(146,0);
         else {
             // Extend frame length
+            write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
+            write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
         }
     } else {
         // Extend frame length
+        write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
+        write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
     }
 #endif
-    write_cmos_sensor(0xfd, 0x01);
-    write_cmos_sensor(0x03, (shutter >> 8) & 0xFF);
-    write_cmos_sensor(0x04, shutter  & 0xFF);
-    write_cmos_sensor(0x01, 0x01);
-    LOG_INF("shutter =%d, framelength =%d\n", shutter, imgsensor.frame_length);
+    // Update Shutter
+	 write_cmos_sensor(0xfd, 0x01);
+	 write_cmos_sensor(0x03, (shutter >> 8) & 0xFF);
+	 write_cmos_sensor(0x04, shutter  & 0xFF);
+	 write_cmos_sensor(0x01, 0x01); 
+
+    //LOG_INF("shutter =%d, framelength =%d\n", shutter, imgsensor.frame_length);
 }
 
 
@@ -308,6 +312,10 @@ static void write_shutter(kal_uint16 shutter)
 static void set_shutter(kal_uint16 shutter)
 {
     unsigned long flags;
+    if (shutter < 7)
+          shutter = 7; 
+	else if(shutter > 0xffff)
+	   shutter = 0xffff;
     spin_lock_irqsave(&imgsensor_drv_lock, flags);
     imgsensor.shutter = shutter;
     spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
@@ -319,10 +327,10 @@ static kal_uint16 gain2reg(const kal_uint16 gain)
 {
 #if 0
     kal_uint16 reg_gain = 0x0000;
-    
+
     reg_gain = ((gain / BASEGAIN) << 4) + ((gain % BASEGAIN) * 16 / BASEGAIN);
     reg_gain = reg_gain & 0xFFFF;
-    
+
     return (kal_uint16)reg_gain;
 #endif
 }
@@ -345,43 +353,37 @@ static kal_uint16 gain2reg(const kal_uint16 gain)
 *************************************************************************/
 static kal_uint16 set_gain(kal_uint16 gain)
 {
-    kal_uint16 reg_gain;
-    
-    /* 0x350A[0:1], 0x350B[0:7] AGC real gain */
-    /* [0:3] = N meams N /16 X    */
-    /* [4:9] = M meams M X         */
-    /* Total gain = M + N /16 X   */
-    
-    //
+    kal_uint16 reg_gain = 0x0000;
+
     if(gain >= BASEGAIN && gain <= 15*BASEGAIN)
-    {
-        reg_gain = 0x10 * gain/BASEGAIN ;        //change mtk gain base to aptina gain base
-        
-        if(reg_gain<=0x10)
-        {
-            write_cmos_sensor(0xfd, 0x01);
-            write_cmos_sensor(0x24, 0x10);//0x23
-            write_cmos_sensor(0x01, 0x01);
-            LOG_INF("SP5409 reg_gain =%d, SP5409MIPI Gain = %d", reg_gain, gain);
-        }
-        else if(reg_gain>= 0x70)
-        {
-            write_cmos_sensor(0xfd, 0x01);
-            write_cmos_sensor(0x24,0x70);
-            write_cmos_sensor(0x01, 0x01);
-            LOG_INF("SP5409MIPI reg_gain =%d, SP5409MIPI Gain = %d",  reg_gain, gain);
-        }
-        else
-        {
-            write_cmos_sensor(0xfd, 0x01);
-            write_cmos_sensor(0x24, (kal_uint8)reg_gain);
-            write_cmos_sensor(0x01, 0x01);
-	       }
-    }
-    else
-        LOG_INF("error gain setting");
-    
-    return gain;
+   	 {   
+   	    	reg_gain = 0x10 * gain/BASEGAIN ;        //change mtk gain base to aptina gain base
+
+   	    	 if(reg_gain<=0x10)
+   	    	 {
+   	    	    	write_cmos_sensor(0xfd, 0x01);
+   	    	    	write_cmos_sensor(0x24, 0x10);//0x23
+   	    	    	write_cmos_sensor(0x01, 0x01);
+ //  	    	    	LOG_INF("SP5409 reg_gain =%d, SP5409MIPI Gain = %d", reg_gain, gain);
+   	    	 }
+   	    	 else if(reg_gain>= 0x70)
+   	    	 {
+   	    	    	 write_cmos_sensor(0xfd, 0x01);
+   	    	    	 write_cmos_sensor(0x24,0x70);
+   	    	    	 write_cmos_sensor(0x01, 0x01);
+  // 	    	    	 LOG_INF("SP5409MIPI reg_gain =%d, SP5409MIPI Gain = %d",  reg_gain, gain);
+	        }        	
+   	    	 else
+   	    	 {
+   	    	    	 write_cmos_sensor(0xfd, 0x01);
+   	    	    	 write_cmos_sensor(0x24, (kal_uint8)reg_gain);
+   	    	    	 write_cmos_sensor(0x01, 0x01);
+	       }	
+   	 }	
+   	 else
+  // 	    	 LOG_INF("error gain setting");
+
+	  return gain;
 }    /*    set_gain  */
 
 static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gain)
@@ -389,6 +391,48 @@ static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gai
     //not support HDR
     //LOG_INF("le:0x%x, se:0x%x, gain:0x%x\n",le,se,gain);
 }
+
+#if 0
+static void set_mirror_flip(kal_uint8 image_mirror)
+{
+  //  LOG_INF("image_mirror = %d\n", image_mirror);
+
+    /********************************************************
+       *
+       *   0x3820[2] ISP Vertical flip
+       *   0x3820[1] Sensor Vertical flip
+       *
+       *   0x3821[2] ISP Horizontal mirror
+       *   0x3821[1] Sensor Horizontal mirror
+       *
+       *   ISP and Sensor flip or mirror register bit should be the same!!
+       *
+       ********************************************************/
+
+    switch (image_mirror) {
+        case IMAGE_NORMAL:
+            write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x00));
+            write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x06));
+            break;
+        case IMAGE_H_MIRROR:
+            write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x00));
+            write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x00));
+            break;
+        case IMAGE_V_MIRROR:
+            write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x06));
+            write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x06));
+            break;
+        case IMAGE_HV_MIRROR:
+            write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x06));
+            write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x00));
+            break;
+        default:
+  //          LOG_INF("Error image_mirror setting\n");
+    }
+
+}
+#endif
+
 /*************************************************************************
 * FUNCTION
 *    night_mode
@@ -411,166 +455,138 @@ static void night_mode(kal_bool enable)
 }    /*    night_mode    */
 
 static void sensor_init(void)
+    /*    MIPI_sensor_Init  */
 {
-    {
-        LOG_INF("E\n");
-        //@@ global setting
-        //updated by xingdy,20141204
-        //soft reset, 0x51=0x10,0x52=3a;0x53=0x10
-        //hblank=0x110,0x72=0x54,rst_num=0x30
-        //T_horizontal=1079,1base=h'129, 15fps
-        //adc_range reduce to 515mv
-        //shutdown pcp rowsel,pcp clk 24M
-        write_cmos_sensor(0xfd,0x00);
-        write_cmos_sensor(0x1b,0x00);
-        write_cmos_sensor(0x2f,0x10);
-        write_cmos_sensor(0x30,0x15);
-        write_cmos_sensor(0x33,0x05);
-        write_cmos_sensor(0x34,0x00);
-        write_cmos_sensor(0xfd,0x01);//vblank
-        write_cmos_sensor(0x06,0x01);
-        write_cmos_sensor(0x03,0x00);
-        write_cmos_sensor(0x04,0xed);
-        write_cmos_sensor(0x09,0x01);
-        write_cmos_sensor(0x0a,0xb5);
-        write_cmos_sensor(0x24,0x70);
-        write_cmos_sensor(0x01,0x01);
-        write_cmos_sensor(0x20,0x3d);
-        write_cmos_sensor(0x21,0x37);
-        write_cmos_sensor(0x25,0xf4);
-        write_cmos_sensor(0x26,0x0c);
-        write_cmos_sensor(0x2a,0x12);
-        write_cmos_sensor(0x2c,0xa0);
-        write_cmos_sensor(0x8a,0x55);
-        write_cmos_sensor(0x8b,0x55);
-        write_cmos_sensor(0x58,0x3a);
-        write_cmos_sensor(0x75,0x58);
-        write_cmos_sensor(0x77,0x6f);
-        write_cmos_sensor(0x78,0xef);
-        write_cmos_sensor(0x84,0x0f);
-        write_cmos_sensor(0x85,0x02);
-        write_cmos_sensor(0xd0,0x01);
-        write_cmos_sensor(0xd1,0x02);
-        write_cmos_sensor(0xd2,0x00);
-        write_cmos_sensor(0xd3,0x02);
-        write_cmos_sensor(0xd4,0x80);
-        write_cmos_sensor(0x11,0x40);
-        write_cmos_sensor(0x51,0x15);
-        write_cmos_sensor(0x52,0x3a);
-        write_cmos_sensor(0x53,0x15);
-        write_cmos_sensor(0x5d,0x00);
-        write_cmos_sensor(0x5e,0x00);
-        write_cmos_sensor(0x66,0x5c); //blacklevel enable
-        write_cmos_sensor(0x68,0x62);
-        write_cmos_sensor(0x72,0x74);
-        write_cmos_sensor(0x7b,0x01);
-        write_cmos_sensor(0x7c,0x10);
-        write_cmos_sensor(0xfb,0x35);
-        write_cmos_sensor(0xfa,0x10);
-        write_cmos_sensor(0xfe,0x10);
-        write_cmos_sensor(0x87,0x08);
-        write_cmos_sensor(0x89,0x10);
-        write_cmos_sensor(0xf0,0x00);
-        write_cmos_sensor(0xf1,0x00);
-        write_cmos_sensor(0xf2,0x00);
-        write_cmos_sensor(0xf3,0x00);
-        write_cmos_sensor(0xfd,0x02);//0x25
-        write_cmos_sensor(0x00,0x8c);
-        write_cmos_sensor(0x01,0x8c);
-        write_cmos_sensor(0x02,0x8c);
-        write_cmos_sensor(0x03,0x8c);
-        write_cmos_sensor(0xfd,0x01);
-        write_cmos_sensor(0xb3,0x00);
-        write_cmos_sensor(0xb1,0x01);
-        write_cmos_sensor(0xa4,0x6d);
-        write_cmos_sensor(0xb6,0xc0);  
-        write_cmos_sensor(0x9d,0x65);
-        write_cmos_sensor(0x97,0x08);
-        write_cmos_sensor(0xc4,0x28); 
-        write_cmos_sensor(0xc1,0x09);   
-    }              
-    
-}    /*    MIPI_sensor_Init  */
-
+//	LOG_INF("2015-2-6 superpix init start E\n");
+		write_cmos_sensor(0xfd,0x00);
+		write_cmos_sensor(0x1b,0x00);
+		write_cmos_sensor(0x2f,0x10);
+		write_cmos_sensor(0x30,0x15);
+		write_cmos_sensor(0x33,0x05);
+		write_cmos_sensor(0x34,0x00);
+		write_cmos_sensor(0xfd,0x01);//vblank
+		write_cmos_sensor(0x06,0x01);
+		write_cmos_sensor(0x03,0x00);
+		write_cmos_sensor(0x04,0xed);
+		write_cmos_sensor(0x09,0x01);
+		write_cmos_sensor(0x0a,0xb5);
+		write_cmos_sensor(0x24,0x60);
+		write_cmos_sensor(0x01,0x01);
+		write_cmos_sensor(0x20,0x3d);
+		write_cmos_sensor(0x21,0x37);
+		write_cmos_sensor(0x25,0xf4);
+		write_cmos_sensor(0x26,0x0c);
+		write_cmos_sensor(0x2a,0x12);
+		write_cmos_sensor(0x2c,0xa0);
+		write_cmos_sensor(0x8a,0x55);
+		write_cmos_sensor(0x8b,0x55);
+		write_cmos_sensor(0x58,0x3a);
+		write_cmos_sensor(0x75,0x58);
+		write_cmos_sensor(0x77,0x6f);
+		write_cmos_sensor(0x78,0xef);
+		write_cmos_sensor(0x84,0x0f);
+		write_cmos_sensor(0x85,0x02);
+		write_cmos_sensor(0xd0,0x01);
+		write_cmos_sensor(0xd1,0x02);
+		write_cmos_sensor(0xd2,0x00);
+		write_cmos_sensor(0xd3,0x02);
+		write_cmos_sensor(0xd4,0x80);
+		write_cmos_sensor(0x11,0x40);
+		write_cmos_sensor(0x51,0x15);
+		write_cmos_sensor(0x52,0x3a);
+		write_cmos_sensor(0x53,0x15);
+		write_cmos_sensor(0x5d,0x00);
+		write_cmos_sensor(0x5e,0x00);
+		write_cmos_sensor(0x66,0x5c); //blacklevel enable
+		write_cmos_sensor(0x68,0x62);
+		write_cmos_sensor(0x72,0x74);
+		write_cmos_sensor(0x7b,0x01);
+		write_cmos_sensor(0x7c,0x10);
+		write_cmos_sensor(0xfb,0x35);
+		write_cmos_sensor(0xfa,0x10);
+		write_cmos_sensor(0xfe,0x10);
+		write_cmos_sensor(0x87,0x08);
+		write_cmos_sensor(0x89,0x10);
+		write_cmos_sensor(0xf0,0x00);
+		write_cmos_sensor(0xf1,0x00);
+		write_cmos_sensor(0xf2,0x00);
+		write_cmos_sensor(0xf3,0x00);
+		write_cmos_sensor(0xfd,0x02);//0x25
+		write_cmos_sensor(0x00,0x8c);
+		write_cmos_sensor(0x01,0x8c);
+		write_cmos_sensor(0x02,0x8c);
+		write_cmos_sensor(0x03,0x8c);
+		write_cmos_sensor(0xfd,0x01);
+		write_cmos_sensor(0xb3,0x00);
+		write_cmos_sensor(0xb1,0x01);
+		write_cmos_sensor(0xa4,0x6d);
+		write_cmos_sensor(0xb6,0xc0);  
+		write_cmos_sensor(0x9d,0x65);
+		write_cmos_sensor(0x97,0x08);
+		write_cmos_sensor(0xc4,0x28); 
+		write_cmos_sensor(0xc1,0x09);   
+		write_cmos_sensor(0xfd,0x02);
+		write_cmos_sensor(0x10,0x00); 
+		write_cmos_sensor(0x11,0xeb);
+		write_cmos_sensor(0x12,0x00); 
+		write_cmos_sensor(0x13,0xed);
+		write_cmos_sensor(0x14,0x0a); 
+		write_cmos_sensor(0x15,0x2f);
+		write_cmos_sensor(0x16,0x0e); 
+		write_cmos_sensor(0x17,0xd0);
+		write_cmos_sensor(0x18,0x60);
+		write_cmos_sensor(0x19,0x40);
+		write_cmos_sensor(0x83,0x00);
+		write_cmos_sensor(0x84,0x00);
+		write_cmos_sensor(0x87,0x00);
+		write_cmos_sensor(0x88,0x00);
+		write_cmos_sensor(0x73,0x00);
+		write_cmos_sensor(0x74,0x00);
+		write_cmos_sensor(0x7f,0xff);
+		write_cmos_sensor(0x80,0xff);
+		write_cmos_sensor(0x93,0x0f);
+		write_cmos_sensor(0xfd,0x00);
+//	LOG_INF("2015-2-6 superpix init end E\n");
+       }
 
 static void preview_setting(void)
 {
-    /********************************************************
-     *
-     *   1296x972 30fps 2 lane MIPI 420Mbps/lane
-     *
-     ********************************************************/
-    
-    
+
 }    /*    preview_setting  */
 
 
 static void capture_setting(kal_uint16 currefps)
 {
-    LOG_INF("E! currefps:%d\n", currefps);
-    
-    /********************************************************
-     *
-     *   2592x1944 15fps 2 lane MIPI 420Mbps/lane
-     *
-     ********************************************************/
-    
-    
+
 }    /*    capture_setting  */
 
 static void normal_video_setting(kal_uint16 currefps)
 {
-    LOG_INF("E! currefps:%d\n", currefps);
-    
-    /********************************************************
-     *
-     *   1296x972 30fps 2 lane MIPI 420Mbps/lane
-     *
-     ********************************************************/
-    
-    
+
 }    /*    preview_setting  */
 
 
 static void video_1080p_setting(void)
 {
-    
-    /********************************************************
-     *
-     *   1080p 30fps 2 lane MIPI 420Mbps/lane
-     *    @@1080p
-     *    ;;pclk=84M,HTS=2500,VTS=1120
-     ********************************************************/
-    
-    
-    
+
 }    /*    preview_setting  */
 
 static void video_720p_setting(void)
 {
-    /********************************************************
-     *
-     *   720p 30fps 2 lane MIPI 420Mbps/lane
-     *    @@720p_30fps
-     *     ;;pclk=84M,HTS=3728,VTS=748
-     ********************************************************/
-    
-    
-    
-    LOG_INF("Exit!");
+
 }    /*    preview_setting  */
 
 
 static void hs_video_setting(void)
 {
-    LOG_INF("E\n");
+  //  LOG_INF("E\n");
 
     video_1080p_setting();
 }
 
 static void slim_video_setting(void)
 {
-    LOG_INF("E\n");
+  //  LOG_INF("E\n");
 
     video_720p_setting();
 }
@@ -595,6 +611,8 @@ static kal_uint32 get_imgsensor_id(UINT32 *sensor_id)
 {
     kal_uint8 i = 0;
     kal_uint8 retry = 2;
+   LOG_1;
+    LOG_2;
     //sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
     while (imgsensor_info.i2c_addr_table[i] != 0xff) {
         spin_lock(&imgsensor_drv_lock);
@@ -603,10 +621,10 @@ static kal_uint32 get_imgsensor_id(UINT32 *sensor_id)
         do {
             *sensor_id = return_sensor_id();
             if (*sensor_id == imgsensor_info.sensor_id) {
-                LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
+                LOG_INF("2015-2-6 superpix i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
                 return ERROR_NONE;
             }
-            LOG_INF("Read sensor id fail, id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
+            LOG_INF("2015-2-6 superpix Read sensor id fail, id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
             retry--;
         } while(retry > 0);
         i++;
@@ -653,10 +671,10 @@ static kal_uint32 open(void)
         do {
             sensor_id = return_sensor_id();
             if (sensor_id == imgsensor_info.sensor_id) {
-                LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
+   //             LOG_INF("2015-2-6 superpix i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
                 break;
             }
-            LOG_INF("Read sensor id fail, id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
+   //         LOG_INF("2015-2-6 superpix Read sensor id fail, id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
             retry--;
         } while(retry > 0);
         i++;
@@ -708,7 +726,7 @@ static kal_uint32 open(void)
 *************************************************************************/
 static kal_uint32 close(void)
 {
-    LOG_INF("E\n");
+  //  LOG_INF("E\n");
 
     /*No Need to implement this function*/
 
@@ -736,7 +754,7 @@ static kal_uint32 close(void)
 static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
                       MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
 {
-    LOG_INF("E\n");
+ //   LOG_INF("E\n");
 
     spin_lock(&imgsensor_drv_lock);
     imgsensor.sensor_mode = IMGSENSOR_MODE_PREVIEW;
@@ -770,7 +788,7 @@ static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
                           MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
 {
-    LOG_INF("E\n");
+  //  LOG_INF("E\n");
 
     spin_lock(&imgsensor_drv_lock);
     imgsensor.sensor_mode = IMGSENSOR_MODE_CAPTURE;
@@ -782,7 +800,7 @@ static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
         imgsensor.autoflicker_en = KAL_FALSE;
     } else {
         if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
-            LOG_INF("Warning: current_fps %d fps is not support, so use cap1's setting: %d fps!\n",imgsensor_info.cap1.max_framerate/10);
+  //          LOG_INF("Warning: current_fps %d fps is not support, so use cap1's setting: %d fps!\n",imgsensor_info.cap1.max_framerate/10);
         imgsensor.pclk = imgsensor_info.cap.pclk;
         imgsensor.line_length = imgsensor_info.cap.linelength;
         imgsensor.frame_length = imgsensor_info.cap.framelength;
@@ -797,7 +815,7 @@ static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
                       MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
 {
-    LOG_INF("E\n");
+  //  LOG_INF("E\n");
 
     spin_lock(&imgsensor_drv_lock);
     imgsensor.sensor_mode = IMGSENSOR_MODE_VIDEO;
@@ -816,8 +834,8 @@ static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
                       MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
 {
-    LOG_INF("E\n");
-    
+ //   LOG_INF("E\n");
+
     spin_lock(&imgsensor_drv_lock);
     imgsensor.sensor_mode = IMGSENSOR_MODE_HIGH_SPEED_VIDEO;
     imgsensor.pclk = imgsensor_info.hs_video.pclk;
@@ -837,8 +855,8 @@ static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
                       MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
 {
-    LOG_INF("E\n");
-    
+ //   LOG_INF("E\n");
+
     spin_lock(&imgsensor_drv_lock);
     imgsensor.sensor_mode = IMGSENSOR_MODE_SLIM_VIDEO;
     imgsensor.pclk = imgsensor_info.slim_video.pclk;
@@ -851,7 +869,7 @@ static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
     spin_unlock(&imgsensor_drv_lock);
     slim_video_setting();
     //set_mirror_flip(sensor_config_data->SensorImageMirror);
-    
+
     return ERROR_NONE;
 }    /*    slim_video     */
 
@@ -859,7 +877,7 @@ static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
 
 static kal_uint32 get_resolution(MSDK_SENSOR_RESOLUTION_INFO_STRUCT *sensor_resolution)
 {
-    LOG_INF("E\n");
+ //   LOG_INF("E\n");
     sensor_resolution->SensorFullWidth = imgsensor_info.cap.grabwindow_width;
     sensor_resolution->SensorFullHeight = imgsensor_info.cap.grabwindow_height;
 
@@ -882,7 +900,7 @@ static kal_uint32 get_info(MSDK_SCENARIO_ID_ENUM scenario_id,
                       MSDK_SENSOR_INFO_STRUCT *sensor_info,
                       MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
 {
-    LOG_INF("scenario_id = %d\n", scenario_id);
+   // LOG_INF("scenario_id = %d\n", scenario_id);
 
 
     //sensor_info->SensorVideoFrameRate = imgsensor_info.normal_video.max_framerate/10; /* not use */
@@ -984,7 +1002,7 @@ static kal_uint32 get_info(MSDK_SCENARIO_ID_ENUM scenario_id,
 static kal_uint32 control(MSDK_SCENARIO_ID_ENUM scenario_id, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
                       MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
 {
-    LOG_INF("scenario_id = %d\n", scenario_id);
+  //  LOG_INF("scenario_id = %d\n", scenario_id);
     spin_lock(&imgsensor_drv_lock);
     imgsensor.current_scenario_id = scenario_id;
     spin_unlock(&imgsensor_drv_lock);
@@ -1005,7 +1023,7 @@ static kal_uint32 control(MSDK_SCENARIO_ID_ENUM scenario_id, MSDK_SENSOR_EXPOSUR
             slim_video(image_window, sensor_config_data);
             break;
         default:
-            LOG_INF("Error ScenarioId setting");
+  //          LOG_INF("Error ScenarioId setting");
             preview(image_window, sensor_config_data);
             return ERROR_INVALID_SCENARIO_ID;
     }
@@ -1015,8 +1033,8 @@ static kal_uint32 control(MSDK_SCENARIO_ID_ENUM scenario_id, MSDK_SENSOR_EXPOSUR
 
 
 static kal_uint32 set_video_mode(UINT16 framerate)
-{
-    LOG_INF("framerate = %d\n ", framerate);
+{//This Function not used after ROME
+  //  LOG_INF("framerate = %d\n ", framerate);
     // SetVideoMode Function should fix framerate
     if (framerate == 0)
         // Dynamic frame rate
@@ -1036,7 +1054,7 @@ static kal_uint32 set_video_mode(UINT16 framerate)
 
 static kal_uint32 set_auto_flicker_mode(kal_bool enable, UINT16 framerate)
 {
-    LOG_INF("enable = %d, framerate = %d \n", enable, framerate);
+  //  LOG_INF("enable = %d, framerate = %d \n", enable, framerate);
     spin_lock(&imgsensor_drv_lock);
     if (enable) //enable auto flicker
         imgsensor.autoflicker_en = KAL_TRUE;
@@ -1051,7 +1069,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
 {
     kal_uint32 frame_length;
 
-    LOG_INF("scenario_id = %d, framerate = %d\n", scenario_id, framerate);
+  //  LOG_INF("scenario_id = %d, framerate = %d\n", scenario_id, framerate);
 
     switch (scenario_id) {
         case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
@@ -1109,7 +1127,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
             imgsensor.min_frame_length = imgsensor.frame_length;
             spin_unlock(&imgsensor_drv_lock);
             //set_dummy();
-            LOG_INF("error scenario_id = %d, we use preview scenario \n", scenario_id);
+   //         LOG_INF("error scenario_id = %d, we use preview scenario \n", scenario_id);
             break;
     }
     return ERROR_NONE;
@@ -1118,7 +1136,7 @@ static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_i
 
 static kal_uint32 get_default_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 *framerate)
 {
-    LOG_INF("scenario_id = %d\n", scenario_id);
+  //  LOG_INF("scenario_id = %d\n", scenario_id);
 
     switch (scenario_id) {
         case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
@@ -1147,7 +1165,7 @@ static kal_uint32 get_default_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenar
 
 static kal_uint32 set_test_pattern_mode(kal_bool enable)
 {
-    LOG_INF("enable: %d\n", enable);
+ //   LOG_INF("enable: %d\n", enable);
 #if 0
     // 0x503D[8]: 1 enable,  0 disable
     // 0x503D[1:0]; 00 Color bar, 01 Random Data, 10 Square
@@ -1155,7 +1173,7 @@ static kal_uint32 set_test_pattern_mode(kal_bool enable)
         write_cmos_sensor(0x503D, 0x80);
     else
         write_cmos_sensor(0x503D, 0x00);
-    
+
     spin_lock(&imgsensor_drv_lock);
     imgsensor.test_pattern = enable;
     spin_unlock(&imgsensor_drv_lock);
@@ -1167,7 +1185,7 @@ static kal_uint32 set_test_pattern_mode(kal_bool enable)
 static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
                              UINT8 *feature_para,UINT32 *feature_para_len)
 {
- UINT16 *feature_return_para_16=(UINT16 *) feature_para;
+    UINT16 *feature_return_para_16=(UINT16 *) feature_para;
     UINT16 *feature_data_16=(UINT16 *) feature_para;
     UINT32 *feature_return_para_32=(UINT32 *) feature_para;
     UINT32 *feature_data_32=(UINT32 *) feature_para;
@@ -1177,7 +1195,7 @@ static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
     SENSOR_WINSIZE_INFO_STRUCT *wininfo;
     MSDK_SENSOR_REG_INFO_STRUCT *sensor_reg_data=(MSDK_SENSOR_REG_INFO_STRUCT *) feature_para;
 
-    LOG_INF("feature_id = %d\n", feature_id);
+    //printk("feature_id = %d\n", feature_id);
     switch (feature_id) {
         case SENSOR_FEATURE_GET_PERIOD:
             *feature_return_para_16++ = imgsensor.line_length;
@@ -1185,6 +1203,7 @@ static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
             *feature_para_len=4;
             break;
         case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:
+ //           LOG_INF("feature_Control imgsensor.pclk = %d,imgsensor.current_fps = %d\n", imgsensor.pclk,imgsensor.current_fps);
             *feature_return_para_32 = imgsensor.pclk;
             *feature_para_len=4;
             break;
@@ -1236,19 +1255,19 @@ static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
             *feature_para_len=4;
             break;
         case SENSOR_FEATURE_SET_FRAMERATE:
-            LOG_INF("current fps :%d\n", (UINT32)*feature_data);
+    //        LOG_INF("current fps :%d\n", (UINT32)*feature_data);
             spin_lock(&imgsensor_drv_lock);
             imgsensor.current_fps = *feature_data;
             spin_unlock(&imgsensor_drv_lock);
             break;
         case SENSOR_FEATURE_SET_HDR:
-            LOG_INF("ihdr enable :%d\n", (BOOL)*feature_data);
+  //          LOG_INF("ihdr enable :%d\n", (BOOL)*feature_data);
             spin_lock(&imgsensor_drv_lock);
             imgsensor.ihdr_en = (BOOL)*feature_data;
             spin_unlock(&imgsensor_drv_lock);
             break;
         case SENSOR_FEATURE_GET_CROP_INFO:
-            LOG_INF("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n", (UINT32)*feature_data);
+   //         LOG_INF("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n", (UINT32)*feature_data);
 
             wininfo = (SENSOR_WINSIZE_INFO_STRUCT *)(uintptr_t)(*(feature_data+1));
 
@@ -1271,14 +1290,13 @@ static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
                     break;
             }
         case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
-            LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",(UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
+  //          LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",(UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
             ihdr_write_shutter_gain((UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
             break;
         default:
             break;
     }
 
-    
     return ERROR_NONE;
 }    /*    feature_control()  */
 
@@ -1291,10 +1309,10 @@ static SENSOR_FUNCTION_STRUCT sensor_func = {
     close
 };
 
-UINT32 SP5409_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
+UINT32 SP5409MIPISensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
 {
     /* To Do : Check Sensor status here */
     if (pfFunc!=NULL)
         *pfFunc=&sensor_func;
     return ERROR_NONE;
-}    /*    sp5409MIPISensorInit    */
+}    /*    SP5409MIPISensorInit    */
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/sp5409_mipi_raw/sp5409mipi_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/sp5409_mipi_raw/sp5409mipi_Sensor.h
old mode 100644
new mode 100755
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/sp5409sub_mipi_raw/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6735m/sp5409sub_mipi_raw/Makefile
new file mode 100755
index 0000000..43c4dec
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/sp5409sub_mipi_raw/Makefile
@@ -0,0 +1,4 @@
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+
+obj-y += sp5409submipi_Sensor.o
+
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/sp5409sub_mipi_raw/sp5409submipi_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/sp5409sub_mipi_raw/sp5409submipi_Sensor.c
new file mode 100644
index 0000000..c8d1ffa
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/sp5409sub_mipi_raw/sp5409submipi_Sensor.c
@@ -0,0 +1,1319 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *     SP5409mipi_Sensor.c
+ *
+ * Project:
+ * --------
+ *     ALPS
+ *
+ * Description:
+ * ------------
+ *     Source code of Sensor driver
+ *
+ *
+ *------------------------------------------------------------------------------
+ * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
+ *============================================================================
+ ****************************************************************************/
+
+#include <linux/videodev2.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <asm/atomic.h>
+//#include <asm/system.h>
+#include <linux/xlog.h>
+
+#include "kd_camera_hw.h"
+#include "kd_imgsensor.h"
+#include "kd_imgsensor_define.h"
+#include "kd_imgsensor_errcode.h"
+
+#include "sp5409submipi_Sensor.h"
+/****************************Modify Following Strings for Debug****************************/
+#define PFX "SP5409_camera_sensor"
+#define LOG_1 LOG_INF("SP5409,MIPI 2LANE\n")
+#define LOG_2 LOG_INF("preview 1280*960@30fps,420Mbps/lane; video 1280*960@30fps,420Mbps/lane; capture 5M@15fps,420Mbps/lane\n")
+/****************************   Modify end    *******************************************/
+
+#define LOG_INF(format, args...)    xlog_printk(ANDROID_LOG_INFO   , PFX, "[%s] " format, __FUNCTION__, ##args)
+
+static DEFINE_SPINLOCK(imgsensor_drv_lock);
+
+
+static imgsensor_info_struct imgsensor_info = {
+    .sensor_id = 0x540a, //SP5409MIPI_SENSOR_ID,
+
+    .checksum_value = 0xf7375923,        //checksum value for Camera Auto Test
+
+    .pre = {
+        .pclk = 42000000,              //record different mode's pclk
+        .linelength = 1772,             //record different mode's linelength
+        .framelength = 1970,            //record different mode's framelength
+        .startx = 2,                    //record different mode's startx of grabwindow
+        .starty = 2,                    //record different mode's starty of grabwindow
+        .grabwindow_width = 2592,        //record different mode's width of grabwindow
+        .grabwindow_height = 1944,        //record different mode's height of grabwindow
+        /*     following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario    */
+        .mipi_data_lp2hs_settle_dc = 85,//unit , ns
+        /*     following for GetDefaultFramerateByScenario()    */
+        .max_framerate = 300,
+    },
+    .cap = {
+        .pclk = 42000000,
+        .linelength = 1772,
+        .framelength = 1970,
+        .startx = 4,
+        .starty = 4,
+        .grabwindow_width = 2592,
+        .grabwindow_height = 1944,
+        .mipi_data_lp2hs_settle_dc = 85,//unit , ns
+        .max_framerate = 300,
+    },
+    .cap1 = {
+        .pclk = 42000000,
+        .linelength = 1772,
+        .framelength = 1970,
+        .startx = 2,
+        .starty = 2,
+        .grabwindow_width = 2592,
+        .grabwindow_height = 1944,
+        .mipi_data_lp2hs_settle_dc = 85,//unit , ns
+        .max_framerate = 300,
+    },
+    .normal_video = {
+        .pclk = 42000000,
+        .linelength = 1772,
+        .framelength = 1970,
+        .startx = 2,
+        .starty = 2,
+        .grabwindow_width = 2592,
+        .grabwindow_height = 1944,
+        .mipi_data_lp2hs_settle_dc = 85,//unit , ns
+        .max_framerate = 300,
+    },
+    .hs_video = {
+        .pclk = 42000000,
+        .linelength = 1772,
+        .framelength = 1970,
+        .startx = 2,
+        .starty = 2,
+        .grabwindow_width = 1280,
+        .grabwindow_height = 720,
+        .mipi_data_lp2hs_settle_dc = 85,//unit , ns
+        .max_framerate = 300,
+    },
+    .slim_video = {
+        .pclk = 42000000,
+        .linelength = 1772,
+        .framelength = 1970,
+        .startx = 2,
+        .starty = 2,
+        .grabwindow_width = 2592,
+        .grabwindow_height = 1944,
+        .mipi_data_lp2hs_settle_dc = 85,//unit , ns
+        .max_framerate = 300,
+    },
+    .margin = 0,            //sensor framelength & shutter margin
+    .min_shutter = 1,        //min shutter
+    .max_frame_length = 0x7fff,//max framelength by sensor register's limitation
+    .ae_shut_delay_frame = 0,    //shutter delay frame for AE cycle, 2 frame with ispGain_delay-shut_delay=2-0=2
+    .ae_sensor_gain_delay_frame = 0,//sensor gain delay frame for AE cycle,2 frame with ispGain_delay-sensor_gain_delay=2-0=2
+    .ae_ispGain_delay_frame = 2,//isp gain delay frame for AE cycle
+    .ihdr_support = 0,      //1, support; 0,not support
+    .ihdr_le_firstline = 0,  //1,le first ; 0, se first
+    .sensor_mode_num = 5,      //support sensor mode num
+
+    .cap_delay_frame = 0,///2,
+    .pre_delay_frame = 2,
+    .video_delay_frame = 2,
+    .hs_video_delay_frame = 2,
+    .slim_video_delay_frame = 2,
+
+    .isp_driving_current = ISP_DRIVING_2MA, //mclk driving current
+    .sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,//sensor_interface_type
+    .mipi_sensor_type = MIPI_OPHY_NCSI2, //0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2
+    .mipi_settle_delay_mode = MIPI_SETTLEDELAY_AUTO,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
+    .sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_B,//sensor output first pixel color
+    .mclk = 24,//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
+    .mipi_lane_num = SENSOR_MIPI_2_LANE,//mipi lane num
+    .i2c_addr_table = {0x78, 0x7a,0xff}, //5409H---0x78 /5409---0x7a
+    .i2c_speed = 200,
+};
+
+
+static imgsensor_struct imgsensor = {
+    .mirror = IMAGE_NORMAL,                //mirrorflip information
+    .sensor_mode = IMGSENSOR_MODE_INIT, //IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
+    .shutter = 0x3D0,                    //current shutter
+    .gain = 0x100,                        //current gain
+    .dummy_pixel = 0,                    //current dummypixel
+    .dummy_line = 0,                    //current dummyline
+    .current_fps = 300,  //full size current fps : 24fps for PIP, 30fps for Normal or ZSD
+    .autoflicker_en = KAL_FALSE,  //auto flicker enable: KAL_FALSE for disable auto flicker, KAL_TRUE for enable auto flicker
+    .test_pattern = KAL_FALSE,        //test pattern mode or not. KAL_FALSE for in test pattern mode, KAL_TRUE for normal output
+    .current_scenario_id = MSDK_SCENARIO_ID_CAMERA_PREVIEW,//current scenario id
+    .ihdr_en = 0, //sensor need support LE, SE with HDR feature
+    .i2c_write_id = 0x78,//record current sensor's i2c write id //5409H---0x78 /5409---0x7a
+};
+
+
+/* Sensor output window information */
+static SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[5]=
+{{ 1616, 1216, 1000, 1000, 2592, 1944, 2592, 1944, 0000, 0000, 2592, 1944, 0000, 0000, 2592, 1944}, // Preview 2112*1558
+ { 1616, 1216, 1000, 1000, 2592, 1944, 2592, 1944, 0000, 0000, 2592, 1944, 0000, 0000, 2592, 1944}, // capture 4206*3128
+ { 1616, 1216, 1000, 1000, 2592, 1944, 2592, 1944, 0000, 0000, 2592, 1944, 0000, 0000, 2592, 1944}, // video 
+ { 1616, 1216, 1000, 1000, 2592, 1944, 2592, 1944, 0000, 0000, 2592, 1944, 0000, 0000, 1280, 720}, //hight speed video 
+ { 1616, 1216, 1000, 1000, 2592, 1944, 2592, 1944, 0000, 0000, 2592, 1944, 0000, 0000, 2592, 1944},// slim video
+};
+
+
+static kal_uint16 read_cmos_sensor(kal_uint32 addr)
+{
+    kal_uint16 get_byte=0;
+	char pu_send_cmd[1] = { (char)(addr & 0xFF) };
+
+	kdSetI2CSpeed(imgsensor_info.i2c_speed); // Add this func to set i2c speed by each sensor
+
+    iReadRegI2C(pu_send_cmd, 1, (u8*)&get_byte, 1, imgsensor.i2c_write_id);
+
+    return get_byte;
+}
+
+static void write_cmos_sensor(kal_uint32 addr, kal_uint32 para)
+{
+    char pu_send_cmd[2] = { (char)(addr & 0xFF), (char)(para & 0xFF)};
+
+	kdSetI2CSpeed(imgsensor_info.i2c_speed); // Add this func to set i2c speed by each sensor
+
+    iWriteRegI2C(pu_send_cmd, 2, imgsensor.i2c_write_id);
+}
+
+static void set_dummy(void)
+{
+   // LOG_INF("dummyline = %d, dummypixels = %d \n", imgsensor.dummy_line, imgsensor.dummy_pixel);
+    /* you can set dummy by imgsensor.dummy_line and imgsensor.dummy_pixel, or you can set dummy by imgsensor.frame_length and imgsensor.line_length */
+#if 0
+    write_cmos_sensor(kal_uint32 addr, kal_uint32 para)(0x380e, imgsensor.frame_length >> 8);
+    write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
+    write_cmos_sensor(0x380c, imgsensor.line_length >> 8);
+    write_cmos_sensor(0x380d, imgsensor.line_length & 0xFF);
+#endif
+}    /*    set_dummy  */
+
+static kal_uint32 return_sensor_id(void)
+{
+    write_cmos_sensor(0xfd, 0x00);
+    return ((read_cmos_sensor(0x02) << 8) | read_cmos_sensor(0x03)+1);
+}
+static void set_max_framerate(UINT16 framerate,kal_bool min_framelength_en)
+{
+    kal_uint32 frame_length = imgsensor.frame_length;
+
+   // LOG_INF("framerate = %d, min framelength should enable? \n", framerate,min_framelength_en);
+
+    frame_length = imgsensor.pclk / framerate * 10 / imgsensor.line_length;
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.frame_length = (frame_length > imgsensor.min_frame_length) ? frame_length : imgsensor.min_frame_length;
+    imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
+    //dummy_line = frame_length - imgsensor.min_frame_length;
+    //if (dummy_line < 0)
+        //imgsensor.dummy_line = 0;
+    //else
+        //imgsensor.dummy_line = dummy_line;
+    //imgsensor.frame_length = frame_length + imgsensor.dummy_line;
+    if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+    {
+        imgsensor.frame_length = imgsensor_info.max_frame_length;
+        imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
+    }
+    if (min_framelength_en)
+        imgsensor.min_frame_length = imgsensor.frame_length;
+    spin_unlock(&imgsensor_drv_lock);
+
+    set_dummy();
+}    /*    set_max_framerate  */
+
+static void write_shutter(kal_uint16 shutter)
+{
+#if 0
+    kal_uint16 realtime_fps = 0;
+
+    /* 0x3500, 0x3501, 0x3502 will increase VBLANK to get exposure larger than frame exposure */
+    /* AE doesn't update sensor gain at capture mode, thus extra exposure lines must be updated here. */
+
+    // OV Recommend Solution
+    // if shutter bigger than frame_length, should extend frame length first
+    spin_lock(&imgsensor_drv_lock);
+    if (shutter > imgsensor.min_frame_length - imgsensor_info.margin)
+        imgsensor.frame_length = shutter + imgsensor_info.margin;
+    else
+        imgsensor.frame_length = imgsensor.min_frame_length;
+    if (imgsensor.frame_length > imgsensor_info.max_frame_length)
+        imgsensor.frame_length = imgsensor_info.max_frame_length;
+    spin_unlock(&imgsensor_drv_lock);
+    shutter = (shutter < imgsensor_info.min_shutter) ? imgsensor_info.min_shutter : shutter;
+    shutter = (shutter > (imgsensor_info.max_frame_length - imgsensor_info.margin)) ? (imgsensor_info.max_frame_length - imgsensor_info.margin) : shutter;
+
+    // Framelength should be an even number
+    shutter = (shutter >> 1) << 1;
+    imgsensor.frame_length = (imgsensor.frame_length >> 1) << 1;
+
+    if (imgsensor.autoflicker_en) {
+        realtime_fps = imgsensor.pclk / imgsensor.line_length * 10 / imgsensor.frame_length;
+
+        if(realtime_fps >= 297 && realtime_fps <= 305)
+            set_max_framerate(296,0);
+        else if(realtime_fps >= 147 && realtime_fps <= 150)
+            set_max_framerate(146,0);
+        else {
+            // Extend frame length
+            write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
+            write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
+        }
+    } else {
+        // Extend frame length
+        write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
+        write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
+    }
+#endif
+    // Update Shutter
+	 write_cmos_sensor(0xfd, 0x01);
+	 write_cmos_sensor(0x03, (shutter >> 8) & 0xFF);
+	 write_cmos_sensor(0x04, shutter  & 0xFF);
+	 write_cmos_sensor(0x01, 0x01); 
+
+    LOG_INF("shutter =%d, framelength =%d\n", shutter, imgsensor.frame_length);
+}
+
+
+/*************************************************************************
+* FUNCTION
+*    set_shutter
+*
+* DESCRIPTION
+*    This function set e-shutter of sensor to change exposure time.
+*
+* PARAMETERS
+*    iShutter : exposured lines
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static void set_shutter(kal_uint16 shutter)
+{
+    unsigned long flags;
+    if (shutter < 7)
+          shutter = 7; 
+	else if(shutter > 0xffff)
+	   shutter = 0xffff;
+    spin_lock_irqsave(&imgsensor_drv_lock, flags);
+    imgsensor.shutter = shutter;
+    spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
+
+    write_shutter(shutter);
+}
+
+static kal_uint16 gain2reg(const kal_uint16 gain)
+{
+#if 0
+    kal_uint16 reg_gain = 0x0000;
+
+    reg_gain = ((gain / BASEGAIN) << 4) + ((gain % BASEGAIN) * 16 / BASEGAIN);
+    reg_gain = reg_gain & 0xFFFF;
+
+    return (kal_uint16)reg_gain;
+#endif
+}
+
+/*************************************************************************
+* FUNCTION
+*    set_gain
+*
+* DESCRIPTION
+*    This function is to set global gain to sensor.
+*
+* PARAMETERS
+*    iGain : sensor global gain(base: 0x40)
+*
+* RETURNS
+*    the actually gain set to sensor.
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint16 set_gain(kal_uint16 gain)
+{
+    kal_uint16 reg_gain = 0x0000;
+
+    if(gain >= BASEGAIN && gain <= 15*BASEGAIN)
+   	 {   
+   	    	reg_gain = 0x10 * gain/BASEGAIN ;        //change mtk gain base to aptina gain base
+
+   	    	 if(reg_gain<=0x10)
+   	    	 {
+   	    	    	write_cmos_sensor(0xfd, 0x01);
+   	    	    	write_cmos_sensor(0x24, 0x10);//0x23
+   	    	    	write_cmos_sensor(0x01, 0x01);
+  	    	    	LOG_INF("SP5409 reg_gain =%d, SP5409MIPI Gain = %d", reg_gain, gain);
+   	    	 }
+   	    	 else if(reg_gain>= 0x70)
+   	    	 {
+   	    	    	 write_cmos_sensor(0xfd, 0x01);
+   	    	    	 write_cmos_sensor(0x24,0x70);
+   	    	    	 write_cmos_sensor(0x01, 0x01);
+  	    	    	 LOG_INF("SP5409MIPI reg_gain =%d, SP5409MIPI Gain = %d",  reg_gain, gain);
+	        }        	
+   	    	 else
+   	    	 {
+   	    	    	 write_cmos_sensor(0xfd, 0x01);
+   	    	    	 write_cmos_sensor(0x24, (kal_uint8)reg_gain);
+   	    	    	 write_cmos_sensor(0x01, 0x01);
+	       }	
+   	 }	
+   	 else
+   	    	 LOG_INF("error gain setting");
+
+	  return gain;
+}    /*    set_gain  */
+
+static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gain)
+{
+    //not support HDR
+    //LOG_INF("le:0x%x, se:0x%x, gain:0x%x\n",le,se,gain);
+}
+
+#if 0
+static void set_mirror_flip(kal_uint8 image_mirror)
+{
+  //  LOG_INF("image_mirror = %d\n", image_mirror);
+
+    /********************************************************
+       *
+       *   0x3820[2] ISP Vertical flip
+       *   0x3820[1] Sensor Vertical flip
+       *
+       *   0x3821[2] ISP Horizontal mirror
+       *   0x3821[1] Sensor Horizontal mirror
+       *
+       *   ISP and Sensor flip or mirror register bit should be the same!!
+       *
+       ********************************************************/
+
+    switch (image_mirror) {
+        case IMAGE_NORMAL:
+            write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x00));
+            write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x06));
+            break;
+        case IMAGE_H_MIRROR:
+            write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x00));
+            write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x00));
+            break;
+        case IMAGE_V_MIRROR:
+            write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x06));
+            write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x06));
+            break;
+        case IMAGE_HV_MIRROR:
+            write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x06));
+            write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x00));
+            break;
+        default:
+  //          LOG_INF("Error image_mirror setting\n");
+    }
+
+}
+#endif
+
+/*************************************************************************
+* FUNCTION
+*    night_mode
+*
+* DESCRIPTION
+*    This function night mode of sensor.
+*
+* PARAMETERS
+*    bEnable: KAL_TRUE -> enable night mode, otherwise, disable night mode
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static void night_mode(kal_bool enable)
+{
+/*No Need to implement this function*/
+}    /*    night_mode    */
+
+static void sensor_init(void)
+    /*    MIPI_sensor_Init  */
+{
+//	LOG_INF("2015-2-6 superpix init start E\n");
+		write_cmos_sensor(0xfd,0x00);
+		write_cmos_sensor(0x1b,0x00);
+		write_cmos_sensor(0x2f,0x10);
+		write_cmos_sensor(0x30,0x15);
+		write_cmos_sensor(0x33,0x05);
+		write_cmos_sensor(0x34,0x00);
+		write_cmos_sensor(0xfd,0x01);//vblank
+		write_cmos_sensor(0x06,0x01);
+		write_cmos_sensor(0x03,0x00);
+		write_cmos_sensor(0x04,0xed);
+		write_cmos_sensor(0x09,0x01);
+		write_cmos_sensor(0x0a,0xb5);
+		write_cmos_sensor(0x24,0x60);
+		write_cmos_sensor(0x01,0x01);
+		write_cmos_sensor(0x20,0x3d);
+		write_cmos_sensor(0x21,0x37);
+		write_cmos_sensor(0x25,0xf4);
+		write_cmos_sensor(0x26,0x0c);
+		write_cmos_sensor(0x2a,0x12);
+		write_cmos_sensor(0x2c,0xa0);
+		write_cmos_sensor(0x8a,0x55);
+		write_cmos_sensor(0x8b,0x55);
+		write_cmos_sensor(0x58,0x3a);
+		write_cmos_sensor(0x75,0x58);
+		write_cmos_sensor(0x77,0x6f);
+		write_cmos_sensor(0x78,0xef);
+		write_cmos_sensor(0x84,0x0f);
+		write_cmos_sensor(0x85,0x02);
+		write_cmos_sensor(0xd0,0x01);
+		write_cmos_sensor(0xd1,0x02);
+		write_cmos_sensor(0xd2,0x00);
+		write_cmos_sensor(0xd3,0x02);
+		write_cmos_sensor(0xd4,0x80);
+		write_cmos_sensor(0x11,0x40);
+		write_cmos_sensor(0x51,0x15);
+		write_cmos_sensor(0x52,0x3a);
+		write_cmos_sensor(0x53,0x15);
+		write_cmos_sensor(0x5d,0x00);
+		write_cmos_sensor(0x5e,0x00);
+		write_cmos_sensor(0x66,0x5c); //blacklevel enable
+		write_cmos_sensor(0x68,0x62);
+		write_cmos_sensor(0x72,0x74);
+		write_cmos_sensor(0x7b,0x01);
+		write_cmos_sensor(0x7c,0x10);
+		write_cmos_sensor(0xfb,0x35);
+		write_cmos_sensor(0xfa,0x10);
+		write_cmos_sensor(0xfe,0x10);
+		write_cmos_sensor(0x87,0x08);
+		write_cmos_sensor(0x89,0x10);
+		write_cmos_sensor(0xf0,0x00);
+		write_cmos_sensor(0xf1,0x00);
+		write_cmos_sensor(0xf2,0x00);
+		write_cmos_sensor(0xf3,0x00);
+		write_cmos_sensor(0xfd,0x02);//0x25
+write_cmos_sensor(0x00,0x94); //R 1.14x
+write_cmos_sensor(0x01,0x94); //B 1.14x
+write_cmos_sensor(0x02,0x94); //Gr 1.14x
+write_cmos_sensor(0x03,0x94); //Gb 1.14x
+		write_cmos_sensor(0xfd,0x01);
+		write_cmos_sensor(0xb3,0x00);
+		write_cmos_sensor(0xb1,0x01);
+		write_cmos_sensor(0xa4,0x6d);
+		write_cmos_sensor(0xb6,0xc0);  
+		write_cmos_sensor(0x9d,0x65);
+		write_cmos_sensor(0x97,0x08);
+		write_cmos_sensor(0xc4,0x28); 
+		write_cmos_sensor(0xc1,0x09);   
+write_cmos_sensor(0xa1,0x02);
+		write_cmos_sensor(0xfd,0x02);
+		write_cmos_sensor(0x10,0x00); 
+		write_cmos_sensor(0x11,0xeb);
+		write_cmos_sensor(0x12,0x00); 
+		write_cmos_sensor(0x13,0xed);
+		write_cmos_sensor(0x14,0x0a); 
+		write_cmos_sensor(0x15,0x2f);
+		write_cmos_sensor(0x16,0x0e); 
+		write_cmos_sensor(0x17,0xd0);
+		write_cmos_sensor(0x18,0x60);
+		write_cmos_sensor(0x19,0x40);
+		write_cmos_sensor(0x83,0x00);
+		write_cmos_sensor(0x84,0x00);
+		write_cmos_sensor(0x87,0x00);
+		write_cmos_sensor(0x88,0x00);
+		write_cmos_sensor(0x73,0x00);
+		write_cmos_sensor(0x74,0x00);
+		write_cmos_sensor(0x7f,0xff);
+		write_cmos_sensor(0x80,0xff);
+write_cmos_sensor(0x93,0x00); //g
+		write_cmos_sensor(0xfd,0x00);
+//	LOG_INF("2015-2-6 superpix init end E\n");
+       }
+
+static void preview_setting(void)
+{
+
+}    /*    preview_setting  */
+
+
+static void capture_setting(kal_uint16 currefps)
+{
+
+}    /*    capture_setting  */
+
+static void normal_video_setting(kal_uint16 currefps)
+{
+
+}    /*    preview_setting  */
+
+
+static void video_1080p_setting(void)
+{
+
+}    /*    preview_setting  */
+
+static void video_720p_setting(void)
+{
+
+}    /*    preview_setting  */
+
+
+static void hs_video_setting(void)
+{
+  //  LOG_INF("E\n");
+
+    video_1080p_setting();
+}
+
+static void slim_video_setting(void)
+{
+  //  LOG_INF("E\n");
+
+    video_720p_setting();
+}
+
+/*************************************************************************
+* FUNCTION
+*    get_imgsensor_id
+*
+* DESCRIPTION
+*    This function get the sensor ID
+*
+* PARAMETERS
+*    *sensorID : return the sensor ID
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 get_imgsensor_id(UINT32 *sensor_id)
+{
+    kal_uint8 i = 0;
+    kal_uint8 retry = 2;
+   LOG_1;
+    LOG_2;
+    //sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
+    while (imgsensor_info.i2c_addr_table[i] != 0xff) {
+        spin_lock(&imgsensor_drv_lock);
+        imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
+        spin_unlock(&imgsensor_drv_lock);
+        do {
+            *sensor_id = return_sensor_id();
+            if (*sensor_id == imgsensor_info.sensor_id) {
+                LOG_INF("2015-2-6 superpix i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
+                return ERROR_NONE;
+            }
+            LOG_INF("2015-2-6 superpix Read sensor id fail, id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
+            retry--;
+        } while(retry > 0);
+        i++;
+        retry = 2;
+    }
+    if (*sensor_id != imgsensor_info.sensor_id) {
+        // if Sensor ID is not correct, Must set *sensor_id to 0xFFFFFFFF
+        *sensor_id = 0xFFFFFFFF;
+        return ERROR_SENSOR_CONNECT_FAIL;
+    }
+    return ERROR_NONE;
+}
+
+
+/*************************************************************************
+* FUNCTION
+*    open
+*
+* DESCRIPTION
+*    This function initialize the registers of CMOS sensor
+*
+* PARAMETERS
+*    None
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 open(void)
+{
+    kal_uint8 i = 0;
+    kal_uint8 retry = 2;
+    kal_uint32 sensor_id = 0;
+    LOG_1;
+    LOG_2;
+
+    //sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
+    while (imgsensor_info.i2c_addr_table[i] != 0xff) {
+        spin_lock(&imgsensor_drv_lock);
+        imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
+        spin_unlock(&imgsensor_drv_lock);
+        do {
+            sensor_id = return_sensor_id();
+            if (sensor_id == imgsensor_info.sensor_id) {
+   //             LOG_INF("2015-2-6 superpix i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
+                break;
+            }
+   //         LOG_INF("2015-2-6 superpix Read sensor id fail, id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
+            retry--;
+        } while(retry > 0);
+        i++;
+        if (sensor_id == imgsensor_info.sensor_id)
+            break;
+        retry = 2;
+    }
+    if (imgsensor_info.sensor_id != sensor_id)
+        return ERROR_SENSOR_CONNECT_FAIL;
+
+    /* initail sequence write in  */
+    sensor_init();
+
+    spin_lock(&imgsensor_drv_lock);
+
+    imgsensor.autoflicker_en= KAL_FALSE;
+    imgsensor.sensor_mode = IMGSENSOR_MODE_INIT;
+    imgsensor.pclk = imgsensor_info.pre.pclk;
+    imgsensor.frame_length = imgsensor_info.pre.framelength;
+    imgsensor.line_length = imgsensor_info.pre.linelength;
+    imgsensor.min_frame_length = imgsensor_info.pre.framelength;
+    imgsensor.dummy_pixel = 0;
+    imgsensor.dummy_line = 0;
+    imgsensor.ihdr_en = 0;
+    imgsensor.test_pattern = KAL_FALSE;
+    imgsensor.current_fps = imgsensor_info.pre.max_framerate;
+    spin_unlock(&imgsensor_drv_lock);
+
+    return ERROR_NONE;
+}    /*    open  */
+
+
+
+/*************************************************************************
+* FUNCTION
+*    close
+*
+* DESCRIPTION
+*
+*
+* PARAMETERS
+*    None
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 close(void)
+{
+  //  LOG_INF("E\n");
+
+    /*No Need to implement this function*/
+
+    return ERROR_NONE;
+}    /*    close  */
+
+
+/*************************************************************************
+* FUNCTION
+* preview
+*
+* DESCRIPTION
+*    This function start the sensor preview.
+*
+* PARAMETERS
+*    *image_window : address pointer of pixel numbers in one period of HSYNC
+*  *sensor_config_data : address pointer of line numbers in one period of VSYNC
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+ //   LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_PREVIEW;
+    imgsensor.pclk = imgsensor_info.pre.pclk;
+    //imgsensor.video_mode = KAL_FALSE;
+    imgsensor.line_length = imgsensor_info.pre.linelength;
+    imgsensor.frame_length = imgsensor_info.pre.framelength;
+    imgsensor.min_frame_length = imgsensor_info.pre.framelength;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    preview_setting();
+    //set_mirror_flip(sensor_config_data->SensorImageMirror);
+    return ERROR_NONE;
+}    /*    preview   */
+
+/*************************************************************************
+* FUNCTION
+*    capture
+*
+* DESCRIPTION
+*    This function setup the CMOS sensor in capture MY_OUTPUT mode
+*
+* PARAMETERS
+*
+* RETURNS
+*    None
+*
+* GLOBALS AFFECTED
+*
+*************************************************************************/
+static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                          MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+  //  LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_CAPTURE;
+    if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {//PIP capture: 24fps for less than 13M, 20fps for 16M,15fps for 20M
+        imgsensor.pclk = imgsensor_info.cap1.pclk;
+        imgsensor.line_length = imgsensor_info.cap1.linelength;
+        imgsensor.frame_length = imgsensor_info.cap1.framelength;
+        imgsensor.min_frame_length = imgsensor_info.cap1.framelength;
+        imgsensor.autoflicker_en = KAL_FALSE;
+    } else {
+        if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
+  //          LOG_INF("Warning: current_fps %d fps is not support, so use cap1's setting: %d fps!\n",imgsensor_info.cap1.max_framerate/10);
+        imgsensor.pclk = imgsensor_info.cap.pclk;
+        imgsensor.line_length = imgsensor_info.cap.linelength;
+        imgsensor.frame_length = imgsensor_info.cap.framelength;
+        imgsensor.min_frame_length = imgsensor_info.cap.framelength;
+        imgsensor.autoflicker_en = KAL_FALSE;
+    }
+    spin_unlock(&imgsensor_drv_lock);
+    capture_setting(imgsensor.current_fps);
+    //set_mirror_flip(sensor_config_data->SensorImageMirror);
+    return ERROR_NONE;
+}    /* capture() */
+static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+  //  LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_VIDEO;
+    imgsensor.pclk = imgsensor_info.normal_video.pclk;
+    imgsensor.line_length = imgsensor_info.normal_video.linelength;
+    imgsensor.frame_length = imgsensor_info.normal_video.framelength;
+    imgsensor.min_frame_length = imgsensor_info.normal_video.framelength;
+    //imgsensor.current_fps = 300;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    normal_video_setting(imgsensor.current_fps);
+    //set_mirror_flip(sensor_config_data->SensorImageMirror);
+    return ERROR_NONE;
+}    /*    normal_video   */
+
+static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+ //   LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_HIGH_SPEED_VIDEO;
+    imgsensor.pclk = imgsensor_info.hs_video.pclk;
+    //imgsensor.video_mode = KAL_TRUE;
+    imgsensor.line_length = imgsensor_info.hs_video.linelength;
+    imgsensor.frame_length = imgsensor_info.hs_video.framelength;
+    imgsensor.min_frame_length = imgsensor_info.hs_video.framelength;
+    imgsensor.dummy_line = 0;
+    imgsensor.dummy_pixel = 0;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    hs_video_setting();
+    //set_mirror_flip(sensor_config_data->SensorImageMirror);
+    return ERROR_NONE;
+}    /*    hs_video   */
+
+static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+ //   LOG_INF("E\n");
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.sensor_mode = IMGSENSOR_MODE_SLIM_VIDEO;
+    imgsensor.pclk = imgsensor_info.slim_video.pclk;
+    imgsensor.line_length = imgsensor_info.slim_video.linelength;
+    imgsensor.frame_length = imgsensor_info.slim_video.framelength;
+    imgsensor.min_frame_length = imgsensor_info.slim_video.framelength;
+    imgsensor.dummy_line = 0;
+    imgsensor.dummy_pixel = 0;
+    imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    slim_video_setting();
+    //set_mirror_flip(sensor_config_data->SensorImageMirror);
+
+    return ERROR_NONE;
+}    /*    slim_video     */
+
+
+
+static kal_uint32 get_resolution(MSDK_SENSOR_RESOLUTION_INFO_STRUCT *sensor_resolution)
+{
+ //   LOG_INF("E\n");
+    sensor_resolution->SensorFullWidth = imgsensor_info.cap.grabwindow_width;
+    sensor_resolution->SensorFullHeight = imgsensor_info.cap.grabwindow_height;
+
+    sensor_resolution->SensorPreviewWidth = imgsensor_info.pre.grabwindow_width;
+    sensor_resolution->SensorPreviewHeight = imgsensor_info.pre.grabwindow_height;
+
+    sensor_resolution->SensorVideoWidth = imgsensor_info.normal_video.grabwindow_width;
+    sensor_resolution->SensorVideoHeight = imgsensor_info.normal_video.grabwindow_height;
+
+
+    sensor_resolution->SensorHighSpeedVideoWidth     = imgsensor_info.hs_video.grabwindow_width;
+    sensor_resolution->SensorHighSpeedVideoHeight     = imgsensor_info.hs_video.grabwindow_height;
+
+    sensor_resolution->SensorSlimVideoWidth     = imgsensor_info.slim_video.grabwindow_width;
+    sensor_resolution->SensorSlimVideoHeight     = imgsensor_info.slim_video.grabwindow_height;
+    return ERROR_NONE;
+}    /*    get_resolution    */
+
+static kal_uint32 get_info(MSDK_SCENARIO_ID_ENUM scenario_id,
+                      MSDK_SENSOR_INFO_STRUCT *sensor_info,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+   // LOG_INF("scenario_id = %d\n", scenario_id);
+
+
+    //sensor_info->SensorVideoFrameRate = imgsensor_info.normal_video.max_framerate/10; /* not use */
+    //sensor_info->SensorStillCaptureFrameRate= imgsensor_info.cap.max_framerate/10; /* not use */
+    //imgsensor_info->SensorWebCamCaptureFrameRate= imgsensor_info.v.max_framerate; /* not use */
+
+    sensor_info->SensorClockPolarity = SENSOR_CLOCK_POLARITY_LOW;
+    sensor_info->SensorClockFallingPolarity = SENSOR_CLOCK_POLARITY_LOW; /* not use */
+    sensor_info->SensorHsyncPolarity = SENSOR_CLOCK_POLARITY_LOW; // inverse with datasheet
+    sensor_info->SensorVsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
+    sensor_info->SensorInterruptDelayLines = 4; /* not use */
+    sensor_info->SensorResetActiveHigh = FALSE; /* not use */
+    sensor_info->SensorResetDelayCount = 5; /* not use */
+
+    sensor_info->SensroInterfaceType = imgsensor_info.sensor_interface_type;
+    sensor_info->MIPIsensorType = imgsensor_info.mipi_sensor_type;
+    sensor_info->SettleDelayMode = imgsensor_info.mipi_settle_delay_mode;
+    sensor_info->SensorOutputDataFormat = imgsensor_info.sensor_output_dataformat;
+
+    sensor_info->CaptureDelayFrame = imgsensor_info.cap_delay_frame;
+    sensor_info->PreviewDelayFrame = imgsensor_info.pre_delay_frame;
+    sensor_info->VideoDelayFrame = imgsensor_info.video_delay_frame;
+    sensor_info->HighSpeedVideoDelayFrame = imgsensor_info.hs_video_delay_frame;
+    sensor_info->SlimVideoDelayFrame = imgsensor_info.slim_video_delay_frame;
+
+    sensor_info->SensorMasterClockSwitch = 0; /* not use */
+    sensor_info->SensorDrivingCurrent = imgsensor_info.isp_driving_current;
+
+    sensor_info->AEShutDelayFrame = imgsensor_info.ae_shut_delay_frame;          /* The frame of setting shutter default 0 for TG int */
+    sensor_info->AESensorGainDelayFrame = imgsensor_info.ae_sensor_gain_delay_frame;    /* The frame of setting sensor gain */
+    sensor_info->AEISPGainDelayFrame = imgsensor_info.ae_ispGain_delay_frame;
+    sensor_info->IHDR_Support = imgsensor_info.ihdr_support;
+    sensor_info->IHDR_LE_FirstLine = imgsensor_info.ihdr_le_firstline;
+    sensor_info->SensorModeNum = imgsensor_info.sensor_mode_num;
+
+    sensor_info->SensorMIPILaneNumber = imgsensor_info.mipi_lane_num;
+    sensor_info->SensorClockFreq = imgsensor_info.mclk;
+    sensor_info->SensorClockDividCount = 3; /* not use */
+    sensor_info->SensorClockRisingCount = 0;
+    sensor_info->SensorClockFallingCount = 2; /* not use */
+    sensor_info->SensorPixelClockCount = 3; /* not use */
+    sensor_info->SensorDataLatchCount = 2; /* not use */
+
+    sensor_info->MIPIDataLowPwr2HighSpeedTermDelayCount = 0;
+    sensor_info->MIPICLKLowPwr2HighSpeedTermDelayCount = 0;
+    sensor_info->SensorWidthSampling = 0;  // 0 is default 1x
+    sensor_info->SensorHightSampling = 0;    // 0 is default 1x
+    sensor_info->SensorPacketECCOrder = 1;
+
+    switch (scenario_id) {
+        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+            sensor_info->SensorGrabStartX = imgsensor_info.pre.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
+
+            break;
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+            sensor_info->SensorGrabStartX = imgsensor_info.cap.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.cap.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.cap.mipi_data_lp2hs_settle_dc;
+
+            break;
+        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+
+            sensor_info->SensorGrabStartX = imgsensor_info.normal_video.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.normal_video.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.normal_video.mipi_data_lp2hs_settle_dc;
+
+            break;
+        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+            sensor_info->SensorGrabStartX = imgsensor_info.hs_video.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.hs_video.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.hs_video.mipi_data_lp2hs_settle_dc;
+
+            break;
+        case MSDK_SCENARIO_ID_SLIM_VIDEO:
+            sensor_info->SensorGrabStartX = imgsensor_info.slim_video.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.slim_video.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.slim_video.mipi_data_lp2hs_settle_dc;
+
+            break;
+        default:
+            sensor_info->SensorGrabStartX = imgsensor_info.pre.startx;
+            sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;
+
+            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
+            break;
+    }
+
+    return ERROR_NONE;
+}    /*    get_info  */
+
+
+static kal_uint32 control(MSDK_SCENARIO_ID_ENUM scenario_id, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
+                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
+{
+  //  LOG_INF("scenario_id = %d\n", scenario_id);
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.current_scenario_id = scenario_id;
+    spin_unlock(&imgsensor_drv_lock);
+    switch (scenario_id) {
+        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+            preview(image_window, sensor_config_data);
+            break;
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+            capture(image_window, sensor_config_data);
+            break;
+        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+            normal_video(image_window, sensor_config_data);
+            break;
+        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+            hs_video(image_window, sensor_config_data);
+            break;
+        case MSDK_SCENARIO_ID_SLIM_VIDEO:
+            slim_video(image_window, sensor_config_data);
+            break;
+        default:
+  //          LOG_INF("Error ScenarioId setting");
+            preview(image_window, sensor_config_data);
+            return ERROR_INVALID_SCENARIO_ID;
+    }
+    return ERROR_NONE;
+}    /* control() */
+
+
+
+static kal_uint32 set_video_mode(UINT16 framerate)
+{//This Function not used after ROME
+  //  LOG_INF("framerate = %d\n ", framerate);
+    // SetVideoMode Function should fix framerate
+    if (framerate == 0)
+        // Dynamic frame rate
+        return ERROR_NONE;
+    spin_lock(&imgsensor_drv_lock);
+    if ((framerate == 300) && (imgsensor.autoflicker_en == KAL_TRUE))
+        imgsensor.current_fps = 296;
+    else if ((framerate == 150) && (imgsensor.autoflicker_en == KAL_TRUE))
+        imgsensor.current_fps = 146;
+    else
+        imgsensor.current_fps = framerate;
+    spin_unlock(&imgsensor_drv_lock);
+    set_max_framerate(imgsensor.current_fps,1);
+
+    return ERROR_NONE;
+}
+
+static kal_uint32 set_auto_flicker_mode(kal_bool enable, UINT16 framerate)
+{
+  //  LOG_INF("enable = %d, framerate = %d \n", enable, framerate);
+    spin_lock(&imgsensor_drv_lock);
+    if (enable) //enable auto flicker
+        imgsensor.autoflicker_en = KAL_TRUE;
+    else //Cancel Auto flick
+        imgsensor.autoflicker_en = KAL_FALSE;
+    spin_unlock(&imgsensor_drv_lock);
+    return ERROR_NONE;
+}
+
+
+static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 framerate)
+{
+    kal_uint32 frame_length;
+
+  //  LOG_INF("scenario_id = %d, framerate = %d\n", scenario_id, framerate);
+
+    switch (scenario_id) {
+        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+            frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            //set_dummy();
+            break;
+        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+            if(framerate == 0)
+                return ERROR_NONE;
+            frame_length = imgsensor_info.normal_video.pclk / framerate * 10 / imgsensor_info.normal_video.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.normal_video.framelength) ? (frame_length - imgsensor_info.normal_video.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.normal_video.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            //set_dummy();
+            break;
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+            frame_length = imgsensor_info.cap.pclk / framerate * 10 / imgsensor_info.cap.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.cap.framelength) ? (frame_length - imgsensor_info.cap.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.cap.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            //set_dummy();
+            break;
+        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+            frame_length = imgsensor_info.hs_video.pclk / framerate * 10 / imgsensor_info.hs_video.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.hs_video.framelength) ? (frame_length - imgsensor_info.hs_video.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.hs_video.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            //set_dummy();
+            break;
+        case MSDK_SCENARIO_ID_SLIM_VIDEO:
+            frame_length = imgsensor_info.slim_video.pclk / framerate * 10 / imgsensor_info.slim_video.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.slim_video.framelength) ? (frame_length - imgsensor_info.slim_video.framelength): 0;
+            imgsensor.frame_length = imgsensor_info.slim_video.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            //set_dummy();
+            break;
+        default:  //coding with  preview scenario by default
+            frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
+            imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
+            imgsensor.min_frame_length = imgsensor.frame_length;
+            spin_unlock(&imgsensor_drv_lock);
+            //set_dummy();
+   //         LOG_INF("error scenario_id = %d, we use preview scenario \n", scenario_id);
+            break;
+    }
+    return ERROR_NONE;
+}
+
+
+static kal_uint32 get_default_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 *framerate)
+{
+  //  LOG_INF("scenario_id = %d\n", scenario_id);
+
+    switch (scenario_id) {
+        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+            *framerate = imgsensor_info.pre.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+            *framerate = imgsensor_info.normal_video.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+            *framerate = imgsensor_info.cap.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+            *framerate = imgsensor_info.hs_video.max_framerate;
+            break;
+        case MSDK_SCENARIO_ID_SLIM_VIDEO:
+            *framerate = imgsensor_info.slim_video.max_framerate;
+            break;
+        default:
+            break;
+    }
+
+    return ERROR_NONE;
+}
+
+
+
+static kal_uint32 set_test_pattern_mode(kal_bool enable)
+{
+ //   LOG_INF("enable: %d\n", enable);
+#if 0
+    // 0x503D[8]: 1 enable,  0 disable
+    // 0x503D[1:0]; 00 Color bar, 01 Random Data, 10 Square
+    if(enable)
+        write_cmos_sensor(0x503D, 0x80);
+    else
+        write_cmos_sensor(0x503D, 0x00);
+
+    spin_lock(&imgsensor_drv_lock);
+    imgsensor.test_pattern = enable;
+    spin_unlock(&imgsensor_drv_lock);
+#endif
+    return ERROR_NONE;
+}
+
+
+static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
+                             UINT8 *feature_para,UINT32 *feature_para_len)
+{
+    UINT16 *feature_return_para_16=(UINT16 *) feature_para;
+    UINT16 *feature_data_16=(UINT16 *) feature_para;
+    UINT32 *feature_return_para_32=(UINT32 *) feature_para;
+    UINT32 *feature_data_32=(UINT32 *) feature_para;
+    unsigned long long *feature_data=(unsigned long long *) feature_para;
+    //unsigned long long *feature_return_para=(unsigned long long *) feature_para;
+
+    SENSOR_WINSIZE_INFO_STRUCT *wininfo;
+    MSDK_SENSOR_REG_INFO_STRUCT *sensor_reg_data=(MSDK_SENSOR_REG_INFO_STRUCT *) feature_para;
+
+    //printk("feature_id = %d\n", feature_id);
+    switch (feature_id) {
+        case SENSOR_FEATURE_GET_PERIOD:
+            *feature_return_para_16++ = imgsensor.line_length;
+            *feature_return_para_16 = imgsensor.frame_length;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:
+ //           LOG_INF("feature_Control imgsensor.pclk = %d,imgsensor.current_fps = %d\n", imgsensor.pclk,imgsensor.current_fps);
+            *feature_return_para_32 = imgsensor.pclk;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_SET_ESHUTTER:
+            set_shutter(*feature_data);
+            break;
+        case SENSOR_FEATURE_SET_NIGHTMODE:
+            night_mode((BOOL) *feature_data);
+            break;
+        case SENSOR_FEATURE_SET_GAIN:
+            set_gain((UINT16) *feature_data);
+            break;
+        case SENSOR_FEATURE_SET_FLASHLIGHT:
+            break;
+        case SENSOR_FEATURE_SET_ISP_MASTER_CLOCK_FREQ:
+            break;
+        case SENSOR_FEATURE_SET_REGISTER:
+            write_cmos_sensor(sensor_reg_data->RegAddr, sensor_reg_data->RegData);
+            break;
+        case SENSOR_FEATURE_GET_REGISTER:
+            sensor_reg_data->RegData = read_cmos_sensor(sensor_reg_data->RegAddr);
+            break;
+        case SENSOR_FEATURE_GET_LENS_DRIVER_ID:
+            // get the lens driver ID from EEPROM or just return LENS_DRIVER_ID_DO_NOT_CARE
+            // if EEPROM does not exist in camera module.
+            *feature_return_para_32=LENS_DRIVER_ID_DO_NOT_CARE;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_SET_VIDEO_MODE:
+            set_video_mode(*feature_data);
+            break;
+        case SENSOR_FEATURE_CHECK_SENSOR_ID:
+            get_imgsensor_id(feature_return_para_32);
+            break;
+        case SENSOR_FEATURE_SET_AUTO_FLICKER_MODE:
+            set_auto_flicker_mode((BOOL)*feature_data_16,*(feature_data_16+1));
+            break;
+        case SENSOR_FEATURE_SET_MAX_FRAME_RATE_BY_SCENARIO:
+            set_max_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data, *(feature_data+1));
+            break;
+        case SENSOR_FEATURE_GET_DEFAULT_FRAME_RATE_BY_SCENARIO:
+            get_default_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*(feature_data), (MUINT32 *)(uintptr_t)(*(feature_data+1)));
+            break;
+        case SENSOR_FEATURE_SET_TEST_PATTERN:
+            set_test_pattern_mode((BOOL)*feature_data);
+            break;
+        case SENSOR_FEATURE_GET_TEST_PATTERN_CHECKSUM_VALUE: //for factory mode auto testing
+            *feature_return_para_32 = imgsensor_info.checksum_value;
+            *feature_para_len=4;
+            break;
+        case SENSOR_FEATURE_SET_FRAMERATE:
+    //        LOG_INF("current fps :%d\n", (UINT32)*feature_data);
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.current_fps = *feature_data;
+            spin_unlock(&imgsensor_drv_lock);
+            break;
+        case SENSOR_FEATURE_SET_HDR:
+  //          LOG_INF("ihdr enable :%d\n", (BOOL)*feature_data);
+            spin_lock(&imgsensor_drv_lock);
+            imgsensor.ihdr_en = (BOOL)*feature_data;
+            spin_unlock(&imgsensor_drv_lock);
+            break;
+        case SENSOR_FEATURE_GET_CROP_INFO:
+   //         LOG_INF("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n", (UINT32)*feature_data);
+
+            wininfo = (SENSOR_WINSIZE_INFO_STRUCT *)(uintptr_t)(*(feature_data+1));
+
+            switch (*feature_data_32) {
+                case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[1],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[2],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[3],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_SLIM_VIDEO:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[4],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+                case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
+                default:
+                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[0],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
+                    break;
+            }
+        case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
+  //          LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",(UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
+            ihdr_write_shutter_gain((UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
+            break;
+        default:
+            break;
+    }
+
+    return ERROR_NONE;
+}    /*    feature_control()  */
+
+static SENSOR_FUNCTION_STRUCT sensor_func = {
+    open,
+    get_info,
+    get_resolution,
+    feature_control,
+    control,
+    close
+};
+
+UINT32 SP5409SUBMIPISensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
+{
+    /* To Do : Check Sensor status here */
+    if (pfFunc!=NULL)
+        *pfFunc=&sensor_func;
+    return ERROR_NONE;
+}    /*    SP5409MIPISensorInit    */
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/sp5409sub_mipi_raw/sp5409submipi_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/sp5409sub_mipi_raw/sp5409submipi_Sensor.h
new file mode 100644
index 0000000..54007e4
--- /dev/null
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/sp5409sub_mipi_raw/sp5409submipi_Sensor.h
@@ -0,0 +1,119 @@
+/*****************************************************************************
+ *
+ * Filename:
+ * ---------
+ *     sp5409mipi_Sensor.h
+ *
+ * Project:
+ * --------
+ *     ALPS
+ *
+ * Description:
+ * ------------
+ *     CMOS sensor header file
+ *
+ ****************************************************************************/
+#ifndef _SP5409MIPI_SENSOR_H
+#define _SP5409MIPI_SENSOR_H
+
+
+typedef enum{
+    IMGSENSOR_MODE_INIT,
+    IMGSENSOR_MODE_PREVIEW,
+    IMGSENSOR_MODE_CAPTURE,
+    IMGSENSOR_MODE_VIDEO,
+    IMGSENSOR_MODE_HIGH_SPEED_VIDEO,
+    IMGSENSOR_MODE_SLIM_VIDEO,
+} IMGSENSOR_MODE;
+
+typedef struct imgsensor_mode_struct {
+    kal_uint32 pclk;                //record different mode's pclk
+    kal_uint32 linelength;            //record different mode's linelength
+    kal_uint32 framelength;            //record different mode's framelength
+
+    kal_uint8 startx;                //record different mode's startx of grabwindow
+    kal_uint8 starty;                //record different mode's startx of grabwindow
+
+    kal_uint16 grabwindow_width;    //record different mode's width of grabwindow
+    kal_uint16 grabwindow_height;    //record different mode's height of grabwindow
+
+    /*     following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario    */
+    kal_uint8 mipi_data_lp2hs_settle_dc;
+
+    /*     following for GetDefaultFramerateByScenario()    */
+    kal_uint16 max_framerate;
+
+} imgsensor_mode_struct;
+
+/* SENSOR PRIVATE STRUCT FOR VARIABLES*/
+typedef struct imgsensor_struct {
+    kal_uint8 mirror;                //mirrorflip information
+
+    kal_uint8 sensor_mode;            //record IMGSENSOR_MODE enum value
+
+    kal_uint32 shutter;                //current shutter
+    kal_uint16 gain;                //current gain
+
+    kal_uint32 pclk;                //current pclk
+
+    kal_uint32 frame_length;        //current framelength
+    kal_uint32 line_length;            //current linelength
+
+    kal_uint32 min_frame_length;    //current min  framelength to max framerate
+    kal_uint16 dummy_pixel;            //current dummypixel
+    kal_uint16 dummy_line;            //current dummline
+
+    kal_uint16 current_fps;            //current max fps
+    kal_bool   autoflicker_en;        //record autoflicker enable or disable
+    kal_bool test_pattern;            //record test pattern mode or not
+    MSDK_SCENARIO_ID_ENUM current_scenario_id;//current scenario id
+    kal_uint8  ihdr_en;                //ihdr enable or disable
+
+    kal_uint8 i2c_write_id;            //record current sensor's i2c write id
+} imgsensor_struct;
+
+/* SENSOR PRIVATE STRUCT FOR CONSTANT*/
+typedef struct imgsensor_info_struct {
+    kal_uint32 sensor_id;            //record sensor id defined in Kd_imgsensor.h
+    kal_uint32 checksum_value;        //checksum value for Camera Auto Test
+    imgsensor_mode_struct pre;        //preview scenario relative information
+    imgsensor_mode_struct cap;        //capture scenario relative information
+    imgsensor_mode_struct cap1;        //capture for PIP 24fps relative information, capture1 mode must use same framelength, linelength with Capture mode for shutter calculate
+    imgsensor_mode_struct normal_video;//normal video  scenario relative information
+    imgsensor_mode_struct hs_video;    //high speed video scenario relative information
+    imgsensor_mode_struct slim_video;    //slim video for VT scenario relative information
+
+    kal_uint8  ae_shut_delay_frame;    //shutter delay frame for AE cycle
+    kal_uint8  ae_sensor_gain_delay_frame;    //sensor gain delay frame for AE cycle
+    kal_uint8  ae_ispGain_delay_frame;    //isp gain delay frame for AE cycle
+    kal_uint8  ihdr_support;        //1, support; 0,not support
+    kal_uint8  ihdr_le_firstline;    //1,le first ; 0, se first
+    kal_uint8  sensor_mode_num;        //support sensor mode num
+
+    kal_uint8  cap_delay_frame;        //enter capture delay frame num
+    kal_uint8  pre_delay_frame;        //enter preview delay frame num
+    kal_uint8  video_delay_frame;    //enter video delay frame num
+    kal_uint8  hs_video_delay_frame;    //enter high speed video  delay frame num
+    kal_uint8  slim_video_delay_frame;    //enter slim video delay frame num
+
+    kal_uint8  margin;                //sensor framelength & shutter margin
+    kal_uint32 min_shutter;            //min shutter
+    kal_uint32 max_frame_length;    //max framelength by sensor register's limitation
+
+    kal_uint8  isp_driving_current;    //mclk driving current
+    kal_uint8  sensor_interface_type;//sensor_interface_type
+    kal_uint8  mipi_sensor_type; //0,MIPI_OPHY_NCSI2; 1,MIPI_OPHY_CSI2, default is NCSI2, don't modify this para
+    kal_uint8  mipi_settle_delay_mode; //0, high speed signal auto detect; 1, use settle delay,unit is ns, default is auto detect, don't modify this para
+    kal_uint8  sensor_output_dataformat;//sensor output first pixel color
+    kal_uint8  mclk;                //mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
+
+    kal_uint8  mipi_lane_num;        //mipi lane num
+    kal_uint8  i2c_addr_table[5];    //record sensor support all write id addr, only supprt 4must end with 0xff
+    kal_uint32  i2c_speed;     //i2c speed
+} imgsensor_info_struct;
+
+extern int iReadRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u8 * a_pRecvData, u16 a_sizeRecvData, u16 i2cId);
+extern int iWriteRegI2C(u8 *a_pSendData , u16 a_sizeSendData, u16 i2cId);
+extern void kdSetI2CSpeed(u16 i2cSpeed);
+
+#endif
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/sp8408_mipi_raw/Makefile b/drivers/misc/mediatek/imgsensor/src/mt6735m/sp8408_mipi_raw/Makefile
old mode 100644
new mode 100755
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/sp8408_mipi_raw/sp8408mipiraw_CameraCustomized.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/sp8408_mipi_raw/sp8408mipiraw_CameraCustomized.h
old mode 100644
new mode 100755
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/sp8408_mipi_raw/sp8408mipiraw_Camera_Sensor_para.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/sp8408_mipi_raw/sp8408mipiraw_Camera_Sensor_para.h
old mode 100644
new mode 100755
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/sp8408_mipi_raw/sp8408mipiraw_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/sp8408_mipi_raw/sp8408mipiraw_Sensor.c
old mode 100644
new mode 100755
index 5e9ad2a..870cbed
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/sp8408_mipi_raw/sp8408mipiraw_Sensor.c
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/sp8408_mipi_raw/sp8408mipiraw_Sensor.c
@@ -142,7 +142,7 @@ static imgsensor_info_struct imgsensor_info = {
 	
 	.isp_driving_current = ISP_DRIVING_8MA, //mclk driving current
 	.sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,//sensor_interface_type
-	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_Gb,//sensor output first pixel color
+	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_Gr,//sensor output first pixel color
 	.mclk = 24,//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
 	.mipi_lane_num = SENSOR_MIPI_2_LANE,//mipi lane num
 	.i2c_addr_table = {0x6c, 0xff},//record sensor support all write id addr, only supprt 4must end with 0xff  //2015-1-14 sp_miao
@@ -150,7 +150,7 @@ static imgsensor_info_struct imgsensor_info = {
 
 
 static imgsensor_struct imgsensor = {
-	.mirror = IMAGE_NORMAL,				//mirrorflip information
+	.mirror = IMAGE_HV_MIRROR,				//mirrorflip information
 	.sensor_mode = IMGSENSOR_MODE_INIT, //IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
 	.shutter = 0x00bb,					//current shutter
 	.gain = 0x200,						//current gain
@@ -520,7 +520,7 @@ write_cmos_sensor(0x3238,0x0003);//, Reserved;wm
 write_cmos_sensor(0x3239,0x0003);//, Reserved;wm
 write_cmos_sensor(0x323A,0x0005);//, Reserved;wm
 write_cmos_sensor(0x323B,0x0006);//, -/-/-/-/-/-/LSC_EN/SHD_GRID_EN;
-write_cmos_sensor(0x3243,0x0003);//, -/-/-/-/-/-/LSC_EN/SHD_GRID_EN;
+write_cmos_sensor(0x3243,0x0000);//, -/-/-/-/-/-/LSC_EN/SHD_GRID_EN;
 write_cmos_sensor(0x3244,0x0008);//, Reserved;
 write_cmos_sensor(0x3245,0x0001);//, Reserved;
 write_cmos_sensor(0x3307,0x0019);//, Reserved;
@@ -789,7 +789,7 @@ static kal_uint32 get_imgsensor_id(UINT32 *sensor_id)
 }
 #define SP8408MIPI_USE_OTP
 #ifdef SP8408MIPI_USE_OTP
-void ReadOTP(int page, UINT8 *rbuf){
+static void ReadOTP(int page, UINT8 *rbuf){
 	int i;
 	write_cmos_sensor( 0x4A00, 0x01);
 	write_cmos_sensor( 0x4A02, page);
@@ -799,7 +799,15 @@ void ReadOTP(int page, UINT8 *rbuf){
 	write_cmos_sensor( 0x4A00, 0x00);
 }
 
-void SP8408MIPI_update_lenc()
+
+static void ReadParam_012Page(UINT8 page, UINT8 *pbuf){
+	int i;
+	UINT8 rbuf[64];
+	ReadOTP(page, rbuf);
+	for(i=0;i<32;i++) pbuf[i]=rbuf[i] | rbuf[32+i];
+}
+
+static void SP8408MIPI_update_lenc()
 {
 	UINT8 sp8408_buf_3[64];
 	UINT8 sp8408_buf_4[64];
@@ -879,7 +887,7 @@ void SP8408MIPI_update_lenc()
 
 
 }
-kal_uint16 SP5408MIPI_update_lenc_register_from_otp(void)
+static kal_uint16 SP8408MIPI_update_lenc_register_from_otp(void)
 {
 	UINT8 sp8408_buf_0[64];
 	UINT8 *p_buf = sp8408_buf_0;
@@ -893,16 +901,45 @@ kal_uint16 SP5408MIPI_update_lenc_register_from_otp(void)
 	    SP8408MIPI_update_lenc();
 	else
 	{
-		return 1;
+		
 	       LOG_INF("[gpw ] no valid LSC OTP data!\n");
+		   return 1;
 	}
    	
    return 0;
    
 
 }
+static kal_uint16 GetOtpCpId()
+{
 
+	UINT8 sp8408_buf[64];
+	UINT8 *p_buf = sp8408_buf;
+	ReadOTP(15,p_buf);
+   
+	kal_uint8 sensorIDH0 =sp8408_buf[32] ;
+    kal_uint8 sensorIDl0 =sp8408_buf[33] ; 
+	kal_uint8 sensorIDH1 =sp8408_buf[34] ;
+    kal_uint8 sensorIDl1 =sp8408_buf[35] ;
+	kal_uint8 sensorIDH2 =sp8408_buf[36] ;
+    kal_uint8 sensorIDl2 =sp8408_buf[37] ;
+	kal_uint8 sensorIDH = sensorIDH0 | sensorIDH1 | sensorIDH2;
+	kal_uint8 sensorIDl = sensorIDl0 | sensorIDl1 | sensorIDl2;
+   return ((sensorIDH<<8) + sensorIDl);
+}
+static kal_uint16 GetOtpId()
+{
 
+	UINT8 sp8408_buf[32];
+	UINT8 *p_buf = sp8408_buf;
+	ReadParam_012Page(0,p_buf);
+    kal_uint16 oknum = sp8408_buf[5];
+	ReadParam_012Page(2,p_buf);
+	oknum = 20+(((oknum&0x04)>>2)+((oknum&0x02)>>1)+(oknum&0x1))*3;
+	 kal_uint8 sensorIDH =sp8408_buf[oknum] ;
+    kal_uint8 sensorIDl =sp8408_buf[oknum+1] ; 
+   return ((sensorIDH<<8) + sensorIDl);
+}
 #endif
 /*************************************************************************
 * FUNCTION
@@ -929,11 +966,16 @@ static kal_uint32 open(void)
 	LOG_INF("MIPI 4LANE\n");
 	//LOG_INF("preview 1280*960@30fps,864Mbps/lane; video 1280*960@30fps,864Mbps/lane; capture 5M@30fps,864Mbps/lane\n");
 #ifdef SP8408MIPI_USE_OTP
+
+
+   kal_uint16 sensorIDtest = GetOtpId() ;
+   kal_uint16 sensorIDtest_Cp = GetOtpCpId();
+   printk("gpw  sensorIDtest 0x%x, sensorIDtest_Cp:0x%x\n",sensorIDtest,sensorIDtest_Cp );	
    
-	printk("[SP8408MIPI_USE_OTP] before update otp wb...........................................\n");
+   if ((sensorIDtest != 0x8408)&&(sensorIDtest_Cp != 0x8408 ))
+   return ERROR_SENSOR_CONNECT_FAIL;
 
-	//ret = sp8408_update_otp_wb();
-    SP5408MIPI_update_lenc_register_from_otp();
+    SP8408MIPI_update_lenc_register_from_otp();
 	
 #endif
 	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
@@ -961,6 +1003,7 @@ static kal_uint32 open(void)
 	/* initail sequence write in  */
 	sensor_init();
 	mdelay(10);
+	set_mirror_flip(imgsensor.mirror);
 	spin_lock(&imgsensor_drv_lock);
 
 	imgsensor.autoflicker_en= KAL_FALSE;
@@ -1524,7 +1567,7 @@ static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
             set_max_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data, *(feature_data+1));
 			break;
 		case SENSOR_FEATURE_GET_DEFAULT_FRAME_RATE_BY_SCENARIO:
-            //get_default_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*(feature_data), (MUINT32 *)(uintptr_t)(*(feature_data+1)));
+            get_default_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*(feature_data), (MUINT32 *)(uintptr_t)(*(feature_data+1)));
 			break;
 		case SENSOR_FEATURE_SET_TEST_PATTERN:
             set_test_pattern_mode((BOOL)*feature_data);
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/sp8408_mipi_raw/sp8408mipiraw_Sensor.h b/drivers/misc/mediatek/imgsensor/src/mt6735m/sp8408_mipi_raw/sp8408mipiraw_Sensor.h
old mode 100644
new mode 100755
diff --git a/drivers/misc/mediatek/mach/mt6735/benefit_m7/camera/camera/kd_camera_hw.c b/drivers/misc/mediatek/mach/mt6735/benefit_m7/camera/camera/kd_camera_hw.c
index d590e1b..a732a4a 100755
--- a/drivers/misc/mediatek/mach/mt6735/benefit_m7/camera/camera/kd_camera_hw.c
+++ b/drivers/misc/mediatek/mach/mt6735/benefit_m7/camera/camera/kd_camera_hw.c
@@ -35,6 +35,13 @@
 #define PK_XLOG_INFO(fmt, args...)
 #endif
 
+#ifndef FALSE
+  #define FALSE 0
+#endif
+#ifndef TRUE
+  #define TRUE 1
+#endif
+
 /*
 #ifndef BOOL
 typedef unsigned char BOOL;
@@ -129,6 +136,8 @@ int kdCISModulePowerOn(CAMERA_DUAL_CAMERA_SENSOR_ENUM SensorIdx, char *currSenso
 {
 
 u32 pinSetIdx = 0;//default main sensor
+bool camera_pdn_reverse = FALSE;
+bool camera_pdn1_reverse = FALSE;
 
 #define IDX_PS_CMRST 0
 #define IDX_PS_CMPDN 4
@@ -149,8 +158,8 @@ u32 pinSet[3][8] = {
                         GPIO_OUT_ZERO,
                      },
                      //for sub sensor
-                     {  CAMERA_CMRST_PIN,
-                        CAMERA_CMRST_PIN_M_GPIO,
+                     {  CAMERA_CMRST1_PIN,
+                        CAMERA_CMRST1_PIN_M_GPIO,
                         GPIO_OUT_ONE,
                         GPIO_OUT_ZERO,
                         CAMERA_CMPDN1_PIN,
@@ -182,6 +191,43 @@ u32 pinSet[3][8] = {
         pinSetIdx = 2;
     }
 
+    if((pinSetIdx == 0) &&
+       currSensorName &&
+       ((0 == strcmp(SENSOR_DRVNAME_GC2755_MIPI_RAW, currSensorName)) ||
+		(0 == strcmp(SENSOR_DRVNAME_GC2355_MIPI_RAW, currSensorName)) ||
+		(0 == strcmp(SENSOR_DRVNAME_GC2235_MIPI_RAW, currSensorName)) ||
+		(0 == strcmp(SENSOR_DRVNAME_GC2145_MIPI_YUV, currSensorName)) ||
+        (0 == strcmp(SENSOR_DRVNAME_SP2508_MIPI_RAW, currSensorName)) ||
+        (0 == strcmp(SENSOR_DRVNAME_SP5409_MIPI_RAW, currSensorName)) ||
+		(0 == strcmp(SENSOR_DRVNAME_GC2155_MIPI_YUV, currSensorName))))
+    {
+        camera_pdn_reverse = TRUE;
+    }
+
+    if((pinSetIdx == 1) &&
+       currSensorName &&
+       ((0 == strcmp(SENSOR_DRVNAME_GC2755_MIPI_RAW, currSensorName)) ||
+        (0 == strcmp(SENSOR_DRVNAME_GC2355_MIPI_RAW, currSensorName)) ||
+        (0 == strcmp(SENSOR_DRVNAME_GC2235_MIPI_RAW, currSensorName)) ||
+		(0 == strcmp(SENSOR_DRVNAME_GC2145_MIPI_YUV, currSensorName)) ||
+		(0 == strcmp(SENSOR_DRVNAME_GC2155_MIPI_YUV, currSensorName)) ||
+        (0 == strcmp(SENSOR_DRVNAME_SP2508_MIPI_RAW, currSensorName)) ||
+		(0 == strcmp(SENSOR_DRVNAME_GC0310_MIPI_YUV, currSensorName))))
+    {
+        camera_pdn1_reverse = TRUE;
+    }
+
+    if(camera_pdn_reverse)
+    {
+        pinSet[0][IDX_PS_CMPDN+IDX_PS_ON] = GPIO_OUT_ZERO;
+        pinSet[0][IDX_PS_CMPDN+IDX_PS_OFF] = GPIO_OUT_ONE;
+    }
+
+    if(camera_pdn1_reverse)
+    {
+        pinSet[1][IDX_PS_CMPDN+IDX_PS_ON] = GPIO_OUT_ZERO;
+        pinSet[1][IDX_PS_CMPDN+IDX_PS_OFF] = GPIO_OUT_ONE;
+    }
 
     //power ON
     if (On) {
@@ -189,6 +235,12 @@ u32 pinSet[3][8] = {
             ISP_MCLK1_EN(1);
 
         PK_DBG("[PowerON]pinSetIdx:%d, currSensorName: %s\n", pinSetIdx, currSensorName);
+#ifdef GPIO_CAMERA_AF_EN_PIN
+		mt_set_gpio_mode(GPIO_CAMERA_AF_EN_PIN,GPIO_MODE_00);
+		mt_set_gpio_dir(GPIO_CAMERA_AF_EN_PIN,GPIO_DIR_OUT);
+		mt_set_gpio_out(GPIO_CAMERA_AF_EN_PIN,GPIO_OUT_ONE);
+#endif
+
 
         if ((currSensorName && (0 == strcmp(currSensorName,"imx135mipiraw")))||
             (currSensorName && (0 == strcmp(currSensorName,"imx220mipiraw"))))
@@ -255,299 +307,693 @@ u32 pinSet[3][8] = {
             }
 
         }
-        else if (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV5648_MIPI_RAW, currSensorName)) && (pinSetIdx == 0))
+        else if ((currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV2680_MIPI_RAW, currSensorName))) \
+                                                                                                      )
         {
-           // mt_set_gpio_mode(GPIO_SPI_MOSI_PIN,GPIO_MODE_00);
-           // mt_set_gpio_dir(GPIO_SPI_MOSI_PIN,GPIO_DIR_OUT);
-           // mt_set_gpio_out(GPIO_SPI_MOSI_PIN,GPIO_OUT_ONE);
+      #ifdef GPIO_CAMERA_LDO_EN_PIN
+            mt_set_gpio_mode(GPIO_CAMERA_LDO_EN_PIN,GPIO_MODE_00);
+            mt_set_gpio_dir(GPIO_CAMERA_LDO_EN_PIN,GPIO_DIR_OUT);
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ONE);
+#endif
             //First Power Pin low and Reset Pin Low
             if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
                 if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
                 if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
                 if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
             }
-			mdelay(2);
+
             if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
                 if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
                 if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
                 if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
-			mdelay(2);
             }
 
-	     //VCAM_A
+
+            //VCAM_IO
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+        //        goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
+
+            //VCAM_A
             if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
             {
                 PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+       //         goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
+            if(TRUE != _hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1600,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", SUB_CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(5);
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1600,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", CAMERA_POWER_VCAM_D);
+     //            goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
+
+            //AF_VCC
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+      //          goto _kdCISModulePowerOn_exit_;
+            }
+
+
+            mdelay(1);
+
+
+            //enable active sensor
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+
+            mdelay(2);
+
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+
+            }
+
+            mdelay(20);
+        }
+        else if (currSensorName && (0 == strcmp(SENSOR_DRVNAME_S5K3M2_MIPI_RAW, currSensorName))){
+        #ifdef GPIO_CAMERA_LDO_EN_PIN
+            mt_set_gpio_mode(GPIO_CAMERA_LDO_EN_PIN,GPIO_MODE_00);
+            mt_set_gpio_dir(GPIO_CAMERA_LDO_EN_PIN,GPIO_DIR_OUT);
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ONE);
+        #endif
+            //First Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){
+                    PK_DBG("[CAMERA LENS] set gpio mode  failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){
+                    PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){
+                    PK_DBG("[CAMERA LENS] set gpio         failed!! (CMPDN)\n");
+                }
+            }
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){
+                    PK_DBG("[CAMERA SENSOR] set gpio     mode failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){
+                    PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){
+                    PK_DBG("[CAMERA SENSOR] set gpio       failed!! (CMRST)\n");
+                }
+            }
+            //VCAM_D
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1100,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+                goto _kdCISModulePowerOn_exit_;
+            }
+            //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name)){
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+            //VCAM_IO
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name)){
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+            //AF_VCC
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name)){
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
                 goto _kdCISModulePowerOn_exit_;
             }
 
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){
+                    PK_DBG("[CAMERA LENS] set gpio mode  failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){
+                    PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){
+                    PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");
+                }
+            }
             mdelay(2);
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){
+                    PK_DBG("[CAMERA SENSOR] set gpio     mode failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){
+                    PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){
+                    PK_DBG("[CAMERA SENSOR] set gpio        failed!! (CMRST)\n");
+                }
+            }
+       }
+        else if(currSensorName && (0 == strcmp(SENSOR_DRVNAME_GC2035_YUV, currSensorName)))
+        {
+
+        #ifdef GPIO_CAMERA_LDO_EN_PIN
+            mt_set_gpio_mode(GPIO_CAMERA_LDO_EN_PIN,GPIO_MODE_00);
+            mt_set_gpio_dir(GPIO_CAMERA_LDO_EN_PIN,GPIO_DIR_OUT);
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ONE);
+        #endif
+                mdelay(5); 
+            //First Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){
+                      PK_DBG("[CAMERA LENS] set gpio mode  failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){
+                      PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){
+                      PK_DBG("[CAMERA LENS] set gpio         failed!! (CMPDN)\n");
+                }
+            }    
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){
+                      PK_DBG("[CAMERA SENSOR] set gpio     mode failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){
+                      PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){
+                      PK_DBG("[CAMERA SENSOR] set gpio       failed!! (CMRST)\n");
+                }
+            } 
+
+            //VCAM_D        
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1200,mode_name))
+            {
+                     PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+                     goto _kdCISModulePowerOn_exit_;
+            }
+            mdelay(5);
+            //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+                goto _kdCISModulePowerOn_exit_;
+            }
+            mdelay(5);
             //VCAM_IO
             if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
             {
                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
                 goto _kdCISModulePowerOn_exit_;
             }
+            mdelay(5);
+             //AF_VCC
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                goto _kdCISModulePowerOn_exit_;
+            }
+            mdelay(5);
 
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){
+                      PK_DBG("[CAMERA LENS] set gpio mode  failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){
+                      PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){
+                      PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");
+                }
+            }
             mdelay(2);
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){
+                        PK_DBG("[CAMERA SENSOR] set gpio     mode failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){
+                        PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){
+                        PK_DBG("[CAMERA SENSOR] set gpio        failed!! (CMRST)\n");
+                }
 
-            if(TRUE != _hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1500,mode_name))
+            }
+        }
+        else if(currSensorName && (0 == strcmp(SENSOR_DRVNAME_S5K4H5YC_MIPI_RAW, currSensorName)))
+        {
+
+        #ifdef GPIO_CAMERA_LDO_EN_PIN
+            mt_set_gpio_mode(GPIO_CAMERA_LDO_EN_PIN,GPIO_MODE_00);
+            mt_set_gpio_dir(GPIO_CAMERA_LDO_EN_PIN,GPIO_DIR_OUT);
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ONE);
+        #endif
+                 
+            //First Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){
+                      PK_DBG("[CAMERA LENS] set gpio mode  failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){
+                      PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){
+                      PK_DBG("[CAMERA LENS] set gpio         failed!! (CMPDN)\n");
+                }
+            }    
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){
+                      PK_DBG("[CAMERA SENSOR] set gpio     mode failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){
+                      PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){
+                      PK_DBG("[CAMERA SENSOR] set gpio       failed!! (CMRST)\n");
+                }
+            } 
+
+            //VCAM_D        
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1200,mode_name))
             {
-                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", SUB_CAMERA_POWER_VCAM_D);
-                 goto _kdCISModulePowerOn_exit_;
+                     PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+                     goto _kdCISModulePowerOn_exit_;
+            }
+            //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+                goto _kdCISModulePowerOn_exit_;
+            }
+            //VCAM_IO
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                goto _kdCISModulePowerOn_exit_;
+            }
+             //AF_VCC
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                goto _kdCISModulePowerOn_exit_;
             }
 
-            mdelay(5);
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){
+                      PK_DBG("[CAMERA LENS] set gpio mode  failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){
+                      PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){
+                      PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");
+                }
+            }
+            mdelay(2);
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){
+                        PK_DBG("[CAMERA SENSOR] set gpio     mode failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){
+                        PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){
+                        PK_DBG("[CAMERA SENSOR] set gpio        failed!! (CMRST)\n");
+                }
+
+            }
+        }
+        else if(currSensorName && (0 == strcmp(SENSOR_DRVNAME_S5K5E2YA_MIPI_RAW, currSensorName))){
+        #ifdef GPIO_CAMERA_LDO_EN_PIN
+            mt_set_gpio_mode(GPIO_CAMERA_LDO_EN_PIN,GPIO_MODE_00);
+            mt_set_gpio_dir(GPIO_CAMERA_LDO_EN_PIN,GPIO_DIR_OUT);
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ONE);
+        #endif
+     
+            //First Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){
+                      PK_DBG("[CAMERA LENS] set gpio mode  failed!! (CMPDN)\n");
+                }    
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){
+                      PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");
+                }    
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){
+                      PK_DBG("[CAMERA LENS] set gpio         failed!! (CMPDN)\n");
+                }    
+            }    
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){
+                      PK_DBG("[CAMERA SENSOR] set gpio     mode failed!! (CMRST)\n");
+                }    
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){
+                      PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");
+                }    
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){
+                      PK_DBG("[CAMERA SENSOR] set gpio       failed!! (CMRST)\n");
+                }    
+            }    
+            mdelay(1);
+
+            //VCAM_D        
+#if 1
+            if(TRUE != _hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1200,mode_name))
+                {
+                     PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+                     goto _kdCISModulePowerOn_exit_;
+                }
+            mdelay(1);
+#endif
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1200,mode_name))
+                {
+                     PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+                     goto _kdCISModulePowerOn_exit_;
+                }
+            mdelay(1);
+            //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+                goto _kdCISModulePowerOn_exit_;
+            }
+            mdelay(1);
+            //VCAM_IO
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                goto _kdCISModulePowerOn_exit_;
+            }
+            mdelay(1);
 
             //AF_VCC
             if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
             {
                 PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
-                goto _kdCISModulePowerOn_exit_;
+      //          goto _kdCISModulePowerOn_exit_;
             }
 
 
             mdelay(1);
 
 
-           if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST])
-		{
-			if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");}
-			mdelay(5);
-	
-			//RST pin
-			if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");}
-			mdelay(5);
-		}
-		mdelay(50);
-
-	#if 1
-	        //disable inactive sensor
-	        //jeff modify for Q26 V1.1   
-	        //cause Main and Sub Cameras use the same RST pin.
-	        //so remove this part's CMRST.
-	       //disable sub
-	        if (GPIO_CAMERA_INVALID != pinSet[1][IDX_PS_CMRST]) {
-	  //          if(mt_set_gpio_mode(pinSet[1][IDX_PS_CMRST],pinSet[1][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! \n");}
-	            if(mt_set_gpio_mode(pinSet[1][IDX_PS_CMPDN],pinSet[1][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! \n");}
-	  //          if(mt_set_gpio_dir(pinSet[1][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! \n");}
-	            if(mt_set_gpio_dir(pinSet[1][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! \n");}
-	  //          if(mt_set_gpio_out(pinSet[1][IDX_PS_CMRST],pinSet[1][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");} //low == reset sensor
-	            if(mt_set_gpio_out(pinSet[1][IDX_PS_CMPDN],pinSet[1][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");} //high == power down lens module
-	        }
-	#endif
+           if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){
+                      PK_DBG("[CAMERA LENS] set gpio mode  failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){
+                      PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){
+                      PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");
+                }
+            }
+
+
+            mdelay(2);
+
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){
+                        PK_DBG("[CAMERA SENSOR] set gpio     mode failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){
+                        PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){
+                        PK_DBG("[CAMERA SENSOR] set gpio        failed!! (CMRST)\n");
+                }
+
+            }
         }
 
-/////////////////////////////////////////////////
-	else if (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV8858_MIPI_RAW, currSensorName)) && (pinSetIdx == 0))
+        else if ((currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV5648_MIPI_RAW, currSensorName))) \
+			||(currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV9760_MIPI_RAW, currSensorName)))\
+                                                                                                      )
         {
-          //  mt_set_gpio_mode(GPIO_SPI_MOSI_PIN,GPIO_MODE_00);
-          //  mt_set_gpio_dir(GPIO_SPI_MOSI_PIN,GPIO_DIR_OUT);
-          //  mt_set_gpio_out(GPIO_SPI_MOSI_PIN,GPIO_OUT_ONE);
+		#ifdef GPIO_CAMERA_LDO_EN_PIN
+            mt_set_gpio_mode(GPIO_CAMERA_LDO_EN_PIN,GPIO_MODE_00);
+            mt_set_gpio_dir(GPIO_CAMERA_LDO_EN_PIN,GPIO_DIR_OUT);
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ONE);
+		#endif
+		
             //First Power Pin low and Reset Pin Low
             if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
                 if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
                 if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
                 if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
             }
-			mdelay(2);
+
             if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
                 if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
                 if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
                 if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
-			mdelay(2);
             }
 
-	   //VCAM_A
-            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
-            {
-                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
-                goto _kdCISModulePowerOn_exit_;
-            }
 
-            mdelay(2);
             //VCAM_IO
             if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
             {
                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
-                goto _kdCISModulePowerOn_exit_;
+        //        goto _kdCISModulePowerOn_exit_;
             }
 
-            mdelay(2);
+            mdelay(1);
 
-            if(TRUE != _hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1200,mode_name))
+            //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+       //         goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
+#if 1
+            if(TRUE != _hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1500,mode_name))
             {
                  PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", SUB_CAMERA_POWER_VCAM_D);
                  goto _kdCISModulePowerOn_exit_;
             }
+#endif
 
             mdelay(5);
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1500,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", CAMERA_POWER_VCAM_D);
+     //            goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
 
             //AF_VCC
             if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
             {
                 PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
-                goto _kdCISModulePowerOn_exit_;
+      //          goto _kdCISModulePowerOn_exit_;
+            }
+
+
+            mdelay(1);
+
+
+            //enable active sensor
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
             }
 
 
             mdelay(2);
 
 
-            //PDN/STBY pin
-		if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST])
-		{
-			if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");}
-			mdelay(5);
-	
-			//RST pin
-			if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");}
-			mdelay(5);
-		}
-		mdelay(50);
-
-	#if 1
-	        //disable inactive sensor
-	        //jeff modify for Q26 V1.1   
-	        //cause Main and Sub Cameras use the same RST pin.
-	        //so remove this part's CMRST.
-	       //disable sub
-	        if (GPIO_CAMERA_INVALID != pinSet[1][IDX_PS_CMRST]) {
-	  //          if(mt_set_gpio_mode(pinSet[1][IDX_PS_CMRST],pinSet[1][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! \n");}
-	            if(mt_set_gpio_mode(pinSet[1][IDX_PS_CMPDN],pinSet[1][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! \n");}
-	  //          if(mt_set_gpio_dir(pinSet[1][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! \n");}
-	            if(mt_set_gpio_dir(pinSet[1][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! \n");}
-	  //          if(mt_set_gpio_out(pinSet[1][IDX_PS_CMRST],pinSet[1][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");} //low == reset sensor
-	            if(mt_set_gpio_out(pinSet[1][IDX_PS_CMPDN],pinSet[1][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");} //high == power down lens module
-	        }
-	#endif
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+
+            }
+
+            mdelay(20);
         }
-       else if (currSensorName && (0 == strcmp(SENSOR_DRVNAME_IMX219_MIPI_RAW, currSensorName)) && (pinSetIdx == 0))
+        else if ((currSensorName && (0 == strcmp(SENSOR_DRVNAME_HI551_MIPI_RAW, currSensorName))) ||\
+                 (currSensorName && (0 == strcmp(SENSOR_DRVNAME_HI545_MIPI_RAW, currSensorName))) ||\
+                 (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV8858_MIPI_RAW, currSensorName))) ||\
+                 (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV5670_MIPI_RAW, currSensorName))) ||\
+                 (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV5693_MIPI_RAW, currSensorName))) ||\
+                 (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV8865_MIPI_RAW, currSensorName)))   \
+                                                                                                      )
         {
-          //  mt_set_gpio_mode(GPIO_SPI_MOSI_PIN,GPIO_MODE_00);
-          //  mt_set_gpio_dir(GPIO_SPI_MOSI_PIN,GPIO_DIR_OUT);
-          //  mt_set_gpio_out(GPIO_SPI_MOSI_PIN,GPIO_OUT_ONE);
+		#ifdef GPIO_CAMERA_LDO_EN_PIN
+            mt_set_gpio_mode(GPIO_CAMERA_LDO_EN_PIN,GPIO_MODE_00);
+            mt_set_gpio_dir(GPIO_CAMERA_LDO_EN_PIN,GPIO_DIR_OUT);
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ONE);
+		#endif
+		
             //First Power Pin low and Reset Pin Low
             if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
                 if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
                 if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
                 if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
             }
-			mdelay(2);
+
             if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
                 if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
                 if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
                 if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
-			mdelay(2);
-            }
-
-	   //VCAM_A
-            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
-            {
-                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
-                goto _kdCISModulePowerOn_exit_;
             }
 
-            mdelay(2);
+
             //VCAM_IO
             if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
             {
                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
-                goto _kdCISModulePowerOn_exit_;
+        //        goto _kdCISModulePowerOn_exit_;
             }
 
-            mdelay(2);
+            mdelay(1);
+
+            //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+       //         goto _kdCISModulePowerOn_exit_;
+            }
 
+            mdelay(1);
+#if 1
             if(TRUE != _hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1200,mode_name))
             {
                  PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", SUB_CAMERA_POWER_VCAM_D);
                  goto _kdCISModulePowerOn_exit_;
             }
+#endif
 
             mdelay(5);
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1200,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", CAMERA_POWER_VCAM_D);
+     //            goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
 
             //AF_VCC
             if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
             {
                 PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
-                goto _kdCISModulePowerOn_exit_;
+      //          goto _kdCISModulePowerOn_exit_;
+            }
+
+
+            mdelay(1);
+
+
+            //enable active sensor
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
             }
 
 
             mdelay(2);
 
 
-            //PDN/STBY pin
-		if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST])
-		{
-			if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");}
-			mdelay(5);
-	
-			//RST pin
-			if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");}
-			mdelay(5);
-		}
-		mdelay(50);
-
-	#if 1
-	        //disable inactive sensor
-	        //jeff modify for Q26 V1.1   
-	        //cause Main and Sub Cameras use the same RST pin.
-	        //so remove this part's CMRST.
-	       //disable sub
-	        if (GPIO_CAMERA_INVALID != pinSet[1][IDX_PS_CMRST]) {
-	  //          if(mt_set_gpio_mode(pinSet[1][IDX_PS_CMRST],pinSet[1][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! \n");}
-	            if(mt_set_gpio_mode(pinSet[1][IDX_PS_CMPDN],pinSet[1][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! \n");}
-	  //          if(mt_set_gpio_dir(pinSet[1][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! \n");}
-	            if(mt_set_gpio_dir(pinSet[1][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! \n");}
-	  //          if(mt_set_gpio_out(pinSet[1][IDX_PS_CMRST],pinSet[1][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");} //low == reset sensor
-	            if(mt_set_gpio_out(pinSet[1][IDX_PS_CMPDN],pinSet[1][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");} //high == power down lens module
-	        }
-	#endif
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+
+            }
+
+            mdelay(20);
         }
-     else if (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV2680_MIPI_RAW, currSensorName)) && (pinSetIdx == 1))
+        else  if ((currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC0310_MIPI_YUV, currSensorName))) ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_SP2508_MIPI_RAW, currSensorName)))      ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_SP5409_MIPI_RAW, currSensorName)))      ||\ 
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC2755_MIPI_RAW, currSensorName))) ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC2145_MIPI_YUV, currSensorName))) ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC2235_MIPI_RAW, currSensorName))) ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC2355_MIPI_RAW, currSensorName))) \
+                                                                                                  )
         {
-          //  mt_set_gpio_mode(GPIO_SPI_MOSI_PIN,GPIO_MODE_00);
-          //  mt_set_gpio_dir(GPIO_SPI_MOSI_PIN,GPIO_DIR_OUT);
-          //  mt_set_gpio_out(GPIO_SPI_MOSI_PIN,GPIO_OUT_ONE);
+		#ifdef GPIO_CAMERA_LDO_EN_PIN
+           mt_set_gpio_mode(GPIO_CAMERA_LDO_EN_PIN,GPIO_MODE_00);
+           mt_set_gpio_dir(GPIO_CAMERA_LDO_EN_PIN,GPIO_DIR_OUT);
+           mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ONE);
+		#endif
+		#ifdef GPIO_CAMERASUB_LDO_EN_PIN
+           mt_set_gpio_mode(GPIO_CAMERASUB_LDO_EN_PIN,GPIO_MODE_00);
+           mt_set_gpio_dir(GPIO_CAMERASUB_LDO_EN_PIN,GPIO_DIR_OUT);
+           mt_set_gpio_out(GPIO_CAMERASUB_LDO_EN_PIN,GPIO_OUT_ONE);
+		#endif
+#if 0
             //First Power Pin low and Reset Pin Low
-           if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
-	            if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! \n");}
-	            if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! \n");}
-	            if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");}
-	            mdelay(10);
-
-	            //PDN pin
-	            if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! \n");}
-	            if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! \n");}
-	            if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");}
-	        }
-	//VCAM_IO
-            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
-            {
-                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
-                goto _kdCISModulePowerOn_exit_;
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
             }
 
-            mdelay(10);
-	   //VCAM_A
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+
+            mdelay(50);
+#endif
+            //VCAM_A
             if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
             {
                 PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
-                goto _kdCISModulePowerOn_exit_;
+         //       goto _kdCISModulePowerOn_exit_;
             }
 
             mdelay(10);
-            
 
-            if(TRUE != _hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1500,mode_name))
+            //VCAM_IO
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+          //      goto _kdCISModulePowerOn_exit_;
+            }
+#if 1
+            mdelay(10);
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1800,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", CAMERA_POWER_VCAM_D);
+           //      goto _kdCISModulePowerOn_exit_;
+            }
+#endif
+            mdelay(1);
+
+            if(TRUE != _hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1800,mode_name))
             {
                  PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", SUB_CAMERA_POWER_VCAM_D);
-                 goto _kdCISModulePowerOn_exit_;
+     //            goto _kdCISModulePowerOn_exit_;
             }
 
             mdelay(10);
-
+#if 1//def VANZO_FEATURE_GC2755MIPIRAW_FOCUS_EN
             //AF_VCC
             if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
             {
@@ -555,48 +1001,39 @@ u32 pinSet[3][8] = {
                 goto _kdCISModulePowerOn_exit_;
             }
 
+#endif
+            mdelay(50);
 
-            mdelay(10);
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+                mdelay(5);
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
 
+            }
+            mdelay(5);
+            //enable active sensor
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+                mdelay(5);
+                //if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
 
-            #if 1
-	        //enable active sensor
-	        if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
-	            //PDN pin
-	            if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! \n");}
-	            if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! \n");}
-	            if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");}
-
-				
-	        //    if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! \n");}
-	        //    if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! \n");}
-	        //    if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");}
-	        //    mdelay(1);
-
-	        }
-#endif
-	#if 1
-	        //disable inactive sensor
-	        //jeff modify for Q26 V1.1   
-	        //cause Main and Sub Cameras use the same RST pin.
-	        //so remove this part's CMRST.
-	        if (GPIO_CAMERA_INVALID != pinSet[0][IDX_PS_CMRST]) {
-	  //          if(mt_set_gpio_mode(pinSet[0][IDX_PS_CMRST],pinSet[0][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! \n");}
-	            if(mt_set_gpio_mode(pinSet[0][IDX_PS_CMPDN],pinSet[0][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! \n");}
-	  //          if(mt_set_gpio_dir(pinSet[0][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! \n");}
-	            if(mt_set_gpio_dir(pinSet[0][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! \n");}
-	  //          if(mt_set_gpio_out(pinSet[0][IDX_PS_CMRST],pinSet[0][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");} //low == reset sensor
-	            if(mt_set_gpio_out(pinSet[0][IDX_PS_CMPDN],pinSet[0][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");} //high == power down lens module
-	        }
-	#endif
+            mdelay(5);
         }
-///////////////////////////////////////////
-
-        else  if (currSensorName && (0 == strcmp(SENSOR_DRVNAME_GC2355_MIPI_RAW, currSensorName)))
+        else  if ((currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC0330_YUV,currSensorName))) ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC0330_YUV,currSensorName))) \
+				                                                                                   )
         {
-           // mt_set_gpio_mode(GPIO_SPI_MOSI_PIN,GPIO_MODE_00);
-          //  mt_set_gpio_dir(GPIO_SPI_MOSI_PIN,GPIO_DIR_OUT);
-           // mt_set_gpio_out(GPIO_SPI_MOSI_PIN,GPIO_OUT_ONE);
+    #ifdef GPIO_CAMERA_LDO_EN_PIN
+           mt_set_gpio_mode(GPIO_CAMERA_LDO_EN_PIN,GPIO_MODE_00);
+           mt_set_gpio_dir(GPIO_CAMERA_LDO_EN_PIN,GPIO_DIR_OUT);
+           mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ONE);
+    #endif
+#if 0
             //First Power Pin low and Reset Pin Low
             if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
                 if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
@@ -611,33 +1048,47 @@ u32 pinSet[3][8] = {
             }
 
             mdelay(50);
-
+#endif
             //VCAM_A
             if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
             {
                 PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
-                goto _kdCISModulePowerOn_exit_;
+         //       goto _kdCISModulePowerOn_exit_;
             }
 
             mdelay(10);
 
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1500,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", CAMERA_POWER_VCAM_D);
+           //      goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
+
             //VCAM_IO
             if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
             {
                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
-                goto _kdCISModulePowerOn_exit_;
+          //      goto _kdCISModulePowerOn_exit_;
             }
-
+#if 0
             mdelay(10);
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1800,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", CAMERA_POWER_VCAM_D);
+           //      goto _kdCISModulePowerOn_exit_;
+            }
+#endif
+            mdelay(1);
 
-            if(TRUE != _hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1500,mode_name))
+            if(TRUE != _hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1800,mode_name))
             {
                  PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", SUB_CAMERA_POWER_VCAM_D);
-                 goto _kdCISModulePowerOn_exit_;
+     //            goto _kdCISModulePowerOn_exit_;
             }
 
             mdelay(10);
-
             //AF_VCC
             if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
             {
@@ -645,7 +1096,6 @@ u32 pinSet[3][8] = {
                 goto _kdCISModulePowerOn_exit_;
             }
 
-
             mdelay(50);
 
             if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
@@ -670,6 +1120,12 @@ u32 pinSet[3][8] = {
         }
         else
         {
+		#ifdef GPIO_CAMERA_LDO_EN_PIN
+           mt_set_gpio_mode(GPIO_CAMERA_LDO_EN_PIN,GPIO_MODE_00);
+           mt_set_gpio_dir(GPIO_CAMERA_LDO_EN_PIN,GPIO_DIR_OUT);
+           mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ONE);
+		#endif
+		
             //First Power Pin low and Reset Pin Low
             if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
                 if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
@@ -721,6 +1177,12 @@ u32 pinSet[3][8] = {
                 }
 
             }
+            if(TRUE != hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1500,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+
 
 
              //AF_VCC
@@ -752,6 +1214,10 @@ u32 pinSet[3][8] = {
 
         PK_DBG("[PowerOFF]pinSetIdx:%d\n", pinSetIdx);
             ISP_MCLK1_EN(0);
+#ifdef GPIO_CAMERA_AF_EN_PIN
+			mt_set_gpio_out(GPIO_CAMERA_AF_EN_PIN,GPIO_OUT_ZERO);
+#endif
+
 
         if ((currSensorName && (0 == strcmp(currSensorName,"imx135mipiraw")))||
             (currSensorName && (0 == strcmp(currSensorName,"imx220mipiraw"))))
@@ -800,37 +1266,46 @@ u32 pinSet[3][8] = {
             }
 
         }
-        else if (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV5648_MIPI_RAW, currSensorName)) && (pinSetIdx == 0))
+        else if ((currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV2680_MIPI_RAW, currSensorName))) \
+                                                                                                      )
         {
-             //PK_DBG("[OFF]sensorIdx:%d \n",SensorIdx);
-	        printk("[CAMERA SENSOR] jeff imx219 poweroff.\n"); //jeff add 
-	        if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
-	        //    if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! \n");}
-	            if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! \n");}
-	       //     if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! \n");}
-	            if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! \n");}
-	    	    if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");} //high == power down lens module
-	       //     if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");} //low == reset sensor
-		}
+      #ifdef GPIO_CAMERA_LDO_EN_PIN
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ZERO);
+#endif
+            //Set Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
 
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+     //            goto _kdCISModulePowerOn_exit_;
+            }
             if(TRUE != _hwPowerDown(SUB_CAMERA_POWER_VCAM_D,mode_name))
             {
                  PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D), power id = %d \n",SUB_CAMERA_POWER_VCAM_D);
                  goto _kdCISModulePowerOn_exit_;
             }
-
             //VCAM_A
             if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
                 PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
                 //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
+     //           goto _kdCISModulePowerOn_exit_;
             }
 
             //VCAM_IO
             if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
                 PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
                 //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
+      //          goto _kdCISModulePowerOn_exit_;
             }
 
             //AF_VCC
@@ -838,42 +1313,53 @@ u32 pinSet[3][8] = {
             {
                 PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
                 //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
+       //         goto _kdCISModulePowerOn_exit_;
             }
 
         }
-//////////////////
-	else if (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV2680_MIPI_RAW, currSensorName)) && (pinSetIdx == 1))
+        else if ((currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV5648_MIPI_RAW, currSensorName))) \
+			||(currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV9760_MIPI_RAW, currSensorName)))\
+                                                                                                      )
         {
-          //  mt_set_gpio_out(GPIO_SPI_MOSI_PIN,GPIO_OUT_ZERO);
+      #ifdef GPIO_CAMERA_LDO_EN_PIN
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ZERO);
+#endif
             //Set Power Pin low and Reset Pin Low
-            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
-	        //    if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! \n");}
-	            if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! \n");}
-	       //     if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! \n");}
-	            if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! \n");}
-	    	    if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");} //high == power down lens module
-	       //     if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");} //low == reset sensor
-		}
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
 
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+     //            goto _kdCISModulePowerOn_exit_;
+            }
+#if 0
             if(TRUE != _hwPowerDown(SUB_CAMERA_POWER_VCAM_D,mode_name))
             {
                  PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D), power id = %d \n",SUB_CAMERA_POWER_VCAM_D);
                  goto _kdCISModulePowerOn_exit_;
             }
-
+#endif
             //VCAM_A
             if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
                 PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
                 //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
+     //           goto _kdCISModulePowerOn_exit_;
             }
 
             //VCAM_IO
             if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
                 PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
                 //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
+      //          goto _kdCISModulePowerOn_exit_;
             }
 
             //AF_VCC
@@ -881,41 +1367,57 @@ u32 pinSet[3][8] = {
             {
                 PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
                 //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
+       //         goto _kdCISModulePowerOn_exit_;
             }
 
         }
-	 else if (currSensorName && (0 == strcmp(SENSOR_DRVNAME_IMX219_MIPI_RAW, currSensorName)) && (pinSetIdx == 0))
+        else if ((currSensorName && (0 == strcmp(SENSOR_DRVNAME_HI551_MIPI_RAW, currSensorName))) ||\
+                 (currSensorName && (0 == strcmp(SENSOR_DRVNAME_HI545_MIPI_RAW, currSensorName))) ||\
+                 (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV8858_MIPI_RAW, currSensorName))) ||\
+                 (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV5670_MIPI_RAW, currSensorName))) ||\
+                 (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV8865_MIPI_RAW, currSensorName)))   \
+                                                                                                      )
         {
-          //  mt_set_gpio_out(GPIO_SPI_MOSI_PIN,GPIO_OUT_ZERO);
+      #ifdef GPIO_CAMERA_LDO_EN_PIN
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ZERO);
+#endif
             //Set Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
             if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
-	        //    if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! \n");}
-	            if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! \n");}
-	       //     if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! \n");}
-	            if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! \n");}
-	    	    if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");} //high == power down lens module
-	       //     if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");} //low == reset sensor
-		}
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+     //            goto _kdCISModulePowerOn_exit_;
+            }
 
+#if 1
             if(TRUE != _hwPowerDown(SUB_CAMERA_POWER_VCAM_D,mode_name))
             {
                  PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D), power id = %d \n",SUB_CAMERA_POWER_VCAM_D);
                  goto _kdCISModulePowerOn_exit_;
             }
-
+#endif
             //VCAM_A
             if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
                 PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
                 //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
+     //           goto _kdCISModulePowerOn_exit_;
             }
 
             //VCAM_IO
             if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
                 PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
                 //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
+      //          goto _kdCISModulePowerOn_exit_;
             }
 
             //AF_VCC
@@ -923,41 +1425,110 @@ u32 pinSet[3][8] = {
             {
                 PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
                 //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
+       //         goto _kdCISModulePowerOn_exit_;
             }
 
         }
-        else if (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV8858_MIPI_RAW, currSensorName)) && (pinSetIdx == 0))
+        else  if ((currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC0310_MIPI_YUV, currSensorName))) ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_SP2508_MIPI_RAW, currSensorName)))      ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_SP5409_MIPI_RAW, currSensorName)))      ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC2755_MIPI_RAW, currSensorName))) ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC2355_MIPI_RAW, currSensorName))) \
+                                                                                                  )
         {
-          //  mt_set_gpio_out(GPIO_SPI_MOSI_PIN,GPIO_OUT_ZERO);
+      #ifdef GPIO_CAMERA_LDO_EN_PIN
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ZERO);
+#endif
+		#ifdef GPIO_CAMERASUB_LDO_EN_PIN
+           mt_set_gpio_mode(GPIO_CAMERASUB_LDO_EN_PIN,GPIO_MODE_00);
+           mt_set_gpio_dir(GPIO_CAMERASUB_LDO_EN_PIN,GPIO_DIR_OUT);
+           mt_set_gpio_out(GPIO_CAMERASUB_LDO_EN_PIN,GPIO_OUT_ZERO);
+		#endif
             //Set Power Pin low and Reset Pin Low
-            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
-	        //    if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! \n");}
-	            if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! \n");}
-	       //     if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! \n");}
-	            if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! \n");}
-	    	    if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");} //high == power down lens module
-	       //     if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");} //low == reset sensor
-		}
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
 
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+            #if 0
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+     //            goto _kdCISModulePowerOn_exit_;
+            }
+            #endif
+#if 1
             if(TRUE != _hwPowerDown(SUB_CAMERA_POWER_VCAM_D,mode_name))
             {
                  PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D), power id = %d \n",SUB_CAMERA_POWER_VCAM_D);
-                 goto _kdCISModulePowerOn_exit_;
+    //             goto _kdCISModulePowerOn_exit_;
+            }
+#endif
+            //VCAM_A
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
+                //return -EIO;
+     //           goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_IO
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                //return -EIO;
+      //          goto _kdCISModulePowerOn_exit_;
+            }
+#if 1//VANZO_FEATURE_GC2755MIPIRAW_FOCUS_EN
+            //AF_VCC
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                //return -EIO;
+       //         goto _kdCISModulePowerOn_exit_;
+            }
+#endif
+
+        } 
+        else if ((currSensorName && (0 == strcmp(SENSOR_DRVNAME_GC2035_YUV, currSensorName))) \
+                                                                                                      )
+        {
+      #ifdef GPIO_CAMERA_LDO_EN_PIN
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ZERO);
+#endif
+            //Set Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
             }
 
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+     //            goto _kdCISModulePowerOn_exit_;
+            }
             //VCAM_A
             if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
                 PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
                 //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
+     //           goto _kdCISModulePowerOn_exit_;
             }
 
             //VCAM_IO
             if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
                 PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
                 //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
+      //          goto _kdCISModulePowerOn_exit_;
             }
 
             //AF_VCC
@@ -965,19 +1536,22 @@ u32 pinSet[3][8] = {
             {
                 PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
                 //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
+       //         goto _kdCISModulePowerOn_exit_;
             }
 
         }
-//////////////////
-        else if (currSensorName && (0 == strcmp(SENSOR_DRVNAME_GC2355_MIPI_RAW, currSensorName)))
+       else  if ((currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC0330_YUV, currSensorName))) || \
+                (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC0330_YUV,currSensorName))) \
+				                                                                                )
         {
-           // mt_set_gpio_out(GPIO_SPI_MOSI_PIN,GPIO_OUT_ZERO);
+                 #ifdef GPIO_CAMERA_LDO_EN_PIN
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ZERO);
+#endif
             //Set Power Pin low and Reset Pin Low
             if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
                 if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
                 if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
-                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
             }
 
             if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
@@ -985,39 +1559,46 @@ u32 pinSet[3][8] = {
                 if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
                 if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
             }
-
-
+            #if 1
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+     //            goto _kdCISModulePowerOn_exit_;
+            }
+            #endif
+#if 0
             if(TRUE != _hwPowerDown(SUB_CAMERA_POWER_VCAM_D,mode_name))
             {
                  PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D), power id = %d \n",SUB_CAMERA_POWER_VCAM_D);
-                 goto _kdCISModulePowerOn_exit_;
+    //             goto _kdCISModulePowerOn_exit_;
             }
-
+#endif
             //VCAM_A
             if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
                 PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
                 //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
+     //           goto _kdCISModulePowerOn_exit_;
             }
 
             //VCAM_IO
             if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
                 PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
                 //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
+      //          goto _kdCISModulePowerOn_exit_;
             }
-
             //AF_VCC
             if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name))
             {
                 PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
                 //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
+       //         goto _kdCISModulePowerOn_exit_;
             }
-
         }
-        else
+             else
         {
+                 #ifdef GPIO_CAMERA_LDO_EN_PIN
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ZERO);
+#endif
             //Set Power Pin low and Reset Pin Low
             if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
                 if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
@@ -1047,6 +1628,12 @@ u32 pinSet[3][8] = {
 	            goto _kdCISModulePowerOn_exit_;
 	          }
 	   }
+            if(TRUE != hwPowerDown(SUB_CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D),       power id = %d \n",SUB_CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+
 
             //VCAM_A
             if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
diff --git a/drivers/misc/mediatek/mach/mt6735/benefit_m7/camera/camera/kd_camera_hw.h b/drivers/misc/mediatek/mach/mt6735/benefit_m7/camera/camera/kd_camera_hw.h
index 48777d4..a9c33b6 100755
--- a/drivers/misc/mediatek/mach/mt6735/benefit_m7/camera/camera/kd_camera_hw.h
+++ b/drivers/misc/mediatek/mach/mt6735/benefit_m7/camera/camera/kd_camera_hw.h
@@ -1,6 +1,5 @@
 #ifndef _KD_CAMERA_HW_H_
 #define _KD_CAMERA_HW_H_
- 
 
 #include <mach/mt_gpio.h>
 
@@ -12,11 +11,11 @@
 #include "pmic_drv.h"
 
 //
-//Analog 
+//Analog
 #define CAMERA_POWER_VCAM_A         PMIC_APP_MAIN_CAMERA_POWER_A
-//Digital 
+//Digital
 #define CAMERA_POWER_VCAM_D         PMIC_APP_MAIN_CAMERA_POWER_D
-//AF 
+//AF
 #define CAMERA_POWER_VCAM_AF        PMIC_APP_MAIN_CAMERA_POWER_AF
 //digital io
 #define CAMERA_POWER_VCAM_IO        PMIC_APP_MAIN_CAMERA_POWER_IO
@@ -24,26 +23,29 @@
 #define SUB_CAMERA_POWER_VCAM_D     PMIC_APP_SUB_CAMERA_POWER_D
 
 
-//FIXME, should defined in DCT tool 
+//FIXME, should defined in DCT tool
 
 //Main sensor
-    // Common phone's reset pin uses extension GPIO10 of mt6306
-    #define CAMERA_CMRST_PIN            GPIO_CAMERA_CMRST_PIN 
-    #define CAMERA_CMRST_PIN_M_GPIO     GPIO_CAMERA_CMRST_PIN_M_GPIO
+#define CAMERA_CMRST_PIN            GPIO_CAMERA_CMRST_PIN
+#define CAMERA_CMRST_PIN_M_GPIO     GPIO_CAMERA_CMRST_PIN_M_GPIO
 
+#define CAMERA_CMPDN_PIN            GPIO_CAMERA_CMPDN_PIN
+#define CAMERA_CMPDN_PIN_M_GPIO     GPIO_CAMERA_CMPDN_PIN_M_GPIO
 
-#define CAMERA_CMPDN_PIN            GPIO_CAMERA_CMPDN_PIN    
-#define CAMERA_CMPDN_PIN_M_GPIO     GPIO_CAMERA_CMPDN_PIN_M_GPIO 
- 
 //FRONT sensor
-#define CAMERA_CMRST1_PIN           GPIO_CAMERA_CMRST1_PIN 
-#define CAMERA_CMRST1_PIN_M_GPIO    GPIO_CAMERA_CMRST1_PIN_M_GPIO 
+#define CAMERA_CMRST1_PIN           GPIO_CAMERA_CMRST1_PIN
+#define CAMERA_CMRST1_PIN_M_GPIO    GPIO_CAMERA_CMRST1_PIN_M_GPIO
 
-#define CAMERA_CMPDN1_PIN           GPIO_CAMERA_CMPDN1_PIN 
-#define CAMERA_CMPDN1_PIN_M_GPIO    GPIO_CAMERA_CMPDN1_PIN_M_GPIO 
+#define CAMERA_CMPDN1_PIN           GPIO_CAMERA_CMPDN1_PIN
+#define CAMERA_CMPDN1_PIN_M_GPIO    GPIO_CAMERA_CMPDN1_PIN_M_GPIO
 
 // Define I2C Bus Num
 #define SUPPORT_I2C_BUS_NUM1        0
+/* Vanzo:yucheng on: Mon, 06 Apr 2015 21:46:53 +0800
+ * Porting from wuzhiyong
 #define SUPPORT_I2C_BUS_NUM2        0
+ */
+#define SUPPORT_I2C_BUS_NUM2        2
+// End of Vanzo: yucheng
 
-#endif 
+#endif
diff --git a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/codegen.dws b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/codegen.dws
old mode 100755
new mode 100644
index 0821c29a7cdd3f976f5fb03d0bb2e883d887c66b..60faf7eebf301b484eb6fe1598954dc11f157b45
GIT binary patch
delta 83
zcmcccg7Ml5#tr34lOM>lOl)8g`40pPK!8k7zR0LBaRP^!I8fX@z|%k8+0oZE$T8l>
a#XsKFZ}LQOmB|y#IVS0FZ2qql7zh9x!6CE&

delta 54
zcmccig7Lx&#tr34lMgT}Or9XjG0}r(a-SWC#D5@Q00KcEb`S9MkM|4;jQ4YM-h5H1
GH4p$;WE2ws

diff --git a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_adc.dtsi b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_adc.dtsi
index e00386c..7523c87 100644
--- a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_adc.dtsi
+++ b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_adc.dtsi
@@ -1,6 +1,6 @@
 /*
  * Generated by MTK SP DrvGen Version 03.13.6 for MT6735M. Copyright MediaTek Inc. (C) 2013.
- * Sun May 08 18:21:52 2016
+ * Sun May 08 22:30:08 2016
  * Do Not Modify the File.
  */
 
diff --git a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_adc.h b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_adc.h
index f3a8828..f2f823c 100644
--- a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_adc.h
+++ b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_adc.h
@@ -1,6 +1,6 @@
 /*
  * Generated by MTK SP DrvGen Version 03.13.6 for MT6735M. Copyright MediaTek Inc. (C) 2013.
- * Sun May 08 18:21:52 2016
+ * Sun May 08 22:30:08 2016
  * Do Not Modify the File.
  */
 
diff --git a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_clk_buf.dtsi b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_clk_buf.dtsi
index d55623b..a44d76b 100644
--- a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_clk_buf.dtsi
+++ b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_clk_buf.dtsi
@@ -1,6 +1,6 @@
 /*
  * Generated by MTK SP DrvGen Version 03.13.6 for MT6735M. Copyright MediaTek Inc. (C) 2013.
- * Sun May 08 18:21:52 2016
+ * Sun May 08 22:30:08 2016
  * Do Not Modify the File.
  */
 
diff --git a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_clk_buf.h b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_clk_buf.h
index 79d084f..61b3f56 100644
--- a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_clk_buf.h
+++ b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_clk_buf.h
@@ -1,6 +1,6 @@
 /*
  * Generated by MTK SP DrvGen Version 03.13.6 for MT6735M. Copyright MediaTek Inc. (C) 2013.
- * Sun May 08 18:21:52 2016
+ * Sun May 08 22:30:08 2016
  * Do Not Modify the File.
  */
 
diff --git a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_eint.dtsi b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_eint.dtsi
index 10ef47c..3827f88 100644
--- a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_eint.dtsi
+++ b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_eint.dtsi
@@ -1,6 +1,6 @@
 /*
  * Generated by MTK SP DrvGen Version 03.13.6 for MT6735M. Copyright MediaTek Inc. (C) 2013.
- * Sun May 08 18:21:52 2016
+ * Sun May 08 22:30:08 2016
  * Do Not Modify the File.
  */
 
diff --git a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_eint.h b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_eint.h
index 7a30331..024ee96 100644
--- a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_eint.h
+++ b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_eint.h
@@ -1,6 +1,6 @@
 /*
  * Generated by MTK SP DrvGen Version 03.13.6 for MT6735M. Copyright MediaTek Inc. (C) 2013.
- * Sun May 08 18:21:52 2016
+ * Sun May 08 22:30:08 2016
  * Do Not Modify the File.
  */
 
diff --git a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_eint_md1.h b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_eint_md1.h
index 3c12411..54aeb7f 100644
--- a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_eint_md1.h
+++ b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_eint_md1.h
@@ -1,6 +1,6 @@
 /*
  * Generated by MTK SP DrvGen Version 03.13.6 for MT6735M. Copyright MediaTek Inc. (C) 2013.
- * Sun May 08 18:21:52 2016
+ * Sun May 08 22:30:08 2016
  * Do Not Modify the File.
  */
 
diff --git a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_gpio.dtsi b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_gpio.dtsi
index cbb2138..b000d8e 100644
--- a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_gpio.dtsi
+++ b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_gpio.dtsi
@@ -1,6 +1,6 @@
 /*
  * Generated by MTK SP DrvGen Version 03.13.6 for MT6735M. Copyright MediaTek Inc. (C) 2013.
- * Sun May 08 18:21:52 2016
+ * Sun May 08 22:30:08 2016
  * Do Not Modify the File.
  */
 
@@ -962,7 +962,7 @@
 	gpio86: gpio@86 {
 		pins_cmd_dat {
 			pins = <PINMUX_GPIO86__FUNC_GPIO86>;
-			slew-rate = <0>;
+			slew-rate = <1>;
 			bias-disable;
 			bias-pull-down = <00>;
 			output-low;
diff --git a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_gpio_boot.h b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_gpio_boot.h
index f41e804..c41e29e 100644
--- a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_gpio_boot.h
+++ b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_gpio_boot.h
@@ -1,6 +1,6 @@
 /*
  * Generated by MTK SP DrvGen Version 03.13.6 for MT6735M. Copyright MediaTek Inc. (C) 2013.
- * Sun May 08 18:21:52 2016
+ * Sun May 08 22:30:08 2016
  * Do Not Modify the File.
  */
 
@@ -741,7 +741,7 @@
 
 //Configureation for Pin 86
 #define GPIO86_MODE      GPIO_MODE_00
-#define GPIO86_DIR       GPIO_DIR_IN
+#define GPIO86_DIR       GPIO_DIR_OUT
 #define GPIO86_PULLEN    GPIO_PULL_DISABLE
 #define GPIO86_PULL      GPIO_PULL_DOWN
 #define GPIO86_DATAOUT   GPIO_OUT_ZERO
diff --git a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_gpio_usage.h b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_gpio_usage.h
index 6be6fed..bb26dcc 100644
--- a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_gpio_usage.h
+++ b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_gpio_usage.h
@@ -1,6 +1,6 @@
 /*
  * Generated by MTK SP DrvGen Version 03.13.6 for MT6735M. Copyright MediaTek Inc. (C) 2013.
- * Sun May 08 18:21:52 2016
+ * Sun May 08 22:30:08 2016
  * Do Not Modify the File.
  */
 
@@ -465,10 +465,9 @@
 #define GPIO_KPD_KCOL1_PIN_M_AUXIF_ST   GPIO_MODE_06
 #define GPIO_KPD_KCOL1_PIN_M_DBG_MON_A   GPIO_MODE_07
 
-#define GPIO_IRQ_NFC_PIN         (GPIO86 | 0x80000000)
-#define GPIO_IRQ_NFC_PIN_M_EINT   GPIO_MODE_00
-#define GPIO_IRQ_NFC_PIN_M_GPIO   GPIO_MODE_00
-#define GPIO_IRQ_NFC_PIN_M_KCOL   GPIO_MODE_01
+#define GPIO_CAMERA_LDO_EN_PIN         (GPIO86 | 0x80000000)
+#define GPIO_CAMERA_LDO_EN_PIN_M_GPIO   GPIO_MODE_00
+#define GPIO_CAMERA_LDO_EN_PIN_M_KCOL   GPIO_MODE_01
 
 #define GPIO_RFIC0_BSI_CK         (GPIO111 | 0x80000000)
 #define GPIO_RFIC0_BSI_CK_M_GPIO   GPIO_MODE_00
diff --git a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_i2c.dtsi b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_i2c.dtsi
index 73922e9..8d5a5d6 100644
--- a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_i2c.dtsi
+++ b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_i2c.dtsi
@@ -1,6 +1,6 @@
 /*
  * Generated by MTK SP DrvGen Version 03.13.6 for MT6735M. Copyright MediaTek Inc. (C) 2013.
- * Sun May 08 18:21:52 2016
+ * Sun May 08 22:30:08 2016
  * Do Not Modify the File.
  */
 
diff --git a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_i2c.h b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_i2c.h
index db851a9..4082d14 100644
--- a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_i2c.h
+++ b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_i2c.h
@@ -1,6 +1,6 @@
 /*
  * Generated by MTK SP DrvGen Version 03.13.6 for MT6735M. Copyright MediaTek Inc. (C) 2013.
- * Sun May 08 18:21:52 2016
+ * Sun May 08 22:30:08 2016
  * Do Not Modify the File.
  */
 
diff --git a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_kpd.dtsi b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_kpd.dtsi
index 771786e..16766af 100644
--- a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_kpd.dtsi
+++ b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_kpd.dtsi
@@ -1,6 +1,6 @@
 /*
  * Generated by MTK SP DrvGen Version 03.13.6 for MT6735M. Copyright MediaTek Inc. (C) 2013.
- * Sun May 08 18:21:52 2016
+ * Sun May 08 22:30:08 2016
  * Do Not Modify the File.
  */
 
diff --git a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_kpd.h b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_kpd.h
index 8c6aad4..81e351b 100644
--- a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_kpd.h
+++ b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_kpd.h
@@ -1,6 +1,6 @@
 /*
  * Generated by MTK SP DrvGen Version 03.13.6 for MT6735M. Copyright MediaTek Inc. (C) 2013.
- * Sun May 08 18:21:52 2016
+ * Sun May 08 22:30:08 2016
  * Do Not Modify the File.
  */
 
diff --git a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_md1_eint.dtsi b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_md1_eint.dtsi
index 1bde932..96092f0 100644
--- a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_md1_eint.dtsi
+++ b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_md1_eint.dtsi
@@ -1,6 +1,6 @@
 /*
  * Generated by MTK SP DrvGen Version 03.13.6 for MT6735M. Copyright MediaTek Inc. (C) 2013.
- * Sun May 08 18:21:52 2016
+ * Sun May 08 22:30:08 2016
  * Do Not Modify the File.
  */
 
diff --git a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_pmic.dtsi b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_pmic.dtsi
index 74f7f18..dbdd2ba 100644
--- a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_pmic.dtsi
+++ b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_pmic.dtsi
@@ -1,6 +1,6 @@
 /*
  * Generated by MTK SP DrvGen Version 03.13.6 for MT6735M. Copyright MediaTek Inc. (C) 2013.
- * Sun May 08 18:21:52 2016
+ * Sun May 08 22:30:08 2016
  * Do Not Modify the File.
  */
 
diff --git a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_power.h b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_power.h
index 025ebce..594ec1f 100644
--- a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_power.h
+++ b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/cust_power.h
@@ -1,6 +1,6 @@
 /*
  * Generated by MTK SP DrvGen Version 03.13.6 for MT6735M. Copyright MediaTek Inc. (C) 2013.
- * Sun May 08 18:21:52 2016
+ * Sun May 08 22:30:08 2016
  * Do Not Modify the File.
  */
 
diff --git a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/mt6735m-pinfunc.h b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/mt6735m-pinfunc.h
index 9c29a57..056f412 100644
--- a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/mt6735m-pinfunc.h
+++ b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/mt6735m-pinfunc.h
@@ -1,6 +1,6 @@
 /*
  * Generated by MTK SP DrvGen Version 03.13.6 for MT6735M. Copyright MediaTek Inc. (C) 2013.
- * Sun May 08 18:21:52 2016
+ * Sun May 08 22:30:08 2016
  * Do Not Modify the File.
  */
 
diff --git a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/pinctrl-mtk-mt6735.h b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/pinctrl-mtk-mt6735.h
index bf9c1b4..b7814ba 100644
--- a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/pinctrl-mtk-mt6735.h
+++ b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/pinctrl-mtk-mt6735.h
@@ -1,6 +1,6 @@
 /*
  * Generated by MTK SP DrvGen Version 03.13.6 for MT6735M. Copyright MediaTek Inc. (C) 2013.
- * Sun May 08 18:21:52 2016
+ * Sun May 08 22:30:08 2016
  * Do Not Modify the File.
  */
 
diff --git a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/pmic_drv.c b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/pmic_drv.c
index 558b00e..d0aa1c5 100644
--- a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/pmic_drv.c
+++ b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/pmic_drv.c
@@ -1,6 +1,6 @@
 /*
  * Generated by MTK SP DrvGen Version 03.13.6 for MT6735M. Copyright MediaTek Inc. (C) 2013.
- * Sun May 08 18:21:52 2016
+ * Sun May 08 22:30:08 2016
  * Do Not Modify the File.
  */
 
diff --git a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/pmic_drv.h b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/pmic_drv.h
index 41779f1..a19ef17 100644
--- a/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/pmic_drv.h
+++ b/drivers/misc/mediatek/mach/mt6735/benefit_m7/dct/dct/pmic_drv.h
@@ -1,6 +1,6 @@
 /*
  * Generated by MTK SP DrvGen Version 03.13.6 for MT6735M. Copyright MediaTek Inc. (C) 2013.
- * Sun May 08 18:21:52 2016
+ * Sun May 08 22:30:08 2016
  * Do Not Modify the File.
  */
 
diff --git a/include/generated/compile.h b/include/generated/compile.h
index 2851362..f3ec75b 100644
--- a/include/generated/compile.h
+++ b/include/generated/compile.h
@@ -1,7 +1,7 @@
-/* This file is auto generated, version 58 */
+/* This file is auto generated, version 74 */
 /* SMP PREEMPT */
 #define UTS_MACHINE "arm64"
-#define UTS_VERSION "#58 SMP PREEMPT Sun May 8 19:03:03 MSK 2016"
+#define UTS_VERSION "#74 SMP PREEMPT Sun May 8 22:31:11 MSK 2016"
 #define LINUX_COMPILE_BY "olegsvs"
 #define LINUX_COMPILE_HOST "olegsvs-develop"
 #define LINUX_COMPILER "gcc version 4.9 20150123 (prerelease) (GCC) "
diff --git a/tools/dct/DCT.log b/tools/dct/DCT.log
index 6025dba..e69de29 100644
--- a/tools/dct/DCT.log
+++ b/tools/dct/DCT.log
@@ -1,5 +0,0 @@
-/* Log generated by MTK SP DrvGen Version 03.13.6;
- Log Time is Sun May 08 18:46:44 2016
- */
-open operater parse MT6735M.fig OK!
-Edit operater parse .cmp file OK!
-- 
2.7.4

