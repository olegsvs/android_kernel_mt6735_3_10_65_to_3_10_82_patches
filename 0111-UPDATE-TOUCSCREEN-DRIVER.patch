From 120838b04d8c04702b65f6b25c42648e7e7e314e Mon Sep 17 00:00:00 2001
From: SnowCatPDA <snowcat@vpro.ru>
Date: Sat, 28 May 2016 16:48:48 +0500
Subject: [PATCH 111/117] UPDATE TOUCSCREEN DRIVER

---
 .../configs/lentk6735m_65c_l1_debug_defconfig~     | 3101 --------------
 arch/arm64/configs/lentk6735m_65c_l1_defconfig~    | 3083 --------------
 drivers/input/touchscreen/Kconfig                  |    4 +
 .../touchscreen/mediatek/GT915_HD/gt9xx_driver.c~  | 3281 --------------
 .../touchscreen/mediatek/GT915_HD/gt9xx_update.c~  | 3456 ---------------
 .../mediatek/GT915_HD/tpd_custom_gt9xx.h~          |  415 --
 .../touchscreen/mediatek/GT915_QHD/gt9xx_driver.c~ | 3276 --------------
 .../mediatek/GT915_QHD/tpd_custom_gt9xx.h~         |  415 --
 drivers/input/touchscreen/mediatek/Makefile        |    5 +
 .../touchscreen/mediatek/focaltech_hd/Makefile~    |   18 -
 .../mediatek/focaltech_hd/focaltech_driver.c~      | 1162 -----
 .../mediatek/focaltech_hd/focaltech_ex_fun.c~      | 1349 ------
 .../touchscreen/mediatek/focaltech_qhd/Makefile~   |   18 -
 .../mediatek/focaltech_qhd/focaltech_driver.c~     | 1162 -----
 .../mediatek/focaltech_qhd/tpd_custom_fts.h~       |  162 -
 .../mediatek/focaltech_qhd_bat/Makefile~           |   18 -
 .../mediatek/focaltech_qhd_bat/tpd_custom_fts.h~   |  170 -
 .../touchscreen/mediatek/ft6x06_qhd/Makefile~      |   16 -
 .../mediatek/ft6x06_qhd/ft6x06_driver.c~           | 1359 ------
 .../mediatek/ft6x06_qhd/tpd_custom_ft6x06.h~       |   55 -
 .../mediatek/ft_allinone_gesture/Makefile          |   12 +
 .../mediatek/ft_allinone_gesture/focaltech_ctl.c   |  284 ++
 .../mediatek/ft_allinone_gesture/focaltech_ctl.h   |   27 +
 .../ft_allinone_gesture/focaltech_driver.c         | 1459 +++++++
 .../ft_allinone_gesture/focaltech_ex_fun.c         | 2251 ++++++++++
 .../ft_allinone_gesture/focaltech_ex_fun.h         |   62 +
 .../ft_allinone_gesture/ft_gesture_lib.a_shipped   |  Bin 0 -> 27542 bytes
 .../mediatek/ft_allinone_gesture/ft_gesture_lib.h  |   24 +
 .../mediatek/ft_allinone_gesture/tpd_custom_fts.h  |  151 +
 drivers/misc/mediatek/Makefile~                    |  327 --
 .../accelerometer/KXTJ2_1009_auto/kxtj2_1009.c~    | 2189 ----------
 .../misc/mediatek/accelerometer/mc3xxx/mc3xxx.c~   | 4105 ------------------
 drivers/misc/mediatek/fingerprint/Makefile~        |   12 -
 drivers/misc/mediatek/fingerprint/eh570-spi.c~     |  527 ---
 .../fingerprint/eh570-spi_data_transfer.c~         |  316 --
 drivers/misc/mediatek/fingerprint/eh570.h~         |   57 -
 drivers/misc/mediatek/fingerprint/fps_trigger.c~   |  267 --
 .../mt6735/ov2680_mipi_raw/ov2680mipi_Sensor.c~    | 1412 -------
 .../mt6735/ov8858_mipi_raw/ov8858mipiraw_Sensor.c~ | 2395 -----------
 .../imx219_mipi_raw/imx219mipiraw_Sensor.c~        | 2150 ----------
 .../imgsensor/src/mt6735m/kd_sensorlist.h~         |  441 --
 .../mt6735m/ov2680_mipi_raw/ov2680mipi_Sensor.c~   | 1412 -------
 .../mt6735m/ov5648_mipi_raw/ov5648mipi_Sensor.c~   | 1818 --------
 .../ov8858_mipi_raw/ov8858mipiraw_Sensor.c~        | 2400 -----------
 .../mt6753/ov8858_mipi_raw/ov8858mipiraw_Sensor.c~ | 2395 -----------
 drivers/misc/mediatek/keypad/kpd.c~                | 1025 -----
 .../lcm/hct_otm1282a_dsi_vdo_hd_auo/Makefile~      |   13 -
 .../hct_otm1282a_dsi_vdo_hd_auo.c~                 |  902 ----
 .../lcm/hct_rm68200_dsi_vdo_hd_cpt/Makefile~       |   15 -
 .../hct_rm68200_dsi_vdo_hd_cpt.c~                  | 1055 -----
 .../misc/mediatek/lcm/ili9807_qhd_dsi/Makefile~    |   10 -
 .../lcm/ili9807_qhd_dsi/ili9807_qhd_dsi.c~         |  660 ---
 .../lcm/otm1284a_hd_dsi_vdo/otm1284a_hd_dsi_vdo.c~ |  572 ---
 drivers/misc/mediatek/lens/Makefile~               |  116 -
 drivers/misc/mediatek/lens/mt6735/ad5823/AD5823.c~ |  582 ---
 drivers/misc/mediatek/mac_fingerprint/madev.c~     |  700 ---
 .../accelerometer/KXTJ2_1009-new/Makefile~         |    4 -
 .../accelerometer/KXTJ2_1009-new/Makefile~         |    4 -
 .../accelerometer/KXTJ2_1009_auto/Makefile~        |    4 -
 .../benefit_m7/accelerometer/mc3xxx_auto/Makefile~ |    4 -
 .../benefit_m7/camera/camera/kd_camera_hw.c~       | 1089 -----
 .../accelerometer/KXTJ2_1009-new/Makefile~         |    4 -
 .../accelerometer/KXTJ2_1009_auto/Makefile~        |    4 -
 .../accelerometer/mc3xxx_auto/Makefile~            |    4 -
 drivers/misc/mediatek/power/mt6735/Makefile~       |   31 -
 .../misc/mediatek/power/mt6735/charging_hw_pmic.c~ |  724 ----
 drivers/misc/mediatek/spi/mt6735/spi-dev.c~        |  901 ----
 .../mediatek/thermal/mt6735/mtk_cooler_bcct.c~     |  478 ---
 drivers/power/mediatek/battery_common.c~           | 4465 --------------------
 drivers/power/mediatek/battery_meter.c~            | 4197 ------------------
 drivers/power/mediatek/linear_charging.c~          | 1272 ------
 drivers/power/mediatek/switch_charging.c~          |  918 ----
 tools/dct/EINT_YuSu.cmp~                           |  172 -
 73 files changed, 4279 insertions(+), 64664 deletions(-)
 delete mode 100644 arch/arm64/configs/lentk6735m_65c_l1_debug_defconfig~
 delete mode 100644 arch/arm64/configs/lentk6735m_65c_l1_defconfig~
 delete mode 100755 drivers/input/touchscreen/mediatek/GT915_HD/gt9xx_driver.c~
 delete mode 100755 drivers/input/touchscreen/mediatek/GT915_HD/gt9xx_update.c~
 delete mode 100755 drivers/input/touchscreen/mediatek/GT915_HD/tpd_custom_gt9xx.h~
 delete mode 100755 drivers/input/touchscreen/mediatek/GT915_QHD/gt9xx_driver.c~
 delete mode 100755 drivers/input/touchscreen/mediatek/GT915_QHD/tpd_custom_gt9xx.h~
 delete mode 100755 drivers/input/touchscreen/mediatek/focaltech_hd/Makefile~
 delete mode 100755 drivers/input/touchscreen/mediatek/focaltech_hd/focaltech_driver.c~
 delete mode 100755 drivers/input/touchscreen/mediatek/focaltech_hd/focaltech_ex_fun.c~
 delete mode 100755 drivers/input/touchscreen/mediatek/focaltech_qhd/Makefile~
 delete mode 100755 drivers/input/touchscreen/mediatek/focaltech_qhd/focaltech_driver.c~
 delete mode 100755 drivers/input/touchscreen/mediatek/focaltech_qhd/tpd_custom_fts.h~
 delete mode 100755 drivers/input/touchscreen/mediatek/focaltech_qhd_bat/Makefile~
 delete mode 100755 drivers/input/touchscreen/mediatek/focaltech_qhd_bat/tpd_custom_fts.h~
 delete mode 100755 drivers/input/touchscreen/mediatek/ft6x06_qhd/Makefile~
 delete mode 100755 drivers/input/touchscreen/mediatek/ft6x06_qhd/ft6x06_driver.c~
 delete mode 100755 drivers/input/touchscreen/mediatek/ft6x06_qhd/tpd_custom_ft6x06.h~
 create mode 100644 drivers/input/touchscreen/mediatek/ft_allinone_gesture/Makefile
 create mode 100644 drivers/input/touchscreen/mediatek/ft_allinone_gesture/focaltech_ctl.c
 create mode 100644 drivers/input/touchscreen/mediatek/ft_allinone_gesture/focaltech_ctl.h
 create mode 100644 drivers/input/touchscreen/mediatek/ft_allinone_gesture/focaltech_driver.c
 create mode 100644 drivers/input/touchscreen/mediatek/ft_allinone_gesture/focaltech_ex_fun.c
 create mode 100644 drivers/input/touchscreen/mediatek/ft_allinone_gesture/focaltech_ex_fun.h
 create mode 100644 drivers/input/touchscreen/mediatek/ft_allinone_gesture/ft_gesture_lib.a_shipped
 create mode 100644 drivers/input/touchscreen/mediatek/ft_allinone_gesture/ft_gesture_lib.h
 create mode 100644 drivers/input/touchscreen/mediatek/ft_allinone_gesture/tpd_custom_fts.h
 delete mode 100755 drivers/misc/mediatek/Makefile~
 delete mode 100644 drivers/misc/mediatek/accelerometer/KXTJ2_1009_auto/kxtj2_1009.c~
 delete mode 100755 drivers/misc/mediatek/accelerometer/mc3xxx/mc3xxx.c~
 delete mode 100755 drivers/misc/mediatek/fingerprint/Makefile~
 delete mode 100755 drivers/misc/mediatek/fingerprint/eh570-spi.c~
 delete mode 100755 drivers/misc/mediatek/fingerprint/eh570-spi_data_transfer.c~
 delete mode 100755 drivers/misc/mediatek/fingerprint/eh570.h~
 delete mode 100755 drivers/misc/mediatek/fingerprint/fps_trigger.c~
 delete mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735/ov2680_mipi_raw/ov2680mipi_Sensor.c~
 delete mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735/ov8858_mipi_raw/ov8858mipiraw_Sensor.c~
 delete mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/imx219_mipi_raw/imx219mipiraw_Sensor.c~
 delete mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/kd_sensorlist.h~
 delete mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/ov2680_mipi_raw/ov2680mipi_Sensor.c~
 delete mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/ov5648_mipi_raw/ov5648mipi_Sensor.c~
 delete mode 100755 drivers/misc/mediatek/imgsensor/src/mt6735m/ov8858_mipi_raw/ov8858mipiraw_Sensor.c~
 delete mode 100755 drivers/misc/mediatek/imgsensor/src/mt6753/ov8858_mipi_raw/ov8858mipiraw_Sensor.c~
 delete mode 100755 drivers/misc/mediatek/keypad/kpd.c~
 delete mode 100644 drivers/misc/mediatek/lcm/hct_otm1282a_dsi_vdo_hd_auo/Makefile~
 delete mode 100644 drivers/misc/mediatek/lcm/hct_otm1282a_dsi_vdo_hd_auo/hct_otm1282a_dsi_vdo_hd_auo.c~
 delete mode 100644 drivers/misc/mediatek/lcm/hct_rm68200_dsi_vdo_hd_cpt/Makefile~
 delete mode 100644 drivers/misc/mediatek/lcm/hct_rm68200_dsi_vdo_hd_cpt/hct_rm68200_dsi_vdo_hd_cpt.c~
 delete mode 100755 drivers/misc/mediatek/lcm/ili9807_qhd_dsi/Makefile~
 delete mode 100755 drivers/misc/mediatek/lcm/ili9807_qhd_dsi/ili9807_qhd_dsi.c~
 delete mode 100755 drivers/misc/mediatek/lcm/otm1284a_hd_dsi_vdo/otm1284a_hd_dsi_vdo.c~
 delete mode 100755 drivers/misc/mediatek/lens/Makefile~
 delete mode 100644 drivers/misc/mediatek/lens/mt6735/ad5823/AD5823.c~
 delete mode 100755 drivers/misc/mediatek/mac_fingerprint/madev.c~
 delete mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/accelerometer/KXTJ2_1009-new/Makefile~
 delete mode 100755 drivers/misc/mediatek/mach/mt6735/benefit_m7/accelerometer/KXTJ2_1009-new/Makefile~
 delete mode 100755 drivers/misc/mediatek/mach/mt6735/benefit_m7/accelerometer/KXTJ2_1009_auto/Makefile~
 delete mode 100755 drivers/misc/mediatek/mach/mt6735/benefit_m7/accelerometer/mc3xxx_auto/Makefile~
 delete mode 100755 drivers/misc/mediatek/mach/mt6735/benefit_m7/camera/camera/kd_camera_hw.c~
 delete mode 100755 drivers/misc/mediatek/mach/mt6735/lentk6735_65c_l1/accelerometer/KXTJ2_1009-new/Makefile~
 delete mode 100755 drivers/misc/mediatek/mach/mt6735/lentk6735_65c_l1/accelerometer/KXTJ2_1009_auto/Makefile~
 delete mode 100755 drivers/misc/mediatek/mach/mt6735/lentk6735_65c_l1/accelerometer/mc3xxx_auto/Makefile~
 delete mode 100755 drivers/misc/mediatek/power/mt6735/Makefile~
 delete mode 100755 drivers/misc/mediatek/power/mt6735/charging_hw_pmic.c~
 delete mode 100755 drivers/misc/mediatek/spi/mt6735/spi-dev.c~
 delete mode 100755 drivers/misc/mediatek/thermal/mt6735/mtk_cooler_bcct.c~
 delete mode 100755 drivers/power/mediatek/battery_common.c~
 delete mode 100755 drivers/power/mediatek/battery_meter.c~
 delete mode 100755 drivers/power/mediatek/linear_charging.c~
 delete mode 100755 drivers/power/mediatek/switch_charging.c~
 delete mode 100755 tools/dct/EINT_YuSu.cmp~

diff --git a/arch/arm64/configs/lentk6735m_65c_l1_debug_defconfig~ b/arch/arm64/configs/lentk6735m_65c_l1_debug_defconfig~
deleted file mode 100644
index bf0213b..0000000
--- a/arch/arm64/configs/lentk6735m_65c_l1_debug_defconfig~
+++ /dev/null
@@ -1,3101 +0,0 @@
-#
-# Automatically generated file; DO NOT EDIT.
-# Linux/arm64 3.10.65 Kernel Configuration
-#
-CONFIG_ARM64=y
-CONFIG_ARM_HAS_SG_CHAIN=y
-CONFIG_64BIT=y
-CONFIG_ARCH_PHYS_ADDR_T_64BIT=y
-CONFIG_MMU=y
-CONFIG_NO_IOPORT=y
-CONFIG_STACKTRACE_SUPPORT=y
-CONFIG_LOCKDEP_SUPPORT=y
-CONFIG_TRACE_IRQFLAGS_SUPPORT=y
-CONFIG_GENERIC_LOCKBREAK=y
-CONFIG_RWSEM_GENERIC_SPINLOCK=y
-CONFIG_ARCH_HAS_CPUFREQ=y
-CONFIG_GENERIC_HWEIGHT=y
-CONFIG_GENERIC_CSUM=y
-CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_ZONE_DMA=y
-CONFIG_ARCH_DMA_ADDR_T_64BIT=y
-CONFIG_NEED_DMA_MAP_STATE=y
-CONFIG_NEED_SG_DMA_LENGTH=y
-CONFIG_SWIOTLB=y
-CONFIG_IOMMU_HELPER=y
-# CONFIG_ARM_ERRATA_824069 is not set
-CONFIG_KERNEL_MODE_NEON=y
-CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
-CONFIG_IRQ_WORK=y
-
-#
-# General setup
-#
-CONFIG_INIT_ENV_ARG_LIMIT=32
-CONFIG_CROSS_COMPILE="aarch64-linux-android-"
-CONFIG_LOCALVERSION=""
-# CONFIG_LOCALVERSION_AUTO is not set
-CONFIG_DEFAULT_HOSTNAME="(none)"
-CONFIG_SWAP=y
-# CONFIG_SYSVIPC is not set
-# CONFIG_POSIX_MQUEUE is not set
-# CONFIG_FHANDLE is not set
-CONFIG_AUDIT=y
-# CONFIG_AUDIT_LOGINUID_IMMUTABLE is not set
-CONFIG_HAVE_GENERIC_HARDIRQS=y
-
-#
-# IRQ subsystem
-#
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
-CONFIG_GENERIC_IRQ_SHOW=y
-CONFIG_HARDIRQS_SW_RESEND=y
-CONFIG_IRQ_DOMAIN=y
-CONFIG_IRQ_DOMAIN_DEBUG=y
-CONFIG_SPARSE_IRQ=y
-CONFIG_GENERIC_TIME_VSYSCALL=y
-CONFIG_GENERIC_CLOCKEVENTS=y
-CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
-CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
-
-#
-# Timers subsystem
-#
-CONFIG_TICK_ONESHOT=y
-CONFIG_NO_HZ_COMMON=y
-# CONFIG_HZ_PERIODIC is not set
-CONFIG_NO_HZ_IDLE=y
-CONFIG_NO_HZ=y
-CONFIG_HIGH_RES_TIMERS=y
-
-#
-# CPU/Task time and stats accounting
-#
-CONFIG_TICK_CPU_ACCOUNTING=y
-# CONFIG_BSD_PROCESS_ACCT is not set
-# CONFIG_TASKSTATS is not set
-
-#
-# RCU Subsystem
-#
-CONFIG_TREE_PREEMPT_RCU=y
-CONFIG_PREEMPT_RCU=y
-CONFIG_RCU_STALL_COMMON=y
-CONFIG_RCU_FANOUT=32
-CONFIG_RCU_FANOUT_LEAF=16
-# CONFIG_RCU_FANOUT_EXACT is not set
-# CONFIG_RCU_FAST_NO_HZ is not set
-# CONFIG_TREE_RCU_TRACE is not set
-# CONFIG_RCU_BOOST is not set
-# CONFIG_RCU_NOCB_CPU is not set
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=17
-CONFIG_GENERIC_SCHED_CLOCK=y
-CONFIG_CGROUPS=y
-# CONFIG_CGROUP_DEBUG is not set
-# CONFIG_CGROUP_FREEZER is not set
-# CONFIG_CGROUP_DEVICE is not set
-# CONFIG_CPUSETS is not set
-CONFIG_CGROUP_CPUACCT=y
-CONFIG_RESOURCE_COUNTERS=y
-# CONFIG_MEMCG is not set
-# CONFIG_CGROUP_PERF is not set
-CONFIG_CGROUP_SCHED=y
-CONFIG_FAIR_GROUP_SCHED=y
-# CONFIG_CFS_BANDWIDTH is not set
-CONFIG_RT_GROUP_SCHED=y
-# CONFIG_BLK_CGROUP is not set
-# CONFIG_CHECKPOINT_RESTORE is not set
-# CONFIG_NAMESPACES is not set
-CONFIG_UIDGID_CONVERTED=y
-# CONFIG_UIDGID_STRICT_TYPE_CHECKS is not set
-# CONFIG_SCHED_AUTOGROUP is not set
-# CONFIG_SYSFS_DEPRECATED is not set
-# CONFIG_RELAY is not set
-CONFIG_BLK_DEV_INITRD=y
-CONFIG_INITRAMFS_SOURCE=""
-CONFIG_RD_GZIP=y
-# CONFIG_RD_BZIP2 is not set
-# CONFIG_RD_LZMA is not set
-# CONFIG_RD_XZ is not set
-# CONFIG_RD_LZO is not set
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
-CONFIG_SYSCTL=y
-CONFIG_ANON_INODES=y
-CONFIG_HAVE_UID16=y
-CONFIG_SYSCTL_EXCEPTION_TRACE=y
-CONFIG_HOTPLUG=y
-CONFIG_PANIC_TIMEOUT=5
-CONFIG_EXPERT=y
-CONFIG_UID16=y
-CONFIG_SYSCTL_SYSCALL=y
-CONFIG_KALLSYMS=y
-CONFIG_KALLSYMS_ALL=y
-CONFIG_PRINTK=y
-CONFIG_BUG=y
-CONFIG_ELF_CORE=y
-CONFIG_BASE_FULL=y
-CONFIG_FUTEX=y
-CONFIG_EPOLL=y
-CONFIG_SIGNALFD=y
-CONFIG_TIMERFD=y
-CONFIG_EVENTFD=y
-CONFIG_SHMEM=y
-CONFIG_AIO=y
-CONFIG_EMBEDDED=y
-CONFIG_HAVE_PERF_EVENTS=y
-CONFIG_PERF_USE_VMALLOC=y
-
-#
-# Kernel Performance Events And Counters
-#
-CONFIG_PERF_EVENTS=y
-# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
-CONFIG_VM_EVENT_COUNTERS=y
-CONFIG_SLUB_DEBUG=y
-CONFIG_COMPAT_BRK=y
-# CONFIG_SLAB is not set
-CONFIG_SLUB=y
-# CONFIG_SLOB is not set
-CONFIG_PROFILING=y
-CONFIG_TRACEPOINTS=y
-# CONFIG_JUMP_LABEL is not set
-CONFIG_HAVE_64BIT_ALIGNED_ACCESS=y
-CONFIG_HAVE_ARCH_TRACEHOOK=y
-CONFIG_HAVE_DMA_ATTRS=y
-CONFIG_USE_GENERIC_SMP_HELPERS=y
-CONFIG_GENERIC_SMP_IDLE_THREAD=y
-CONFIG_HAVE_CLK=y
-CONFIG_HAVE_DMA_API_DEBUG=y
-CONFIG_HAVE_HW_BREAKPOINT=y
-CONFIG_HAVE_ARCH_JUMP_LABEL=y
-CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION=y
-CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
-CONFIG_MODULES_USE_ELF_RELA=y
-CONFIG_CLONE_BACKWARDS=y
-CONFIG_OLD_SIGSUSPEND3=y
-CONFIG_COMPAT_OLD_SIGACTION=y
-
-#
-# GCOV-based kernel profiling
-#
-# CONFIG_GCOV_KERNEL is not set
-CONFIG_HAVE_GENERIC_DMA_COHERENT=y
-CONFIG_SLABINFO=y
-CONFIG_RT_MUTEXES=y
-CONFIG_BASE_SMALL=0
-# CONFIG_MODULES is not set
-CONFIG_STOP_MACHINE=y
-CONFIG_BLOCK=y
-# CONFIG_BLK_DEV_BSG is not set
-# CONFIG_BLK_DEV_BSGLIB is not set
-# CONFIG_BLK_DEV_INTEGRITY is not set
-
-#
-# Partition Types
-#
-# CONFIG_PARTITION_ADVANCED is not set
-CONFIG_MSDOS_PARTITION=y
-CONFIG_EFI_PARTITION=y
-CONFIG_BLOCK_COMPAT=y
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_DEADLINE=y
-CONFIG_IOSCHED_CFQ=y
-# CONFIG_DEFAULT_DEADLINE is not set
-CONFIG_DEFAULT_CFQ=y
-# CONFIG_DEFAULT_NOOP is not set
-CONFIG_DEFAULT_IOSCHED="cfq"
-CONFIG_UNINLINE_SPIN_UNLOCK=y
-CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
-CONFIG_FREEZER=y
-
-#
-# Platform selection
-#
-# CONFIG_ARCH_VEXPRESS is not set
-# CONFIG_ARCH_MT6735 is not set
-CONFIG_ARCH_MT6735M=y
-# CONFIG_ARCH_MT6753 is not set
-# CONFIG_ARCH_MT6752 is not set
-# CONFIG_ARCH_MT8163 is not set
-# CONFIG_ARCH_MT6795 is not set
-
-#
-# MTK Board Support Package
-#
-CONFIG_MTK_EVB_BOARD=y
-# CONFIG_MTK_FPGA is not set
-CONFIG_MTK_PSCI=y
-CONFIG_MAX_DRAM_SIZE_SUPPORT=0x10000000
-
-#
-# Bus support
-#
-CONFIG_ARM_AMBA=y
-
-#
-# Kernel Features
-#
-# CONFIG_ARM64_64K_PAGES is not set
-CONFIG_SMP=y
-CONFIG_ARM_CPU_TOPOLOGY=y
-# CONFIG_SCHED_MC is not set
-# CONFIG_SCHED_SMT is not set
-# CONFIG_DISABLE_CPU_SCHED_DOMAIN_BALANCE is not set
-# CONFIG_HEVTASK_INTERFACE is not set
-# CONFIG_ARCH_SCALE_INVARIANT_CPU_CAPACITY is not set
-CONFIG_NR_CPUS=8
-CONFIG_SWP_EMULATE=y
-CONFIG_HOTPLUG_CPU=y
-# CONFIG_PREEMPT_NONE is not set
-# CONFIG_PREEMPT_VOLUNTARY is not set
-CONFIG_PREEMPT=y
-CONFIG_PREEMPT_COUNT=y
-CONFIG_HZ=100
-CONFIG_ARCH_HAS_HOLES_MEMORYMODEL=y
-CONFIG_ARCH_SPARSEMEM_ENABLE=y
-CONFIG_ARCH_SPARSEMEM_DEFAULT=y
-CONFIG_ARCH_SELECT_MEMORY_MODEL=y
-CONFIG_HAVE_ARCH_PFN_VALID=y
-CONFIG_HW_PERF_EVENTS=y
-CONFIG_ARMV7_COMPAT=y
-CONFIG_ARMV7_COMPAT_CPUINFO=y
-CONFIG_SELECT_MEMORY_MODEL=y
-CONFIG_SPARSEMEM_MANUAL=y
-CONFIG_SPARSEMEM=y
-CONFIG_HAVE_MEMORY_PRESENT=y
-CONFIG_SPARSEMEM_EXTREME=y
-CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
-CONFIG_SPARSEMEM_VMEMMAP=y
-CONFIG_HAVE_MEMBLOCK=y
-CONFIG_NO_BOOTMEM=y
-# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
-CONFIG_PAGEFLAGS_EXTENDED=y
-CONFIG_SPLIT_PTLOCK_CPUS=999999
-CONFIG_COMPACTION=y
-CONFIG_MIGRATION=y
-CONFIG_PHYS_ADDR_T_64BIT=y
-CONFIG_ZONE_DMA_FLAG=1
-CONFIG_BOUNCE=y
-# CONFIG_KSM is not set
-CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
-CONFIG_CROSS_MEMORY_ATTACH=y
-# CONFIG_CLEANCACHE is not set
-# CONFIG_FRONTSWAP is not set
-CONFIG_SECCOMP=y
-CONFIG_SECCOMP_FILTER=y
-
-#
-# Boot options
-#
-CONFIG_CMDLINE="console=tty0 console=ttyMT3,921600n1 root=/dev/ram vmalloc=496M slub_max_order=0 slub_debug=O "
-CONFIG_CMDLINE_FROM_BOOTLOADER=y
-# CONFIG_CMDLINE_EXTEND is not set
-# CONFIG_CMDLINE_FORCE is not set
-CONFIG_BUILD_ARM64_APPENDED_DTB_IMAGE=y
-CONFIG_BUILD_ARM64_APPENDED_DTB_IMAGE_NAMES="lentk6735m_65c_l1"
-
-#
-# CPU Power Management
-#
-
-#
-# CPU Frequency scaling
-#
-CONFIG_CPU_FREQ=y
-CONFIG_CPU_FREQ_TABLE=y
-CONFIG_CPU_FREQ_GOV_COMMON=y
-CONFIG_CPU_FREQ_STAT=y
-CONFIG_CPU_FREQ_STAT_DETAILS=y
-# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVEPLUS is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
-CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE=y
-# CONFIG_CPU_FREQ_DEFAULT_GOV_BALANCE is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_HOTPLUG is not set
-# CONFIG_CPU_FREQ_GOV_BALANCE is not set
-CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
-CONFIG_CPU_FREQ_GOV_POWERSAVE=y
-CONFIG_CPU_FREQ_GOV_USERSPACE=y
-CONFIG_CPU_FREQ_GOV_ONDEMAND=y
-# CONFIG_CPU_FREQ_GOV_INTERACTIVEPLUS is not set
-CONFIG_CPU_FREQ_GOV_INTERACTIVE=y
-# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
-# CONFIG_CPU_FREQ_GOV_HOTPLUG is not set
-
-#
-# ARM CPU frequency scaling drivers
-#
-# CONFIG_ARM_EXYNOS4210_CPUFREQ is not set
-# CONFIG_ARM_EXYNOS4X12_CPUFREQ is not set
-# CONFIG_ARM_EXYNOS5250_CPUFREQ is not set
-# CONFIG_ARM_KIRKWOOD_CPUFREQ is not set
-
-#
-# Userspace binary formats
-#
-CONFIG_BINFMT_ELF=y
-CONFIG_COMPAT_BINFMT_ELF=y
-# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
-CONFIG_BINFMT_SCRIPT=y
-# CONFIG_HAVE_AOUT is not set
-# CONFIG_BINFMT_MISC is not set
-CONFIG_COREDUMP=y
-CONFIG_COMPAT=y
-
-#
-# Power management options
-#
-CONFIG_SUSPEND=y
-CONFIG_SUSPEND_FREEZER=y
-CONFIG_HAS_WAKELOCK=y
-CONFIG_HAS_EARLYSUSPEND=y
-CONFIG_HAS_SBSUSPEND=y
-CONFIG_WAKELOCK=y
-CONFIG_EARLYSUSPEND=y
-CONFIG_FB_EARLYSUSPEND=y
-CONFIG_HIBERNATE_CALLBACKS=y
-CONFIG_HIBERNATION=y
-CONFIG_PM_STD_PARTITION=""
-CONFIG_TOI_CORE=y
-
-#
-# Image Storage (you need at least one allocator)
-#
-# CONFIG_TOI_FILE is not set
-CONFIG_TOI_SWAP=y
-
-#
-# General Options
-#
-CONFIG_TOI_CRYPTO=y
-CONFIG_TOI_DEFAULT_IMAGE_SIZE_LIMIT=-2
-# CONFIG_TOI_KEEP_IMAGE is not set
-CONFIG_TOI_REPLACE_SWSUSP=y
-# CONFIG_TOI_IGNORE_LATE_INITCALL is not set
-CONFIG_TOI_DEFAULT_WAIT=2
-CONFIG_TOI_DEFAULT_EXTRA_PAGES_ALLOWANCE=2000
-# CONFIG_TOI_CHECKSUM is not set
-CONFIG_TOI=y
-CONFIG_TOI_ZRAM_SUPPORT=y
-CONFIG_TOI_FIXUP=y
-CONFIG_TOI_ENHANCE=y
-CONFIG_PM_SLEEP=y
-CONFIG_PM_SLEEP_SMP=y
-CONFIG_PM_AUTOSLEEP=y
-CONFIG_PM_WAKELOCKS=y
-CONFIG_PM_WAKELOCKS_LIMIT=100
-CONFIG_PM_WAKELOCKS_GC=y
-# CONFIG_PM_RUNTIME is not set
-CONFIG_PM=y
-# CONFIG_PM_DEBUG is not set
-CONFIG_PM_CLK=y
-# CONFIG_SUSPEND_TIME is not set
-CONFIG_ARCH_SUSPEND_POSSIBLE=y
-CONFIG_ARM64_CPU_SUSPEND=y
-CONFIG_ARCH_HIBERNATION_POSSIBLE=y
-CONFIG_NET=y
-CONFIG_COMPAT_NETLINK_MESSAGES=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-# CONFIG_PACKET_DIAG is not set
-CONFIG_UNIX=y
-# CONFIG_UNIX_DIAG is not set
-CONFIG_XFRM=y
-CONFIG_XFRM_ALGO=y
-# CONFIG_XFRM_USER is not set
-# CONFIG_XFRM_SUB_POLICY is not set
-CONFIG_XFRM_MIGRATE=y
-# CONFIG_XFRM_STATISTICS is not set
-CONFIG_XFRM_IPCOMP=y
-CONFIG_NET_KEY=y
-# CONFIG_NET_KEY_MIGRATE is not set
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-CONFIG_IP_ADVANCED_ROUTER=y
-# CONFIG_IP_FIB_TRIE_STATS is not set
-CONFIG_IP_MULTIPLE_TABLES=y
-# CONFIG_IP_ROUTE_MULTIPATH is not set
-# CONFIG_IP_ROUTE_VERBOSE is not set
-CONFIG_IP_ROUTE_CLASSID=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_IP_PNP_RARP is not set
-CONFIG_NET_IPIP=y
-# CONFIG_NET_IPGRE_DEMUX is not set
-CONFIG_NET_IP_TUNNEL=y
-CONFIG_IP_MROUTE=y
-CONFIG_IP_MROUTE_MULTIPLE_TABLES=y
-CONFIG_IP_PIMSM_V1=y
-CONFIG_IP_PIMSM_V2=y
-CONFIG_ARPD=y
-CONFIG_SYN_COOKIES=y
-# CONFIG_NET_IPVTI is not set
-CONFIG_INET_AH=y
-CONFIG_INET_ESP=y
-CONFIG_INET_IPCOMP=y
-CONFIG_INET_XFRM_TUNNEL=y
-CONFIG_INET_TUNNEL=y
-CONFIG_INET_XFRM_MODE_TRANSPORT=y
-CONFIG_INET_XFRM_MODE_TUNNEL=y
-CONFIG_INET_XFRM_MODE_BEET=y
-# CONFIG_INET_LRO is not set
-CONFIG_INET_DIAG=y
-CONFIG_INET_TCP_DIAG=y
-# CONFIG_INET_UDP_DIAG is not set
-# CONFIG_TCP_CONG_ADVANCED is not set
-CONFIG_TCP_CONG_CUBIC=y
-CONFIG_DEFAULT_TCP_CONG="cubic"
-# CONFIG_TCP_MD5SIG is not set
-CONFIG_IPV6=y
-CONFIG_IPV6_PRIVACY=y
-CONFIG_IPV6_ROUTER_PREF=y
-CONFIG_IPV6_ROUTE_INFO=y
-CONFIG_IPV6_OPTIMISTIC_DAD=y
-CONFIG_INET6_AH=y
-CONFIG_INET6_ESP=y
-CONFIG_INET6_IPCOMP=y
-CONFIG_IPV6_MIP6=y
-CONFIG_INET6_XFRM_TUNNEL=y
-CONFIG_INET6_TUNNEL=y
-CONFIG_INET6_XFRM_MODE_TRANSPORT=y
-CONFIG_INET6_XFRM_MODE_TUNNEL=y
-CONFIG_INET6_XFRM_MODE_BEET=y
-CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION=y
-CONFIG_IPV6_SIT=y
-CONFIG_IPV6_SIT_6RD=y
-CONFIG_IPV6_NDISC_NODETYPE=y
-CONFIG_IPV6_TUNNEL=y
-# CONFIG_IPV6_GRE is not set
-CONFIG_IPV6_MULTIPLE_TABLES=y
-CONFIG_IPV6_SUBTREES=y
-CONFIG_IPV6_MROUTE=y
-# CONFIG_IPV6_MROUTE_MULTIPLE_TABLES is not set
-CONFIG_IPV6_PIMSM_V2=y
-CONFIG_MTK_DHCPV6C_WIFI=y
-# CONFIG_NETLABEL is not set
-CONFIG_ANDROID_PARANOID_NETWORK=y
-CONFIG_NET_ACTIVITY_STATS=y
-CONFIG_NETWORK_SECMARK=y
-# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
-CONFIG_NETFILTER=y
-# CONFIG_NETFILTER_DEBUG is not set
-CONFIG_NETFILTER_ADVANCED=y
-CONFIG_BRIDGE_NETFILTER=y
-
-#
-# Core Netfilter Configuration
-#
-CONFIG_NETFILTER_NETLINK=y
-# CONFIG_NETFILTER_NETLINK_ACCT is not set
-CONFIG_NETFILTER_NETLINK_QUEUE=y
-CONFIG_NETFILTER_NETLINK_LOG=y
-CONFIG_NF_CONNTRACK=y
-CONFIG_NF_CONNTRACK_MARK=y
-# CONFIG_NF_CONNTRACK_SECMARK is not set
-CONFIG_NF_CONNTRACK_PROCFS=y
-CONFIG_NF_CONNTRACK_EVENTS=y
-# CONFIG_NF_CONNTRACK_TIMEOUT is not set
-# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
-# CONFIG_NF_CT_PROTO_DCCP is not set
-CONFIG_NF_CT_PROTO_GRE=y
-# CONFIG_NF_CT_PROTO_SCTP is not set
-CONFIG_NF_CT_PROTO_UDPLITE=y
-# CONFIG_NF_CONNTRACK_AMANDA is not set
-CONFIG_NF_CONNTRACK_FTP=y
-# CONFIG_NF_CONNTRACK_H323 is not set
-# CONFIG_NF_CONNTRACK_IRC is not set
-# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
-# CONFIG_NF_CONNTRACK_SNMP is not set
-CONFIG_NF_CONNTRACK_PPTP=y
-# CONFIG_NF_CONNTRACK_SANE is not set
-CONFIG_NF_CONNTRACK_SIP=y
-CONFIG_NF_CONNTRACK_TFTP=y
-CONFIG_NF_CT_NETLINK=y
-# CONFIG_NF_CT_NETLINK_TIMEOUT is not set
-# CONFIG_NETFILTER_NETLINK_QUEUE_CT is not set
-CONFIG_NF_NAT=y
-CONFIG_NF_NAT_NEEDED=y
-CONFIG_NF_NAT_PROTO_UDPLITE=y
-# CONFIG_NF_NAT_AMANDA is not set
-CONFIG_NF_NAT_FTP=y
-# CONFIG_NF_NAT_IRC is not set
-CONFIG_NF_NAT_SIP=y
-CONFIG_NF_NAT_TFTP=y
-CONFIG_NETFILTER_TPROXY=y
-CONFIG_NETFILTER_XTABLES=y
-
-#
-# Xtables combined modules
-#
-CONFIG_NETFILTER_XT_MARK=y
-CONFIG_NETFILTER_XT_CONNMARK=y
-
-#
-# Xtables targets
-#
-# CONFIG_NETFILTER_XT_TARGET_AUDIT is not set
-# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
-CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
-# CONFIG_NETFILTER_XT_TARGET_CONNMARK is not set
-# CONFIG_NETFILTER_XT_TARGET_CT is not set
-# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
-CONFIG_NETFILTER_XT_TARGET_HL=y
-# CONFIG_NETFILTER_XT_TARGET_HMARK is not set
-CONFIG_NETFILTER_XT_TARGET_IDLETIMER=y
-# CONFIG_NETFILTER_XT_TARGET_LED is not set
-# CONFIG_NETFILTER_XT_TARGET_LOG is not set
-CONFIG_NETFILTER_XT_TARGET_MARK=y
-CONFIG_NETFILTER_XT_TARGET_NETMAP=y
-CONFIG_NETFILTER_XT_TARGET_NFLOG=y
-CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
-# CONFIG_NETFILTER_XT_TARGET_NOTRACK is not set
-# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
-CONFIG_NETFILTER_XT_TARGET_REDIRECT=y
-# CONFIG_NETFILTER_XT_TARGET_TEE is not set
-# CONFIG_NETFILTER_XT_TARGET_TPROXY is not set
-# CONFIG_NETFILTER_XT_TARGET_TRACE is not set
-# CONFIG_NETFILTER_XT_TARGET_SECMARK is not set
-CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
-# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
-
-#
-# Xtables matches
-#
-# CONFIG_NETFILTER_XT_MATCH_ADDRTYPE is not set
-# CONFIG_NETFILTER_XT_MATCH_BPF is not set
-# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
-# CONFIG_NETFILTER_XT_MATCH_COMMENT is not set
-CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
-# CONFIG_NETFILTER_XT_MATCH_CONNLABEL is not set
-# CONFIG_NETFILTER_XT_MATCH_CONNLIMIT is not set
-# CONFIG_NETFILTER_XT_MATCH_CONNMARK is not set
-# CONFIG_NETFILTER_XT_MATCH_CONNTRACK is not set
-# CONFIG_NETFILTER_XT_MATCH_CPU is not set
-# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
-# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
-# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
-# CONFIG_NETFILTER_XT_MATCH_ECN is not set
-# CONFIG_NETFILTER_XT_MATCH_ESP is not set
-# CONFIG_NETFILTER_XT_MATCH_HASHLIMIT is not set
-# CONFIG_NETFILTER_XT_MATCH_HELPER is not set
-# CONFIG_NETFILTER_XT_MATCH_HL is not set
-CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
-CONFIG_NETFILTER_XT_MATCH_LENGTH=y
-CONFIG_NETFILTER_XT_MATCH_LIMIT=y
-CONFIG_NETFILTER_XT_MATCH_MAC=y
-CONFIG_NETFILTER_XT_MATCH_MARK=y
-CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
-# CONFIG_NETFILTER_XT_MATCH_NFACCT is not set
-# CONFIG_NETFILTER_XT_MATCH_OSF is not set
-# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
-CONFIG_NETFILTER_XT_MATCH_POLICY=y
-CONFIG_NETFILTER_XT_MATCH_PHYSDEV=y
-# CONFIG_NETFILTER_XT_MATCH_PKTTYPE is not set
-CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
-CONFIG_NETFILTER_XT_MATCH_QUOTA=y
-CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
-CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
-# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
-CONFIG_NETFILTER_XT_MATCH_REALM=y
-CONFIG_NETFILTER_XT_MATCH_RECENT=y
-# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
-CONFIG_NETFILTER_XT_MATCH_SOCKET=y
-CONFIG_NETFILTER_XT_MATCH_STATE=y
-CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
-CONFIG_NETFILTER_XT_MATCH_STRING=y
-CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
-CONFIG_NETFILTER_XT_MATCH_TIME=y
-CONFIG_NETFILTER_XT_MATCH_U32=y
-# CONFIG_IP_SET is not set
-# CONFIG_IP_VS is not set
-
-#
-# IP: Netfilter Configuration
-#
-CONFIG_NF_DEFRAG_IPV4=y
-CONFIG_NF_CONNTRACK_IPV4=y
-CONFIG_NF_CONNTRACK_PROC_COMPAT=y
-CONFIG_IP_NF_IPTABLES=y
-# CONFIG_IP_NF_MATCH_AH is not set
-# CONFIG_IP_NF_MATCH_ECN is not set
-# CONFIG_IP_NF_MATCH_RPFILTER is not set
-# CONFIG_IP_NF_MATCH_TTL is not set
-CONFIG_IP_NF_FILTER=y
-CONFIG_IP_NF_TARGET_REJECT=y
-# CONFIG_IP_NF_TARGET_REJECT_SKERR is not set
-# CONFIG_IP_NF_TARGET_ULOG is not set
-CONFIG_NF_NAT_IPV4=y
-CONFIG_IP_NF_TARGET_MASQUERADE=y
-CONFIG_IP_NF_TARGET_NETMAP=y
-CONFIG_IP_NF_TARGET_REDIRECT=y
-CONFIG_NF_NAT_PROTO_GRE=y
-CONFIG_NF_NAT_PPTP=y
-# CONFIG_NF_NAT_H323 is not set
-CONFIG_IP_NF_MANGLE=y
-# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
-# CONFIG_IP_NF_TARGET_ECN is not set
-# CONFIG_IP_NF_TARGET_TTL is not set
-CONFIG_IP_NF_RAW=y
-# CONFIG_IP_NF_SECURITY is not set
-CONFIG_IP_NF_ARPTABLES=y
-# CONFIG_IP_NF_ARPFILTER is not set
-# CONFIG_IP_NF_ARP_MANGLE is not set
-
-#
-# IPv6: Netfilter Configuration
-#
-CONFIG_NF_DEFRAG_IPV6=y
-CONFIG_NF_CONNTRACK_IPV6=y
-CONFIG_IP6_NF_IPTABLES=y
-# CONFIG_IP6_NF_MATCH_AH is not set
-# CONFIG_IP6_NF_MATCH_EUI64 is not set
-CONFIG_IP6_NF_MATCH_FRAG=y
-# CONFIG_IP6_NF_MATCH_OPTS is not set
-# CONFIG_IP6_NF_MATCH_HL is not set
-CONFIG_IP6_NF_MATCH_IPV6HEADER=y
-# CONFIG_IP6_NF_MATCH_MH is not set
-# CONFIG_IP6_NF_MATCH_RPFILTER is not set
-# CONFIG_IP6_NF_MATCH_RT is not set
-CONFIG_IP6_NF_TARGET_HL=y
-CONFIG_IP6_NF_FILTER=y
-CONFIG_IP6_NF_TARGET_REJECT=y
-CONFIG_IP6_NF_TARGET_REJECT_SKERR=y
-CONFIG_IP6_NF_MANGLE=y
-CONFIG_IP6_NF_RAW=y
-# CONFIG_IP6_NF_SECURITY is not set
-# CONFIG_NF_NAT_IPV6 is not set
-# CONFIG_BRIDGE_NF_EBTABLES is not set
-# CONFIG_IP_DCCP is not set
-# CONFIG_IP_SCTP is not set
-# CONFIG_RDS is not set
-# CONFIG_TIPC is not set
-# CONFIG_ATM is not set
-# CONFIG_L2TP is not set
-CONFIG_STP=y
-CONFIG_BRIDGE=y
-CONFIG_BRIDGE_IGMP_SNOOPING=y
-# CONFIG_BRIDGE_VLAN_FILTERING is not set
-CONFIG_HAVE_NET_DSA=y
-CONFIG_VLAN_8021Q=y
-# CONFIG_VLAN_8021Q_GVRP is not set
-# CONFIG_VLAN_8021Q_MVRP is not set
-# CONFIG_DECNET is not set
-CONFIG_LLC=y
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_PHONET is not set
-# CONFIG_IEEE802154 is not set
-CONFIG_NET_SCHED=y
-
-#
-# Queueing/Scheduling
-#
-# CONFIG_NET_SCH_CBQ is not set
-CONFIG_NET_SCH_HTB=y
-# CONFIG_NET_SCH_HFSC is not set
-# CONFIG_NET_SCH_PRIO is not set
-# CONFIG_NET_SCH_MULTIQ is not set
-# CONFIG_NET_SCH_RED is not set
-# CONFIG_NET_SCH_SFB is not set
-# CONFIG_NET_SCH_SFQ is not set
-# CONFIG_NET_SCH_TEQL is not set
-# CONFIG_NET_SCH_TBF is not set
-# CONFIG_NET_SCH_GRED is not set
-# CONFIG_NET_SCH_DSMARK is not set
-# CONFIG_NET_SCH_NETEM is not set
-# CONFIG_NET_SCH_DRR is not set
-# CONFIG_NET_SCH_MQPRIO is not set
-# CONFIG_NET_SCH_CHOKE is not set
-# CONFIG_NET_SCH_QFQ is not set
-# CONFIG_NET_SCH_CODEL is not set
-# CONFIG_NET_SCH_FQ_CODEL is not set
-CONFIG_NET_SCH_INGRESS=y
-# CONFIG_NET_SCH_PLUG is not set
-
-#
-# Classification
-#
-CONFIG_NET_CLS=y
-# CONFIG_NET_CLS_BASIC is not set
-# CONFIG_NET_CLS_TCINDEX is not set
-# CONFIG_NET_CLS_ROUTE4 is not set
-CONFIG_NET_CLS_FW=y
-CONFIG_NET_CLS_U32=y
-CONFIG_CLS_U32_PERF=y
-CONFIG_CLS_U32_MARK=y
-# CONFIG_NET_CLS_RSVP is not set
-# CONFIG_NET_CLS_RSVP6 is not set
-CONFIG_NET_CLS_FLOW=y
-# CONFIG_NET_CLS_CGROUP is not set
-# CONFIG_NET_EMATCH is not set
-CONFIG_NET_CLS_ACT=y
-CONFIG_NET_ACT_POLICE=y
-# CONFIG_NET_ACT_GACT is not set
-CONFIG_NET_ACT_MIRRED=y
-CONFIG_NET_ACT_IPT=y
-# CONFIG_NET_ACT_NAT is not set
-# CONFIG_NET_ACT_PEDIT is not set
-# CONFIG_NET_ACT_SIMP is not set
-# CONFIG_NET_ACT_SKBEDIT is not set
-# CONFIG_NET_ACT_CSUM is not set
-CONFIG_NET_CLS_IND=y
-CONFIG_NET_SCH_FIFO=y
-# CONFIG_DCB is not set
-# CONFIG_BATMAN_ADV is not set
-# CONFIG_OPENVSWITCH is not set
-# CONFIG_VSOCKETS is not set
-# CONFIG_NETLINK_MMAP is not set
-# CONFIG_NETLINK_DIAG is not set
-CONFIG_RPS=y
-CONFIG_RFS_ACCEL=y
-CONFIG_XPS=y
-# CONFIG_NETPRIO_CGROUP is not set
-CONFIG_BQL=y
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-CONFIG_NET_DROP_MONITOR=y
-# CONFIG_HAMRADIO is not set
-# CONFIG_CAN is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
-# CONFIG_AF_RXRPC is not set
-CONFIG_FIB_RULES=y
-CONFIG_WIRELESS=y
-CONFIG_WIRELESS_EXT=y
-CONFIG_WEXT_CORE=y
-CONFIG_WEXT_PROC=y
-CONFIG_WEXT_PRIV=y
-CONFIG_CFG80211=y
-CONFIG_NL80211_TESTMODE=y
-CONFIG_CFG80211_DEVELOPER_WARNINGS=y
-# CONFIG_CFG80211_REG_DEBUG is not set
-# CONFIG_CFG80211_CERTIFICATION_ONUS is not set
-# CONFIG_CFG80211_DEFAULT_PS is not set
-CONFIG_CFG80211_DEBUGFS=y
-CONFIG_CFG80211_INTERNAL_REGDB=y
-CONFIG_CFG80211_WEXT=y
-# CONFIG_LIB80211 is not set
-CONFIG_CFG80211_ALLOW_RECONNECT=y
-# CONFIG_MAC80211 is not set
-# CONFIG_WIMAX is not set
-# CONFIG_RFKILL is not set
-# CONFIG_RFKILL_REGULATOR is not set
-# CONFIG_NET_9P is not set
-# CONFIG_CAIF is not set
-# CONFIG_CEPH_LIB is not set
-# CONFIG_NFC is not set
-CONFIG_MTK_NET_LOGGING=y
-
-#
-# Device Drivers
-#
-
-#
-# Generic Driver Options
-#
-CONFIG_UEVENT_HELPER_PATH=""
-# CONFIG_DEVTMPFS is not set
-CONFIG_STANDALONE=y
-CONFIG_PREVENT_FIRMWARE_BUILD=y
-CONFIG_FW_LOADER=y
-CONFIG_FIRMWARE_IN_KERNEL=y
-CONFIG_EXTRA_FIRMWARE=""
-CONFIG_FW_LOADER_USER_HELPER=y
-# CONFIG_DEBUG_DRIVER is not set
-# CONFIG_DEBUG_DEVRES is not set
-# CONFIG_SYS_HYPERVISOR is not set
-# CONFIG_GENERIC_CPU_DEVICES is not set
-CONFIG_HAVE_CPU_AUTOPROBE=y
-CONFIG_GENERIC_CPU_AUTOPROBE=y
-CONFIG_REGMAP=y
-CONFIG_REGMAP_I2C=y
-CONFIG_REGMAP_SPI=y
-CONFIG_DMA_SHARED_BUFFER=y
-
-#
-# Bus devices
-#
-# CONFIG_CONNECTOR is not set
-CONFIG_MTD=y
-# CONFIG_MTD_REDBOOT_PARTS is not set
-# CONFIG_MTD_CMDLINE_PARTS is not set
-CONFIG_MTD_OF_PARTS=y
-# CONFIG_MTD_AR7_PARTS is not set
-
-#
-# User Modules And Translation Layers
-#
-CONFIG_MTD_BLKDEVS=y
-CONFIG_MTD_BLOCK=y
-# CONFIG_FTL is not set
-# CONFIG_NFTL is not set
-# CONFIG_INFTL is not set
-# CONFIG_RFD_FTL is not set
-# CONFIG_SSFDC is not set
-# CONFIG_SM_FTL is not set
-# CONFIG_MTD_OOPS is not set
-# CONFIG_MTD_SWAP is not set
-
-#
-# RAM/ROM/Flash chip drivers
-#
-# CONFIG_MTD_CFI is not set
-# CONFIG_MTD_JEDECPROBE is not set
-CONFIG_MTD_MAP_BANK_WIDTH_1=y
-CONFIG_MTD_MAP_BANK_WIDTH_2=y
-CONFIG_MTD_MAP_BANK_WIDTH_4=y
-# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
-CONFIG_MTD_CFI_I1=y
-CONFIG_MTD_CFI_I2=y
-# CONFIG_MTD_CFI_I4 is not set
-# CONFIG_MTD_CFI_I8 is not set
-# CONFIG_MTD_RAM is not set
-# CONFIG_MTD_ROM is not set
-# CONFIG_MTD_ABSENT is not set
-
-#
-# Mapping drivers for chip access
-#
-# CONFIG_MTD_COMPLEX_MAPPINGS is not set
-# CONFIG_MTD_PLATRAM is not set
-
-#
-# Self-contained MTD device drivers
-#
-# CONFIG_MTD_DATAFLASH is not set
-# CONFIG_MTD_M25P80 is not set
-# CONFIG_MTD_SST25L is not set
-# CONFIG_MTD_SLRAM is not set
-# CONFIG_MTD_PHRAM is not set
-# CONFIG_MTD_MTDRAM is not set
-# CONFIG_MTD_BLOCK2MTD is not set
-
-#
-# Disk-On-Chip Device Drivers
-#
-# CONFIG_MTD_DOCG3 is not set
-CONFIG_MTD_NAND_IDS=y
-# CONFIG_MTD_NAND is not set
-# CONFIG_MTD_ONENAND is not set
-
-#
-# LPDDR flash memory drivers
-#
-# CONFIG_MTD_LPDDR is not set
-# CONFIG_MTD_UBI is not set
-CONFIG_DTC=y
-CONFIG_OF=y
-
-#
-# Device Tree and Open Firmware support
-#
-# CONFIG_PROC_DEVICETREE is not set
-# CONFIG_OF_SELFTEST is not set
-CONFIG_OF_FLATTREE=y
-CONFIG_OF_EARLY_FLATTREE=y
-CONFIG_OF_ADDRESS=y
-CONFIG_OF_IRQ=y
-CONFIG_OF_DEVICE=y
-CONFIG_OF_I2C=y
-CONFIG_OF_NET=y
-CONFIG_OF_MTD=y
-CONFIG_OF_RESERVED_MEM=y
-# CONFIG_PARPORT is not set
-CONFIG_BLK_DEV=y
-# CONFIG_BLK_DEV_COW_COMMON is not set
-CONFIG_BLK_DEV_LOOP=y
-CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
-# CONFIG_BLK_DEV_CRYPTOLOOP is not set
-# CONFIG_BLK_DEV_DRBD is not set
-# CONFIG_BLK_DEV_NBD is not set
-# CONFIG_BLK_DEV_RAM is not set
-# CONFIG_CDROM_PKTCDVD is not set
-# CONFIG_ATA_OVER_ETH is not set
-# CONFIG_BLK_DEV_RBD is not set
-
-#
-# Misc devices
-#
-# CONFIG_ANDROID_PMEM is not set
-# CONFIG_SENSORS_LIS3LV02D is not set
-# CONFIG_AD525X_DPOT is not set
-# CONFIG_ATMEL_PWM is not set
-# CONFIG_DUMMY_IRQ is not set
-# CONFIG_ICS932S401 is not set
-# CONFIG_ATMEL_SSC is not set
-# CONFIG_ENCLOSURE_SERVICES is not set
-# CONFIG_APDS9802ALS is not set
-# CONFIG_ISL29003 is not set
-# CONFIG_ISL29020 is not set
-# CONFIG_SENSORS_TSL2550 is not set
-# CONFIG_SENSORS_BH1780 is not set
-# CONFIG_SENSORS_BH1770 is not set
-# CONFIG_SENSORS_APDS990X is not set
-# CONFIG_HMC6352 is not set
-# CONFIG_DS1682 is not set
-# CONFIG_TI_DAC7512 is not set
-CONFIG_UID_STAT=y
-# CONFIG_BMP085_I2C is not set
-# CONFIG_BMP085_SPI is not set
-# CONFIG_USB_SWITCH_FSA9480 is not set
-# CONFIG_LATTICE_ECP3_CONFIG is not set
-# CONFIG_SRAM is not set
-# CONFIG_C2PORT is not set
-
-#
-# EEPROM support
-#
-# CONFIG_EEPROM_AT24 is not set
-# CONFIG_EEPROM_AT25 is not set
-# CONFIG_EEPROM_LEGACY is not set
-# CONFIG_EEPROM_MAX6875 is not set
-# CONFIG_EEPROM_93CX6 is not set
-# CONFIG_EEPROM_93XX46 is not set
-
-#
-# Texas Instruments shared transport line discipline
-#
-# CONFIG_TI_ST is not set
-# CONFIG_SENSORS_LIS3_SPI is not set
-# CONFIG_SENSORS_LIS3_I2C is not set
-
-#
-# Altera FPGA firmware download module
-#
-# CONFIG_ALTERA_STAPL is not set
-CONFIG_MEDIATEK_SOLUTION=y
-CONFIG_MTK_PLATFORM="mt6735"
-CONFIG_ARCH_MTK_PROJECT="lentk6735m_65c_l1"
-# CONFIG_MTK_INTERNAL is not set
-CONFIG_MTK_CIRQ=y
-CONFIG_MTK_SYS_CIRQ=y
-CONFIG_MTK_SYSTRACKER=y
-# CONFIG_MTK_L2C_SHARE is not set
-CONFIG_HAVE_AEE_FEATURE=y
-CONFIG_HAVE_XLOG_FEATURE=y
-# CONFIG_FPGA_EARLY_PORTING is not set
-CONFIG_MTK_EMMC_SUPPORT=y
-CONFIG_MTK_NEW_COMBO_EMMC_SUPPORT=y
-CONFIG_MTK_GPT_SCHEME_SUPPORT=y
-# CONFIG_MTK_SHARED_SDCARD is not set
-CONFIG_MTK_MULTI_STORAGE_SUPPORT=y
-# CONFIG_MTK_MULTI_PARTITION_MOUNT_ONLY_SUPPORT is not set
-CONFIG_MTK_SECURITY_SW_SUPPORT=y
-# CONFIG_HAVE_MTK_IN_HOUSE_TEE_SUPPORT is not set
-# CONFIG_HAVE_TRUSTONIC_TEE_SUPPORT is not set
-# CONFIG_MTK_THERMAL_STATUS_COLLECTION is not set
-# CONFIG_MD32_SUPPORT is not set
-CONFIG_MTK_MEMCFG=y
-# CONFIG_MTK_DT_SUPPORT is not set
-# CONFIG_MTK_SMARTBOOK_SUPPORT is not set
-CONFIG_MTK_SENSOR_SUPPORT=y
-CONFIG_MTK_AUTO_DETECT_ACCELEROMETER=y
-# CONFIG_MTK_AUTO_DETECT_MAGNETOMETER is not set
-# CONFIG_MTK_AUTO_DETECT_ALSPS is not set
-CONFIG_CUSTOM_KERNEL_ACCELEROMETER=y
-CONFIG_CUSTOM_KERNEL_GYROSCOPE=y
-CONFIG_CUSTOM_KERNEL_ALSPS=y
-# CONFIG_CUSTOM_SEC_AUTH_SUPPORT is not set
-CONFIG_CUSTOM_KERNEL_MAGNETOMETER=y
-# CONFIG_CUSTOM_KERNEL_BAROMETER is not set
-# CONFIG_MTK_SENSOR_HUB_SUPPORT is not set
-CONFIG_CUSTOM_KERNEL_SENSORHUB=""
-CONFIG_CUSTOM_KERNEL_STEP_COUNTER=""
-CONFIG_CUSTOM_KERNEL_SIGNIFICANT_MOTION_SENSOR=""
-CONFIG_CUSTOM_KERNEL_ACTIVITY_SENSOR=""
-CONFIG_CUSTOM_KERNEL_PICK_UP_SENSOR=""
-CONFIG_CUSTOM_KERNEL_SHAKE_SENSOR=""
-CONFIG_CUSTOM_KERNEL_FACE_DOWN_SENSOR=""
-CONFIG_CUSTOM_KERNEL_IN_POCKET_SENSOR=""
-CONFIG_CUSTOM_KERNEL_PEDOMETER=""
-CONFIG_CUSTOM_KERNEL_HEART_RATE_SENSOR=""
-CONFIG_CUSTOM_KERNEL_TILT_DETECTOR_SENSOR=""
-CONFIG_CUSTOM_KERNEL_WAKE_GESTURE_SENSOR=""
-CONFIG_CUSTOM_KERNEL_GLANCE_GESTURE_SENSOR=""
-CONFIG_CUSTOM_KERNEL_IMGSENSOR="imx219_mipi_raw ov8858_mipi_raw ov5648_mipi_raw ov2680_mipi_raw"
-CONFIG_CUSTOM_KERNEL_CAM_CAL_DRV="imx219_eeprom"
-CONFIG_CUSTOM_KERNEL_LCM="otm1284a_hd_dsi_vdo"
-CONFIG_CUSTOM_KERNEL_FLASHLIGHT="constant_flashlight"
-CONFIG_CUSTOM_KERNEL_EXTMD=""
-CONFIG_CUSTOM_KERNEL_SSW="ssw_single_v2"
-# CONFIG_MTK_FORCE_CLUSTER1 is not set
-# CONFIG_MTK_MMPROFILE_SUPPORT is not set
-CONFIG_MTK_HIBERNATION=y
-# CONFIG_CUSTOM_KERNEL_CHARGEPUMP is not set
-# CONFIG_MTK_TC1_FEATURE is not set
-# CONFIG_MTK_TC7_FEATURE is not set
-# CONFIG_MTK_TC1_FM_AT_SUSPEND is not set
-
-#
-# Kernel Configurations
-#
-
-#
-# Tracer Related
-#
-CONFIG_MTK_SCHED_TRACERS=y
-CONFIG_MTK_FTRACE_DEFAULT_ENABLE=y
-# CONFIG_MTK_KERNEL_MARKER is not set
-# CONFIG_MT65XX_TRACER is not set
-
-#
-# MET
-#
-CONFIG_MTK_MET=y
-CONFIG_MTK_MET_PLF=y
-
-#
-# MTPROF tools
-#
-CONFIG_MTK_MUTATION=y
-CONFIG_MTPROF_CPUTIME=y
-CONFIG_MTPROF_IRQ_DURATION=y
-CONFIG_MTK_AEE_FEATURE=y
-CONFIG_MTK_AEE_AED=y
-CONFIG_MTK_AEE_IPANIC=y
-# CONFIG_MTK_AEE_POWERKEY_HANG_DETECT is not set
-CONFIG_MTK_AEE_MRDUMP=y
-# CONFIG_ANDROID_VMEM is not set
-# CONFIG_CPUTIME_SUPPORT is not set
-# CONFIG_CPUTIME_STATS is not set
-CONFIG_MTK_RAM_CONSOLE=y
-# CONFIG_MTK_RAM_CONSOLE_USING_SRAM is not set
-CONFIG_MTK_RAM_CONSOLE_USING_DRAM=y
-CONFIG_MTK_RAM_CONSOLE_SIZE=0x3000
-CONFIG_MTK_RAM_CONSOLE_ADDR=0xF912D000
-CONFIG_MTK_RAM_CONSOLE_DRAM_SIZE=0x10000
-CONFIG_MTK_RAM_CONSOLE_DRAM_ADDR=0x43F00000
-CONFIG_PREEMPT_MONITOR=y
-CONFIG_ISR_MONITOR=y
-CONFIG_MT_SCHED_MONITOR=y
-# CONFIG_MT_CHRDEV_REG is not set
-# CONFIG_MT_LOCK_DEBUG is not set
-# CONFIG_MT_DEBUG_MUTEXES is not set
-CONFIG_PRINTK_PROCESS_INFO=y
-CONFIG_MT_PRINTK_UART_CONSOLE=y
-CONFIG_MT_ENG_BUILD=y
-CONFIG_RAMDISK_OFFSET=0xF00000
-# CONFIG_EARLY_LINUX_PORTING is not set
-# CONFIG_MTK_MCI is not set
-# CONFIG_MTK_ETM is not set
-
-#
-# MT load balance and schedule enhancement
-#
-CONFIG_MT_SCHED=y
-CONFIG_MT_LOAD_BALANCE_ENHANCEMENT=y
-# CONFIG_MT_LOAD_BALANCE_PROFILER is not set
-CONFIG_MTK_COMPAT=y
-CONFIG_MT_SCHED_INTEROP=y
-CONFIG_MTK_SCHED_RQAVG_US=y
-CONFIG_MTK_SCHED_RQAVG_KS=y
-# CONFIG_MT_PRIO_TRACER is not set
-CONFIG_MT_SCHED_TRACE=y
-# CONFIG_MT_SCHED_DEBUG is not set
-# CONFIG_MT_DEBUG_PREEMPT is not set
-
-#
-# MTK Cluster MultiProcessor Scheduler
-#
-CONFIG_MTK_CPU_TOPOLOGY=y
-# CONFIG_MTK_WQ_DEBUG is not set
-CONFIG_MTK_STORAGE_PID_LOGGER=y
-
-#
-# MTK Large Memory mode support
-#
-# CONFIG_MTK_LM_MODE is not set
-# CONFIG_MTK_TABLET_HARDWARE is not set
-CONFIG_GATOR_DRIVER=y
-# CONFIG_MTK_IPV6_TETHER_NDP_MODE is not set
-# CONFIG_MTK_EMMC_SUPPORT_OTP is not set
-CONFIG_MTK_TETHERINGIPV6_SUPPORT=y
-CONFIG_MTK_LEGACY=y
-
-#
-# Drivers Configurations
-#
-# CONFIG_MTK_LDVT is not set
-CONFIG_MTK_ACCDET=y
-# CONFIG_MTK_IRTX_SUPPORT is not set
-CONFIG_MTK_CCCI_DEVICES=y
-# CONFIG_MTK_CCCI_DRIVER is not set
-# CONFIG_MTK_CCCI_EXT is not set
-CONFIG_MTK_ECCCI_DRIVER=y
-CONFIG_MTK_ECCCI_CLDMA=y
-# CONFIG_MTK_ECCCI_CCIF is not set
-# CONFIG_MTK_ECCCI_UT is not set
-# CONFIG_MTK_MD_LOW_BAT_SUPPORT is not set
-CONFIG_MTK_NET_CCMNI=y
-CONFIG_MTK_ENABLE_MD1=y
-CONFIG_MTK_MD1_SUPPORT=6
-CONFIG_MD1_SIZE=0x5000000
-CONFIG_MD1_SMEM_SIZE=0x200000
-# CONFIG_MTK_ENABLE_MD2 is not set
-CONFIG_MTK_MD_SBP_CUSTOM_VALUE=""
-CONFIG_MTK_MD2_SBP_CUSTOM_VALUE=""
-CONFIG_MTK_UMTS_TDD128_MODE=y
-# CONFIG_MTK_EMCI_DEVICES is not set
-CONFIG_MTK_EXTERNAL_MODEM_SLOT=""
-# CONFIG_MTK_SWITCH_TX_POWER is not set
-CONFIG_MTK_CONN_LTE_IDC_SUPPORT=y
-CONFIG_MTK_FB=y
-CONFIG_MTK_FB_SUPPORT_ASSERTION_LAYER=y
-CONFIG_MTK_DITHERING_SUPPORT=y
-CONFIG_MTK_LCM_PHYSICAL_ROTATION="0"
-CONFIG_LCM_HEIGHT="1280"
-CONFIG_LCM_WIDTH="720"
-CONFIG_CUSTOM_LCM_X="0"
-CONFIG_CUSTOM_LCM_Y="0"
-# CONFIG_MTK_OVERLAY_ENGINE_SUPPORT is not set
-# CONFIG_MTK_TVOUT_SUPPORT is not set
-# CONFIG_MIXMODE_FOR_INCELL is not set
-# CONFIG_LCM_SEND_CMD_IN_VIDEO is not set
-CONFIG_GPS=y
-CONFIG_MTK_GPS=y
-# CONFIG_MTK_NFC is not set
-# CONFIG_NFC_MT6605 is not set
-# CONFIG_NFC_MSR3110 is not set
-CONFIG_MTK_BTIF=y
-CONFIG_MTK_COMBO=y
-# CONFIG_MTK_COMBO_CHIP_MT6620 is not set
-# CONFIG_MTK_COMBO_CHIP_MT6628 is not set
-# CONFIG_MTK_COMBO_CHIP_MT6630 is not set
-# CONFIG_MTK_COMBO_CHIP_CONSYS_6572 is not set
-# CONFIG_MTK_COMBO_CHIP_CONSYS_6582 is not set
-# CONFIG_MTK_COMBO_CHIP_CONSYS_8127 is not set
-# CONFIG_MTK_COMBO_CHIP_CONSYS_6752 is not set
-# CONFIG_MTK_COMBO_CHIP_CONSYS_6592 is not set
-# CONFIG_MTK_COMBO_CHIP_CONSYS_8163 is not set
-CONFIG_MTK_COMBO_CHIP_CONSYS_6735=y
-# CONFIG_MTK_COMBO_CHIP_CONSYS_6580 is not set
-CONFIG_MTK_COMBO_CHIP="CONSYS_6735"
-CONFIG_MTK_WAPI_SUPPORT=y
-CONFIG_MTK_PASSPOINT_R1_SUPPORT=y
-# CONFIG_MTK_PASSPOINT_R2_SUPPORT is not set
-CONFIG_MTK_WIFI_MCC_SUPPORT=y
-CONFIG_MTK_COMBO_PLAT_PATH=""
-# CONFIG_MTK_COMBO_COMM is not set
-CONFIG_MTK_COMBO_BT=y
-# CONFIG_MTK_COMBO_ANT is not set
-CONFIG_MTK_COMBO_GPS=y
-CONFIG_MTK_GPS_SUPPORT=y
-CONFIG_MTK_COMBO_WIFI=y
-CONFIG_MTK_BT_SUPPORT=y
-# CONFIG_MTK_WFD_SUPPORT is not set
-CONFIG_MTK_FM=y
-CONFIG_MTK_FM_SUPPORT=y
-CONFIG_MTK_FM_CHIP="MT6625_FM"
-# CONFIG_MTK_FM_50KHZ_SUPPORT is not set
-# CONFIG_MTK_MERGE_INTERFACE_SUPPORT is not set
-# CONFIG_SDIOAUTOK_SUPPORT is not set
-# CONFIG_MTK_MT6306_SUPPORT is not set
-# CONFIG_MTK_IDLE_TIME_FIX is not set
-CONFIG_MTK_G2D=y
-CONFIG_MTK_MPEG4_DEC_DRIVER=y
-CONFIG_MTK_MPEG4_ENC_DRIVER=y
-CONFIG_MTK_H264_DEC_DRIVER=y
-CONFIG_MTK_MFLEXVIDEO_DRIVER=y
-CONFIG_MTK_VIDEOCODEC_DRIVER=y
-# CONFIG_MTK_MJC_DRIVER is not set
-CONFIG_MTK_I2C=y
-CONFIG_MTK_SPI=y
-# CONFIG_MTK_CMMB is not set
-CONFIG_MTK_JPEG=y
-CONFIG_MTK_KEYPAD=y
-# CONFIG_KEYBOARD_HID is not set
-CONFIG_MTK_LEDS=y
-CONFIG_MTK_MMC=y
-# CONFIG_MTK_SDIOAUTOK_SUPPORT is not set
-
-#
-# MediaTek OFN / Jogball Related Drivers
-#
-# CONFIG_MOUSE_PANASONIC_EVQWJN is not set
-# CONFIG_MOUSE_AVAGOTECH_A320 is not set
-CONFIG_MTK_SMART_BATTERY=y
-CONFIG_MTK_PMIC=y
-CONFIG_MTK_PMIC_WRAP=y
-# CONFIG_MTK_PMIC_MT6397 is not set
-# CONFIG_POWER_EXT is not set
-# CONFIG_MTK_POWER_EXT_DETECT is not set
-# CONFIG_MTK_PUMP_EXPRESS_SUPPORT is not set
-# CONFIG_MTK_PUMP_EXPRESS_PLUS_SUPPORT is not set
-# CONFIG_MTK_VOW_SUPPORT is not set
-# CONFIG_MTK_EXTERNAL_LDO is not set
-# CONFIG_X2_BQ27531_SUPPORT is not set
-# CONFIG_MTK_BQ24250_SUPPORT is not set
-# CONFIG_MTK_BQ24261_SUPPORT is not set
-# CONFIG_MTK_BQ24196_SUPPORT is not set
-# CONFIG_MTK_FAN5405_SUPPORT is not set
-# CONFIG_MTK_FAN5402_SUPPORT is not set
-# CONFIG_MTK_BQ24158_SUPPORT is not set
-# CONFIG_MTK_BQ24296_SUPPORT is not set
-# CONFIG_MTK_BQ27541_SUPPORT is not set
-# CONFIG_MTK_NCP1851_SUPPORT is not set
-# CONFIG_MTK_NCP1854_SUPPORT is not set
-# CONFIG_MTK_RT9536_SUPPORT is not set
-# CONFIG_MTK_MAX8971_SUPPORT is not set
-# CONFIG_MTK_DUAL_INPUT_CHARGER_SUPPORT is not set
-# CONFIG_MTK_WIRELESS_CHARGER_SUPPORT is not set
-# CONFIG_MTK_JEITA_STANDARD_SUPPORT is not set
-CONFIG_MTK_RTC=y
-CONFIG_MTK_SERIAL=y
-CONFIG_MTK_SERIAL_CONSOLE=y
-# CONFIG_MTK_SERIAL_MODEM_TEST is not set
-# CONFIG_MTK_UART_USB_SWITCH is not set
-CONFIG_MTK_SIM2=y
-# CONFIG_MTK_SOUND is not set
-# CONFIG_MTK_AUDIO_EXTCODEC_SUPPORT is not set
-# CONFIG_MTK_CM36283 is not set
-# CONFIG_MTK_GP2AP002S00F is not set
-# CONFIG_MTK_APM_16D is not set
-# CONFIG_MTK_EPL2182 is not set
-# CONFIG_MTK_EPL2182_NEW is not set
-# CONFIG_MTK_STK3X1X is not set
-# CONFIG_MTK_STK3X1X_NEW is not set
-# CONFIG_MTK_CM36652_NEW is not set
-# CONFIG_MTK_APDS9930 is not set
-# CONFIG_MTK_CM3232_NEW is not set
-# CONFIG_MTK_APDS9930_NEW is not set
-# CONFIG_MTK_KXTJ2_1009 is not set
-# CONFIG_MTK_KXTIK1004 is not set
-# CONFIG_MTK_K2DH is not set
-# CONFIG_MTK_BMA222E is not set
-# CONFIG_MTK_BMA222E_NEW is not set
-# CONFIG_MTK_MC3410_NEW is not set
-# CONFIG_MTK_KXTJ2_1009_AUTO is not set
-# CONFIG_MTK_MC3XXX is not set
-# CONFIG_MTK_MPU6050G_NEW is not set
-# CONFIG_MTK_BMA250 is not set
-# CONFIG_MTK_MPU6515A is not set
-# CONFIG_MTK_MPU60X0 is not set
-CONFIG_MTK_KXTJ2_1009_NEW=y
-CONFIG_MTK_MC3XXX_AUTO=y
-# CONFIG_MTK_BMA250E is not set
-# CONFIG_MTK_MPU3050C is not set
-# CONFIG_MTK_MPU3000 is not set
-# CONFIG_MTK_MPU3000_NEW is not set
-# CONFIG_MTK_MPU6050GY_NEW is not set
-# CONFIG_MTK_ITG1010_NEW is not set
-# CONFIG_MTK_MPU6515G is not set
-# CONFIG_MTK_MPU3050C_NEW is not set
-# CONFIG_MTK_MPU6050C is not set
-# CONFIG_MTK_AKM8963 is not set
-# CONFIG_MTK_AKM8963_NEW is not set
-# CONFIG_MTK_AKM09911 is not set
-CONFIG_MTK_AKM09911_NEW=y
-# CONFIG_MTK_HSCDTD006 is not set
-# CONFIG_MTK_BMM050 is not set
-# CONFIG_MTK_BMM050_NEW is not set
-# CONFIG_MTK_MMC3416X is not set
-# CONFIG_MTK_BMA050 is not set
-# CONFIG_MTK_BMA050_NEW is not set
-# CONFIG_MTK_BMA255_SDO0 is not set
-# CONFIG_MTK_BMA255_SDO1 is not set
-# CONFIG_MTK_S2200 is not set
-# CONFIG_MTK_YAS532 is not set
-# CONFIG_MTK_YAS532_NEW is not set
-# CONFIG_MTK_BMP180_NEW is not set
-CONFIG_MTK_TOUCHPANEL=y
-# CONFIG_MTK_S7020 is not set
-CONFIG_MTK_USB_GADGET=y
-# CONFIG_USB_MU3D_PIO_ONLY is not set
-# CONFIG_USB_MU3D_DRV is not set
-# CONFIG_USB_MU3D_DVT is not set
-# CONFIG_MU3_PHY is not set
-# CONFIG_MTK_XHCI is not set
-# CONFIG_MTK_OTG_PMIC_BOOST_5V is not set
-# CONFIG_MTK_OTG_OC_DETECTOR is not set
-# CONFIG_MTK_TEST_XHCI is not set
-# CONFIG_USBIF_COMPLIANCE is not set
-# CONFIG_MTK_S3320 is not set
-# CONFIG_MTK_S3320_47 is not set
-# CONFIG_MTK_S3320_50 is not set
-# CONFIG_LEDS_LM3632 is not set
-# CONFIG_LEDS_LM3639 is not set
-# CONFIG_LEDS_RT8542 is not set
-CONFIG_MTK_VIBRATOR=y
-CONFIG_MTK_WD_KICKER=y
-# CONFIG_MT592X_SDIO_CLNT is not set
-CONFIG_USB_MTK_ACM_TEMP=y
-CONFIG_USB_MTK_HDRC=y
-CONFIG_USB_MTK_HDRC_GADGET=y
-# CONFIG_USB_MTK_OTG is not set
-# CONFIG_USB_MTK_DUALMODE is not set
-CONFIG_USB_MTK_DEBUG_FS=y
-CONFIG_USB_MTK_DEBUG=y
-# CONFIG_USB_MTK_HDRC_HCD is not set
-# CONFIG_MTK_USB_UNIQUE_SERIAL is not set
-# CONFIG_MTK_USBFSH is not set
-# CONFIG_MUSBFSH_PIO_ONLY is not set
-# CONFIG_MTK_MUSB_QMU_SUPPORT is not set
-CONFIG_AMPC_CDEV_NUM=151
-CONFIG_ION_MTK=y
-CONFIG_ION_MTK_FB_HEAP_SUPPORT=y
-CONFIG_MMPROFILE=y
-# CONFIG_MTK_STAGING is not set
-# CONFIG_PWR_LOSS_MTK_TEST is not set
-CONFIG_MTK_EMMC_CACHE=y
-CONFIG_MTK_GPU_SUPPORT=y
-# CONFIG_MTK_ICUSB_SUPPORT is not set
-# CONFIG_MTK_DT_USB_SUPPORT is not set
-# CONFIG_MTK_SWCHR_SUPPORT is not set
-# CONFIG_MTK_DISABLE_POWER_ON_OFF_VOLTAGE_LIMITATION is not set
-CONFIG_MTK_KERNEL_POWER_OFF_CHARGING=y
-# CONFIG_MTK_BQ24160_SUPPORT is not set
-# CONFIG_MTK_MT8193_SUPPORT is not set
-# CONFIG_MTK_HDMI_SUPPORT is not set
-# CONFIG_MTK_MT8193_HDCP_SUPPORT is not set
-CONFIG_CUSTOM_KERNEL_HDMI=""
-# CONFIG_SINGLE_PANEL_OUTPUT is not set
-CONFIG_MTK_THERMAL_PA_VIA_ATCMD=y
-CONFIG_MTK_SIM1_SOCKET_TYPE="1"
-CONFIG_MTK_SIM2_SOCKET_TYPE="1"
-CONFIG_MTK_SEC_MODEM_NVRAM_ANTI_CLONE=y
-# CONFIG_MTK_MT6333_SUPPORT is not set
-# CONFIG_MTK_CTP_RESET_CONFIG is not set
-CONFIG_MTK_BICR_SUPPORT=y
-# CONFIG_MTK_VIDEO_HEVC_SUPPORT is not set
-# CONFIG_MTK_AAL_SUPPORT is not set
-# CONFIG_MTK_MULTIBRIDGE_SUPPORT is not set
-# CONFIG_NAND_OTP_SUPPORT is not set
-# CONFIG_MTK_OD_SUPPORT is not set
-# CONFIG_MTK_LENS_DUMMYLENS_SUPPORT is not set
-# CONFIG_MTK_LENS_AD5820AF_SUPPORT is not set
-CONFIG_MTK_LENS_AD5823_SUPPORT=y
-# CONFIG_MTK_LENS_AD5823AF_SUPPORT is not set
-# CONFIG_MTK_LENS_AK7345AF_SUPPORT is not set
-# CONFIG_MTK_LENS_BU6424AF_SUPPORT is not set
-# CONFIG_MTK_LENS_BU6429AF_SUPPORT is not set
-# CONFIG_MTK_LENS_BU64745GWZAF_SUPPORT is not set
-# CONFIG_MTK_LENS_DW9718AF_SUPPORT is not set
-# CONFIG_MTK_LENS_DW9714AF_SUPPORT is not set
-# CONFIG_MTK_LENS_DW9714A_SUPPORT is not set
-# CONFIG_MTK_LENS_DW9814AF_SUPPORT is not set
-# CONFIG_MTK_LENS_LC898122AF_SUPPORT is not set
-# CONFIG_MTK_LENS_LC898212AF_SUPPORT is not set
-CONFIG_MTK_LENS_FM50AF_SUPPORT=y
-# CONFIG_MTK_LENS_MT9P017AF_SUPPORT is not set
-# CONFIG_MTK_LENS_OV8825AF_SUPPORT is not set
-# CONFIG_MTK_LENS_SENSORDRIVE_SUPPORT is not set
-# CONFIG_MTK_LENS_GAF001AF_SUPPORT is not set
-# CONFIG_MTK_LENS_GAF002AF_SUPPORT is not set
-# CONFIG_MTK_LENS_GAF008AF_SUPPORT is not set
-# CONFIG_MTK_EXTMEM is not set
-# CONFIG_MTK_INHOUSE_GPU is not set
-# CONFIG_SW_SYNC64 is not set
-CONFIG_MTK_CPU_STRESS=y
-CONFIG_MTK_LASTPC=y
-CONFIG_MTK_FMRADIO=y
-CONFIG_MTK_HWMON=y
-CONFIG_MTK_CMDQ=y
-CONFIG_MTK_VIDEOX=y
-CONFIG_MTK_MT_LOGGER=y
-CONFIG_MTK_CONN_MD=y
-CONFIG_MTK_LENS=y
-# CONFIG_MTK_IMGSENSOR is not set
-# CONFIG_MTK_CAM_CAL is not set
-# CONFIG_MTK_FLASHLIGHT is not set
-# CONFIG_MTK_DUM_CHAR is not set
-CONFIG_MTK_SYSENV=y
-CONFIG_MTK_SMI=y
-CONFIG_MTK_BTCVSD=y
-# CONFIG_MTK_SOUND_DRV is not set
-CONFIG_MTK_POWER_GS=y
-# CONFIG_MTK_VIDEO is not set
-# CONFIG_MTK_MRDUMP is not set
-# CONFIG_MTK_WMT_CCCI is not set
-CONFIG_MTK_VCOREFS=y
-CONFIG_MTK_EMI_MPU=y
-CONFIG_MTK_EMI_BWL=y
-# CONFIG_MTK_DBG_DUMP is not set
-
-#
-# SCSI device support
-#
-CONFIG_SCSI_MOD=y
-# CONFIG_RAID_ATTRS is not set
-CONFIG_SCSI=y
-CONFIG_SCSI_DMA=y
-CONFIG_SCSI_TGT=y
-# CONFIG_SCSI_NETLINK is not set
-CONFIG_SCSI_PROC_FS=y
-
-#
-# SCSI support type (disk, tape, CD-ROM)
-#
-CONFIG_BLK_DEV_SD=y
-# CONFIG_CHR_DEV_ST is not set
-# CONFIG_CHR_DEV_OSST is not set
-# CONFIG_BLK_DEV_SR is not set
-# CONFIG_CHR_DEV_SG is not set
-# CONFIG_CHR_DEV_SCH is not set
-CONFIG_SCSI_MULTI_LUN=y
-# CONFIG_SCSI_CONSTANTS is not set
-# CONFIG_SCSI_LOGGING is not set
-CONFIG_SCSI_SCAN_ASYNC=y
-
-#
-# SCSI Transports
-#
-# CONFIG_SCSI_SPI_ATTRS is not set
-# CONFIG_SCSI_FC_ATTRS is not set
-# CONFIG_SCSI_ISCSI_ATTRS is not set
-# CONFIG_SCSI_SAS_ATTRS is not set
-# CONFIG_SCSI_SAS_LIBSAS is not set
-# CONFIG_SCSI_SRP_ATTRS is not set
-# CONFIG_SCSI_LOWLEVEL is not set
-# CONFIG_SCSI_LOWLEVEL_PCMCIA is not set
-# CONFIG_SCSI_DH is not set
-# CONFIG_SCSI_OSD_INITIATOR is not set
-# CONFIG_ATA is not set
-CONFIG_MD=y
-# CONFIG_BLK_DEV_MD is not set
-# CONFIG_BCACHE is not set
-CONFIG_BLK_DEV_DM_BUILTIN=y
-CONFIG_BLK_DEV_DM=y
-CONFIG_DM_DEBUG=y
-CONFIG_DM_CRYPT=y
-# CONFIG_DM_SNAPSHOT is not set
-# CONFIG_DM_THIN_PROVISIONING is not set
-# CONFIG_DM_CACHE is not set
-# CONFIG_DM_MIRROR is not set
-# CONFIG_DM_RAID is not set
-# CONFIG_DM_ZERO is not set
-# CONFIG_DM_MULTIPATH is not set
-# CONFIG_DM_DELAY is not set
-CONFIG_DM_UEVENT=y
-# CONFIG_DM_FLAKEY is not set
-# CONFIG_DM_VERITY is not set
-# CONFIG_TARGET_CORE is not set
-CONFIG_NETDEVICES=y
-CONFIG_NET_CORE=y
-# CONFIG_BONDING is not set
-# CONFIG_DUMMY is not set
-# CONFIG_EQUALIZER is not set
-# CONFIG_MII is not set
-CONFIG_IFB=y
-# CONFIG_NET_TEAM is not set
-# CONFIG_MACVLAN is not set
-# CONFIG_VXLAN is not set
-# CONFIG_NETCONSOLE is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-CONFIG_TUN=y
-# CONFIG_VETH is not set
-
-#
-# CAIF transport drivers
-#
-
-#
-# Distributed Switch Architecture drivers
-#
-# CONFIG_NET_DSA_MV88E6XXX is not set
-# CONFIG_NET_DSA_MV88E6060 is not set
-# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
-# CONFIG_NET_DSA_MV88E6131 is not set
-# CONFIG_NET_DSA_MV88E6123_61_65 is not set
-# CONFIG_ETHERNET is not set
-# CONFIG_PHYLIB is not set
-# CONFIG_MICREL_KS8995MA is not set
-CONFIG_PPP=y
-CONFIG_PPP_BSDCOMP=y
-CONFIG_PPP_DEFLATE=y
-CONFIG_PPP_FILTER=y
-CONFIG_PPP_MPPE=y
-CONFIG_PPP_MULTILINK=y
-CONFIG_PPPOE=y
-CONFIG_PPPOLAC=y
-CONFIG_PPPOPNS=y
-CONFIG_PPP_ASYNC=y
-CONFIG_PPP_SYNC_TTY=y
-# CONFIG_SLIP is not set
-CONFIG_SLHC=y
-
-#
-# USB Network Adapters
-#
-# CONFIG_USB_CATC is not set
-# CONFIG_USB_KAWETH is not set
-# CONFIG_USB_PEGASUS is not set
-# CONFIG_USB_RTL8150 is not set
-# CONFIG_USB_RTL8152 is not set
-# CONFIG_USB_USBNET is not set
-# CONFIG_USB_IPHETH is not set
-CONFIG_WLAN=y
-# CONFIG_USB_ZD1201 is not set
-# CONFIG_USB_NET_RNDIS_WLAN is not set
-# CONFIG_WIFI_CONTROL_FUNC is not set
-# CONFIG_ATH_CARDS is not set
-# CONFIG_BRCMFMAC is not set
-# CONFIG_HOSTAP is not set
-# CONFIG_LIBERTAS is not set
-# CONFIG_WL_TI is not set
-# CONFIG_MWIFIEX is not set
-
-#
-# Enable WiMAX (Networking options) to see the WiMAX drivers
-#
-# CONFIG_WAN is not set
-# CONFIG_ISDN is not set
-
-#
-# Input device support
-#
-CONFIG_INPUT=y
-# CONFIG_INPUT_FF_MEMLESS is not set
-# CONFIG_INPUT_POLLDEV is not set
-# CONFIG_INPUT_SPARSEKMAP is not set
-# CONFIG_INPUT_MATRIXKMAP is not set
-
-#
-# Userland interfaces
-#
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_JOYDEV is not set
-CONFIG_INPUT_EVDEV=y
-# CONFIG_INPUT_EVBUG is not set
-# CONFIG_INPUT_KEYRESET is not set
-# CONFIG_INPUT_KEYCOMBO is not set
-
-#
-# Input Device Drivers
-#
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_INPUT_JOYSTICK is not set
-# CONFIG_INPUT_TABLET is not set
-CONFIG_INPUT_TOUCHSCREEN=y
-# CONFIG_TOUCHSCREEN_ADS7846 is not set
-# CONFIG_TOUCHSCREEN_AD7877 is not set
-# CONFIG_TOUCHSCREEN_AD7879 is not set
-# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
-# CONFIG_TOUCHSCREEN_AUO_PIXCIR is not set
-# CONFIG_TOUCHSCREEN_BU21013 is not set
-# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
-# CONFIG_TOUCHSCREEN_CYTTSP_CORE is not set
-# CONFIG_TOUCHSCREEN_DYNAPRO is not set
-# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
-# CONFIG_TOUCHSCREEN_EETI is not set
-# CONFIG_TOUCHSCREEN_EGALAX is not set
-# CONFIG_TOUCHSCREEN_FUJITSU is not set
-# CONFIG_TOUCHSCREEN_ILI210X is not set
-# CONFIG_TOUCHSCREEN_GUNZE is not set
-# CONFIG_TOUCHSCREEN_ELO is not set
-# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
-# CONFIG_TOUCHSCREEN_WACOM_I2C is not set
-# CONFIG_TOUCHSCREEN_MAX11801 is not set
-# CONFIG_TOUCHSCREEN_MCS5000 is not set
-# CONFIG_TOUCHSCREEN_MMS114 is not set
-# CONFIG_TOUCHSCREEN_MTOUCH is not set
-# CONFIG_TOUCHSCREEN_INEXIO is not set
-# CONFIG_TOUCHSCREEN_MK712 is not set
-CONFIG_TOUCHSCREEN_MTK=y
-# CONFIG_TOUCHSCREEN_MTK_GT9XX is not set
-# CONFIG_TOUCHSCREEN_MTK_FHD is not set
-# CONFIG_TOUCHSCREEN_MTK_HD is not set
-# CONFIG_TOUCHSCREEN_MTK_GT9XX_AIO is not set
-# CONFIG_TOUCHSCREEN_MTK_GT9XX_HOTKNOT_SCP is not set
-# CONFIG_TOUCHSCREEN_MTK_GT9XX_HOTKNOT is not set
-# CONFIG_TOUCHSCREEN_MTK_GT1151 is not set
-CONFIG_MTK_GT915_HD=y
-CONFIG_MTK_FOCALTECH_HD=y
-# CONFIG_MTK_GT915_QHD is not set
-# CONFIG_MTK_FOCALTECH_QHD is not set
-# CONFIG_MTK_FT6X06_QHD is not set
-# CONFIG_TOUCHSCREEN_MTK_GT910 is not set
-# CONFIG_TOUCHSCREEN_MTK_MAX1187X is not set
-# CONFIG_TOUCHSCREEN_MTK_GT9XX_HOTKNOT_FPGA is not set
-# CONFIG_TOUCHSCREEN_MTK_GT9XXTB_HOTKNOT is not set
-# CONFIG_TOUCHSCREEN_MTK_GT818B_FPGA is not set
-# CONFIG_TOUCHSCREEN_S7020 is not set
-# CONFIG_TOUCHSCREEN_MTK_GT9XX_2 is not set
-# CONFIG_MTK_GT9XX is not set
-# CONFIG_GT9XX_2 is not set
-# CONFIG_MTK_GT911 is not set
-# CONFIG_MTK_MMS244 is not set
-# CONFIG_GT9XX_HOTKNOT_FLASHLESS is not set
-# CONFIG_MTK_FT5406 is not set
-# CONFIG_MTK_FT5406_82 is not set
-# CONFIG_MTK_FT5206 is not set
-# CONFIG_MTK_FT5X0X is not set
-# CONFIG_MTK_MMS134 is not set
-# CONFIG_MTK_MMS128 is not set
-# CONFIG_MTK_MIT200 is not set
-# CONFIG_TOUCHSCREEN_PENMOUNT is not set
-# CONFIG_TOUCHSCREEN_EDT_FT5X06 is not set
-# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
-# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
-# CONFIG_TOUCHSCREEN_PIXCIR is not set
-# CONFIG_TOUCHSCREEN_MTK_FTS2A052 is not set
-# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
-# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
-# CONFIG_TOUCHSCREEN_TSC_SERIO is not set
-# CONFIG_TOUCHSCREEN_TSC2005 is not set
-# CONFIG_TOUCHSCREEN_TSC2007 is not set
-# CONFIG_TOUCHSCREEN_W90X900 is not set
-# CONFIG_TOUCHSCREEN_ST1232 is not set
-# CONFIG_TOUCHSCREEN_TPS6507X is not set
-# CONFIG_TOUCHSCREEN_SYNAPTICS_S3528 is not set
-# CONFIG_TOUCHSCREEN_SYNAPTICS is not set
-CONFIG_INPUT_MISC=y
-# CONFIG_INPUT_AD714X is not set
-# CONFIG_INPUT_BMA150 is not set
-# CONFIG_INPUT_MMA8450 is not set
-# CONFIG_INPUT_MPU3050 is not set
-# CONFIG_INPUT_GP2A is not set
-# CONFIG_INPUT_GPIO_TILT_POLLED is not set
-# CONFIG_INPUT_ATI_REMOTE2 is not set
-# CONFIG_INPUT_KEYCHORD is not set
-# CONFIG_INPUT_KEYSPAN_REMOTE is not set
-# CONFIG_INPUT_KXTJ9 is not set
-# CONFIG_INPUT_POWERMATE is not set
-# CONFIG_INPUT_YEALINK is not set
-# CONFIG_INPUT_CM109 is not set
-CONFIG_INPUT_UINPUT=y
-# CONFIG_INPUT_GPIO is not set
-# CONFIG_INPUT_PCF8574 is not set
-# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
-# CONFIG_INPUT_ADXL34X is not set
-# CONFIG_INPUT_IMS_PCU is not set
-# CONFIG_INPUT_CMA3000 is not set
-
-#
-# Hardware I/O ports
-#
-# CONFIG_SERIO is not set
-# CONFIG_GAMEPORT is not set
-
-#
-# Character devices
-#
-CONFIG_TTY=y
-# CONFIG_VT is not set
-CONFIG_UNIX98_PTYS=y
-# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
-CONFIG_LEGACY_PTYS=y
-CONFIG_LEGACY_PTY_COUNT=16
-# CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_N_GSM is not set
-# CONFIG_TRACE_SINK is not set
-CONFIG_DEVMEM=y
-CONFIG_DEVKMEM=y
-
-#
-# Serial drivers
-#
-# CONFIG_SERIAL_8250 is not set
-
-#
-# Non-8250 serial port support
-#
-# CONFIG_SERIAL_AMBA_PL010 is not set
-# CONFIG_SERIAL_AMBA_PL011 is not set
-# CONFIG_SERIAL_KGDB_NMI is not set
-# CONFIG_SERIAL_MAX3100 is not set
-# CONFIG_SERIAL_MAX310X is not set
-CONFIG_SERIAL_CORE=y
-CONFIG_SERIAL_CORE_CONSOLE=y
-CONFIG_CONSOLE_POLL=y
-# CONFIG_SERIAL_SCCNXP is not set
-# CONFIG_SERIAL_TIMBERDALE is not set
-# CONFIG_SERIAL_ALTERA_JTAGUART is not set
-# CONFIG_SERIAL_ALTERA_UART is not set
-# CONFIG_SERIAL_IFX6X60 is not set
-# CONFIG_SERIAL_XILINX_PS_UART is not set
-# CONFIG_SERIAL_ARC is not set
-# CONFIG_TTY_PRINTK is not set
-# CONFIG_IPMI_HANDLER is not set
-# CONFIG_HW_RANDOM is not set
-# CONFIG_R3964 is not set
-
-#
-# PCMCIA character devices
-#
-# CONFIG_RAW_DRIVER is not set
-# CONFIG_TCG_TPM is not set
-CONFIG_I2C=y
-CONFIG_I2C_BOARDINFO=y
-CONFIG_I2C_COMPAT=y
-# CONFIG_I2C_CHARDEV is not set
-# CONFIG_I2C_MUX is not set
-CONFIG_I2C_HELPER_AUTO=y
-
-#
-# I2C Hardware Bus support
-#
-
-#
-# I2C system bus drivers (mostly embedded / system-on-chip)
-#
-# CONFIG_I2C_CBUS_GPIO is not set
-# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
-# CONFIG_I2C_GPIO is not set
-# CONFIG_I2C_NOMADIK is not set
-# CONFIG_I2C_OCORES is not set
-# CONFIG_I2C_PCA_PLATFORM is not set
-# CONFIG_I2C_PXA_PCI is not set
-# CONFIG_I2C_SIMTEC is not set
-# CONFIG_I2C_XILINX is not set
-
-#
-# External I2C/SMBus adapter drivers
-#
-# CONFIG_I2C_DIOLAN_U2C is not set
-# CONFIG_I2C_PARPORT_LIGHT is not set
-# CONFIG_I2C_TAOS_EVM is not set
-# CONFIG_I2C_TINY_USB is not set
-
-#
-# Other I2C/SMBus bus drivers
-#
-# CONFIG_I2C_DEBUG_CORE is not set
-# CONFIG_I2C_DEBUG_ALGO is not set
-# CONFIG_I2C_DEBUG_BUS is not set
-CONFIG_SPI=y
-# CONFIG_SPI_DEBUG is not set
-CONFIG_SPI_MASTER=y
-
-#
-# SPI Master Controller Drivers
-#
-# CONFIG_SPI_ALTERA is not set
-# CONFIG_SPI_BITBANG is not set
-# CONFIG_SPI_GPIO is not set
-# CONFIG_SPI_FSL_SPI is not set
-# CONFIG_SPI_OC_TINY is not set
-# CONFIG_SPI_PL022 is not set
-# CONFIG_SPI_PXA2XX_PCI is not set
-# CONFIG_SPI_SC18IS602 is not set
-# CONFIG_SPI_XCOMM is not set
-# CONFIG_SPI_XILINX is not set
-# CONFIG_SPI_DESIGNWARE is not set
-
-#
-# SPI Protocol Masters
-#
-# CONFIG_SPI_SPIDEV is not set
-# CONFIG_SPI_TLE62X0 is not set
-
-#
-# Qualcomm MSM SSBI bus support
-#
-# CONFIG_SSBI is not set
-# CONFIG_HSI is not set
-
-#
-# PPS support
-#
-# CONFIG_PPS is not set
-
-#
-# PPS generators support
-#
-
-#
-# PTP clock support
-#
-# CONFIG_PTP_1588_CLOCK is not set
-
-#
-# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
-#
-# CONFIG_PTP_1588_CLOCK_PCH is not set
-CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
-CONFIG_GPIO_DEVRES=y
-CONFIG_GPIOLIB=y
-CONFIG_OF_GPIO=y
-# CONFIG_DEBUG_GPIO is not set
-# CONFIG_GPIO_SYSFS is not set
-
-#
-# Memory mapped GPIO drivers:
-#
-# CONFIG_GPIO_GENERIC_PLATFORM is not set
-# CONFIG_GPIO_TS5500 is not set
-# CONFIG_GPIO_GRGPIO is not set
-
-#
-# I2C GPIO expanders:
-#
-# CONFIG_GPIO_MAX7300 is not set
-# CONFIG_GPIO_MAX732X is not set
-# CONFIG_GPIO_PCA953X is not set
-# CONFIG_GPIO_PCF857X is not set
-# CONFIG_GPIO_SX150X is not set
-# CONFIG_GPIO_ADP5588 is not set
-# CONFIG_GPIO_ADNP is not set
-
-#
-# PCI GPIO expanders:
-#
-
-#
-# SPI GPIO expanders:
-#
-# CONFIG_GPIO_MAX7301 is not set
-# CONFIG_GPIO_MCP23S08 is not set
-# CONFIG_GPIO_MC33880 is not set
-# CONFIG_GPIO_74X164 is not set
-
-#
-# AC97 GPIO expanders:
-#
-
-#
-# MODULbus GPIO expanders:
-#
-
-#
-# USB GPIO expanders:
-#
-# CONFIG_W1 is not set
-CONFIG_POWER_SUPPLY=y
-# CONFIG_POWER_SUPPLY_DEBUG is not set
-# CONFIG_PDA_POWER is not set
-# CONFIG_TEST_POWER is not set
-# CONFIG_BATTERY_DS2780 is not set
-# CONFIG_BATTERY_DS2781 is not set
-# CONFIG_BATTERY_DS2782 is not set
-# CONFIG_BATTERY_SBS is not set
-# CONFIG_BATTERY_BQ27x00 is not set
-# CONFIG_BATTERY_MAX17040 is not set
-# CONFIG_BATTERY_MAX17042 is not set
-# CONFIG_CHARGER_ISP1704 is not set
-# CONFIG_CHARGER_MAX8903 is not set
-# CONFIG_CHARGER_LP8727 is not set
-# CONFIG_CHARGER_GPIO is not set
-# CONFIG_CHARGER_MANAGER is not set
-# CONFIG_CHARGER_BQ2415X is not set
-# CONFIG_CHARGER_SMB347 is not set
-# CONFIG_BATTERY_GOLDFISH is not set
-CONFIG_POWER_RESET=y
-# CONFIG_POWER_RESET_GPIO is not set
-# CONFIG_POWER_AVS is not set
-# CONFIG_HWMON is not set
-CONFIG_THERMAL=y
-CONFIG_THERMAL_DEFAULT_GOV_BACKWARD_COMPATIBLE=y
-# CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE is not set
-# CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE is not set
-# CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE is not set
-CONFIG_BACKWARD_COMPATIBLE=y
-# CONFIG_THERMAL_GOV_FAIR_SHARE is not set
-# CONFIG_THERMAL_GOV_STEP_WISE is not set
-# CONFIG_THERMAL_GOV_USER_SPACE is not set
-# CONFIG_CPU_THERMAL is not set
-# CONFIG_THERMAL_EMULATION is not set
-# CONFIG_WATCHDOG is not set
-CONFIG_SSB_POSSIBLE=y
-
-#
-# Sonics Silicon Backplane
-#
-# CONFIG_SSB is not set
-CONFIG_BCMA_POSSIBLE=y
-
-#
-# Broadcom specific AMBA
-#
-# CONFIG_BCMA is not set
-
-#
-# Multifunction device drivers
-#
-# CONFIG_MFD_CORE is not set
-# CONFIG_MFD_AS3711 is not set
-# CONFIG_PMIC_ADP5520 is not set
-# CONFIG_MFD_AAT2870_CORE is not set
-# CONFIG_MFD_CROS_EC is not set
-# CONFIG_PMIC_DA903X is not set
-# CONFIG_MFD_DA9052_SPI is not set
-# CONFIG_MFD_DA9052_I2C is not set
-# CONFIG_MFD_DA9055 is not set
-# CONFIG_MFD_MC13XXX_SPI is not set
-# CONFIG_MFD_MC13XXX_I2C is not set
-# CONFIG_HTC_PASIC3 is not set
-# CONFIG_HTC_I2CPLD is not set
-# CONFIG_MFD_88PM800 is not set
-# CONFIG_MFD_88PM805 is not set
-# CONFIG_MFD_88PM860X is not set
-# CONFIG_MFD_MAX77686 is not set
-# CONFIG_MFD_MAX77693 is not set
-# CONFIG_MFD_MAX8907 is not set
-# CONFIG_MFD_MAX8925 is not set
-# CONFIG_MFD_MAX8997 is not set
-# CONFIG_MFD_MAX8998 is not set
-# CONFIG_EZX_PCAP is not set
-# CONFIG_MFD_VIPERBOARD is not set
-# CONFIG_MFD_RETU is not set
-# CONFIG_MFD_PCF50633 is not set
-# CONFIG_MFD_RC5T583 is not set
-# CONFIG_MFD_SEC_CORE is not set
-# CONFIG_MFD_SI476X_CORE is not set
-# CONFIG_MFD_SM501 is not set
-# CONFIG_MFD_SMSC is not set
-# CONFIG_ABX500_CORE is not set
-# CONFIG_MFD_STMPE is not set
-# CONFIG_MFD_SYSCON is not set
-# CONFIG_MFD_TI_AM335X_TSCADC is not set
-# CONFIG_MFD_LP8788 is not set
-# CONFIG_MFD_PALMAS is not set
-# CONFIG_TPS6105X is not set
-# CONFIG_TPS65010 is not set
-# CONFIG_TPS6507X is not set
-# CONFIG_MFD_TPS65090 is not set
-# CONFIG_MFD_TPS65217 is not set
-# CONFIG_MFD_TPS6586X is not set
-# CONFIG_MFD_TPS65910 is not set
-# CONFIG_MFD_TPS65912 is not set
-# CONFIG_MFD_TPS65912_I2C is not set
-# CONFIG_MFD_TPS65912_SPI is not set
-# CONFIG_MFD_TPS80031 is not set
-# CONFIG_TWL4030_CORE is not set
-# CONFIG_TWL6040_CORE is not set
-# CONFIG_MFD_WL1273_CORE is not set
-# CONFIG_MFD_LM3533 is not set
-# CONFIG_MFD_TC3589X is not set
-# CONFIG_MFD_TMIO is not set
-# CONFIG_MFD_ARIZONA_I2C is not set
-# CONFIG_MFD_ARIZONA_SPI is not set
-# CONFIG_MFD_WM8400 is not set
-# CONFIG_MFD_WM831X_I2C is not set
-# CONFIG_MFD_WM831X_SPI is not set
-# CONFIG_MFD_WM8350_I2C is not set
-# CONFIG_MFD_WM8994 is not set
-CONFIG_REGULATOR=y
-# CONFIG_REGULATOR_DEBUG is not set
-# CONFIG_REGULATOR_DUMMY is not set
-# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
-# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
-# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
-# CONFIG_REGULATOR_GPIO is not set
-# CONFIG_REGULATOR_AD5398 is not set
-# CONFIG_REGULATOR_FAN53555 is not set
-# CONFIG_REGULATOR_ISL6271A is not set
-# CONFIG_REGULATOR_MAX1586 is not set
-# CONFIG_REGULATOR_MAX8649 is not set
-# CONFIG_REGULATOR_MAX8660 is not set
-# CONFIG_REGULATOR_MAX8952 is not set
-# CONFIG_REGULATOR_MAX8973 is not set
-# CONFIG_REGULATOR_LP3971 is not set
-# CONFIG_REGULATOR_LP3972 is not set
-# CONFIG_REGULATOR_LP872X is not set
-# CONFIG_REGULATOR_LP8755 is not set
-# CONFIG_REGULATOR_TPS51632 is not set
-# CONFIG_REGULATOR_TPS62360 is not set
-# CONFIG_REGULATOR_TPS65023 is not set
-# CONFIG_REGULATOR_TPS6507X is not set
-# CONFIG_REGULATOR_TPS6524X is not set
-# CONFIG_MEDIA_SUPPORT is not set
-
-#
-# Graphics support
-#
-# CONFIG_DRM is not set
-# CONFIG_VGASTATE is not set
-# CONFIG_VIDEO_OUTPUT_CONTROL is not set
-CONFIG_FB=y
-# CONFIG_FIRMWARE_EDID is not set
-# CONFIG_FB_DDC is not set
-# CONFIG_FB_BOOT_VESA_SUPPORT is not set
-CONFIG_FB_CFB_FILLRECT=y
-CONFIG_FB_CFB_COPYAREA=y
-CONFIG_FB_CFB_IMAGEBLIT=y
-# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
-# CONFIG_FB_SYS_FILLRECT is not set
-# CONFIG_FB_SYS_COPYAREA is not set
-# CONFIG_FB_SYS_IMAGEBLIT is not set
-# CONFIG_FB_FOREIGN_ENDIAN is not set
-# CONFIG_FB_SYS_FOPS is not set
-# CONFIG_FB_SVGALIB is not set
-# CONFIG_FB_MACMODES is not set
-# CONFIG_FB_BACKLIGHT is not set
-CONFIG_FB_MODE_HELPERS=y
-CONFIG_FB_TILEBLITTING=y
-
-#
-# Frame buffer hardware drivers
-#
-# CONFIG_FB_S1D13XXX is not set
-# CONFIG_FB_SMSCUFX is not set
-# CONFIG_FB_UDL is not set
-# CONFIG_FB_GOLDFISH is not set
-# CONFIG_FB_VIRTUAL is not set
-# CONFIG_FB_METRONOME is not set
-# CONFIG_FB_BROADSHEET is not set
-# CONFIG_FB_AUO_K190X is not set
-# CONFIG_FB_SIMPLE is not set
-# CONFIG_EXYNOS_VIDEO is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
-# CONFIG_ADF is not set
-
-#
-# Console display driver support
-#
-CONFIG_FONT_8x16=y
-CONFIG_LOGO=y
-CONFIG_LOGO_LINUX_MONO=y
-CONFIG_LOGO_LINUX_VGA16=y
-CONFIG_LOGO_LINUX_CLUT224=y
-# CONFIG_FB_SSD1307 is not set
-CONFIG_SOUND=y
-CONFIG_SOUND_OSS_CORE=y
-CONFIG_SOUND_OSS_CORE_PRECLAIM=y
-CONFIG_SND=y
-CONFIG_SND_TIMER=y
-CONFIG_SND_PCM=y
-CONFIG_SND_HWDEP=y
-CONFIG_SND_RAWMIDI=y
-CONFIG_SND_COMPRESS_OFFLOAD=y
-CONFIG_SND_JACK=y
-CONFIG_SND_SEQUENCER=y
-CONFIG_SND_SEQ_DUMMY=y
-CONFIG_SND_OSSEMUL=y
-CONFIG_SND_MIXER_OSS=y
-CONFIG_SND_PCM_OSS=y
-CONFIG_SND_PCM_OSS_PLUGINS=y
-CONFIG_SND_SEQUENCER_OSS=y
-CONFIG_SND_HRTIMER=y
-CONFIG_SND_SEQ_HRTIMER_DEFAULT=y
-CONFIG_SND_DYNAMIC_MINORS=y
-CONFIG_SND_SUPPORT_OLD_API=y
-CONFIG_SND_VERBOSE_PROCFS=y
-CONFIG_SND_VERBOSE_PRINTK=y
-CONFIG_SND_DEBUG=y
-CONFIG_SND_DEBUG_VERBOSE=y
-CONFIG_SND_PCM_XRUN_DEBUG=y
-CONFIG_SND_RAWMIDI_SEQ=y
-# CONFIG_SND_OPL3_LIB_SEQ is not set
-# CONFIG_SND_OPL4_LIB_SEQ is not set
-# CONFIG_SND_SBAWE_SEQ is not set
-# CONFIG_SND_EMU10K1_SEQ is not set
-CONFIG_SND_DRIVERS=y
-# CONFIG_SND_DUMMY is not set
-# CONFIG_SND_ALOOP is not set
-# CONFIG_SND_VIRMIDI is not set
-# CONFIG_SND_MTPAV is not set
-# CONFIG_SND_SERIAL_U16550 is not set
-# CONFIG_SND_MPU401 is not set
-# CONFIG_SND_SPI is not set
-CONFIG_SND_USB=y
-CONFIG_SND_USB_AUDIO=y
-# CONFIG_SND_USB_UA101 is not set
-# CONFIG_SND_USB_CAIAQ is not set
-# CONFIG_SND_USB_6FIRE is not set
-CONFIG_SND_SOC=y
-# CONFIG_SND_ATMEL_SOC is not set
-# CONFIG_SND_DESIGNWARE_I2S is not set
-# CONFIG_MT_SND_SOC_V1 is not set
-# CONFIG_MT_SND_SOC_V2 is not set
-CONFIG_MT_SND_SOC_V3=y
-# CONFIG_MT_SND_SOC_6580 is not set
-# CONFIG_MT_SND_SOC_8163 is not set
-# CONFIG_MTK_SPEAKER is not set
-# CONFIG_MTK_NXP_TFA9890 is not set
-CONFIG_SND_SOC_I2C_AND_SPI=y
-# CONFIG_SND_SOC_ALL_CODECS is not set
-CONFIG_SND_SIMPLE_CARD=y
-CONFIG_SOUND_PRIME=y
-
-#
-# HID support
-#
-CONFIG_HID=y
-# CONFIG_HID_BATTERY_STRENGTH is not set
-CONFIG_HIDRAW=y
-CONFIG_UHID=y
-CONFIG_HID_GENERIC=y
-
-#
-# Special HID drivers
-#
-CONFIG_HID_A4TECH=y
-# CONFIG_HID_ACRUX is not set
-CONFIG_HID_APPLE=y
-# CONFIG_HID_APPLEIR is not set
-# CONFIG_HID_AUREAL is not set
-CONFIG_HID_BELKIN=y
-CONFIG_HID_CHERRY=y
-CONFIG_HID_CHICONY=y
-# CONFIG_HID_PRODIKEYS is not set
-CONFIG_HID_CYPRESS=y
-CONFIG_HID_DRAGONRISE=y
-# CONFIG_DRAGONRISE_FF is not set
-# CONFIG_HID_EMS_FF is not set
-# CONFIG_HID_ELECOM is not set
-CONFIG_HID_EZKEY=y
-# CONFIG_HID_HOLTEK is not set
-# CONFIG_HID_KEYTOUCH is not set
-CONFIG_HID_KYE=y
-# CONFIG_HID_UCLOGIC is not set
-# CONFIG_HID_WALTOP is not set
-CONFIG_HID_GYRATION=y
-# CONFIG_HID_ICADE is not set
-CONFIG_HID_TWINHAN=y
-CONFIG_HID_KENSINGTON=y
-# CONFIG_HID_LCPOWER is not set
-# CONFIG_HID_LENOVO_TPKBD is not set
-CONFIG_HID_LOGITECH=y
-# CONFIG_LOGITECH_FF is not set
-# CONFIG_LOGIRUMBLEPAD2_FF is not set
-# CONFIG_LOGIG940_FF is not set
-# CONFIG_LOGIWHEELS_FF is not set
-CONFIG_HID_MAGICMOUSE=y
-CONFIG_HID_MICROSOFT=y
-CONFIG_HID_MONTEREY=y
-# CONFIG_HID_MULTITOUCH is not set
-# CONFIG_HID_NTRIG is not set
-# CONFIG_HID_ORTEK is not set
-CONFIG_HID_PANTHERLORD=y
-# CONFIG_PANTHERLORD_FF is not set
-CONFIG_HID_PETALYNX=y
-# CONFIG_HID_PICOLCD is not set
-# CONFIG_HID_PRIMAX is not set
-# CONFIG_HID_PS3REMOTE is not set
-# CONFIG_HID_ROCCAT is not set
-# CONFIG_HID_SAITEK is not set
-CONFIG_HID_SAMSUNG=y
-# CONFIG_HID_SONY is not set
-# CONFIG_HID_SPEEDLINK is not set
-# CONFIG_HID_STEELSERIES is not set
-CONFIG_HID_SUNPLUS=y
-CONFIG_HID_GREENASIA=y
-# CONFIG_GREENASIA_FF is not set
-CONFIG_HID_SMARTJOYPLUS=y
-# CONFIG_SMARTJOYPLUS_FF is not set
-# CONFIG_HID_TIVO is not set
-CONFIG_HID_TOPSEED=y
-# CONFIG_HID_THINGM is not set
-CONFIG_HID_THRUSTMASTER=y
-# CONFIG_THRUSTMASTER_FF is not set
-# CONFIG_HID_WACOM is not set
-# CONFIG_HID_WIIMOTE is not set
-CONFIG_HID_ZEROPLUS=y
-# CONFIG_ZEROPLUS_FF is not set
-# CONFIG_HID_ZYDACRON is not set
-# CONFIG_HID_SENSOR_HUB is not set
-
-#
-# USB HID support
-#
-CONFIG_USB_HID=y
-# CONFIG_HID_PID is not set
-# CONFIG_USB_HIDDEV is not set
-
-#
-# I2C HID support
-#
-# CONFIG_I2C_HID is not set
-# CONFIG_USB_ARCH_HAS_OHCI is not set
-# CONFIG_USB_ARCH_HAS_EHCI is not set
-# CONFIG_USB_ARCH_HAS_XHCI is not set
-CONFIG_USB_SUPPORT=y
-CONFIG_USB_COMMON=y
-CONFIG_USB_ARCH_HAS_HCD=y
-CONFIG_USB=y
-CONFIG_USB_DEBUG=y
-# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
-
-#
-# Miscellaneous USB options
-#
-CONFIG_USB_DEFAULT_PERSIST=y
-# CONFIG_USB_DYNAMIC_MINORS is not set
-# CONFIG_USB_OTG_WHITELIST is not set
-# CONFIG_USB_OTG_BLACKLIST_HUB is not set
-# CONFIG_USB_MON is not set
-# CONFIG_USB_WUSB_CBAF is not set
-
-#
-# USB Host Controller Drivers
-#
-# CONFIG_USB_C67X00_HCD is not set
-# CONFIG_USB_OXU210HP_HCD is not set
-# CONFIG_USB_ISP116X_HCD is not set
-# CONFIG_USB_ISP1760_HCD is not set
-# CONFIG_USB_ISP1362_HCD is not set
-# CONFIG_USB_SL811_HCD is not set
-# CONFIG_USB_R8A66597_HCD is not set
-# CONFIG_USB_MUSB_HDRC is not set
-# CONFIG_USB_RENESAS_USBHS is not set
-
-#
-# USB Device Class drivers
-#
-# CONFIG_USB_ACM is not set
-# CONFIG_USB_PRINTER is not set
-# CONFIG_USB_WDM is not set
-# CONFIG_USB_TMC is not set
-
-#
-# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
-#
-
-#
-# also be needed; see USB_STORAGE Help for more info
-#
-CONFIG_USB_STORAGE=y
-CONFIG_USB_STORAGE_DEBUG=y
-# CONFIG_USB_STORAGE_REALTEK is not set
-CONFIG_USB_STORAGE_DATAFAB=y
-CONFIG_USB_STORAGE_FREECOM=y
-CONFIG_USB_STORAGE_ISD200=y
-CONFIG_USB_STORAGE_USBAT=y
-CONFIG_USB_STORAGE_SDDR09=y
-CONFIG_USB_STORAGE_SDDR55=y
-CONFIG_USB_STORAGE_JUMPSHOT=y
-CONFIG_USB_STORAGE_ALAUDA=y
-CONFIG_USB_STORAGE_ONETOUCH=y
-CONFIG_USB_STORAGE_KARMA=y
-CONFIG_USB_STORAGE_CYPRESS_ATACB=y
-# CONFIG_USB_STORAGE_ENE_UB6250 is not set
-
-#
-# USB Imaging devices
-#
-# CONFIG_USB_MDC800 is not set
-# CONFIG_USB_MICROTEK is not set
-# CONFIG_USB_DWC3 is not set
-# CONFIG_USB_CHIPIDEA is not set
-
-#
-# USB port drivers
-#
-# CONFIG_USB_SERIAL is not set
-
-#
-# USB Miscellaneous drivers
-#
-# CONFIG_USB_EMI62 is not set
-# CONFIG_USB_EMI26 is not set
-# CONFIG_USB_ADUTUX is not set
-# CONFIG_USB_SEVSEG is not set
-# CONFIG_USB_RIO500 is not set
-# CONFIG_USB_LEGOTOWER is not set
-# CONFIG_USB_LCD is not set
-# CONFIG_USB_LED is not set
-# CONFIG_USB_CYPRESS_CY7C63 is not set
-# CONFIG_USB_CYTHERM is not set
-# CONFIG_USB_IDMOUSE is not set
-# CONFIG_USB_FTDI_ELAN is not set
-# CONFIG_USB_APPLEDISPLAY is not set
-# CONFIG_USB_LD is not set
-CONFIG_USB_TRANCEVIBRATOR=y
-# CONFIG_USB_IOWARRIOR is not set
-# CONFIG_USB_TEST is not set
-# CONFIG_USB_ISIGHTFW is not set
-# CONFIG_USB_YUREX is not set
-# CONFIG_USB_EZUSB_FX2 is not set
-# CONFIG_USB_HSIC_USB3503 is not set
-CONFIG_USB_PHY=y
-# CONFIG_USB_OTG_WAKELOCK is not set
-CONFIG_NOP_USB_XCEIV=y
-# CONFIG_OMAP_CONTROL_USB is not set
-# CONFIG_OMAP_USB3 is not set
-# CONFIG_SAMSUNG_USBPHY is not set
-# CONFIG_SAMSUNG_USB2PHY is not set
-# CONFIG_SAMSUNG_USB3PHY is not set
-# CONFIG_USB_GPIO_VBUS is not set
-# CONFIG_USB_ISP1301 is not set
-# CONFIG_USB_RCAR_PHY is not set
-CONFIG_USB_GADGET=y
-# CONFIG_USB_GADGET_DEBUG is not set
-# CONFIG_USB_GADGET_DEBUG_FILES is not set
-# CONFIG_USB_GADGET_DEBUG_FS is not set
-CONFIG_USB_GADGET_VBUS_DRAW=500
-CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
-
-#
-# USB Peripheral Controller
-#
-# CONFIG_USB_R8A66597 is not set
-# CONFIG_USB_PXA27X is not set
-# CONFIG_USB_MV_UDC is not set
-# CONFIG_USB_MV_U3D is not set
-# CONFIG_USB_M66592 is not set
-# CONFIG_USB_NET2272 is not set
-# CONFIG_USB_DUMMY_HCD is not set
-CONFIG_USB_LIBCOMPOSITE=y
-CONFIG_USB_F_ACM=y
-CONFIG_USB_U_SERIAL=y
-CONFIG_USB_F_SERIAL=y
-# CONFIG_USB_ZERO is not set
-# CONFIG_USB_AUDIO is not set
-# CONFIG_USB_ETH is not set
-# CONFIG_USB_G_NCM is not set
-# CONFIG_USB_GADGETFS is not set
-# CONFIG_USB_FUNCTIONFS is not set
-# CONFIG_USB_MASS_STORAGE is not set
-# CONFIG_USB_G_SERIAL is not set
-# CONFIG_USB_MIDI_GADGET is not set
-# CONFIG_USB_G_PRINTER is not set
-CONFIG_USB_G_ANDROID=y
-# CONFIG_USB_ANDROID_RNDIS_DWORD_ALIGNED is not set
-# CONFIG_USB_CDC_COMPOSITE is not set
-# CONFIG_USB_G_ACM_MS is not set
-# CONFIG_USB_G_MULTI is not set
-# CONFIG_USB_G_HID is not set
-# CONFIG_USB_G_DBGP is not set
-CONFIG_MMC=y
-# CONFIG_MMC_DEBUG is not set
-CONFIG_MMC_UNSAFE_RESUME=y
-# CONFIG_MMC_CLKGATE is not set
-# CONFIG_MMC_EMBEDDED_SDIO is not set
-# CONFIG_MMC_PARANOID_SD_INIT is not set
-
-#
-# MMC/SD/SDIO Card Drivers
-#
-CONFIG_MMC_BLOCK=y
-CONFIG_MMC_BLOCK_MINORS=32
-CONFIG_MMC_BLOCK_BOUNCE=y
-# CONFIG_MMC_BLOCK_DEFERRED_RESUME is not set
-# CONFIG_SDIO_UART is not set
-# CONFIG_MMC_TEST is not set
-# CONFIG_MMC_FFU is not set
-
-#
-# MMC/SD/SDIO Host Controller Drivers
-#
-# CONFIG_MMC_ARMMMCI is not set
-# CONFIG_MMC_SDHCI is not set
-# CONFIG_MMC_SDHCI_PXAV3 is not set
-# CONFIG_MMC_SDHCI_PXAV2 is not set
-# CONFIG_MMC_SPI is not set
-# CONFIG_MMC_VUB300 is not set
-# CONFIG_MMC_USHC is not set
-# CONFIG_MEMSTICK is not set
-CONFIG_NEW_LEDS=y
-CONFIG_LEDS_CLASS=y
-
-#
-# LED drivers
-#
-# CONFIG_LEDS_LM3530 is not set
-# CONFIG_LEDS_LM3642 is not set
-# CONFIG_LEDS_PCA9532 is not set
-# CONFIG_LEDS_GPIO is not set
-# CONFIG_LEDS_LP3944 is not set
-# CONFIG_LEDS_LP5521 is not set
-# CONFIG_LEDS_LP5523 is not set
-# CONFIG_LEDS_LP5562 is not set
-# CONFIG_LEDS_PCA955X is not set
-# CONFIG_LEDS_PCA9633 is not set
-# CONFIG_LEDS_DAC124S085 is not set
-# CONFIG_LEDS_REGULATOR is not set
-# CONFIG_LEDS_BD2802 is not set
-# CONFIG_LEDS_LT3593 is not set
-# CONFIG_LEDS_RENESAS_TPU is not set
-# CONFIG_LEDS_TCA6507 is not set
-# CONFIG_LEDS_LM355x is not set
-# CONFIG_LEDS_OT200 is not set
-# CONFIG_LEDS_BLINKM is not set
-
-#
-# LED Triggers
-#
-CONFIG_LEDS_TRIGGERS=y
-CONFIG_LEDS_TRIGGER_TIMER=y
-# CONFIG_LEDS_TRIGGER_ONESHOT is not set
-# CONFIG_LEDS_TRIGGER_HEARTBEAT is not set
-# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
-# CONFIG_LEDS_TRIGGER_CPU is not set
-# CONFIG_LEDS_TRIGGER_GPIO is not set
-# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
-
-#
-# iptables trigger is under Netfilter config (LED target)
-#
-# CONFIG_LEDS_TRIGGER_TRANSIENT is not set
-# CONFIG_LEDS_TRIGGER_CAMERA is not set
-CONFIG_SWITCH=y
-# CONFIG_SWITCH_GPIO is not set
-# CONFIG_ACCESSIBILITY is not set
-CONFIG_RTC_LIB=y
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_HCTOSYS=y
-# CONFIG_RTC_SYSTOHC is not set
-CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
-# CONFIG_RTC_DEBUG is not set
-
-#
-# RTC interfaces
-#
-CONFIG_RTC_INTF_SYSFS=y
-CONFIG_RTC_INTF_PROC=y
-CONFIG_RTC_INTF_DEV=y
-# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
-# CONFIG_RTC_DRV_TEST is not set
-
-#
-# I2C RTC drivers
-#
-# CONFIG_RTC_DRV_DS1307 is not set
-# CONFIG_RTC_DRV_DS1374 is not set
-# CONFIG_RTC_DRV_DS1672 is not set
-# CONFIG_RTC_DRV_DS3232 is not set
-# CONFIG_RTC_DRV_MAX6900 is not set
-# CONFIG_RTC_DRV_RS5C372 is not set
-# CONFIG_RTC_DRV_ISL1208 is not set
-# CONFIG_RTC_DRV_ISL12022 is not set
-# CONFIG_RTC_DRV_X1205 is not set
-# CONFIG_RTC_DRV_PCF8523 is not set
-# CONFIG_RTC_DRV_PCF8563 is not set
-# CONFIG_RTC_DRV_PCF8583 is not set
-# CONFIG_RTC_DRV_M41T80 is not set
-# CONFIG_RTC_DRV_BQ32K is not set
-# CONFIG_RTC_DRV_S35390A is not set
-# CONFIG_RTC_DRV_FM3130 is not set
-# CONFIG_RTC_DRV_RX8581 is not set
-# CONFIG_RTC_DRV_RX8025 is not set
-# CONFIG_RTC_DRV_EM3027 is not set
-# CONFIG_RTC_DRV_RV3029C2 is not set
-
-#
-# SPI RTC drivers
-#
-# CONFIG_RTC_DRV_M41T93 is not set
-# CONFIG_RTC_DRV_M41T94 is not set
-# CONFIG_RTC_DRV_DS1305 is not set
-# CONFIG_RTC_DRV_DS1390 is not set
-# CONFIG_RTC_DRV_MAX6902 is not set
-# CONFIG_RTC_DRV_R9701 is not set
-# CONFIG_RTC_DRV_RS5C348 is not set
-# CONFIG_RTC_DRV_DS3234 is not set
-# CONFIG_RTC_DRV_PCF2123 is not set
-# CONFIG_RTC_DRV_RX4581 is not set
-
-#
-# Platform RTC drivers
-#
-# CONFIG_RTC_DRV_DS1286 is not set
-# CONFIG_RTC_DRV_DS1511 is not set
-# CONFIG_RTC_DRV_DS1553 is not set
-# CONFIG_RTC_DRV_DS1742 is not set
-# CONFIG_RTC_DRV_STK17TA8 is not set
-# CONFIG_RTC_DRV_M48T86 is not set
-# CONFIG_RTC_DRV_M48T35 is not set
-# CONFIG_RTC_DRV_M48T59 is not set
-# CONFIG_RTC_DRV_MSM6242 is not set
-# CONFIG_RTC_DRV_BQ4802 is not set
-# CONFIG_RTC_DRV_RP5C01 is not set
-# CONFIG_RTC_DRV_V3020 is not set
-# CONFIG_RTC_DRV_DS2404 is not set
-
-#
-# on-CPU RTC drivers
-#
-# CONFIG_RTC_DRV_PL030 is not set
-# CONFIG_RTC_DRV_PL031 is not set
-# CONFIG_RTC_DRV_SNVS is not set
-
-#
-# HID Sensor RTC drivers
-#
-# CONFIG_RTC_DRV_HID_SENSOR_TIME is not set
-# CONFIG_DMADEVICES is not set
-# CONFIG_AUXDISPLAY is not set
-# CONFIG_UIO is not set
-# CONFIG_VIRT_DRIVERS is not set
-
-#
-# Virtio drivers
-#
-# CONFIG_VIRTIO_MMIO is not set
-
-#
-# Microsoft Hyper-V guest support
-#
-CONFIG_STAGING=y
-# CONFIG_USBIP_CORE is not set
-# CONFIG_PRISM2_USB is not set
-# CONFIG_ECHO is not set
-# CONFIG_ASUS_OLED is not set
-# CONFIG_R8712U is not set
-# CONFIG_RTS5139 is not set
-# CONFIG_TRANZPORT is not set
-# CONFIG_LINE6_USB is not set
-CONFIG_ZSMALLOC=y
-CONFIG_ZRAM=y
-CONFIG_ZRAM_DEBUG=y
-# CONFIG_ZSM is not set
-# CONFIG_BCM_WIMAX is not set
-# CONFIG_FT1000 is not set
-
-#
-# Speakup console speech
-#
-# CONFIG_TOUCHSCREEN_CLEARPAD_TM1217 is not set
-# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4 is not set
-# CONFIG_STAGING_MEDIA is not set
-
-#
-# Android
-#
-CONFIG_ANDROID=y
-CONFIG_ASHMEM=y
-CONFIG_ANDROID_LOGGER=y
-CONFIG_ANDROID_TIMED_OUTPUT=y
-# CONFIG_ANDROID_TIMED_GPIO is not set
-CONFIG_ANDROID_LOW_MEMORY_KILLER=y
-CONFIG_ANDROID_LOW_MEMORY_KILLER_AUTODETECT_OOM_ADJ_VALUES=y
-CONFIG_ANDROID_INTF_ALARM_DEV=y
-CONFIG_SYNC=y
-CONFIG_SW_SYNC=y
-CONFIG_SW_SYNC_USER=y
-# CONFIG_MTK_GMO_RAM_OPTIMIZE is not set
-CONFIG_ION=y
-# CONFIG_ION_TEST is not set
-# CONFIG_FIQ_DEBUGGER is not set
-# CONFIG_FIQ_WATCHDOG is not set
-# CONFIG_USB_WPAN_HCD is not set
-# CONFIG_WIMAX_GDM72XX is not set
-# CONFIG_CSR_WIFI is not set
-# CONFIG_CED1401 is not set
-# CONFIG_DGRP is not set
-CONFIG_CLKDEV_LOOKUP=y
-CONFIG_HAVE_CLK_PREPARE=y
-CONFIG_COMMON_CLK=y
-
-#
-# Common Clock Framework
-#
-# CONFIG_COMMON_CLK_DEBUG is not set
-# CONFIG_COMMON_CLK_SI5351 is not set
-
-#
-# Hardware Spinlock drivers
-#
-CONFIG_CLKSRC_OF=y
-CONFIG_ARM_ARCH_TIMER=y
-# CONFIG_MAILBOX is not set
-CONFIG_IOMMU_SUPPORT=y
-CONFIG_OF_IOMMU=y
-
-#
-# Remoteproc drivers
-#
-# CONFIG_STE_MODEM_RPROC is not set
-
-#
-# Rpmsg drivers
-#
-# CONFIG_PM_DEVFREQ is not set
-# CONFIG_EXTCON is not set
-# CONFIG_MEMORY is not set
-# CONFIG_IIO is not set
-# CONFIG_PWM is not set
-CONFIG_IRQCHIP=y
-CONFIG_ARM_GIC=y
-CONFIG_MTK_GIC=y
-CONFIG_MTK_EIC=y
-# CONFIG_IPACK_BUS is not set
-# CONFIG_RESET_CONTROLLER is not set
-
-#
-# Android
-#
-CONFIG_ANDROID_BINDER_IPC=y
-
-#
-# File systems
-#
-# CONFIG_EXT2_FS is not set
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
-CONFIG_EXT3_FS_XATTR=y
-CONFIG_EXT3_FS_POSIX_ACL=y
-# CONFIG_EXT3_FS_SECURITY is not set
-CONFIG_EXT4_FS=y
-CONFIG_EXT4_USE_FOR_EXT23=y
-# CONFIG_EXT4_FS_POSIX_ACL is not set
-CONFIG_EXT4_FS_SECURITY=y
-CONFIG_EXT4_DEBUG=y
-CONFIG_JBD=y
-CONFIG_JBD_DEBUG=y
-CONFIG_JBD2=y
-# CONFIG_JBD2_DEBUG is not set
-CONFIG_FS_MBCACHE=y
-# CONFIG_REISERFS_FS is not set
-# CONFIG_JFS_FS is not set
-# CONFIG_XFS_FS is not set
-# CONFIG_GFS2_FS is not set
-# CONFIG_OCFS2_FS is not set
-# CONFIG_BTRFS_FS is not set
-# CONFIG_NILFS2_FS is not set
-CONFIG_FS_POSIX_ACL=y
-CONFIG_FILE_LOCKING=y
-CONFIG_FSNOTIFY=y
-CONFIG_DNOTIFY=y
-CONFIG_INOTIFY_USER=y
-# CONFIG_FANOTIFY is not set
-CONFIG_QUOTA=y
-# CONFIG_QUOTA_NETLINK_INTERFACE is not set
-CONFIG_PRINT_QUOTA_WARNING=y
-# CONFIG_QUOTA_DEBUG is not set
-CONFIG_QUOTA_TREE=y
-# CONFIG_QFMT_V1 is not set
-CONFIG_QFMT_V2=y
-CONFIG_QUOTACTL=y
-# CONFIG_AUTOFS4_FS is not set
-CONFIG_FUSE_FS=y
-# CONFIG_CUSE is not set
-
-#
-# Caches
-#
-# CONFIG_FSCACHE is not set
-
-#
-# CD-ROM/DVD Filesystems
-#
-CONFIG_ISO9660_FS=y
-CONFIG_JOLIET=y
-CONFIG_ZISOFS=y
-# CONFIG_UDF_FS is not set
-
-#
-# DOS/FAT/NT Filesystems
-#
-CONFIG_FAT_FS=y
-CONFIG_MSDOS_FS=y
-CONFIG_VFAT_FS=y
-CONFIG_FAT_DEFAULT_CODEPAGE=437
-CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
-# CONFIG_NTFS_FS is not set
-
-#
-# Pseudo filesystems
-#
-CONFIG_PROC_FS=y
-# CONFIG_PROC_KCORE is not set
-CONFIG_PROC_SYSCTL=y
-CONFIG_PROC_PAGE_MONITOR=y
-CONFIG_SYSFS=y
-CONFIG_TMPFS=y
-# CONFIG_TMPFS_POSIX_ACL is not set
-# CONFIG_TMPFS_XATTR is not set
-# CONFIG_HUGETLB_PAGE is not set
-CONFIG_CONFIGFS_FS=y
-CONFIG_MISC_FILESYSTEMS=y
-# CONFIG_ADFS_FS is not set
-# CONFIG_AFFS_FS is not set
-# CONFIG_HFS_FS is not set
-# CONFIG_HFSPLUS_FS is not set
-# CONFIG_BEFS_FS is not set
-# CONFIG_BFS_FS is not set
-# CONFIG_EFS_FS is not set
-# CONFIG_JFFS2_FS is not set
-# CONFIG_LOGFS is not set
-# CONFIG_CRAMFS is not set
-# CONFIG_SQUASHFS is not set
-# CONFIG_VXFS_FS is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_OMFS_FS is not set
-# CONFIG_HPFS_FS is not set
-# CONFIG_QNX4FS_FS is not set
-# CONFIG_QNX6FS_FS is not set
-# CONFIG_ROMFS_FS is not set
-# CONFIG_PSTORE is not set
-# CONFIG_SYSV_FS is not set
-# CONFIG_UFS_FS is not set
-# CONFIG_F2FS_FS is not set
-# CONFIG_NETWORK_FILESYSTEMS is not set
-CONFIG_NLS=y
-CONFIG_NLS_DEFAULT="iso8859-1"
-CONFIG_NLS_CODEPAGE_437=y
-# CONFIG_NLS_CODEPAGE_737 is not set
-# CONFIG_NLS_CODEPAGE_775 is not set
-# CONFIG_NLS_CODEPAGE_850 is not set
-# CONFIG_NLS_CODEPAGE_852 is not set
-# CONFIG_NLS_CODEPAGE_855 is not set
-# CONFIG_NLS_CODEPAGE_857 is not set
-# CONFIG_NLS_CODEPAGE_860 is not set
-# CONFIG_NLS_CODEPAGE_861 is not set
-# CONFIG_NLS_CODEPAGE_862 is not set
-# CONFIG_NLS_CODEPAGE_863 is not set
-# CONFIG_NLS_CODEPAGE_864 is not set
-# CONFIG_NLS_CODEPAGE_865 is not set
-# CONFIG_NLS_CODEPAGE_866 is not set
-# CONFIG_NLS_CODEPAGE_869 is not set
-# CONFIG_NLS_CODEPAGE_936 is not set
-CONFIG_NLS_CODEPAGE_950=y
-# CONFIG_NLS_CODEPAGE_932 is not set
-# CONFIG_NLS_CODEPAGE_949 is not set
-# CONFIG_NLS_CODEPAGE_874 is not set
-# CONFIG_NLS_ISO8859_8 is not set
-# CONFIG_NLS_CODEPAGE_1250 is not set
-# CONFIG_NLS_CODEPAGE_1251 is not set
-CONFIG_NLS_ASCII=y
-CONFIG_NLS_ISO8859_1=y
-# CONFIG_NLS_ISO8859_2 is not set
-# CONFIG_NLS_ISO8859_3 is not set
-# CONFIG_NLS_ISO8859_4 is not set
-# CONFIG_NLS_ISO8859_5 is not set
-# CONFIG_NLS_ISO8859_6 is not set
-# CONFIG_NLS_ISO8859_7 is not set
-# CONFIG_NLS_ISO8859_9 is not set
-# CONFIG_NLS_ISO8859_13 is not set
-# CONFIG_NLS_ISO8859_14 is not set
-# CONFIG_NLS_ISO8859_15 is not set
-# CONFIG_NLS_KOI8_R is not set
-# CONFIG_NLS_KOI8_U is not set
-# CONFIG_NLS_MAC_ROMAN is not set
-# CONFIG_NLS_MAC_CELTIC is not set
-# CONFIG_NLS_MAC_CENTEURO is not set
-# CONFIG_NLS_MAC_CROATIAN is not set
-# CONFIG_NLS_MAC_CYRILLIC is not set
-# CONFIG_NLS_MAC_GAELIC is not set
-# CONFIG_NLS_MAC_GREEK is not set
-# CONFIG_NLS_MAC_ICELAND is not set
-# CONFIG_NLS_MAC_INUIT is not set
-# CONFIG_NLS_MAC_ROMANIAN is not set
-# CONFIG_NLS_MAC_TURKISH is not set
-CONFIG_NLS_UTF8=y
-# CONFIG_DLM is not set
-# CONFIG_RAWFS_FS is not set
-
-#
-# Kernel hacking
-#
-CONFIG_PRINTK_TIME=y
-CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
-CONFIG_ENABLE_WARN_DEPRECATED=y
-CONFIG_ENABLE_MUST_CHECK=y
-CONFIG_FRAME_WARN=1400
-CONFIG_MAGIC_SYSRQ=y
-# CONFIG_STRIP_ASM_SYMS is not set
-# CONFIG_READABLE_ASM is not set
-# CONFIG_UNUSED_SYMBOLS is not set
-CONFIG_DEBUG_FS=y
-# CONFIG_HEADERS_CHECK is not set
-# CONFIG_DEBUG_SECTION_MISMATCH is not set
-CONFIG_DEBUG_KERNEL=y
-# CONFIG_DEBUG_SHIRQ is not set
-# CONFIG_LOCKUP_DETECTOR is not set
-CONFIG_PANIC_ON_OOPS=y
-CONFIG_PANIC_ON_OOPS_VALUE=1
-CONFIG_DETECT_HUNG_TASK=y
-CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=120
-# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
-CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
-CONFIG_SCHED_DEBUG=y
-CONFIG_SCHEDSTATS=y
-# CONFIG_TIMER_STATS is not set
-# CONFIG_DEBUG_OBJECTS is not set
-CONFIG_SLUB_DEBUG_ON=y
-# CONFIG_SLUB_STATS is not set
-CONFIG_HAVE_DEBUG_KMEMLEAK=y
-# CONFIG_DEBUG_KMEMLEAK is not set
-CONFIG_DEBUG_PREEMPT=y
-# CONFIG_DEBUG_RT_MUTEXES is not set
-# CONFIG_RT_MUTEX_TESTER is not set
-CONFIG_DEBUG_SPINLOCK=y
-CONFIG_DEBUG_MUTEXES=y
-CONFIG_DEBUG_LOCK_ALLOC=y
-CONFIG_PROVE_LOCKING=y
-CONFIG_LOCKDEP=y
-# CONFIG_LOCK_STAT is not set
-CONFIG_DEBUG_LOCKDEP=y
-CONFIG_TRACE_IRQFLAGS=y
-# CONFIG_DEBUG_ATOMIC_SLEEP is not set
-# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
-CONFIG_STACKTRACE=y
-# CONFIG_DEBUG_STACK_USAGE is not set
-# CONFIG_DEBUG_KOBJECT is not set
-CONFIG_HAVE_DEBUG_BUGVERBOSE=y
-# CONFIG_DEBUG_BUGVERBOSE is not set
-CONFIG_DEBUG_INFO=y
-# CONFIG_DEBUG_INFO_REDUCED is not set
-# CONFIG_DEBUG_VM is not set
-# CONFIG_DEBUG_WRITECOUNT is not set
-# CONFIG_DEBUG_MEMORY_INIT is not set
-CONFIG_DEBUG_LIST=y
-# CONFIG_TEST_LIST_SORT is not set
-# CONFIG_DEBUG_SG is not set
-# CONFIG_DEBUG_NOTIFIERS is not set
-# CONFIG_DEBUG_CREDENTIALS is not set
-CONFIG_ARCH_WANT_FRAME_POINTERS=y
-CONFIG_FRAME_POINTER=y
-# CONFIG_BOOT_PRINTK_DELAY is not set
-
-#
-# RCU Debugging
-#
-# CONFIG_PROVE_RCU is not set
-# CONFIG_PROVE_RCU_DELAY is not set
-# CONFIG_SPARSE_RCU_POINTER is not set
-# CONFIG_RCU_TORTURE_TEST is not set
-CONFIG_RCU_CPU_STALL_TIMEOUT=60
-CONFIG_RCU_CPU_STALL_VERBOSE=y
-# CONFIG_RCU_CPU_STALL_INFO is not set
-# CONFIG_RCU_TRACE is not set
-# CONFIG_BACKTRACE_SELF_TEST is not set
-# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
-# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
-# CONFIG_DEBUG_PER_CPU_MAPS is not set
-# CONFIG_LKDTM is not set
-# CONFIG_NOTIFIER_ERROR_INJECTION is not set
-CONFIG_FAULT_INJECTION=y
-# CONFIG_FAILSLAB is not set
-# CONFIG_FAIL_PAGE_ALLOC is not set
-# CONFIG_FAIL_MAKE_REQUEST is not set
-# CONFIG_FAIL_IO_TIMEOUT is not set
-# CONFIG_FAIL_MMC_REQUEST is not set
-# CONFIG_FAULT_INJECTION_DEBUG_FS is not set
-CONFIG_NOP_TRACER=y
-CONFIG_HAVE_FUNCTION_TRACER=y
-CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
-CONFIG_HAVE_DYNAMIC_FTRACE=y
-CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
-CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
-CONFIG_HAVE_C_RECORDMCOUNT=y
-CONFIG_TRACE_CLOCK=y
-CONFIG_RING_BUFFER=y
-CONFIG_EVENT_TRACING=y
-CONFIG_CONTEXT_SWITCH_TRACER=y
-CONFIG_TRACING=y
-CONFIG_TRACING_SUPPORT=y
-CONFIG_FTRACE=y
-# CONFIG_FUNCTION_TRACER is not set
-# CONFIG_IRQSOFF_TRACER is not set
-# CONFIG_PREEMPT_TRACER is not set
-# CONFIG_SCHED_TRACER is not set
-CONFIG_ENABLE_DEFAULT_TRACERS=y
-# CONFIG_FTRACE_SYSCALLS is not set
-# CONFIG_TRACER_SNAPSHOT is not set
-CONFIG_BRANCH_PROFILE_NONE=y
-# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
-# CONFIG_PROFILE_ALL_BRANCHES is not set
-# CONFIG_STACK_TRACER is not set
-# CONFIG_BLK_DEV_IO_TRACE is not set
-# CONFIG_PROBE_EVENTS is not set
-# CONFIG_RING_BUFFER_BENCHMARK is not set
-# CONFIG_RING_BUFFER_STARTUP_TEST is not set
-CONFIG_DYNAMIC_DEBUG=y
-CONFIG_DMA_API_DEBUG=y
-# CONFIG_ATOMIC64_SELFTEST is not set
-# CONFIG_SAMPLES is not set
-CONFIG_HAVE_ARCH_KGDB=y
-CONFIG_KGDB=y
-CONFIG_KGDB_SERIAL_CONSOLE=y
-# CONFIG_KGDB_TESTS is not set
-CONFIG_KGDB_KDB=y
-CONFIG_KDB_CONTINUE_CATASTROPHIC=0
-# CONFIG_TEST_STRING_HELPERS is not set
-# CONFIG_TEST_KSTRTOX is not set
-CONFIG_EARLY_PRINTK=y
-# CONFIG_PID_IN_CONTEXTIDR is not set
-
-#
-# Security options
-#
-# CONFIG_KEYS is not set
-# CONFIG_SECURITY_DMESG_RESTRICT is not set
-CONFIG_SECURITY=y
-# CONFIG_SECURITYFS is not set
-CONFIG_SECURITY_NETWORK=y
-# CONFIG_SECURITY_NETWORK_XFRM is not set
-# CONFIG_SECURITY_PATH is not set
-CONFIG_LSM_MMAP_MIN_ADDR=32768
-CONFIG_SECURITY_SELINUX=y
-CONFIG_SECURITY_SELINUX_BOOTPARAM=y
-CONFIG_SECURITY_SELINUX_BOOTPARAM_VALUE=1
-# CONFIG_SECURITY_SELINUX_DISABLE is not set
-CONFIG_SECURITY_SELINUX_DEVELOP=y
-CONFIG_SECURITY_SELINUX_AVC_STATS=y
-CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE=1
-# CONFIG_SECURITY_SELINUX_POLICYDB_VERSION_MAX is not set
-# CONFIG_SECURITY_SMACK is not set
-# CONFIG_SECURITY_TOMOYO is not set
-# CONFIG_SECURITY_APPARMOR is not set
-# CONFIG_SECURITY_YAMA is not set
-# CONFIG_IMA is not set
-CONFIG_DEFAULT_SECURITY_SELINUX=y
-# CONFIG_DEFAULT_SECURITY_DAC is not set
-CONFIG_DEFAULT_SECURITY="selinux"
-CONFIG_CRYPTO=y
-
-#
-# Crypto core or helper
-#
-CONFIG_CRYPTO_ALGAPI=y
-CONFIG_CRYPTO_ALGAPI2=y
-CONFIG_CRYPTO_AEAD=y
-CONFIG_CRYPTO_AEAD2=y
-CONFIG_CRYPTO_BLKCIPHER=y
-CONFIG_CRYPTO_BLKCIPHER2=y
-CONFIG_CRYPTO_HASH=y
-CONFIG_CRYPTO_HASH2=y
-CONFIG_CRYPTO_RNG2=y
-CONFIG_CRYPTO_PCOMP2=y
-CONFIG_CRYPTO_MANAGER=y
-CONFIG_CRYPTO_MANAGER2=y
-# CONFIG_CRYPTO_USER is not set
-CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
-# CONFIG_CRYPTO_GF128MUL is not set
-# CONFIG_CRYPTO_NULL is not set
-# CONFIG_CRYPTO_PCRYPT is not set
-CONFIG_CRYPTO_WORKQUEUE=y
-CONFIG_CRYPTO_CRYPTD=y
-CONFIG_CRYPTO_AUTHENC=y
-CONFIG_CRYPTO_ABLK_HELPER=y
-
-#
-# Authenticated Encryption with Associated Data
-#
-# CONFIG_CRYPTO_CCM is not set
-# CONFIG_CRYPTO_GCM is not set
-# CONFIG_CRYPTO_SEQIV is not set
-
-#
-# Block modes
-#
-CONFIG_CRYPTO_CBC=y
-# CONFIG_CRYPTO_CTR is not set
-# CONFIG_CRYPTO_CTS is not set
-CONFIG_CRYPTO_ECB=y
-# CONFIG_CRYPTO_LRW is not set
-# CONFIG_CRYPTO_PCBC is not set
-# CONFIG_CRYPTO_XTS is not set
-
-#
-# Hash modes
-#
-# CONFIG_CRYPTO_CMAC is not set
-CONFIG_CRYPTO_HMAC=y
-# CONFIG_CRYPTO_XCBC is not set
-# CONFIG_CRYPTO_VMAC is not set
-
-#
-# Digest
-#
-CONFIG_CRYPTO_CRC32C=y
-# CONFIG_CRYPTO_CRC32 is not set
-# CONFIG_CRYPTO_GHASH is not set
-# CONFIG_CRYPTO_MD4 is not set
-CONFIG_CRYPTO_MD5=y
-# CONFIG_CRYPTO_MICHAEL_MIC is not set
-# CONFIG_CRYPTO_RMD128 is not set
-# CONFIG_CRYPTO_RMD160 is not set
-# CONFIG_CRYPTO_RMD256 is not set
-# CONFIG_CRYPTO_RMD320 is not set
-CONFIG_CRYPTO_SHA1=y
-CONFIG_CRYPTO_SHA256=y
-# CONFIG_CRYPTO_SHA512 is not set
-# CONFIG_CRYPTO_TGR192 is not set
-# CONFIG_CRYPTO_WP512 is not set
-
-#
-# Ciphers
-#
-CONFIG_CRYPTO_AES=y
-# CONFIG_CRYPTO_AES_ARM32_CE is not set
-# CONFIG_CRYPTO_ANUBIS is not set
-CONFIG_CRYPTO_ARC4=y
-# CONFIG_CRYPTO_BLOWFISH is not set
-# CONFIG_CRYPTO_CAMELLIA is not set
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
-CONFIG_CRYPTO_DES=y
-# CONFIG_CRYPTO_FCRYPT is not set
-# CONFIG_CRYPTO_KHAZAD is not set
-# CONFIG_CRYPTO_SALSA20 is not set
-# CONFIG_CRYPTO_SEED is not set
-# CONFIG_CRYPTO_SERPENT is not set
-# CONFIG_CRYPTO_TEA is not set
-CONFIG_CRYPTO_TWOFISH=y
-CONFIG_CRYPTO_TWOFISH_COMMON=y
-
-#
-# Compression
-#
-CONFIG_CRYPTO_DEFLATE=y
-# CONFIG_CRYPTO_ZLIB is not set
-CONFIG_CRYPTO_LZO=y
-# CONFIG_CRYPTO_LZ4K is not set
-
-#
-# Random Number Generation
-#
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-# CONFIG_CRYPTO_USER_API_HASH is not set
-# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
-# CONFIG_CRYPTO_HW is not set
-CONFIG_ARM64_CRYPTO=y
-# CONFIG_CRYPTO_SHA1_ARM64_CE is not set
-CONFIG_CRYPTO_SHA2_ARM64_CE=y
-# CONFIG_CRYPTO_GHASH_ARM64_CE is not set
-CONFIG_CRYPTO_AES_ARM64_CE=y
-# CONFIG_CRYPTO_AES_ARM64_CE_CCM is not set
-CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
-# CONFIG_CRYPTO_AES_ARM64_NEON_BLK is not set
-CONFIG_BINARY_PRINTF=y
-
-#
-# Library routines
-#
-CONFIG_BITREVERSE=y
-CONFIG_GENERIC_PCI_IOMAP=y
-CONFIG_GENERIC_IOMAP=y
-CONFIG_GENERIC_IO=y
-CONFIG_CRC_CCITT=y
-CONFIG_CRC16=y
-# CONFIG_CRC_T10DIF is not set
-# CONFIG_CRC_ITU_T is not set
-CONFIG_CRC32=y
-# CONFIG_CRC32_SELFTEST is not set
-CONFIG_CRC32_SLICEBY8=y
-# CONFIG_CRC32_SLICEBY4 is not set
-# CONFIG_CRC32_SARWATE is not set
-# CONFIG_CRC32_BIT is not set
-# CONFIG_CRC7 is not set
-CONFIG_LIBCRC32C=y
-# CONFIG_CRC8 is not set
-CONFIG_AUDIT_GENERIC=y
-CONFIG_ZLIB_INFLATE=y
-CONFIG_ZLIB_DEFLATE=y
-CONFIG_LZO_COMPRESS=y
-CONFIG_LZO_DECOMPRESS=y
-# CONFIG_LZ4K is not set
-# CONFIG_XZ_DEC is not set
-# CONFIG_XZ_DEC_BCJ is not set
-CONFIG_DECOMPRESS_GZIP=y
-CONFIG_GENERIC_ALLOCATOR=y
-CONFIG_TEXTSEARCH=y
-CONFIG_TEXTSEARCH_KMP=y
-CONFIG_TEXTSEARCH_BM=y
-CONFIG_TEXTSEARCH_FSM=y
-CONFIG_HAS_IOMEM=y
-CONFIG_HAS_DMA=y
-CONFIG_CPU_RMAP=y
-CONFIG_DQL=y
-CONFIG_NLATTR=y
-CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
-# CONFIG_AVERAGE is not set
-# CONFIG_CORDIC is not set
-# CONFIG_DDR is not set
diff --git a/arch/arm64/configs/lentk6735m_65c_l1_defconfig~ b/arch/arm64/configs/lentk6735m_65c_l1_defconfig~
deleted file mode 100644
index 6c20acf..0000000
--- a/arch/arm64/configs/lentk6735m_65c_l1_defconfig~
+++ /dev/null
@@ -1,3083 +0,0 @@
-#
-# Automatically generated file; DO NOT EDIT.
-# Linux/arm64 3.10.65 Kernel Configuration
-#
-CONFIG_ARM64=y
-CONFIG_ARM_HAS_SG_CHAIN=y
-CONFIG_64BIT=y
-CONFIG_ARCH_PHYS_ADDR_T_64BIT=y
-CONFIG_MMU=y
-CONFIG_NO_IOPORT=y
-CONFIG_STACKTRACE_SUPPORT=y
-CONFIG_LOCKDEP_SUPPORT=y
-CONFIG_TRACE_IRQFLAGS_SUPPORT=y
-CONFIG_GENERIC_LOCKBREAK=y
-CONFIG_RWSEM_GENERIC_SPINLOCK=y
-CONFIG_ARCH_HAS_CPUFREQ=y
-CONFIG_GENERIC_HWEIGHT=y
-CONFIG_GENERIC_CSUM=y
-CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_ZONE_DMA=y
-CONFIG_ARCH_DMA_ADDR_T_64BIT=y
-CONFIG_NEED_DMA_MAP_STATE=y
-CONFIG_NEED_SG_DMA_LENGTH=y
-CONFIG_SWIOTLB=y
-CONFIG_IOMMU_HELPER=y
-# CONFIG_ARM_ERRATA_824069 is not set
-CONFIG_KERNEL_MODE_NEON=y
-CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
-CONFIG_IRQ_WORK=y
-
-#
-# General setup
-#
-CONFIG_INIT_ENV_ARG_LIMIT=32
-CONFIG_CROSS_COMPILE="aarch64-linux-android-"
-CONFIG_LOCALVERSION=""
-# CONFIG_LOCALVERSION_AUTO is not set
-CONFIG_DEFAULT_HOSTNAME="(none)"
-CONFIG_SWAP=y
-# CONFIG_SYSVIPC is not set
-# CONFIG_POSIX_MQUEUE is not set
-# CONFIG_FHANDLE is not set
-CONFIG_AUDIT=y
-# CONFIG_AUDIT_LOGINUID_IMMUTABLE is not set
-CONFIG_HAVE_GENERIC_HARDIRQS=y
-
-#
-# IRQ subsystem
-#
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
-CONFIG_GENERIC_IRQ_SHOW=y
-CONFIG_HARDIRQS_SW_RESEND=y
-CONFIG_IRQ_DOMAIN=y
-CONFIG_IRQ_DOMAIN_DEBUG=y
-CONFIG_SPARSE_IRQ=y
-CONFIG_GENERIC_TIME_VSYSCALL=y
-CONFIG_GENERIC_CLOCKEVENTS=y
-CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
-CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
-
-#
-# Timers subsystem
-#
-CONFIG_TICK_ONESHOT=y
-CONFIG_NO_HZ_COMMON=y
-# CONFIG_HZ_PERIODIC is not set
-CONFIG_NO_HZ_IDLE=y
-CONFIG_NO_HZ=y
-CONFIG_HIGH_RES_TIMERS=y
-
-#
-# CPU/Task time and stats accounting
-#
-CONFIG_TICK_CPU_ACCOUNTING=y
-# CONFIG_BSD_PROCESS_ACCT is not set
-# CONFIG_TASKSTATS is not set
-
-#
-# RCU Subsystem
-#
-CONFIG_TREE_PREEMPT_RCU=y
-CONFIG_PREEMPT_RCU=y
-CONFIG_RCU_STALL_COMMON=y
-CONFIG_RCU_FANOUT=32
-CONFIG_RCU_FANOUT_LEAF=16
-# CONFIG_RCU_FANOUT_EXACT is not set
-# CONFIG_RCU_FAST_NO_HZ is not set
-# CONFIG_TREE_RCU_TRACE is not set
-# CONFIG_RCU_BOOST is not set
-# CONFIG_RCU_NOCB_CPU is not set
-# CONFIG_IKCONFIG is not set
-CONFIG_LOG_BUF_SHIFT=17
-CONFIG_GENERIC_SCHED_CLOCK=y
-CONFIG_CGROUPS=y
-# CONFIG_CGROUP_DEBUG is not set
-# CONFIG_CGROUP_FREEZER is not set
-# CONFIG_CGROUP_DEVICE is not set
-# CONFIG_CPUSETS is not set
-CONFIG_CGROUP_CPUACCT=y
-CONFIG_RESOURCE_COUNTERS=y
-# CONFIG_MEMCG is not set
-# CONFIG_CGROUP_PERF is not set
-CONFIG_CGROUP_SCHED=y
-CONFIG_FAIR_GROUP_SCHED=y
-# CONFIG_CFS_BANDWIDTH is not set
-CONFIG_RT_GROUP_SCHED=y
-# CONFIG_BLK_CGROUP is not set
-# CONFIG_CHECKPOINT_RESTORE is not set
-# CONFIG_NAMESPACES is not set
-CONFIG_UIDGID_CONVERTED=y
-# CONFIG_UIDGID_STRICT_TYPE_CHECKS is not set
-# CONFIG_SCHED_AUTOGROUP is not set
-# CONFIG_SYSFS_DEPRECATED is not set
-# CONFIG_RELAY is not set
-CONFIG_BLK_DEV_INITRD=y
-CONFIG_INITRAMFS_SOURCE=""
-CONFIG_RD_GZIP=y
-# CONFIG_RD_BZIP2 is not set
-# CONFIG_RD_LZMA is not set
-# CONFIG_RD_XZ is not set
-# CONFIG_RD_LZO is not set
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
-CONFIG_SYSCTL=y
-CONFIG_ANON_INODES=y
-CONFIG_HAVE_UID16=y
-CONFIG_SYSCTL_EXCEPTION_TRACE=y
-CONFIG_HOTPLUG=y
-CONFIG_PANIC_TIMEOUT=1
-CONFIG_EXPERT=y
-CONFIG_UID16=y
-CONFIG_SYSCTL_SYSCALL=y
-CONFIG_KALLSYMS=y
-# CONFIG_KALLSYMS_ALL is not set
-CONFIG_PRINTK=y
-CONFIG_BUG=y
-CONFIG_ELF_CORE=y
-CONFIG_BASE_FULL=y
-CONFIG_FUTEX=y
-CONFIG_EPOLL=y
-CONFIG_SIGNALFD=y
-CONFIG_TIMERFD=y
-CONFIG_EVENTFD=y
-CONFIG_SHMEM=y
-CONFIG_AIO=y
-CONFIG_EMBEDDED=y
-CONFIG_HAVE_PERF_EVENTS=y
-CONFIG_PERF_USE_VMALLOC=y
-
-#
-# Kernel Performance Events And Counters
-#
-CONFIG_PERF_EVENTS=y
-# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
-CONFIG_VM_EVENT_COUNTERS=y
-# CONFIG_SLUB_DEBUG is not set
-CONFIG_COMPAT_BRK=y
-# CONFIG_SLAB is not set
-CONFIG_SLUB=y
-# CONFIG_SLOB is not set
-CONFIG_PROFILING=y
-CONFIG_TRACEPOINTS=y
-# CONFIG_JUMP_LABEL is not set
-CONFIG_HAVE_64BIT_ALIGNED_ACCESS=y
-CONFIG_HAVE_ARCH_TRACEHOOK=y
-CONFIG_HAVE_DMA_ATTRS=y
-CONFIG_USE_GENERIC_SMP_HELPERS=y
-CONFIG_GENERIC_SMP_IDLE_THREAD=y
-CONFIG_HAVE_CLK=y
-CONFIG_HAVE_DMA_API_DEBUG=y
-CONFIG_HAVE_HW_BREAKPOINT=y
-CONFIG_HAVE_ARCH_JUMP_LABEL=y
-CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION=y
-CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
-CONFIG_MODULES_USE_ELF_RELA=y
-CONFIG_CLONE_BACKWARDS=y
-CONFIG_OLD_SIGSUSPEND3=y
-CONFIG_COMPAT_OLD_SIGACTION=y
-
-#
-# GCOV-based kernel profiling
-#
-# CONFIG_GCOV_KERNEL is not set
-CONFIG_HAVE_GENERIC_DMA_COHERENT=y
-CONFIG_RT_MUTEXES=y
-CONFIG_BASE_SMALL=0
-# CONFIG_MODULES is not set
-CONFIG_STOP_MACHINE=y
-CONFIG_BLOCK=y
-# CONFIG_BLK_DEV_BSG is not set
-# CONFIG_BLK_DEV_BSGLIB is not set
-# CONFIG_BLK_DEV_INTEGRITY is not set
-
-#
-# Partition Types
-#
-# CONFIG_PARTITION_ADVANCED is not set
-CONFIG_MSDOS_PARTITION=y
-CONFIG_EFI_PARTITION=y
-CONFIG_BLOCK_COMPAT=y
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_DEADLINE=y
-CONFIG_IOSCHED_CFQ=y
-# CONFIG_DEFAULT_DEADLINE is not set
-CONFIG_DEFAULT_CFQ=y
-# CONFIG_DEFAULT_NOOP is not set
-CONFIG_DEFAULT_IOSCHED="cfq"
-CONFIG_UNINLINE_SPIN_UNLOCK=y
-CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
-CONFIG_MUTEX_SPIN_ON_OWNER=y
-CONFIG_FREEZER=y
-
-#
-# Platform selection
-#
-# CONFIG_ARCH_VEXPRESS is not set
-# CONFIG_ARCH_MT6735 is not set
-CONFIG_ARCH_MT6735M=y
-# CONFIG_ARCH_MT6753 is not set
-# CONFIG_ARCH_MT6752 is not set
-# CONFIG_ARCH_MT8163 is not set
-# CONFIG_ARCH_MT6795 is not set
-
-#
-# MTK Board Support Package
-#
-CONFIG_MTK_EVB_BOARD=y
-# CONFIG_MTK_FPGA is not set
-CONFIG_MTK_PSCI=y
-CONFIG_MAX_DRAM_SIZE_SUPPORT=0x10000000
-
-#
-# Bus support
-#
-CONFIG_ARM_AMBA=y
-
-#
-# Kernel Features
-#
-# CONFIG_ARM64_64K_PAGES is not set
-CONFIG_SMP=y
-CONFIG_ARM_CPU_TOPOLOGY=y
-# CONFIG_SCHED_MC is not set
-# CONFIG_SCHED_SMT is not set
-# CONFIG_DISABLE_CPU_SCHED_DOMAIN_BALANCE is not set
-# CONFIG_HEVTASK_INTERFACE is not set
-# CONFIG_ARCH_SCALE_INVARIANT_CPU_CAPACITY is not set
-CONFIG_NR_CPUS=8
-CONFIG_SWP_EMULATE=y
-CONFIG_HOTPLUG_CPU=y
-# CONFIG_PREEMPT_NONE is not set
-# CONFIG_PREEMPT_VOLUNTARY is not set
-CONFIG_PREEMPT=y
-CONFIG_PREEMPT_COUNT=y
-CONFIG_HZ=100
-CONFIG_ARCH_HAS_HOLES_MEMORYMODEL=y
-CONFIG_ARCH_SPARSEMEM_ENABLE=y
-CONFIG_ARCH_SPARSEMEM_DEFAULT=y
-CONFIG_ARCH_SELECT_MEMORY_MODEL=y
-CONFIG_HAVE_ARCH_PFN_VALID=y
-CONFIG_HW_PERF_EVENTS=y
-CONFIG_ARMV7_COMPAT=y
-CONFIG_ARMV7_COMPAT_CPUINFO=y
-CONFIG_SELECT_MEMORY_MODEL=y
-CONFIG_SPARSEMEM_MANUAL=y
-CONFIG_SPARSEMEM=y
-CONFIG_HAVE_MEMORY_PRESENT=y
-CONFIG_SPARSEMEM_EXTREME=y
-CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
-CONFIG_SPARSEMEM_VMEMMAP=y
-CONFIG_HAVE_MEMBLOCK=y
-CONFIG_NO_BOOTMEM=y
-# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
-CONFIG_PAGEFLAGS_EXTENDED=y
-CONFIG_SPLIT_PTLOCK_CPUS=4
-CONFIG_COMPACTION=y
-CONFIG_MIGRATION=y
-CONFIG_PHYS_ADDR_T_64BIT=y
-CONFIG_ZONE_DMA_FLAG=1
-CONFIG_BOUNCE=y
-# CONFIG_KSM is not set
-CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
-CONFIG_CROSS_MEMORY_ATTACH=y
-# CONFIG_CLEANCACHE is not set
-# CONFIG_FRONTSWAP is not set
-CONFIG_SECCOMP=y
-CONFIG_SECCOMP_FILTER=y
-
-#
-# Boot options
-#
-CONFIG_CMDLINE="console=tty0 console=ttyMT3,921600n1 root=/dev/ram vmalloc=496M slub_max_order=0 slub_debug=O "
-CONFIG_CMDLINE_FROM_BOOTLOADER=y
-# CONFIG_CMDLINE_EXTEND is not set
-# CONFIG_CMDLINE_FORCE is not set
-CONFIG_BUILD_ARM64_APPENDED_DTB_IMAGE=y
-CONFIG_BUILD_ARM64_APPENDED_DTB_IMAGE_NAMES="lentk6735m_65c_l1"
-
-#
-# CPU Power Management
-#
-
-#
-# CPU Frequency scaling
-#
-CONFIG_CPU_FREQ=y
-CONFIG_CPU_FREQ_TABLE=y
-CONFIG_CPU_FREQ_GOV_COMMON=y
-CONFIG_CPU_FREQ_STAT=y
-CONFIG_CPU_FREQ_STAT_DETAILS=y
-# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVEPLUS is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
-CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE=y
-# CONFIG_CPU_FREQ_DEFAULT_GOV_BALANCE is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_HOTPLUG is not set
-# CONFIG_CPU_FREQ_GOV_BALANCE is not set
-CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
-CONFIG_CPU_FREQ_GOV_POWERSAVE=y
-CONFIG_CPU_FREQ_GOV_USERSPACE=y
-CONFIG_CPU_FREQ_GOV_ONDEMAND=y
-# CONFIG_CPU_FREQ_GOV_INTERACTIVEPLUS is not set
-CONFIG_CPU_FREQ_GOV_INTERACTIVE=y
-# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
-# CONFIG_CPU_FREQ_GOV_HOTPLUG is not set
-
-#
-# ARM CPU frequency scaling drivers
-#
-# CONFIG_ARM_EXYNOS4210_CPUFREQ is not set
-# CONFIG_ARM_EXYNOS4X12_CPUFREQ is not set
-# CONFIG_ARM_EXYNOS5250_CPUFREQ is not set
-# CONFIG_ARM_KIRKWOOD_CPUFREQ is not set
-
-#
-# Userspace binary formats
-#
-CONFIG_BINFMT_ELF=y
-CONFIG_COMPAT_BINFMT_ELF=y
-# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
-CONFIG_BINFMT_SCRIPT=y
-# CONFIG_HAVE_AOUT is not set
-# CONFIG_BINFMT_MISC is not set
-CONFIG_COREDUMP=y
-CONFIG_COMPAT=y
-
-#
-# Power management options
-#
-CONFIG_SUSPEND=y
-CONFIG_SUSPEND_FREEZER=y
-CONFIG_HAS_WAKELOCK=y
-CONFIG_HAS_EARLYSUSPEND=y
-CONFIG_HAS_SBSUSPEND=y
-CONFIG_WAKELOCK=y
-CONFIG_EARLYSUSPEND=y
-CONFIG_FB_EARLYSUSPEND=y
-CONFIG_HIBERNATE_CALLBACKS=y
-CONFIG_HIBERNATION=y
-CONFIG_PM_STD_PARTITION=""
-CONFIG_TOI_CORE=y
-
-#
-# Image Storage (you need at least one allocator)
-#
-# CONFIG_TOI_FILE is not set
-CONFIG_TOI_SWAP=y
-
-#
-# General Options
-#
-CONFIG_TOI_CRYPTO=y
-CONFIG_TOI_DEFAULT_IMAGE_SIZE_LIMIT=-2
-# CONFIG_TOI_KEEP_IMAGE is not set
-CONFIG_TOI_REPLACE_SWSUSP=y
-# CONFIG_TOI_IGNORE_LATE_INITCALL is not set
-CONFIG_TOI_DEFAULT_WAIT=2
-CONFIG_TOI_DEFAULT_EXTRA_PAGES_ALLOWANCE=2000
-# CONFIG_TOI_CHECKSUM is not set
-CONFIG_TOI=y
-CONFIG_TOI_ZRAM_SUPPORT=y
-CONFIG_TOI_FIXUP=y
-CONFIG_TOI_ENHANCE=y
-CONFIG_PM_SLEEP=y
-CONFIG_PM_SLEEP_SMP=y
-CONFIG_PM_AUTOSLEEP=y
-CONFIG_PM_WAKELOCKS=y
-CONFIG_PM_WAKELOCKS_LIMIT=100
-CONFIG_PM_WAKELOCKS_GC=y
-# CONFIG_PM_RUNTIME is not set
-CONFIG_PM=y
-# CONFIG_PM_DEBUG is not set
-CONFIG_PM_CLK=y
-# CONFIG_SUSPEND_TIME is not set
-CONFIG_ARCH_SUSPEND_POSSIBLE=y
-CONFIG_ARM64_CPU_SUSPEND=y
-CONFIG_ARCH_HIBERNATION_POSSIBLE=y
-CONFIG_NET=y
-CONFIG_COMPAT_NETLINK_MESSAGES=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-# CONFIG_PACKET_DIAG is not set
-CONFIG_UNIX=y
-# CONFIG_UNIX_DIAG is not set
-CONFIG_XFRM=y
-CONFIG_XFRM_ALGO=y
-# CONFIG_XFRM_USER is not set
-# CONFIG_XFRM_SUB_POLICY is not set
-CONFIG_XFRM_MIGRATE=y
-# CONFIG_XFRM_STATISTICS is not set
-CONFIG_XFRM_IPCOMP=y
-CONFIG_NET_KEY=y
-# CONFIG_NET_KEY_MIGRATE is not set
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-CONFIG_IP_ADVANCED_ROUTER=y
-# CONFIG_IP_FIB_TRIE_STATS is not set
-CONFIG_IP_MULTIPLE_TABLES=y
-# CONFIG_IP_ROUTE_MULTIPATH is not set
-# CONFIG_IP_ROUTE_VERBOSE is not set
-CONFIG_IP_ROUTE_CLASSID=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_IP_PNP_RARP is not set
-CONFIG_NET_IPIP=y
-# CONFIG_NET_IPGRE_DEMUX is not set
-CONFIG_NET_IP_TUNNEL=y
-CONFIG_IP_MROUTE=y
-CONFIG_IP_MROUTE_MULTIPLE_TABLES=y
-CONFIG_IP_PIMSM_V1=y
-CONFIG_IP_PIMSM_V2=y
-CONFIG_ARPD=y
-CONFIG_SYN_COOKIES=y
-# CONFIG_NET_IPVTI is not set
-CONFIG_INET_AH=y
-CONFIG_INET_ESP=y
-CONFIG_INET_IPCOMP=y
-CONFIG_INET_XFRM_TUNNEL=y
-CONFIG_INET_TUNNEL=y
-CONFIG_INET_XFRM_MODE_TRANSPORT=y
-CONFIG_INET_XFRM_MODE_TUNNEL=y
-CONFIG_INET_XFRM_MODE_BEET=y
-# CONFIG_INET_LRO is not set
-CONFIG_INET_DIAG=y
-CONFIG_INET_TCP_DIAG=y
-# CONFIG_INET_UDP_DIAG is not set
-# CONFIG_TCP_CONG_ADVANCED is not set
-CONFIG_TCP_CONG_CUBIC=y
-CONFIG_DEFAULT_TCP_CONG="cubic"
-# CONFIG_TCP_MD5SIG is not set
-CONFIG_IPV6=y
-CONFIG_IPV6_PRIVACY=y
-CONFIG_IPV6_ROUTER_PREF=y
-CONFIG_IPV6_ROUTE_INFO=y
-CONFIG_IPV6_OPTIMISTIC_DAD=y
-CONFIG_INET6_AH=y
-CONFIG_INET6_ESP=y
-CONFIG_INET6_IPCOMP=y
-CONFIG_IPV6_MIP6=y
-CONFIG_INET6_XFRM_TUNNEL=y
-CONFIG_INET6_TUNNEL=y
-CONFIG_INET6_XFRM_MODE_TRANSPORT=y
-CONFIG_INET6_XFRM_MODE_TUNNEL=y
-CONFIG_INET6_XFRM_MODE_BEET=y
-CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION=y
-CONFIG_IPV6_SIT=y
-CONFIG_IPV6_SIT_6RD=y
-CONFIG_IPV6_NDISC_NODETYPE=y
-CONFIG_IPV6_TUNNEL=y
-# CONFIG_IPV6_GRE is not set
-CONFIG_IPV6_MULTIPLE_TABLES=y
-CONFIG_IPV6_SUBTREES=y
-CONFIG_IPV6_MROUTE=y
-# CONFIG_IPV6_MROUTE_MULTIPLE_TABLES is not set
-CONFIG_IPV6_PIMSM_V2=y
-CONFIG_MTK_DHCPV6C_WIFI=y
-# CONFIG_NETLABEL is not set
-CONFIG_ANDROID_PARANOID_NETWORK=y
-CONFIG_NET_ACTIVITY_STATS=y
-CONFIG_NETWORK_SECMARK=y
-# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
-CONFIG_NETFILTER=y
-# CONFIG_NETFILTER_DEBUG is not set
-CONFIG_NETFILTER_ADVANCED=y
-CONFIG_BRIDGE_NETFILTER=y
-
-#
-# Core Netfilter Configuration
-#
-CONFIG_NETFILTER_NETLINK=y
-# CONFIG_NETFILTER_NETLINK_ACCT is not set
-CONFIG_NETFILTER_NETLINK_QUEUE=y
-CONFIG_NETFILTER_NETLINK_LOG=y
-CONFIG_NF_CONNTRACK=y
-CONFIG_NF_CONNTRACK_MARK=y
-# CONFIG_NF_CONNTRACK_SECMARK is not set
-CONFIG_NF_CONNTRACK_PROCFS=y
-CONFIG_NF_CONNTRACK_EVENTS=y
-# CONFIG_NF_CONNTRACK_TIMEOUT is not set
-# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
-# CONFIG_NF_CT_PROTO_DCCP is not set
-CONFIG_NF_CT_PROTO_GRE=y
-# CONFIG_NF_CT_PROTO_SCTP is not set
-CONFIG_NF_CT_PROTO_UDPLITE=y
-# CONFIG_NF_CONNTRACK_AMANDA is not set
-CONFIG_NF_CONNTRACK_FTP=y
-# CONFIG_NF_CONNTRACK_H323 is not set
-# CONFIG_NF_CONNTRACK_IRC is not set
-# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
-# CONFIG_NF_CONNTRACK_SNMP is not set
-CONFIG_NF_CONNTRACK_PPTP=y
-# CONFIG_NF_CONNTRACK_SANE is not set
-CONFIG_NF_CONNTRACK_SIP=y
-CONFIG_NF_CONNTRACK_TFTP=y
-CONFIG_NF_CT_NETLINK=y
-# CONFIG_NF_CT_NETLINK_TIMEOUT is not set
-# CONFIG_NETFILTER_NETLINK_QUEUE_CT is not set
-CONFIG_NF_NAT=y
-CONFIG_NF_NAT_NEEDED=y
-CONFIG_NF_NAT_PROTO_UDPLITE=y
-# CONFIG_NF_NAT_AMANDA is not set
-CONFIG_NF_NAT_FTP=y
-# CONFIG_NF_NAT_IRC is not set
-CONFIG_NF_NAT_SIP=y
-CONFIG_NF_NAT_TFTP=y
-CONFIG_NETFILTER_TPROXY=y
-CONFIG_NETFILTER_XTABLES=y
-
-#
-# Xtables combined modules
-#
-CONFIG_NETFILTER_XT_MARK=y
-CONFIG_NETFILTER_XT_CONNMARK=y
-
-#
-# Xtables targets
-#
-# CONFIG_NETFILTER_XT_TARGET_AUDIT is not set
-# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
-CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
-# CONFIG_NETFILTER_XT_TARGET_CONNMARK is not set
-# CONFIG_NETFILTER_XT_TARGET_CT is not set
-# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
-CONFIG_NETFILTER_XT_TARGET_HL=y
-# CONFIG_NETFILTER_XT_TARGET_HMARK is not set
-CONFIG_NETFILTER_XT_TARGET_IDLETIMER=y
-# CONFIG_NETFILTER_XT_TARGET_LED is not set
-# CONFIG_NETFILTER_XT_TARGET_LOG is not set
-CONFIG_NETFILTER_XT_TARGET_MARK=y
-CONFIG_NETFILTER_XT_TARGET_NETMAP=y
-CONFIG_NETFILTER_XT_TARGET_NFLOG=y
-CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
-# CONFIG_NETFILTER_XT_TARGET_NOTRACK is not set
-# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
-CONFIG_NETFILTER_XT_TARGET_REDIRECT=y
-# CONFIG_NETFILTER_XT_TARGET_TEE is not set
-# CONFIG_NETFILTER_XT_TARGET_TPROXY is not set
-# CONFIG_NETFILTER_XT_TARGET_TRACE is not set
-# CONFIG_NETFILTER_XT_TARGET_SECMARK is not set
-CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
-# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
-
-#
-# Xtables matches
-#
-# CONFIG_NETFILTER_XT_MATCH_ADDRTYPE is not set
-# CONFIG_NETFILTER_XT_MATCH_BPF is not set
-# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
-# CONFIG_NETFILTER_XT_MATCH_COMMENT is not set
-CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
-# CONFIG_NETFILTER_XT_MATCH_CONNLABEL is not set
-# CONFIG_NETFILTER_XT_MATCH_CONNLIMIT is not set
-# CONFIG_NETFILTER_XT_MATCH_CONNMARK is not set
-# CONFIG_NETFILTER_XT_MATCH_CONNTRACK is not set
-# CONFIG_NETFILTER_XT_MATCH_CPU is not set
-# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
-# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
-# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
-# CONFIG_NETFILTER_XT_MATCH_ECN is not set
-# CONFIG_NETFILTER_XT_MATCH_ESP is not set
-# CONFIG_NETFILTER_XT_MATCH_HASHLIMIT is not set
-# CONFIG_NETFILTER_XT_MATCH_HELPER is not set
-# CONFIG_NETFILTER_XT_MATCH_HL is not set
-CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
-CONFIG_NETFILTER_XT_MATCH_LENGTH=y
-CONFIG_NETFILTER_XT_MATCH_LIMIT=y
-CONFIG_NETFILTER_XT_MATCH_MAC=y
-CONFIG_NETFILTER_XT_MATCH_MARK=y
-CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
-# CONFIG_NETFILTER_XT_MATCH_NFACCT is not set
-# CONFIG_NETFILTER_XT_MATCH_OSF is not set
-# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
-CONFIG_NETFILTER_XT_MATCH_POLICY=y
-CONFIG_NETFILTER_XT_MATCH_PHYSDEV=y
-# CONFIG_NETFILTER_XT_MATCH_PKTTYPE is not set
-CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
-CONFIG_NETFILTER_XT_MATCH_QUOTA=y
-CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
-CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
-# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
-CONFIG_NETFILTER_XT_MATCH_REALM=y
-CONFIG_NETFILTER_XT_MATCH_RECENT=y
-# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
-CONFIG_NETFILTER_XT_MATCH_SOCKET=y
-CONFIG_NETFILTER_XT_MATCH_STATE=y
-CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
-CONFIG_NETFILTER_XT_MATCH_STRING=y
-CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
-CONFIG_NETFILTER_XT_MATCH_TIME=y
-CONFIG_NETFILTER_XT_MATCH_U32=y
-# CONFIG_IP_SET is not set
-# CONFIG_IP_VS is not set
-
-#
-# IP: Netfilter Configuration
-#
-CONFIG_NF_DEFRAG_IPV4=y
-CONFIG_NF_CONNTRACK_IPV4=y
-CONFIG_NF_CONNTRACK_PROC_COMPAT=y
-CONFIG_IP_NF_IPTABLES=y
-# CONFIG_IP_NF_MATCH_AH is not set
-# CONFIG_IP_NF_MATCH_ECN is not set
-# CONFIG_IP_NF_MATCH_RPFILTER is not set
-# CONFIG_IP_NF_MATCH_TTL is not set
-CONFIG_IP_NF_FILTER=y
-CONFIG_IP_NF_TARGET_REJECT=y
-# CONFIG_IP_NF_TARGET_REJECT_SKERR is not set
-# CONFIG_IP_NF_TARGET_ULOG is not set
-CONFIG_NF_NAT_IPV4=y
-CONFIG_IP_NF_TARGET_MASQUERADE=y
-CONFIG_IP_NF_TARGET_NETMAP=y
-CONFIG_IP_NF_TARGET_REDIRECT=y
-CONFIG_NF_NAT_PROTO_GRE=y
-CONFIG_NF_NAT_PPTP=y
-# CONFIG_NF_NAT_H323 is not set
-CONFIG_IP_NF_MANGLE=y
-# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
-# CONFIG_IP_NF_TARGET_ECN is not set
-# CONFIG_IP_NF_TARGET_TTL is not set
-CONFIG_IP_NF_RAW=y
-# CONFIG_IP_NF_SECURITY is not set
-CONFIG_IP_NF_ARPTABLES=y
-# CONFIG_IP_NF_ARPFILTER is not set
-# CONFIG_IP_NF_ARP_MANGLE is not set
-
-#
-# IPv6: Netfilter Configuration
-#
-CONFIG_NF_DEFRAG_IPV6=y
-CONFIG_NF_CONNTRACK_IPV6=y
-CONFIG_IP6_NF_IPTABLES=y
-# CONFIG_IP6_NF_MATCH_AH is not set
-# CONFIG_IP6_NF_MATCH_EUI64 is not set
-CONFIG_IP6_NF_MATCH_FRAG=y
-# CONFIG_IP6_NF_MATCH_OPTS is not set
-# CONFIG_IP6_NF_MATCH_HL is not set
-CONFIG_IP6_NF_MATCH_IPV6HEADER=y
-# CONFIG_IP6_NF_MATCH_MH is not set
-# CONFIG_IP6_NF_MATCH_RPFILTER is not set
-# CONFIG_IP6_NF_MATCH_RT is not set
-CONFIG_IP6_NF_TARGET_HL=y
-CONFIG_IP6_NF_FILTER=y
-CONFIG_IP6_NF_TARGET_REJECT=y
-CONFIG_IP6_NF_TARGET_REJECT_SKERR=y
-CONFIG_IP6_NF_MANGLE=y
-CONFIG_IP6_NF_RAW=y
-# CONFIG_IP6_NF_SECURITY is not set
-# CONFIG_NF_NAT_IPV6 is not set
-# CONFIG_BRIDGE_NF_EBTABLES is not set
-# CONFIG_IP_DCCP is not set
-# CONFIG_IP_SCTP is not set
-# CONFIG_RDS is not set
-# CONFIG_TIPC is not set
-# CONFIG_ATM is not set
-# CONFIG_L2TP is not set
-CONFIG_STP=y
-CONFIG_BRIDGE=y
-CONFIG_BRIDGE_IGMP_SNOOPING=y
-# CONFIG_BRIDGE_VLAN_FILTERING is not set
-CONFIG_HAVE_NET_DSA=y
-CONFIG_VLAN_8021Q=y
-# CONFIG_VLAN_8021Q_GVRP is not set
-# CONFIG_VLAN_8021Q_MVRP is not set
-# CONFIG_DECNET is not set
-CONFIG_LLC=y
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_PHONET is not set
-# CONFIG_IEEE802154 is not set
-CONFIG_NET_SCHED=y
-
-#
-# Queueing/Scheduling
-#
-# CONFIG_NET_SCH_CBQ is not set
-CONFIG_NET_SCH_HTB=y
-# CONFIG_NET_SCH_HFSC is not set
-# CONFIG_NET_SCH_PRIO is not set
-# CONFIG_NET_SCH_MULTIQ is not set
-# CONFIG_NET_SCH_RED is not set
-# CONFIG_NET_SCH_SFB is not set
-# CONFIG_NET_SCH_SFQ is not set
-# CONFIG_NET_SCH_TEQL is not set
-# CONFIG_NET_SCH_TBF is not set
-# CONFIG_NET_SCH_GRED is not set
-# CONFIG_NET_SCH_DSMARK is not set
-# CONFIG_NET_SCH_NETEM is not set
-# CONFIG_NET_SCH_DRR is not set
-# CONFIG_NET_SCH_MQPRIO is not set
-# CONFIG_NET_SCH_CHOKE is not set
-# CONFIG_NET_SCH_QFQ is not set
-# CONFIG_NET_SCH_CODEL is not set
-# CONFIG_NET_SCH_FQ_CODEL is not set
-CONFIG_NET_SCH_INGRESS=y
-# CONFIG_NET_SCH_PLUG is not set
-
-#
-# Classification
-#
-CONFIG_NET_CLS=y
-# CONFIG_NET_CLS_BASIC is not set
-# CONFIG_NET_CLS_TCINDEX is not set
-# CONFIG_NET_CLS_ROUTE4 is not set
-CONFIG_NET_CLS_FW=y
-CONFIG_NET_CLS_U32=y
-CONFIG_CLS_U32_PERF=y
-CONFIG_CLS_U32_MARK=y
-# CONFIG_NET_CLS_RSVP is not set
-# CONFIG_NET_CLS_RSVP6 is not set
-CONFIG_NET_CLS_FLOW=y
-# CONFIG_NET_CLS_CGROUP is not set
-# CONFIG_NET_EMATCH is not set
-CONFIG_NET_CLS_ACT=y
-CONFIG_NET_ACT_POLICE=y
-# CONFIG_NET_ACT_GACT is not set
-CONFIG_NET_ACT_MIRRED=y
-CONFIG_NET_ACT_IPT=y
-# CONFIG_NET_ACT_NAT is not set
-# CONFIG_NET_ACT_PEDIT is not set
-# CONFIG_NET_ACT_SIMP is not set
-# CONFIG_NET_ACT_SKBEDIT is not set
-# CONFIG_NET_ACT_CSUM is not set
-CONFIG_NET_CLS_IND=y
-CONFIG_NET_SCH_FIFO=y
-# CONFIG_DCB is not set
-# CONFIG_BATMAN_ADV is not set
-# CONFIG_OPENVSWITCH is not set
-# CONFIG_VSOCKETS is not set
-# CONFIG_NETLINK_MMAP is not set
-# CONFIG_NETLINK_DIAG is not set
-CONFIG_RPS=y
-CONFIG_RFS_ACCEL=y
-CONFIG_XPS=y
-# CONFIG_NETPRIO_CGROUP is not set
-CONFIG_BQL=y
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-CONFIG_NET_DROP_MONITOR=y
-# CONFIG_HAMRADIO is not set
-# CONFIG_CAN is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
-# CONFIG_AF_RXRPC is not set
-CONFIG_FIB_RULES=y
-CONFIG_WIRELESS=y
-CONFIG_WIRELESS_EXT=y
-CONFIG_WEXT_CORE=y
-CONFIG_WEXT_PROC=y
-CONFIG_WEXT_PRIV=y
-CONFIG_CFG80211=y
-CONFIG_NL80211_TESTMODE=y
-CONFIG_CFG80211_DEVELOPER_WARNINGS=y
-# CONFIG_CFG80211_REG_DEBUG is not set
-# CONFIG_CFG80211_CERTIFICATION_ONUS is not set
-# CONFIG_CFG80211_DEFAULT_PS is not set
-# CONFIG_CFG80211_DEBUGFS is not set
-CONFIG_CFG80211_INTERNAL_REGDB=y
-CONFIG_CFG80211_WEXT=y
-# CONFIG_LIB80211 is not set
-CONFIG_CFG80211_ALLOW_RECONNECT=y
-# CONFIG_MAC80211 is not set
-# CONFIG_WIMAX is not set
-# CONFIG_RFKILL is not set
-# CONFIG_RFKILL_REGULATOR is not set
-# CONFIG_NET_9P is not set
-# CONFIG_CAIF is not set
-# CONFIG_CEPH_LIB is not set
-# CONFIG_NFC is not set
-# CONFIG_MTK_NET_LOGGING is not set
-
-#
-# Device Drivers
-#
-
-#
-# Generic Driver Options
-#
-CONFIG_UEVENT_HELPER_PATH=""
-# CONFIG_DEVTMPFS is not set
-CONFIG_STANDALONE=y
-CONFIG_PREVENT_FIRMWARE_BUILD=y
-CONFIG_FW_LOADER=y
-CONFIG_FIRMWARE_IN_KERNEL=y
-CONFIG_EXTRA_FIRMWARE=""
-CONFIG_FW_LOADER_USER_HELPER=y
-# CONFIG_DEBUG_DRIVER is not set
-# CONFIG_DEBUG_DEVRES is not set
-# CONFIG_SYS_HYPERVISOR is not set
-# CONFIG_GENERIC_CPU_DEVICES is not set
-CONFIG_HAVE_CPU_AUTOPROBE=y
-CONFIG_GENERIC_CPU_AUTOPROBE=y
-CONFIG_REGMAP=y
-CONFIG_REGMAP_I2C=y
-CONFIG_REGMAP_SPI=y
-CONFIG_DMA_SHARED_BUFFER=y
-
-#
-# Bus devices
-#
-# CONFIG_CONNECTOR is not set
-CONFIG_MTD=y
-# CONFIG_MTD_REDBOOT_PARTS is not set
-# CONFIG_MTD_CMDLINE_PARTS is not set
-CONFIG_MTD_OF_PARTS=y
-# CONFIG_MTD_AR7_PARTS is not set
-
-#
-# User Modules And Translation Layers
-#
-CONFIG_MTD_BLKDEVS=y
-CONFIG_MTD_BLOCK=y
-# CONFIG_FTL is not set
-# CONFIG_NFTL is not set
-# CONFIG_INFTL is not set
-# CONFIG_RFD_FTL is not set
-# CONFIG_SSFDC is not set
-# CONFIG_SM_FTL is not set
-# CONFIG_MTD_OOPS is not set
-# CONFIG_MTD_SWAP is not set
-
-#
-# RAM/ROM/Flash chip drivers
-#
-# CONFIG_MTD_CFI is not set
-# CONFIG_MTD_JEDECPROBE is not set
-CONFIG_MTD_MAP_BANK_WIDTH_1=y
-CONFIG_MTD_MAP_BANK_WIDTH_2=y
-CONFIG_MTD_MAP_BANK_WIDTH_4=y
-# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
-CONFIG_MTD_CFI_I1=y
-CONFIG_MTD_CFI_I2=y
-# CONFIG_MTD_CFI_I4 is not set
-# CONFIG_MTD_CFI_I8 is not set
-# CONFIG_MTD_RAM is not set
-# CONFIG_MTD_ROM is not set
-# CONFIG_MTD_ABSENT is not set
-
-#
-# Mapping drivers for chip access
-#
-# CONFIG_MTD_COMPLEX_MAPPINGS is not set
-# CONFIG_MTD_PLATRAM is not set
-
-#
-# Self-contained MTD device drivers
-#
-# CONFIG_MTD_DATAFLASH is not set
-# CONFIG_MTD_M25P80 is not set
-# CONFIG_MTD_SST25L is not set
-# CONFIG_MTD_SLRAM is not set
-# CONFIG_MTD_PHRAM is not set
-# CONFIG_MTD_MTDRAM is not set
-# CONFIG_MTD_BLOCK2MTD is not set
-
-#
-# Disk-On-Chip Device Drivers
-#
-# CONFIG_MTD_DOCG3 is not set
-CONFIG_MTD_NAND_IDS=y
-# CONFIG_MTD_NAND is not set
-# CONFIG_MTD_ONENAND is not set
-
-#
-# LPDDR flash memory drivers
-#
-# CONFIG_MTD_LPDDR is not set
-# CONFIG_MTD_UBI is not set
-CONFIG_DTC=y
-CONFIG_OF=y
-
-#
-# Device Tree and Open Firmware support
-#
-# CONFIG_PROC_DEVICETREE is not set
-# CONFIG_OF_SELFTEST is not set
-CONFIG_OF_FLATTREE=y
-CONFIG_OF_EARLY_FLATTREE=y
-CONFIG_OF_ADDRESS=y
-CONFIG_OF_IRQ=y
-CONFIG_OF_DEVICE=y
-CONFIG_OF_I2C=y
-CONFIG_OF_NET=y
-CONFIG_OF_MTD=y
-CONFIG_OF_RESERVED_MEM=y
-# CONFIG_PARPORT is not set
-CONFIG_BLK_DEV=y
-# CONFIG_BLK_DEV_COW_COMMON is not set
-CONFIG_BLK_DEV_LOOP=y
-CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
-# CONFIG_BLK_DEV_CRYPTOLOOP is not set
-# CONFIG_BLK_DEV_DRBD is not set
-# CONFIG_BLK_DEV_NBD is not set
-# CONFIG_BLK_DEV_RAM is not set
-# CONFIG_CDROM_PKTCDVD is not set
-# CONFIG_ATA_OVER_ETH is not set
-# CONFIG_BLK_DEV_RBD is not set
-
-#
-# Misc devices
-#
-# CONFIG_ANDROID_PMEM is not set
-# CONFIG_SENSORS_LIS3LV02D is not set
-# CONFIG_AD525X_DPOT is not set
-# CONFIG_ATMEL_PWM is not set
-# CONFIG_DUMMY_IRQ is not set
-# CONFIG_ICS932S401 is not set
-# CONFIG_ATMEL_SSC is not set
-# CONFIG_ENCLOSURE_SERVICES is not set
-# CONFIG_APDS9802ALS is not set
-# CONFIG_ISL29003 is not set
-# CONFIG_ISL29020 is not set
-# CONFIG_SENSORS_TSL2550 is not set
-# CONFIG_SENSORS_BH1780 is not set
-# CONFIG_SENSORS_BH1770 is not set
-# CONFIG_SENSORS_APDS990X is not set
-# CONFIG_HMC6352 is not set
-# CONFIG_DS1682 is not set
-# CONFIG_TI_DAC7512 is not set
-CONFIG_UID_STAT=y
-# CONFIG_BMP085_I2C is not set
-# CONFIG_BMP085_SPI is not set
-# CONFIG_USB_SWITCH_FSA9480 is not set
-# CONFIG_LATTICE_ECP3_CONFIG is not set
-# CONFIG_SRAM is not set
-# CONFIG_C2PORT is not set
-
-#
-# EEPROM support
-#
-# CONFIG_EEPROM_AT24 is not set
-# CONFIG_EEPROM_AT25 is not set
-# CONFIG_EEPROM_LEGACY is not set
-# CONFIG_EEPROM_MAX6875 is not set
-# CONFIG_EEPROM_93CX6 is not set
-# CONFIG_EEPROM_93XX46 is not set
-
-#
-# Texas Instruments shared transport line discipline
-#
-# CONFIG_TI_ST is not set
-# CONFIG_SENSORS_LIS3_SPI is not set
-# CONFIG_SENSORS_LIS3_I2C is not set
-
-#
-# Altera FPGA firmware download module
-#
-# CONFIG_ALTERA_STAPL is not set
-CONFIG_MEDIATEK_SOLUTION=y
-CONFIG_MTK_PLATFORM="mt6735"
-CONFIG_ARCH_MTK_PROJECT="lentk6735m_65c_l1"
-# CONFIG_MTK_INTERNAL is not set
-CONFIG_MTK_CIRQ=y
-CONFIG_MTK_SYS_CIRQ=y
-CONFIG_MTK_SYSTRACKER=y
-# CONFIG_MTK_L2C_SHARE is not set
-CONFIG_HAVE_AEE_FEATURE=y
-CONFIG_HAVE_XLOG_FEATURE=y
-# CONFIG_FPGA_EARLY_PORTING is not set
-CONFIG_MTK_EMMC_SUPPORT=y
-CONFIG_MTK_NEW_COMBO_EMMC_SUPPORT=y
-CONFIG_MTK_GPT_SCHEME_SUPPORT=y
-# CONFIG_MTK_SHARED_SDCARD is not set
-CONFIG_MTK_MULTI_STORAGE_SUPPORT=y
-# CONFIG_MTK_MULTI_PARTITION_MOUNT_ONLY_SUPPORT is not set
-CONFIG_MTK_SECURITY_SW_SUPPORT=y
-# CONFIG_HAVE_MTK_IN_HOUSE_TEE_SUPPORT is not set
-# CONFIG_HAVE_TRUSTONIC_TEE_SUPPORT is not set
-# CONFIG_MTK_THERMAL_STATUS_COLLECTION is not set
-# CONFIG_MD32_SUPPORT is not set
-# CONFIG_MTK_MEMCFG is not set
-# CONFIG_MTK_DT_SUPPORT is not set
-# CONFIG_MTK_SMARTBOOK_SUPPORT is not set
-CONFIG_MTK_SENSOR_SUPPORT=y
-CONFIG_MTK_AUTO_DETECT_ACCELEROMETER=y
-# CONFIG_MTK_AUTO_DETECT_MAGNETOMETER is not set
-# CONFIG_MTK_AUTO_DETECT_ALSPS is not set
-CONFIG_CUSTOM_KERNEL_ACCELEROMETER=y
-CONFIG_CUSTOM_KERNEL_GYROSCOPE=y
-CONFIG_CUSTOM_KERNEL_ALSPS=y
-# CONFIG_CUSTOM_SEC_AUTH_SUPPORT is not set
-CONFIG_CUSTOM_KERNEL_MAGNETOMETER=y
-# CONFIG_CUSTOM_KERNEL_BAROMETER is not set
-# CONFIG_MTK_SENSOR_HUB_SUPPORT is not set
-CONFIG_CUSTOM_KERNEL_SENSORHUB=""
-CONFIG_CUSTOM_KERNEL_STEP_COUNTER=""
-CONFIG_CUSTOM_KERNEL_SIGNIFICANT_MOTION_SENSOR=""
-CONFIG_CUSTOM_KERNEL_ACTIVITY_SENSOR=""
-CONFIG_CUSTOM_KERNEL_PICK_UP_SENSOR=""
-CONFIG_CUSTOM_KERNEL_SHAKE_SENSOR=""
-CONFIG_CUSTOM_KERNEL_FACE_DOWN_SENSOR=""
-CONFIG_CUSTOM_KERNEL_IN_POCKET_SENSOR=""
-CONFIG_CUSTOM_KERNEL_PEDOMETER=""
-CONFIG_CUSTOM_KERNEL_HEART_RATE_SENSOR=""
-CONFIG_CUSTOM_KERNEL_TILT_DETECTOR_SENSOR=""
-CONFIG_CUSTOM_KERNEL_WAKE_GESTURE_SENSOR=""
-CONFIG_CUSTOM_KERNEL_GLANCE_GESTURE_SENSOR=""
-CONFIG_CUSTOM_KERNEL_IMGSENSOR="imx219_mipi_raw ov8858_mipi_raw ov5648_mipi_raw ov2680_mipi_raw"
-CONFIG_CUSTOM_KERNEL_CAM_CAL_DRV="imx219_eeprom"
-CONFIG_CUSTOM_KERNEL_LCM="otm1284a_hd_dsi_vdo"
-CONFIG_CUSTOM_KERNEL_FLASHLIGHT="constant_flashlight"
-CONFIG_CUSTOM_KERNEL_EXTMD=""
-CONFIG_CUSTOM_KERNEL_SSW="ssw_single_v2"
-# CONFIG_MTK_FORCE_CLUSTER1 is not set
-# CONFIG_MTK_MMPROFILE_SUPPORT is not set
-CONFIG_MTK_HIBERNATION=y
-# CONFIG_CUSTOM_KERNEL_CHARGEPUMP is not set
-# CONFIG_MTK_TC1_FEATURE is not set
-# CONFIG_MTK_TC7_FEATURE is not set
-# CONFIG_MTK_TC1_FM_AT_SUSPEND is not set
-
-#
-# Kernel Configurations
-#
-
-#
-# Tracer Related
-#
-# CONFIG_MTK_SCHED_TRACERS is not set
-# CONFIG_MTK_KERNEL_MARKER is not set
-# CONFIG_MT65XX_TRACER is not set
-
-#
-# MET
-#
-CONFIG_MTK_MET=y
-CONFIG_MTK_MET_PLF=y
-
-#
-# MTPROF tools
-#
-CONFIG_MTK_MUTATION=y
-CONFIG_MTPROF_CPUTIME=y
-# CONFIG_MTPROF_IRQ_DURATION is not set
-CONFIG_MTK_AEE_FEATURE=y
-CONFIG_MTK_AEE_AED=y
-CONFIG_MTK_AEE_IPANIC=y
-# CONFIG_MTK_AEE_POWERKEY_HANG_DETECT is not set
-# CONFIG_MTK_AEE_MRDUMP is not set
-# CONFIG_ANDROID_VMEM is not set
-# CONFIG_CPUTIME_SUPPORT is not set
-# CONFIG_CPUTIME_STATS is not set
-CONFIG_MTK_RAM_CONSOLE=y
-# CONFIG_MTK_RAM_CONSOLE_USING_SRAM is not set
-CONFIG_MTK_RAM_CONSOLE_USING_DRAM=y
-CONFIG_MTK_RAM_CONSOLE_SIZE=0x3000
-CONFIG_MTK_RAM_CONSOLE_ADDR=0xF912D000
-CONFIG_MTK_RAM_CONSOLE_DRAM_SIZE=0x10000
-CONFIG_MTK_RAM_CONSOLE_DRAM_ADDR=0x43F00000
-# CONFIG_PREEMPT_MONITOR is not set
-# CONFIG_ISR_MONITOR is not set
-# CONFIG_MT_SCHED_MONITOR is not set
-# CONFIG_MT_CHRDEV_REG is not set
-# CONFIG_MT_LOCK_DEBUG is not set
-CONFIG_PRINTK_PROCESS_INFO=y
-CONFIG_MT_PRINTK_UART_CONSOLE=y
-# CONFIG_MT_ENG_BUILD is not set
-CONFIG_RAMDISK_OFFSET=0xF00000
-# CONFIG_EARLY_LINUX_PORTING is not set
-# CONFIG_MTK_MCI is not set
-# CONFIG_MTK_ETM is not set
-
-#
-# MT load balance and schedule enhancement
-#
-CONFIG_MT_SCHED=y
-CONFIG_MT_LOAD_BALANCE_ENHANCEMENT=y
-# CONFIG_MT_LOAD_BALANCE_PROFILER is not set
-CONFIG_MTK_COMPAT=y
-CONFIG_MT_SCHED_INTEROP=y
-CONFIG_MTK_SCHED_RQAVG_US=y
-CONFIG_MTK_SCHED_RQAVG_KS=y
-# CONFIG_MT_PRIO_TRACER is not set
-# CONFIG_MT_SCHED_TRACE is not set
-# CONFIG_MT_DEBUG_PREEMPT is not set
-
-#
-# MTK Cluster MultiProcessor Scheduler
-#
-CONFIG_MTK_CPU_TOPOLOGY=y
-# CONFIG_MTK_WQ_DEBUG is not set
-CONFIG_MTK_STORAGE_PID_LOGGER=y
-
-#
-# MTK Large Memory mode support
-#
-# CONFIG_MTK_LM_MODE is not set
-# CONFIG_MTK_TABLET_HARDWARE is not set
-CONFIG_GATOR_DRIVER=y
-# CONFIG_MTK_IPV6_TETHER_NDP_MODE is not set
-# CONFIG_MTK_EMMC_SUPPORT_OTP is not set
-CONFIG_MTK_TETHERINGIPV6_SUPPORT=y
-CONFIG_MTK_LEGACY=y
-
-#
-# Drivers Configurations
-#
-# CONFIG_MTK_LDVT is not set
-CONFIG_MTK_ACCDET=y
-# CONFIG_MTK_IRTX_SUPPORT is not set
-CONFIG_MTK_CCCI_DEVICES=y
-# CONFIG_MTK_CCCI_DRIVER is not set
-# CONFIG_MTK_CCCI_EXT is not set
-CONFIG_MTK_ECCCI_DRIVER=y
-CONFIG_MTK_ECCCI_CLDMA=y
-# CONFIG_MTK_ECCCI_CCIF is not set
-# CONFIG_MTK_ECCCI_UT is not set
-# CONFIG_MTK_MD_LOW_BAT_SUPPORT is not set
-CONFIG_MTK_NET_CCMNI=y
-CONFIG_MTK_ENABLE_MD1=y
-CONFIG_MTK_MD1_SUPPORT=6
-CONFIG_MD1_SIZE=0x5000000
-CONFIG_MD1_SMEM_SIZE=0x200000
-# CONFIG_MTK_ENABLE_MD2 is not set
-CONFIG_MTK_MD_SBP_CUSTOM_VALUE=""
-CONFIG_MTK_MD2_SBP_CUSTOM_VALUE=""
-CONFIG_MTK_UMTS_TDD128_MODE=y
-# CONFIG_MTK_EMCI_DEVICES is not set
-CONFIG_MTK_EXTERNAL_MODEM_SLOT=""
-# CONFIG_MTK_SWITCH_TX_POWER is not set
-CONFIG_MTK_CONN_LTE_IDC_SUPPORT=y
-CONFIG_MTK_FB=y
-CONFIG_MTK_FB_SUPPORT_ASSERTION_LAYER=y
-CONFIG_MTK_DITHERING_SUPPORT=y
-CONFIG_MTK_LCM_PHYSICAL_ROTATION="0"
-CONFIG_LCM_HEIGHT="1280"
-CONFIG_LCM_WIDTH="720"
-CONFIG_CUSTOM_LCM_X="0"
-CONFIG_CUSTOM_LCM_Y="0"
-# CONFIG_MTK_OVERLAY_ENGINE_SUPPORT is not set
-# CONFIG_MTK_TVOUT_SUPPORT is not set
-# CONFIG_MIXMODE_FOR_INCELL is not set
-# CONFIG_LCM_SEND_CMD_IN_VIDEO is not set
-CONFIG_GPS=y
-CONFIG_MTK_GPS=y
-# CONFIG_MTK_NFC is not set
-# CONFIG_NFC_MT6605 is not set
-# CONFIG_NFC_MSR3110 is not set
-CONFIG_MTK_BTIF=y
-CONFIG_MTK_COMBO=y
-# CONFIG_MTK_COMBO_CHIP_MT6620 is not set
-# CONFIG_MTK_COMBO_CHIP_MT6628 is not set
-# CONFIG_MTK_COMBO_CHIP_MT6630 is not set
-# CONFIG_MTK_COMBO_CHIP_CONSYS_6572 is not set
-# CONFIG_MTK_COMBO_CHIP_CONSYS_6582 is not set
-# CONFIG_MTK_COMBO_CHIP_CONSYS_8127 is not set
-# CONFIG_MTK_COMBO_CHIP_CONSYS_6752 is not set
-# CONFIG_MTK_COMBO_CHIP_CONSYS_6592 is not set
-# CONFIG_MTK_COMBO_CHIP_CONSYS_8163 is not set
-CONFIG_MTK_COMBO_CHIP_CONSYS_6735=y
-# CONFIG_MTK_COMBO_CHIP_CONSYS_6580 is not set
-CONFIG_MTK_COMBO_CHIP="CONSYS_6735"
-CONFIG_MTK_WAPI_SUPPORT=y
-CONFIG_MTK_PASSPOINT_R1_SUPPORT=y
-# CONFIG_MTK_PASSPOINT_R2_SUPPORT is not set
-CONFIG_MTK_WIFI_MCC_SUPPORT=y
-CONFIG_MTK_COMBO_PLAT_PATH=""
-# CONFIG_MTK_COMBO_COMM is not set
-CONFIG_MTK_COMBO_BT=y
-# CONFIG_MTK_COMBO_ANT is not set
-CONFIG_MTK_COMBO_GPS=y
-CONFIG_MTK_GPS_SUPPORT=y
-CONFIG_MTK_COMBO_WIFI=y
-CONFIG_MTK_BT_SUPPORT=y
-# CONFIG_MTK_WFD_SUPPORT is not set
-CONFIG_MTK_FM=y
-CONFIG_MTK_FM_SUPPORT=y
-CONFIG_MTK_FM_CHIP="MT6625_FM"
-# CONFIG_MTK_FM_50KHZ_SUPPORT is not set
-# CONFIG_MTK_MERGE_INTERFACE_SUPPORT is not set
-# CONFIG_SDIOAUTOK_SUPPORT is not set
-# CONFIG_MTK_MT6306_SUPPORT is not set
-# CONFIG_MTK_IDLE_TIME_FIX is not set
-CONFIG_MTK_G2D=y
-CONFIG_MTK_MPEG4_DEC_DRIVER=y
-CONFIG_MTK_MPEG4_ENC_DRIVER=y
-CONFIG_MTK_H264_DEC_DRIVER=y
-CONFIG_MTK_MFLEXVIDEO_DRIVER=y
-CONFIG_MTK_VIDEOCODEC_DRIVER=y
-# CONFIG_MTK_MJC_DRIVER is not set
-CONFIG_MTK_I2C=y
-CONFIG_MTK_SPI=y
-# CONFIG_MTK_CMMB is not set
-CONFIG_MTK_JPEG=y
-CONFIG_MTK_KEYPAD=y
-# CONFIG_KEYBOARD_HID is not set
-CONFIG_MTK_LEDS=y
-CONFIG_MTK_MMC=y
-# CONFIG_MTK_SDIOAUTOK_SUPPORT is not set
-
-#
-# MediaTek OFN / Jogball Related Drivers
-#
-# CONFIG_MOUSE_PANASONIC_EVQWJN is not set
-# CONFIG_MOUSE_AVAGOTECH_A320 is not set
-CONFIG_MTK_SMART_BATTERY=y
-CONFIG_MTK_PMIC=y
-CONFIG_MTK_PMIC_WRAP=y
-# CONFIG_MTK_PMIC_MT6397 is not set
-# CONFIG_POWER_EXT is not set
-# CONFIG_MTK_POWER_EXT_DETECT is not set
-# CONFIG_MTK_PUMP_EXPRESS_SUPPORT is not set
-# CONFIG_MTK_PUMP_EXPRESS_PLUS_SUPPORT is not set
-# CONFIG_MTK_VOW_SUPPORT is not set
-# CONFIG_MTK_EXTERNAL_LDO is not set
-# CONFIG_X2_BQ27531_SUPPORT is not set
-# CONFIG_MTK_BQ24250_SUPPORT is not set
-# CONFIG_MTK_BQ24261_SUPPORT is not set
-# CONFIG_MTK_BQ24196_SUPPORT is not set
-# CONFIG_MTK_FAN5405_SUPPORT is not set
-# CONFIG_MTK_FAN5402_SUPPORT is not set
-# CONFIG_MTK_BQ24158_SUPPORT is not set
-# CONFIG_MTK_BQ24296_SUPPORT is not set
-# CONFIG_MTK_BQ27541_SUPPORT is not set
-# CONFIG_MTK_NCP1851_SUPPORT is not set
-# CONFIG_MTK_NCP1854_SUPPORT is not set
-# CONFIG_MTK_RT9536_SUPPORT is not set
-# CONFIG_MTK_MAX8971_SUPPORT is not set
-# CONFIG_MTK_DUAL_INPUT_CHARGER_SUPPORT is not set
-# CONFIG_MTK_WIRELESS_CHARGER_SUPPORT is not set
-# CONFIG_MTK_JEITA_STANDARD_SUPPORT is not set
-CONFIG_MTK_RTC=y
-CONFIG_MTK_SERIAL=y
-CONFIG_MTK_SERIAL_CONSOLE=y
-# CONFIG_MTK_SERIAL_MODEM_TEST is not set
-# CONFIG_MTK_UART_USB_SWITCH is not set
-CONFIG_MTK_SIM2=y
-# CONFIG_MTK_SOUND is not set
-# CONFIG_MTK_AUDIO_EXTCODEC_SUPPORT is not set
-# CONFIG_MTK_CM36283 is not set
-# CONFIG_MTK_GP2AP002S00F is not set
-# CONFIG_MTK_APM_16D is not set
-# CONFIG_MTK_EPL2182 is not set
-# CONFIG_MTK_EPL2182_NEW is not set
-# CONFIG_MTK_STK3X1X is not set
-# CONFIG_MTK_STK3X1X_NEW is not set
-# CONFIG_MTK_CM36652_NEW is not set
-# CONFIG_MTK_APDS9930 is not set
-# CONFIG_MTK_CM3232_NEW is not set
-# CONFIG_MTK_APDS9930_NEW is not set
-# CONFIG_MTK_KXTJ2_1009 is not set
-# CONFIG_MTK_KXTIK1004 is not set
-# CONFIG_MTK_K2DH is not set
-# CONFIG_MTK_BMA222E is not set
-# CONFIG_MTK_BMA222E_NEW is not set
-# CONFIG_MTK_MC3410_NEW is not set
-# CONFIG_MTK_KXTJ2_1009_AUTO is not set
-# CONFIG_MTK_MC3XXX is not set
-# CONFIG_MTK_MPU6050G_NEW is not set
-# CONFIG_MTK_BMA250 is not set
-# CONFIG_MTK_MPU6515A is not set
-# CONFIG_MTK_MPU60X0 is not set
-CONFIG_MTK_KXTJ2_1009_NEW=y
-CONFIG_MTK_MC3XXX_AUTO=y
-# CONFIG_MTK_BMA250E is not set
-# CONFIG_MTK_MPU3050C is not set
-# CONFIG_MTK_MPU3000 is not set
-# CONFIG_MTK_MPU3000_NEW is not set
-# CONFIG_MTK_MPU6050GY_NEW is not set
-# CONFIG_MTK_ITG1010_NEW is not set
-# CONFIG_MTK_MPU6515G is not set
-# CONFIG_MTK_MPU3050C_NEW is not set
-# CONFIG_MTK_MPU6050C is not set
-# CONFIG_MTK_AKM8963 is not set
-# CONFIG_MTK_AKM8963_NEW is not set
-# CONFIG_MTK_AKM09911 is not set
-CONFIG_MTK_AKM09911_NEW=y
-# CONFIG_MTK_HSCDTD006 is not set
-# CONFIG_MTK_BMM050 is not set
-# CONFIG_MTK_BMM050_NEW is not set
-# CONFIG_MTK_MMC3416X is not set
-# CONFIG_MTK_BMA050 is not set
-# CONFIG_MTK_BMA050_NEW is not set
-# CONFIG_MTK_BMA255_SDO0 is not set
-# CONFIG_MTK_BMA255_SDO1 is not set
-# CONFIG_MTK_S2200 is not set
-# CONFIG_MTK_YAS532 is not set
-# CONFIG_MTK_YAS532_NEW is not set
-# CONFIG_MTK_BMP180_NEW is not set
-CONFIG_MTK_TOUCHPANEL=y
-# CONFIG_MTK_S7020 is not set
-CONFIG_MTK_USB_GADGET=y
-# CONFIG_USB_MU3D_PIO_ONLY is not set
-# CONFIG_USB_MU3D_DRV is not set
-# CONFIG_USB_MU3D_DVT is not set
-# CONFIG_MU3_PHY is not set
-# CONFIG_MTK_XHCI is not set
-# CONFIG_MTK_OTG_PMIC_BOOST_5V is not set
-# CONFIG_MTK_OTG_OC_DETECTOR is not set
-# CONFIG_MTK_TEST_XHCI is not set
-# CONFIG_USBIF_COMPLIANCE is not set
-# CONFIG_MTK_S3320 is not set
-# CONFIG_MTK_S3320_47 is not set
-# CONFIG_MTK_S3320_50 is not set
-# CONFIG_LEDS_LM3632 is not set
-# CONFIG_LEDS_LM3639 is not set
-# CONFIG_LEDS_RT8542 is not set
-CONFIG_MTK_VIBRATOR=y
-CONFIG_MTK_WD_KICKER=y
-# CONFIG_MT592X_SDIO_CLNT is not set
-CONFIG_USB_MTK_ACM_TEMP=y
-CONFIG_USB_MTK_HDRC=y
-CONFIG_USB_MTK_HDRC_GADGET=y
-# CONFIG_USB_MTK_OTG is not set
-# CONFIG_USB_MTK_DUALMODE is not set
-CONFIG_USB_MTK_DEBUG_FS=y
-CONFIG_USB_MTK_DEBUG=y
-# CONFIG_USB_MTK_HDRC_HCD is not set
-# CONFIG_MTK_USB_UNIQUE_SERIAL is not set
-# CONFIG_MTK_USBFSH is not set
-# CONFIG_MUSBFSH_PIO_ONLY is not set
-# CONFIG_MTK_MUSB_QMU_SUPPORT is not set
-CONFIG_AMPC_CDEV_NUM=151
-CONFIG_ION_MTK=y
-CONFIG_ION_MTK_FB_HEAP_SUPPORT=y
-CONFIG_MMPROFILE=y
-# CONFIG_MTK_STAGING is not set
-# CONFIG_PWR_LOSS_MTK_TEST is not set
-CONFIG_MTK_EMMC_CACHE=y
-CONFIG_MTK_GPU_SUPPORT=y
-# CONFIG_MTK_ICUSB_SUPPORT is not set
-# CONFIG_MTK_DT_USB_SUPPORT is not set
-# CONFIG_MTK_SWCHR_SUPPORT is not set
-# CONFIG_MTK_DISABLE_POWER_ON_OFF_VOLTAGE_LIMITATION is not set
-CONFIG_MTK_KERNEL_POWER_OFF_CHARGING=y
-# CONFIG_MTK_BQ24160_SUPPORT is not set
-# CONFIG_MTK_MT8193_SUPPORT is not set
-# CONFIG_MTK_HDMI_SUPPORT is not set
-# CONFIG_MTK_MT8193_HDCP_SUPPORT is not set
-CONFIG_CUSTOM_KERNEL_HDMI=""
-# CONFIG_SINGLE_PANEL_OUTPUT is not set
-CONFIG_MTK_THERMAL_PA_VIA_ATCMD=y
-CONFIG_MTK_SIM1_SOCKET_TYPE="1"
-CONFIG_MTK_SIM2_SOCKET_TYPE="1"
-CONFIG_MTK_SEC_MODEM_NVRAM_ANTI_CLONE=y
-# CONFIG_MTK_MT6333_SUPPORT is not set
-# CONFIG_MTK_CTP_RESET_CONFIG is not set
-CONFIG_MTK_BICR_SUPPORT=y
-# CONFIG_MTK_VIDEO_HEVC_SUPPORT is not set
-# CONFIG_MTK_AAL_SUPPORT is not set
-# CONFIG_MTK_MULTIBRIDGE_SUPPORT is not set
-# CONFIG_NAND_OTP_SUPPORT is not set
-# CONFIG_MTK_OD_SUPPORT is not set
-# CONFIG_MTK_LENS_DUMMYLENS_SUPPORT is not set
-# CONFIG_MTK_LENS_AD5820AF_SUPPORT is not set
-CONFIG_MTK_LENS_AD5823_SUPPORT=y
-# CONFIG_MTK_LENS_AD5823AF_SUPPORT is not set
-# CONFIG_MTK_LENS_AK7345AF_SUPPORT is not set
-# CONFIG_MTK_LENS_BU6424AF_SUPPORT is not set
-# CONFIG_MTK_LENS_BU6429AF_SUPPORT is not set
-# CONFIG_MTK_LENS_BU64745GWZAF_SUPPORT is not set
-# CONFIG_MTK_LENS_DW9718AF_SUPPORT is not set
-# CONFIG_MTK_LENS_DW9714AF_SUPPORT is not set
-# CONFIG_MTK_LENS_DW9714A_SUPPORT is not set
-# CONFIG_MTK_LENS_DW9814AF_SUPPORT is not set
-# CONFIG_MTK_LENS_LC898122AF_SUPPORT is not set
-# CONFIG_MTK_LENS_LC898212AF_SUPPORT is not set
-CONFIG_MTK_LENS_FM50AF_SUPPORT=y
-# CONFIG_MTK_LENS_MT9P017AF_SUPPORT is not set
-# CONFIG_MTK_LENS_OV8825AF_SUPPORT is not set
-# CONFIG_MTK_LENS_SENSORDRIVE_SUPPORT is not set
-# CONFIG_MTK_LENS_GAF001AF_SUPPORT is not set
-# CONFIG_MTK_LENS_GAF002AF_SUPPORT is not set
-# CONFIG_MTK_LENS_GAF008AF_SUPPORT is not set
-# CONFIG_MTK_EXTMEM is not set
-# CONFIG_MTK_INHOUSE_GPU is not set
-# CONFIG_SW_SYNC64 is not set
-CONFIG_MTK_CPU_STRESS=y
-CONFIG_MTK_LASTPC=y
-CONFIG_MTK_FMRADIO=y
-CONFIG_MTK_HWMON=y
-CONFIG_MTK_CMDQ=y
-CONFIG_MTK_VIDEOX=y
-CONFIG_MTK_MT_LOGGER=y
-CONFIG_MTK_CONN_MD=y
-CONFIG_MTK_LENS=y
-# CONFIG_MTK_IMGSENSOR is not set
-# CONFIG_MTK_CAM_CAL is not set
-# CONFIG_MTK_FLASHLIGHT is not set
-# CONFIG_MTK_DUM_CHAR is not set
-CONFIG_MTK_SYSENV=y
-CONFIG_MTK_SMI=y
-CONFIG_MTK_BTCVSD=y
-# CONFIG_MTK_SOUND_DRV is not set
-CONFIG_MTK_POWER_GS=y
-# CONFIG_MTK_VIDEO is not set
-# CONFIG_MTK_MRDUMP is not set
-# CONFIG_MTK_WMT_CCCI is not set
-CONFIG_MTK_VCOREFS=y
-CONFIG_MTK_EMI_MPU=y
-CONFIG_MTK_EMI_BWL=y
-# CONFIG_MTK_DBG_DUMP is not set
-
-#
-# SCSI device support
-#
-CONFIG_SCSI_MOD=y
-# CONFIG_RAID_ATTRS is not set
-CONFIG_SCSI=y
-CONFIG_SCSI_DMA=y
-CONFIG_SCSI_TGT=y
-# CONFIG_SCSI_NETLINK is not set
-CONFIG_SCSI_PROC_FS=y
-
-#
-# SCSI support type (disk, tape, CD-ROM)
-#
-CONFIG_BLK_DEV_SD=y
-# CONFIG_CHR_DEV_ST is not set
-# CONFIG_CHR_DEV_OSST is not set
-# CONFIG_BLK_DEV_SR is not set
-# CONFIG_CHR_DEV_SG is not set
-# CONFIG_CHR_DEV_SCH is not set
-CONFIG_SCSI_MULTI_LUN=y
-# CONFIG_SCSI_CONSTANTS is not set
-# CONFIG_SCSI_LOGGING is not set
-CONFIG_SCSI_SCAN_ASYNC=y
-
-#
-# SCSI Transports
-#
-# CONFIG_SCSI_SPI_ATTRS is not set
-# CONFIG_SCSI_FC_ATTRS is not set
-# CONFIG_SCSI_ISCSI_ATTRS is not set
-# CONFIG_SCSI_SAS_ATTRS is not set
-# CONFIG_SCSI_SAS_LIBSAS is not set
-# CONFIG_SCSI_SRP_ATTRS is not set
-# CONFIG_SCSI_LOWLEVEL is not set
-# CONFIG_SCSI_LOWLEVEL_PCMCIA is not set
-# CONFIG_SCSI_DH is not set
-# CONFIG_SCSI_OSD_INITIATOR is not set
-# CONFIG_ATA is not set
-CONFIG_MD=y
-# CONFIG_BLK_DEV_MD is not set
-# CONFIG_BCACHE is not set
-CONFIG_BLK_DEV_DM_BUILTIN=y
-CONFIG_BLK_DEV_DM=y
-# CONFIG_DM_DEBUG is not set
-CONFIG_DM_CRYPT=y
-# CONFIG_DM_SNAPSHOT is not set
-# CONFIG_DM_THIN_PROVISIONING is not set
-# CONFIG_DM_CACHE is not set
-# CONFIG_DM_MIRROR is not set
-# CONFIG_DM_RAID is not set
-# CONFIG_DM_ZERO is not set
-# CONFIG_DM_MULTIPATH is not set
-# CONFIG_DM_DELAY is not set
-CONFIG_DM_UEVENT=y
-# CONFIG_DM_FLAKEY is not set
-# CONFIG_DM_VERITY is not set
-# CONFIG_TARGET_CORE is not set
-CONFIG_NETDEVICES=y
-CONFIG_NET_CORE=y
-# CONFIG_BONDING is not set
-# CONFIG_DUMMY is not set
-# CONFIG_EQUALIZER is not set
-# CONFIG_MII is not set
-CONFIG_IFB=y
-# CONFIG_NET_TEAM is not set
-# CONFIG_MACVLAN is not set
-# CONFIG_VXLAN is not set
-# CONFIG_NETCONSOLE is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-CONFIG_TUN=y
-# CONFIG_VETH is not set
-
-#
-# CAIF transport drivers
-#
-
-#
-# Distributed Switch Architecture drivers
-#
-# CONFIG_NET_DSA_MV88E6XXX is not set
-# CONFIG_NET_DSA_MV88E6060 is not set
-# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
-# CONFIG_NET_DSA_MV88E6131 is not set
-# CONFIG_NET_DSA_MV88E6123_61_65 is not set
-# CONFIG_ETHERNET is not set
-# CONFIG_PHYLIB is not set
-# CONFIG_MICREL_KS8995MA is not set
-CONFIG_PPP=y
-CONFIG_PPP_BSDCOMP=y
-CONFIG_PPP_DEFLATE=y
-CONFIG_PPP_FILTER=y
-CONFIG_PPP_MPPE=y
-CONFIG_PPP_MULTILINK=y
-CONFIG_PPPOE=y
-CONFIG_PPPOLAC=y
-CONFIG_PPPOPNS=y
-CONFIG_PPP_ASYNC=y
-CONFIG_PPP_SYNC_TTY=y
-# CONFIG_SLIP is not set
-CONFIG_SLHC=y
-
-#
-# USB Network Adapters
-#
-# CONFIG_USB_CATC is not set
-# CONFIG_USB_KAWETH is not set
-# CONFIG_USB_PEGASUS is not set
-# CONFIG_USB_RTL8150 is not set
-# CONFIG_USB_RTL8152 is not set
-# CONFIG_USB_USBNET is not set
-# CONFIG_USB_IPHETH is not set
-CONFIG_WLAN=y
-# CONFIG_USB_ZD1201 is not set
-# CONFIG_USB_NET_RNDIS_WLAN is not set
-# CONFIG_WIFI_CONTROL_FUNC is not set
-# CONFIG_ATH_CARDS is not set
-# CONFIG_BRCMFMAC is not set
-# CONFIG_HOSTAP is not set
-# CONFIG_LIBERTAS is not set
-# CONFIG_WL_TI is not set
-# CONFIG_MWIFIEX is not set
-
-#
-# Enable WiMAX (Networking options) to see the WiMAX drivers
-#
-# CONFIG_WAN is not set
-# CONFIG_ISDN is not set
-
-#
-# Input device support
-#
-CONFIG_INPUT=y
-# CONFIG_INPUT_FF_MEMLESS is not set
-# CONFIG_INPUT_POLLDEV is not set
-# CONFIG_INPUT_SPARSEKMAP is not set
-# CONFIG_INPUT_MATRIXKMAP is not set
-
-#
-# Userland interfaces
-#
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_JOYDEV is not set
-CONFIG_INPUT_EVDEV=y
-# CONFIG_INPUT_EVBUG is not set
-# CONFIG_INPUT_KEYRESET is not set
-# CONFIG_INPUT_KEYCOMBO is not set
-
-#
-# Input Device Drivers
-#
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_INPUT_JOYSTICK is not set
-# CONFIG_INPUT_TABLET is not set
-CONFIG_INPUT_TOUCHSCREEN=y
-# CONFIG_TOUCHSCREEN_ADS7846 is not set
-# CONFIG_TOUCHSCREEN_AD7877 is not set
-# CONFIG_TOUCHSCREEN_AD7879 is not set
-# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
-# CONFIG_TOUCHSCREEN_AUO_PIXCIR is not set
-# CONFIG_TOUCHSCREEN_BU21013 is not set
-# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
-# CONFIG_TOUCHSCREEN_CYTTSP_CORE is not set
-# CONFIG_TOUCHSCREEN_DYNAPRO is not set
-# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
-# CONFIG_TOUCHSCREEN_EETI is not set
-# CONFIG_TOUCHSCREEN_EGALAX is not set
-# CONFIG_TOUCHSCREEN_FUJITSU is not set
-# CONFIG_TOUCHSCREEN_ILI210X is not set
-# CONFIG_TOUCHSCREEN_GUNZE is not set
-# CONFIG_TOUCHSCREEN_ELO is not set
-# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
-# CONFIG_TOUCHSCREEN_WACOM_I2C is not set
-# CONFIG_TOUCHSCREEN_MAX11801 is not set
-# CONFIG_TOUCHSCREEN_MCS5000 is not set
-# CONFIG_TOUCHSCREEN_MMS114 is not set
-# CONFIG_TOUCHSCREEN_MTOUCH is not set
-# CONFIG_TOUCHSCREEN_INEXIO is not set
-# CONFIG_TOUCHSCREEN_MK712 is not set
-CONFIG_TOUCHSCREEN_MTK=y
-# CONFIG_TOUCHSCREEN_MTK_GT9XX is not set
-# CONFIG_TOUCHSCREEN_MTK_FHD is not set
-# CONFIG_TOUCHSCREEN_MTK_HD is not set
-# CONFIG_TOUCHSCREEN_MTK_GT9XX_AIO is not set
-# CONFIG_TOUCHSCREEN_MTK_GT9XX_HOTKNOT_SCP is not set
-# CONFIG_TOUCHSCREEN_MTK_GT9XX_HOTKNOT is not set
-# CONFIG_TOUCHSCREEN_MTK_GT1151 is not set
-CONFIG_MTK_GT915_HD=y
-CONFIG_MTK_FOCALTECH_HD=y
-# CONFIG_MTK_GT915_QHD is not set
-# CONFIG_MTK_FOCALTECH_QHD is not set
-# CONFIG_MTK_FT6X06_QHD is not set
-# CONFIG_TOUCHSCREEN_MTK_GT910 is not set
-# CONFIG_TOUCHSCREEN_MTK_MAX1187X is not set
-# CONFIG_TOUCHSCREEN_MTK_GT9XX_HOTKNOT_FPGA is not set
-# CONFIG_TOUCHSCREEN_MTK_GT9XXTB_HOTKNOT is not set
-# CONFIG_TOUCHSCREEN_MTK_GT818B_FPGA is not set
-# CONFIG_TOUCHSCREEN_S7020 is not set
-# CONFIG_TOUCHSCREEN_MTK_GT9XX_2 is not set
-# CONFIG_MTK_GT9XX is not set
-# CONFIG_GT9XX_2 is not set
-# CONFIG_MTK_GT911 is not set
-# CONFIG_MTK_MMS244 is not set
-# CONFIG_GT9XX_HOTKNOT_FLASHLESS is not set
-# CONFIG_MTK_FT5406 is not set
-# CONFIG_MTK_FT5406_82 is not set
-# CONFIG_MTK_FT5206 is not set
-# CONFIG_MTK_FT5X0X is not set
-# CONFIG_MTK_MMS134 is not set
-# CONFIG_MTK_MMS128 is not set
-# CONFIG_MTK_MIT200 is not set
-# CONFIG_TOUCHSCREEN_PENMOUNT is not set
-# CONFIG_TOUCHSCREEN_EDT_FT5X06 is not set
-# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
-# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
-# CONFIG_TOUCHSCREEN_PIXCIR is not set
-# CONFIG_TOUCHSCREEN_MTK_FTS2A052 is not set
-# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
-# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
-# CONFIG_TOUCHSCREEN_TSC_SERIO is not set
-# CONFIG_TOUCHSCREEN_TSC2005 is not set
-# CONFIG_TOUCHSCREEN_TSC2007 is not set
-# CONFIG_TOUCHSCREEN_W90X900 is not set
-# CONFIG_TOUCHSCREEN_ST1232 is not set
-# CONFIG_TOUCHSCREEN_TPS6507X is not set
-# CONFIG_TOUCHSCREEN_SYNAPTICS_S3528 is not set
-# CONFIG_TOUCHSCREEN_SYNAPTICS is not set
-CONFIG_INPUT_MISC=y
-# CONFIG_INPUT_AD714X is not set
-# CONFIG_INPUT_BMA150 is not set
-# CONFIG_INPUT_MMA8450 is not set
-# CONFIG_INPUT_MPU3050 is not set
-# CONFIG_INPUT_GP2A is not set
-# CONFIG_INPUT_GPIO_TILT_POLLED is not set
-# CONFIG_INPUT_ATI_REMOTE2 is not set
-# CONFIG_INPUT_KEYCHORD is not set
-# CONFIG_INPUT_KEYSPAN_REMOTE is not set
-# CONFIG_INPUT_KXTJ9 is not set
-# CONFIG_INPUT_POWERMATE is not set
-# CONFIG_INPUT_YEALINK is not set
-# CONFIG_INPUT_CM109 is not set
-CONFIG_INPUT_UINPUT=y
-# CONFIG_INPUT_GPIO is not set
-# CONFIG_INPUT_PCF8574 is not set
-# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
-# CONFIG_INPUT_ADXL34X is not set
-# CONFIG_INPUT_IMS_PCU is not set
-# CONFIG_INPUT_CMA3000 is not set
-
-#
-# Hardware I/O ports
-#
-# CONFIG_SERIO is not set
-# CONFIG_GAMEPORT is not set
-
-#
-# Character devices
-#
-CONFIG_TTY=y
-# CONFIG_VT is not set
-CONFIG_UNIX98_PTYS=y
-# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
-CONFIG_LEGACY_PTYS=y
-CONFIG_LEGACY_PTY_COUNT=16
-# CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_N_GSM is not set
-# CONFIG_TRACE_SINK is not set
-# CONFIG_DEVMEM is not set
-# CONFIG_DEVKMEM is not set
-
-#
-# Serial drivers
-#
-# CONFIG_SERIAL_8250 is not set
-
-#
-# Non-8250 serial port support
-#
-# CONFIG_SERIAL_AMBA_PL010 is not set
-# CONFIG_SERIAL_AMBA_PL011 is not set
-# CONFIG_SERIAL_MAX3100 is not set
-# CONFIG_SERIAL_MAX310X is not set
-CONFIG_SERIAL_CORE=y
-CONFIG_SERIAL_CORE_CONSOLE=y
-# CONFIG_SERIAL_SCCNXP is not set
-# CONFIG_SERIAL_TIMBERDALE is not set
-# CONFIG_SERIAL_ALTERA_JTAGUART is not set
-# CONFIG_SERIAL_ALTERA_UART is not set
-# CONFIG_SERIAL_IFX6X60 is not set
-# CONFIG_SERIAL_XILINX_PS_UART is not set
-# CONFIG_SERIAL_ARC is not set
-# CONFIG_TTY_PRINTK is not set
-# CONFIG_IPMI_HANDLER is not set
-# CONFIG_HW_RANDOM is not set
-# CONFIG_R3964 is not set
-
-#
-# PCMCIA character devices
-#
-# CONFIG_RAW_DRIVER is not set
-# CONFIG_TCG_TPM is not set
-CONFIG_I2C=y
-CONFIG_I2C_BOARDINFO=y
-CONFIG_I2C_COMPAT=y
-# CONFIG_I2C_CHARDEV is not set
-# CONFIG_I2C_MUX is not set
-CONFIG_I2C_HELPER_AUTO=y
-
-#
-# I2C Hardware Bus support
-#
-
-#
-# I2C system bus drivers (mostly embedded / system-on-chip)
-#
-# CONFIG_I2C_CBUS_GPIO is not set
-# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
-# CONFIG_I2C_GPIO is not set
-# CONFIG_I2C_NOMADIK is not set
-# CONFIG_I2C_OCORES is not set
-# CONFIG_I2C_PCA_PLATFORM is not set
-# CONFIG_I2C_PXA_PCI is not set
-# CONFIG_I2C_SIMTEC is not set
-# CONFIG_I2C_XILINX is not set
-
-#
-# External I2C/SMBus adapter drivers
-#
-# CONFIG_I2C_DIOLAN_U2C is not set
-# CONFIG_I2C_PARPORT_LIGHT is not set
-# CONFIG_I2C_TAOS_EVM is not set
-# CONFIG_I2C_TINY_USB is not set
-
-#
-# Other I2C/SMBus bus drivers
-#
-# CONFIG_I2C_DEBUG_CORE is not set
-# CONFIG_I2C_DEBUG_ALGO is not set
-# CONFIG_I2C_DEBUG_BUS is not set
-CONFIG_SPI=y
-# CONFIG_SPI_DEBUG is not set
-CONFIG_SPI_MASTER=y
-
-#
-# SPI Master Controller Drivers
-#
-# CONFIG_SPI_ALTERA is not set
-# CONFIG_SPI_BITBANG is not set
-# CONFIG_SPI_GPIO is not set
-# CONFIG_SPI_FSL_SPI is not set
-# CONFIG_SPI_OC_TINY is not set
-# CONFIG_SPI_PL022 is not set
-# CONFIG_SPI_PXA2XX_PCI is not set
-# CONFIG_SPI_SC18IS602 is not set
-# CONFIG_SPI_XCOMM is not set
-# CONFIG_SPI_XILINX is not set
-# CONFIG_SPI_DESIGNWARE is not set
-
-#
-# SPI Protocol Masters
-#
-# CONFIG_SPI_SPIDEV is not set
-# CONFIG_SPI_TLE62X0 is not set
-
-#
-# Qualcomm MSM SSBI bus support
-#
-# CONFIG_SSBI is not set
-# CONFIG_HSI is not set
-
-#
-# PPS support
-#
-# CONFIG_PPS is not set
-
-#
-# PPS generators support
-#
-
-#
-# PTP clock support
-#
-# CONFIG_PTP_1588_CLOCK is not set
-
-#
-# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
-#
-# CONFIG_PTP_1588_CLOCK_PCH is not set
-CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
-CONFIG_GPIO_DEVRES=y
-CONFIG_GPIOLIB=y
-CONFIG_OF_GPIO=y
-# CONFIG_DEBUG_GPIO is not set
-# CONFIG_GPIO_SYSFS is not set
-
-#
-# Memory mapped GPIO drivers:
-#
-# CONFIG_GPIO_GENERIC_PLATFORM is not set
-# CONFIG_GPIO_TS5500 is not set
-# CONFIG_GPIO_GRGPIO is not set
-
-#
-# I2C GPIO expanders:
-#
-# CONFIG_GPIO_MAX7300 is not set
-# CONFIG_GPIO_MAX732X is not set
-# CONFIG_GPIO_PCA953X is not set
-# CONFIG_GPIO_PCF857X is not set
-# CONFIG_GPIO_SX150X is not set
-# CONFIG_GPIO_ADP5588 is not set
-# CONFIG_GPIO_ADNP is not set
-
-#
-# PCI GPIO expanders:
-#
-
-#
-# SPI GPIO expanders:
-#
-# CONFIG_GPIO_MAX7301 is not set
-# CONFIG_GPIO_MCP23S08 is not set
-# CONFIG_GPIO_MC33880 is not set
-# CONFIG_GPIO_74X164 is not set
-
-#
-# AC97 GPIO expanders:
-#
-
-#
-# MODULbus GPIO expanders:
-#
-
-#
-# USB GPIO expanders:
-#
-# CONFIG_W1 is not set
-CONFIG_POWER_SUPPLY=y
-# CONFIG_POWER_SUPPLY_DEBUG is not set
-# CONFIG_PDA_POWER is not set
-# CONFIG_TEST_POWER is not set
-# CONFIG_BATTERY_DS2780 is not set
-# CONFIG_BATTERY_DS2781 is not set
-# CONFIG_BATTERY_DS2782 is not set
-# CONFIG_BATTERY_SBS is not set
-# CONFIG_BATTERY_BQ27x00 is not set
-# CONFIG_BATTERY_MAX17040 is not set
-# CONFIG_BATTERY_MAX17042 is not set
-# CONFIG_CHARGER_ISP1704 is not set
-# CONFIG_CHARGER_MAX8903 is not set
-# CONFIG_CHARGER_LP8727 is not set
-# CONFIG_CHARGER_GPIO is not set
-# CONFIG_CHARGER_MANAGER is not set
-# CONFIG_CHARGER_BQ2415X is not set
-# CONFIG_CHARGER_SMB347 is not set
-# CONFIG_BATTERY_GOLDFISH is not set
-CONFIG_POWER_RESET=y
-# CONFIG_POWER_RESET_GPIO is not set
-# CONFIG_POWER_AVS is not set
-# CONFIG_HWMON is not set
-CONFIG_THERMAL=y
-CONFIG_THERMAL_DEFAULT_GOV_BACKWARD_COMPATIBLE=y
-# CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE is not set
-# CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE is not set
-# CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE is not set
-CONFIG_BACKWARD_COMPATIBLE=y
-# CONFIG_THERMAL_GOV_FAIR_SHARE is not set
-# CONFIG_THERMAL_GOV_STEP_WISE is not set
-# CONFIG_THERMAL_GOV_USER_SPACE is not set
-# CONFIG_CPU_THERMAL is not set
-# CONFIG_THERMAL_EMULATION is not set
-# CONFIG_WATCHDOG is not set
-CONFIG_SSB_POSSIBLE=y
-
-#
-# Sonics Silicon Backplane
-#
-# CONFIG_SSB is not set
-CONFIG_BCMA_POSSIBLE=y
-
-#
-# Broadcom specific AMBA
-#
-# CONFIG_BCMA is not set
-
-#
-# Multifunction device drivers
-#
-# CONFIG_MFD_CORE is not set
-# CONFIG_MFD_AS3711 is not set
-# CONFIG_PMIC_ADP5520 is not set
-# CONFIG_MFD_AAT2870_CORE is not set
-# CONFIG_MFD_CROS_EC is not set
-# CONFIG_PMIC_DA903X is not set
-# CONFIG_MFD_DA9052_SPI is not set
-# CONFIG_MFD_DA9052_I2C is not set
-# CONFIG_MFD_DA9055 is not set
-# CONFIG_MFD_MC13XXX_SPI is not set
-# CONFIG_MFD_MC13XXX_I2C is not set
-# CONFIG_HTC_PASIC3 is not set
-# CONFIG_HTC_I2CPLD is not set
-# CONFIG_MFD_88PM800 is not set
-# CONFIG_MFD_88PM805 is not set
-# CONFIG_MFD_88PM860X is not set
-# CONFIG_MFD_MAX77686 is not set
-# CONFIG_MFD_MAX77693 is not set
-# CONFIG_MFD_MAX8907 is not set
-# CONFIG_MFD_MAX8925 is not set
-# CONFIG_MFD_MAX8997 is not set
-# CONFIG_MFD_MAX8998 is not set
-# CONFIG_EZX_PCAP is not set
-# CONFIG_MFD_VIPERBOARD is not set
-# CONFIG_MFD_RETU is not set
-# CONFIG_MFD_PCF50633 is not set
-# CONFIG_MFD_RC5T583 is not set
-# CONFIG_MFD_SEC_CORE is not set
-# CONFIG_MFD_SI476X_CORE is not set
-# CONFIG_MFD_SM501 is not set
-# CONFIG_MFD_SMSC is not set
-# CONFIG_ABX500_CORE is not set
-# CONFIG_MFD_STMPE is not set
-# CONFIG_MFD_SYSCON is not set
-# CONFIG_MFD_TI_AM335X_TSCADC is not set
-# CONFIG_MFD_LP8788 is not set
-# CONFIG_MFD_PALMAS is not set
-# CONFIG_TPS6105X is not set
-# CONFIG_TPS65010 is not set
-# CONFIG_TPS6507X is not set
-# CONFIG_MFD_TPS65090 is not set
-# CONFIG_MFD_TPS65217 is not set
-# CONFIG_MFD_TPS6586X is not set
-# CONFIG_MFD_TPS65910 is not set
-# CONFIG_MFD_TPS65912 is not set
-# CONFIG_MFD_TPS65912_I2C is not set
-# CONFIG_MFD_TPS65912_SPI is not set
-# CONFIG_MFD_TPS80031 is not set
-# CONFIG_TWL4030_CORE is not set
-# CONFIG_TWL6040_CORE is not set
-# CONFIG_MFD_WL1273_CORE is not set
-# CONFIG_MFD_LM3533 is not set
-# CONFIG_MFD_TC3589X is not set
-# CONFIG_MFD_TMIO is not set
-# CONFIG_MFD_ARIZONA_I2C is not set
-# CONFIG_MFD_ARIZONA_SPI is not set
-# CONFIG_MFD_WM8400 is not set
-# CONFIG_MFD_WM831X_I2C is not set
-# CONFIG_MFD_WM831X_SPI is not set
-# CONFIG_MFD_WM8350_I2C is not set
-# CONFIG_MFD_WM8994 is not set
-CONFIG_REGULATOR=y
-# CONFIG_REGULATOR_DEBUG is not set
-# CONFIG_REGULATOR_DUMMY is not set
-# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
-# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
-# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
-# CONFIG_REGULATOR_GPIO is not set
-# CONFIG_REGULATOR_AD5398 is not set
-# CONFIG_REGULATOR_FAN53555 is not set
-# CONFIG_REGULATOR_ISL6271A is not set
-# CONFIG_REGULATOR_MAX1586 is not set
-# CONFIG_REGULATOR_MAX8649 is not set
-# CONFIG_REGULATOR_MAX8660 is not set
-# CONFIG_REGULATOR_MAX8952 is not set
-# CONFIG_REGULATOR_MAX8973 is not set
-# CONFIG_REGULATOR_LP3971 is not set
-# CONFIG_REGULATOR_LP3972 is not set
-# CONFIG_REGULATOR_LP872X is not set
-# CONFIG_REGULATOR_LP8755 is not set
-# CONFIG_REGULATOR_TPS51632 is not set
-# CONFIG_REGULATOR_TPS62360 is not set
-# CONFIG_REGULATOR_TPS65023 is not set
-# CONFIG_REGULATOR_TPS6507X is not set
-# CONFIG_REGULATOR_TPS6524X is not set
-# CONFIG_MEDIA_SUPPORT is not set
-
-#
-# Graphics support
-#
-# CONFIG_DRM is not set
-# CONFIG_VGASTATE is not set
-# CONFIG_VIDEO_OUTPUT_CONTROL is not set
-CONFIG_FB=y
-# CONFIG_FIRMWARE_EDID is not set
-# CONFIG_FB_DDC is not set
-# CONFIG_FB_BOOT_VESA_SUPPORT is not set
-CONFIG_FB_CFB_FILLRECT=y
-CONFIG_FB_CFB_COPYAREA=y
-CONFIG_FB_CFB_IMAGEBLIT=y
-# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
-# CONFIG_FB_SYS_FILLRECT is not set
-# CONFIG_FB_SYS_COPYAREA is not set
-# CONFIG_FB_SYS_IMAGEBLIT is not set
-# CONFIG_FB_FOREIGN_ENDIAN is not set
-# CONFIG_FB_SYS_FOPS is not set
-# CONFIG_FB_SVGALIB is not set
-# CONFIG_FB_MACMODES is not set
-# CONFIG_FB_BACKLIGHT is not set
-CONFIG_FB_MODE_HELPERS=y
-CONFIG_FB_TILEBLITTING=y
-
-#
-# Frame buffer hardware drivers
-#
-# CONFIG_FB_S1D13XXX is not set
-# CONFIG_FB_SMSCUFX is not set
-# CONFIG_FB_UDL is not set
-# CONFIG_FB_GOLDFISH is not set
-# CONFIG_FB_VIRTUAL is not set
-# CONFIG_FB_METRONOME is not set
-# CONFIG_FB_BROADSHEET is not set
-# CONFIG_FB_AUO_K190X is not set
-# CONFIG_FB_SIMPLE is not set
-# CONFIG_EXYNOS_VIDEO is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
-# CONFIG_ADF is not set
-
-#
-# Console display driver support
-#
-CONFIG_FONT_8x16=y
-CONFIG_LOGO=y
-CONFIG_LOGO_LINUX_MONO=y
-CONFIG_LOGO_LINUX_VGA16=y
-CONFIG_LOGO_LINUX_CLUT224=y
-# CONFIG_FB_SSD1307 is not set
-CONFIG_SOUND=y
-CONFIG_SOUND_OSS_CORE=y
-CONFIG_SOUND_OSS_CORE_PRECLAIM=y
-CONFIG_SND=y
-CONFIG_SND_TIMER=y
-CONFIG_SND_PCM=y
-CONFIG_SND_HWDEP=y
-CONFIG_SND_RAWMIDI=y
-CONFIG_SND_COMPRESS_OFFLOAD=y
-CONFIG_SND_JACK=y
-CONFIG_SND_SEQUENCER=y
-CONFIG_SND_SEQ_DUMMY=y
-CONFIG_SND_OSSEMUL=y
-CONFIG_SND_MIXER_OSS=y
-CONFIG_SND_PCM_OSS=y
-CONFIG_SND_PCM_OSS_PLUGINS=y
-CONFIG_SND_SEQUENCER_OSS=y
-CONFIG_SND_HRTIMER=y
-CONFIG_SND_SEQ_HRTIMER_DEFAULT=y
-CONFIG_SND_DYNAMIC_MINORS=y
-CONFIG_SND_SUPPORT_OLD_API=y
-CONFIG_SND_VERBOSE_PROCFS=y
-CONFIG_SND_VERBOSE_PRINTK=y
-CONFIG_SND_DEBUG=y
-CONFIG_SND_DEBUG_VERBOSE=y
-CONFIG_SND_PCM_XRUN_DEBUG=y
-CONFIG_SND_RAWMIDI_SEQ=y
-# CONFIG_SND_OPL3_LIB_SEQ is not set
-# CONFIG_SND_OPL4_LIB_SEQ is not set
-# CONFIG_SND_SBAWE_SEQ is not set
-# CONFIG_SND_EMU10K1_SEQ is not set
-CONFIG_SND_DRIVERS=y
-# CONFIG_SND_DUMMY is not set
-# CONFIG_SND_ALOOP is not set
-# CONFIG_SND_VIRMIDI is not set
-# CONFIG_SND_MTPAV is not set
-# CONFIG_SND_SERIAL_U16550 is not set
-# CONFIG_SND_MPU401 is not set
-# CONFIG_SND_SPI is not set
-CONFIG_SND_USB=y
-CONFIG_SND_USB_AUDIO=y
-# CONFIG_SND_USB_UA101 is not set
-# CONFIG_SND_USB_CAIAQ is not set
-# CONFIG_SND_USB_6FIRE is not set
-CONFIG_SND_SOC=y
-# CONFIG_SND_ATMEL_SOC is not set
-# CONFIG_SND_DESIGNWARE_I2S is not set
-# CONFIG_MT_SND_SOC_V1 is not set
-# CONFIG_MT_SND_SOC_V2 is not set
-CONFIG_MT_SND_SOC_V3=y
-# CONFIG_MT_SND_SOC_6580 is not set
-# CONFIG_MT_SND_SOC_8163 is not set
-# CONFIG_MTK_SPEAKER is not set
-# CONFIG_MTK_NXP_TFA9890 is not set
-CONFIG_SND_SOC_I2C_AND_SPI=y
-# CONFIG_SND_SOC_ALL_CODECS is not set
-CONFIG_SND_SIMPLE_CARD=y
-CONFIG_SOUND_PRIME=y
-
-#
-# HID support
-#
-CONFIG_HID=y
-# CONFIG_HID_BATTERY_STRENGTH is not set
-CONFIG_HIDRAW=y
-CONFIG_UHID=y
-CONFIG_HID_GENERIC=y
-
-#
-# Special HID drivers
-#
-CONFIG_HID_A4TECH=y
-# CONFIG_HID_ACRUX is not set
-CONFIG_HID_APPLE=y
-# CONFIG_HID_APPLEIR is not set
-# CONFIG_HID_AUREAL is not set
-CONFIG_HID_BELKIN=y
-CONFIG_HID_CHERRY=y
-CONFIG_HID_CHICONY=y
-# CONFIG_HID_PRODIKEYS is not set
-CONFIG_HID_CYPRESS=y
-CONFIG_HID_DRAGONRISE=y
-# CONFIG_DRAGONRISE_FF is not set
-# CONFIG_HID_EMS_FF is not set
-# CONFIG_HID_ELECOM is not set
-CONFIG_HID_EZKEY=y
-# CONFIG_HID_HOLTEK is not set
-# CONFIG_HID_KEYTOUCH is not set
-CONFIG_HID_KYE=y
-# CONFIG_HID_UCLOGIC is not set
-# CONFIG_HID_WALTOP is not set
-CONFIG_HID_GYRATION=y
-# CONFIG_HID_ICADE is not set
-CONFIG_HID_TWINHAN=y
-CONFIG_HID_KENSINGTON=y
-# CONFIG_HID_LCPOWER is not set
-# CONFIG_HID_LENOVO_TPKBD is not set
-CONFIG_HID_LOGITECH=y
-# CONFIG_LOGITECH_FF is not set
-# CONFIG_LOGIRUMBLEPAD2_FF is not set
-# CONFIG_LOGIG940_FF is not set
-# CONFIG_LOGIWHEELS_FF is not set
-CONFIG_HID_MAGICMOUSE=y
-CONFIG_HID_MICROSOFT=y
-CONFIG_HID_MONTEREY=y
-# CONFIG_HID_MULTITOUCH is not set
-# CONFIG_HID_NTRIG is not set
-# CONFIG_HID_ORTEK is not set
-CONFIG_HID_PANTHERLORD=y
-# CONFIG_PANTHERLORD_FF is not set
-CONFIG_HID_PETALYNX=y
-# CONFIG_HID_PICOLCD is not set
-# CONFIG_HID_PRIMAX is not set
-# CONFIG_HID_PS3REMOTE is not set
-# CONFIG_HID_ROCCAT is not set
-# CONFIG_HID_SAITEK is not set
-CONFIG_HID_SAMSUNG=y
-# CONFIG_HID_SONY is not set
-# CONFIG_HID_SPEEDLINK is not set
-# CONFIG_HID_STEELSERIES is not set
-CONFIG_HID_SUNPLUS=y
-CONFIG_HID_GREENASIA=y
-# CONFIG_GREENASIA_FF is not set
-CONFIG_HID_SMARTJOYPLUS=y
-# CONFIG_SMARTJOYPLUS_FF is not set
-# CONFIG_HID_TIVO is not set
-CONFIG_HID_TOPSEED=y
-# CONFIG_HID_THINGM is not set
-CONFIG_HID_THRUSTMASTER=y
-# CONFIG_THRUSTMASTER_FF is not set
-# CONFIG_HID_WACOM is not set
-# CONFIG_HID_WIIMOTE is not set
-CONFIG_HID_ZEROPLUS=y
-# CONFIG_ZEROPLUS_FF is not set
-# CONFIG_HID_ZYDACRON is not set
-# CONFIG_HID_SENSOR_HUB is not set
-
-#
-# USB HID support
-#
-CONFIG_USB_HID=y
-# CONFIG_HID_PID is not set
-# CONFIG_USB_HIDDEV is not set
-
-#
-# I2C HID support
-#
-# CONFIG_I2C_HID is not set
-# CONFIG_USB_ARCH_HAS_OHCI is not set
-# CONFIG_USB_ARCH_HAS_EHCI is not set
-# CONFIG_USB_ARCH_HAS_XHCI is not set
-CONFIG_USB_SUPPORT=y
-CONFIG_USB_COMMON=y
-CONFIG_USB_ARCH_HAS_HCD=y
-CONFIG_USB=y
-# CONFIG_USB_DEBUG is not set
-# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
-
-#
-# Miscellaneous USB options
-#
-CONFIG_USB_DEFAULT_PERSIST=y
-# CONFIG_USB_DYNAMIC_MINORS is not set
-# CONFIG_USB_OTG_WHITELIST is not set
-# CONFIG_USB_OTG_BLACKLIST_HUB is not set
-# CONFIG_USB_MON is not set
-# CONFIG_USB_WUSB_CBAF is not set
-
-#
-# USB Host Controller Drivers
-#
-# CONFIG_USB_C67X00_HCD is not set
-# CONFIG_USB_OXU210HP_HCD is not set
-# CONFIG_USB_ISP116X_HCD is not set
-# CONFIG_USB_ISP1760_HCD is not set
-# CONFIG_USB_ISP1362_HCD is not set
-# CONFIG_USB_SL811_HCD is not set
-# CONFIG_USB_R8A66597_HCD is not set
-# CONFIG_USB_MUSB_HDRC is not set
-# CONFIG_USB_RENESAS_USBHS is not set
-
-#
-# USB Device Class drivers
-#
-# CONFIG_USB_ACM is not set
-# CONFIG_USB_PRINTER is not set
-# CONFIG_USB_WDM is not set
-# CONFIG_USB_TMC is not set
-
-#
-# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
-#
-
-#
-# also be needed; see USB_STORAGE Help for more info
-#
-CONFIG_USB_STORAGE=y
-# CONFIG_USB_STORAGE_DEBUG is not set
-# CONFIG_USB_STORAGE_REALTEK is not set
-CONFIG_USB_STORAGE_DATAFAB=y
-CONFIG_USB_STORAGE_FREECOM=y
-CONFIG_USB_STORAGE_ISD200=y
-CONFIG_USB_STORAGE_USBAT=y
-CONFIG_USB_STORAGE_SDDR09=y
-CONFIG_USB_STORAGE_SDDR55=y
-CONFIG_USB_STORAGE_JUMPSHOT=y
-CONFIG_USB_STORAGE_ALAUDA=y
-CONFIG_USB_STORAGE_ONETOUCH=y
-CONFIG_USB_STORAGE_KARMA=y
-CONFIG_USB_STORAGE_CYPRESS_ATACB=y
-# CONFIG_USB_STORAGE_ENE_UB6250 is not set
-
-#
-# USB Imaging devices
-#
-# CONFIG_USB_MDC800 is not set
-# CONFIG_USB_MICROTEK is not set
-# CONFIG_USB_DWC3 is not set
-# CONFIG_USB_CHIPIDEA is not set
-
-#
-# USB port drivers
-#
-# CONFIG_USB_SERIAL is not set
-
-#
-# USB Miscellaneous drivers
-#
-# CONFIG_USB_EMI62 is not set
-# CONFIG_USB_EMI26 is not set
-# CONFIG_USB_ADUTUX is not set
-# CONFIG_USB_SEVSEG is not set
-# CONFIG_USB_RIO500 is not set
-# CONFIG_USB_LEGOTOWER is not set
-# CONFIG_USB_LCD is not set
-# CONFIG_USB_LED is not set
-# CONFIG_USB_CYPRESS_CY7C63 is not set
-# CONFIG_USB_CYTHERM is not set
-# CONFIG_USB_IDMOUSE is not set
-# CONFIG_USB_FTDI_ELAN is not set
-# CONFIG_USB_APPLEDISPLAY is not set
-# CONFIG_USB_LD is not set
-CONFIG_USB_TRANCEVIBRATOR=y
-# CONFIG_USB_IOWARRIOR is not set
-# CONFIG_USB_TEST is not set
-# CONFIG_USB_ISIGHTFW is not set
-# CONFIG_USB_YUREX is not set
-# CONFIG_USB_EZUSB_FX2 is not set
-# CONFIG_USB_HSIC_USB3503 is not set
-CONFIG_USB_PHY=y
-# CONFIG_USB_OTG_WAKELOCK is not set
-CONFIG_NOP_USB_XCEIV=y
-# CONFIG_OMAP_CONTROL_USB is not set
-# CONFIG_OMAP_USB3 is not set
-# CONFIG_SAMSUNG_USBPHY is not set
-# CONFIG_SAMSUNG_USB2PHY is not set
-# CONFIG_SAMSUNG_USB3PHY is not set
-# CONFIG_USB_GPIO_VBUS is not set
-# CONFIG_USB_ISP1301 is not set
-# CONFIG_USB_RCAR_PHY is not set
-CONFIG_USB_GADGET=y
-# CONFIG_USB_GADGET_DEBUG is not set
-# CONFIG_USB_GADGET_DEBUG_FILES is not set
-# CONFIG_USB_GADGET_DEBUG_FS is not set
-CONFIG_USB_GADGET_VBUS_DRAW=500
-CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
-
-#
-# USB Peripheral Controller
-#
-# CONFIG_USB_R8A66597 is not set
-# CONFIG_USB_PXA27X is not set
-# CONFIG_USB_MV_UDC is not set
-# CONFIG_USB_MV_U3D is not set
-# CONFIG_USB_M66592 is not set
-# CONFIG_USB_NET2272 is not set
-# CONFIG_USB_DUMMY_HCD is not set
-CONFIG_USB_LIBCOMPOSITE=y
-CONFIG_USB_F_ACM=y
-CONFIG_USB_U_SERIAL=y
-CONFIG_USB_F_SERIAL=y
-# CONFIG_USB_ZERO is not set
-# CONFIG_USB_AUDIO is not set
-# CONFIG_USB_ETH is not set
-# CONFIG_USB_G_NCM is not set
-# CONFIG_USB_GADGETFS is not set
-# CONFIG_USB_FUNCTIONFS is not set
-# CONFIG_USB_MASS_STORAGE is not set
-# CONFIG_USB_G_SERIAL is not set
-# CONFIG_USB_MIDI_GADGET is not set
-# CONFIG_USB_G_PRINTER is not set
-CONFIG_USB_G_ANDROID=y
-# CONFIG_USB_ANDROID_RNDIS_DWORD_ALIGNED is not set
-# CONFIG_USB_CDC_COMPOSITE is not set
-# CONFIG_USB_G_ACM_MS is not set
-# CONFIG_USB_G_MULTI is not set
-# CONFIG_USB_G_HID is not set
-# CONFIG_USB_G_DBGP is not set
-CONFIG_MMC=y
-# CONFIG_MMC_DEBUG is not set
-CONFIG_MMC_UNSAFE_RESUME=y
-# CONFIG_MMC_CLKGATE is not set
-# CONFIG_MMC_EMBEDDED_SDIO is not set
-# CONFIG_MMC_PARANOID_SD_INIT is not set
-
-#
-# MMC/SD/SDIO Card Drivers
-#
-CONFIG_MMC_BLOCK=y
-CONFIG_MMC_BLOCK_MINORS=32
-CONFIG_MMC_BLOCK_BOUNCE=y
-# CONFIG_MMC_BLOCK_DEFERRED_RESUME is not set
-# CONFIG_SDIO_UART is not set
-# CONFIG_MMC_TEST is not set
-# CONFIG_MMC_FFU is not set
-
-#
-# MMC/SD/SDIO Host Controller Drivers
-#
-# CONFIG_MMC_ARMMMCI is not set
-# CONFIG_MMC_SDHCI is not set
-# CONFIG_MMC_SDHCI_PXAV3 is not set
-# CONFIG_MMC_SDHCI_PXAV2 is not set
-# CONFIG_MMC_SPI is not set
-# CONFIG_MMC_VUB300 is not set
-# CONFIG_MMC_USHC is not set
-# CONFIG_MEMSTICK is not set
-CONFIG_NEW_LEDS=y
-CONFIG_LEDS_CLASS=y
-
-#
-# LED drivers
-#
-# CONFIG_LEDS_LM3530 is not set
-# CONFIG_LEDS_LM3642 is not set
-# CONFIG_LEDS_PCA9532 is not set
-# CONFIG_LEDS_GPIO is not set
-# CONFIG_LEDS_LP3944 is not set
-# CONFIG_LEDS_LP5521 is not set
-# CONFIG_LEDS_LP5523 is not set
-# CONFIG_LEDS_LP5562 is not set
-# CONFIG_LEDS_PCA955X is not set
-# CONFIG_LEDS_PCA9633 is not set
-# CONFIG_LEDS_DAC124S085 is not set
-# CONFIG_LEDS_REGULATOR is not set
-# CONFIG_LEDS_BD2802 is not set
-# CONFIG_LEDS_LT3593 is not set
-# CONFIG_LEDS_RENESAS_TPU is not set
-# CONFIG_LEDS_TCA6507 is not set
-# CONFIG_LEDS_LM355x is not set
-# CONFIG_LEDS_OT200 is not set
-# CONFIG_LEDS_BLINKM is not set
-
-#
-# LED Triggers
-#
-CONFIG_LEDS_TRIGGERS=y
-CONFIG_LEDS_TRIGGER_TIMER=y
-# CONFIG_LEDS_TRIGGER_ONESHOT is not set
-# CONFIG_LEDS_TRIGGER_HEARTBEAT is not set
-# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
-# CONFIG_LEDS_TRIGGER_CPU is not set
-# CONFIG_LEDS_TRIGGER_GPIO is not set
-# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
-
-#
-# iptables trigger is under Netfilter config (LED target)
-#
-# CONFIG_LEDS_TRIGGER_TRANSIENT is not set
-# CONFIG_LEDS_TRIGGER_CAMERA is not set
-CONFIG_SWITCH=y
-# CONFIG_SWITCH_GPIO is not set
-# CONFIG_ACCESSIBILITY is not set
-CONFIG_RTC_LIB=y
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_HCTOSYS=y
-# CONFIG_RTC_SYSTOHC is not set
-CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
-# CONFIG_RTC_DEBUG is not set
-
-#
-# RTC interfaces
-#
-CONFIG_RTC_INTF_SYSFS=y
-CONFIG_RTC_INTF_PROC=y
-CONFIG_RTC_INTF_DEV=y
-# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
-# CONFIG_RTC_DRV_TEST is not set
-
-#
-# I2C RTC drivers
-#
-# CONFIG_RTC_DRV_DS1307 is not set
-# CONFIG_RTC_DRV_DS1374 is not set
-# CONFIG_RTC_DRV_DS1672 is not set
-# CONFIG_RTC_DRV_DS3232 is not set
-# CONFIG_RTC_DRV_MAX6900 is not set
-# CONFIG_RTC_DRV_RS5C372 is not set
-# CONFIG_RTC_DRV_ISL1208 is not set
-# CONFIG_RTC_DRV_ISL12022 is not set
-# CONFIG_RTC_DRV_X1205 is not set
-# CONFIG_RTC_DRV_PCF8523 is not set
-# CONFIG_RTC_DRV_PCF8563 is not set
-# CONFIG_RTC_DRV_PCF8583 is not set
-# CONFIG_RTC_DRV_M41T80 is not set
-# CONFIG_RTC_DRV_BQ32K is not set
-# CONFIG_RTC_DRV_S35390A is not set
-# CONFIG_RTC_DRV_FM3130 is not set
-# CONFIG_RTC_DRV_RX8581 is not set
-# CONFIG_RTC_DRV_RX8025 is not set
-# CONFIG_RTC_DRV_EM3027 is not set
-# CONFIG_RTC_DRV_RV3029C2 is not set
-
-#
-# SPI RTC drivers
-#
-# CONFIG_RTC_DRV_M41T93 is not set
-# CONFIG_RTC_DRV_M41T94 is not set
-# CONFIG_RTC_DRV_DS1305 is not set
-# CONFIG_RTC_DRV_DS1390 is not set
-# CONFIG_RTC_DRV_MAX6902 is not set
-# CONFIG_RTC_DRV_R9701 is not set
-# CONFIG_RTC_DRV_RS5C348 is not set
-# CONFIG_RTC_DRV_DS3234 is not set
-# CONFIG_RTC_DRV_PCF2123 is not set
-# CONFIG_RTC_DRV_RX4581 is not set
-
-#
-# Platform RTC drivers
-#
-# CONFIG_RTC_DRV_DS1286 is not set
-# CONFIG_RTC_DRV_DS1511 is not set
-# CONFIG_RTC_DRV_DS1553 is not set
-# CONFIG_RTC_DRV_DS1742 is not set
-# CONFIG_RTC_DRV_STK17TA8 is not set
-# CONFIG_RTC_DRV_M48T86 is not set
-# CONFIG_RTC_DRV_M48T35 is not set
-# CONFIG_RTC_DRV_M48T59 is not set
-# CONFIG_RTC_DRV_MSM6242 is not set
-# CONFIG_RTC_DRV_BQ4802 is not set
-# CONFIG_RTC_DRV_RP5C01 is not set
-# CONFIG_RTC_DRV_V3020 is not set
-# CONFIG_RTC_DRV_DS2404 is not set
-
-#
-# on-CPU RTC drivers
-#
-# CONFIG_RTC_DRV_PL030 is not set
-# CONFIG_RTC_DRV_PL031 is not set
-# CONFIG_RTC_DRV_SNVS is not set
-
-#
-# HID Sensor RTC drivers
-#
-# CONFIG_RTC_DRV_HID_SENSOR_TIME is not set
-# CONFIG_DMADEVICES is not set
-# CONFIG_AUXDISPLAY is not set
-# CONFIG_UIO is not set
-# CONFIG_VIRT_DRIVERS is not set
-
-#
-# Virtio drivers
-#
-# CONFIG_VIRTIO_MMIO is not set
-
-#
-# Microsoft Hyper-V guest support
-#
-CONFIG_STAGING=y
-# CONFIG_USBIP_CORE is not set
-# CONFIG_PRISM2_USB is not set
-# CONFIG_ECHO is not set
-# CONFIG_ASUS_OLED is not set
-# CONFIG_R8712U is not set
-# CONFIG_RTS5139 is not set
-# CONFIG_TRANZPORT is not set
-# CONFIG_LINE6_USB is not set
-CONFIG_ZSMALLOC=y
-CONFIG_ZRAM=y
-CONFIG_ZRAM_DEBUG=y
-# CONFIG_ZSM is not set
-# CONFIG_BCM_WIMAX is not set
-# CONFIG_FT1000 is not set
-
-#
-# Speakup console speech
-#
-# CONFIG_TOUCHSCREEN_CLEARPAD_TM1217 is not set
-# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4 is not set
-# CONFIG_STAGING_MEDIA is not set
-
-#
-# Android
-#
-CONFIG_ANDROID=y
-CONFIG_ASHMEM=y
-CONFIG_ANDROID_LOGGER=y
-CONFIG_ANDROID_TIMED_OUTPUT=y
-# CONFIG_ANDROID_TIMED_GPIO is not set
-CONFIG_ANDROID_LOW_MEMORY_KILLER=y
-CONFIG_ANDROID_LOW_MEMORY_KILLER_AUTODETECT_OOM_ADJ_VALUES=y
-CONFIG_ANDROID_INTF_ALARM_DEV=y
-CONFIG_SYNC=y
-CONFIG_SW_SYNC=y
-CONFIG_SW_SYNC_USER=y
-# CONFIG_MTK_GMO_RAM_OPTIMIZE is not set
-CONFIG_ION=y
-# CONFIG_ION_TEST is not set
-# CONFIG_FIQ_DEBUGGER is not set
-# CONFIG_FIQ_WATCHDOG is not set
-# CONFIG_USB_WPAN_HCD is not set
-# CONFIG_WIMAX_GDM72XX is not set
-# CONFIG_CSR_WIFI is not set
-# CONFIG_CED1401 is not set
-# CONFIG_DGRP is not set
-CONFIG_CLKDEV_LOOKUP=y
-CONFIG_HAVE_CLK_PREPARE=y
-CONFIG_COMMON_CLK=y
-
-#
-# Common Clock Framework
-#
-# CONFIG_COMMON_CLK_DEBUG is not set
-# CONFIG_COMMON_CLK_SI5351 is not set
-
-#
-# Hardware Spinlock drivers
-#
-CONFIG_CLKSRC_OF=y
-CONFIG_ARM_ARCH_TIMER=y
-# CONFIG_MAILBOX is not set
-CONFIG_IOMMU_SUPPORT=y
-CONFIG_OF_IOMMU=y
-
-#
-# Remoteproc drivers
-#
-# CONFIG_STE_MODEM_RPROC is not set
-
-#
-# Rpmsg drivers
-#
-# CONFIG_PM_DEVFREQ is not set
-# CONFIG_EXTCON is not set
-# CONFIG_MEMORY is not set
-# CONFIG_IIO is not set
-# CONFIG_PWM is not set
-CONFIG_IRQCHIP=y
-CONFIG_ARM_GIC=y
-CONFIG_MTK_GIC=y
-CONFIG_MTK_EIC=y
-# CONFIG_IPACK_BUS is not set
-# CONFIG_RESET_CONTROLLER is not set
-
-#
-# Android
-#
-CONFIG_ANDROID_BINDER_IPC=y
-
-#
-# File systems
-#
-# CONFIG_EXT2_FS is not set
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
-CONFIG_EXT3_FS_XATTR=y
-CONFIG_EXT3_FS_POSIX_ACL=y
-# CONFIG_EXT3_FS_SECURITY is not set
-CONFIG_EXT4_FS=y
-CONFIG_EXT4_USE_FOR_EXT23=y
-# CONFIG_EXT4_FS_POSIX_ACL is not set
-CONFIG_EXT4_FS_SECURITY=y
-CONFIG_EXT4_DEBUG=y
-CONFIG_JBD=y
-# CONFIG_JBD_DEBUG is not set
-CONFIG_JBD2=y
-# CONFIG_JBD2_DEBUG is not set
-CONFIG_FS_MBCACHE=y
-# CONFIG_REISERFS_FS is not set
-# CONFIG_JFS_FS is not set
-# CONFIG_XFS_FS is not set
-# CONFIG_GFS2_FS is not set
-# CONFIG_OCFS2_FS is not set
-# CONFIG_BTRFS_FS is not set
-# CONFIG_NILFS2_FS is not set
-CONFIG_FS_POSIX_ACL=y
-CONFIG_FILE_LOCKING=y
-CONFIG_FSNOTIFY=y
-CONFIG_DNOTIFY=y
-CONFIG_INOTIFY_USER=y
-# CONFIG_FANOTIFY is not set
-CONFIG_QUOTA=y
-# CONFIG_QUOTA_NETLINK_INTERFACE is not set
-CONFIG_PRINT_QUOTA_WARNING=y
-# CONFIG_QUOTA_DEBUG is not set
-CONFIG_QUOTA_TREE=y
-# CONFIG_QFMT_V1 is not set
-CONFIG_QFMT_V2=y
-CONFIG_QUOTACTL=y
-# CONFIG_AUTOFS4_FS is not set
-CONFIG_FUSE_FS=y
-# CONFIG_CUSE is not set
-
-#
-# Caches
-#
-# CONFIG_FSCACHE is not set
-
-#
-# CD-ROM/DVD Filesystems
-#
-CONFIG_ISO9660_FS=y
-CONFIG_JOLIET=y
-CONFIG_ZISOFS=y
-# CONFIG_UDF_FS is not set
-
-#
-# DOS/FAT/NT Filesystems
-#
-CONFIG_FAT_FS=y
-CONFIG_MSDOS_FS=y
-CONFIG_VFAT_FS=y
-CONFIG_FAT_DEFAULT_CODEPAGE=437
-CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
-# CONFIG_NTFS_FS is not set
-
-#
-# Pseudo filesystems
-#
-CONFIG_PROC_FS=y
-# CONFIG_PROC_KCORE is not set
-CONFIG_PROC_SYSCTL=y
-CONFIG_PROC_PAGE_MONITOR=y
-CONFIG_SYSFS=y
-CONFIG_TMPFS=y
-# CONFIG_TMPFS_POSIX_ACL is not set
-# CONFIG_TMPFS_XATTR is not set
-# CONFIG_HUGETLB_PAGE is not set
-CONFIG_CONFIGFS_FS=y
-CONFIG_MISC_FILESYSTEMS=y
-# CONFIG_ADFS_FS is not set
-# CONFIG_AFFS_FS is not set
-# CONFIG_HFS_FS is not set
-# CONFIG_HFSPLUS_FS is not set
-# CONFIG_BEFS_FS is not set
-# CONFIG_BFS_FS is not set
-# CONFIG_EFS_FS is not set
-# CONFIG_JFFS2_FS is not set
-# CONFIG_LOGFS is not set
-# CONFIG_CRAMFS is not set
-# CONFIG_SQUASHFS is not set
-# CONFIG_VXFS_FS is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_OMFS_FS is not set
-# CONFIG_HPFS_FS is not set
-# CONFIG_QNX4FS_FS is not set
-# CONFIG_QNX6FS_FS is not set
-# CONFIG_ROMFS_FS is not set
-# CONFIG_PSTORE is not set
-# CONFIG_SYSV_FS is not set
-# CONFIG_UFS_FS is not set
-# CONFIG_F2FS_FS is not set
-# CONFIG_NETWORK_FILESYSTEMS is not set
-CONFIG_NLS=y
-CONFIG_NLS_DEFAULT="iso8859-1"
-CONFIG_NLS_CODEPAGE_437=y
-# CONFIG_NLS_CODEPAGE_737 is not set
-# CONFIG_NLS_CODEPAGE_775 is not set
-# CONFIG_NLS_CODEPAGE_850 is not set
-# CONFIG_NLS_CODEPAGE_852 is not set
-# CONFIG_NLS_CODEPAGE_855 is not set
-# CONFIG_NLS_CODEPAGE_857 is not set
-# CONFIG_NLS_CODEPAGE_860 is not set
-# CONFIG_NLS_CODEPAGE_861 is not set
-# CONFIG_NLS_CODEPAGE_862 is not set
-# CONFIG_NLS_CODEPAGE_863 is not set
-# CONFIG_NLS_CODEPAGE_864 is not set
-# CONFIG_NLS_CODEPAGE_865 is not set
-# CONFIG_NLS_CODEPAGE_866 is not set
-# CONFIG_NLS_CODEPAGE_869 is not set
-# CONFIG_NLS_CODEPAGE_936 is not set
-CONFIG_NLS_CODEPAGE_950=y
-# CONFIG_NLS_CODEPAGE_932 is not set
-# CONFIG_NLS_CODEPAGE_949 is not set
-# CONFIG_NLS_CODEPAGE_874 is not set
-# CONFIG_NLS_ISO8859_8 is not set
-# CONFIG_NLS_CODEPAGE_1250 is not set
-# CONFIG_NLS_CODEPAGE_1251 is not set
-CONFIG_NLS_ASCII=y
-CONFIG_NLS_ISO8859_1=y
-# CONFIG_NLS_ISO8859_2 is not set
-# CONFIG_NLS_ISO8859_3 is not set
-# CONFIG_NLS_ISO8859_4 is not set
-# CONFIG_NLS_ISO8859_5 is not set
-# CONFIG_NLS_ISO8859_6 is not set
-# CONFIG_NLS_ISO8859_7 is not set
-# CONFIG_NLS_ISO8859_9 is not set
-# CONFIG_NLS_ISO8859_13 is not set
-# CONFIG_NLS_ISO8859_14 is not set
-# CONFIG_NLS_ISO8859_15 is not set
-# CONFIG_NLS_KOI8_R is not set
-# CONFIG_NLS_KOI8_U is not set
-# CONFIG_NLS_MAC_ROMAN is not set
-# CONFIG_NLS_MAC_CELTIC is not set
-# CONFIG_NLS_MAC_CENTEURO is not set
-# CONFIG_NLS_MAC_CROATIAN is not set
-# CONFIG_NLS_MAC_CYRILLIC is not set
-# CONFIG_NLS_MAC_GAELIC is not set
-# CONFIG_NLS_MAC_GREEK is not set
-# CONFIG_NLS_MAC_ICELAND is not set
-# CONFIG_NLS_MAC_INUIT is not set
-# CONFIG_NLS_MAC_ROMANIAN is not set
-# CONFIG_NLS_MAC_TURKISH is not set
-CONFIG_NLS_UTF8=y
-# CONFIG_DLM is not set
-# CONFIG_RAWFS_FS is not set
-
-#
-# Kernel hacking
-#
-CONFIG_PRINTK_TIME=y
-CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
-CONFIG_ENABLE_WARN_DEPRECATED=y
-CONFIG_ENABLE_MUST_CHECK=y
-CONFIG_FRAME_WARN=1400
-CONFIG_MAGIC_SYSRQ=y
-# CONFIG_STRIP_ASM_SYMS is not set
-# CONFIG_READABLE_ASM is not set
-# CONFIG_UNUSED_SYMBOLS is not set
-CONFIG_DEBUG_FS=y
-# CONFIG_HEADERS_CHECK is not set
-# CONFIG_DEBUG_SECTION_MISMATCH is not set
-CONFIG_DEBUG_KERNEL=y
-# CONFIG_DEBUG_SHIRQ is not set
-# CONFIG_LOCKUP_DETECTOR is not set
-CONFIG_PANIC_ON_OOPS=y
-CONFIG_PANIC_ON_OOPS_VALUE=1
-# CONFIG_DETECT_HUNG_TASK is not set
-CONFIG_SCHED_DEBUG=y
-CONFIG_SCHEDSTATS=y
-# CONFIG_TIMER_STATS is not set
-# CONFIG_DEBUG_OBJECTS is not set
-# CONFIG_SLUB_STATS is not set
-CONFIG_HAVE_DEBUG_KMEMLEAK=y
-# CONFIG_DEBUG_KMEMLEAK is not set
-CONFIG_DEBUG_PREEMPT=y
-# CONFIG_DEBUG_RT_MUTEXES is not set
-# CONFIG_RT_MUTEX_TESTER is not set
-# CONFIG_DEBUG_SPINLOCK is not set
-# CONFIG_DEBUG_MUTEXES is not set
-# CONFIG_DEBUG_LOCK_ALLOC is not set
-# CONFIG_PROVE_LOCKING is not set
-# CONFIG_LOCK_STAT is not set
-# CONFIG_DEBUG_ATOMIC_SLEEP is not set
-# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
-CONFIG_STACKTRACE=y
-# CONFIG_DEBUG_STACK_USAGE is not set
-# CONFIG_DEBUG_KOBJECT is not set
-CONFIG_HAVE_DEBUG_BUGVERBOSE=y
-# CONFIG_DEBUG_BUGVERBOSE is not set
-CONFIG_DEBUG_INFO=y
-# CONFIG_DEBUG_INFO_REDUCED is not set
-# CONFIG_DEBUG_VM is not set
-# CONFIG_DEBUG_WRITECOUNT is not set
-# CONFIG_DEBUG_MEMORY_INIT is not set
-# CONFIG_DEBUG_LIST is not set
-# CONFIG_TEST_LIST_SORT is not set
-# CONFIG_DEBUG_SG is not set
-# CONFIG_DEBUG_NOTIFIERS is not set
-# CONFIG_DEBUG_CREDENTIALS is not set
-CONFIG_ARCH_WANT_FRAME_POINTERS=y
-CONFIG_FRAME_POINTER=y
-# CONFIG_BOOT_PRINTK_DELAY is not set
-
-#
-# RCU Debugging
-#
-# CONFIG_PROVE_RCU_DELAY is not set
-# CONFIG_SPARSE_RCU_POINTER is not set
-# CONFIG_RCU_TORTURE_TEST is not set
-CONFIG_RCU_CPU_STALL_TIMEOUT=60
-CONFIG_RCU_CPU_STALL_VERBOSE=y
-# CONFIG_RCU_CPU_STALL_INFO is not set
-# CONFIG_RCU_TRACE is not set
-# CONFIG_BACKTRACE_SELF_TEST is not set
-# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
-# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
-# CONFIG_DEBUG_PER_CPU_MAPS is not set
-# CONFIG_LKDTM is not set
-# CONFIG_NOTIFIER_ERROR_INJECTION is not set
-CONFIG_FAULT_INJECTION=y
-# CONFIG_FAILSLAB is not set
-# CONFIG_FAIL_PAGE_ALLOC is not set
-# CONFIG_FAIL_MAKE_REQUEST is not set
-# CONFIG_FAIL_IO_TIMEOUT is not set
-# CONFIG_FAIL_MMC_REQUEST is not set
-# CONFIG_FAULT_INJECTION_DEBUG_FS is not set
-CONFIG_NOP_TRACER=y
-CONFIG_HAVE_FUNCTION_TRACER=y
-CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
-CONFIG_HAVE_DYNAMIC_FTRACE=y
-CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
-CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
-CONFIG_HAVE_C_RECORDMCOUNT=y
-CONFIG_TRACE_CLOCK=y
-CONFIG_RING_BUFFER=y
-CONFIG_EVENT_TRACING=y
-CONFIG_CONTEXT_SWITCH_TRACER=y
-CONFIG_TRACING=y
-CONFIG_TRACING_SUPPORT=y
-CONFIG_FTRACE=y
-# CONFIG_FUNCTION_TRACER is not set
-# CONFIG_IRQSOFF_TRACER is not set
-# CONFIG_PREEMPT_TRACER is not set
-# CONFIG_SCHED_TRACER is not set
-CONFIG_ENABLE_DEFAULT_TRACERS=y
-# CONFIG_FTRACE_SYSCALLS is not set
-# CONFIG_TRACER_SNAPSHOT is not set
-CONFIG_BRANCH_PROFILE_NONE=y
-# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
-# CONFIG_PROFILE_ALL_BRANCHES is not set
-# CONFIG_STACK_TRACER is not set
-# CONFIG_BLK_DEV_IO_TRACE is not set
-# CONFIG_PROBE_EVENTS is not set
-# CONFIG_RING_BUFFER_BENCHMARK is not set
-# CONFIG_RING_BUFFER_STARTUP_TEST is not set
-CONFIG_DYNAMIC_DEBUG=y
-# CONFIG_DMA_API_DEBUG is not set
-# CONFIG_ATOMIC64_SELFTEST is not set
-# CONFIG_SAMPLES is not set
-CONFIG_HAVE_ARCH_KGDB=y
-# CONFIG_KGDB is not set
-# CONFIG_TEST_STRING_HELPERS is not set
-# CONFIG_TEST_KSTRTOX is not set
-CONFIG_EARLY_PRINTK=y
-# CONFIG_PID_IN_CONTEXTIDR is not set
-
-#
-# Security options
-#
-# CONFIG_KEYS is not set
-# CONFIG_SECURITY_DMESG_RESTRICT is not set
-CONFIG_SECURITY=y
-# CONFIG_SECURITYFS is not set
-CONFIG_SECURITY_NETWORK=y
-# CONFIG_SECURITY_NETWORK_XFRM is not set
-# CONFIG_SECURITY_PATH is not set
-CONFIG_LSM_MMAP_MIN_ADDR=32768
-CONFIG_SECURITY_SELINUX=y
-CONFIG_SECURITY_SELINUX_BOOTPARAM=y
-CONFIG_SECURITY_SELINUX_BOOTPARAM_VALUE=1
-# CONFIG_SECURITY_SELINUX_DISABLE is not set
-CONFIG_SECURITY_SELINUX_DEVELOP=y
-CONFIG_SECURITY_SELINUX_AVC_STATS=y
-CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE=1
-# CONFIG_SECURITY_SELINUX_POLICYDB_VERSION_MAX is not set
-# CONFIG_SECURITY_SMACK is not set
-# CONFIG_SECURITY_TOMOYO is not set
-# CONFIG_SECURITY_APPARMOR is not set
-# CONFIG_SECURITY_YAMA is not set
-# CONFIG_IMA is not set
-CONFIG_DEFAULT_SECURITY_SELINUX=y
-# CONFIG_DEFAULT_SECURITY_DAC is not set
-CONFIG_DEFAULT_SECURITY="selinux"
-CONFIG_CRYPTO=y
-
-#
-# Crypto core or helper
-#
-CONFIG_CRYPTO_ALGAPI=y
-CONFIG_CRYPTO_ALGAPI2=y
-CONFIG_CRYPTO_AEAD=y
-CONFIG_CRYPTO_AEAD2=y
-CONFIG_CRYPTO_BLKCIPHER=y
-CONFIG_CRYPTO_BLKCIPHER2=y
-CONFIG_CRYPTO_HASH=y
-CONFIG_CRYPTO_HASH2=y
-CONFIG_CRYPTO_RNG2=y
-CONFIG_CRYPTO_PCOMP2=y
-CONFIG_CRYPTO_MANAGER=y
-CONFIG_CRYPTO_MANAGER2=y
-# CONFIG_CRYPTO_USER is not set
-CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
-# CONFIG_CRYPTO_GF128MUL is not set
-# CONFIG_CRYPTO_NULL is not set
-# CONFIG_CRYPTO_PCRYPT is not set
-CONFIG_CRYPTO_WORKQUEUE=y
-CONFIG_CRYPTO_CRYPTD=y
-CONFIG_CRYPTO_AUTHENC=y
-CONFIG_CRYPTO_ABLK_HELPER=y
-
-#
-# Authenticated Encryption with Associated Data
-#
-# CONFIG_CRYPTO_CCM is not set
-# CONFIG_CRYPTO_GCM is not set
-# CONFIG_CRYPTO_SEQIV is not set
-
-#
-# Block modes
-#
-CONFIG_CRYPTO_CBC=y
-# CONFIG_CRYPTO_CTR is not set
-# CONFIG_CRYPTO_CTS is not set
-CONFIG_CRYPTO_ECB=y
-# CONFIG_CRYPTO_LRW is not set
-# CONFIG_CRYPTO_PCBC is not set
-# CONFIG_CRYPTO_XTS is not set
-
-#
-# Hash modes
-#
-# CONFIG_CRYPTO_CMAC is not set
-CONFIG_CRYPTO_HMAC=y
-# CONFIG_CRYPTO_XCBC is not set
-# CONFIG_CRYPTO_VMAC is not set
-
-#
-# Digest
-#
-CONFIG_CRYPTO_CRC32C=y
-# CONFIG_CRYPTO_CRC32 is not set
-# CONFIG_CRYPTO_GHASH is not set
-# CONFIG_CRYPTO_MD4 is not set
-CONFIG_CRYPTO_MD5=y
-# CONFIG_CRYPTO_MICHAEL_MIC is not set
-# CONFIG_CRYPTO_RMD128 is not set
-# CONFIG_CRYPTO_RMD160 is not set
-# CONFIG_CRYPTO_RMD256 is not set
-# CONFIG_CRYPTO_RMD320 is not set
-CONFIG_CRYPTO_SHA1=y
-CONFIG_CRYPTO_SHA256=y
-# CONFIG_CRYPTO_SHA512 is not set
-# CONFIG_CRYPTO_TGR192 is not set
-# CONFIG_CRYPTO_WP512 is not set
-
-#
-# Ciphers
-#
-CONFIG_CRYPTO_AES=y
-# CONFIG_CRYPTO_AES_ARM32_CE is not set
-# CONFIG_CRYPTO_ANUBIS is not set
-CONFIG_CRYPTO_ARC4=y
-# CONFIG_CRYPTO_BLOWFISH is not set
-# CONFIG_CRYPTO_CAMELLIA is not set
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
-CONFIG_CRYPTO_DES=y
-# CONFIG_CRYPTO_FCRYPT is not set
-# CONFIG_CRYPTO_KHAZAD is not set
-# CONFIG_CRYPTO_SALSA20 is not set
-# CONFIG_CRYPTO_SEED is not set
-# CONFIG_CRYPTO_SERPENT is not set
-# CONFIG_CRYPTO_TEA is not set
-CONFIG_CRYPTO_TWOFISH=y
-CONFIG_CRYPTO_TWOFISH_COMMON=y
-
-#
-# Compression
-#
-CONFIG_CRYPTO_DEFLATE=y
-# CONFIG_CRYPTO_ZLIB is not set
-CONFIG_CRYPTO_LZO=y
-# CONFIG_CRYPTO_LZ4K is not set
-
-#
-# Random Number Generation
-#
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-# CONFIG_CRYPTO_USER_API_HASH is not set
-# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
-# CONFIG_CRYPTO_HW is not set
-CONFIG_ARM64_CRYPTO=y
-# CONFIG_CRYPTO_SHA1_ARM64_CE is not set
-CONFIG_CRYPTO_SHA2_ARM64_CE=y
-# CONFIG_CRYPTO_GHASH_ARM64_CE is not set
-CONFIG_CRYPTO_AES_ARM64_CE=y
-# CONFIG_CRYPTO_AES_ARM64_CE_CCM is not set
-CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
-# CONFIG_CRYPTO_AES_ARM64_NEON_BLK is not set
-CONFIG_BINARY_PRINTF=y
-
-#
-# Library routines
-#
-CONFIG_BITREVERSE=y
-CONFIG_GENERIC_PCI_IOMAP=y
-CONFIG_GENERIC_IOMAP=y
-CONFIG_GENERIC_IO=y
-CONFIG_CRC_CCITT=y
-CONFIG_CRC16=y
-# CONFIG_CRC_T10DIF is not set
-# CONFIG_CRC_ITU_T is not set
-CONFIG_CRC32=y
-# CONFIG_CRC32_SELFTEST is not set
-CONFIG_CRC32_SLICEBY8=y
-# CONFIG_CRC32_SLICEBY4 is not set
-# CONFIG_CRC32_SARWATE is not set
-# CONFIG_CRC32_BIT is not set
-# CONFIG_CRC7 is not set
-CONFIG_LIBCRC32C=y
-# CONFIG_CRC8 is not set
-CONFIG_AUDIT_GENERIC=y
-CONFIG_ZLIB_INFLATE=y
-CONFIG_ZLIB_DEFLATE=y
-CONFIG_LZO_COMPRESS=y
-CONFIG_LZO_DECOMPRESS=y
-# CONFIG_LZ4K is not set
-# CONFIG_XZ_DEC is not set
-# CONFIG_XZ_DEC_BCJ is not set
-CONFIG_DECOMPRESS_GZIP=y
-CONFIG_GENERIC_ALLOCATOR=y
-CONFIG_TEXTSEARCH=y
-CONFIG_TEXTSEARCH_KMP=y
-CONFIG_TEXTSEARCH_BM=y
-CONFIG_TEXTSEARCH_FSM=y
-CONFIG_HAS_IOMEM=y
-CONFIG_HAS_DMA=y
-CONFIG_CPU_RMAP=y
-CONFIG_DQL=y
-CONFIG_NLATTR=y
-CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
-# CONFIG_AVERAGE is not set
-# CONFIG_CORDIC is not set
-# CONFIG_DDR is not set
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index f46ba53..e97759c 100755
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -70,6 +70,10 @@ config TOUCHSCREEN_MTK_FT6206_X2605
 	bool "FT6206_X2605 for Mediatek package"
 	depends on TOUCHSCREEN_MTK
 
+config TOUCHSCREEN_MTK_FT_ALLINONE_GESTURE
+	bool "FT_ALLINONE_GESTURE for Mediatek package"
+	depends on TOUCHSCREEN_MTK
+
 config TOUCHSCREEN_AD7879_I2C
 	tristate "support I2C bus connection"
 	depends on TOUCHSCREEN_AD7879 && I2C
diff --git a/drivers/input/touchscreen/mediatek/GT915_HD/gt9xx_driver.c~ b/drivers/input/touchscreen/mediatek/GT915_HD/gt9xx_driver.c~
deleted file mode 100755
index 84eac62..0000000
--- a/drivers/input/touchscreen/mediatek/GT915_HD/gt9xx_driver.c~
+++ /dev/null
@@ -1,3281 +0,0 @@
-/* Copyright Statement:
- *
- * This software/firmware and related documentation ("MediaTek Software") are
- * protected under relevant copyright laws. The information contained herein
- * is confidential and proprietary to MediaTek Inc. and/or its licensors.
- * Without the prior written permission of MediaTek inc. and/or its licensors,
- * any reproduction, modification, use or disclosure of MediaTek Software,
- * and information contained herein, in whole or in part, shall be strictly prohibited.
- *  
- * MediaTek Inc. (C) 2012. All rights reserved. 
- * 
- * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
- * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
- * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
- * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
- * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
- * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
- * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
- * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
- * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
- * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
- * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
- * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
- * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
- * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
- * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
- * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
- *
- * The following software/firmware and/or related documentation ("MediaTek Software")
- * have been modified by MediaTek Inc. All revisions are subject to any receiver's
- * applicable license agreements with MediaTek Inc.
- */
- 
-/*
- * Version: V2.0
- * Release Date: 2013/08/28
- * Contact: andrew@goodix.com, meta@goodix.com
- * Revision Record:
- *      V1.4:
- *          1. New Heartbeat/ESD-protect Mechanism(external watchdog)
- *          2. doze mode, sliding wakeup
- *          3. config length verification & 3 more config groups(GT9 Sensor_ID: 0 ~ 5)
- *          4. charger status switch
- *                  By Meta, 2013/03/11
- *      V1.6:
- *          1. pen/stylus support 
- *          2. slide wakeup, new esd optimization
- *                  By Meta, 2013/04/18
- *      V1.8:
- *          1. read double check & fixed config support
- *          2. other optimizations
- *                  By Meta, 2013/06/08
- *      V2.0:
- *          1. compatible with GT9XXF
- *          2. I2C DMA support
- *                  By Meta, 2013/08/28
- *      V2.2:
- *          1. update gt9xx_config to compatible with Linux 3.10
- *          2. gesture wakeup
- *          3. pen separate input device, active-pen button support
- *          4. coordinates & keys optimization
- *          5. no longer support GT915S
- *                  By Meta, 2014/01/14
- */
-
-#include "tpd.h"
-#include "tpd_custom_gt9xx.h"
-
-#ifndef TPD_NO_GPIO
-#include "cust_gpio_usage.h" 
-#endif
-#ifdef TPD_PROXIMITY
-#include <linux/hwmsensor.h>
-#include <linux/hwmsen_dev.h>
-#include <linux/sensors_io.h>
-#endif
-
-#if GTP_SUPPORT_I2C_DMA
-    #include <linux/dma-mapping.h>
-#endif
-//fix kernel 3.10, copy KK1.MP1
-#ifdef I2C_PUSHPULL_FLAG
-#undef I2C_PUSHPULL_FLAG
-#define I2C_PUSHPULL_FLAG	(0x0100)
-#endif
-
-extern struct tpd_device *tpd;
-
-static int tpd_flag = 0; 
-int tpd_halt = 0;
-static struct task_struct *thread = NULL;
-static DECLARE_WAIT_QUEUE_HEAD(waiter);
-
-#ifdef TPD_HAVE_BUTTON
-static int tpd_keys_local[TPD_KEY_COUNT] = TPD_KEYS;
-static int tpd_keys_dim_local[TPD_KEY_COUNT][4] = TPD_KEYS_DIM;
-#endif
-
-#if GTP_GESTURE_WAKEUP
-typedef enum
-{
-    DOZE_DISABLED = 0,
-    DOZE_ENABLED = 1,
-    DOZE_WAKEUP = 2,
-}DOZE_T;
-static DOZE_T doze_status = DOZE_DISABLED;
-static s8 gtp_enter_doze(struct i2c_client *client);
-#endif
-
-#if GTP_CHARGER_SWITCH
-    #ifdef MT6573
-        #define CHR_CON0      (0xF7000000+0x2FA00)
-    #else
-        extern kal_bool upmu_is_chr_det(void);
-    #endif
-    static void gtp_charger_switch(s32 dir_update);
-#endif 
-
-#if GTP_HAVE_TOUCH_KEY
-const u16 touch_key_array[] = GTP_KEY_TAB;
-#define GTP_MAX_KEY_NUM ( sizeof( touch_key_array )/sizeof( touch_key_array[0] ) )
-#endif
-
-#if (defined(TPD_WARP_START) && defined(TPD_WARP_END))
-static int tpd_wb_start_local[TPD_WARP_CNT] = TPD_WARP_START;
-static int tpd_wb_end_local[TPD_WARP_CNT]   = TPD_WARP_END;
-#endif
-
-#if (defined(TPD_HAVE_CALIBRATION) && !defined(TPD_CUSTOM_CALIBRATION))
-//static int tpd_calmat_local[8]     = TPD_CALIBRATION_MATRIX;
-static int tpd_def_calmat_local[8] = TPD_CALIBRATION_MATRIX;
-#endif
-
-#if GTP_SUPPORT_I2C_DMA
-s32 i2c_dma_write(struct i2c_client *client, u16 addr, u8 *txbuf, s32 len);
-s32 i2c_dma_read(struct i2c_client *client, u16 addr, u8 *rxbuf, s32 len);
-
-static u8 *gpDMABuf_va = NULL;
-static u32 gpDMABuf_pa = 0;
-#endif
-
-s32 gtp_send_cfg(struct i2c_client *client);
-void gtp_reset_guitar(struct i2c_client *client, s32 ms);
-static void tpd_eint_interrupt_handler(void);
-static int touch_event_handler(void *unused);
-static int tpd_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id);
-static int tpd_i2c_detect(struct i2c_client *client, struct i2c_board_info *info);
-static int tpd_i2c_remove(struct i2c_client *client);
-s32 gtp_i2c_read_dbl_check(struct i2c_client *client, u16 addr, u8 *rxbuf, int len);
-extern void mt65xx_eint_unmask(unsigned int line);
-extern void mt65xx_eint_mask(unsigned int line);
-
-#ifndef MT6572
-extern void mt65xx_eint_set_hw_debounce(kal_uint8 eintno, kal_uint32 ms);
-extern kal_uint32 mt65xx_eint_set_sens(kal_uint8 eintno, kal_bool sens);
-extern void mt65xx_eint_registration(kal_uint8 eintno, kal_bool Dbounce_En,
-                                     kal_bool ACT_Polarity, void (EINT_FUNC_PTR)(void),
-                                     kal_bool auto_umask);
-#endif
-
-
-//add clj 20150203
-extern void mt_eint_mask(unsigned int eint_num);
-extern void mt_eint_unmask(unsigned int eint_num);
-extern void mt_eint_set_hw_debounce(unsigned int eint_num, unsigned int ms);
-extern void mt_eint_set_polarity(unsigned int eint_num, unsigned int pol);
-extern unsigned int mt_eint_set_sens(unsigned int eint_num, unsigned int sens);
-extern void mt_eint_registration(unsigned int eint_num, unsigned int flow, void (EINT_FUNC_PTR)(void), unsigned int is_auto_umask);
-extern void mt_eint_print_status(void);
-//end add 
-
-
-#if GTP_CREATE_WR_NODE
-extern s32 init_wr_node(struct i2c_client *);
-extern void uninit_wr_node(void);
-#endif
-
-#if (GTP_ESD_PROTECT || GTP_COMPATIBLE_MODE)
-static void force_reset_guitar(void);
-#endif
-
-#if GTP_ESD_PROTECT
-static int clk_tick_cnt = 200;
-static struct delayed_work gtp_esd_check_work;
-static struct workqueue_struct *gtp_esd_check_workqueue = NULL;
-static s32 gtp_init_ext_watchdog(struct i2c_client *client);
-static void gtp_esd_check_func(struct work_struct *);
-void gtp_esd_switch(struct i2c_client *client, s32 on);
-u8 esd_running = 0;
-spinlock_t esd_lock;
-#endif
-
-
-#ifdef TPD_PROXIMITY
-#define TPD_PROXIMITY_VALID_REG                   0x814E
-#define TPD_PROXIMITY_ENABLE_REG                  0x8042
-static u8 tpd_proximity_flag = 0;
-static u8 tpd_proximity_flag_one 	= 0;	//jeff add 20150317
-static u8 tpd_proximity_detect = 1;//0-->close ; 1--> far away
-#endif
-
-struct i2c_client *i2c_client_point = NULL;
-static const struct i2c_device_id tpd_i2c_id[] = {{"gt9xx", 0}, {}};
-static unsigned short force[] = {0, 0xBA, I2C_CLIENT_END, I2C_CLIENT_END};
-static const unsigned short *const forces[] = { force, NULL };
-//static struct i2c_client_address_data addr_data = { .forces = forces,};
-static struct i2c_board_info __initdata i2c_tpd = { I2C_BOARD_INFO("gt9xx", (0xBA >> 1))};
-static struct i2c_driver tpd_i2c_driver =
-{
-    .probe = tpd_i2c_probe,
-    .remove = tpd_i2c_remove,
-    .detect = tpd_i2c_detect,
-    .driver.name = "gt9xx",
-    .id_table = tpd_i2c_id,
-    .address_list = (const unsigned short *) forces,
-};
-
-
-static u8 config[GTP_CONFIG_MAX_LENGTH + GTP_ADDR_LENGTH]
-    = {GTP_REG_CONFIG_DATA >> 8, GTP_REG_CONFIG_DATA & 0xff};
-
-#pragma pack(1)
-typedef struct
-{
-    u16 pid;                 //product id   //
-    u16 vid;                 //version id   //
-} st_tpd_info;
-#pragma pack()
-
-st_tpd_info tpd_info;
-u8 int_type = 0;
-u32 abs_x_max = 0;
-u32 abs_y_max = 0;
-u8 gtp_rawdiff_mode = 0;
-u8 cfg_len = 0;
-u8 grp_cfg_version = 0;
-u8 fixed_config = 0;
-u8 pnl_init_error = 0;
-
-#if GTP_WITH_PEN
-struct input_dev *pen_dev;
-#endif
-
-#if GTP_COMPATIBLE_MODE
-u8 driver_num = 0;
-u8 sensor_num = 0;
-u8 gtp_ref_retries = 0;
-u8 gtp_clk_retries = 0;
-CHIP_TYPE_T gtp_chip_type = CHIP_TYPE_GT9;
-u8 rqst_processing = 0;
-u8 is_950 = 0;
-
-extern u8 gup_check_fs_mounted(char *path_name);
-extern u8 gup_clk_calibration(void);
-extern s32 gup_fw_download_proc(void *dir, u8 dwn_mode);
-void gtp_get_chip_type(struct i2c_client *client);
-u8 gtp_fw_startup(struct i2c_client *client);
-static u8 gtp_bak_ref_proc(struct i2c_client *client, u8 mode);
-static u8 gtp_main_clk_proc(struct i2c_client *client);
-static void gtp_recovery_reset(struct i2c_client *client);
-#endif
-
-/* proc file system */
-s32 i2c_read_bytes(struct i2c_client *client, u16 addr, u8 *rxbuf, int len);
-s32 i2c_write_bytes(struct i2c_client *client, u16 addr, u8 *txbuf, int len);
-
-static ssize_t gt91xx_config_read_proc(struct file *, char __user *, size_t, loff_t *);
-static ssize_t gt91xx_config_write_proc(struct file *, const char __user *, size_t, loff_t *);
-
-static struct proc_dir_entry *gt91xx_config_proc = NULL;
-static const struct file_operations config_proc_ops = {
-    .owner = THIS_MODULE,
-    .read = gt91xx_config_read_proc,
-    .write = gt91xx_config_write_proc,
-};
-
-#define VELOCITY_CUSTOM
-#ifdef VELOCITY_CUSTOM
-#include <linux/device.h>
-#include <linux/miscdevice.h>
-#include <asm/uaccess.h>
-
-#ifndef TPD_VELOCITY_CUSTOM_X
-#define TPD_VELOCITY_CUSTOM_X 10
-#endif
-#ifndef TPD_VELOCITY_CUSTOM_Y
-#define TPD_VELOCITY_CUSTOM_Y 10
-#endif
-
-// for magnify velocity********************************************
-#define TOUCH_IOC_MAGIC 'A'
-
-#define TPD_GET_VELOCITY_CUSTOM_X _IO(TOUCH_IOC_MAGIC,0)
-#define TPD_GET_VELOCITY_CUSTOM_Y _IO(TOUCH_IOC_MAGIC,1)
-
-int g_v_magnify_x = TPD_VELOCITY_CUSTOM_X;
-int g_v_magnify_y = TPD_VELOCITY_CUSTOM_Y;
-static int tpd_misc_open(struct inode *inode, struct file *file)
-{
-    return nonseekable_open(inode, file);
-}
-
-static int tpd_misc_release(struct inode *inode, struct file *file)
-{
-    return 0;
-}
-
-static long tpd_unlocked_ioctl(struct file *file, unsigned int cmd,
-                               unsigned long arg)
-{
-    //char strbuf[256];
-    void __user *data;
-
-    long err = 0;
-
-    if (_IOC_DIR(cmd) & _IOC_READ)
-    {
-        err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
-    }
-    else if (_IOC_DIR(cmd) & _IOC_WRITE)
-    {
-        err = !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
-    }
-
-    if (err)
-    {
-        printk("tpd: access error: %08X, (%2d, %2d)\n", cmd, _IOC_DIR(cmd), _IOC_SIZE(cmd));
-        return -EFAULT;
-    }
-
-    switch (cmd)
-    {
-        case TPD_GET_VELOCITY_CUSTOM_X:
-            data = (void __user *) arg;
-
-            if (data == NULL)
-            {
-                err = -EINVAL;
-                break;
-            }
-
-            if (copy_to_user(data, &g_v_magnify_x, sizeof(g_v_magnify_x)))
-            {
-                err = -EFAULT;
-                break;
-            }
-
-            break;
-
-        case TPD_GET_VELOCITY_CUSTOM_Y:
-            data = (void __user *) arg;
-
-            if (data == NULL)
-            {
-                err = -EINVAL;
-                break;
-            }
-
-            if (copy_to_user(data, &g_v_magnify_y, sizeof(g_v_magnify_y)))
-            {
-                err = -EFAULT;
-                break;
-            }
-
-            break;
-
-        default:
-            printk("tpd: unknown IOCTL: 0x%08x\n", cmd);
-            err = -ENOIOCTLCMD;
-            break;
-
-    }
-
-    return err;
-}
-
-
-static struct file_operations tpd_fops =
-{
-//  .owner = THIS_MODULE,
-    .open = tpd_misc_open,
-    .release = tpd_misc_release,
-    .unlocked_ioctl = tpd_unlocked_ioctl,
-};
-/*----------------------------------------------------------------------------*/
-static struct miscdevice tpd_misc_device =
-{
-    .minor = MISC_DYNAMIC_MINOR,
-    .name = "touch",
-    .fops = &tpd_fops,
-};
-
-//**********************************************
-#endif
-
-static int tpd_i2c_detect(struct i2c_client *client, struct i2c_board_info *info)
-{
-    strcpy(info->type, "mtk-tpd");
-    return 0;
-}
-
-#ifdef TPD_PROXIMITY
-static s32 tpd_get_ps_value(void)
-{
-    return tpd_proximity_detect;
-}
-
-static s32 tpd_enable_ps(s32 enable)
-{
-    u8  state;
-    s32 ret = -1;
-
-    if (enable)
-    {
-        state = 1;
-        tpd_proximity_flag = 1;
-        GTP_INFO("TPD proximity function to be on.");
-    }
-    else
-    {
-        state = 0;
-        tpd_proximity_flag = 0;
-        GTP_INFO("TPD proximity function to be off.");
-    }
-
-    ret = i2c_write_bytes(i2c_client_point, TPD_PROXIMITY_ENABLE_REG, &state, 1);
-
-    if (ret < 0)
-    {
-        GTP_ERROR("TPD %s proximity cmd failed.", state ? "enable" : "disable");
-        return ret;
-    }
-
-    GTP_INFO("TPD proximity function %s success.", state ? "enable" : "disable");
-    return 0;
-}
-
-s32 gt9xx_tpd_ps_operate(void *self, u32 command, void *buff_in, s32 size_in,
-                   void *buff_out, s32 size_out, s32 *actualout)
-{
-    s32 err = 0;
-    s32 value;
-    hwm_sensor_data *sensor_data;
-
-    switch (command)
-    {
-        case SENSOR_DELAY:
-            if ((buff_in == NULL) || (size_in < sizeof(int)))
-            {
-                GTP_ERROR("Set delay parameter error!");
-                err = -EINVAL;
-            }
-
-            // Do nothing
-            break;
-
-        case SENSOR_ENABLE:
-            if ((buff_in == NULL) || (size_in < sizeof(int)))
-            {
-                GTP_ERROR("Enable sensor parameter error!");
-                err = -EINVAL;
-            }
-            else
-            {
-                value = *(int *)buff_in;
-                err = tpd_enable_ps(value);
-            }
-
-            break;
-
-        case SENSOR_GET_DATA:
-            if ((buff_out == NULL) || (size_out < sizeof(hwm_sensor_data)))
-            {
-                GTP_ERROR("Get sensor data parameter error!");
-                err = -EINVAL;
-            }
-            else
-            {
-                sensor_data = (hwm_sensor_data *)buff_out;
-                sensor_data->values[0] = tpd_get_ps_value();
-                sensor_data->value_divide = 1;
-                sensor_data->status = SENSOR_STATUS_ACCURACY_MEDIUM;
-            }
-
-            break;
-
-        default:
-            GTP_ERROR("proxmy sensor operate function no this parameter %d!\n", command);
-            err = -1;
-            break;
-    }
-
-    return err;
-}
-#endif
-
-
-static ssize_t gt91xx_config_read_proc(struct file *file, char __user *page, size_t size, loff_t *ppos)
-{
-    char *ptr = page;
-    char temp_data[GTP_CONFIG_MAX_LENGTH + 2] = {0};
-    int i;
-    
-    if (*ppos)  // CMD call again
-    {
-        return 0;
-    }
-    
-    ptr += sprintf(ptr, "==== GT9XX config init value====\n");
-
-    for (i = 0 ; i < GTP_CONFIG_MAX_LENGTH ; i++)
-    {
-        ptr += sprintf(ptr, "0x%02X ", config[i + 2]);
-
-        if (i % 8 == 7)
-            ptr += sprintf(ptr, "\n");
-    }
-
-    ptr += sprintf(ptr, "\n");
-
-    ptr += sprintf(ptr, "==== GT9XX config real value====\n");
-    i2c_read_bytes(i2c_client_point, GTP_REG_CONFIG_DATA, temp_data, GTP_CONFIG_MAX_LENGTH);
-
-    for (i = 0 ; i < GTP_CONFIG_MAX_LENGTH ; i++)
-    {
-        ptr += sprintf(ptr, "0x%02X ", temp_data[i]);
-
-        if (i % 8 == 7)
-            ptr += sprintf(ptr, "\n");
-    }
-    *ppos += ptr - page;
-    return (ptr - page);
-}
-
-static ssize_t gt91xx_config_write_proc(struct file *filp, const char __user *buffer, size_t count, loff_t *off)
-{
-    s32 ret = 0;
-
-   // GTP_DEBUG("write count %d\n", count);
-
-    if (count > GTP_CONFIG_MAX_LENGTH)
-    {
-     //   GTP_ERROR("size not match [%d:%d]\n", GTP_CONFIG_MAX_LENGTH, count);
-        return -EFAULT;
-    }
-
-    if (copy_from_user(&config[2], buffer, count))
-    {
-        GTP_ERROR("copy from user fail\n");
-        return -EFAULT;
-    }
-
-    ret = gtp_send_cfg(i2c_client_point);
-    abs_x_max = (config[RESOLUTION_LOC + 1] << 8) + config[RESOLUTION_LOC];
-    abs_y_max = (config[RESOLUTION_LOC + 3] << 8) + config[RESOLUTION_LOC + 2];
-    int_type = (config[TRIGGER_LOC]) & 0x03;
-
-    if (ret < 0)
-    {
-        GTP_ERROR("send config failed.");
-    }
-
-    return count;
-}
-
-#if GTP_SUPPORT_I2C_DMA
-s32 i2c_dma_read(struct i2c_client *client, u16 addr, u8 *rxbuf, s32 len)
-{
-    int ret;
-    s32 retry = 0;
-    u8 buffer[2];
-
-    struct i2c_msg msg[2] =
-    {
-        {
-            .addr = (client->addr & I2C_MASK_FLAG),
-            .flags = 0,
-            .buf = buffer,
-            .len = 2,
-            .timing = I2C_MASTER_CLOCK
-        },
-        {
-            .addr = (client->addr & I2C_MASK_FLAG),
-            .ext_flag = (client->ext_flag | I2C_ENEXT_FLAG | I2C_DMA_FLAG),
-            .flags = I2C_M_RD,
-            .buf = (u8*)gpDMABuf_pa,     
-            .len = len,
-            .timing = I2C_MASTER_CLOCK
-        },
-    };
-    
-    buffer[0] = (addr >> 8) & 0xFF;
-    buffer[1] = addr & 0xFF;
-
-    if (rxbuf == NULL)
-        return -1;
-
-    //GTP_DEBUG("dma i2c read: 0x%04X, %d bytes(s)", addr, len);
-    for (retry = 0; retry < 5; ++retry)
-    {
-        ret = i2c_transfer(client->adapter, &msg[0], 2);
-        if (ret < 0)
-        {
-            continue;
-        }
-        memcpy(rxbuf, gpDMABuf_va, len);
-        return 0;
-    }
-    GTP_ERROR("Dma I2C Read Error: 0x%04X, %d byte(s), err-code: %d", addr, len, ret);
-    return ret;
-}
-
-
-s32 i2c_dma_write(struct i2c_client *client, u16 addr, u8 *txbuf, s32 len)
-{
-    int ret;
-    s32 retry = 0;
-    u8 *wr_buf = gpDMABuf_va;
-    
-    struct i2c_msg msg =
-    {
-        .addr = (client->addr & I2C_MASK_FLAG),
-        .ext_flag = (client->ext_flag | I2C_ENEXT_FLAG | I2C_DMA_FLAG),
-        .flags = 0,
-        .buf = (u8*)gpDMABuf_pa,
-        .len = 2 + len,
-        .timing = I2C_MASTER_CLOCK
-    };
-    
-    wr_buf[0] = (u8)((addr >> 8) & 0xFF);
-    wr_buf[1] = (u8)(addr & 0xFF);
-
-    if (txbuf == NULL)
-        return -1;
-    
-    //GTP_DEBUG("dma i2c write: 0x%04X, %d bytes(s)", addr, len);
-    memcpy(wr_buf+2, txbuf, len);
-    for (retry = 0; retry < 5; ++retry)
-    {
-        ret = i2c_transfer(client->adapter, &msg, 1);
-        if (ret < 0)
-        {
-            continue;
-        }
-        return 0;
-    }
-    GTP_ERROR("Dma I2C Write Error: 0x%04X, %d byte(s), err-code: %d", addr, len, ret);
-    return ret;
-}
-
-s32 i2c_read_bytes_dma(struct i2c_client *client, u16 addr, u8 *rxbuf, s32 len)
-{
-    s32 left = len;
-    s32 read_len = 0;
-    u8 *rd_buf = rxbuf;
-    s32 ret = 0;    
-    
-    //GTP_DEBUG("Read bytes dma: 0x%04X, %d byte(s)", addr, len);
-    while (left > 0)
-    {
-        if (left > GTP_DMA_MAX_TRANSACTION_LENGTH)
-        {
-            read_len = GTP_DMA_MAX_TRANSACTION_LENGTH;
-        }
-        else
-        {
-            read_len = left;
-        }
-        ret = i2c_dma_read(client, addr, rd_buf, read_len);
-        if (ret < 0)
-        {
-            GTP_ERROR("dma read failed");
-            return -1;
-        }
-        
-        left -= read_len;
-        addr += read_len;
-        rd_buf += read_len;
-    }
-    return 0;
-}
-
-s32 i2c_write_bytes_dma(struct i2c_client *client, u16 addr, u8 *txbuf, s32 len)
-{
-
-    s32 ret = 0;
-    s32 write_len = 0;
-    s32 left = len;
-    u8 *wr_buf = txbuf;
-    
-    //GTP_DEBUG("Write bytes dma: 0x%04X, %d byte(s)", addr, len);
-    while (left > 0)
-    {
-        if (left > GTP_DMA_MAX_I2C_TRANSFER_SIZE)
-        {
-            write_len = GTP_DMA_MAX_I2C_TRANSFER_SIZE;
-        }
-        else
-        {
-            write_len = left;
-        }
-        ret = i2c_dma_write(client, addr, wr_buf, write_len);
-        
-        if (ret < 0)
-        {
-            GTP_ERROR("dma i2c write failed!");
-            return -1;
-        }
-        
-        left -= write_len;
-        addr += write_len;
-        wr_buf += write_len;
-    }
-    return 0;
-}
-#endif
-
-
-int i2c_read_bytes_non_dma(struct i2c_client *client, u16 addr, u8 *rxbuf, int len)
-{
-    u8 buffer[GTP_ADDR_LENGTH];
-    u8 retry;
-    u16 left = len;
-    u16 offset = 0;
-
-    struct i2c_msg msg[2] =
-    {
-        {
-            //.addr = ((client->addr &I2C_MASK_FLAG) | (I2C_ENEXT_FLAG)),
-            .addr = ((client->addr &I2C_MASK_FLAG) | (I2C_PUSHPULL_FLAG)),
-            .flags = 0,
-            .buf = buffer,
-            .len = GTP_ADDR_LENGTH,
-            .timing = I2C_MASTER_CLOCK
-        },
-        {
-            //.addr = ((client->addr &I2C_MASK_FLAG) | (I2C_ENEXT_FLAG)),
-            .addr = ((client->addr &I2C_MASK_FLAG) | (I2C_PUSHPULL_FLAG)),
-            .flags = I2C_M_RD,
-            .timing = I2C_MASTER_CLOCK
-        },
-    };
-
-    if (rxbuf == NULL)
-        return -1;
-
-    //GTP_DEBUG("i2c_read_bytes to device %02X address %04X len %d\n", client->addr, addr, len);
-
-    while (left > 0)
-    {
-        buffer[0] = ((addr + offset) >> 8) & 0xFF;
-        buffer[1] = (addr + offset) & 0xFF;
-
-        msg[1].buf = &rxbuf[offset];
-
-        if (left > MAX_TRANSACTION_LENGTH)
-        {
-            msg[1].len = MAX_TRANSACTION_LENGTH;
-            left -= MAX_TRANSACTION_LENGTH;
-            offset += MAX_TRANSACTION_LENGTH;
-        }
-        else
-        {
-            msg[1].len = left;
-            left = 0;
-        }
-
-        retry = 0;
-
-        while (i2c_transfer(client->adapter, &msg[0], 2) != 2)
-        {
-            retry++;
-
-            //if (retry == 20)
-            if (retry == 5)
-            {
-                GTP_ERROR("I2C read 0x%X length=%d failed\n", addr + offset, len);
-                return -1;
-            }
-        }
-    }
-
-    return 0;
-}
-
-
-int i2c_read_bytes(struct i2c_client *client, u16 addr, u8 *rxbuf, int len)
-{
-#if GTP_SUPPORT_I2C_DMA
-    return i2c_read_bytes_dma(client, addr, rxbuf, len);
-#else
-    return i2c_read_bytes_non_dma(client, addr, rxbuf, len);
-#endif
-}
-
-s32 gtp_i2c_read(struct i2c_client *client, u8 *buf, s32 len)
-{
-    s32 ret = -1;
-    u16 addr = (buf[0] << 8) + buf[1];
-
-    ret = i2c_read_bytes_non_dma(client, addr, &buf[2], len - 2);
-
-    if (!ret)
-    {
-        return 2;
-    }
-    else
-    {
-    #if GTP_GESTURE_WAKEUP
-        if (DOZE_ENABLED == doze_status)
-        {
-            return ret;
-        }
-    #endif
-    #if GTP_COMPATIBLE_MODE
-        if (CHIP_TYPE_GT9F == gtp_chip_type)
-        {
-            gtp_recovery_reset(client);
-        }
-        else
-    #endif
-        {
-            gtp_reset_guitar(client, 20);
-        }
-        return ret;
-    }
-}
-
-
-s32 gtp_i2c_read_dbl_check(struct i2c_client *client, u16 addr, u8 *rxbuf, int len)
-{
-    u8 buf[16] = {0};
-    u8 confirm_buf[16] = {0};
-    u8 retry = 0;
-    
-    while (retry++ < 3)
-    {
-        memset(buf, 0xAA, 16);
-        buf[0] = (u8)(addr >> 8);
-        buf[1] = (u8)(addr & 0xFF);
-        gtp_i2c_read(client, buf, len + 2);
-        
-        memset(confirm_buf, 0xAB, 16);
-        confirm_buf[0] = (u8)(addr >> 8);
-        confirm_buf[1] = (u8)(addr & 0xFF);
-        gtp_i2c_read(client, confirm_buf, len + 2);
-        
-        if (!memcmp(buf, confirm_buf, len+2))
-        {
-            memcpy(rxbuf, confirm_buf+2, len);
-            return SUCCESS;
-        }
-    }    
-    GTP_ERROR("i2c read 0x%04X, %d bytes, double check failed!", addr, len);
-    return FAIL;
-}
-
-int i2c_write_bytes_non_dma(struct i2c_client *client, u16 addr, u8 *txbuf, int len)
-{
-    u8 buffer[MAX_TRANSACTION_LENGTH];
-    u16 left = len;
-    u16 offset = 0;
-    u8 retry = 0;
-
-    struct i2c_msg msg =
-    {
-        //.addr = ((client->addr &I2C_MASK_FLAG) | (I2C_ENEXT_FLAG)),
-        .addr = ((client->addr &I2C_MASK_FLAG) | (I2C_PUSHPULL_FLAG)),
-        .flags = 0,
-        .buf = buffer,
-        .timing = I2C_MASTER_CLOCK,
-    };
-
-
-    if (txbuf == NULL)
-        return -1;
-
-    //GTP_DEBUG("i2c_write_bytes to device %02X address %04X len %d\n", client->addr, addr, len);
-
-    while (left > 0)
-    {
-        retry = 0;
-
-        buffer[0] = ((addr + offset) >> 8) & 0xFF;
-        buffer[1] = (addr + offset) & 0xFF;
-
-        if (left > MAX_I2C_TRANSFER_SIZE)
-        {
-            memcpy(&buffer[GTP_ADDR_LENGTH], &txbuf[offset], MAX_I2C_TRANSFER_SIZE);
-            msg.len = MAX_TRANSACTION_LENGTH;
-            left -= MAX_I2C_TRANSFER_SIZE;
-            offset += MAX_I2C_TRANSFER_SIZE;
-        }
-        else
-        {
-            memcpy(&buffer[GTP_ADDR_LENGTH], &txbuf[offset], left);
-            msg.len = left + GTP_ADDR_LENGTH;
-            left = 0;
-        }
-
-        //GTP_DEBUG("byte left %d offset %d\n", left, offset);
-
-        while (i2c_transfer(client->adapter, &msg, 1) != 1)
-        {
-            retry++;
-
-            //if (retry == 20)
-            if (retry == 5)
-            {
-                GTP_ERROR("I2C write 0x%X%X length=%d failed\n", buffer[0], buffer[1], len);
-                return -1;
-            }
-        }
-    }
-
-    return 0;
-}
-
-int i2c_write_bytes(struct i2c_client *client, u16 addr, u8 *txbuf, int len)
-{
-#if GTP_SUPPORT_I2C_DMA
-    return i2c_write_bytes_dma(client, addr, txbuf, len);
-#else
-    return i2c_write_bytes_non_dma(client, addr, txbuf, len);
-#endif
-}
-
-s32 gtp_i2c_write(struct i2c_client *client, u8 *buf, s32 len)
-{
-    s32 ret = -1;
-    u16 addr = (buf[0] << 8) + buf[1];
-
-    ret = i2c_write_bytes_non_dma(client, addr, &buf[2], len - 2);
-
-    if (!ret)
-    {
-        return 1;
-    }
-    else
-    {
-    #if GTP_GESTURE_WAKEUP
-        if (DOZE_ENABLED == doze_status)
-        {
-            return ret;
-        }
-    #endif
-    #if GTP_COMPATIBLE_MODE
-        if (CHIP_TYPE_GT9F == gtp_chip_type)
-        {
-            gtp_recovery_reset(client);
-        }
-        else
-    #endif
-        {
-            gtp_reset_guitar(client, 20);
-        }
-        return ret;
-    }
-}
-
-
-
-/*******************************************************
-Function:
-    Send config Function.
-
-Input:
-    client: i2c client.
-
-Output:
-    Executive outcomes.0--success,non-0--fail.
-*******************************************************/
-s32 gtp_send_cfg(struct i2c_client *client)
-{
-    s32 ret = 1;
-
-#if GTP_DRIVER_SEND_CFG
-    s32 retry = 0;
-    if (fixed_config)
-    {
-        GTP_INFO("Ic fixed config, no config sent!");
-        return 0;
-    }
-    else if (pnl_init_error)
-    {
-        GTP_INFO("Error occurred in init_panel, no config sent!");
-        return 0;
-    }
-    
-    GTP_INFO("Driver Send Config");
-    for (retry = 0; retry < 5; retry++)
-    {
-        ret = gtp_i2c_write(client, config, GTP_CONFIG_MAX_LENGTH + GTP_ADDR_LENGTH);
-
-        if (ret > 0)
-        {
-            break;
-        }
-    }
-#endif
-    return ret;
-}
-
-
-/*******************************************************
-Function:
-    Read goodix touchscreen version function.
-
-Input:
-    client: i2c client struct.
-    version:address to store version info
-
-Output:
-    Executive outcomes.0---succeed.
-*******************************************************/
-s32 gtp_read_version(struct i2c_client *client, u16 *version)
-{
-    s32 ret = -1;
-    s32 i;
-    u8 buf[8] = {GTP_REG_VERSION >> 8, GTP_REG_VERSION & 0xff};
-
-    GTP_DEBUG_FUNC();
-
-    ret = gtp_i2c_read(client, buf, sizeof(buf));
-
-    if (ret < 0)
-    {
-        GTP_ERROR("GTP read version failed");
-        return ret;
-    }
-
-    if (version)
-    {
-        *version = (buf[7] << 8) | buf[6];
-    }
-
-    tpd_info.vid = *version;
-    tpd_info.pid = 0x00;
-
-    for (i = 0; i < 4; i++)
-    {
-        if (buf[i + 2] < 0x30)break;
-
-        tpd_info.pid |= ((buf[i + 2] - 0x30) << ((3 - i) * 4));
-    }
-
-    if (buf[5] == 0x00)
-    {        
-        GTP_INFO("IC VERSION: %c%c%c_%02x%02x",
-             buf[2], buf[3], buf[4], buf[7], buf[6]);  
-    }
-    else
-    {
-        GTP_INFO("IC VERSION:%c%c%c%c_%02x%02x",
-             buf[2], buf[3], buf[4], buf[5], buf[7], buf[6]);
-    }
-    return ret;
-}
-
-#if GTP_DRIVER_SEND_CFG
-/*******************************************************
-Function:
-    Get information from ic, such as resolution and 
-    int trigger type
-Input:
-    client: i2c client private struct.
-
-Output:
-    FAIL: i2c failed, SUCCESS: i2c ok
-*******************************************************/
-static s32 gtp_get_info(struct i2c_client *client)
-{
-    u8 opr_buf[6] = {0};
-    s32 ret = 0;
-    
-    opr_buf[0] = (u8)((GTP_REG_CONFIG_DATA+1) >> 8);
-    opr_buf[1] = (u8)((GTP_REG_CONFIG_DATA+1) & 0xFF);
-    
-    ret = gtp_i2c_read(client, opr_buf, 6);
-    if (ret < 0)
-    {
-        return FAIL;
-    }
-    
-    abs_x_max = (opr_buf[3] << 8) + opr_buf[2];
-    abs_y_max = (opr_buf[5] << 8) + opr_buf[4];
-    
-    opr_buf[0] = (u8)((GTP_REG_CONFIG_DATA+6) >> 8);
-    opr_buf[1] = (u8)((GTP_REG_CONFIG_DATA+6) & 0xFF);
-    
-    ret = gtp_i2c_read(client, opr_buf, 3);
-    if (ret < 0)
-    {
-        return FAIL;
-    }
-    int_type = opr_buf[2] & 0x03;
-    
-    GTP_INFO("X_MAX = %d, Y_MAX = %d, TRIGGER = 0x%02x",
-            abs_x_max,abs_y_max, int_type);
-            
-    return SUCCESS;
-}
-#endif
-
-
-/*******************************************************
-Function:
-    GTP initialize function.
-
-Input:
-    client: i2c client private struct.
-
-Output:
-    Executive outcomes.0---succeed.
-*******************************************************/
-static s32 gtp_init_panel(struct i2c_client *client)
-{
-    s32 ret = 0;
-
-#if GTP_DRIVER_SEND_CFG
-    s32 i;
-    u8 check_sum = 0;
-    u8 opr_buf[16];
-    u8 sensor_id = 0;
-    //ret = gtp_i2c_read_dbl_check(client, GTP_REG_SENSOR_ID, &sensor_id, 1);//first:2 second:0
-    u8 cfg_info_group1[] = CTP_CFG_GROUP1;
-    u8 cfg_info_group2[] = CTP_CFG_GROUP2;
-    u8 cfg_info_group3[] = CTP_CFG_GROUP3;
-    u8 cfg_info_group4[] = CTP_CFG_GROUP4;
-    u8 cfg_info_group5[] = CTP_CFG_GROUP5;
-    u8 cfg_info_group6[] = CTP_CFG_GROUP6;
-    u8 *send_cfg_buf[] = {cfg_info_group1, cfg_info_group2, cfg_info_group3,
-                        cfg_info_group4, cfg_info_group5, cfg_info_group6};
-    u8 cfg_info_len[] = { CFG_GROUP_LEN(cfg_info_group1), 
-                          CFG_GROUP_LEN(cfg_info_group2),
-                          CFG_GROUP_LEN(cfg_info_group3),
-                          CFG_GROUP_LEN(cfg_info_group4), 
-                          CFG_GROUP_LEN(cfg_info_group5),
-                          CFG_GROUP_LEN(cfg_info_group6)};
-
-    GTP_DEBUG("Config Groups\' Lengths: %d, %d, %d, %d, %d, %d", 
-        cfg_info_len[0], cfg_info_len[1], cfg_info_len[2], cfg_info_len[3],
-        cfg_info_len[4], cfg_info_len[5]);
-
-    if ((!cfg_info_len[1]) && (!cfg_info_len[2]) && 
-        (!cfg_info_len[3]) && (!cfg_info_len[4]) && 
-        (!cfg_info_len[5]))
-    {
-        sensor_id = 0; 
-    }
-    else
-    {
-    #if GTP_COMPATIBLE_MODE
-        if (CHIP_TYPE_GT9F == gtp_chip_type)
-        {
-            msleep(50);
-        }
-    #endif
-        ret = gtp_i2c_read_dbl_check(client, GTP_REG_SENSOR_ID, &sensor_id, 1);
-        if (SUCCESS == ret)
-        {
-            if (sensor_id >= 0x06)
-            {
-                GTP_ERROR("Invalid sensor_id(0x%02X), No Config Sent!", sensor_id);
-                pnl_init_error = 1;
-                return -1;
-            }
-        }
-        else
-        {
-            GTP_ERROR("Failed to get sensor_id, No config sent!");
-            pnl_init_error = 1;
-            return -1;
-        }
-        GTP_INFO("Sensor_ID: %d", sensor_id);
-    }
-    
-    cfg_len = cfg_info_len[sensor_id];
-    
-    GTP_INFO("CTP_CONFIG_GROUP%d used, config length: %d", sensor_id + 1, cfg_len);
-    
-    if (cfg_len < GTP_CONFIG_MIN_LENGTH)
-    {
-        GTP_ERROR("CTP_CONFIG_GROUP%d is INVALID CONFIG GROUP! NO Config Sent! You need to check you header file CFG_GROUP section!", sensor_id+1);
-        pnl_init_error = 1;
-        return -1;
-    }
-    
-#if GTP_COMPATIBLE_MODE
-    if (CHIP_TYPE_GT9F == gtp_chip_type)
-    {
-        fixed_config = 0;
-    }
-    else
-#endif
-    {
-        ret = gtp_i2c_read_dbl_check(client, GTP_REG_CONFIG_DATA, &opr_buf[0], 1);
-        
-        if (ret == SUCCESS)
-        {
-            GTP_DEBUG("CFG_CONFIG_GROUP%d Config Version: %d, 0x%02X; IC Config Version: %d, 0x%02X", sensor_id+1, 
-                        send_cfg_buf[sensor_id][0], send_cfg_buf[sensor_id][0], opr_buf[0], opr_buf[0]);
-            
-            if (opr_buf[0] < 90)
-            {
-                grp_cfg_version = send_cfg_buf[sensor_id][0];       // backup group config version
-                send_cfg_buf[sensor_id][0] = 0x00;
-                fixed_config = 0;
-            }
-            else        // treated as fixed config, not send config
-            {
-                GTP_INFO("Ic fixed config with config version(%d)", opr_buf[0]);
-                fixed_config = 1;
-                gtp_get_info(client);
-                return 0;
-            }
-        }
-        else
-        {
-            GTP_ERROR("Failed to get ic config version!No config sent!");
-            return -1;
-        }
-    }
-    
-    memset(&config[GTP_ADDR_LENGTH], 0, GTP_CONFIG_MAX_LENGTH);
-    memcpy(&config[GTP_ADDR_LENGTH], send_cfg_buf[sensor_id], cfg_len);
-
-#if GTP_CUSTOM_CFG
-    config[RESOLUTION_LOC]     = (u8)GTP_MAX_WIDTH;
-    config[RESOLUTION_LOC + 1] = (u8)(GTP_MAX_WIDTH>>8);
-    config[RESOLUTION_LOC + 2] = (u8)GTP_MAX_HEIGHT;
-    config[RESOLUTION_LOC + 3] = (u8)(GTP_MAX_HEIGHT>>8);
-    
-    if (GTP_INT_TRIGGER == 0)  //RISING
-    {
-        config[TRIGGER_LOC] &= 0xfe; 
-    }
-    else if (GTP_INT_TRIGGER == 1)  //FALLING
-    {
-        config[TRIGGER_LOC] |= 0x01;
-    }
-#endif  // GTP_CUSTOM_CFG
-    
-    check_sum = 0;
-    for (i = GTP_ADDR_LENGTH; i < cfg_len; i++)
-    {
-        check_sum += config[i];
-    }
-    config[cfg_len] = (~check_sum) + 1;
-    
-#else // DRIVER NOT SEND CONFIG
-    cfg_len = GTP_CONFIG_MAX_LENGTH;
-    ret = gtp_i2c_read(client, config, cfg_len + GTP_ADDR_LENGTH);
-    if (ret < 0)
-    {
-        GTP_ERROR("Read Config Failed, Using DEFAULT Resolution & INT Trigger!");
-        abs_x_max = GTP_MAX_WIDTH;
-        abs_y_max = GTP_MAX_HEIGHT;
-        int_type = GTP_INT_TRIGGER;
-    }
-#endif // GTP_DRIVER_SEND_CFG
-
-    GTP_DEBUG_FUNC();
-    if ((abs_x_max == 0) && (abs_y_max == 0))
-    {
-        abs_x_max = (config[RESOLUTION_LOC + 1] << 8) + config[RESOLUTION_LOC];
-        abs_y_max = (config[RESOLUTION_LOC + 3] << 8) + config[RESOLUTION_LOC + 2];
-        int_type = (config[TRIGGER_LOC]) & 0x03; 
-    }
-    
-#if GTP_COMPATIBLE_MODE
-    if (CHIP_TYPE_GT9F == gtp_chip_type)
-    {
-        u8 have_key = 0;
-        if (is_950)
-        {
-            driver_num = config[GTP_REG_MATRIX_DRVNUM - GTP_REG_CONFIG_DATA + 2];
-            sensor_num = config[GTP_REG_MATRIX_SENNUM - GTP_REG_CONFIG_DATA + 2];
-        }
-        else
-        {
-            driver_num = (config[CFG_LOC_DRVA_NUM]&0x1F) + (config[CFG_LOC_DRVB_NUM]&0x1F);
-            sensor_num = (config[CFG_LOC_SENS_NUM]&0x0F) + ((config[CFG_LOC_SENS_NUM]>>4)&0x0F);
-        }
-        
-        have_key = config[GTP_REG_HAVE_KEY - GTP_REG_CONFIG_DATA + 2] & 0x01;  // have key or not
-        if (1 == have_key)
-        {
-            driver_num--;
-        }
-        
-        GTP_INFO("Driver * Sensor: %d * %d(Key: %d), X_MAX = %d, Y_MAX = %d, TRIGGER = 0x%02x",
-            driver_num, sensor_num, have_key, abs_x_max,abs_y_max,int_type);
-    }
-    else
-#endif
-    {
-    #if GTP_DRIVER_SEND_CFG
-        ret = gtp_send_cfg(client);
-        if (ret < 0)
-        {
-            GTP_ERROR("Send config error.");
-        }
-        // set config version to CTP_CFG_GROUP
-        // for resume to send config
-        config[GTP_ADDR_LENGTH] = grp_cfg_version;
-        check_sum = 0;
-        for (i = GTP_ADDR_LENGTH; i < cfg_len; i++)
-        {
-            check_sum += config[i];
-        }
-        config[cfg_len] = (~check_sum) + 1;
-    #endif
-        GTP_INFO("X_MAX = %d, Y_MAX = %d, TRIGGER = 0x%02x",
-            abs_x_max,abs_y_max,int_type);
-    }
-    
-    msleep(10);
-    return 0;
-}
-
-static s8 gtp_i2c_test(struct i2c_client *client)
-{
-
-    u8 retry = 0;
-    s8 ret = -1;
-    u32 hw_info = 0;
-
-    GTP_DEBUG_FUNC();
-
-    while (retry++ < 5)
-    {
-        ret = i2c_read_bytes(client, GTP_REG_HW_INFO, (u8 *)&hw_info, sizeof(hw_info));
-
-        if ((!ret) && (hw_info == 0x00900600))              //20121212
-        {
-            return ret;
-        }
-
-        GTP_ERROR("GTP_REG_HW_INFO : %08X", hw_info);
-        GTP_ERROR("GTP i2c test failed time %d.", retry);
-        msleep(10);
-    }
-
-    return -1;
-}
-
-
-
-/*******************************************************
-Function:
-    Set INT pin  as input for FW sync.
-
-Note:
-  If the INT is high, It means there is pull up resistor attached on the INT pin.
-  Pull low the INT pin manaully for FW sync.
-*******************************************************/
-void gtp_int_sync(s32 ms)
-{
-    GTP_GPIO_OUTPUT(GTP_INT_PORT, 0);
-    msleep(ms);
-    GTP_GPIO_AS_INT(GTP_INT_PORT);
-}
-
-void gtp_reset_guitar(struct i2c_client *client, s32 ms)
-{
-    GTP_INFO("GTP RESET!\n");
-    GTP_GPIO_OUTPUT(GTP_RST_PORT, 0);
-    msleep(ms);
-    GTP_GPIO_OUTPUT(GTP_INT_PORT, client->addr == 0x14);
-
-    msleep(2);
-    GTP_GPIO_OUTPUT(GTP_RST_PORT, 1);
-
-    msleep(6);                      //must >= 6ms
-
-#if GTP_COMPATIBLE_MODE
-    if (CHIP_TYPE_GT9F == gtp_chip_type)
-    {
-        return;
-    }
-#endif
-
-    gtp_int_sync(50); 
-#if GTP_ESD_PROTECT
-    gtp_init_ext_watchdog(i2c_client_point);
-#endif
-}
-
-static int tpd_power_on(struct i2c_client *client)
-{
-    int ret = 0;
-    int reset_count = 0;
-
-reset_proc:
-    GTP_GPIO_OUTPUT(GTP_RST_PORT, 0);   
-    GTP_GPIO_OUTPUT(GTP_INT_PORT, 0);
-    msleep(10);
-
-#ifdef MT6573
-    // power on CTP
-    mt_set_gpio_mode(GPIO_CTP_EN_PIN, GPIO_CTP_EN_PIN_M_GPIO);
-    mt_set_gpio_dir(GPIO_CTP_EN_PIN, GPIO_DIR_OUT);
-    mt_set_gpio_out(GPIO_CTP_EN_PIN, GPIO_OUT_ONE);
-
-#else   // ( defined(MT6575) || defined(MT6577) || defined(MT6589) )
-
-    #ifdef TPD_POWER_SOURCE_CUSTOM                           
-     //   hwPowerOn(TPD_POWER_SOURCE_CUSTOM, VOL_2800, "TP");    
-    #else
-        hwPowerOn(MT65XX_POWER_LDO_VGP2, VOL_2800, "TP");
-    #endif
-    #ifdef TPD_POWER_SOURCE_1800
-        hwPowerOn(TPD_POWER_SOURCE_1800, VOL_1800, "TP");
-    #endif
-
-#endif
-
-    gtp_reset_guitar(client, 20);
-
-#if GTP_COMPATIBLE_MODE
-    gtp_get_chip_type(client);
-    
-    if (CHIP_TYPE_GT9F == gtp_chip_type)
-    {
-        ret = gup_fw_download_proc(NULL, GTP_FL_FW_BURN);
-    
-        if(FAIL == ret)
-        {
-            GTP_ERROR("[tpd_power_on]Download fw failed.");
-            if(reset_count++ < TPD_MAX_RESET_COUNT)
-            {
-                goto reset_proc;
-            }
-            else
-            {
-                return -1;
-            }
-        }
-        
-        ret = gtp_fw_startup(client);
-        if(FAIL == ret)
-        {
-            GTP_ERROR("[tpd_power_on]Startup fw failed.");
-            if(reset_count++ < TPD_MAX_RESET_COUNT)
-            {
-                goto reset_proc;
-            }
-            else
-            {
-                return -1;
-            }
-        }
-    }
-    else  
-#endif
-    {
-        ret = gtp_i2c_test(client);
-    
-        if (ret < 0)
-        {
-            GTP_ERROR("I2C communication ERROR!");
-    
-            if (reset_count < TPD_MAX_RESET_COUNT)
-            {
-                reset_count++;
-                goto reset_proc;
-            }
-        }
-    }
-    return ret;
-}
-
-//**************** For GT9XXF Start ********************//
-#if GTP_COMPATIBLE_MODE
-
-
-void gtp_get_chip_type(struct i2c_client *client)
-{
-    u8 opr_buf[10] = {0x00};
-    s32 ret = 0;
-    
-    msleep(10);
-    
-    ret = gtp_i2c_read_dbl_check(client, GTP_REG_CHIP_TYPE, opr_buf, 10);
-    
-    if (FAIL == ret)
-    {
-        GTP_ERROR("Failed to get chip-type, set chip type default: GOODIX_GT9");
-        gtp_chip_type = CHIP_TYPE_GT9;
-        return;
-    }
-    
-    if (!memcmp(opr_buf, "GOODIX_GT9", 10))
-    {
-        gtp_chip_type = CHIP_TYPE_GT9;
-    }
-    else // GT9XXF
-    {
-        gtp_chip_type = CHIP_TYPE_GT9F;
-    }
-    GTP_INFO("Chip Type: %s", (gtp_chip_type == CHIP_TYPE_GT9) ? "GOODIX_GT9" : "GOODIX_GT9F");
-}
-
-static u8 gtp_bak_ref_proc(struct i2c_client *client, u8 mode)
-{
-    s32 i = 0;
-    s32 j = 0;
-    s32 ret = 0;
-    struct file *flp = NULL;
-    u8 *refp = NULL;
-    u32 ref_len = 0;
-    u32 ref_seg_len = 0;
-    s32 ref_grps = 0;
-    s32 ref_chksum = 0;
-    u16 tmp = 0;
-    
-    GTP_DEBUG("[gtp_bak_ref_proc]Driver:%d,Sensor:%d.", driver_num, sensor_num);
-
-    //check file-system mounted 
-    GTP_DEBUG("[gtp_bak_ref_proc]Waiting for FS %d", gtp_ref_retries);        
-    if (gup_check_fs_mounted("/data") == FAIL)        
-    {
-        GTP_DEBUG("[gtp_bak_ref_proc]/data not mounted");
-        if(gtp_ref_retries++ < GTP_CHK_FS_MNT_MAX)
-        {
-            return FAIL;
-        }
-    }
-    else
-    {
-        GTP_DEBUG("[gtp_bak_ref_proc]/data mounted !!!!");
-    }
-    
-    if (is_950)
-    {
-        ref_seg_len = (driver_num * (sensor_num - 1) + 2) * 2;
-        ref_grps = 6;
-        ref_len =  ref_seg_len * 6;  // for GT950, backup-reference for six segments
-    }
-    else
-    {
-        ref_len = driver_num*(sensor_num-2)*2 + 4;
-        ref_seg_len = ref_len;
-        ref_grps = 1;
-    }
-    
-    refp = (u8 *)kzalloc(ref_len, GFP_KERNEL);
-    if(refp == NULL)
-    {
-        GTP_ERROR("Failed to allocate memory for reference buffer!"); 
-        return FAIL;
-    }
-    memset(refp, 0, ref_len);
-    
-    //get ref file data
-    flp = filp_open(GTP_BAK_REF_PATH, O_RDWR | O_CREAT, 0666);
-    if (IS_ERR(flp))
-    {
-        GTP_ERROR("Failed to open/create %s.", GTP_BAK_REF_PATH);
-        if (GTP_BAK_REF_SEND == mode)
-        {
-            goto default_bak_ref;
-        }
-        else
-        {
-            goto exit_ref_proc;
-        }
-    }
-    
-    switch (mode)
-    {
-    case GTP_BAK_REF_SEND:
-        {
-            flp->f_op->llseek(flp, 0, SEEK_SET);
-            ret = flp->f_op->read(flp, (char *)refp, ref_len, &flp->f_pos);
-            if(ret < 0)
-            {
-                GTP_ERROR("Read ref file failed, send default bak ref.");
-                goto default_bak_ref;
-            }
-            //checksum ref file
-            for (j = 0; j < ref_grps; ++j)
-            {
-                ref_chksum = 0;
-                for(i=0; i<ref_seg_len-2; i+=2)
-                {
-                    ref_chksum += ((refp[i + j * ref_seg_len]<<8) + refp[i + 1 + j * ref_seg_len]);
-                }
-            
-                GTP_DEBUG("Reference chksum:0x%04X", ref_chksum&0xFF);
-                tmp = ref_chksum + (refp[ref_seg_len + j * ref_seg_len -2]<<8) + refp[ref_seg_len + j * ref_seg_len -1];
-                if(1 != tmp)
-                {
-                    GTP_DEBUG("Invalid checksum for reference, reset reference.");
-                    memset(&refp[j * ref_seg_len], 0, ref_seg_len);
-                    refp[ref_seg_len - 1 + j * ref_seg_len] = 0x01;
-                }
-                else
-                {
-                    if (j == (ref_grps - 1))
-                    {
-                        GTP_INFO("Reference data in %s used.", GTP_BAK_REF_PATH);
-                    }
-                }
-              
-            }
-            ret = i2c_write_bytes(client, GTP_REG_BAK_REF, refp, ref_len);
-            if(-1 == ret)
-            {
-                GTP_ERROR("Write ref i2c error.");
-                ret = FAIL;
-                goto exit_ref_proc;
-            }
-        }
-        break;
-        
-    case GTP_BAK_REF_STORE:
-        {
-            ret = i2c_read_bytes(client, GTP_REG_BAK_REF, refp, ref_len);
-            if(-1 == ret)
-            {
-                GTP_ERROR("Read ref i2c error.");
-                ret = FAIL;
-                goto exit_ref_proc;
-            }
-            flp->f_op->llseek(flp, 0, SEEK_SET);
-            flp->f_op->write(flp, (char *)refp, ref_len, &flp->f_pos);
-        }
-        break;
-        
-    default:
-        GTP_ERROR("Invalid Argument(%d) for backup reference", mode);
-        ret = FAIL;
-        goto exit_ref_proc;
-    }
-    
-    ret = SUCCESS;
-    goto exit_ref_proc;
-
-default_bak_ref:
-    for (j = 0; j < ref_grps; ++j)
-    {
-        memset(&refp[j * ref_seg_len], 0, ref_seg_len);
-        refp[j * ref_seg_len + ref_seg_len - 1] = 0x01;  // checksum = 1
-    }
-    ret = i2c_write_bytes(client, GTP_REG_BAK_REF, refp, ref_len);
-    if (flp && !IS_ERR(flp))
-    {
-        GTP_INFO("Write backup-reference data into %s", GTP_BAK_REF_PATH);
-        flp->f_op->llseek(flp, 0, SEEK_SET);
-        flp->f_op->write(flp, (char*)refp, ref_len, &flp->f_pos);
-    }
-    if (ret < 0)
-    {
-        GTP_ERROR("Failed to load the default backup reference");
-        ret = FAIL;
-    }
-    else
-    {
-        ret = SUCCESS;
-    }
-exit_ref_proc:
-    if (refp)
-    {
-        kfree(refp);
-    }
-    if (flp && !IS_ERR(flp))
-    {
-        filp_close(flp, NULL);
-    }
-    return ret;
-}
-
-u8 gtp_fw_startup(struct i2c_client *client)
-{
-    u8 wr_buf[4];
-    s32 ret = 0;
-    
-    //init sw WDT
-    wr_buf[0] = 0xAA;
-    ret = i2c_write_bytes(client, 0x8041, wr_buf, 1);
-    if (ret < 0)
-    {
-        GTP_ERROR("I2C error to firmware startup.");
-        return FAIL;
-    }
-    //release SS51 & DSP
-    wr_buf[0] = 0x00;
-    i2c_write_bytes(client, 0x4180, wr_buf, 1);
-    
-    //int sync
-    gtp_int_sync(25);
-    
-    //check fw run status
-    i2c_read_bytes(client, 0x8041, wr_buf, 1);
-    if(0xAA == wr_buf[0])
-    {
-        GTP_ERROR("IC works abnormally,startup failed.");
-        return FAIL;
-    }
-    else
-    {
-        GTP_DEBUG("IC works normally,Startup success.");
-        wr_buf[0] = 0xAA;
-        i2c_write_bytes(client, 0x8041, wr_buf, 1);
-        return SUCCESS;
-    }
-}
-
-
-static void gtp_recovery_reset(struct i2c_client *client)
-{
-#if GTP_ESD_PROTECT
-    gtp_esd_switch(client, SWITCH_OFF);
-#endif
-    force_reset_guitar();
-#if GTP_ESD_PROTECT
-    gtp_esd_switch(client, SWITCH_ON);
-#endif
-}
-
-static u8 gtp_check_clk_legality(u8 *p_clk_buf)
-{
-    u8 i = 0;
-    u8 clk_chksum = p_clk_buf[5];
-    
-    for(i = 0; i < 5; i++)
-    {
-        if((p_clk_buf[i] < 50) || (p_clk_buf[i] > 120) ||
-            (p_clk_buf[i] != p_clk_buf[0]))
-        {
-            break;
-        }
-        clk_chksum += p_clk_buf[i];
-    }
-    
-    if((i == 5) && (clk_chksum == 0))
-    {
-        GTP_DEBUG("Valid main clock data.");
-        return SUCCESS;
-    }
-    GTP_ERROR("Invalid main clock data.");
-    return FAIL;
-}
-
-static u8 gtp_main_clk_proc(struct i2c_client *client)
-{
-    s32 ret = 0;
-    u8  i = 0;
-    u8  clk_cal_result = 0;
-    u8  clk_chksum = 0;
-    u8  gtp_clk_buf[6] = {0};
-    struct file *flp = NULL;
-    
-    GTP_DEBUG("[gtp_main_clk_proc]Waiting for FS %d", gtp_ref_retries);        
-    if (gup_check_fs_mounted("/data") == FAIL)        
-    {            
-        GTP_DEBUG("[gtp_main_clk_proc]/data not mounted");
-        if(gtp_clk_retries++ < GTP_CHK_FS_MNT_MAX)
-        {
-            return FAIL;
-        }
-        else
-        {
-            GTP_ERROR("[gtp_main_clk_proc]Wait for file system timeout,need cal clk");
-        }
-    }
-    else
-    {
-        GTP_DEBUG("[gtp_main_clk_proc]/data mounted !!!!");
-        flp = filp_open(GTP_MAIN_CLK_PATH, O_RDWR | O_CREAT, 0666);
-        if (!IS_ERR(flp))
-        {
-            flp->f_op->llseek(flp, 0, SEEK_SET);
-            ret = flp->f_op->read(flp, (char *)gtp_clk_buf, 6, &flp->f_pos);
-            if(ret > 0)
-            {
-                ret = gtp_check_clk_legality(gtp_clk_buf);
-                if(SUCCESS == ret)
-                {
-                        GTP_DEBUG("[gtp_main_clk_proc]Open & read & check clk file success.");
-                    goto send_main_clk;
-                }
-            }
-        }
-        GTP_ERROR("[gtp_main_clk_proc]Check clk file failed,need cal clk");
-    }
-    
-    //cal clk
-#if GTP_ESD_PROTECT
-    gtp_esd_switch(client, SWITCH_OFF);
-#endif
-    clk_cal_result = gup_clk_calibration();
-    force_reset_guitar();
-    GTP_DEBUG("&&&&&&&&&&clk cal result:%d", clk_cal_result);
-    
-#if GTP_ESD_PROTECT
-    gtp_esd_switch(client, SWITCH_ON);
-#endif  
-
-    if(clk_cal_result < 50 || clk_cal_result > 120)
-    {
-        GTP_ERROR("Invalid main clock: %d", clk_cal_result);
-        ret = FAIL;
-        goto exit_clk_proc;
-    }
-    
-    for(i = 0;i < 5; i++)
-    {
-        gtp_clk_buf[i] = clk_cal_result;
-        clk_chksum += gtp_clk_buf[i];
-    }
-    gtp_clk_buf[5] = 0 - clk_chksum;
-    
-send_main_clk:
-    
-    ret = i2c_write_bytes(client, 0x8020, gtp_clk_buf, 6);
-    
-    if (flp && !IS_ERR(flp))
-    {
-        flp->f_op->llseek(flp, 0, SEEK_SET);
-        flp->f_op->write(flp, (char *)gtp_clk_buf, 6, &flp->f_pos);
-    }
-    
-    if(-1 == ret)
-    {
-        GTP_ERROR("[gtp_main_clk_proc]send main clk i2c error!");
-        ret = FAIL;
-    }
-    else
-    {
-        ret = SUCCESS;
-    }
-    
-exit_clk_proc:
-    if (flp && !IS_ERR(flp))
-    {
-        filp_close(flp, NULL);
-    }
-    return ret;
-}
-
-#endif
-//************* For GT9XXF End **********************//
-
-#if GTP_WITH_PEN
-static void gtp_pen_init(void)
-{
-    s32 ret = 0;
-    
-    pen_dev = input_allocate_device();
-    if (pen_dev == NULL)
-    {
-        GTP_ERROR("Failed to allocate input device for pen/stylus.");
-        return;
-    }
-    
-    pen_dev->evbit[0] = BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS) ;
-    pen_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
-    
-    set_bit(BTN_TOOL_PEN, pen_dev->keybit);
-    set_bit(INPUT_PROP_DIRECT, pen_dev->propbit);
-    //set_bit(INPUT_PROP_POINTER, pen_dev->propbit);
-    
-#if GTP_PEN_HAVE_BUTTON
-    input_set_capability(pen_dev, EV_KEY, BTN_STYLUS);
-    input_set_capability(pen_dev, EV_KEY, BTN_STYLUS2);
-#endif
-
-    input_set_abs_params(pen_dev, ABS_MT_POSITION_X, 0, TPD_RES_X, 0, 0);
-    input_set_abs_params(pen_dev, ABS_MT_POSITION_Y, 0, TPD_RES_Y, 0, 0);
-    input_set_abs_params(pen_dev, ABS_MT_PRESSURE, 0, 255, 0, 0);
-    input_set_abs_params(pen_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
-    input_set_abs_params(pen_dev, ABS_MT_TRACKING_ID, 0, 255, 0, 0);
-    
-    pen_dev->name = "mtk-pen";
-    pen_dev->phys = "input/ts";
-    pen_dev->id.bustype = BUS_I2C;
-    
-    ret = input_register_device(pen_dev);
-    if (ret)
-    {
-        GTP_ERROR("Register %s input device failed", pen_dev->name);
-        return;
-    }
-}
-
-static void gtp_pen_down(s32 x, s32 y, s32 size, s32 id)
-{
-    input_report_key(pen_dev, BTN_TOOL_PEN, 1);
-    input_report_key(pen_dev, BTN_TOUCH, 1);
-    input_report_abs(pen_dev, ABS_MT_POSITION_X, x);
-    input_report_abs(pen_dev, ABS_MT_POSITION_Y, y);
-    if ((!size) && (!id))
-    {
-        input_report_abs(pen_dev, ABS_MT_PRESSURE, 100);
-        input_report_abs(pen_dev, ABS_MT_TOUCH_MAJOR, 100);
-    }
-    else
-    {
-        input_report_abs(pen_dev, ABS_MT_PRESSURE, size);
-        input_report_abs(pen_dev, ABS_MT_TOUCH_MAJOR, size);
-        input_report_abs(pen_dev, ABS_MT_TRACKING_ID, id);
-    }
-    input_mt_sync(pen_dev);
-}
-
-static void gtp_pen_up(void)
-{
-    input_report_key(pen_dev, BTN_TOOL_PEN, 0);
-    input_report_key(pen_dev, BTN_TOUCH, 0);
-}
-#endif
-
-static s32 tpd_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
-{
-    s32 err = 0;
-    s32 ret = 0;
-
-    u16 version_info;
-#if GTP_HAVE_TOUCH_KEY
-    s32 idx = 0;
-#endif
-#ifdef TPD_PROXIMITY
-    struct hwmsen_object obj_ps;
-#endif
-//add at 20150330 by zhu
-#if 1//def MAIERXUN_TP_COM
-    if(touchpanel_flag){
-	return 0;
-     }
-#endif
-//add at 20150330 by zhu end
-    i2c_client_point = client;
-    ret = tpd_power_on(client);
-
-    if (ret < 0)
-    {
-//add at 20150330 by zhu
-#if 1//def MAIERXUN_TP_COM
-       touchpanel_flag=false;
-#endif
-//add at 20150330 by zhu end
-        GTP_ERROR("I2C communication ERROR!");
-	return 0;
-    }
-    
-#ifdef VELOCITY_CUSTOM
-
-    if ((err = misc_register(&tpd_misc_device)))
-    {
-        printk("mtk_tpd: tpd_misc_device register failed\n");
-    }
-
-#endif
-    ret = gtp_read_version(client, &version_info);
-
-    if (ret < 0)
-    {
-        GTP_ERROR("Read version failed.");
-    }    
-    
-    ret = gtp_init_panel(client);
-
-    if (ret < 0)
-    {
-        GTP_ERROR("GTP init panel failed.");
-    }
-    
-    // Create proc file system
-    gt91xx_config_proc = proc_create(GT91XX_CONFIG_PROC_FILE, 0666, NULL, &config_proc_ops);
-    if (gt91xx_config_proc == NULL)
-    {
-        GTP_ERROR("create_proc_entry %s failed\n", GT91XX_CONFIG_PROC_FILE);
-    }
-    else
-    {
-        GTP_INFO("create proc entry %s success", GT91XX_CONFIG_PROC_FILE);
-    }
-
-#if GTP_CREATE_WR_NODE
-    init_wr_node(client);
-#endif
-
-    thread = kthread_run(touch_event_handler, 0, TPD_DEVICE);
-
-    if (IS_ERR(thread))
-    {
-        err = PTR_ERR(thread);
-        GTP_INFO(TPD_DEVICE " failed to create kernel thread: %d\n", err);
-    }
-    
-    
-#if GTP_HAVE_TOUCH_KEY
-
-    for (idx = 0; idx < GTP_MAX_KEY_NUM; idx++)
-    {
-        input_set_capability(tpd->dev, EV_KEY, touch_key_array[idx]);
-    }
-
-#endif
-#if GTP_GESTURE_WAKEUP
-    input_set_capability(tpd->dev, EV_KEY, KEY_POWER);
-#endif
-    
-#if GTP_WITH_PEN
-    gtp_pen_init();
-#endif
-    // set INT mode
-    mt_set_gpio_mode(GPIO_CTP_EINT_PIN, GPIO_CTP_EINT_PIN_M_EINT);
-    mt_set_gpio_dir(GPIO_CTP_EINT_PIN, GPIO_DIR_IN);
-    mt_set_gpio_pull_enable(GPIO_CTP_EINT_PIN, GPIO_PULL_DISABLE);
-
-    msleep(50);
-
-#ifdef MT6572
-    if (!int_type)  //EINTF_TRIGGER
-    {
-        mt_eint_registration(CUST_EINT_TOUCH_PANEL_NUM, EINTF_TRIGGER_RISING, tpd_eint_interrupt_handler, 1);
-    }
-    else
-    {
-        mt_eint_registration(CUST_EINT_TOUCH_PANEL_NUM, EINTF_TRIGGER_FALLING, tpd_eint_interrupt_handler, 1);
-    }
-    
-#else
-   // mt65xx_eint_set_sens(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_SENSITIVE);
-   // mt65xx_eint_set_hw_debounce(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_DEBOUNCE_CN);
-
-    if (!int_type)
-    {
-        mt_eint_registration(CUST_EINT_TOUCH_PANEL_NUM, EINTF_TRIGGER_RISING, tpd_eint_interrupt_handler, 1);
-    }
-    else
-    {
-        mt_eint_registration(CUST_EINT_TOUCH_PANEL_NUM, EINTF_TRIGGER_FALLING, tpd_eint_interrupt_handler, 1);
-    }
-#endif
-
-    mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
-
-#if GTP_AUTO_UPDATE
-    ret = gup_init_update_proc(client);
-
-    if (ret < 0)
-    {
-        GTP_ERROR("Create update thread error.");
-    }
-#endif
-
-#ifdef TPD_PROXIMITY
-    //obj_ps.self = cm3623_obj;
-    obj_ps.polling = 0;         //0--interrupt mode;1--polling mode;
-    obj_ps.sensor_operate = gt9xx_tpd_ps_operate;
-
-    if ((err = hwmsen_attach(ID_PROXIMITY, &obj_ps)))
-    {
-        GTP_ERROR("hwmsen attach fail, return:%d.", err);
-    }
-
-#endif
-
-#if GTP_ESD_PROTECT
-    gtp_esd_switch(client, SWITCH_ON);
-#endif
-   
-    tpd_load_status = 1;
-//add at 20150330 by zhu
-#if 1//def MAIERXUN_TP_COM
-    touchpanel_flag=true;
-#endif
-//add at 20150330 by zhu end
-    return 0;
-}
-
-static void tpd_eint_interrupt_handler(void)
-{
-    TPD_DEBUG_PRINT_INT;
-    
-    tpd_flag = 1;
-    
-    wake_up_interruptible(&waiter);
-}
-static int tpd_i2c_remove(struct i2c_client *client)
-{
-#if GTP_CREATE_WR_NODE
-    uninit_wr_node();
-#endif
-
-#if GTP_ESD_PROTECT
-    destroy_workqueue(gtp_esd_check_workqueue);
-#endif
-
-    return 0;
-}
-#if (GTP_ESD_PROTECT || GTP_COMPATIBLE_MODE)
-static void force_reset_guitar(void)
-{
-    s32 i = 0;
-    s32 ret = 0;
-
-    GTP_INFO("force_reset_guitar");
-    
-    mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
-
-    GTP_GPIO_OUTPUT(GTP_RST_PORT, 0);   
-    GTP_GPIO_OUTPUT(GTP_INT_PORT, 0);
-#ifdef MT6573
-    //Power off TP
-    mt_set_gpio_mode(GPIO_CTP_EN_PIN, GPIO_CTP_EN_PIN_M_GPIO);
-    mt_set_gpio_dir(GPIO_CTP_EN_PIN, GPIO_DIR_OUT);
-    mt_set_gpio_out(GPIO_CTP_EN_PIN, GPIO_OUT_ZERO);  
-    msleep(30);
-    //Power on TP
-    mt_set_gpio_out(GPIO_CTP_EN_PIN, GPIO_OUT_ONE);
-    msleep(30);
-#else           // ( defined(MT6575) || defined(MT6577) || defined(MT6589) )
-    // Power off TP
-    #ifdef TPD_POWER_SOURCE_CUSTOM
-    //    hwPowerDown(TPD_POWER_SOURCE_CUSTOM, "TP");
-    #else
-        hwPowerDown(MT65XX_POWER_LDO_VGP2, "TP");
-    #endif
-        msleep(30); 
-
-    // Power on TP
-    #ifdef TPD_POWER_SOURCE_CUSTOM
-    //    hwPowerOn(TPD_POWER_SOURCE_CUSTOM, VOL_2800, "TP");
-    #else
-        hwPowerOn(MT65XX_POWER_LDO_VGP2, VOL_2800, "TP");
-    #endif
-        msleep(30);
-
-#endif
-
-    for (i = 0; i < 5; i++)
-    {
-    #if GTP_COMPATIBLE_MODE
-        if (CHIP_TYPE_GT9F == gtp_chip_type)
-        {
-            ret = gup_fw_download_proc(NULL, GTP_FL_ESD_RECOVERY);
-            if(FAIL == ret)
-            {
-                GTP_ERROR("[force_reset_guitar]Check & repair fw failed.");
-                continue;
-            }
-            //startup fw
-            ret = gtp_fw_startup(i2c_client_point);
-            if(FAIL == ret)
-            {
-                GTP_ERROR("[force_reset_guitar]Startup fw failed.");
-                continue;
-            }
-            break;
-        }
-        else
-    #endif
-        {
-            //Reset Guitar
-            gtp_reset_guitar(i2c_client_point, 20);
-            msleep(50);
-            //Send config
-            ret = gtp_send_cfg(i2c_client_point);
-    
-            if (ret < 0)
-            {
-                continue;
-            }
-        }
-        break;
-    }
-    mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
-    
-    if (i >= 5)
-    {
-        GTP_ERROR("Failed to reset guitar.");
-        return;
-    }
-    GTP_INFO("Esd recovery successful");
-    return;
-}
-#endif
-
-#if GTP_ESD_PROTECT
-static s32 gtp_init_ext_watchdog(struct i2c_client *client)
-{
-    u8 opr_buffer[2] = {0xAA};
-    GTP_DEBUG("Init external watchdog.");
-    return i2c_write_bytes(client, 0x8041, opr_buffer, 1);
-}
-
-void gtp_esd_switch(struct i2c_client *client, s32 on)
-{
-    spin_lock(&esd_lock);     
-    if (SWITCH_ON == on)     // switch on esd 
-    {
-        if (!esd_running)
-        {
-            esd_running = 1;
-            spin_unlock(&esd_lock);
-            GTP_INFO("Esd started");
-            queue_delayed_work(gtp_esd_check_workqueue, &gtp_esd_check_work, clk_tick_cnt);
-        }
-        else
-        {
-            spin_unlock(&esd_lock);
-        }
-    }
-    else    // switch off esd
-    {
-        if (esd_running)
-        {
-            esd_running = 0;
-            spin_unlock(&esd_lock);
-            GTP_INFO("Esd cancelled");
-            cancel_delayed_work_sync(&gtp_esd_check_work);
-        }
-        else
-        {
-            spin_unlock(&esd_lock);
-        }
-    }
-}
-
-
-static void gtp_esd_check_func(struct work_struct *work)
-{
-    s32 i = 0;
-    s32 ret = -1;
-    u8 esd_buf[3] = {0x00};
-
-    if (tpd_halt)
-    {
-        GTP_INFO("Esd suspended!");
-        return;
-    }
-    for (i = 0; i < 3; i++)
-    {
-        ret = i2c_read_bytes_non_dma(i2c_client_point, 0x8040, esd_buf, 2);
-        
-        GTP_DEBUG("[Esd]0x8040 = 0x%02X, 0x8041 = 0x%02X", esd_buf[0], esd_buf[1]);
-        if (ret < 0)
-        {
-            // IIC communication problem
-            continue;
-        }
-        else 
-        {
-            if ((esd_buf[0] == 0xAA) || (esd_buf[1] != 0xAA))
-            {
-                u8 chk_buf[2] = {0x00};
-                i2c_read_bytes_non_dma(i2c_client_point, 0x8040, chk_buf, 2);
-                
-                GTP_DEBUG("[Check]0x8040 = 0x%02X, 0x8041 = 0x%02X", chk_buf[0], chk_buf[1]);
-                
-                if ( (chk_buf[0] == 0xAA) || (chk_buf[1] != 0xAA) )
-                {
-                    i = 3;          // jump to reset guitar
-                    break;
-                }
-                else
-                {
-                    continue;
-                }
-            }
-            else
-            {
-                // IC works normally, Write 0x8040 0xAA, feed the watchdog
-                esd_buf[0] = 0xAA;
-                i2c_write_bytes_non_dma(i2c_client_point, 0x8040, esd_buf, 1);
-                
-                break;
-            }
-        }
-    }
-
-    if (i >= 3)
-    {   
-    #if GTP_COMPATIBLE_MODE
-        if ((CHIP_TYPE_GT9F == gtp_chip_type) && (1 == rqst_processing))
-        {
-            GTP_INFO("Request Processing, no reset guitar.");
-        }
-        else
-    #endif
-        {
-            GTP_INFO("IC works abnormally! Process reset guitar.");
-            esd_buf[0] = 0x01;
-            esd_buf[1] = 0x01;
-            esd_buf[2] = 0x01;
-            i2c_write_bytes(i2c_client_point, 0x4226, esd_buf, 3);  
-            msleep(50);
-            force_reset_guitar();
-        }
-    }
-
-    if (!tpd_halt)
-    {
-        queue_delayed_work(gtp_esd_check_workqueue, &gtp_esd_check_work, clk_tick_cnt);
-    }
-    else
-    {
-        GTP_INFO("Esd suspended!");
-    }
-
-    return;
-}
-#endif
-
-static void tpd_down(s32 x, s32 y, s32 size, s32 id)
-{
-    if ((!size) && (!id))
-    {
-        input_report_abs(tpd->dev, ABS_MT_PRESSURE, 100);
-        input_report_abs(tpd->dev, ABS_MT_TOUCH_MAJOR, 100);
-    }
-    else
-    {
-        input_report_abs(tpd->dev, ABS_MT_PRESSURE, size);
-        input_report_abs(tpd->dev, ABS_MT_TOUCH_MAJOR, size);
-        /* track id Start 0 */
-        input_report_abs(tpd->dev, ABS_MT_TRACKING_ID, id);
-    }
-
-    input_report_key(tpd->dev, BTN_TOUCH, 1);
-    input_report_abs(tpd->dev, ABS_MT_POSITION_X, x);
-    input_report_abs(tpd->dev, ABS_MT_POSITION_Y, y);
-    input_mt_sync(tpd->dev);
-    TPD_EM_PRINT(x, y, x, y, id, 1);
-
-#if (defined(MT6575)||defined(MT6577))
-
-    if (FACTORY_BOOT == get_boot_mode() || RECOVERY_BOOT == get_boot_mode())
-    {
-        tpd_button(x, y, 1);
-    }
-
-#endif
-}
-
-static void tpd_up(s32 x, s32 y, s32 id)
-{
-    input_report_key(tpd->dev, BTN_TOUCH, 0);
-    input_mt_sync(tpd->dev);
-    TPD_EM_PRINT(x, y, x, y, id, 0);
-
-#if (defined(MT6575) || defined(MT6577))
-
-    if (FACTORY_BOOT == get_boot_mode() || RECOVERY_BOOT == get_boot_mode())
-    {
-        tpd_button(x, y, 0);
-    }
-
-#endif
-}
-#if GTP_CHARGER_SWITCH
-static void gtp_charger_switch(s32 dir_update)
-{
-    u32 chr_status = 0;
-    u8 chr_cmd[3] = {0x80, 0x40};
-    static u8 chr_pluggedin = 0;
-    int ret = 0;
-    
-#ifdef MT6573
-    chr_status = *(volatile u32 *)CHR_CON0;
-    chr_status &= (1 << 13);
-#else   // ( defined(MT6575) || defined(MT6577) || defined(MT6589) )
-    chr_status = upmu_is_chr_det();
-#endif
-    
-    if (chr_status)     // charger plugged in
-    {
-        if (!chr_pluggedin || dir_update)
-        {
-            chr_cmd[2] = 6;
-            ret = gtp_i2c_write(i2c_client_point, chr_cmd, 3);
-            if (ret > 0)
-            {
-                GTP_INFO("Update status for Charger Plugin");
-            }
-            chr_pluggedin = 1;
-        }
-    }
-    else            // charger plugged out
-    {
-        if (chr_pluggedin || dir_update)
-        {
-            chr_cmd[2] = 7;
-            ret = gtp_i2c_write(i2c_client_point, chr_cmd, 3);
-            if (ret > 0)
-            {
-                GTP_INFO("Update status for Charger Plugout");
-            }
-            chr_pluggedin = 0;
-        }
-    }
-}
-#endif
-
-static int touch_event_handler(void *unused)
-{
-    struct sched_param param = { .sched_priority = RTPM_PRIO_TPD };
-    u8  end_cmd[3] = {GTP_READ_COOR_ADDR >> 8, GTP_READ_COOR_ADDR & 0xFF, 0};
-    u8  point_data[2 + 1 + 8 * GTP_MAX_TOUCH + 1] = {GTP_READ_COOR_ADDR >> 8, GTP_READ_COOR_ADDR & 0xFF};
-    u8  touch_num = 0;
-    u8  finger = 0;
-    static u8 pre_touch = 0;
-    static u8 pre_key = 0;
-#if GTP_WITH_PEN
-    u8 pen_active = 0;
-    static u8 pre_pen = 0;
-#endif
-    u8  key_value = 0;
-    u8 *coor_data = NULL;
-    s32 input_x = 0;
-    s32 input_y = 0;
-    s32 input_w = 0;
-    s32 id = 0;
-    s32 i  = 0;
-    s32 ret = -1;
-    
-#if GTP_COMPATIBLE_MODE
-    u8  rqst_data[3] = {(u8)(GTP_REG_RQST >> 8), (u8)(GTP_REG_RQST & 0xFF), 0};
-#endif
-
-#ifdef TPD_PROXIMITY
-    s32 err = 0;
-    hwm_sensor_data sensor_data;
-    u8 proximity_status;
-#endif
-
-#if GTP_GESTURE_WAKEUP
-    u8 doze_buf[3] = {0x81, 0x4B};
-#endif
-
-    sched_setscheduler(current, SCHED_RR, &param);
-    do
-    {
-        set_current_state(TASK_INTERRUPTIBLE);
-        
-        while (tpd_halt)
-        {
-        #if GTP_GESTURE_WAKEUP
-            if (DOZE_ENABLED == doze_status)
-            {
-                break;
-            }
-        #endif
-            tpd_flag = 0;
-            msleep(20);
-        }
-
-        wait_event_interruptible(waiter, tpd_flag != 0);
-        tpd_flag = 0;
-        TPD_DEBUG_SET_TIME;
-        set_current_state(TASK_RUNNING);
-
-    #if GTP_CHARGER_SWITCH
-        gtp_charger_switch(0);
-    #endif
-
-    #if GTP_GESTURE_WAKEUP
-        if (DOZE_ENABLED == doze_status)
-        {
-            ret = gtp_i2c_read(i2c_client_point, doze_buf, 3);
-            GTP_DEBUG("0x814B = 0x%02X", doze_buf[2]);
-            if (ret > 0)
-            {               
-                if ((doze_buf[2] == 'a') || (doze_buf[2] == 'b') || (doze_buf[2] == 'c') ||
-                    (doze_buf[2] == 'd') || (doze_buf[2] == 'e') || (doze_buf[2] == 'g') || 
-                    (doze_buf[2] == 'h') || (doze_buf[2] == 'm') || (doze_buf[2] == 'o') ||
-                    (doze_buf[2] == 'q') || (doze_buf[2] == 's') || (doze_buf[2] == 'v') || 
-                    (doze_buf[2] == 'w') || (doze_buf[2] == 'y') || (doze_buf[2] == 'z') ||
-                    (doze_buf[2] == 0x5E) /* ^ */
-                    )
-                {
-                    if (doze_buf[2] != 0x5E)
-                    {
-                        GTP_INFO("Wakeup by gesture(%c), light up the screen!", doze_buf[2]);
-                    }
-                    else
-                    {
-                        GTP_INFO("Wakeup by gesture(^), light up the screen!");
-                    }
-                    doze_status = DOZE_WAKEUP;
-                    input_report_key(tpd->dev, KEY_POWER, 1);
-                    input_sync(tpd->dev);
-                    input_report_key(tpd->dev, KEY_POWER, 0);
-                    input_sync(tpd->dev);
-                    // clear 0x814B
-                    doze_buf[2] = 0x00;
-                    gtp_i2c_write(i2c_client_point, doze_buf, 3);
-                }
-                else if ( (doze_buf[2] == 0xAA) || (doze_buf[2] == 0xBB) ||
-                    (doze_buf[2] == 0xAB) || (doze_buf[2] == 0xBA) )
-                {
-                    char *direction[4] = {"Right", "Down", "Up", "Left"};
-                    u8 type = ((doze_buf[2] & 0x0F) - 0x0A) + (((doze_buf[2] >> 4) & 0x0F) - 0x0A) * 2;
-                    
-                    GTP_INFO("%s slide to light up the screen!", direction[type]);
-                    doze_status = DOZE_WAKEUP;
-                    input_report_key(tpd->dev, KEY_POWER, 1);
-                    input_sync(tpd->dev);
-                    input_report_key(tpd->dev, KEY_POWER, 0);
-                    input_sync(tpd->dev);
-                    // clear 0x814B
-                    doze_buf[2] = 0x00;
-                    gtp_i2c_write(i2c_client_point, doze_buf, 3);
-                }
-                else if (0xCC == doze_buf[2])
-                {
-                    GTP_INFO("Double click to light up the screen!");
-                    doze_status = DOZE_WAKEUP;
-                    input_report_key(tpd->dev, KEY_POWER, 1);
-                    input_sync(tpd->dev);
-                    input_report_key(tpd->dev, KEY_POWER, 0);
-                    input_sync(tpd->dev);
-                    // clear 0x814B
-                    doze_buf[2] = 0x00;
-                    gtp_i2c_write(i2c_client_point, doze_buf, 3);
-                }
-                else
-                {
-                    // clear 0x814B
-                    doze_buf[2] = 0x00;
-                    gtp_i2c_write(i2c_client_point, doze_buf, 3);
-                    gtp_enter_doze(i2c_client_point);
-                }
-            }
-            continue;
-        }
-    #endif
-        ret = gtp_i2c_read(i2c_client_point, point_data, 12);
-        if (ret < 0)
-        {
-            GTP_ERROR("I2C transfer error. errno:%d\n ", ret);
-            continue;
-        }
-        finger = point_data[GTP_ADDR_LENGTH];
-        
-    #if GTP_COMPATIBLE_MODE
-        if ((finger == 0x00) && (CHIP_TYPE_GT9F == gtp_chip_type))
-        {
-            ret = gtp_i2c_read(i2c_client_point, rqst_data, 3);
-
-            if(ret < 0)
-            {
-                GTP_ERROR("I2C transfer error. errno:%d\n ", ret);
-                continue;
-            }
-            switch (rqst_data[2])
-            {
-                case GTP_RQST_BAK_REF:
-                    GTP_INFO("Request Ref.");
-                    rqst_processing = 1;
-                    ret = gtp_bak_ref_proc(i2c_client_point, GTP_BAK_REF_SEND);
-                    if(SUCCESS == ret)
-                    {
-                        GTP_INFO("Send ref success.");
-                        rqst_data[2] = GTP_RQST_RESPONDED;
-                        gtp_i2c_write(i2c_client_point, rqst_data, 3);
-                        rqst_processing = 0;
-                    }
-                    goto exit_work_func;
-                    
-                case GTP_RQST_CONFIG:
-                    GTP_INFO("Request Config.");
-                    ret = gtp_send_cfg(i2c_client_point);
-                    if (ret < 0)
-                    {
-                        GTP_ERROR("Send config error.");
-                    }
-                    else 
-                    {
-                        GTP_INFO("Send config success.");
-                        rqst_data[2] = GTP_RQST_RESPONDED;
-                        gtp_i2c_write(i2c_client_point, rqst_data, 3);
-                    }
-                    goto exit_work_func;
-                    
-                case GTP_RQST_MAIN_CLOCK:
-                    GTP_INFO("Request main clock.");
-                    rqst_processing = 1;
-                    ret = gtp_main_clk_proc(i2c_client_point);
-                    if(SUCCESS == ret)
-                    {
-                        GTP_INFO("Send main clk success.");
-                        
-                        rqst_data[2] = GTP_RQST_RESPONDED;
-                        gtp_i2c_write(i2c_client_point, rqst_data, 3);
-                        rqst_processing = 0;
-                    }
-                    goto exit_work_func;
-                    
-                case GTP_RQST_RESET:
-                    GTP_INFO("Request Reset.");
-                    gtp_recovery_reset(i2c_client_point);
-                    goto exit_work_func;
-                    
-                default:
-                    GTP_INFO("Undefined request code: 0x%02X", rqst_data[2]);
-                    rqst_data[2] = GTP_RQST_RESPONDED;
-                    gtp_i2c_write(i2c_client_point, rqst_data, 3);
-                    break;
-            }
-        }
-    #endif
-    
-        if (finger == 0x00)
-        {
-            continue;
-        }
-        
-        if ((finger & 0x80) == 0)
-        {
-            goto exit_work_func;
-        }
-        
-    #ifdef TPD_PROXIMITY
-        if (tpd_proximity_flag == 1)
-        {
-            proximity_status = point_data[GTP_ADDR_LENGTH];
-            GTP_DEBUG("REG INDEX[0x814E]:0x%02X\n", proximity_status);
-
-            if (proximity_status & 0x60)                //proximity or large touch detect,enable hwm_sensor.
-            {
-                tpd_proximity_detect = 0;
-                //sensor_data.values[0] = 0;
-            }
-            else
-            {
-                tpd_proximity_detect = 1;
-                //sensor_data.values[0] = 1;
-            }
-
-            //get raw data
-            GTP_DEBUG(" ps change\n");
-            GTP_DEBUG("PROXIMITY STATUS:0x%02X\n", tpd_proximity_detect);
-            //map and store data to hwm_sensor_data
-            sensor_data.values[0] = tpd_get_ps_value();
-            sensor_data.value_divide = 1;
-            sensor_data.status = SENSOR_STATUS_ACCURACY_MEDIUM;
-            //report to the up-layer
-            ret = hwmsen_get_interrupt_data(ID_PROXIMITY, &sensor_data);
-
-            if (ret)
-            {
-                GTP_ERROR("Call hwmsen_get_interrupt_data fail = %d\n", err);
-            }
-        }
-
-    #endif
-
-        touch_num = finger & 0x0f;
-
-        if (touch_num > GTP_MAX_TOUCH)
-        {
-            goto exit_work_func;
-        }
-
-        if (touch_num > 1)
-        {
-            u8 buf[8 * GTP_MAX_TOUCH] = {(GTP_READ_COOR_ADDR + 10) >> 8, (GTP_READ_COOR_ADDR + 10) & 0xff};
-
-            ret = gtp_i2c_read(i2c_client_point, buf, 2 + 8 * (touch_num - 1));
-            memcpy(&point_data[12], &buf[2], 8 * (touch_num - 1));
-        }
-
-    #if (GTP_HAVE_TOUCH_KEY || GTP_PEN_HAVE_BUTTON)
-        key_value = point_data[3 + 8 * touch_num];
-
-        if (key_value || pre_key)
-        {
-        #if GTP_PEN_HAVE_BUTTON
-            if (key_value == 0x40)
-            {
-                GTP_DEBUG("BTN_STYLUS & BTN_STYLUS2 Down.");
-                input_report_key(pen_dev, BTN_STYLUS, 1);
-                input_report_key(pen_dev, BTN_STYLUS2, 1);
-                pen_active = 1;
-            }
-            else if (key_value == 0x10)
-            {
-                GTP_DEBUG("BTN_STYLUS Down, BTN_STYLUS2 Up.");
-                input_report_key(pen_dev, BTN_STYLUS, 1);
-                input_report_key(pen_dev, BTN_STYLUS2, 0);
-                pen_active = 1;
-            }
-            else if (key_value == 0x20)
-            {
-                GTP_DEBUG("BTN_STYLUS Up, BTN_STYLUS2 Down.");
-                input_report_key(pen_dev, BTN_STYLUS, 0);
-                input_report_key(pen_dev, BTN_STYLUS2, 1);
-                pen_active = 1;
-            }
-            else
-            {
-                GTP_DEBUG("BTN_STYLUS & BTN_STYLUS2 Up.");
-                input_report_key(pen_dev, BTN_STYLUS, 0);
-                input_report_key(pen_dev, BTN_STYLUS2, 0);
-                if ( (pre_key == 0x40) || (pre_key == 0x20) ||
-                     (pre_key == 0x10) 
-                   )
-                {
-                    pen_active = 1;
-                }
-            }
-            if (pen_active)
-            {
-                touch_num = 0;      // shield pen point
-                //pre_touch = 0;    // clear last pen status
-            }
-        #endif
-        #if GTP_HAVE_TOUCH_KEY
-            if (!pre_touch)
-            {
-                for (i = 0; i < GTP_MAX_KEY_NUM; i++)
-                {
-                    input_report_key(tpd->dev, touch_key_array[i], key_value & (0x01 << i));
-                }
-                touch_num = 0;  // shiled fingers
-            }
-        #endif
-        }
-    #endif
-        pre_key = key_value;
-
-        GTP_DEBUG("pre_touch:%02x, finger:%02x.", pre_touch, finger);
-        
-        if (touch_num)
-        {
-            for (i = 0; i < touch_num; i++)
-            {
-                coor_data = &point_data[i * 8 + 3];
-
-                id = coor_data[0] & 0x0F;      
-                input_x  = coor_data[1] | coor_data[2] << 8;
-                input_y  = coor_data[3] | coor_data[4] << 8;
-                input_w  = coor_data[5] | coor_data[6] << 8;
-
-                input_x = TPD_WARP_X(abs_x_max, input_x);
-                input_y = TPD_WARP_Y(abs_y_max, input_y);
-
-            #if GTP_WITH_PEN
-                id = coor_data[0];
-                if ((id & 0x80))      // pen/stylus is activated
-                {
-                    GTP_DEBUG("Pen touch DOWN!");
-                    pre_pen = 1;
-                    //id &= 0x7F;
-                    id = 0;
-                    GTP_DEBUG("(%d)(%d, %d)[%d]", id, input_x, input_y, input_w);
-                    gtp_pen_down(input_x, input_y, input_w, id);
-                    pen_active = 1;
-                }
-                else
-            #endif
-                {
-                    GTP_DEBUG(" (%d)(%d, %d)[%d]", id, input_x, input_y, input_w);
-                    tpd_down(input_x, input_y, input_w, id);
-                }
-            }
-        }
-        else
-        {
-            if (pre_touch)
-            {
-            #if GTP_WITH_PEN
-                if (pre_pen)
-                {   
-                    GTP_DEBUG("Pen touch UP!");
-                    gtp_pen_up();
-                    pre_pen = 0;
-                    pen_active = 1;
-                }
-                else
-            #endif
-                {
-                    GTP_DEBUG("Touch Release!");
-                    tpd_up(0, 0, 0);
-                }
-            }
-        }
-        pre_touch = touch_num;
- 
-    #if GTP_WITH_PEN
-        if (pen_active)
-        {
-            pen_active = 0;
-            input_sync(pen_dev);
-        }
-        else
-    #endif
-        {
-            input_sync(tpd->dev);
-        }
-
-exit_work_func:
-
-        if (!gtp_rawdiff_mode)
-        {
-            ret = gtp_i2c_write(i2c_client_point, end_cmd, 3);
-
-            if (ret < 0)
-            {
-                GTP_INFO("I2C write end_cmd  error!");
-            }
-        }
-
-    } while (!kthread_should_stop());
-
-    return 0;
-}
-
-static int tpd_local_init(void)
-{
-#if GTP_ESD_PROTECT
-    clk_tick_cnt = 2 * HZ;   // HZ: clock ticks in 1 second generated by system
-    GTP_DEBUG("Clock ticks for an esd cycle: %d", clk_tick_cnt);
-    INIT_DELAYED_WORK(&gtp_esd_check_work, gtp_esd_check_func);
-    gtp_esd_check_workqueue = create_workqueue("gtp_esd_check");
-    spin_lock_init(&esd_lock);          // 2.6.39 & later
-    // esd_lock = SPIN_LOCK_UNLOCKED;   // 2.6.39 & before
-#endif
-
-#if GTP_SUPPORT_I2C_DMA
-    gpDMABuf_va = (u8 *)dma_alloc_coherent(NULL, GTP_DMA_MAX_TRANSACTION_LENGTH, &gpDMABuf_pa, GFP_KERNEL);
-    if(!gpDMABuf_va){
-        GTP_INFO("[Error] Allocate DMA I2C Buffer failed!\n");
-    }
-    memset(gpDMABuf_va, 0, GTP_DMA_MAX_TRANSACTION_LENGTH);
-#endif
-    if (i2c_add_driver(&tpd_i2c_driver) != 0)
-    {
-        GTP_INFO("unable to add i2c driver.\n");
-        return -1;
-    }
-
-    if (tpd_load_status == 0) //if(tpd_load_status == 0) // disable auto load touch driver for linux3.0 porting
-    {
-        GTP_INFO("add error touch panel driver.\n");
-        i2c_del_driver(&tpd_i2c_driver);
-        return -1;
-    }
-
-#ifdef TPD_HAVE_BUTTON
-    tpd_button_setting(TPD_KEY_COUNT, tpd_keys_local, tpd_keys_dim_local);// initialize tpd button data
-#endif
-
-#if (defined(TPD_WARP_START) && defined(TPD_WARP_END))
-    TPD_DO_WARP = 1;
-    memcpy(tpd_wb_start, tpd_wb_start_local, TPD_WARP_CNT * 4);
-    memcpy(tpd_wb_end, tpd_wb_start_local, TPD_WARP_CNT * 4);
-#endif
-
-#if (defined(TPD_HAVE_CALIBRATION) && !defined(TPD_CUSTOM_CALIBRATION))
-    memcpy(tpd_calmat, tpd_def_calmat_local, 8 * 4);
-    memcpy(tpd_def_calmat, tpd_def_calmat_local, 8 * 4);
-#endif
-
-    // set vendor string
-    tpd->dev->id.vendor = 0x00;
-    tpd->dev->id.product = tpd_info.pid;
-    tpd->dev->id.version = tpd_info.vid;
-
-    GTP_INFO("end %s, %d\n", __FUNCTION__, __LINE__);
-    tpd_type_cap = 1;
-
-    return 0;
-}
-
-#if GTP_GESTURE_WAKEUP
-static s8 gtp_enter_doze(struct i2c_client *client)
-{
-    s8 ret = -1;
-    s8 retry = 0;
-    u8 i2c_control_buf[3] = {(u8)(GTP_REG_SLEEP >> 8), (u8)GTP_REG_SLEEP, 8};
-
-    GTP_DEBUG_FUNC();
-
-    GTP_DEBUG("Entering gesture mode...");
-    while(retry++ < 5)
-    {
-        i2c_control_buf[0] = 0x80;
-        i2c_control_buf[1] = 0x46;
-        ret = gtp_i2c_write(client, i2c_control_buf, 3);
-        if (ret < 0)
-        {
-            GTP_DEBUG("Failed to set gesture flag into 0x8046, %d", retry);
-            continue;
-        }
-        i2c_control_buf[0] = 0x80;
-        i2c_control_buf[1] = 0x40;
-        ret = gtp_i2c_write(client, i2c_control_buf, 3);
-        if (ret > 0)
-        {
-            doze_status = DOZE_ENABLED;
-            GTP_INFO("Gesture mode enabled.");
-            return ret;
-        }
-        msleep(10);
-    }
-    GTP_ERROR("GTP send gesture cmd failed.");
-    return ret;
-}
-
-#else
-/*******************************************************
-Function:
-    Eter sleep function.
-
-Input:
-    client:i2c_client.
-
-Output:
-    Executive outcomes.0--success,non-0--fail.
-*******************************************************/
-static s8 gtp_enter_sleep(struct i2c_client *client)
-{
-#if GTP_COMPATIBLE_MODE
-    if (CHIP_TYPE_GT9F == gtp_chip_type)
-    {
-        u8 i2c_status_buf[3] = {0x80, 0x44, 0x00};
-        s32 ret = 0;
-      
-        ret = gtp_i2c_read(client, i2c_status_buf, 3);
-        if(ret <= 0)
-        {
-             GTP_ERROR("[gtp_enter_sleep]Read ref status reg error.");
-        }
-        
-        if (i2c_status_buf[2] & 0x80)
-        {
-            //Store bak ref
-            ret = gtp_bak_ref_proc(client, GTP_BAK_REF_STORE);
-            if(FAIL == ret)
-            {
-                GTP_ERROR("[gtp_enter_sleep]Store bak ref failed.");
-            }        
-        }
-    }
-#endif
-#if GTP_POWER_CTRL_SLEEP
-
-    GTP_GPIO_OUTPUT(GTP_RST_PORT, 0);   
-    GTP_GPIO_OUTPUT(GTP_INT_PORT, 0);
-    msleep(10);
-
-#ifdef MT6573
-    mt_set_gpio_mode(GPIO_CTP_EN_PIN, GPIO_CTP_EN_PIN_M_GPIO);
-    mt_set_gpio_dir(GPIO_CTP_EN_PIN, GPIO_DIR_OUT);
-    mt_set_gpio_out(GPIO_CTP_EN_PIN, GPIO_OUT_ZERO);  
-    msleep(30);
-#else               // ( defined(MT6575) || defined(MT6577) || defined(MT6589) )
-
-    #ifdef TPD_POWER_SOURCE_1800
-        hwPowerDown(TPD_POWER_SOURCE_1800, "TP");
-    #endif
-    
-    #ifdef TPD_POWER_SOURCE_CUSTOM
-    //    hwPowerDown(TPD_POWER_SOURCE_CUSTOM, "TP");
-    #else
-        hwPowerDown(MT65XX_POWER_LDO_VGP2, "TP");
-    #endif
-#endif
-   
-    GTP_INFO("GTP enter sleep by poweroff!");
-    return 0;
-    
-#else
-    {
-        s8 ret = -1;
-        s8 retry = 0;
-        u8 i2c_control_buf[3] = {(u8)(GTP_REG_SLEEP >> 8), (u8)GTP_REG_SLEEP, 5};
-        
-        
-        GTP_GPIO_OUTPUT(GTP_INT_PORT, 0);
-        msleep(5);
-    
-        while (retry++ < 5)
-        {
-            ret = gtp_i2c_write(client, i2c_control_buf, 3);
-    
-            if (ret > 0)
-            {
-                GTP_INFO("GTP enter sleep!");
-                    
-                return ret;
-            }
-    
-            msleep(10);
-        }
-    
-        GTP_ERROR("GTP send sleep cmd failed.");
-        return ret;
-    }
-#endif
-}
-#endif
-
-/*******************************************************
-Function:
-    Wakeup from sleep mode Function.
-
-Input:
-    client:i2c_client.
-
-Output:
-    Executive outcomes.0--success,non-0--fail.
-*******************************************************/
-static s8 gtp_wakeup_sleep(struct i2c_client *client)
-{
-    u8 retry = 0;
-    s8 ret = -1;
-
-    GTP_DEBUG("GTP wakeup begin.");
-
-#if (GTP_POWER_CTRL_SLEEP)   
-
-#if GTP_COMPATIBLE_MODE
-    if (CHIP_TYPE_GT9F == gtp_chip_type)
-    {
-        force_reset_guitar();
-        GTP_INFO("Esd recovery wakeup.");
-        return 0;
-    }
-#endif
-
-    while (retry++ < 5)
-    {
-        ret = tpd_power_on(client);
-
-        if (ret < 0)
-        {
-            GTP_ERROR("I2C Power on ERROR!");
-            continue;
-        }
-        GTP_INFO("Ic wakeup by poweron");
-        return 0;
-    }
-#else
-
-#if GTP_COMPATIBLE_MODE
-    if (CHIP_TYPE_GT9F == gtp_chip_type)
-    {
-        u8 opr_buf[2] = {0};
-        
-        while (retry++ < 10)
-        {
-            GTP_GPIO_OUTPUT(GTP_INT_PORT, 1);
-            msleep(5);
-            
-            ret = gtp_i2c_test(client);
-    
-            if (ret >= 0)
-            {  
-                // Hold ss51 & dsp
-                opr_buf[0] = 0x0C;
-                ret = i2c_write_bytes(client, 0x4180, opr_buf, 1);
-                if (ret < 0)
-                {
-                    GTP_DEBUG("Hold ss51 & dsp I2C error,retry:%d", retry);
-                    continue;
-                }
-                
-                // Confirm hold
-                opr_buf[0] = 0x00;
-                ret = i2c_read_bytes(client, 0x4180, opr_buf, 1);
-                if (ret < 0)
-                {
-                    GTP_DEBUG("confirm ss51 & dsp hold, I2C error,retry:%d", retry);
-                    continue;
-                }
-                if (0x0C != opr_buf[0])
-                {
-                    GTP_DEBUG("ss51 & dsp not hold, val: %d, retry: %d", opr_buf[0], retry);
-                    continue;
-                }
-                GTP_DEBUG("ss51 & dsp has been hold");
-                
-                ret = gtp_fw_startup(client);
-                if (FAIL == ret)
-                {
-                    GTP_ERROR("[gtp_wakeup_sleep]Startup fw failed.");
-                    continue;
-                }
-                GTP_INFO("flashless wakeup sleep success");
-                return ret;
-            }
-            force_reset_guitar();
-            retry = 0;
-            break;
-        }
-        if (retry >= 10)
-        {
-            GTP_ERROR("wakeup retry timeout, process esd reset");
-            force_reset_guitar();
-        }
-        GTP_ERROR("GTP wakeup sleep failed.");
-        return ret;
-    }
-#endif
-    while (retry++ < 10)
-    {
-    #if GTP_GESTURE_WAKEUP
-        if (DOZE_WAKEUP != doze_status)
-        {
-            GTP_INFO("Powerkey wakeup.");
-        }
-        else
-        {
-            GTP_INFO("Gesture wakeup.");
-        }
-        doze_status = DOZE_DISABLED;
-        
-        mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
-        gtp_reset_guitar(client, 20);
-        mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
-    #else
-    
-        GTP_GPIO_OUTPUT(GTP_INT_PORT, 1);
-        msleep(5);
-    #endif
-        
-        ret = gtp_i2c_test(client);
-
-        if (ret >= 0)
-        {
-            GTP_INFO("GTP wakeup sleep.");
-        #if (!GTP_GESTURE_WAKEUP)
-            {
-                gtp_int_sync(25);
-            #if GTP_ESD_PROTECT
-                gtp_init_ext_watchdog(client);
-            #endif
-            }
-        #endif
-            
-            return ret;
-        }
-        gtp_reset_guitar(client, 20);
-    }
-#endif
-    GTP_ERROR("GTP wakeup sleep failed.");
-    return ret;
-}
-
-/* Function to manage low power suspend */
-static void tpd_suspend(struct early_suspend *h)
-{
-    s32 ret = -1;
-
-    GTP_INFO("System suspend.");
-
-#ifdef TPD_PROXIMITY
-
-    if (tpd_proximity_flag == 1)
-    {
-    	tpd_proximity_flag_one = 1;	//jeff add 20150317
-        return ;
-    }
-
-#endif
-
-    tpd_halt = 1;
-#if GTP_ESD_PROTECT
-    gtp_esd_switch(i2c_client_point, SWITCH_OFF);
-#endif
-    
-#if GTP_GESTURE_WAKEUP
-    ret = gtp_enter_doze(i2c_client_point);
-#else
-    mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
-    ret = gtp_enter_sleep(i2c_client_point);
-#endif
-    if (ret < 0)
-    {
-        GTP_ERROR("GTP early suspend failed.");
-    }
-    // to avoid waking up while not sleeping, delay 48 + 10ms to ensure reliability 
-    msleep(58);
-}
-
-/* Function to manage power-on resume */
-static void tpd_resume(struct early_suspend *h)
-{
-    s32 ret = -1;
-
-    GTP_INFO("System resume.");
-    
-#ifdef TPD_PROXIMITY
-
-    if (tpd_proximity_flag == 1)
-    {
-//        return ;
-	//jeff modify 20150317
-	if(tpd_proximity_flag_one == 1)
-	{
-		tpd_proximity_flag_one = 0;	
-		GTP_INFO(TPD_DEVICE " tpd_proximity_flag_one \n"); 
-		return;
-	}
-    }
-
-#endif
-    ret = gtp_wakeup_sleep(i2c_client_point);
-
-    if (ret < 0)
-    {
-        GTP_ERROR("GTP later resume failed.");
-    }
-    
-#if GTP_COMPATIBLE_MODE
-    if (CHIP_TYPE_GT9F == gtp_chip_type)
-    {
-        // do nothing
-    }
-    else
-#endif
-    {
-        gtp_send_cfg(i2c_client_point);
-    }
-    
-#if GTP_CHARGER_SWITCH
-    gtp_charger_switch(1);  // force update
-#endif
-
-    tpd_halt = 0;
-#if GTP_GESTURE_WAKEUP
-    doze_status = DOZE_DISABLED;
-#else 
-    mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
-#endif
-
-#if GTP_ESD_PROTECT
-    gtp_esd_switch(i2c_client_point, SWITCH_ON);
-#endif
-
-}
-
-static struct tpd_driver_t tpd_device_driver =
-{
-    .tpd_device_name = "gt9xx",
-    .tpd_local_init = tpd_local_init,
-    .suspend = tpd_suspend,
-    .resume = tpd_resume,
-#ifdef TPD_HAVE_BUTTON
-    .tpd_have_button = 1,
-#else
-    .tpd_have_button = 0,
-#endif
-};
-
-/* called when loaded into kernel */
-static int __init tpd_driver_init(void)
-{
-    GTP_INFO("MediaTek gt91xx touch panel driver init\n");
-#ifdef MT6572
-    i2c_register_board_info(I2C_BUS_NUMBER, &i2c_tpd, 1);
-#else
-    i2c_register_board_info(1, &i2c_tpd, 1);
-#endif
-    if (tpd_driver_add(&tpd_device_driver) < 0)
-        GTP_INFO("add generic driver failed\n");
-
-    return 0;
-}
-
-/* should never be called */
-static void __exit tpd_driver_exit(void)
-{
-    GTP_INFO("MediaTek gt91xx touch panel driver exit\n");
-    tpd_driver_remove(&tpd_device_driver);
-}
-
-module_init(tpd_driver_init);
-module_exit(tpd_driver_exit);
-
diff --git a/drivers/input/touchscreen/mediatek/GT915_HD/gt9xx_update.c~ b/drivers/input/touchscreen/mediatek/GT915_HD/gt9xx_update.c~
deleted file mode 100755
index a10ff0d..0000000
--- a/drivers/input/touchscreen/mediatek/GT915_HD/gt9xx_update.c~
+++ /dev/null
@@ -1,3456 +0,0 @@
-/* drivers/input/touchscreen/gt9xx_update.c
- *
- * 2010 - 2012 Goodix Technology.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be a reference
- * to you, when you are integrating the GOODiX's CTP IC into your system,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- * 
- * Version: 2.0   
- * Revision Record: 
- *      V1.0:  first release. by Andrew, 2012/08/27.
- *      V1.2:  modify gt9110p pid map, by Andrew, 2012/10/15
- *      V1.4: 
- *          1. modify gup_enter_update_mode,
- *          2. rewrite i2c read/write func
- *          3. check update file checksum
- *                  by Andrew, 2012/12/12
- *      v1.6:
- *          1. delete GTP_FW_DOWNLOAD related things.
- *          2. add GTP_HEADER_FW_UPDATE switch to update fw by gtp_default_fw in *.h directly
- *                  by Meta, 2013/04/18
- *      V2.0:
- *          1. GT9XXF main clock calibration
- *          2. header fw update no fs related
- *          3. update file searching optimization
- *          4. config update as module, switchable
- *                  by Meta, 2013/08/28
- *      V2.2:
- *          1. multi-system supported
- *          2. flashless update no pid vid compare
- *                          By Meta, 2014/01/14
- */
-#include "tpd.h"
-#include <linux/interrupt.h>
-#include <cust_eint.h>
-#include <linux/i2c.h>
-#include <linux/sched.h>
-#include <linux/kthread.h>
-#include <linux/rtpm_prio.h>
-#include <linux/wait.h>
-#include <linux/time.h>
-#include <linux/delay.h>
-#include <linux/namei.h>
-#include <linux/mount.h>
-#include "cust_gpio_usage.h"
-#include <asm/uaccess.h>
-
-#include "tpd_custom_gt9xx.h"
-
-#if ( (GTP_AUTO_UPDATE && GTP_HEADER_FW_UPDATE) || GTP_COMPATIBLE_MODE )
-    #include "gt9xx_firmware.h"
-#endif
-
-#define GUP_REG_HW_INFO             0x4220
-#define GUP_REG_FW_MSG              0x41E4
-#define GUP_REG_PID_VID             0x8140
-
-#define GUP_SEARCH_FILE_TIMES       50
-#define UPDATE_FILE_PATH_1          "/data/_goodix_update_.bin"
-#define UPDATE_FILE_PATH_2          "/sdcard/_goodix_update_.bin"
-
-#define CONFIG_FILE_PATH_1          "/data/_goodix_config_.cfg"
-#define CONFIG_FILE_PATH_2          "/sdcard/_goodix_config_.cfg"
-
-#define FW_HEAD_LENGTH               14
-#define FW_DOWNLOAD_LENGTH           0x4000
-#define FW_SECTION_LENGTH            0x2000
-#define FW_DSP_ISP_LENGTH            0x1000
-#define FW_DSP_LENGTH                0x1000
-#define FW_BOOT_LENGTH               0x800
-#define FW_SS51_LENGTH               (4 * FW_SECTION_LENGTH)
-#define FW_BOOT_ISP_LENGTH           0x800                     // 2k
-#define FW_GLINK_LENGTH              0x3000                    // 12k
-#define FW_GWAKE_LENGTH              (4 * FW_SECTION_LENGTH)   // 32k
-
-#define PACK_SIZE                    256
-#define MAX_FRAME_CHECK_TIME         5
-
-
-#define _bRW_MISCTL__SRAM_BANK       0x4048
-#define _bRW_MISCTL__MEM_CD_EN       0x4049
-#define _bRW_MISCTL__CACHE_EN        0x404B
-#define _bRW_MISCTL__TMR0_EN         0x40B0
-#define _rRW_MISCTL__SWRST_B0_       0x4180
-#define _bWO_MISCTL__CPU_SWRST_PULSE 0x4184
-#define _rRW_MISCTL__BOOTCTL_B0_     0x4190
-#define _rRW_MISCTL__BOOT_OPT_B0_    0x4218
-#define _rRW_MISCTL__BOOT_CTL_       0x5094
-
-#define AUTO_SEARCH_BIN           0x01
-#define AUTO_SEARCH_CFG           0x02
-#define BIN_FILE_READY            0x80
-#define CFG_FILE_READY            0x08
-#define HEADER_FW_READY           0x01
-
-#pragma pack(1)
-typedef struct
-{
-    u8  hw_info[4];          //hardware info//
-    u8  pid[8];              //product id   //
-    u16 vid;                 //version id   //
-} st_fw_head;
-#pragma pack()
-
-typedef struct
-{
-    u8 force_update;
-    u8 fw_flag;
-    struct file *file;
-    struct file *cfg_file;
-    st_fw_head  ic_fw_msg;
-    mm_segment_t old_fs;
-    u32 fw_total_len;
-    u32 fw_burned_len;
-} st_update_msg;
-
-st_update_msg update_msg;
-extern struct i2c_client *i2c_client_point;
-u16 show_len;
-u16 total_len;
-extern u8 fw_updating;
-extern u8 cfg_len;
-u8 searching_file = 0;
-u8 got_file_flag = 0;
-
-#if GTP_ESD_PROTECT
-extern void gtp_esd_switch(struct i2c_client *client, s32 on);
-#endif
-
-#if GTP_COMPATIBLE_MODE
-extern CHIP_TYPE_T gtp_chip_type;
-extern u8 rqst_processing;
-extern u8 is_950; 
-extern u8 gtp_fw_startup(struct i2c_client *client);
-static u8 gup_check_and_repair(struct i2c_client *, s32 , u8 *, u32 );
-s32 gup_fw_download_proc(void *dir, u8 dwn_mode);
-#endif
-
-#define _CLOSE_FILE(p_file) if (p_file && !IS_ERR(p_file)) \
-                            { \
-                                filp_close(p_file, NULL); \
-                            }
-
-
-static u8 gup_burn_fw_gwake_section(struct i2c_client *client, u8 *fw_section, u16 start_addr, u32 len, u8 bank_cmd );
-
-static s32 gup_i2c_read(struct i2c_client *client, u8 *buf, s32 len)
-{
-    s32 ret = -1;
-    u16 addr = (buf[0] << 8) + buf[1];
-
-    ret = i2c_read_bytes(client, addr, &buf[2], len - 2);
-
-    if (!ret)
-    {
-        return 2;
-    }
-    else
-    {
-        return ret;
-    }
-}
-
-static s32 gup_i2c_write(struct i2c_client *client, u8 *buf, s32 len)
-{
-    s32 ret = -1;
-    u16 addr = (buf[0] << 8) + buf[1];
-
-    ret = i2c_write_bytes(client, addr, &buf[2], len - 2);
-
-    if (!ret)
-    {
-        return 1;
-    }
-    else
-    {
-        return ret;
-    }
-}
-
-static u8 gup_get_ic_msg(struct i2c_client *client, u16 addr, u8 *msg, s32 len)
-{
-    s32 i = 0;
-
-    msg[0] = (addr >> 8) & 0xff;
-    msg[1] = addr & 0xff;
-
-    for (i = 0; i < 5; i++)
-    {
-        if (gup_i2c_read(client, msg, GTP_ADDR_LENGTH + len) > 0)
-        {
-            break;
-        }
-    }
-
-    if (i >= 5)
-    {
-        GTP_ERROR("Read data from 0x%02x%02x failed!", msg[0], msg[1]);
-        return FAIL;
-    }
-
-    return SUCCESS;
-}
-
-static u8 gup_set_ic_msg(struct i2c_client *client, u16 addr, u8 val)
-{
-    s32 i = 0;
-    u8 msg[3];
-
-    msg[0] = (addr >> 8) & 0xff;
-    msg[1] = addr & 0xff;
-    msg[2] = val; 
- 
-    for (i = 0; i < 5; i++)
-    {
-        if (gup_i2c_write(client, msg, GTP_ADDR_LENGTH + 1) > 0)
-        {
-            break;
-        }
-    }
-
-    if (i >= 5)
-    {
-        GTP_ERROR("Set data to 0x%02x%02x failed!", msg[0], msg[1]);
-        return FAIL;
-    }
-
-    return SUCCESS;
-}
-
-static u8 gup_get_ic_fw_msg(struct i2c_client *client)
-{
-    s32 ret = -1;
-    u8  retry = 0;
-    u8  buf[16];
-    u8  i;
-
-    //step1:get hardware info
-    ret = gtp_i2c_read_dbl_check(client, GUP_REG_HW_INFO, &buf[GTP_ADDR_LENGTH], 4);
-    if (FAIL == ret)
-    {
-        GTP_ERROR("[get_ic_fw_msg]get hw_info failed,exit");
-        return FAIL;
-    }
-
-    // buf[2~5]: 00 06 90 00
-    // hw_info: 00 90 06 00
-    for (i = 0; i < 4; i++)
-    {
-        update_msg.ic_fw_msg.hw_info[i] = buf[GTP_ADDR_LENGTH + 3 - i];
-    }
-
-    GTP_INFO("IC Hardware info:%02x%02x%02x%02x", update_msg.ic_fw_msg.hw_info[0], update_msg.ic_fw_msg.hw_info[1],
-             update_msg.ic_fw_msg.hw_info[2], update_msg.ic_fw_msg.hw_info[3]);
-
-    //step2:get firmware message
-    for (retry = 0; retry < 2; retry++)
-    {
-        ret = gup_get_ic_msg(client, GUP_REG_FW_MSG, buf, 1);
-
-        if (FAIL == ret)
-        {
-            GTP_ERROR("Read firmware message fail.");
-            return ret;
-        }
-
-        update_msg.force_update = buf[GTP_ADDR_LENGTH];
-
-        if ((0xBE != update_msg.force_update) && (!retry))
-        {
-            GTP_INFO("The check sum in ic is error.");
-            GTP_INFO("The IC will be updated by force.");
-            continue;
-        }
-        break;
-    }
-
-    GTP_INFO("IC force update flag:0x%x", update_msg.force_update);
-
-    //step3:get pid & vid
-    ret = gtp_i2c_read_dbl_check(client, GUP_REG_PID_VID, &buf[GTP_ADDR_LENGTH], 6);
-    if (FAIL == ret)
-    {
-        GTP_ERROR("[get_ic_fw_msg]get pid & vid failed,exit");
-        return FAIL;
-    }
-
-    memset(update_msg.ic_fw_msg.pid, 0, sizeof(update_msg.ic_fw_msg.pid));
-    memcpy(update_msg.ic_fw_msg.pid, &buf[GTP_ADDR_LENGTH], 4);
-
-
-    //GT9XX PID MAPPING
-    /*|-----FLASH-----RAM-----|
-      |------918------918-----|
-      |------968------968-----|
-      |------913------913-----|
-      |------913P-----913P----|
-      |------927------927-----|
-      |------927P-----927P----|
-      |------9110-----9110----|
-      |------9110P----9111----|*/
-    if(update_msg.ic_fw_msg.pid[0] != 0)
-    {
-        if (!memcmp(update_msg.ic_fw_msg.pid, "9111", 4))
-        {
-            GTP_INFO("IC Mapping Product id:%s", update_msg.ic_fw_msg.pid);
-            memcpy(update_msg.ic_fw_msg.pid, "9110P", 5);
-        }
-    }
-
-    update_msg.ic_fw_msg.vid = buf[GTP_ADDR_LENGTH + 4] + (buf[GTP_ADDR_LENGTH + 5] << 8);
-    return SUCCESS;
-}
-
-s32 gup_enter_update_mode(struct i2c_client *client)
-{
-    s32 ret = -1;
-    s32 retry = 0;
-    u8 rd_buf[3];
-    
-    //step1:RST output low last at least 2ms
-    GTP_GPIO_OUTPUT(GTP_RST_PORT, 0);
-    msleep(2);
-    
-    //step2:select I2C slave addr,INT:0--0xBA;1--0x28.
-    GTP_GPIO_OUTPUT(GTP_INT_PORT, (client->addr == 0x14));
-    msleep(2);
-    
-    //step3:RST output high reset guitar
-    GTP_GPIO_OUTPUT(GTP_RST_PORT, 1);
-    
-    //20121211 modify start
-    msleep(5);
-    while(retry++ < 200)
-    {
-        //step4:Hold ss51 & dsp
-        ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
-        if(ret <= 0)
-        {
-            GTP_DEBUG("Hold ss51 & dsp I2C error,retry:%d", retry);
-            continue;
-        }
-        
-        //step5:Confirm hold
-        ret = gup_get_ic_msg(client, _rRW_MISCTL__SWRST_B0_, rd_buf, 1);
-        if(ret <= 0)
-        {
-            GTP_DEBUG("Hold ss51 & dsp I2C error,retry:%d", retry);
-            continue;
-        }
-        if(0x0C == rd_buf[GTP_ADDR_LENGTH])
-        {
-            GTP_DEBUG("Hold ss51 & dsp confirm SUCCESS");
-            break;
-        }
-        GTP_DEBUG("Hold ss51 & dsp confirm 0x4180 failed,value:%d", rd_buf[GTP_ADDR_LENGTH]);
-    }
-    if(retry >= 200)
-    {
-        GTP_ERROR("Enter update Hold ss51 failed.");
-        return FAIL;
-    }
-    
-    //step6:DSP_CK and DSP_ALU_CK PowerOn
-    ret = gup_set_ic_msg(client, 0x4010, 0x00);
-    
-    //20121211 modify end
-    return ret;
-}
-
-void gup_leave_update_mode(void)
-{
-    GTP_GPIO_AS_INT(GTP_INT_PORT);
-    
-    GTP_DEBUG("[leave_update_mode]reset chip.");
-    gtp_reset_guitar(i2c_client_point, 20);
-}
-
-static u8 gup_enter_update_judge(st_fw_head *fw_head)
-{
-    u16 u16_tmp;
-    s32 i = 0;
-    u32 fw_len = 0;
-    s32 pid_cmp_len = 0;
-    //Get the correct nvram data
-    //The correct conditions:
-    //1. the hardware info is the same
-    //2. the product id is the same
-    //3. the firmware version in update file is greater than the firmware version in ic
-    //or the check sum in ic is wrong
-
-    u16_tmp = fw_head->vid;
-    fw_head->vid = (u16)(u16_tmp >> 8) + (u16)(u16_tmp << 8);
-
-    GTP_INFO("FILE HARDWARE INFO:%02x%02x%02x%02x", fw_head->hw_info[0], fw_head->hw_info[1], fw_head->hw_info[2], fw_head->hw_info[3]);
-    GTP_INFO("FILE PID:%s", fw_head->pid);
-    GTP_INFO("FILE VID:%04x", fw_head->vid);
-    GTP_INFO("IC HARDWARE INFO:%02x%02x%02x%02x", update_msg.ic_fw_msg.hw_info[0], update_msg.ic_fw_msg.hw_info[1],
-             update_msg.ic_fw_msg.hw_info[2], update_msg.ic_fw_msg.hw_info[3]);
-    GTP_INFO("IC PID:%s", update_msg.ic_fw_msg.pid);
-    GTP_INFO("IC VID:%04x", update_msg.ic_fw_msg.vid);
-    
-    if (!memcmp(fw_head->pid, "9158", 4) && !memcmp(update_msg.ic_fw_msg.pid, "915S", 4))
-    {
-        GTP_INFO("Update GT915S to GT9158 directly!");
-        return SUCCESS;
-    }
-
-    if (!memcmp(fw_head->hw_info, update_msg.ic_fw_msg.hw_info, sizeof(update_msg.ic_fw_msg.hw_info)))
-    {
-        fw_len = 42 * 1024;
-    }
-    else
-    {
-        fw_len = fw_head->hw_info[3];
-        fw_len += (((u32)fw_head->hw_info[2]) << 8);
-        fw_len += (((u32)fw_head->hw_info[1]) << 16);
-        fw_len += (((u32)fw_head->hw_info[0]) << 24);
-    }
-    if (update_msg.fw_total_len != fw_len)
-    {
-        GTP_ERROR("Inconsistent firmware size, Update aborted! Default size: %d(%dK), actual size: %d(%dK)", fw_len, fw_len/1024, update_msg.fw_total_len, update_msg.fw_total_len/1024);
-        return FAIL;
-    }
-    GTP_INFO("Firmware length:%d(%dK)", update_msg.fw_total_len, update_msg.fw_total_len/1024);
-    
-    if (update_msg.force_update != 0xBE)
-    {
-        GTP_INFO("FW chksum error,need enter update.");
-        return SUCCESS;
-    }
-    // 20130523 start
-    if (strlen(update_msg.ic_fw_msg.pid) < 3)
-    {
-        GTP_INFO("Illegal IC pid, need enter update");
-        return SUCCESS;
-    }
-    else
-    {
-        for (i = 0; i < 3; i++)
-        {
-            if ((update_msg.ic_fw_msg.pid[i] < 0x30) || (update_msg.ic_fw_msg.pid[i] > 0x39))
-            {
-                GTP_INFO("Illegal IC pid, out of bound, need enter update");
-                return SUCCESS;
-            }
-        }
-    }
-    // 20130523 end
-    
-    pid_cmp_len = strlen(fw_head->pid);
-    if (pid_cmp_len < strlen(update_msg.ic_fw_msg.pid))
-    {
-        pid_cmp_len = strlen(update_msg.ic_fw_msg.pid);
-    }
-    
-    if ((!memcmp(fw_head->pid, update_msg.ic_fw_msg.pid, pid_cmp_len)) ||
-            (!memcmp(update_msg.ic_fw_msg.pid, "91XX", 4))||
-            (!memcmp(fw_head->pid, "91XX", 4)))
-    {
-        if(!memcmp(fw_head->pid, "91XX", 4))
-        {
-            GTP_DEBUG("Force none same pid update mode.");
-        }
-        else
-        {
-            GTP_DEBUG("Get the same pid.");
-        }
-
-        //The third condition
-        if (fw_head->vid > update_msg.ic_fw_msg.vid)
-        {
-
-            GTP_INFO("Need enter update.");
-            return SUCCESS;
-        }
-
-        GTP_INFO("Don't meet the third condition.");
-        GTP_ERROR("File VID <= IC VID, update aborted!");
-    }
-    else
-    {
-        GTP_ERROR("File PID != IC PID, update aborted!");
-    }
-
-    return FAIL;
-}
-
-#if GTP_AUTO_UPDATE_CFG
-static u8 ascii2hex(u8 a)
-{
-    s8 value = 0;
-
-    if(a >= '0' && a <= '9')
-    {
-        value = a - '0';
-    }
-    else if(a >= 'A' && a <= 'F')
-    {
-        value = a - 'A' + 0x0A;
-    }
-    else if(a >= 'a' && a <= 'f')
-    {
-        value = a - 'a' + 0x0A;
-    }
-    else
-    {
-        value = 0xff;
-    }
-    
-    return value;
-}
-
-static s8 gup_update_config(struct i2c_client *client)
-{
-    s32 file_len = 0;
-    s32 ret = 0;
-    s32 i = 0;
-    s32 file_cfg_len = 0;
-    s32 chip_cfg_len = 0;
-    s32 count = 0;
-    u8 *buf;
-    u8 *pre_buf;
-    u8 *file_config;
-    //u8 checksum = 0;
-    
-    if(NULL == update_msg.cfg_file)
-    {
-        GTP_ERROR("[update_cfg]No need to upgrade config!");
-        return FAIL;
-    }
-    file_len = update_msg.cfg_file->f_op->llseek(update_msg.cfg_file, 0, SEEK_END);
-    
-    chip_cfg_len = cfg_len;
-    
-    GTP_DEBUG("[update_cfg]config file len:%d", file_len);
-    GTP_DEBUG("[update_cfg]need config len:%d",chip_cfg_len);
-    if((file_len+5) < chip_cfg_len*5)
-    {
-        GTP_ERROR("Config length error");
-        return -1;
-    }
-    
-    buf = (u8*)kzalloc(file_len, GFP_KERNEL);
-    pre_buf = (u8*)kzalloc(file_len, GFP_KERNEL);
-    file_config = (u8*)kzalloc(chip_cfg_len + GTP_ADDR_LENGTH, GFP_KERNEL);
-    update_msg.cfg_file->f_op->llseek(update_msg.cfg_file, 0, SEEK_SET);
-    
-    GTP_DEBUG("[update_cfg]Read config from file.");
-    ret = update_msg.cfg_file->f_op->read(update_msg.cfg_file, (char*)pre_buf, file_len, &update_msg.cfg_file->f_pos);
-    if(ret<0)
-    {
-        GTP_ERROR("[update_cfg]Read config file failed.");
-        goto update_cfg_file_failed;
-    }
-    
-    GTP_DEBUG("[update_cfg]Delete illgal charactor.");
-    for(i=0,count=0; i<file_len; i++)
-    {
-        if (pre_buf[i] == ' ' || pre_buf[i] == '\r' || pre_buf[i] == '\n')
-        {
-            continue;
-        }
-        buf[count++] = pre_buf[i];
-    }
-    
-    GTP_DEBUG("[update_cfg]Ascii to hex.");
-    file_config[0] = GTP_REG_CONFIG_DATA >> 8;
-    file_config[1] = GTP_REG_CONFIG_DATA & 0xff;
-    for(i=0,file_cfg_len=GTP_ADDR_LENGTH; i<count; i+=5)
-    {
-        if((buf[i]=='0') && ((buf[i+1]=='x') || (buf[i+1]=='X')))
-        {
-            u8 high,low;
-            high = ascii2hex(buf[i+2]);
-            low = ascii2hex(buf[i+3]);
-            
-            if((high == 0xFF) || (low == 0xFF))
-            {
-                ret = 0;
-                GTP_ERROR("[update_cfg]Illegal config file.");
-                goto update_cfg_file_failed;
-            }
-            file_config[file_cfg_len++] = (high<<4) + low;
-        }
-        else
-        {
-            ret = 0;
-            GTP_ERROR("[update_cfg]Illegal config file.");
-            goto update_cfg_file_failed;
-        }
-    }
-    
-    
-    GTP_DEBUG("config:");
-    GTP_DEBUG_ARRAY(file_config+2, file_cfg_len);
-    
-    i = 0;
-    while(i++ < 5)
-    {
-        ret = gup_i2c_write(client, file_config, file_cfg_len);
-        if(ret > 0)
-        {
-            GTP_INFO("[update_cfg]Send config SUCCESS.");
-            break;
-        }
-        GTP_ERROR("[update_cfg]Send config i2c error.");
-    }
-    
-update_cfg_file_failed:
-    kfree(pre_buf);
-    kfree(buf);
-    kfree(file_config);
-    return ret;
-}
-
-#endif 
-
-#if (GTP_AUTO_UPDATE && (!GTP_HEADER_FW_UPDATE || GTP_AUTO_UPDATE_CFG))
-static void gup_search_file(s32 search_type)
-{
-    s32 i = 0;
-    struct file *pfile = NULL;
-
-    got_file_flag = 0x00;
-    
-    searching_file = 1;
-    for (i = 0; i < GUP_SEARCH_FILE_TIMES; ++i)
-    {            
-        if (0 == searching_file)
-        {
-            GTP_INFO("Force exiting file searching");
-            got_file_flag = 0x00;
-            return;
-        }
-        
-        if (search_type & AUTO_SEARCH_BIN)
-        {
-            GTP_DEBUG("Search for %s, %s for fw update.(%d/%d)", UPDATE_FILE_PATH_1, UPDATE_FILE_PATH_2, i+1, GUP_SEARCH_FILE_TIMES);
-            pfile = filp_open(UPDATE_FILE_PATH_1, O_RDONLY, 0);
-            if (IS_ERR(pfile))
-            {
-                pfile = filp_open(UPDATE_FILE_PATH_2, O_RDONLY, 0);
-                if (!IS_ERR(pfile))
-                {
-                    GTP_INFO("Bin file: %s for fw update.", UPDATE_FILE_PATH_2);
-                    got_file_flag |= BIN_FILE_READY;
-                    update_msg.file = pfile;
-                }
-            }
-            else
-            {
-                GTP_INFO("Bin file: %s for fw update.", UPDATE_FILE_PATH_1);
-                got_file_flag |= BIN_FILE_READY;
-                update_msg.file = pfile;
-            }
-            if (got_file_flag & BIN_FILE_READY)
-            {
-            #if GTP_AUTO_UPDATE_CFG
-                if (search_type & AUTO_SEARCH_CFG)
-                {
-                    i = GUP_SEARCH_FILE_TIMES;    // Bin & Cfg File required to be in the same directory
-                }
-                else
-            #endif
-                {
-                    searching_file = 0;
-                    return;
-                }
-            }
-        }
-    
-    #if GTP_AUTO_UPDATE_CFG
-        if ( (search_type & AUTO_SEARCH_CFG) && !(got_file_flag & CFG_FILE_READY) )
-        {
-            GTP_DEBUG("Search for %s, %s for config update.(%d/%d)", CONFIG_FILE_PATH_1, CONFIG_FILE_PATH_2, i+1, GUP_SEARCH_FILE_TIMES);
-            pfile = filp_open(CONFIG_FILE_PATH_1, O_RDONLY, 0);
-            if (IS_ERR(pfile))
-            {
-                pfile = filp_open(CONFIG_FILE_PATH_2, O_RDONLY, 0);
-                if (!IS_ERR(pfile))
-                {
-                    GTP_INFO("Cfg file: %s for config update.", CONFIG_FILE_PATH_2);
-                    got_file_flag |= CFG_FILE_READY;
-                    update_msg.cfg_file = pfile;
-                }
-            }
-            else
-            {
-                GTP_INFO("Cfg file: %s for config update.", CONFIG_FILE_PATH_1);
-                got_file_flag |= CFG_FILE_READY;
-                update_msg.cfg_file = pfile;
-            }
-            if (got_file_flag & CFG_FILE_READY)
-            {
-                searching_file = 0;
-                return;
-            }
-        }
-    #endif
-        msleep(3000);
-    }
-    searching_file = 0;
-}
-#endif
-
-static u8 gup_check_update_file(struct i2c_client *client, st_fw_head *fw_head, u8 *path)
-{
-    s32 ret = 0;
-    s32 i = 0;
-    s32 fw_checksum = 0;
-    u8 buf[FW_HEAD_LENGTH];
-
-    got_file_flag = 0x00;
-    if (path)
-    {
-        GTP_DEBUG("Update File path:%s, %d", path, strlen(path));
-        update_msg.file = filp_open(path, O_RDONLY, 0);
-
-        if (IS_ERR(update_msg.file))
-        {
-            GTP_ERROR("Open update file(%s) error!", path);
-            return FAIL;
-        }
-        got_file_flag = BIN_FILE_READY;
-    }
-    else
-    {
-#if GTP_AUTO_UPDATE
-    #if GTP_HEADER_FW_UPDATE
-        GTP_INFO("Update by default firmware array");
-        update_msg.fw_total_len = sizeof(gtp_default_FW) - FW_HEAD_LENGTH;
-        if (sizeof(gtp_default_FW) < (FW_HEAD_LENGTH + FW_SECTION_LENGTH*4+FW_DSP_ISP_LENGTH+FW_DSP_LENGTH+FW_BOOT_LENGTH))
-        {
-            GTP_ERROR("INVALID gtp_default_FW, check your gt9xx_firmware.h file!");
-            return FAIL;
-        }
-        GTP_DEBUG("Firmware actual size: %d(%dK)", update_msg.fw_total_len, update_msg.fw_total_len/1024);
-        memcpy(fw_head, &gtp_default_FW[0], FW_HEAD_LENGTH);
-        
-        //check firmware legality
-        fw_checksum = 0;
-        for (i = 0; i < update_msg.fw_total_len; i += 2)
-        {
-            fw_checksum += (gtp_default_FW[FW_HEAD_LENGTH + i] << 8) + gtp_default_FW[FW_HEAD_LENGTH + i + 1];
-        }
-        
-        GTP_DEBUG("firmware checksum:%x", fw_checksum&0xFFFF);
-        if(fw_checksum&0xFFFF)
-        {
-            GTP_ERROR("Illegal firmware file.");
-            return FAIL;
-        }
-        got_file_flag = HEADER_FW_READY;
-        return SUCCESS;
-        
-    #else
-        #if GTP_AUTO_UPDATE_CFG
-            gup_search_file(AUTO_SEARCH_BIN | AUTO_SEARCH_CFG);
-            if (got_file_flag & CFG_FILE_READY)
-            {
-                ret = gup_update_config(client);
-            	if(ret <= 0)
-                {
-                    GTP_ERROR("Update config failed!");
-                }
-                _CLOSE_FILE(update_msg.cfg_file);
-                msleep(500);                //waiting config to be stored in FLASH.
-            }
-        #else
-            gup_search_file(AUTO_SEARCH_BIN);
-        #endif
-
-            if (!(got_file_flag & BIN_FILE_READY))
-            {
-                GTP_ERROR("No bin file for fw Update");
-                return FAIL;
-            }
-    #endif
-#else
-        {
-            GTP_ERROR("NULL file for fw update!");
-            return FAIL;
-        }
-#endif
-    }
-    
-    update_msg.old_fs = get_fs();
-    set_fs(KERNEL_DS);
-    
-    update_msg.file->f_op->llseek(update_msg.file, 0, SEEK_SET);
-    update_msg.fw_total_len = update_msg.file->f_op->llseek(update_msg.file, 0, SEEK_END);
-    
-    if (update_msg.fw_total_len < (FW_HEAD_LENGTH + FW_SECTION_LENGTH*4+FW_DSP_ISP_LENGTH+FW_DSP_LENGTH+FW_BOOT_LENGTH))
-    {
-        GTP_ERROR("INVALID bin file(size: %d), update aborted.", update_msg.fw_total_len);
-        return FAIL;
-    }
-    
-    update_msg.fw_total_len -= FW_HEAD_LENGTH;
-    
-    GTP_DEBUG("Bin firmware actual size: %d(%dK)", update_msg.fw_total_len, update_msg.fw_total_len/1024);
-    
-    update_msg.file->f_op->llseek(update_msg.file, 0, SEEK_SET);
-    ret = update_msg.file->f_op->read(update_msg.file, (char *)buf, FW_HEAD_LENGTH, &update_msg.file->f_pos);
-    if (ret < 0)
-    {
-        GTP_ERROR("Read firmware head in update file error.");
-        return FAIL;
-    }
-
-    memcpy(fw_head, buf, FW_HEAD_LENGTH);
-    
-    //check firmware legality
-    fw_checksum = 0;
-    for(i=0; i < update_msg.fw_total_len; i+=2)
-    {
-        u16 temp;
-        ret = update_msg.file->f_op->read(update_msg.file, (char*)buf, 2, &update_msg.file->f_pos);
-        if (ret < 0)
-        {
-            GTP_ERROR("Read firmware file error.");
-            return FAIL;
-        }
-        //GTP_DEBUG("BUF[0]:%x", buf[0]);
-        temp = (buf[0]<<8) + buf[1];
-        fw_checksum += temp;
-    }
-    
-    GTP_DEBUG("firmware checksum:%x", fw_checksum&0xFFFF);
-    if(fw_checksum&0xFFFF)
-    {
-        GTP_ERROR("Illegal firmware file.");
-        return FAIL;
-    }
-    
-    return SUCCESS;
-}
-
-static u8 gup_burn_proc(struct i2c_client *client, u8 *burn_buf, u16 start_addr, u16 total_length)
-{
-    s32 ret = 0;
-    u16 burn_addr = start_addr;
-    u16 frame_length = 0;
-    u16 burn_length = 0;
-    u8  wr_buf[PACK_SIZE + GTP_ADDR_LENGTH];
-    u8  rd_buf[PACK_SIZE + GTP_ADDR_LENGTH];
-    u8  retry = 0;
-
-    GTP_DEBUG("Begin burn %dk data to addr 0x%x", (total_length / 1024), start_addr);
-
-    while (burn_length < total_length)
-    {
-        GTP_DEBUG("B/T:%04d/%04d", burn_length, total_length);
-        frame_length = ((total_length - burn_length) > PACK_SIZE) ? PACK_SIZE : (total_length - burn_length);
-        wr_buf[0] = (u8)(burn_addr >> 8);
-        rd_buf[0] = wr_buf[0];
-        wr_buf[1] = (u8)burn_addr;
-        rd_buf[1] = wr_buf[1];
-        memcpy(&wr_buf[GTP_ADDR_LENGTH], &burn_buf[burn_length], frame_length);
-
-        for (retry = 0; retry < MAX_FRAME_CHECK_TIME; retry++)
-        {
-            ret = gup_i2c_write(client, wr_buf, GTP_ADDR_LENGTH + frame_length);
-
-            if (ret <= 0)
-            {
-                GTP_ERROR("Write frame data i2c error.");
-                continue;
-            }
-
-            ret = gup_i2c_read(client, rd_buf, GTP_ADDR_LENGTH + frame_length);
-
-            if (ret <= 0)
-            {
-                GTP_ERROR("Read back frame data i2c error.");
-                continue;
-            }
-
-            if (memcmp(&wr_buf[GTP_ADDR_LENGTH], &rd_buf[GTP_ADDR_LENGTH], frame_length))
-            {
-                GTP_ERROR("Check frame data fail,not equal.");
-                GTP_DEBUG("write array:");
-                GTP_DEBUG_ARRAY(&wr_buf[GTP_ADDR_LENGTH], frame_length);
-                GTP_DEBUG("read array:");
-                GTP_DEBUG_ARRAY(&rd_buf[GTP_ADDR_LENGTH], frame_length);
-                continue;
-            }
-            else
-            {
-                //GTP_DEBUG("Check frame data success.");
-                break;
-            }
-        }
-        if(retry >= MAX_FRAME_CHECK_TIME)
-        {
-            GTP_ERROR("Burn frame data time out,exit.");
-            return FAIL;
-        }
-        burn_length += frame_length;
-        burn_addr += frame_length;
-    }
-    return SUCCESS;
-}
-
-static u8 gup_load_section_file(u8 *buf, u32 offset, u16 length, u8 set_or_end)
-{
-#if (GTP_AUTO_UPDATE && GTP_HEADER_FW_UPDATE)
-    if (HEADER_FW_READY == got_file_flag)
-    {
-        if(SEEK_SET == set_or_end)
-        {
-            memcpy(buf, &gtp_default_FW[FW_HEAD_LENGTH + offset], length);
-        }
-        else    //seek end
-        {
-            memcpy(buf, &gtp_default_FW[update_msg.fw_total_len + FW_HEAD_LENGTH - offset], length);
-        }
-        return SUCCESS;
-    }
-#endif
-    {
-        s32 ret = 0;
-    
-        if ( (update_msg.file == NULL) || IS_ERR(update_msg.file))
-        {
-            GTP_ERROR("cannot find update file,load section file fail.");
-            return FAIL;
-        }
-        
-        if(SEEK_SET == set_or_end)
-        {
-            update_msg.file->f_pos = FW_HEAD_LENGTH + offset;
-        }
-        else    //seek end
-        {
-            update_msg.file->f_pos = update_msg.fw_total_len + FW_HEAD_LENGTH - offset;
-        }
-    
-        ret = update_msg.file->f_op->read(update_msg.file, (char *)buf, length, &update_msg.file->f_pos);
-    
-        if (ret < 0)
-        {
-            GTP_ERROR("Read update file fail.");
-            return FAIL;
-        }
-    
-        return SUCCESS;
-    }
-}
-
-static u8 gup_recall_check(struct i2c_client *client, u8 *chk_src, u16 start_rd_addr, u16 chk_length)
-{
-    u8  rd_buf[PACK_SIZE + GTP_ADDR_LENGTH];
-    s32 ret = 0;
-    u16 recall_addr = start_rd_addr;
-    u16 recall_length = 0;
-    u16 frame_length = 0;
-
-    while (recall_length < chk_length)
-    {
-        frame_length = ((chk_length - recall_length) > PACK_SIZE) ? PACK_SIZE : (chk_length - recall_length);
-        ret = gup_get_ic_msg(client, recall_addr, rd_buf, frame_length);
-
-        if (ret <= 0)
-        {
-            GTP_ERROR("recall i2c error,exit");
-            return FAIL;
-        }
-
-        if (memcmp(&rd_buf[GTP_ADDR_LENGTH], &chk_src[recall_length], frame_length))
-        {
-            GTP_ERROR("Recall frame data fail,not equal.");
-            GTP_DEBUG("chk_src array:");
-            GTP_DEBUG_ARRAY(&chk_src[recall_length], frame_length);
-            GTP_DEBUG("recall array:");
-            GTP_DEBUG_ARRAY(&rd_buf[GTP_ADDR_LENGTH], frame_length);
-            return FAIL;
-        }
-
-        recall_length += frame_length;
-        recall_addr += frame_length;
-    }
-
-    GTP_DEBUG("Recall check %dk firmware success.", (chk_length / 1024));
-
-    return SUCCESS;
-}
-
-static u8 gup_burn_fw_section(struct i2c_client *client, u8 *fw_section, u16 start_addr, u8 bank_cmd)
-{
-    s32 ret = 0;
-    u8  rd_buf[5];
-
-    //step1:hold ss51 & dsp
-    ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
-
-    if (ret <= 0)
-    {
-        GTP_ERROR("[burn_fw_section]hold ss51 & dsp fail.");
-        return FAIL;
-    }
-
-    //step2:set scramble
-    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x00);
-
-    if (ret <= 0)
-    {
-        GTP_ERROR("[burn_fw_section]set scramble fail.");
-        return FAIL;
-    }
-
-    //step3:select bank
-    ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK, (bank_cmd >> 4) & 0x0F);
-
-    if (ret <= 0)
-    {
-        GTP_ERROR("[burn_fw_section]select bank %d fail.", (bank_cmd >> 4) & 0x0F);
-        return FAIL;
-    }
-
-    //step4:enable accessing code
-    ret = gup_set_ic_msg(client, _bRW_MISCTL__MEM_CD_EN, 0x01);
-
-    if (ret <= 0)
-    {
-        GTP_ERROR("[burn_fw_section]enable accessing code fail.");
-        return FAIL;
-    }
-
-    //step5:burn 8k fw section
-    ret = gup_burn_proc(client, fw_section, start_addr, FW_SECTION_LENGTH);
-
-    if (FAIL == ret)
-    {
-        GTP_ERROR("[burn_fw_section]burn fw_section fail.");
-        return FAIL;
-    }
-
-    //step6:hold ss51 & release dsp
-    ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x04);
-
-    if (ret <= 0)
-    {
-        GTP_ERROR("[burn_fw_section]hold ss51 & release dsp fail.");
-        return FAIL;
-    }
-
-    //must delay
-    msleep(1);
-
-    //step7:send burn cmd to move data to flash from sram
-    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, bank_cmd & 0x0f);
-
-    if (ret <= 0)
-    {
-        GTP_ERROR("[burn_fw_section]send burn cmd fail.");
-        return FAIL;
-    }
-
-    GTP_DEBUG("[burn_fw_section]Wait for the burn is complete......");
-
-    do
-    {
-        ret = gup_get_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, rd_buf, 1);
-
-        if (ret <= 0)
-        {
-            GTP_ERROR("[burn_fw_section]Get burn state fail");
-            return FAIL;
-        }
-
-        msleep(10);
-        //GTP_DEBUG("[burn_fw_section]Get burn state:%d.", rd_buf[GTP_ADDR_LENGTH]);
-    }
-    while (rd_buf[GTP_ADDR_LENGTH]);
-
-    //step8:select bank
-    ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK, (bank_cmd >> 4) & 0x0F);
-
-    if (ret <= 0)
-    {
-        GTP_ERROR("[burn_fw_section]select bank %d fail.", (bank_cmd >> 4) & 0x0F);
-        return FAIL;
-    }
-
-    //step9:enable accessing code
-    ret = gup_set_ic_msg(client, _bRW_MISCTL__MEM_CD_EN, 0x01);
-
-    if (ret <= 0)
-    {
-        GTP_ERROR("[burn_fw_section]enable accessing code fail.");
-        return FAIL;
-    }
-
-    //step10:recall 8k fw section
-    ret = gup_recall_check(client, fw_section, start_addr, FW_SECTION_LENGTH);
-
-    if (FAIL == ret)
-    {
-        GTP_ERROR("[burn_fw_section]recall check %dk firmware fail.", FW_SECTION_LENGTH/1024);
-        return FAIL;
-    }
-
-    //step11:disable accessing code
-    ret = gup_set_ic_msg(client, _bRW_MISCTL__MEM_CD_EN, 0x00);
-
-    if (ret <= 0)
-    {
-        GTP_ERROR("[burn_fw_section]disable accessing code fail.");
-        return FAIL;
-    }
-
-    return SUCCESS;
-}
-
-static u8 gup_burn_dsp_isp(struct i2c_client *client)
-{
-    s32 ret = 0;
-    u8 *fw_dsp_isp = NULL;
-    u8  retry = 0;
-    //u32 offset;
-
-    GTP_INFO("[burn_dsp_isp]Begin burn dsp isp---->>");
-
-    //step1:alloc memory
-    GTP_DEBUG("[burn_dsp_isp]step1:alloc memory");
-
-    while (retry++ < 5)
-    {
-        fw_dsp_isp = (u8 *)kzalloc(FW_DSP_ISP_LENGTH, GFP_KERNEL);
-
-        if (fw_dsp_isp == NULL)
-        {
-            continue;
-        }
-        else
-        {
-            GTP_DEBUG("[burn_dsp_isp]Alloc %dk byte memory success.", (FW_DSP_ISP_LENGTH / 1024));
-            break;
-        }
-    }
-
-    if (retry >= 5)
-    {
-        GTP_ERROR("[burn_dsp_isp]Alloc memory fail,exit.");
-        return FAIL;
-    }
-
-    //step2:load dsp isp file data
-    GTP_DEBUG("[burn_dsp_isp]step2:load dsp isp file data");
-    ret = gup_load_section_file(fw_dsp_isp, FW_DSP_ISP_LENGTH, FW_DSP_ISP_LENGTH, SEEK_END);
-    
-    if (FAIL == ret)
-    {
-        GTP_ERROR("[burn_dsp_isp]load firmware dsp_isp fail.");
-        goto exit_burn_dsp_isp;
-    }
-
-    //step3:disable wdt,clear cache enable
-    GTP_DEBUG("[burn_dsp_isp]step3:disable wdt,clear cache enable");
-    ret = gup_set_ic_msg(client, _bRW_MISCTL__TMR0_EN, 0x00);
-
-    if (ret <= 0)
-    {
-        GTP_ERROR("[burn_dsp_isp]disable wdt fail.");
-        ret = FAIL;
-        goto exit_burn_dsp_isp;
-    }
-
-    ret = gup_set_ic_msg(client, _bRW_MISCTL__CACHE_EN, 0x00);
-
-    if (ret <= 0)
-    {
-        GTP_ERROR("[burn_dsp_isp]clear cache enable fail.");
-        ret = FAIL;
-        goto exit_burn_dsp_isp;
-    }
-
-    //step4:hold ss51 & dsp
-    GTP_DEBUG("[burn_dsp_isp]step4:hold ss51 & dsp");
-    ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
-
-    if (ret <= 0)
-    {
-        GTP_ERROR("[burn_dsp_isp]hold ss51 & dsp fail.");
-        ret = FAIL;
-        goto exit_burn_dsp_isp;
-    }
-
-    //step5:set boot from sram
-    GTP_DEBUG("[burn_dsp_isp]step5:set boot from sram");
-    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOTCTL_B0_, 0x02);
-
-    if (ret <= 0)
-    {
-        GTP_ERROR("[burn_dsp_isp]set boot from sram fail.");
-        ret = FAIL;
-        goto exit_burn_dsp_isp;
-    }
-
-    //step6:software reboot
-    GTP_DEBUG("[burn_dsp_isp]step6:software reboot");
-    ret = gup_set_ic_msg(client, _bWO_MISCTL__CPU_SWRST_PULSE, 0x01);
-
-    if (ret <= 0)
-    {
-        GTP_ERROR("[burn_dsp_isp]software reboot fail.");
-        ret = FAIL;
-        goto exit_burn_dsp_isp;
-    }
-
-    //step7:select bank2
-    GTP_DEBUG("[burn_dsp_isp]step7:select bank2");
-    ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK, 0x02);
-
-    if (ret <= 0)
-    {
-        GTP_ERROR("[burn_dsp_isp]select bank2 fail.");
-        ret = FAIL;
-        goto exit_burn_dsp_isp;
-    }
-
-    //step8:enable accessing code
-    GTP_DEBUG("[burn_dsp_isp]step8:enable accessing code");
-    ret = gup_set_ic_msg(client, _bRW_MISCTL__MEM_CD_EN, 0x01);
-
-    if (ret <= 0)
-    {
-        GTP_ERROR("[burn_dsp_isp]enable accessing code fail.");
-        ret = FAIL;
-        goto exit_burn_dsp_isp;
-    }
-
-    //step9:burn 4k dsp_isp
-    GTP_DEBUG("[burn_dsp_isp]step9:burn 4k dsp_isp");
-    ret = gup_burn_proc(client, fw_dsp_isp, 0xC000, FW_DSP_ISP_LENGTH);
-
-    if (FAIL == ret)
-    {
-        GTP_ERROR("[burn_dsp_isp]burn dsp_isp fail.");
-        goto exit_burn_dsp_isp;
-    }
-
-    //step10:set scramble
-    GTP_DEBUG("[burn_dsp_isp]step10:set scramble");
-    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x00);
-
-    if (ret <= 0)
-    {
-        GTP_ERROR("[burn_dsp_isp]set scramble fail.");
-        ret = FAIL;
-        goto exit_burn_dsp_isp;
-    }
-    
-    update_msg.fw_burned_len += FW_DSP_ISP_LENGTH;
-    GTP_DEBUG("[burn_dsp_isp]Burned length:%d", update_msg.fw_burned_len);
-    ret = SUCCESS;
-
-exit_burn_dsp_isp:
-    kfree(fw_dsp_isp);
-    return ret;
-}
-
-static u8 gup_burn_fw_ss51(struct i2c_client *client)
-{
-    u8 *fw_ss51 = NULL;
-    u8  retry = 0;
-    s32 ret = 0;
-
-    GTP_INFO("[burn_fw_ss51]Begin burn ss51 firmware---->>");
-
-    //step1:alloc memory
-    GTP_DEBUG("[burn_fw_ss51]step1:alloc memory");
-
-    while (retry++ < 5)
-    {
-        fw_ss51 = (u8 *)kzalloc(FW_SECTION_LENGTH, GFP_KERNEL);
-
-        if (fw_ss51 == NULL)
-        {
-            continue;
-        }
-        else
-        {
-            GTP_DEBUG("[burn_fw_ss51]Alloc %dk byte memory success.", (FW_SECTION_LENGTH / 1024));
-            break;
-        }
-    }
-
-    if (retry >= 5)
-    {
-        GTP_ERROR("[burn_fw_ss51]Alloc memory fail,exit.");
-        return FAIL;
-    }
-
-    //step2:load ss51 firmware section 1 file data
-    //GTP_DEBUG("[burn_fw_ss51]step2:load ss51 firmware section 1 file data");
-    //ret = gup_load_section_file(fw_ss51, 0, FW_SECTION_LENGTH, SEEK_SET);
-//	
-//    if (FAIL == ret)
-//    {
-//        GTP_ERROR("[burn_fw_ss51]load ss51 firmware section 1 fail.");
-//        goto exit_burn_fw_ss51;
-//    }
-    GTP_INFO("[burn_fw_ss51]Reset first 8K of ss51 to 0xFF.");
-    GTP_DEBUG("[burn_fw_ss51]step2: reset bank0 0xC000~0xD000");
-    memset(fw_ss51, 0xFF, FW_SECTION_LENGTH);
-		
-    //step3:clear control flag
-    GTP_DEBUG("[burn_fw_ss51]step3:clear control flag");
-    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x00);
-
-    if (ret <= 0)
-    {
-        GTP_ERROR("[burn_fw_ss51]clear control flag fail.");
-        ret = FAIL;
-        goto exit_burn_fw_ss51;
-    }
-
-    //step4:burn ss51 firmware section 1
-    GTP_DEBUG("[burn_fw_ss51]step4:burn ss51 firmware section 1");
-    ret = gup_burn_fw_section(client, fw_ss51, 0xC000, 0x01);
-
-    if (FAIL == ret)
-    {
-        GTP_ERROR("[burn_fw_ss51]burn ss51 firmware section 1 fail.");
-        goto exit_burn_fw_ss51;
-    }
-
-    //step5:load ss51 firmware section 2 file data
-    GTP_DEBUG("[burn_fw_ss51]step5:load ss51 firmware section 2 file data");
-    ret = gup_load_section_file(fw_ss51, FW_SECTION_LENGTH, FW_SECTION_LENGTH, SEEK_SET);
-
-    if (FAIL == ret)
-    {
-        GTP_ERROR("[burn_fw_ss51]load ss51 firmware section 2 fail.");
-        goto exit_burn_fw_ss51;
-    }
-
-    //step6:burn ss51 firmware section 2
-    GTP_DEBUG("[burn_fw_ss51]step6:burn ss51 firmware section 2");
-    ret = gup_burn_fw_section(client, fw_ss51, 0xE000, 0x02);
-
-    if (FAIL == ret)
-    {
-        GTP_ERROR("[burn_fw_ss51]burn ss51 firmware section 2 fail.");
-        goto exit_burn_fw_ss51;
-    }
-
-    //step7:load ss51 firmware section 3 file data
-    GTP_DEBUG("[burn_fw_ss51]step7:load ss51 firmware section 3 file data");
-    ret = gup_load_section_file(fw_ss51, 2 * FW_SECTION_LENGTH, FW_SECTION_LENGTH, SEEK_SET);
-
-    if (FAIL == ret)
-    {
-        GTP_ERROR("[burn_fw_ss51]load ss51 firmware section 3 fail.");
-        goto exit_burn_fw_ss51;
-    }
-
-    //step8:burn ss51 firmware section 3
-    GTP_DEBUG("[burn_fw_ss51]step8:burn ss51 firmware section 3");
-    ret = gup_burn_fw_section(client, fw_ss51, 0xC000, 0x13);
-
-    if (FAIL == ret)
-    {
-        GTP_ERROR("[burn_fw_ss51]burn ss51 firmware section 3 fail.");
-        goto exit_burn_fw_ss51;
-    }
-
-    //step9:load ss51 firmware section 4 file data
-    GTP_DEBUG("[burn_fw_ss51]step9:load ss51 firmware section 4 file data");
-    ret = gup_load_section_file(fw_ss51, 3 * FW_SECTION_LENGTH, FW_SECTION_LENGTH, SEEK_SET);
-
-    if (FAIL == ret)
-    {
-        GTP_ERROR("[burn_fw_ss51]load ss51 firmware section 4 fail.");
-        goto exit_burn_fw_ss51;
-    }
-
-    //step10:burn ss51 firmware section 4
-    GTP_DEBUG("[burn_fw_ss51]step10:burn ss51 firmware section 4");
-    ret = gup_burn_fw_section(client, fw_ss51, 0xE000, 0x14);
-
-    if (FAIL == ret)
-    {
-        GTP_ERROR("[burn_fw_ss51]burn ss51 firmware section 4 fail.");
-        goto exit_burn_fw_ss51;
-    }
-    
-    update_msg.fw_burned_len += (FW_SECTION_LENGTH*4);
-    GTP_DEBUG("[burn_fw_ss51]Burned length:%d", update_msg.fw_burned_len);
-    ret = SUCCESS;
-
-exit_burn_fw_ss51:
-    kfree(fw_ss51);
-    return ret;
-}
-
-static u8 gup_burn_fw_dsp(struct i2c_client *client)
-{
-    s32 ret = 0;
-    u8 *fw_dsp = NULL;
-    u8  retry = 0;
-    u8  rd_buf[5];
-
-    GTP_INFO("[burn_fw_dsp]Begin burn dsp firmware---->>");
-    //step1:alloc memory
-    GTP_DEBUG("[burn_fw_dsp]step1:alloc memory");
-
-    while (retry++ < 5)
-    {
-        fw_dsp = (u8 *)kzalloc(FW_DSP_LENGTH, GFP_KERNEL);
-
-        if (fw_dsp == NULL)
-        {
-            continue;
-        }
-        else
-        {
-            GTP_DEBUG("[burn_fw_dsp]Alloc %dk byte memory success.", (FW_SECTION_LENGTH / 1024));
-            break;
-        }
-    }
-
-    if (retry >= 5)
-    {
-        GTP_ERROR("[burn_fw_dsp]Alloc memory fail,exit.");
-        return FAIL;
-    }
-
-    //step2:load firmware dsp
-    GTP_DEBUG("[burn_fw_dsp]step2:load firmware dsp");
-    ret = gup_load_section_file(fw_dsp, 4 * FW_SECTION_LENGTH, FW_DSP_LENGTH, SEEK_SET);
-
-    if (FAIL == ret)
-    {
-        GTP_ERROR("[burn_fw_dsp]load firmware dsp fail.");
-        goto exit_burn_fw_dsp;
-    }
-
-    //step3:select bank3
-    GTP_DEBUG("[burn_fw_dsp]step3:select bank3");
-    ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK, 0x03);
-
-    if (ret <= 0)
-    {
-        GTP_ERROR("[burn_fw_dsp]select bank3 fail.");
-        ret = FAIL;
-        goto exit_burn_fw_dsp;
-    }
-
-    //step4:hold ss51 & dsp
-    GTP_DEBUG("[burn_fw_dsp]step4:hold ss51 & dsp");
-    ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
-
-    if (ret <= 0)
-    {
-        GTP_ERROR("[burn_fw_dsp]hold ss51 & dsp fail.");
-        ret = FAIL;
-        goto exit_burn_fw_dsp;
-    }
-
-    //step5:set scramble
-    GTP_DEBUG("[burn_fw_dsp]step5:set scramble");
-    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x00);
-
-    if (ret <= 0)
-    {
-        GTP_ERROR("[burn_fw_dsp]set scramble fail.");
-        ret = FAIL;
-        goto exit_burn_fw_dsp;
-    }
-
-    //step6:release ss51 & dsp
-    GTP_DEBUG("[burn_fw_dsp]step6:release ss51 & dsp");
-    ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x04);             //20121212
-
-    if (ret <= 0)
-    {
-        GTP_ERROR("[burn_fw_dsp]release ss51 & dsp fail.");
-        ret = FAIL;
-        goto exit_burn_fw_dsp;
-    }
-
-    //must delay
-    msleep(1);
-
-    //step7:burn 4k dsp firmware
-    GTP_DEBUG("[burn_fw_dsp]step7:burn 4k dsp firmware");
-    ret = gup_burn_proc(client, fw_dsp, 0x9000, FW_DSP_LENGTH);
-
-    if (FAIL == ret)
-    {
-        GTP_ERROR("[burn_fw_dsp]burn fw_section fail.");
-        goto exit_burn_fw_dsp;
-    }
-
-    //step8:send burn cmd to move data to flash from sram
-    GTP_DEBUG("[burn_fw_dsp]step8:send burn cmd to move data to flash from sram");
-    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x05);
-
-    if (ret <= 0)
-    {
-        GTP_ERROR("[burn_fw_dsp]send burn cmd fail.");
-        goto exit_burn_fw_dsp;
-    }
-
-    GTP_DEBUG("[burn_fw_dsp]Wait for the burn is complete......");
-
-    do
-    {
-        ret = gup_get_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, rd_buf, 1);
-
-        if (ret <= 0)
-        {
-            GTP_ERROR("[burn_fw_dsp]Get burn state fail");
-            goto exit_burn_fw_dsp;
-        }
-
-        msleep(10);
-        //GTP_DEBUG("[burn_fw_dsp]Get burn state:%d.", rd_buf[GTP_ADDR_LENGTH]);
-    }
-    while (rd_buf[GTP_ADDR_LENGTH]);
-
-    //step9:recall check 4k dsp firmware
-    GTP_DEBUG("[burn_fw_dsp]step9:recall check 4k dsp firmware");
-    ret = gup_recall_check(client, fw_dsp, 0x9000, FW_DSP_LENGTH);
-
-    if (FAIL == ret)
-    {
-        GTP_ERROR("[burn_fw_dsp]recall check 4k dsp firmware fail.");
-        goto exit_burn_fw_dsp;
-    }
-    
-    update_msg.fw_burned_len += FW_DSP_LENGTH;
-    GTP_DEBUG("[burn_fw_dsp]Burned length:%d", update_msg.fw_burned_len);
-    ret = SUCCESS;
-
-exit_burn_fw_dsp:
-    kfree(fw_dsp);
-    return ret;
-}
-
-static u8 gup_burn_fw_boot(struct i2c_client *client)
-{
-    s32 ret = 0;
-    u8* fw_boot = NULL;
-    u8  retry = 0;
-    u8  rd_buf[5];
-    
-    GTP_INFO("[burn_fw_boot]Begin burn bootloader firmware---->>");
-    
-    //step1:Alloc memory
-    GTP_DEBUG("[burn_fw_boot]step1:Alloc memory");
-
-    while(retry++ < 5)
-    {
-        fw_boot = (u8*)kzalloc(FW_BOOT_LENGTH, GFP_KERNEL);
-
-        if(fw_boot == NULL)
-        {
-            continue;
-        }
-        else
-        {
-            GTP_DEBUG("[burn_fw_boot]Alloc %dk byte memory success.", (FW_BOOT_LENGTH/1024));
-            break;
-        }
-    }
-
-    if(retry >= 5)
-    {
-        GTP_ERROR("[burn_fw_boot]Alloc memory fail,exit.");
-        return FAIL;
-    }
-    
-    //step2:load firmware bootloader
-    GTP_DEBUG("[burn_fw_boot]step2:load firmware bootloader");
-    ret = gup_load_section_file(fw_boot, (4 * FW_SECTION_LENGTH + FW_DSP_LENGTH), FW_BOOT_LENGTH, SEEK_SET);
-
-    if(FAIL == ret)
-    {
-        GTP_ERROR("[burn_fw_boot]load firmware bootcode fail.");
-        goto exit_burn_fw_boot;
-    }
-    
-    //step3:hold ss51 & dsp
-    GTP_DEBUG("[burn_fw_boot]step3:hold ss51 & dsp");
-    ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
-    if(ret <= 0)
-    {
-        GTP_ERROR("[burn_fw_boot]hold ss51 & dsp fail.");
-        ret = FAIL;
-        goto exit_burn_fw_boot;
-    }
-    
-    //step4:set scramble
-    GTP_DEBUG("[burn_fw_boot]step4:set scramble");
-    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x00);
-    if(ret <= 0)
-    {
-        GTP_ERROR("[burn_fw_boot]set scramble fail.");
-        ret = FAIL;
-        goto exit_burn_fw_boot;
-    }
-    
-    //step5:hold ss51 & release dsp
-    GTP_DEBUG("[burn_fw_boot]step5:hold ss51 & release dsp");
-    ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x04);                 //20121211
-    if(ret <= 0)
-    {
-        GTP_ERROR("[burn_fw_boot]release ss51 & dsp fail.");
-        ret = FAIL;
-        goto exit_burn_fw_boot;
-    }
-    //must delay
-    msleep(1);
-    
-    //step6:select bank3
-    GTP_DEBUG("[burn_fw_boot]step6:select bank3");
-    ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK, 0x03);
-    if(ret <= 0)
-    {
-        GTP_ERROR("[burn_fw_boot]select bank3 fail.");
-        ret = FAIL;
-        goto exit_burn_fw_boot;
-    }
-    
-    //step7:burn 2k bootloader firmware
-    GTP_DEBUG("[burn_fw_boot]step7:burn 2k bootloader firmware");
-    ret = gup_burn_proc(client, fw_boot, 0x9000, FW_BOOT_LENGTH);
-    if(FAIL == ret)
-    {
-        GTP_ERROR("[burn_fw_boot]burn fw_boot fail.");
-        goto exit_burn_fw_boot;
-    }
-    
-    //step7:send burn cmd to move data to flash from sram
-    GTP_DEBUG("[burn_fw_boot]step7:send burn cmd to move data to flash from sram");
-    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x06);
-    if(ret <= 0)
-    {
-        GTP_ERROR("[burn_fw_boot]send burn cmd fail.");
-        goto exit_burn_fw_boot;
-    }
-    GTP_DEBUG("[burn_fw_boot]Wait for the burn is complete......");
-    do{
-        ret = gup_get_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, rd_buf, 1);
-        if(ret <= 0)
-        {
-            GTP_ERROR("[burn_fw_boot]Get burn state fail");
-            goto exit_burn_fw_boot;
-        }
-        msleep(10);
-        //GTP_DEBUG("[burn_fw_boot]Get burn state:%d.", rd_buf[GTP_ADDR_LENGTH]);
-    }while(rd_buf[GTP_ADDR_LENGTH]);
-    
-    //step8:recall check 2k bootloader firmware
-    GTP_DEBUG("[burn_fw_boot]step8:recall check 2k bootloader firmware");
-    ret = gup_recall_check(client, fw_boot, 0x9000, FW_BOOT_LENGTH);
-    if(FAIL == ret)
-    {
-        GTP_ERROR("[burn_fw_boot]recall check 2k bootcode firmware fail.");
-        goto exit_burn_fw_boot;
-    }
-    
-    update_msg.fw_burned_len += FW_BOOT_LENGTH;
-    GTP_DEBUG("[burn_fw_boot]Burned length:%d", update_msg.fw_burned_len);
-    ret = SUCCESS;
-    
-exit_burn_fw_boot:
-    kfree(fw_boot);
-    return ret;
-}
-
-
-static u8 gup_burn_fw_boot_isp(struct i2c_client *client)
-{
-    s32 ret = 0;
-    u8* fw_boot_isp = NULL;
-    u8  retry = 0;
-    u8  rd_buf[5];
-    
-    if(update_msg.fw_burned_len >= update_msg.fw_total_len)
-    {
-        GTP_DEBUG("No need to upgrade the boot_isp code!");
-        return SUCCESS;
-    }
-    GTP_INFO("[burn_fw_boot_isp]Begin burn boot_isp firmware---->>");
-    
-    //step1:Alloc memory
-    GTP_DEBUG("[burn_fw_boot_isp]step1:Alloc memory");
-    while(retry++ < 5)
-    {
-        fw_boot_isp = (u8*)kzalloc(FW_BOOT_ISP_LENGTH, GFP_KERNEL);
-        if(fw_boot_isp == NULL)
-        {
-            continue;
-        }
-        else
-        {
-            GTP_DEBUG("[burn_fw_boot_isp]Alloc %dk byte memory success.", (FW_BOOT_ISP_LENGTH/1024));
-            break;
-        }
-    }
-    if(retry >= 5)
-    {
-        GTP_ERROR("[burn_fw_boot_isp]Alloc memory fail,exit.");
-        return FAIL;
-    }
-    
-    //step2:load firmware bootloader
-    GTP_DEBUG("[burn_fw_boot_isp]step2:load firmware bootloader isp");
-    //ret = gup_load_section_file(fw_boot_isp, (4*FW_SECTION_LENGTH+FW_DSP_LENGTH+FW_BOOT_LENGTH+FW_DSP_ISP_LENGTH), FW_BOOT_ISP_LENGTH, SEEK_SET);
-    ret = gup_load_section_file(fw_boot_isp, (update_msg.fw_burned_len - FW_DSP_ISP_LENGTH), FW_BOOT_ISP_LENGTH, SEEK_SET);
-    if(FAIL == ret)
-    {
-        GTP_ERROR("[burn_fw_boot_isp]load firmware boot_isp fail.");
-        goto exit_burn_fw_boot_isp;
-    }
-    
-    //step3:hold ss51 & dsp
-    GTP_DEBUG("[burn_fw_boot_isp]step3:hold ss51 & dsp");
-    ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
-    if(ret <= 0)
-    {
-        GTP_ERROR("[burn_fw_boot_isp]hold ss51 & dsp fail.");
-        ret = FAIL;
-        goto exit_burn_fw_boot_isp;
-    }
-    
-    //step4:set scramble
-    GTP_DEBUG("[burn_fw_boot_isp]step4:set scramble");
-    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x00);
-    if(ret <= 0)
-    {
-        GTP_ERROR("[burn_fw_boot_isp]set scramble fail.");
-        ret = FAIL;
-        goto exit_burn_fw_boot_isp;
-    }
-    
-    
-    //step5:hold ss51 & release dsp
-    GTP_DEBUG("[burn_fw_boot_isp]step5:hold ss51 & release dsp");
-    ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x04);                 //20121211
-    if(ret <= 0)
-    {
-        GTP_ERROR("[burn_fw_boot_isp]release ss51 & dsp fail.");
-        ret = FAIL;
-        goto exit_burn_fw_boot_isp;
-    }
-    //must delay
-    msleep(1);
-    
-    //step6:select bank3
-    GTP_DEBUG("[burn_fw_boot_isp]step6:select bank3");
-    ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK, 0x03);
-    if(ret <= 0)
-    {
-        GTP_ERROR("[burn_fw_boot_isp]select bank3 fail.");
-        ret = FAIL;
-        goto exit_burn_fw_boot_isp;
-    }
-    
-    //step7:burn 2k bootload_isp firmware
-    GTP_DEBUG("[burn_fw_boot_isp]step7:burn 2k bootloader firmware");
-    ret = gup_burn_proc(client, fw_boot_isp, 0x9000, FW_BOOT_ISP_LENGTH);
-    if(FAIL == ret)
-    {
-        GTP_ERROR("[burn_fw_boot_isp]burn fw_section fail.");
-        goto exit_burn_fw_boot_isp;
-    }
-    
-    //step7:send burn cmd to move data to flash from sram
-    GTP_DEBUG("[burn_fw_boot_isp]step8:send burn cmd to move data to flash from sram");
-    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x07);
-    if(ret <= 0)
-    {
-        GTP_ERROR("[burn_fw_boot_isp]send burn cmd fail.");
-        goto exit_burn_fw_boot_isp;
-    }
-    GTP_DEBUG("[burn_fw_boot_isp]Wait for the burn is complete......");
-    do{
-        ret = gup_get_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, rd_buf, 1);
-        if(ret <= 0)
-        {
-            GTP_ERROR("[burn_fw_boot_isp]Get burn state fail");
-            goto exit_burn_fw_boot_isp;
-        }
-        msleep(10);
-        //GTP_DEBUG("[burn_fw_boot_isp]Get burn state:%d.", rd_buf[GTP_ADDR_LENGTH]);
-    }while(rd_buf[GTP_ADDR_LENGTH]);
-    
-    //step8:recall check 2k bootload_isp firmware
-    GTP_DEBUG("[burn_fw_boot_isp]step9:recall check 2k bootloader firmware");
-    ret = gup_recall_check(client, fw_boot_isp, 0x9000, FW_BOOT_ISP_LENGTH);
-    if(FAIL == ret)
-    {
-        GTP_ERROR("[burn_fw_boot_isp]recall check 2k bootcode_isp firmware fail.");
-        goto exit_burn_fw_boot_isp;
-    }
-    
-    update_msg.fw_burned_len += FW_BOOT_ISP_LENGTH;
-    GTP_DEBUG("[burn_fw_boot_isp]Burned length:%d", update_msg.fw_burned_len);
-    ret = SUCCESS;
-    
-exit_burn_fw_boot_isp:
-    kfree(fw_boot_isp);
-    return ret;
-}
-
-static u8 gup_burn_fw_link(struct i2c_client *client)
-{
-    s32 ret = 0;
-    u8* fw_link = NULL;
-    u8  retry = 0;
-    u32 offset;
-    
-    if(update_msg.fw_burned_len >= update_msg.fw_total_len)
-    {
-        GTP_DEBUG("No need to upgrade the link code!");
-        return SUCCESS;
-    }
-    GTP_INFO("[burn_fw_link]Begin burn link firmware---->>");
-    
-    //step1:Alloc memory
-    GTP_DEBUG("[burn_fw_link]step1:Alloc memory");
-    while(retry++ < 5)
-    {
-        fw_link = (u8*)kzalloc(FW_SECTION_LENGTH, GFP_KERNEL);
-        if(fw_link == NULL)
-        {
-            continue;
-        }
-        else
-        {
-            GTP_DEBUG("[burn_fw_link]Alloc %dk byte memory success.", (FW_SECTION_LENGTH/1024));
-            break;
-        }
-    }
-    if(retry >= 5)
-    {
-        GTP_ERROR("[burn_fw_link]Alloc memory fail,exit.");
-        return FAIL;
-    }
-    
-    //step2:load firmware link section 1
-    GTP_DEBUG("[burn_fw_link]step2:load firmware link section 1");
-    offset = update_msg.fw_burned_len - FW_DSP_ISP_LENGTH;
-    ret = gup_load_section_file(fw_link, offset, FW_SECTION_LENGTH, SEEK_SET);
-    if(FAIL == ret)
-    {
-        GTP_ERROR("[burn_fw_link]load firmware link section 1 fail.");
-        goto exit_burn_fw_link;
-    }
-    
-    //step3:burn link firmware section 1
-    GTP_DEBUG("[burn_fw_link]step3:burn link firmware section 1");
-    ret = gup_burn_fw_gwake_section(client, fw_link, 0x9000, FW_SECTION_LENGTH, 0x38);
-
-    if (FAIL == ret)
-    {
-        GTP_ERROR("[burn_fw_link]burn link firmware section 1 fail.");
-        goto exit_burn_fw_link;
-    }
-    
-    //step4:load link firmware section 2 file data
-    GTP_DEBUG("[burn_fw_link]step4:load link firmware section 2 file data");
-    offset += FW_SECTION_LENGTH;
-    ret = gup_load_section_file(fw_link, offset, FW_GLINK_LENGTH - FW_SECTION_LENGTH, SEEK_SET);
-
-    if (FAIL == ret)
-    {
-        GTP_ERROR("[burn_fw_link]load link firmware section 2 fail.");
-        goto exit_burn_fw_link;
-    }
-    
-    //step5:burn link firmware section 2
-    GTP_DEBUG("[burn_fw_link]step4:burn link firmware section 2");
-    ret = gup_burn_fw_gwake_section(client, fw_link, 0x9000, FW_GLINK_LENGTH - FW_SECTION_LENGTH, 0x39);
-
-    if (FAIL == ret)
-    {
-        GTP_ERROR("[burn_fw_link]burn link firmware section 2 fail.");
-        goto exit_burn_fw_link;
-    }
-    
-    update_msg.fw_burned_len += FW_GLINK_LENGTH;
-    GTP_DEBUG("[burn_fw_link]Burned length:%d", update_msg.fw_burned_len);
-    ret = SUCCESS;
-    
-exit_burn_fw_link:
-    kfree(fw_link);
-    return ret;
-}
-
-static u8 gup_burn_fw_gwake_section(struct i2c_client *client, u8 *fw_section, u16 start_addr, u32 len, u8 bank_cmd )
-{
-    s32 ret = 0;
-    u8  rd_buf[5];
-  
-    //step1:hold ss51 & dsp
-    ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
-    if(ret <= 0)
-    {
-        GTP_ERROR("[burn_fw_app_section]hold ss51 & dsp fail.");
-        return FAIL;
-    }
-    
-    //step2:set scramble
-    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x00);
-    if(ret <= 0)
-    {
-        GTP_ERROR("[burn_fw_app_section]set scramble fail.");
-        return FAIL;
-    }
-        
-    //step3:hold ss51 & release dsp
-    ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x04);
-    if(ret <= 0)
-    {
-        GTP_ERROR("[burn_fw_app_section]hold ss51 & release dsp fail.");
-        return FAIL;
-    }
-    //must delay
-    msleep(1);
-    
-    //step4:select bank
-    ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK, (bank_cmd >> 4)&0x0F);
-    if(ret <= 0)
-    {
-        GTP_ERROR("[burn_fw_section]select bank %d fail.", (bank_cmd >> 4)&0x0F);
-        return FAIL;
-    }
-    
-    //step5:burn fw section
-    ret = gup_burn_proc(client, fw_section, start_addr, len);
-    if(FAIL == ret)
-    {
-        GTP_ERROR("[burn_fw_app_section]burn fw_section fail.");
-        return FAIL;
-    }
-    
-    //step6:send burn cmd to move data to flash from sram
-    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, bank_cmd&0x0F);
-    if(ret <= 0)
-    {
-        GTP_ERROR("[burn_fw_app_section]send burn cmd fail.");
-        return FAIL;
-    }
-    GTP_DEBUG("[burn_fw_section]Wait for the burn is complete......");
-    do{
-        ret = gup_get_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, rd_buf, 1);
-        if(ret <= 0)
-        {
-            GTP_ERROR("[burn_fw_app_section]Get burn state fail");
-            return FAIL;
-        }
-        msleep(10);
-        //GTP_DEBUG("[burn_fw_app_section]Get burn state:%d.", rd_buf[GTP_ADDR_LENGTH]);
-    }while(rd_buf[GTP_ADDR_LENGTH]);
-    
-    //step7:recall fw section
-    ret = gup_recall_check(client, fw_section, start_addr, len);
-    if(FAIL == ret)
-    {
-        GTP_ERROR("[burn_fw_app_section]recall check %dk firmware fail.", len/1024);
-        return FAIL;
-    }
-    
-    return SUCCESS;
-}
-
-static u8 gup_burn_fw_gwake(struct i2c_client *client)
-{
-    u8* fw_gwake = NULL;
-    u8  retry = 0;
-    s32 ret = 0;
-    //u16 start_index = 4*FW_SECTION_LENGTH+FW_DSP_LENGTH+FW_BOOT_LENGTH + FW_DSP_ISP_LENGTH + FW_BOOT_ISP_LENGTH; // 32 + 4 + 2 + 4 = 42K
-    u16 start_index;
-    
-    if(update_msg.fw_burned_len >= update_msg.fw_total_len)
-    {
-        GTP_DEBUG("No need to upgrade the gwake code!");
-        return SUCCESS;
-    }
-    start_index = update_msg.fw_burned_len - FW_DSP_ISP_LENGTH;
-    GTP_INFO("[burn_fw_gwake]Begin burn gwake firmware---->>");
-    
-    //step1:alloc memory
-    GTP_DEBUG("[burn_fw_gwake]step1:alloc memory");
-    while(retry++ < 5)
-    {
-        fw_gwake = (u8*)kzalloc(FW_SECTION_LENGTH, GFP_KERNEL);
-        if(fw_gwake == NULL)
-        {
-            continue;
-        }
-        else
-        {
-            GTP_DEBUG("[burn_fw_gwake]Alloc %dk byte memory success.", (FW_SECTION_LENGTH/1024));
-            break;
-        }
-    }
-    if(retry >= 5)
-    {
-        GTP_ERROR("[burn_fw_gwake]Alloc memory fail,exit.");
-        return FAIL;
-    }
-    
-    //step2:load app_code firmware section 1 file data
-    GTP_DEBUG("[burn_fw_gwake]step2:load app_code firmware section 1 file data");
-    ret = gup_load_section_file(fw_gwake, start_index, FW_SECTION_LENGTH, SEEK_SET);
-    if(FAIL == ret)
-    {
-        GTP_ERROR("[burn_fw_gwake]load app_code firmware section 1 fail.");
-        goto exit_burn_fw_gwake;
-    }
-  
-    //step3:burn app_code firmware section 1
-    GTP_DEBUG("[burn_fw_gwake]step3:burn app_code firmware section 1");
-    ret = gup_burn_fw_gwake_section(client, fw_gwake, 0x9000, FW_SECTION_LENGTH, 0x3A);
-    if(FAIL == ret)
-    {
-        GTP_ERROR("[burn_fw_gwake]burn app_code firmware section 1 fail.");
-        goto exit_burn_fw_gwake;
-    }
-    
-    //step5:load app_code firmware section 2 file data
-    GTP_DEBUG("[burn_fw_gwake]step5:load app_code firmware section 2 file data");
-    ret = gup_load_section_file(fw_gwake, start_index+FW_SECTION_LENGTH, FW_SECTION_LENGTH, SEEK_SET);
-    if(FAIL == ret)
-    {
-        GTP_ERROR("[burn_fw_gwake]load app_code firmware section 2 fail.");
-        goto exit_burn_fw_gwake;
-    }
-    
-    //step6:burn app_code firmware section 2
-    GTP_DEBUG("[burn_fw_gwake]step6:burn app_code firmware section 2");
-    ret = gup_burn_fw_gwake_section(client, fw_gwake, 0x9000, FW_SECTION_LENGTH, 0x3B);
-    if(FAIL == ret)
-    {
-        GTP_ERROR("[burn_fw_gwake]burn app_code firmware section 2 fail.");
-        goto exit_burn_fw_gwake;
-    }
-    
-    //step7:load app_code firmware section 3 file data
-    GTP_DEBUG("[burn_fw_gwake]step7:load app_code firmware section 3 file data");
-    ret = gup_load_section_file(fw_gwake, start_index+2*FW_SECTION_LENGTH, FW_SECTION_LENGTH, SEEK_SET);
-    if(FAIL == ret)
-    {
-        GTP_ERROR("[burn_fw_gwake]load app_code firmware section 3 fail.");
-        goto exit_burn_fw_gwake;
-    }
-    
-    //step8:burn app_code firmware section 3
-    GTP_DEBUG("[burn_fw_gwake]step8:burn app_code firmware section 3");
-    ret = gup_burn_fw_gwake_section(client, fw_gwake, 0x9000, FW_SECTION_LENGTH, 0x3C);
-    if(FAIL == ret)
-    {
-        GTP_ERROR("[burn_fw_gwake]burn app_code firmware section 3 fail.");
-        goto exit_burn_fw_gwake;
-    }
-    
-    //step9:load app_code firmware section 4 file data
-    GTP_DEBUG("[burn_fw_gwake]step9:load app_code firmware section 4 file data");
-    ret = gup_load_section_file(fw_gwake, start_index + 3*FW_SECTION_LENGTH, FW_SECTION_LENGTH, SEEK_SET);
-    if(FAIL == ret)
-    {
-        GTP_ERROR("[burn_fw_gwake]load app_code firmware section 4 fail.");
-        goto exit_burn_fw_gwake;
-    }
-    
-    //step10:burn app_code firmware section 4
-    GTP_DEBUG("[burn_fw_gwake]step10:burn app_code firmware section 4");
-    ret = gup_burn_fw_gwake_section(client, fw_gwake, 0x9000, FW_SECTION_LENGTH, 0x3D);
-    if(FAIL == ret)
-    {
-        GTP_ERROR("[burn_fw_gwake]burn app_code firmware section 4 fail.");
-        goto exit_burn_fw_gwake;
-    }
-    
-    update_msg.fw_burned_len += FW_GWAKE_LENGTH;
-    GTP_DEBUG("[burn_fw_gwake]Burned length:%d", update_msg.fw_burned_len);
-    ret = SUCCESS;
-    
-exit_burn_fw_gwake:
-    kfree(fw_gwake);
-    return ret;
-}
-
-static u8 gup_burn_fw_finish(struct i2c_client *client)
-{
-    u8* fw_ss51 = NULL;
-    u8  retry = 0;
-    s32 ret = 0;
-    
-    GTP_INFO("[burn_fw_finish]burn first 8K of ss51 and finish update.");
-    //step1:alloc memory
-    GTP_DEBUG("[burn_fw_finish]step1:alloc memory");
-    while(retry++ < 5)
-    {
-        fw_ss51 = (u8*)kzalloc(FW_SECTION_LENGTH, GFP_KERNEL);
-        if(fw_ss51 == NULL)
-        {
-            continue;
-        }
-        else
-        {
-            GTP_DEBUG("[burn_fw_finish]Alloc %dk byte memory success.", (FW_SECTION_LENGTH/1024));
-            break;
-        }
-    }
-    if(retry >= 5)
-    {
-        GTP_ERROR("[burn_fw_finish]Alloc memory fail,exit.");
-        return FAIL;
-    }
-    
-    GTP_DEBUG("[burn_fw_finish]step2: burn ss51 first 8K.");
-    ret = gup_load_section_file(fw_ss51, 0, FW_SECTION_LENGTH, SEEK_SET);
-    if(FAIL == ret)
-    {
-        GTP_ERROR("[burn_fw_finish]load ss51 firmware section 1 fail.");
-        goto exit_burn_fw_finish;
-    }
-
-    GTP_DEBUG("[burn_fw_finish]step3:clear control flag");
-    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x00);
-    if(ret <= 0)
-    {
-        GTP_ERROR("[burn_fw_finish]clear control flag fail.");
-        goto exit_burn_fw_finish;
-    }
-    
-    GTP_DEBUG("[burn_fw_finish]step4:burn ss51 firmware section 1");
-    ret = gup_burn_fw_section(client, fw_ss51, 0xC000, 0x01);
-    if(FAIL == ret)
-    {
-        GTP_ERROR("[burn_fw_finish]burn ss51 firmware section 1 fail.");
-        goto exit_burn_fw_finish;
-    }
-    
-    //step11:enable download DSP code 
-    GTP_DEBUG("[burn_fw_finish]step5:enable download DSP code ");
-    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x99);
-    if(ret <= 0)
-    {
-        GTP_ERROR("[burn_fw_finish]enable download DSP code fail.");
-        goto exit_burn_fw_finish;
-    }
-    
-    //step12:release ss51 & hold dsp
-    GTP_DEBUG("[burn_fw_finish]step6:release ss51 & hold dsp");
-    ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x08);
-    if(ret <= 0)
-    {
-        GTP_ERROR("[burn_fw_finish]release ss51 & hold dsp fail.");
-        goto exit_burn_fw_finish;
-    }
-
-    if (fw_ss51)
-    {
-        kfree(fw_ss51);
-    }
-    return SUCCESS;
-    
-exit_burn_fw_finish:
-    if (fw_ss51)
-    {
-        kfree(fw_ss51);
-    }
-    return FAIL;
-}
-
-s32 gup_update_proc(void *dir)
-{
-    s32 ret = 0;
-    u8  retry = 0;
-    s32 update_ret = FAIL;
-    st_fw_head fw_head;
-    
-    GTP_INFO("[update_proc]Begin update ......");
-    
-#if GTP_AUTO_UPDATE
-    if (1 == searching_file)
-    {
-        u8 timeout = 0;
-        searching_file = 0;     // exit .bin update file searching 
-        GTP_INFO("Exiting searching file for auto update.");
-        while ((show_len != 200) && (show_len != 100) && (timeout++ < 150))     // wait for auto update quitted completely
-        {
-            msleep(100);
-        }
-    }
-#endif
-    
-    show_len = 1;
-    total_len = 100; 
-    
-#if GTP_COMPATIBLE_MODE
-    if (CHIP_TYPE_GT9F == gtp_chip_type)
-    {
-        return gup_fw_download_proc(dir, GTP_FL_FW_BURN);
-    }
-#endif
-
-    update_msg.file = NULL;
-    ret = gup_check_update_file(i2c_client_point, &fw_head, (u8*)dir);     //20121211
-    if (FAIL == ret)
-    {
-        GTP_ERROR("[update_proc]check update file fail.");
-        goto file_fail;
-    }
-    
-    //gtp_reset_guitar(i2c_client_point, 20);
-    ret = gup_get_ic_fw_msg(i2c_client_point);
-
-    if (FAIL == ret)
-    {
-        GTP_ERROR("[update_proc]get ic message fail.");
-        goto file_fail;
-    }
-
-    ret = gup_enter_update_judge(&fw_head);                             //20121212
-
-    if (FAIL == ret)
-    {
-        GTP_ERROR("[update_proc]Check *.bin file fail.");
-        goto file_fail;
-    }
-
-    mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
-#if GTP_ESD_PROTECT
-    gtp_esd_switch(i2c_client_point, SWITCH_OFF);
-#endif
-    ret = gup_enter_update_mode(i2c_client_point);
-
-    if (FAIL == ret)
-    {
-        GTP_ERROR("[update_proc]enter update mode fail.");
-        goto update_fail;
-    }
-
-    while (retry++ < 5)
-    {
-        show_len = 10;
-        total_len = 100;
-        update_msg.fw_burned_len = 0;
-        ret = gup_burn_dsp_isp(i2c_client_point);
-        if(FAIL == ret)
-        {
-            GTP_ERROR("[update_proc]burn dsp isp fail.");
-            continue;
-        }
-        
-        show_len = 20;
-        ret = gup_burn_fw_ss51(i2c_client_point);
-        if(FAIL == ret)
-        {
-            GTP_ERROR("[update_proc]burn ss51 firmware fail.");
-            continue;
-        }
-        
-        show_len = 30;
-        ret = gup_burn_fw_dsp(i2c_client_point);
-        if(FAIL == ret)
-        {
-            GTP_ERROR("[update_proc]burn dsp firmware fail.");
-            continue;
-        }
-        
-        show_len = 40;
-        ret = gup_burn_fw_boot(i2c_client_point);
-        if(FAIL == ret)
-        {
-            GTP_ERROR("[update_proc]burn bootloader firmware fail.");
-            continue;
-        }
-        show_len = 50;
-        
-        ret = gup_burn_fw_boot_isp(i2c_client_point);
-        if (FAIL == ret)
-        {
-            GTP_ERROR("[update_proc]burn boot_isp firmware fail.");
-            continue;
-        }
-        
-        show_len = 60;
-        ret = gup_burn_fw_link(i2c_client_point);
-        if (FAIL == ret)
-        {
-            GTP_ERROR("[update_proc]burn link firmware fail.");
-            continue;
-        }
-        
-        show_len = 70;
-        ret = gup_burn_fw_gwake(i2c_client_point);
-        if (FAIL == ret)
-        {
-            GTP_ERROR("[update_proc]burn app_code firmware fail.");
-            continue;
-        }       
-        show_len = 80;
-        
-        ret = gup_burn_fw_finish(i2c_client_point);
-        if (FAIL == ret)
-        {
-            GTP_ERROR("[update_proc]burn finish fail.");
-            continue;
-        }
-        show_len = 90;
-        GTP_INFO("[update_proc]UPDATE SUCCESS.");
-        retry = 0;
-        break;
-    }
-
-    if (retry >= 5)
-    {
-        GTP_ERROR("[update_proc]retry timeout,UPDATE FAIL.");
-        update_ret = FAIL;
-    }
-    else
-    {
-        update_ret = SUCCESS;
-    }
-    
-update_fail:
-    GTP_DEBUG("[update_proc]leave update mode.");
-    gup_leave_update_mode();    
-
-    msleep(100);
-    
-    if (SUCCESS == update_ret)
-    {
-        GTP_DEBUG("[update_proc]send config.");
-        ret = gtp_send_cfg(i2c_client_point);
-        if (ret < 0)
-        {
-            GTP_ERROR("[update_proc]send config fail.");
-        }
-    }
-    
-    mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
-#if GTP_ESD_PROTECT
-    gtp_esd_switch(i2c_client_point, SWITCH_ON);
-#endif
-
-file_fail:
-    
-	if (update_msg.file && !IS_ERR(update_msg.file))
-	{
-        if (update_msg.old_fs)
-        {
-            set_fs(update_msg.old_fs);
-        }
-		filp_close(update_msg.file, NULL);
-	}
-#if (GTP_AUTO_UPDATE && GTP_AUTO_UPDATE_CFG && GTP_HEADER_FW_UPDATE)
-    if (NULL == dir)
-    {
-        gup_search_file(AUTO_SEARCH_CFG);
-        if (got_file_flag & CFG_FILE_READY)
-        {
-            ret = gup_update_config(i2c_client_point);
-            if(ret <= 0)
-            {
-                GTP_ERROR("Update config failed.");
-            }
-            _CLOSE_FILE(update_msg.cfg_file);
-            msleep(500);                //waiting config to be stored in FLASH.
-        }
-    }    
-#endif
-
-    total_len = 100;
-    if (SUCCESS == update_ret)
-    {
-        show_len = 100;
-        return SUCCESS;
-    }
-    else
-    {
-        show_len = 200;
-        return FAIL;
-    }
-}
-
-#if GTP_AUTO_UPDATE
-u8 gup_init_update_proc(struct i2c_client *client)
-{
-    struct task_struct *thread = NULL;
-    
-    GTP_INFO("Ready to run auto update thread");
-
-#if GTP_COMPATIBLE_MODE
-    if (CHIP_TYPE_GT9F == gtp_chip_type)
-    {
-        thread = kthread_run(gup_update_proc, "update", "fl_auto_update");
-    }
-    else
-#endif
-    {
-        thread = kthread_run(gup_update_proc, (void *)NULL, "guitar_update");
-    }
-    if (IS_ERR(thread))
-    {
-        GTP_ERROR("Failed to create update thread.\n");
-        return -1;
-    }
-
-    return 0;
-}
-#endif
-
-
-//******************* For GT9XXF Start ********************//
-
-#define FL_UPDATE_PATH              "/data/_fl_update_.bin"
-#define FL_UPDATE_PATH_SD           "/sdcard/_fl_update_.bin" 
-
-#define GUP_FW_CHK_SIZE              256
-#define MAX_CHECK_TIMES              128    // max: 2 * (16 * 1024) / 256 = 128
-
-//for clk cal
-#define PULSE_LENGTH      (200)
-#define INIT_CLK_DAC      (50)
-#define MAX_CLK_DAC       (120)
-#define CLK_AVG_TIME      (1)
-#define MILLION           1000000
-
-#define _wRW_MISCTL__RG_DMY                       0x4282
-#define _bRW_MISCTL__RG_OSC_CALIB                 0x4268
-#define _fRW_MISCTL__GIO0                         0x41e9
-#define _fRW_MISCTL__GIO1                         0x41ed
-#define _fRW_MISCTL__GIO2                         0x41f1
-#define _fRW_MISCTL__GIO3                         0x41f5
-#define _fRW_MISCTL__GIO4                         0x41f9
-#define _fRW_MISCTL__GIO5                         0x41fd
-#define _fRW_MISCTL__GIO6                         0x4201
-#define _fRW_MISCTL__GIO7                         0x4205
-#define _fRW_MISCTL__GIO8                         0x4209
-#define _fRW_MISCTL__GIO9                         0x420d
-#define _fRW_MISCTL__MEA                          0x41a0
-#define _bRW_MISCTL__MEA_MODE                     0x41a1
-#define _wRW_MISCTL__MEA_MAX_NUM                  0x41a4
-#define _dRO_MISCTL__MEA_VAL                      0x41b0
-#define _bRW_MISCTL__MEA_SRCSEL                   0x41a3
-#define _bRO_MISCTL__MEA_RDY                      0x41a8
-#define _rRW_MISCTL__ANA_RXADC_B0_                0x4250
-#define _bRW_MISCTL__RG_LDO_A18_PWD               0x426f
-#define _bRW_MISCTL__RG_BG_PWD                    0x426a
-#define _bRW_MISCTL__RG_CLKGEN_PWD                0x4269
-#define _fRW_MISCTL__RG_RXADC_PWD                 0x426a
-#define _bRW_MISCTL__OSC_CK_SEL                   0x4030
-#define _rRW_MISCTL_RG_DMY83                      0x4283
-#define _rRW_MISCTL__GIO1CTL_B2_                  0x41ee
-#define _rRW_MISCTL__GIO1CTL_B1_                  0x41ed
-
-#if GTP_COMPATIBLE_MODE
-
-u8 gup_check_fs_mounted(char *path_name)
-{
-    struct path root_path;
-    struct path path;
-    int err;
-    err = kern_path("/", LOOKUP_FOLLOW, &root_path);
-
-    if (err)
-        return FAIL;
-
-    err = kern_path(path_name, LOOKUP_FOLLOW, &path);
-
-    if (err)
-        return FAIL;
-
-    if (path.mnt->mnt_sb == root_path.mnt->mnt_sb)
-    {
-        //-- not mounted
-        path_put(&path);
-        return FAIL;
-    }
-    else
-    {
-        path_put(&path);
-        return SUCCESS;
-    }
-}
-
-s32 gup_hold_ss51_dsp(struct i2c_client *client)
-{
-    s32 ret = -1;
-    s32 retry = 0;
-    u8 rd_buf[3];
-    
-    while(retry++ < 200)
-    {
-        // step4:Hold ss51 & dsp
-        ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
-        if(ret <= 0)
-        {
-            GTP_DEBUG("Hold ss51 & dsp I2C error,retry:%d", retry);
-            continue;
-        }
-        
-        // step5:Confirm hold
-        ret = gup_get_ic_msg(client, _rRW_MISCTL__SWRST_B0_, rd_buf, 1);
-        if (ret <= 0)
-        {
-            GTP_DEBUG("Hold ss51 & dsp I2C error,retry:%d", retry);
-            continue;
-        }
-        if (0x0C == rd_buf[GTP_ADDR_LENGTH])
-        {
-            GTP_DEBUG("[enter_update_mode]Hold ss51 & dsp confirm SUCCESS");
-            break;
-        }
-        GTP_DEBUG("Hold ss51 & dsp confirm 0x4180 failed,value:%d", rd_buf[GTP_ADDR_LENGTH]);
-    }
-    if(retry >= 200)
-    {
-        GTP_ERROR("Enter update Hold ss51 failed.");
-        return FAIL;
-    }
-        //DSP_CK and DSP_ALU_CK PowerOn
-    ret = gup_set_ic_msg(client, 0x4010, 0x00);
-    if (ret <= 0)
-    {
-        GTP_ERROR("[enter_update_mode]DSP_CK and DSP_ALU_CK PowerOn fail.");
-        return FAIL;
-    }
-    
-    //disable wdt
-    ret = gup_set_ic_msg(client, _bRW_MISCTL__TMR0_EN, 0x00);
-
-    if (ret <= 0)
-    {
-        GTP_ERROR("[enter_update_mode]disable wdt fail.");
-        return FAIL;
-    }
-    
-    //clear cache enable
-    ret = gup_set_ic_msg(client, _bRW_MISCTL__CACHE_EN, 0x00);
-
-    if (ret <= 0)
-    {
-        GTP_ERROR("[enter_update_mode]clear cache enable fail.");
-        return FAIL;
-    }
-    
-    //set boot from sram
-    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOTCTL_B0_, 0x02);
-
-    if (ret <= 0)
-    {
-        GTP_ERROR("[enter_update_mode]set boot from sram fail.");
-        return FAIL;
-    }
-
-	//software reboot    
-	ret = gup_set_ic_msg(client, _bWO_MISCTL__CPU_SWRST_PULSE, 0x01);
-	if (ret <= 0)
-	{    
-	    GTP_ERROR("[enter_update_mode]software reboot fail.");
-	    return FAIL;
-	}
-    
-    return SUCCESS;
-}
-
-s32 gup_enter_update_mode_fl(struct i2c_client *client)
-{
-    s32 ret = -1;
-    //s32 retry = 0;
-    //u8 rd_buf[3];
-    
-    //step1:RST output low last at least 2ms
-    GTP_GPIO_OUTPUT(GTP_RST_PORT, 0);
-    msleep(2);
-    
-    //step2:select I2C slave addr,INT:0--0xBA;1--0x28.
-    GTP_GPIO_OUTPUT(GTP_INT_PORT, (client->addr == 0x14));
-    msleep(2);
-    
-    //step3:RST output high reset guitar
-    GTP_GPIO_OUTPUT(GTP_RST_PORT, 1);
-    
-    msleep(5);
-    
-    //select addr & hold ss51_dsp
-    ret = gup_hold_ss51_dsp(client);
-    if (ret <= 0)
-    {
-        GTP_ERROR("[enter_update_mode]hold ss51 & dsp failed.");
-        return FAIL;
-    }
-    
-    //clear control flag
-    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x00);
-
-    if (ret <= 0)
-    {
-        GTP_ERROR("[enter_update_mode]clear control flag fail.");
-        return FAIL;
-    }
-    
-    //set scramble
-    ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x00);
-
-    if (ret <= 0)
-    {
-        GTP_ERROR("[enter_update_mode]set scramble fail.");
-        return FAIL;
-    }
-    
-    //enable accessing code
-    ret = gup_set_ic_msg(client, _bRW_MISCTL__MEM_CD_EN, 0x01);
-
-    if (ret <= 0)
-    {
-        GTP_ERROR("[enter_update_mode]enable accessing code fail.");
-        return FAIL;
-    }
-    
-    return SUCCESS;
-}
-
-
-static s32 gup_prepare_fl_fw(char *path, st_fw_head *fw_head)
-{
-    s32 i = 0;
-    s32 ret = 0;
-    s32 timeout = 0;
-    
-    if (!memcmp(path, "update", 6))
-    {
-        GTP_INFO("Search for Flashless firmware file to update");
-        searching_file = 1;
-        for (i = 0; i < GUP_SEARCH_FILE_TIMES; ++i)
-        {
-            if (0 == searching_file)
-            {
-                GTP_INFO("Force terminate searching file auto update.");
-                return FAIL;
-            }
-            update_msg.file = filp_open(FL_UPDATE_PATH, O_RDONLY, 0);
-            if (IS_ERR(update_msg.file))
-            {
-                update_msg.file = filp_open(FL_UPDATE_PATH_SD, O_RDONLY, 0);
-                if (IS_ERR(update_msg.file))
-                {
-                    msleep(2000);
-                    continue;
-                }
-                else
-                {
-                    path = FL_UPDATE_PATH_SD;
-                    break;
-                }
-            }
-            else
-            {
-                path = FL_UPDATE_PATH;
-                break;
-            }
-        }
-        searching_file = 0;
-        if (i >= 50)
-        {
-            GTP_ERROR("Search timeout, update aborted");
-            return FAIL;
-        }
-        else
-        {
-            _CLOSE_FILE(update_msg.file);
-        }
-        while (rqst_processing && (timeout++ < 15))
-        {
-            GTP_INFO("wait for request process completed!");
-            msleep(1000);
-        }
-    }
-    
-    GTP_INFO("Firmware update file path: %s", path);
-    update_msg.file = filp_open(path, O_RDONLY, 0);
-    
-    if (IS_ERR(update_msg.file))
-    {
-        GTP_ERROR("Open update file(%s) error!", path);
-        return FAIL;
-    }
-    
-    update_msg.old_fs = get_fs();
-    set_fs(KERNEL_DS);
-    update_msg.file->f_op->llseek(update_msg.file, 0, SEEK_SET);
-    update_msg.fw_total_len = update_msg.file->f_op->llseek(update_msg.file, 0, SEEK_END);
-    if (sizeof(gtp_default_FW_fl) != update_msg.fw_total_len)
-    {
-        GTP_ERROR("Inconsistent firmware size. File size: %d, default fw size: %d", update_msg.fw_total_len, sizeof(gtp_default_FW_fl));
-        set_fs(update_msg.old_fs);
-        _CLOSE_FILE(update_msg.file);
-        return FAIL;
-    }
-    
-    GTP_DEBUG("Firmware size: %d", update_msg.fw_total_len);
-    update_msg.file->f_op->llseek(update_msg.file, 0, SEEK_SET);
-    update_msg.file->f_op->read(update_msg.file, (char*)fw_head, FW_HEAD_LENGTH, &update_msg.file->f_pos);
-    
-    update_msg.file->f_op->llseek(update_msg.file, 0, SEEK_SET);
-    //copy fw file to gtp_default_FW_fl array
-    ret = update_msg.file->f_op->read(update_msg.file, 
-                                (char*)gtp_default_FW_fl,
-                                update_msg.fw_total_len,
-                                &update_msg.file->f_pos);
-    if (ret < 0)
-    {
-        GTP_ERROR("Failed to read firmware data from %s, err-code: %d", path, ret);
-        ret = FAIL;
-    }
-    else
-    {
-        ret = SUCCESS;
-    }
-    set_fs(update_msg.old_fs);
-    _CLOSE_FILE(update_msg.file);
-    return ret;
-}
-
-static u8 gup_check_update_file_fl(struct i2c_client *client, st_fw_head *fw_head, char *path)
-{
-    s32 i = 0;
-    s32 fw_checksum = 0;
-    s32 ret = 0;
-    
-    if (NULL != path)
-    {
-        ret = gup_prepare_fl_fw(path, fw_head);
-        if (ret == FAIL)
-        {
-            return FAIL;
-        }
-    }
-
-    memcpy(fw_head, gtp_default_FW_fl, FW_HEAD_LENGTH);
-    GTP_INFO("FILE HARDWARE INFO:%02x%02x%02x%02x", fw_head->hw_info[0], fw_head->hw_info[1], fw_head->hw_info[2], fw_head->hw_info[3]);
-    GTP_INFO("FILE PID:%s", fw_head->pid);
-    fw_head->vid = ((fw_head->vid & 0xFF00) >> 8) + ((fw_head->vid & 0x00FF) << 8);
-    GTP_INFO("FILE VID:%04x", fw_head->vid);
-    
-    //check firmware legality
-    fw_checksum = 0;
-    for (i = FW_HEAD_LENGTH; i < (FW_HEAD_LENGTH + update_msg.fw_total_len); i += 2)
-    {
-        fw_checksum = (gtp_default_FW_fl[i]<<8) + gtp_default_FW_fl[i+1];
-    }
-    
-    GTP_DEBUG("firmware checksum:%x", fw_checksum&0xFFFF);
-    if(fw_checksum&0xFFFF)
-    {
-        GTP_ERROR("Illegal firmware file.");
-        return FAIL;
-    }
-    
-    return SUCCESS;
-}
-
-static u8 gup_download_fw_ss51(struct i2c_client *client, u8 dwn_mode)
-{
-    s32 ret = 0;
-    
-    if (GTP_FL_FW_BURN == dwn_mode)
-    {
-        GTP_INFO("[download_fw_ss51]Begin download ss51 firmware---->>");
-    }
-    else 
-    {
-        GTP_INFO("[download_fw_ss51]Begin check ss51 firmware----->>");
-    }
-    //step1:download FW section 1
-    GTP_DEBUG("[download_fw_ss51]step1:download FW section 1");
-    ret = gup_set_ic_msg(i2c_client_point, _bRW_MISCTL__SRAM_BANK, 0x00);
-    
-    if (ret <= 0)
-    {
-        GTP_ERROR("[download_fw_ss51]select bank0 fail.");
-        ret = FAIL;
-        goto exit_download_fw_ss51;
-    }
-    
-    
-    ret = i2c_write_bytes(client, 0xC000, 
-                &gtp_default_FW_fl[FW_HEAD_LENGTH], FW_DOWNLOAD_LENGTH);   // write the first bank
-
-    if (ret == -1)
-    {
-        GTP_ERROR("[download_fw_ss51]download FW section 1 fail.");
-        ret = FAIL;
-        goto exit_download_fw_ss51;
-    }
-    
-    
-    if (GTP_FL_FW_BURN == dwn_mode)
-    {
-        ret = gup_check_and_repair(i2c_client_point, 
-                                   0xC000, 
-                                   &gtp_default_FW_fl[FW_HEAD_LENGTH], 
-                                   FW_DOWNLOAD_LENGTH);
-        if(FAIL == ret)
-        {
-            GTP_ERROR("[download_fw_ss51]Checked FW section 1 fail.");
-            goto exit_download_fw_ss51;
-        }
-    }
-    
-    //step2:download FW section 2
-    GTP_DEBUG("[download_fw_ss51]step2:download FW section 1");
-    ret = gup_set_ic_msg(i2c_client_point, _bRW_MISCTL__SRAM_BANK, 0x01);
-    
-    if (ret <= 0)
-    {
-        GTP_ERROR("[download_fw_ss51]select bank1 fail.");
-        ret = FAIL;
-        goto exit_download_fw_ss51;
-    }
-
-    ret = i2c_write_bytes(client, 0xC000, &gtp_default_FW_fl[FW_HEAD_LENGTH+FW_DOWNLOAD_LENGTH],FW_DOWNLOAD_LENGTH);  // write the second bank
-
-    if (ret == -1)
-    {
-        GTP_ERROR("[download_fw_ss51]download FW section 2 fail.");
-        ret = FAIL;
-        goto exit_download_fw_ss51;
-    }
-    
-    if (GTP_FL_FW_BURN == dwn_mode)
-    {
-        ret = gup_check_and_repair(i2c_client_point, 
-                                   0xC000, 
-                                   &gtp_default_FW_fl[FW_HEAD_LENGTH+FW_DOWNLOAD_LENGTH], 
-                                   FW_DOWNLOAD_LENGTH);
-        
-        if(FAIL == ret)
-        {
-            GTP_ERROR("[download_fw_ss51]Checked FW section 2 fail.");
-            goto exit_download_fw_ss51;
-        }
-    }
-    ret = SUCCESS;
-
-exit_download_fw_ss51:
-    
-    return ret;
-}
-#if (!GTP_SUPPORT_I2C_DMA)
-static s32 i2c_auto_read(struct i2c_client *client,u8 *rxbuf, int len)
-{
-    u8 retry;
-    u16 left = len;
-    u16 offset = 0;
-    
-    struct i2c_msg msg = 
-    {
-        //.addr = ((client->addr &I2C_MASK_FLAG) | (I2C_ENEXT_FLAG)),
-        .addr = ((client->addr &I2C_MASK_FLAG) | (I2C_PUSHPULL_FLAG)),
-        .flags = I2C_M_RD,
-        .timing = I2C_MASTER_CLOCK
-    };
-    
-    if(NULL == rxbuf)
-    {
-        return -1;
-    }
-    
-    while (left > 0)
-    {
-        msg.buf = &rxbuf[offset];
-
-        if (left > MAX_TRANSACTION_LENGTH)
-        {
-            msg.len = MAX_TRANSACTION_LENGTH;
-            left -= MAX_TRANSACTION_LENGTH;
-            offset += MAX_TRANSACTION_LENGTH;
-        }
-        else
-        {
-            msg.len = left;
-            left = 0;
-        }
-
-        retry = 0;
-
-        while (i2c_transfer(client->adapter, &msg, 1) != 1)
-        {
-            retry++;
-
-            if (retry == 20)
-            {
-                GTP_ERROR("I2C read 0x%X length=%d failed\n", offset, len);
-                return -1;
-            }
-        }
-    }
-    
-    return 0;
-}
-#endif
-
-static u8 gup_check_and_repair(struct i2c_client *client, s32 chk_start_addr, u8 *target_fw, u32 chk_total_length)
-{
-    s32 ret = 0;
-    u32 chked_len = 0;
-    u8  chked_times = 0;
-    u32 chk_addr = 0;
-    u8  chk_buf[GUP_FW_CHK_SIZE];
-    u32 rd_size = 0;
-    u8  flag_err = 0;
-    s32 i = 0;
-    
-    chk_addr = chk_start_addr;
-    while((chked_times < MAX_CHECK_TIMES) && (chked_len < chk_total_length))
-    {
-        rd_size = chk_total_length - chked_len;
-        if(rd_size >= GUP_FW_CHK_SIZE)
-        {
-            rd_size = GUP_FW_CHK_SIZE;
-        }
-    #if GTP_SUPPORT_I2C_DMA
-        ret = i2c_read_bytes(client, chk_addr, chk_buf, rd_size);
-    #else
-        if (!i)
-        {
-            ret = i2c_read_bytes(client, chk_addr, chk_buf, rd_size);
-        }
-        else
-        {
-            ret = i2c_auto_read(client, chk_buf, rd_size);
-        }
-    #endif
-    
-        if(-1 == ret)
-        {
-            GTP_ERROR("Read chk ram fw i2c error");
-            chked_times++;
-            continue;
-        }
-        
-        for(i=0; i<rd_size; i++)
-        {
-            if(chk_buf[i] != target_fw[i])
-            {
-                GTP_ERROR("Ram pos[0x%04x] checked failed,rewrite.", chk_addr + i);
-                i2c_write_bytes(client, chk_addr+i, &target_fw[i], rd_size-i);
-                flag_err = 1;
-                i = 0;
-                break;
-            }
-        }
-        
-        if(!flag_err)
-        {
-            GTP_DEBUG("Ram pos[0x%04X] check pass!", chk_addr);
-            chked_len += rd_size;
-            target_fw += rd_size;
-            chk_addr += rd_size;
-        }
-        else
-        {
-            flag_err = 0;
-            chked_times++;
-        }      
-    }
-    
-    if(chked_times >= MAX_CHECK_TIMES)
-    {
-        GTP_ERROR("Ram data check failed.");
-        return FAIL;
-    }
-    return SUCCESS;
-}
-
-static u8 gup_download_fw_dsp(struct i2c_client *client, u8 dwn_mode)
-{
-    s32 ret = 0;
-    
-    if(GTP_FL_FW_BURN == dwn_mode)
-    {
-        GTP_INFO("[download_fw_dsp]Begin download dsp fw---->>");
-    }
-    else
-    {
-        GTP_INFO("[download_fw_dsp]Begin check dsp fw---->>");
-    }
-
-    //step1:select bank2
-    GTP_DEBUG("[download_fw_dsp]step1:select bank2");
-    ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK, 0x02);
-
-    if (ret <= 0)
-    {
-        GTP_ERROR("[download_fw_dsp]select bank2 fail.");
-        ret = FAIL;
-        goto exit_download_fw_dsp;
-    }
-    
-    ret = i2c_write_bytes(client,
-                          0xC000,
-                          &gtp_default_FW_fl[FW_HEAD_LENGTH+2*FW_DOWNLOAD_LENGTH],
-                          FW_DSP_LENGTH); // write the second bank    
-    if (ret == -1)
-    {
-        GTP_ERROR("[download_fw_dsp]download FW dsp fail.");
-        ret = FAIL;
-        goto exit_download_fw_dsp;
-    }
-
-    if (GTP_FL_FW_BURN == dwn_mode)
-    {
-        ret = gup_check_and_repair(client, 
-                                   0xC000, 
-                                   &gtp_default_FW_fl[FW_HEAD_LENGTH+2*FW_DOWNLOAD_LENGTH], 
-                                   FW_DSP_LENGTH);
-        
-        if(FAIL == ret)
-        {
-            GTP_ERROR("[download_fw_dsp]Checked FW dsp fail.");
-            goto exit_download_fw_dsp;
-        }
-    
-    }
-    ret = SUCCESS;
-
-exit_download_fw_dsp:
-    
-    return ret;
-}
-
-
-
-s32 gup_fw_download_proc(void *dir, u8 dwn_mode)
-{
-    s32 ret = 0;
-    u8  retry = 0;
-    st_fw_head fw_head;
-    
-    if(GTP_FL_FW_BURN == dwn_mode)
-    {
-        GTP_INFO("[fw_download_proc]Begin fw download ......");
-    }
-    else
-    {
-        GTP_INFO("[fw_download_proc]Begin fw check ......");
-    }
-        
-    show_len = 0;
-    total_len = 100;
-    
-    ret = gup_check_update_file_fl(i2c_client_point, &fw_head, (char *)dir);
-    
-    show_len = 10;
-    
-    if (FAIL == ret)
-    {
-        GTP_ERROR("[fw_download_proc]check update file fail.");
-        goto file_fail;
-    }
-    
-    if (!memcmp(fw_head.pid, "950", 3))
-    {
-        is_950 = 1;
-        GTP_DEBUG("GT9XXF IC Type: gt950");
-    }
-    else
-    {
-        is_950 = 0;
-    }
-    
-    if (NULL != dir)
-    {
-        mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
-    #if GTP_ESD_PROTECT
-        gtp_esd_switch(i2c_client_point, SWITCH_OFF);
-    #endif
-    }
-
-    ret = gup_enter_update_mode_fl(i2c_client_point);
-    show_len = 20;
-    
-    if (FAIL == ret)
-    {
-        GTP_ERROR("[fw_download_proc]enter update mode fail.");
-        goto download_fail;
-    }
-
-    while (retry++ < 5)
-    {
-        ret = gup_download_fw_ss51(i2c_client_point, dwn_mode);
-        show_len = 60;
-        if (FAIL == ret)
-        {
-            GTP_ERROR("[fw_download_proc]burn ss51 firmware fail.");
-            continue;
-        }
-
-        ret = gup_download_fw_dsp(i2c_client_point, dwn_mode);
-        show_len = 80;
-        if (FAIL == ret)
-        {
-            GTP_ERROR("[fw_download_proc]burn dsp firmware fail.");
-            continue;
-        }
-        GTP_INFO("[fw_download_proc]UPDATE SUCCESS.");
-        retry = 0;
-        break;
-    }
-
-    if (retry >= 5)
-    {
-        GTP_ERROR("[fw_download_proc]retry timeout,UPDATE FAIL.");
-        goto download_fail;
-    }
-
-    if (NULL != dir)
-    {
-        mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
-        gtp_fw_startup(i2c_client_point);
-    #if GTP_ESD_PROTECT
-        gtp_esd_switch(i2c_client_point, SWITCH_ON);
-    #endif    
-    }
-    show_len = 100;
-    return SUCCESS;
-    
-download_fail:
-    if (NULL != dir)
-    {
-        mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
-        gtp_fw_startup(i2c_client_point);
-    #if GTP_ESD_PROTECT
-        gtp_esd_switch(i2c_client_point, SWITCH_ON);
-    #endif    
-    }
-    
-file_fail:
-    show_len = 200;
-    return FAIL;
-}
-
-
-static void gup_bit_write(s32 addr, s32 bit, s32 val)
-{
-    u8 buf;
-    i2c_read_bytes(i2c_client_point, addr, &buf, 1);
-
-    buf = (buf & (~((u8)1 << bit))) | ((u8)val << bit);
-
-    i2c_write_bytes(i2c_client_point, addr, &buf, 1);
-}
-
-static void gup_clk_count_init(s32 bCh, s32 bCNT)
-{
-    u8 buf;
-    
-    //_fRW_MISCTL__MEA_EN = 0; //Frequency measure enable
-    gup_bit_write(_fRW_MISCTL__MEA, 0, 0);
-    //_fRW_MISCTL__MEA_CLR = 1; //Frequency measure clear
-    gup_bit_write(_fRW_MISCTL__MEA, 1, 1);
-    //_bRW_MISCTL__MEA_MODE = 0; //Pulse mode
-    buf = 0;
-    i2c_write_bytes(i2c_client_point, _bRW_MISCTL__MEA_MODE, &buf, 1);
-    //_bRW_MISCTL__MEA_SRCSEL = 8 + bCh; //From GIO1
-    buf = 8 + bCh;
-    i2c_write_bytes(i2c_client_point, _bRW_MISCTL__MEA_SRCSEL, &buf, 1);
-    //_wRW_MISCTL__MEA_MAX_NUM = bCNT; //Set the Measure Counts = 1
-    buf = bCNT;
-    i2c_write_bytes(i2c_client_point, _wRW_MISCTL__MEA_MAX_NUM, &buf, 1);
-    //_fRW_MISCTL__MEA_CLR = 0; //Frequency measure not clear
-    gup_bit_write(_fRW_MISCTL__MEA, 1, 0);
-    //_fRW_MISCTL__MEA_EN = 1;
-    gup_bit_write(_fRW_MISCTL__MEA, 0, 1);
-}
-
-static u32 gup_clk_count_get(void)
-{
-    s32 ready = 0;
-    s32 temp;
-    s8  buf[4];
-
-    while ((ready == 0)) //Wait for measurement complete
-    {
-        i2c_read_bytes(i2c_client_point, _bRO_MISCTL__MEA_RDY, buf, 1);
-        ready = buf[0];
-    }
-
-    udelay(50);
-
-    //_fRW_MISCTL__MEA_EN = 0;
-    gup_bit_write(_fRW_MISCTL__MEA, 0, 0);
-    i2c_read_bytes(i2c_client_point, _dRO_MISCTL__MEA_VAL, buf, 4);
-    GTP_INFO("Clk_count 0: %2X", buf[0]);
-    GTP_INFO("Clk_count 1: %2X", buf[1]);
-    GTP_INFO("Clk_count 2: %2X", buf[2]);
-    GTP_INFO("Clk_count 3: %2X", buf[3]);
-
-    temp = (s32)buf[0] + ((s32)buf[1] << 8) + ((s32)buf[2] << 16) + ((s32)buf[3] << 24);
-    GTP_INFO("Clk_count : %d", temp);
-    return temp;
-}
-u8 gup_clk_dac_setting(int dac)
-{
-    s8 buf1, buf2;
-    
-    i2c_read_bytes(i2c_client_point, _wRW_MISCTL__RG_DMY, &buf1, 1);
-    i2c_read_bytes(i2c_client_point, _bRW_MISCTL__RG_OSC_CALIB, &buf2, 1);
-
-    buf1 = (buf1 & 0xFFCF) | ((dac & 0x03) << 4);
-    buf2 = (dac >> 2) & 0x3f;
-
-    i2c_write_bytes(i2c_client_point, _wRW_MISCTL__RG_DMY, &buf1, 1);
-    i2c_write_bytes(i2c_client_point, _bRW_MISCTL__RG_OSC_CALIB, &buf2, 1);
-    
-    return 0;
-}
-
-static u8 gup_clk_calibration_pin_select(s32 bCh)
-{
-    s32 i2c_addr;
-
-    switch (bCh)
-    {
-        case 0:
-            i2c_addr = _fRW_MISCTL__GIO0;
-            break;
-
-        case 1:
-            i2c_addr = _fRW_MISCTL__GIO1;
-            break;
-
-        case 2:
-            i2c_addr = _fRW_MISCTL__GIO2;
-            break;
-
-        case 3:
-            i2c_addr = _fRW_MISCTL__GIO3;
-            break;
-
-        case 4:
-            i2c_addr = _fRW_MISCTL__GIO4;
-            break;
-
-        case 5:
-            i2c_addr = _fRW_MISCTL__GIO5;
-            break;
-
-        case 6:
-            i2c_addr = _fRW_MISCTL__GIO6;
-            break;
-
-        case 7:
-            i2c_addr = _fRW_MISCTL__GIO7;
-            break;
-
-        case 8:
-            i2c_addr = _fRW_MISCTL__GIO8;
-            break;
-
-        case 9:
-            i2c_addr = _fRW_MISCTL__GIO9;
-            break;
-    }
-
-    gup_bit_write(i2c_addr, 1, 0);
-    
-    return 0;
-}
-
-void gup_output_pulse(int t)
-{
-    unsigned long flags;
-    //s32 i;
-    
-    GTP_GPIO_OUTPUT(GTP_INT_PORT, 0);
-    udelay(10);
-    
-    local_irq_save(flags);
-
-    mt_set_gpio_out(GTP_INT_PORT, 1);
-    udelay(50);
-    mt_set_gpio_out(GTP_INT_PORT, 0);
-    udelay(t - 50);
-    mt_set_gpio_out(GTP_INT_PORT, 1);
-
-    local_irq_restore(flags);
-
-    udelay(20);
-    GTP_GPIO_OUTPUT(GTP_INT_PORT, 0);
-}
-
-static void gup_sys_clk_init(void)
-{
-    u8 buf;
-    
-    //_fRW_MISCTL__RG_RXADC_CKMUX = 0;
-    gup_bit_write(_rRW_MISCTL__ANA_RXADC_B0_, 5, 0);
-    //_bRW_MISCTL__RG_LDO_A18_PWD = 0; //DrvMISCTL_A18_PowerON
-    buf = 0;
-    i2c_write_bytes(i2c_client_point, _bRW_MISCTL__RG_LDO_A18_PWD, &buf, 1);
-    //_bRW_MISCTL__RG_BG_PWD = 0; //DrvMISCTL_BG_PowerON
-    buf = 0;
-    i2c_write_bytes(i2c_client_point, _bRW_MISCTL__RG_BG_PWD, &buf, 1);
-    //_bRW_MISCTL__RG_CLKGEN_PWD = 0; //DrvMISCTL_CLKGEN_PowerON
-    buf = 0;
-    i2c_write_bytes(i2c_client_point, _bRW_MISCTL__RG_CLKGEN_PWD, &buf, 1);
-    //_fRW_MISCTL__RG_RXADC_PWD = 0; //DrvMISCTL_RX_ADC_PowerON
-    gup_bit_write(_rRW_MISCTL__ANA_RXADC_B0_, 0, 0);
-    //_fRW_MISCTL__RG_RXADC_REF_PWD = 0; //DrvMISCTL_RX_ADCREF_PowerON
-    gup_bit_write(_rRW_MISCTL__ANA_RXADC_B0_, 1, 0);
-    //gup_clk_dac_setting(60);
-    //_bRW_MISCTL__OSC_CK_SEL = 1;;
-    buf = 1;
-    i2c_write_bytes(i2c_client_point, _bRW_MISCTL__OSC_CK_SEL, &buf, 1);
-}
-
-u8 gup_clk_calibration(void)
-{
-    //u8 buf;
-    //u8 trigger;
-    s32 i;
-    struct timeval start, end;
-    s32 count;
-    s32 count_ref;
-    s32 sec;
-    s32 usec;
-    s32 ret = 0;
-    //unsigned long flags;
-
-    //buf = 0x0C; // hold ss51 and dsp
-    //i2c_write_bytes(i2c_client_point, _rRW_MISCTL__SWRST_B0_, &buf, 1);
-    ret = gup_hold_ss51_dsp(i2c_client_point);
-    if (ret <= 0)
-    {
-        GTP_ERROR("[gup_clk_calibration]hold ss51 & dsp failed.");
-        return FAIL;
-    }
-
-    //_fRW_MISCTL__CLK_BIAS = 0; //disable clock bias
-    gup_bit_write(_rRW_MISCTL_RG_DMY83, 7, 0);
-
-    //_fRW_MISCTL__GIO1_PU = 0; //set TOUCH INT PIN MODE as input
-    gup_bit_write(_rRW_MISCTL__GIO1CTL_B2_, 0, 0);
-
-    //_fRW_MISCTL__GIO1_OE = 0; //set TOUCH INT PIN MODE as input
-    gup_bit_write(_rRW_MISCTL__GIO1CTL_B1_, 1, 0);
-
-    //buf = 0x00;
-    //i2c_write_bytes(i2c_client_point, _rRW_MISCTL__SWRST_B0_, &buf, 1);
-    //msleep(1000);
-
-    GTP_INFO("CLK calibration GO");
-    gup_sys_clk_init();
-    gup_clk_calibration_pin_select(1);//use GIO1 to do the calibration
-
-    GTP_GPIO_OUTPUT(GTP_INT_PORT, 0);
- 
-    for (i = INIT_CLK_DAC; i < MAX_CLK_DAC; i++)
-    {
-        if (tpd_halt)
-        {
-            i = 72; //80;     // if sleeping while calibrating main clock, set it default 80
-            break;
-        }
-        GTP_INFO("CLK calibration DAC %d", i);
-
-        gup_clk_dac_setting(i);
-        gup_clk_count_init(1, CLK_AVG_TIME);
-
-    #if 0
-        gup_output_pulse(PULSE_LENGTH);
-        count = gup_clk_count_get();
-  
-        if (count > PULSE_LENGTH * 60)//60= 60Mhz * 1us
-        {
-            break;
-        }
-        
-    #else
-        GTP_GPIO_OUTPUT(GTP_INT_PORT, 0);
-        
-        //local_irq_save(flags);
-        do_gettimeofday(&start);
-        mt_set_gpio_out(GTP_INT_PORT, 1);
-        //local_irq_restore(flags);
-        
-        msleep(1);
-        mt_set_gpio_out(GTP_INT_PORT, 0);
-        msleep(1);
-        
-        //local_irq_save(flags);
-        do_gettimeofday(&end);
-        mt_set_gpio_out(GTP_INT_PORT, 1);
-        //local_irq_restore(flags);
-        
-        count = gup_clk_count_get();
-        udelay(20);
-        GTP_GPIO_OUTPUT(GTP_INT_PORT, 0);
-        
-        usec = end.tv_usec - start.tv_usec;
-        sec = end.tv_sec - start.tv_sec;
-        count_ref = 60 * (usec+ sec * MILLION);//60= 60Mhz * 1us
-        
-        GTP_DEBUG("== time %d, %d, %d", sec, usec, count_ref);
-        
-        if (count > count_ref)
-        {
-            GTP_DEBUG("== count_diff %d", count - count_ref);
-            break;
-        }
-
-    #endif
-    }
-
-    //clk_dac = i;
-
-    //gtp_reset_guitar(i2c_client_point, 20);
-
-#if 0//for debug
-    //-- ouput clk to GPIO 4
-    buf = 0x00;
-    i2c_write_bytes(i2c_client_point, 0x41FA, &buf, 1);
-    buf = 0x00;
-    i2c_write_bytes(i2c_client_point, 0x4104, &buf, 1);
-    buf = 0x00;
-    i2c_write_bytes(i2c_client_point, 0x4105, &buf, 1);
-    buf = 0x00;
-    i2c_write_bytes(i2c_client_point, 0x4106, &buf, 1);
-    buf = 0x01;
-    i2c_write_bytes(i2c_client_point, 0x4107, &buf, 1);
-    buf = 0x06;
-    i2c_write_bytes(i2c_client_point, 0x41F8, &buf, 1);
-    buf = 0x02;
-    i2c_write_bytes(i2c_client_point, 0x41F9, &buf, 1);
-#endif
-
-    GTP_GPIO_AS_INT(GTP_INT_PORT);
-    return i;
-}
-
-#endif 
-//*************** For GT9XXF End ***********************//
\ No newline at end of file
diff --git a/drivers/input/touchscreen/mediatek/GT915_HD/tpd_custom_gt9xx.h~ b/drivers/input/touchscreen/mediatek/GT915_HD/tpd_custom_gt9xx.h~
deleted file mode 100755
index e6f1fc2..0000000
--- a/drivers/input/touchscreen/mediatek/GT915_HD/tpd_custom_gt9xx.h~
+++ /dev/null
@@ -1,415 +0,0 @@
-/* Copyright Statement:
- *
- * This software/firmware and related documentation ("MediaTek Software") are
- * protected under relevant copyright laws. The information contained herein
- * is confidential and proprietary to MediaTek Inc. and/or its licensors.
- * Without the prior written permission of MediaTek inc. and/or its licensors,
- * any reproduction, modification, use or disclosure of MediaTek Software,
- * and information contained herein, in whole or in part, shall be strictly prohibited.
- */ 
-/* MediaTek Inc. (C) 2010. All rights reserved.
- * 
- * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
- * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE") 
- * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
- * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
- * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
- * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
- * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
- * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
- * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
- * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
- * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
- * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
- * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
- * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
- * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
- * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
- *
- * The following software/firmware and/or related documentation ("MediaTek Software")
- * have been modified by MediaTek Inc. All revisions are subject to any receiver's
- * applicable license agreements with MediaTek Inc.
- */
-
-#ifndef TPD_CUSTOM_GT9XX_H__
-#define TPD_CUSTOM_GT9XX_H__
-
-#include <linux/hrtimer.h>
-#include <linux/string.h>
-#include <linux/vmalloc.h>
-//#include <linux/io.h>
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/delay.h>
-#include <linux/i2c.h>
-#include <linux/input.h>
-#include <linux/slab.h>
-#include <linux/gpio.h>
-#include <linux/sched.h>
-#include <linux/kthread.h>
-#include <linux/bitops.h>
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/byteorder/generic.h>
-#ifdef CONFIG_HAS_EARLYSUSPEND
-#include <linux/earlysuspend.h>
-#endif
-#include <linux/interrupt.h>
-#include <linux/time.h>
-#include <linux/rtpm_prio.h>
-
-#include <linux/proc_fs.h>
-#include <asm/uaccess.h>
-#ifdef MT6575
-#include <mach/mt6575_pm_ldo.h>
-#include <mach/mt6575_typedefs.h>
-#include <mach/mt6575_boot.h>
-#endif
-#ifdef MT6577
-#include <mach/mt6577_pm_ldo.h>
-#include <mach/mt6577_typedefs.h>
-#include <mach/mt6577_boot.h>
-#endif
-#include <mach/mt_pm_ldo.h>
-#include <mach/mt_typedefs.h>
-#include <mach/mt_boot.h>
-
-#include <linux/rtpm_prio.h>
-//#include "tpd.h"
-#include "cust_gpio_usage.h"
-#include <pmic_drv.h>
-
-#include <cust_eint.h>
-#include <linux/jiffies.h>
-
-/* Pre-defined definition */
-#define TPD_KEY_COUNT   4
-#define key_1           60,850              //auto define  
-#define key_2           180,850
-#define key_3           300,850
-#define key_4           420,850
-
-#define TPD_KEYS        {KEY_BACK, KEY_HOME, KEY_MENU, KEY_SEARCH}
-#define TPD_KEYS_DIM    {{key_1,50,30},{key_2,50,30},{key_3,50,30},{key_4,50,30}}
-extern u16 show_len;
-extern u16 total_len;
-extern u8 gtp_rawdiff_mode;
-
-extern int tpd_halt;
-extern s32 gtp_send_cfg(struct i2c_client *client);
-extern void gtp_reset_guitar(struct i2c_client *client, s32 ms);
-extern void gtp_int_sync(s32 ms);       
-extern u8 gup_init_update_proc(struct i2c_client *client);
-extern u8 gup_init_fw_proc(struct i2c_client *client);
-extern void mt65xx_eint_unmask(unsigned int line);
-extern void mt65xx_eint_mask(unsigned int line);
-extern s32 gtp_i2c_read(struct i2c_client *client, u8 *buf, s32 len);
-extern s32 gtp_i2c_write(struct i2c_client *client,u8 *buf,s32 len);
-extern int i2c_write_bytes(struct i2c_client *client, u16 addr, u8 *txbuf, int len);
-extern int i2c_read_bytes(struct i2c_client *client, u16 addr, u8 *rxbuf, int len);
-extern s32 i2c_read_dbl_check(struct i2c_client *client, u16 addr, u8 *rxbuf, int len);
-extern s32 gtp_i2c_read_dbl_check(struct i2c_client *client, u16 addr, u8 *rxbuf, int len);
-
-//***************************PART1:ON/OFF define*******************************
-#define GTP_CUSTOM_CFG        0
-#define GTP_DRIVER_SEND_CFG   1       // driver send config to TP in intilization
-#define GTP_HAVE_TOUCH_KEY    1
-#define GTP_POWER_CTRL_SLEEP  0       // turn off/on power on suspend/resume
-
-#define GTP_AUTO_UPDATE       0       // auto updated fw by .bin file
-#define GTP_HEADER_FW_UPDATE  0       // auto updated fw by gtp_default_FW in gt9xx_firmware.h, function together with GTP_AUTO_UDPATE
-#define GTP_AUTO_UPDATE_CFG   0       // auto update config by .cfg file, function together with GTP_AUTO_UPDATE
-
-#define GTP_SUPPORT_I2C_DMA   0       // if gt9xxf, better enable it if hardware platform supported
-#define GTP_COMPATIBLE_MODE   0       // compatible with GT9XXF
-
-#define GTP_CREATE_WR_NODE    1
-#define GTP_ESD_PROTECT       0       // esd protection with a cycle of 2 seconds
-#define GTP_CHARGER_SWITCH    0       // charger plugin & plugout detect
-
-#define GTP_WITH_PEN          0      
-#define GTP_PEN_HAVE_BUTTON   0       // active pen has buttons, functions together with GTP_WITH_PEN
-
-#define GTP_GESTURE_WAKEUP    0 
-
-#define TPD_PROXIMITY
-//#define TPD_HAVE_BUTTON             // report key as coordinate,Vibration feedback
-#define TPD_WARP_X                  // mirrored x coordinate
-#define TPD_WARP_Y                  // mirrored y coordinate
-#define GTP_DEBUG_ON          0//1
-#define GTP_DEBUG_ARRAY_ON    0
-#define GTP_DEBUG_FUNC_ON     0
-
-//***************************PART2:TODO define**********************************
-//STEP_1(REQUIRED):Change config table.
-// Sensor_ID Map:
-/* sensor_opt1 sensor_opt2 Sensor_ID 
-    GND         GND         0 
-    VDDIO       GND         1 
-    NC          GND         2 
-    GND         NC/300K     3 
-    VDDIO       NC/300K     4 
-    NC          NC/300K     5 
-*/
-// TODO: define your own default or for Sensor_ID == 0 config here. 
-// The predefined one is just a sample config, which is not suitable for your tp in most cases.
-
-//add clj 20150203 q32  shanghai_youxia
- 
-#if 0
-
-#define CTP_CFG_GROUP1 {\
-    0x43,0xD0,0x02,0x00,0x05,0x05,0x05,0x00,0x01,0x0F,\
-    0x28,0x0F,0x50,0x32,0x03,0x05,0x00,0x00,0xFF,0x7F,\
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x89,0x09,0x0A,\
-    0x2D,0x00,0x0F,0x0A,0x00,0x14,0x01,0x02,0x33,0x1D,\
-    0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x32,0x00,0x28,\
-    0x7A,0x23,0x55,0x94,0xC5,0x02,0x07,0x00,0x00,0x04,\
-    0x95,0x26,0x00,0x80,0x2D,0x00,0x6C,0x36,0x00,0x5C,\
-    0x41,0x00,0x4E,0x4E,0x00,0x4E,0x00,0x00,0x00,0x00,\
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x32,0x02,0x14,\
-    0x1E,0x01,0x1D,0x1E,0x14,0x0F,0x00,0x00,0x01,0x00,\
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x19,0x00,0x00,\
-    0x46,0x32,0x08,0x0A,0x0C,0x0E,0x10,0x12,0x14,0x16,\
-    0x18,0x1A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
-    0x0A,0x00,0x2A,0x29,0x28,0x24,0x22,0x20,0x1F,0x1E,\
-    0x1D,0x00,0x02,0x04,0x05,0x06,0x08,0x0A,0x0C,0x0E,\
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
-    0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\
-    0xFF,0xFF,0xFF,0xFF,0x8A,0x01\
-    }
-#else 
-//add clj q33
-
-#define CTP_CFG_GROUP1 {\
-    0x44,0xD0,0x02,0x00,0x05,0x05,0x05,0x01,0x01,0x0F,\
-0x28,0x0F,0x46,0x32,0x03,0x05,0x00,0x00,0xFF,0x7F,\
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x8B,0x0B,0x0C,\
-0x28,0x2A,0x0F,0x0A,0x00,0x14,0x00,0x03,0x22,0x1D,\
-0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x32,0x00,0x28,\
-0x7B,0x1E,0x50,0x94,0xC5,0x02,0x07,0x00,0x00,0x04,\
-0x98,0x21,0x00,0x80,0x28,0x00,0x6B,0x31,0x00,0x5B,\
-0x3B,0x00,0x4D,0x48,0x00,0x4D,0x38,0x00,0x00,0x00,\
-0xF0,0x30,0x20,0xFF,0xFF,0x27,0x00,0x32,0x02,0x14,\
-0x1E,0x99,0x1D,0x1E,0x14,0x0F,0x00,0x00,0x01,0x00,\
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x19,0x00,0x00,\
-0x46,0x32,0x18,0x16,0x14,0x12,0x10,0x0E,0x0C,0x0A,\
-0x08,0x06,0x04,0x02,0xFF,0xFF,0x00,0x00,0x00,0x00,\
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
-0x0A,0x00,0x02,0x04,0x06,0x08,0x0A,0x0C,0x0F,0x10,\
-0x12,0x13,0x16,0x18,0x1C,0x1D,0x1E,0x1F,0x20,0x21,\
-0x22,0x24,0x26,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x00,\
-0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\
-0xFF,0xAF,0xFF,0xFF,0x85,0x01 \
-    }
-#endif 
-
-
-// TODO: define your config for Sensor_ID == 1 here, if needed
-#define CTP_CFG_GROUP2 {\
-    }
-
-// TODO: define your config for Sensor_ID == 2 here, if needed
-#define CTP_CFG_GROUP3 {\
-    }
-
-// TODO: define your config for Sensor_ID == 3 here, if needed
-#define CTP_CFG_GROUP4 {\
-    }
-
-// TODO: define your config for Sensor_ID == 4 here, if needed
-#define CTP_CFG_GROUP5 {\
-    }
-
-// TODO: define your config for Sensor_ID == 5 here, if needed
-#define CTP_CFG_GROUP6 {\
-    }
-
-// STEP_2(REQUIRED): Customize your I/O ports & I/O operations here
-#define TPD_POWER_SOURCE_CUSTOM     PMIC_APP_CAP_TOUCH_VDD//MT65XX_POWER_LDO_VGP4      // define your power source for tp if needed
-#define GTP_RST_PORT    GPIO_CTP_RST_PIN
-#define GTP_INT_PORT    GPIO_CTP_EINT_PIN
-
-#define GTP_GPIO_AS_INPUT(pin)          do{\
-                                            if(pin == GPIO_CTP_EINT_PIN)\
-                                                mt_set_gpio_mode(pin, GPIO_CTP_EINT_PIN_M_GPIO);\
-                                            else\
-                                                mt_set_gpio_mode(pin, GPIO_CTP_RST_PIN_M_GPIO);\
-                                            mt_set_gpio_dir(pin, GPIO_DIR_IN);\
-                                            mt_set_gpio_pull_enable(pin, GPIO_PULL_DISABLE);\
-                                        }while(0)
-#define GTP_GPIO_AS_INT(pin)            do{\
-                                            mt_set_gpio_mode(pin, GPIO_CTP_EINT_PIN_M_EINT);\
-                                            mt_set_gpio_dir(pin, GPIO_DIR_IN);\
-                                            mt_set_gpio_pull_enable(pin, GPIO_PULL_DISABLE);\
-                                        }while(0)
-#define GTP_GPIO_GET_VALUE(pin)         mt_get_gpio_in(pin)
-#define GTP_GPIO_OUTPUT(pin,level)      do{\
-                                            if(pin == GPIO_CTP_EINT_PIN)\
-                                                mt_set_gpio_mode(pin, GPIO_CTP_EINT_PIN_M_GPIO);\
-                                            else\
-                                                mt_set_gpio_mode(pin, GPIO_CTP_RST_PIN_M_GPIO);\
-                                            mt_set_gpio_dir(pin, GPIO_DIR_OUT);\
-                                            mt_set_gpio_out(pin, level);\
-                                        }while(0)
-#define GTP_GPIO_REQUEST(pin, label)    gpio_request(pin, label)
-#define GTP_GPIO_FREE(pin)              gpio_free(pin)
-#define GTP_IRQ_TAB                     {IRQ_TYPE_EDGE_RISING, IRQ_TYPE_EDGE_FALLING, IRQ_TYPE_LEVEL_LOW, IRQ_TYPE_LEVEL_HIGH}
-
-// STEP_3(optional):Custom set some config by themself,if need.
-#if GTP_CUSTOM_CFG
-  #define GTP_MAX_HEIGHT   1280           
-  #define GTP_MAX_WIDTH    720
-  #define GTP_INT_TRIGGER  0    //0:Rising 1:Falling
-#else 
-  #define GTP_MAX_HEIGHT   1280  //4096
-  #define GTP_MAX_WIDTH    720
-  #define GTP_INT_TRIGGER  1
-#endif
-#define GTP_MAX_TOUCH      5
-#define VELOCITY_CUSTOM
-#define TPD_VELOCITY_CUSTOM_X 15
-#define TPD_VELOCITY_CUSTOM_Y 15
-
-//STEP_4(optional):If this project have touch key,Set touch key config.                                    
-#if GTP_HAVE_TOUCH_KEY
-    #define GTP_KEY_TAB  {KEY_FINGER, KEY_HOME, KEY_BACK, KEY_SEND}
-#endif
-
-//***************************PART3:OTHER define*********************************
-#define GTP_DRIVER_VERSION          "V2.2<2014/01/14>"
-#define GTP_I2C_NAME                "Goodix-TS"
-#define GT91XX_CONFIG_PROC_FILE     "gt9xx_config"
-#define GTP_POLL_TIME               10
-#define GTP_ADDR_LENGTH             2
-#define GTP_CONFIG_MIN_LENGTH       186
-#define GTP_CONFIG_MAX_LENGTH       240
-#define FAIL                        0
-#define SUCCESS                     1
-#define SWITCH_OFF                  0
-#define SWITCH_ON                   1
-
-#define CFG_GROUP_LEN(p_cfg_grp)  (sizeof(p_cfg_grp) / sizeof(p_cfg_grp[0]))
-
-//******************** For GT9XXF Start **********************//
-#if GTP_COMPATIBLE_MODE
-typedef enum
-{
-    CHIP_TYPE_GT9  = 0,
-    CHIP_TYPE_GT9F = 1,
-} CHIP_TYPE_T;
-#endif
-
-#define GTP_REG_MATRIX_DRVNUM           0x8069
-#define GTP_REG_MATRIX_SENNUM           0x806A
-#define GTP_REG_RQST                    0x8043
-#define GTP_REG_BAK_REF                 0x99D0
-#define GTP_REG_MAIN_CLK                0x8020
-#define GTP_REG_CHIP_TYPE               0x8000
-#define GTP_REG_HAVE_KEY                0x804E
-
-#define GTP_FL_FW_BURN              0x00
-#define GTP_FL_ESD_RECOVERY         0x01
-#define GTP_FL_READ_REPAIR          0x02
-
-#define GTP_BAK_REF_SEND                0
-#define GTP_BAK_REF_STORE               1
-#define CFG_LOC_DRVA_NUM                29
-#define CFG_LOC_DRVB_NUM                30
-#define CFG_LOC_SENS_NUM                31
-
-#define GTP_CHK_FW_MAX                  1000
-#define GTP_CHK_FS_MNT_MAX              300
-#define GTP_BAK_REF_PATH                "/data/gtp_ref.bin"
-#define GTP_MAIN_CLK_PATH               "/data/gtp_clk.bin"
-#define GTP_RQST_CONFIG                 0x01
-#define GTP_RQST_BAK_REF                0x02
-#define GTP_RQST_RESET                  0x03
-#define GTP_RQST_MAIN_CLOCK             0x04
-#define GTP_RQST_RESPONDED              0x00
-#define GTP_RQST_IDLE                   0xFF
-
-//******************** For GT9XXF End **********************//
-
-//Register define
-#define GTP_READ_COOR_ADDR          0x814E
-#define GTP_REG_SLEEP               0x8040
-#define GTP_REG_SENSOR_ID           0x814A
-#define GTP_REG_CONFIG_DATA         0x8047
-#define GTP_REG_VERSION             0x8140
-#define GTP_REG_HW_INFO             0x4220
-
-#define RESOLUTION_LOC              3
-#define TRIGGER_LOC                 8
-
-#define I2C_MASTER_CLOCK                300
-#define I2C_BUS_NUMBER                  1     // I2C Bus for TP, mt6572
-#define GTP_DMA_MAX_TRANSACTION_LENGTH  255   // for DMA mode
-#define GTP_DMA_MAX_I2C_TRANSFER_SIZE   (GTP_DMA_MAX_TRANSACTION_LENGTH - GTP_ADDR_LENGTH)
-#define MAX_TRANSACTION_LENGTH          8
-#define MAX_I2C_TRANSFER_SIZE           (MAX_TRANSACTION_LENGTH - GTP_ADDR_LENGTH)
-#define TPD_MAX_RESET_COUNT             3
-#define TPD_CALIBRATION_MATRIX          {962,0,0,0,1600,0,0,0};
-
-
-#define TPD_RESET_ISSUE_WORKAROUND
-#define TPD_HAVE_CALIBRATION
-#define TPD_NO_GPIO
-#define TPD_RESET_ISSUE_WORKAROUND
-
-#ifdef TPD_WARP_X
-#undef TPD_WARP_X
-#define TPD_WARP_X(x_max, x) ( x_max - 1 - x )
-#else
-#define TPD_WARP_X(x_max, x) x
-#endif
-
-#ifdef TPD_WARP_Y
-#undef TPD_WARP_Y
-#define TPD_WARP_Y(y_max, y) ( y_max - 1 - y )
-#else
-#define TPD_WARP_Y(y_max, y) y
-#endif
-
-//Log define
-#define GTP_INFO(fmt,arg...)           printk("<<-GTP-INFO->> "fmt"\n",##arg)
-#define GTP_ERROR(fmt,arg...)          printk("<<-GTP-ERROR->> "fmt"\n",##arg)
-#define GTP_DEBUG(fmt,arg...)          do{\
-                                         if(GTP_DEBUG_ON)\
-                                         printk("<<-GTP-DEBUG->> [%d]"fmt"\n",__LINE__, ##arg);\
-                                       }while(0)
-#define GTP_DEBUG_ARRAY(array, num)    do{\
-                                         s32 i;\
-                                         u8* a = array;\
-                                         if(GTP_DEBUG_ARRAY_ON)\
-                                         {\
-                                            printk("<<-GTP-DEBUG-ARRAY->>\n");\
-                                            for (i = 0; i < (num); i++)\
-                                            {\
-                                                printk("%02x   ", (a)[i]);\
-                                                if ((i + 1 ) %10 == 0)\
-                                                {\
-                                                    printk("\n");\
-                                                }\
-                                            }\
-                                            printk("\n");\
-                                        }\
-                                       }while(0)
-#define GTP_DEBUG_FUNC()               do{\
-                                         if(GTP_DEBUG_FUNC_ON)\
-                                         printk("<<-GTP-FUNC->> Func:%s@Line:%d\n",__func__,__LINE__);\
-                                       }while(0)
-#define GTP_SWAP(x, y)                 do{\
-                                         typeof(x) z = x;\
-                                         x = y;\
-                                         y = z;\
-                                       }while (0)
-
-
-//*****************************End of Part III********************************
-
-#endif /* TPD_CUSTOM_GT9XX_H__ */
diff --git a/drivers/input/touchscreen/mediatek/GT915_QHD/gt9xx_driver.c~ b/drivers/input/touchscreen/mediatek/GT915_QHD/gt9xx_driver.c~
deleted file mode 100755
index 0a91217..0000000
--- a/drivers/input/touchscreen/mediatek/GT915_QHD/gt9xx_driver.c~
+++ /dev/null
@@ -1,3276 +0,0 @@
-/* Copyright Statement:
- *
- * This software/firmware and related documentation ("MediaTek Software") are
- * protected under relevant copyright laws. The information contained herein
- * is confidential and proprietary to MediaTek Inc. and/or its licensors.
- * Without the prior written permission of MediaTek inc. and/or its licensors,
- * any reproduction, modification, use or disclosure of MediaTek Software,
- * and information contained herein, in whole or in part, shall be strictly prohibited.
- *  
- * MediaTek Inc. (C) 2012. All rights reserved. 
- * 
- * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
- * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
- * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
- * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
- * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
- * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
- * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
- * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
- * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
- * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
- * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
- * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
- * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
- * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
- * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
- * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
- *
- * The following software/firmware and/or related documentation ("MediaTek Software")
- * have been modified by MediaTek Inc. All revisions are subject to any receiver's
- * applicable license agreements with MediaTek Inc.
- */
- 
-/*
- * Version: V2.0
- * Release Date: 2013/08/28
- * Contact: andrew@goodix.com, meta@goodix.com
- * Revision Record:
- *      V1.4:
- *          1. New Heartbeat/ESD-protect Mechanism(external watchdog)
- *          2. doze mode, sliding wakeup
- *          3. config length verification & 3 more config groups(GT9 Sensor_ID: 0 ~ 5)
- *          4. charger status switch
- *                  By Meta, 2013/03/11
- *      V1.6:
- *          1. pen/stylus support 
- *          2. slide wakeup, new esd optimization
- *                  By Meta, 2013/04/18
- *      V1.8:
- *          1. read double check & fixed config support
- *          2. other optimizations
- *                  By Meta, 2013/06/08
- *      V2.0:
- *          1. compatible with GT9XXF
- *          2. I2C DMA support
- *                  By Meta, 2013/08/28
- *      V2.2:
- *          1. update gt9xx_config to compatible with Linux 3.10
- *          2. gesture wakeup
- *          3. pen separate input device, active-pen button support
- *          4. coordinates & keys optimization
- *          5. no longer support GT915S
- *                  By Meta, 2014/01/14
- */
-
-#include "tpd.h"
-#include "tpd_custom_gt9xx.h"
-
-#ifndef TPD_NO_GPIO
-#include "cust_gpio_usage.h" 
-#endif
-#ifdef TPD_PROXIMITY
-#include <linux/hwmsensor.h>
-#include <linux/hwmsen_dev.h>
-#include <linux/sensors_io.h>
-#endif
-
-#if GTP_SUPPORT_I2C_DMA
-    #include <linux/dma-mapping.h>
-#endif
-
-extern struct tpd_device *tpd;
-
-static int tpd_flag = 0; 
-int tpd_halt = 0;
-static struct task_struct *thread = NULL;
-static DECLARE_WAIT_QUEUE_HEAD(waiter);
-
-#ifdef TPD_HAVE_BUTTON
-static int tpd_keys_local[TPD_KEY_COUNT] = TPD_KEYS;
-static int tpd_keys_dim_local[TPD_KEY_COUNT][4] = TPD_KEYS_DIM;
-#endif
-
-#if GTP_GESTURE_WAKEUP
-typedef enum
-{
-    DOZE_DISABLED = 0,
-    DOZE_ENABLED = 1,
-    DOZE_WAKEUP = 2,
-}DOZE_T;
-static DOZE_T doze_status = DOZE_DISABLED;
-static s8 gtp_enter_doze(struct i2c_client *client);
-#endif
-
-#if GTP_CHARGER_SWITCH
-    #ifdef MT6573
-        #define CHR_CON0      (0xF7000000+0x2FA00)
-    #else
-        extern kal_bool upmu_is_chr_det(void);
-    #endif
-    static void gtp_charger_switch(s32 dir_update);
-#endif 
-
-#if GTP_HAVE_TOUCH_KEY
-const u16 touch_key_array[] = GTP_KEY_TAB;
-#define GTP_MAX_KEY_NUM ( sizeof( touch_key_array )/sizeof( touch_key_array[0] ) )
-#endif
-
-#if (defined(TPD_WARP_START) && defined(TPD_WARP_END))
-static int tpd_wb_start_local[TPD_WARP_CNT] = TPD_WARP_START;
-static int tpd_wb_end_local[TPD_WARP_CNT]   = TPD_WARP_END;
-#endif
-
-#if (defined(TPD_HAVE_CALIBRATION) && !defined(TPD_CUSTOM_CALIBRATION))
-//static int tpd_calmat_local[8]     = TPD_CALIBRATION_MATRIX;
-static int tpd_def_calmat_local[8] = TPD_CALIBRATION_MATRIX;
-#endif
-
-#if GTP_SUPPORT_I2C_DMA
-s32 i2c_dma_write(struct i2c_client *client, u16 addr, u8 *txbuf, s32 len);
-s32 i2c_dma_read(struct i2c_client *client, u16 addr, u8 *rxbuf, s32 len);
-
-static u8 *gpDMABuf_va = NULL;
-static u32 gpDMABuf_pa = 0;
-#endif
-
-s32 gtp_send_cfg(struct i2c_client *client);
-void gtp_reset_guitar(struct i2c_client *client, s32 ms);
-static void tpd_eint_interrupt_handler(void);
-static int touch_event_handler(void *unused);
-static int tpd_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id);
-static int tpd_i2c_detect(struct i2c_client *client, struct i2c_board_info *info);
-static int tpd_i2c_remove(struct i2c_client *client);
-s32 gtp_i2c_read_dbl_check(struct i2c_client *client, u16 addr, u8 *rxbuf, int len);
-extern void mt65xx_eint_unmask(unsigned int line);
-extern void mt65xx_eint_mask(unsigned int line);
-
-#ifndef MT6572
-extern void mt65xx_eint_set_hw_debounce(kal_uint8 eintno, kal_uint32 ms);
-extern kal_uint32 mt65xx_eint_set_sens(kal_uint8 eintno, kal_bool sens);
-extern void mt65xx_eint_registration(kal_uint8 eintno, kal_bool Dbounce_En,
-                                     kal_bool ACT_Polarity, void (EINT_FUNC_PTR)(void),
-                                     kal_bool auto_umask);
-#endif
-
-
-//add clj 20150203
-extern void mt_eint_mask(unsigned int eint_num);
-extern void mt_eint_unmask(unsigned int eint_num);
-extern void mt_eint_set_hw_debounce(unsigned int eint_num, unsigned int ms);
-extern void mt_eint_set_polarity(unsigned int eint_num, unsigned int pol);
-extern unsigned int mt_eint_set_sens(unsigned int eint_num, unsigned int sens);
-extern void mt_eint_registration(unsigned int eint_num, unsigned int flow, void (EINT_FUNC_PTR)(void), unsigned int is_auto_umask);
-extern void mt_eint_print_status(void);
-//end add 
-
-
-#if GTP_CREATE_WR_NODE
-extern s32 init_wr_node(struct i2c_client *);
-extern void uninit_wr_node(void);
-#endif
-
-#if (GTP_ESD_PROTECT || GTP_COMPATIBLE_MODE)
-static void force_reset_guitar(void);
-#endif
-
-#if GTP_ESD_PROTECT
-static int clk_tick_cnt = 200;
-static struct delayed_work gtp_esd_check_work;
-static struct workqueue_struct *gtp_esd_check_workqueue = NULL;
-static s32 gtp_init_ext_watchdog(struct i2c_client *client);
-static void gtp_esd_check_func(struct work_struct *);
-void gtp_esd_switch(struct i2c_client *client, s32 on);
-u8 esd_running = 0;
-spinlock_t esd_lock;
-#endif
-
-
-#ifdef TPD_PROXIMITY
-#define TPD_PROXIMITY_VALID_REG                   0x814E
-#define TPD_PROXIMITY_ENABLE_REG                  0x8042
-static u8 tpd_proximity_flag = 0;
-static u8 tpd_proximity_flag_one 	= 0;	//jeff add 20150317
-static u8 tpd_proximity_detect = 1;//0-->close ; 1--> far away
-#endif
-
-struct i2c_client *i2c_client_point = NULL;
-static const struct i2c_device_id tpd_i2c_id[] = {{"gt9xx", 0}, {}};
-static unsigned short force[] = {0, 0xBA, I2C_CLIENT_END, I2C_CLIENT_END};
-static const unsigned short *const forces[] = { force, NULL };
-//static struct i2c_client_address_data addr_data = { .forces = forces,};
-static struct i2c_board_info __initdata i2c_tpd = { I2C_BOARD_INFO("gt9xx", (0xBA >> 1))};
-static struct i2c_driver tpd_i2c_driver =
-{
-    .probe = tpd_i2c_probe,
-    .remove = tpd_i2c_remove,
-    .detect = tpd_i2c_detect,
-    .driver.name = "gt9xx",
-    .id_table = tpd_i2c_id,
-    .address_list = (const unsigned short *) forces,
-};
-
-
-static u8 config[GTP_CONFIG_MAX_LENGTH + GTP_ADDR_LENGTH]
-    = {GTP_REG_CONFIG_DATA >> 8, GTP_REG_CONFIG_DATA & 0xff};
-
-#pragma pack(1)
-typedef struct
-{
-    u16 pid;                 //product id   //
-    u16 vid;                 //version id   //
-} st_tpd_info;
-#pragma pack()
-
-st_tpd_info tpd_info;
-u8 int_type = 0;
-u32 abs_x_max = 0;
-u32 abs_y_max = 0;
-u8 gtp_rawdiff_mode = 0;
-u8 cfg_len = 0;
-u8 grp_cfg_version = 0;
-u8 fixed_config = 0;
-u8 pnl_init_error = 0;
-
-#if GTP_WITH_PEN
-struct input_dev *pen_dev;
-#endif
-
-#if GTP_COMPATIBLE_MODE
-u8 driver_num = 0;
-u8 sensor_num = 0;
-u8 gtp_ref_retries = 0;
-u8 gtp_clk_retries = 0;
-CHIP_TYPE_T gtp_chip_type = CHIP_TYPE_GT9;
-u8 rqst_processing = 0;
-u8 is_950 = 0;
-
-extern u8 gup_check_fs_mounted(char *path_name);
-extern u8 gup_clk_calibration(void);
-extern s32 gup_fw_download_proc(void *dir, u8 dwn_mode);
-void gtp_get_chip_type(struct i2c_client *client);
-u8 gtp_fw_startup(struct i2c_client *client);
-static u8 gtp_bak_ref_proc(struct i2c_client *client, u8 mode);
-static u8 gtp_main_clk_proc(struct i2c_client *client);
-static void gtp_recovery_reset(struct i2c_client *client);
-#endif
-
-/* proc file system */
-s32 i2c_read_bytes(struct i2c_client *client, u16 addr, u8 *rxbuf, int len);
-s32 i2c_write_bytes(struct i2c_client *client, u16 addr, u8 *txbuf, int len);
-
-static ssize_t gt91xx_config_read_proc(struct file *, char __user *, size_t, loff_t *);
-static ssize_t gt91xx_config_write_proc(struct file *, const char __user *, size_t, loff_t *);
-
-static struct proc_dir_entry *gt91xx_config_proc = NULL;
-static const struct file_operations config_proc_ops = {
-    .owner = THIS_MODULE,
-    .read = gt91xx_config_read_proc,
-    .write = gt91xx_config_write_proc,
-};
-
-#define VELOCITY_CUSTOM
-#ifdef VELOCITY_CUSTOM
-#include <linux/device.h>
-#include <linux/miscdevice.h>
-#include <asm/uaccess.h>
-
-#ifndef TPD_VELOCITY_CUSTOM_X
-#define TPD_VELOCITY_CUSTOM_X 10
-#endif
-#ifndef TPD_VELOCITY_CUSTOM_Y
-#define TPD_VELOCITY_CUSTOM_Y 10
-#endif
-
-// for magnify velocity********************************************
-#define TOUCH_IOC_MAGIC 'A'
-
-#define TPD_GET_VELOCITY_CUSTOM_X _IO(TOUCH_IOC_MAGIC,0)
-#define TPD_GET_VELOCITY_CUSTOM_Y _IO(TOUCH_IOC_MAGIC,1)
-
-int g_v_magnify_x = TPD_VELOCITY_CUSTOM_X;
-int g_v_magnify_y = TPD_VELOCITY_CUSTOM_Y;
-static int tpd_misc_open(struct inode *inode, struct file *file)
-{
-    return nonseekable_open(inode, file);
-}
-
-static int tpd_misc_release(struct inode *inode, struct file *file)
-{
-    return 0;
-}
-
-static long tpd_unlocked_ioctl(struct file *file, unsigned int cmd,
-                               unsigned long arg)
-{
-    //char strbuf[256];
-    void __user *data;
-
-    long err = 0;
-
-    if (_IOC_DIR(cmd) & _IOC_READ)
-    {
-        err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
-    }
-    else if (_IOC_DIR(cmd) & _IOC_WRITE)
-    {
-        err = !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
-    }
-
-    if (err)
-    {
-        printk("tpd: access error: %08X, (%2d, %2d)\n", cmd, _IOC_DIR(cmd), _IOC_SIZE(cmd));
-        return -EFAULT;
-    }
-
-    switch (cmd)
-    {
-        case TPD_GET_VELOCITY_CUSTOM_X:
-            data = (void __user *) arg;
-
-            if (data == NULL)
-            {
-                err = -EINVAL;
-                break;
-            }
-
-            if (copy_to_user(data, &g_v_magnify_x, sizeof(g_v_magnify_x)))
-            {
-                err = -EFAULT;
-                break;
-            }
-
-            break;
-
-        case TPD_GET_VELOCITY_CUSTOM_Y:
-            data = (void __user *) arg;
-
-            if (data == NULL)
-            {
-                err = -EINVAL;
-                break;
-            }
-
-            if (copy_to_user(data, &g_v_magnify_y, sizeof(g_v_magnify_y)))
-            {
-                err = -EFAULT;
-                break;
-            }
-
-            break;
-
-        default:
-            printk("tpd: unknown IOCTL: 0x%08x\n", cmd);
-            err = -ENOIOCTLCMD;
-            break;
-
-    }
-
-    return err;
-}
-
-
-static struct file_operations tpd_fops =
-{
-//  .owner = THIS_MODULE,
-    .open = tpd_misc_open,
-    .release = tpd_misc_release,
-    .unlocked_ioctl = tpd_unlocked_ioctl,
-};
-/*----------------------------------------------------------------------------*/
-static struct miscdevice tpd_misc_device =
-{
-    .minor = MISC_DYNAMIC_MINOR,
-    .name = "touch",
-    .fops = &tpd_fops,
-};
-
-//**********************************************
-#endif
-
-static int tpd_i2c_detect(struct i2c_client *client, struct i2c_board_info *info)
-{
-    strcpy(info->type, "mtk-tpd");
-    return 0;
-}
-
-#ifdef TPD_PROXIMITY
-static s32 tpd_get_ps_value(void)
-{
-    return tpd_proximity_detect;
-}
-
-static s32 tpd_enable_ps(s32 enable)
-{
-    u8  state;
-    s32 ret = -1;
-
-    if (enable)
-    {
-        state = 1;
-        tpd_proximity_flag = 1;
-        GTP_INFO("TPD proximity function to be on.");
-    }
-    else
-    {
-        state = 0;
-        tpd_proximity_flag = 0;
-        GTP_INFO("TPD proximity function to be off.");
-    }
-
-    ret = i2c_write_bytes(i2c_client_point, TPD_PROXIMITY_ENABLE_REG, &state, 1);
-
-    if (ret < 0)
-    {
-        GTP_ERROR("TPD %s proximity cmd failed.", state ? "enable" : "disable");
-        return ret;
-    }
-
-    GTP_INFO("TPD proximity function %s success.", state ? "enable" : "disable");
-    return 0;
-}
-
-s32 gt9xx_tpd_ps_operate(void *self, u32 command, void *buff_in, s32 size_in,
-                   void *buff_out, s32 size_out, s32 *actualout)
-{
-    s32 err = 0;
-    s32 value;
-    hwm_sensor_data *sensor_data;
-
-    switch (command)
-    {
-        case SENSOR_DELAY:
-            if ((buff_in == NULL) || (size_in < sizeof(int)))
-            {
-                GTP_ERROR("Set delay parameter error!");
-                err = -EINVAL;
-            }
-
-            // Do nothing
-            break;
-
-        case SENSOR_ENABLE:
-            if ((buff_in == NULL) || (size_in < sizeof(int)))
-            {
-                GTP_ERROR("Enable sensor parameter error!");
-                err = -EINVAL;
-            }
-            else
-            {
-                value = *(int *)buff_in;
-                err = tpd_enable_ps(value);
-            }
-
-            break;
-
-        case SENSOR_GET_DATA:
-            if ((buff_out == NULL) || (size_out < sizeof(hwm_sensor_data)))
-            {
-                GTP_ERROR("Get sensor data parameter error!");
-                err = -EINVAL;
-            }
-            else
-            {
-                sensor_data = (hwm_sensor_data *)buff_out;
-                sensor_data->values[0] = tpd_get_ps_value();
-                sensor_data->value_divide = 1;
-                sensor_data->status = SENSOR_STATUS_ACCURACY_MEDIUM;
-            }
-
-            break;
-
-        default:
-            GTP_ERROR("proxmy sensor operate function no this parameter %d!\n", command);
-            err = -1;
-            break;
-    }
-
-    return err;
-}
-#endif
-
-
-static ssize_t gt91xx_config_read_proc(struct file *file, char __user *page, size_t size, loff_t *ppos)
-{
-    char *ptr = page;
-    char temp_data[GTP_CONFIG_MAX_LENGTH + 2] = {0};
-    int i;
-    
-    if (*ppos)  // CMD call again
-    {
-        return 0;
-    }
-    
-    ptr += sprintf(ptr, "==== GT9XX config init value====\n");
-
-    for (i = 0 ; i < GTP_CONFIG_MAX_LENGTH ; i++)
-    {
-        ptr += sprintf(ptr, "0x%02X ", config[i + 2]);
-
-        if (i % 8 == 7)
-            ptr += sprintf(ptr, "\n");
-    }
-
-    ptr += sprintf(ptr, "\n");
-
-    ptr += sprintf(ptr, "==== GT9XX config real value====\n");
-    i2c_read_bytes(i2c_client_point, GTP_REG_CONFIG_DATA, temp_data, GTP_CONFIG_MAX_LENGTH);
-
-    for (i = 0 ; i < GTP_CONFIG_MAX_LENGTH ; i++)
-    {
-        ptr += sprintf(ptr, "0x%02X ", temp_data[i]);
-
-        if (i % 8 == 7)
-            ptr += sprintf(ptr, "\n");
-    }
-    *ppos += ptr - page;
-    return (ptr - page);
-}
-
-static ssize_t gt91xx_config_write_proc(struct file *filp, const char __user *buffer, size_t count, loff_t *off)
-{
-    s32 ret = 0;
-
-    GTP_DEBUG("write count %d\n", count);
-
-    if (count > GTP_CONFIG_MAX_LENGTH)
-    {
-        GTP_ERROR("size not match [%d:%d]\n", GTP_CONFIG_MAX_LENGTH, count);
-        return -EFAULT;
-    }
-
-    if (copy_from_user(&config[2], buffer, count))
-    {
-        GTP_ERROR("copy from user fail\n");
-        return -EFAULT;
-    }
-
-    ret = gtp_send_cfg(i2c_client_point);
-    abs_x_max = (config[RESOLUTION_LOC + 1] << 8) + config[RESOLUTION_LOC];
-    abs_y_max = (config[RESOLUTION_LOC + 3] << 8) + config[RESOLUTION_LOC + 2];
-    int_type = (config[TRIGGER_LOC]) & 0x03;
-
-    if (ret < 0)
-    {
-        GTP_ERROR("send config failed.");
-    }
-
-    return count;
-}
-
-#if GTP_SUPPORT_I2C_DMA
-s32 i2c_dma_read(struct i2c_client *client, u16 addr, u8 *rxbuf, s32 len)
-{
-    int ret;
-    s32 retry = 0;
-    u8 buffer[2];
-
-    struct i2c_msg msg[2] =
-    {
-        {
-            .addr = (client->addr & I2C_MASK_FLAG),
-            .flags = 0,
-            .buf = buffer,
-            .len = 2,
-            .timing = I2C_MASTER_CLOCK
-        },
-        {
-            .addr = (client->addr & I2C_MASK_FLAG),
-            .ext_flag = (client->ext_flag | I2C_ENEXT_FLAG | I2C_DMA_FLAG),
-            .flags = I2C_M_RD,
-            .buf = (u8*)gpDMABuf_pa,     
-            .len = len,
-            .timing = I2C_MASTER_CLOCK
-        },
-    };
-    
-    buffer[0] = (addr >> 8) & 0xFF;
-    buffer[1] = addr & 0xFF;
-
-    if (rxbuf == NULL)
-        return -1;
-
-    //GTP_DEBUG("dma i2c read: 0x%04X, %d bytes(s)", addr, len);
-    for (retry = 0; retry < 5; ++retry)
-    {
-        ret = i2c_transfer(client->adapter, &msg[0], 2);
-        if (ret < 0)
-        {
-            continue;
-        }
-        memcpy(rxbuf, gpDMABuf_va, len);
-        return 0;
-    }
-    GTP_ERROR("Dma I2C Read Error: 0x%04X, %d byte(s), err-code: %d", addr, len, ret);
-    return ret;
-}
-
-
-s32 i2c_dma_write(struct i2c_client *client, u16 addr, u8 *txbuf, s32 len)
-{
-    int ret;
-    s32 retry = 0;
-    u8 *wr_buf = gpDMABuf_va;
-    
-    struct i2c_msg msg =
-    {
-        .addr = (client->addr & I2C_MASK_FLAG),
-        .ext_flag = (client->ext_flag | I2C_ENEXT_FLAG | I2C_DMA_FLAG),
-        .flags = 0,
-        .buf = (u8*)gpDMABuf_pa,
-        .len = 2 + len,
-        .timing = I2C_MASTER_CLOCK
-    };
-    
-    wr_buf[0] = (u8)((addr >> 8) & 0xFF);
-    wr_buf[1] = (u8)(addr & 0xFF);
-
-    if (txbuf == NULL)
-        return -1;
-    
-    //GTP_DEBUG("dma i2c write: 0x%04X, %d bytes(s)", addr, len);
-    memcpy(wr_buf+2, txbuf, len);
-    for (retry = 0; retry < 5; ++retry)
-    {
-        ret = i2c_transfer(client->adapter, &msg, 1);
-        if (ret < 0)
-        {
-            continue;
-        }
-        return 0;
-    }
-    GTP_ERROR("Dma I2C Write Error: 0x%04X, %d byte(s), err-code: %d", addr, len, ret);
-    return ret;
-}
-
-s32 i2c_read_bytes_dma(struct i2c_client *client, u16 addr, u8 *rxbuf, s32 len)
-{
-    s32 left = len;
-    s32 read_len = 0;
-    u8 *rd_buf = rxbuf;
-    s32 ret = 0;    
-    
-    //GTP_DEBUG("Read bytes dma: 0x%04X, %d byte(s)", addr, len);
-    while (left > 0)
-    {
-        if (left > GTP_DMA_MAX_TRANSACTION_LENGTH)
-        {
-            read_len = GTP_DMA_MAX_TRANSACTION_LENGTH;
-        }
-        else
-        {
-            read_len = left;
-        }
-        ret = i2c_dma_read(client, addr, rd_buf, read_len);
-        if (ret < 0)
-        {
-            GTP_ERROR("dma read failed");
-            return -1;
-        }
-        
-        left -= read_len;
-        addr += read_len;
-        rd_buf += read_len;
-    }
-    return 0;
-}
-
-s32 i2c_write_bytes_dma(struct i2c_client *client, u16 addr, u8 *txbuf, s32 len)
-{
-
-    s32 ret = 0;
-    s32 write_len = 0;
-    s32 left = len;
-    u8 *wr_buf = txbuf;
-    
-    //GTP_DEBUG("Write bytes dma: 0x%04X, %d byte(s)", addr, len);
-    while (left > 0)
-    {
-        if (left > GTP_DMA_MAX_I2C_TRANSFER_SIZE)
-        {
-            write_len = GTP_DMA_MAX_I2C_TRANSFER_SIZE;
-        }
-        else
-        {
-            write_len = left;
-        }
-        ret = i2c_dma_write(client, addr, wr_buf, write_len);
-        
-        if (ret < 0)
-        {
-            GTP_ERROR("dma i2c write failed!");
-            return -1;
-        }
-        
-        left -= write_len;
-        addr += write_len;
-        wr_buf += write_len;
-    }
-    return 0;
-}
-#endif
-
-
-int i2c_read_bytes_non_dma(struct i2c_client *client, u16 addr, u8 *rxbuf, int len)
-{
-    u8 buffer[GTP_ADDR_LENGTH];
-    u8 retry;
-    u16 left = len;
-    u16 offset = 0;
-
-    struct i2c_msg msg[2] =
-    {
-        {
-            //.addr = ((client->addr &I2C_MASK_FLAG) | (I2C_ENEXT_FLAG)),
-            .addr = ((client->addr &I2C_MASK_FLAG) | (I2C_PUSHPULL_FLAG)),
-            .flags = 0,
-            .buf = buffer,
-            .len = GTP_ADDR_LENGTH,
-            .timing = I2C_MASTER_CLOCK
-        },
-        {
-            //.addr = ((client->addr &I2C_MASK_FLAG) | (I2C_ENEXT_FLAG)),
-            .addr = ((client->addr &I2C_MASK_FLAG) | (I2C_PUSHPULL_FLAG)),
-            .flags = I2C_M_RD,
-            .timing = I2C_MASTER_CLOCK
-        },
-    };
-
-    if (rxbuf == NULL)
-        return -1;
-
-    //GTP_DEBUG("i2c_read_bytes to device %02X address %04X len %d\n", client->addr, addr, len);
-
-    while (left > 0)
-    {
-        buffer[0] = ((addr + offset) >> 8) & 0xFF;
-        buffer[1] = (addr + offset) & 0xFF;
-
-        msg[1].buf = &rxbuf[offset];
-
-        if (left > MAX_TRANSACTION_LENGTH)
-        {
-            msg[1].len = MAX_TRANSACTION_LENGTH;
-            left -= MAX_TRANSACTION_LENGTH;
-            offset += MAX_TRANSACTION_LENGTH;
-        }
-        else
-        {
-            msg[1].len = left;
-            left = 0;
-        }
-
-        retry = 0;
-
-        while (i2c_transfer(client->adapter, &msg[0], 2) != 2)
-        {
-            retry++;
-
-            //if (retry == 20)
-            if (retry == 5)
-            {
-                GTP_ERROR("I2C read 0x%X length=%d failed\n", addr + offset, len);
-                return -1;
-            }
-        }
-    }
-
-    return 0;
-}
-
-
-int i2c_read_bytes(struct i2c_client *client, u16 addr, u8 *rxbuf, int len)
-{
-#if GTP_SUPPORT_I2C_DMA
-    return i2c_read_bytes_dma(client, addr, rxbuf, len);
-#else
-    return i2c_read_bytes_non_dma(client, addr, rxbuf, len);
-#endif
-}
-
-s32 gtp_i2c_read(struct i2c_client *client, u8 *buf, s32 len)
-{
-    s32 ret = -1;
-    u16 addr = (buf[0] << 8) + buf[1];
-
-    ret = i2c_read_bytes_non_dma(client, addr, &buf[2], len - 2);
-
-    if (!ret)
-    {
-        return 2;
-    }
-    else
-    {
-    #if GTP_GESTURE_WAKEUP
-        if (DOZE_ENABLED == doze_status)
-        {
-            return ret;
-        }
-    #endif
-    #if GTP_COMPATIBLE_MODE
-        if (CHIP_TYPE_GT9F == gtp_chip_type)
-        {
-            gtp_recovery_reset(client);
-        }
-        else
-    #endif
-        {
-            gtp_reset_guitar(client, 20);
-        }
-        return ret;
-    }
-}
-
-
-s32 gtp_i2c_read_dbl_check(struct i2c_client *client, u16 addr, u8 *rxbuf, int len)
-{
-    u8 buf[16] = {0};
-    u8 confirm_buf[16] = {0};
-    u8 retry = 0;
-    
-    while (retry++ < 3)
-    {
-        memset(buf, 0xAA, 16);
-        buf[0] = (u8)(addr >> 8);
-        buf[1] = (u8)(addr & 0xFF);
-        gtp_i2c_read(client, buf, len + 2);
-        
-        memset(confirm_buf, 0xAB, 16);
-        confirm_buf[0] = (u8)(addr >> 8);
-        confirm_buf[1] = (u8)(addr & 0xFF);
-        gtp_i2c_read(client, confirm_buf, len + 2);
-        
-        if (!memcmp(buf, confirm_buf, len+2))
-        {
-            memcpy(rxbuf, confirm_buf+2, len);
-            return SUCCESS;
-        }
-    }    
-    GTP_ERROR("i2c read 0x%04X, %d bytes, double check failed!", addr, len);
-    return FAIL;
-}
-
-int i2c_write_bytes_non_dma(struct i2c_client *client, u16 addr, u8 *txbuf, int len)
-{
-    u8 buffer[MAX_TRANSACTION_LENGTH];
-    u16 left = len;
-    u16 offset = 0;
-    u8 retry = 0;
-
-    struct i2c_msg msg =
-    {
-        //.addr = ((client->addr &I2C_MASK_FLAG) | (I2C_ENEXT_FLAG)),
-        .addr = ((client->addr &I2C_MASK_FLAG) | (I2C_PUSHPULL_FLAG)),
-        .flags = 0,
-        .buf = buffer,
-        .timing = I2C_MASTER_CLOCK,
-    };
-
-
-    if (txbuf == NULL)
-        return -1;
-
-    //GTP_DEBUG("i2c_write_bytes to device %02X address %04X len %d\n", client->addr, addr, len);
-
-    while (left > 0)
-    {
-        retry = 0;
-
-        buffer[0] = ((addr + offset) >> 8) & 0xFF;
-        buffer[1] = (addr + offset) & 0xFF;
-
-        if (left > MAX_I2C_TRANSFER_SIZE)
-        {
-            memcpy(&buffer[GTP_ADDR_LENGTH], &txbuf[offset], MAX_I2C_TRANSFER_SIZE);
-            msg.len = MAX_TRANSACTION_LENGTH;
-            left -= MAX_I2C_TRANSFER_SIZE;
-            offset += MAX_I2C_TRANSFER_SIZE;
-        }
-        else
-        {
-            memcpy(&buffer[GTP_ADDR_LENGTH], &txbuf[offset], left);
-            msg.len = left + GTP_ADDR_LENGTH;
-            left = 0;
-        }
-
-        //GTP_DEBUG("byte left %d offset %d\n", left, offset);
-
-        while (i2c_transfer(client->adapter, &msg, 1) != 1)
-        {
-            retry++;
-
-            //if (retry == 20)
-            if (retry == 5)
-            {
-                GTP_ERROR("I2C write 0x%X%X length=%d failed\n", buffer[0], buffer[1], len);
-                return -1;
-            }
-        }
-    }
-
-    return 0;
-}
-
-int i2c_write_bytes(struct i2c_client *client, u16 addr, u8 *txbuf, int len)
-{
-#if GTP_SUPPORT_I2C_DMA
-    return i2c_write_bytes_dma(client, addr, txbuf, len);
-#else
-    return i2c_write_bytes_non_dma(client, addr, txbuf, len);
-#endif
-}
-
-s32 gtp_i2c_write(struct i2c_client *client, u8 *buf, s32 len)
-{
-    s32 ret = -1;
-    u16 addr = (buf[0] << 8) + buf[1];
-
-    ret = i2c_write_bytes_non_dma(client, addr, &buf[2], len - 2);
-
-    if (!ret)
-    {
-        return 1;
-    }
-    else
-    {
-    #if GTP_GESTURE_WAKEUP
-        if (DOZE_ENABLED == doze_status)
-        {
-            return ret;
-        }
-    #endif
-    #if GTP_COMPATIBLE_MODE
-        if (CHIP_TYPE_GT9F == gtp_chip_type)
-        {
-            gtp_recovery_reset(client);
-        }
-        else
-    #endif
-        {
-            gtp_reset_guitar(client, 20);
-        }
-        return ret;
-    }
-}
-
-
-
-/*******************************************************
-Function:
-    Send config Function.
-
-Input:
-    client: i2c client.
-
-Output:
-    Executive outcomes.0--success,non-0--fail.
-*******************************************************/
-s32 gtp_send_cfg(struct i2c_client *client)
-{
-    s32 ret = 1;
-
-#if GTP_DRIVER_SEND_CFG
-    s32 retry = 0;
-    if (fixed_config)
-    {
-        GTP_INFO("Ic fixed config, no config sent!");
-        return 0;
-    }
-    else if (pnl_init_error)
-    {
-        GTP_INFO("Error occurred in init_panel, no config sent!");
-        return 0;
-    }
-    
-    GTP_INFO("Driver Send Config");
-    for (retry = 0; retry < 5; retry++)
-    {
-        ret = gtp_i2c_write(client, config, GTP_CONFIG_MAX_LENGTH + GTP_ADDR_LENGTH);
-
-        if (ret > 0)
-        {
-            break;
-        }
-    }
-#endif
-    return ret;
-}
-
-
-/*******************************************************
-Function:
-    Read goodix touchscreen version function.
-
-Input:
-    client: i2c client struct.
-    version:address to store version info
-
-Output:
-    Executive outcomes.0---succeed.
-*******************************************************/
-s32 gtp_read_version(struct i2c_client *client, u16 *version)
-{
-    s32 ret = -1;
-    s32 i;
-    u8 buf[8] = {GTP_REG_VERSION >> 8, GTP_REG_VERSION & 0xff};
-
-    GTP_DEBUG_FUNC();
-
-    ret = gtp_i2c_read(client, buf, sizeof(buf));
-
-    if (ret < 0)
-    {
-        GTP_ERROR("GTP read version failed");
-        return ret;
-    }
-
-    if (version)
-    {
-        *version = (buf[7] << 8) | buf[6];
-    }
-
-    tpd_info.vid = *version;
-    tpd_info.pid = 0x00;
-
-    for (i = 0; i < 4; i++)
-    {
-        if (buf[i + 2] < 0x30)break;
-
-        tpd_info.pid |= ((buf[i + 2] - 0x30) << ((3 - i) * 4));
-    }
-
-    if (buf[5] == 0x00)
-    {        
-        GTP_INFO("IC VERSION: %c%c%c_%02x%02x",
-             buf[2], buf[3], buf[4], buf[7], buf[6]);  
-    }
-    else
-    {
-        GTP_INFO("IC VERSION:%c%c%c%c_%02x%02x",
-             buf[2], buf[3], buf[4], buf[5], buf[7], buf[6]);
-    }
-    return ret;
-}
-
-#if GTP_DRIVER_SEND_CFG
-/*******************************************************
-Function:
-    Get information from ic, such as resolution and 
-    int trigger type
-Input:
-    client: i2c client private struct.
-
-Output:
-    FAIL: i2c failed, SUCCESS: i2c ok
-*******************************************************/
-static s32 gtp_get_info(struct i2c_client *client)
-{
-    u8 opr_buf[6] = {0};
-    s32 ret = 0;
-    
-    opr_buf[0] = (u8)((GTP_REG_CONFIG_DATA+1) >> 8);
-    opr_buf[1] = (u8)((GTP_REG_CONFIG_DATA+1) & 0xFF);
-    
-    ret = gtp_i2c_read(client, opr_buf, 6);
-    if (ret < 0)
-    {
-        return FAIL;
-    }
-    
-    abs_x_max = (opr_buf[3] << 8) + opr_buf[2];
-    abs_y_max = (opr_buf[5] << 8) + opr_buf[4];
-    
-    opr_buf[0] = (u8)((GTP_REG_CONFIG_DATA+6) >> 8);
-    opr_buf[1] = (u8)((GTP_REG_CONFIG_DATA+6) & 0xFF);
-    
-    ret = gtp_i2c_read(client, opr_buf, 3);
-    if (ret < 0)
-    {
-        return FAIL;
-    }
-    int_type = opr_buf[2] & 0x03;
-    
-    GTP_INFO("X_MAX = %d, Y_MAX = %d, TRIGGER = 0x%02x",
-            abs_x_max,abs_y_max, int_type);
-            
-    return SUCCESS;
-}
-#endif
-
-
-/*******************************************************
-Function:
-    GTP initialize function.
-
-Input:
-    client: i2c client private struct.
-
-Output:
-    Executive outcomes.0---succeed.
-*******************************************************/
-static s32 gtp_init_panel(struct i2c_client *client)
-{
-    s32 ret = 0;
-
-#if GTP_DRIVER_SEND_CFG
-    s32 i;
-    u8 check_sum = 0;
-    u8 opr_buf[16];
-    u8 sensor_id = 0;
-    //ret = gtp_i2c_read_dbl_check(client, GTP_REG_SENSOR_ID, &sensor_id, 1);//first:2 second:0
-    u8 cfg_info_group1[] = CTP_CFG_GROUP1;
-    u8 cfg_info_group2[] = CTP_CFG_GROUP2;
-    u8 cfg_info_group3[] = CTP_CFG_GROUP3;
-    u8 cfg_info_group4[] = CTP_CFG_GROUP4;
-    u8 cfg_info_group5[] = CTP_CFG_GROUP5;
-    u8 cfg_info_group6[] = CTP_CFG_GROUP6;
-    u8 *send_cfg_buf[] = {cfg_info_group1, cfg_info_group2, cfg_info_group3,
-                        cfg_info_group4, cfg_info_group5, cfg_info_group6};
-    u8 cfg_info_len[] = { CFG_GROUP_LEN(cfg_info_group1), 
-                          CFG_GROUP_LEN(cfg_info_group2),
-                          CFG_GROUP_LEN(cfg_info_group3),
-                          CFG_GROUP_LEN(cfg_info_group4), 
-                          CFG_GROUP_LEN(cfg_info_group5),
-                          CFG_GROUP_LEN(cfg_info_group6)};
-
-    GTP_DEBUG("Config Groups\' Lengths: %d, %d, %d, %d, %d, %d", 
-        cfg_info_len[0], cfg_info_len[1], cfg_info_len[2], cfg_info_len[3],
-        cfg_info_len[4], cfg_info_len[5]);
-
-    if ((!cfg_info_len[1]) && (!cfg_info_len[2]) && 
-        (!cfg_info_len[3]) && (!cfg_info_len[4]) && 
-        (!cfg_info_len[5]))
-    {
-        sensor_id = 0; 
-    }
-    else
-    {
-    #if GTP_COMPATIBLE_MODE
-        if (CHIP_TYPE_GT9F == gtp_chip_type)
-        {
-            msleep(50);
-        }
-    #endif
-        ret = gtp_i2c_read_dbl_check(client, GTP_REG_SENSOR_ID, &sensor_id, 1);
-        if (SUCCESS == ret)
-        {
-            if (sensor_id >= 0x06)
-            {
-                GTP_ERROR("Invalid sensor_id(0x%02X), No Config Sent!", sensor_id);
-                pnl_init_error = 1;
-                return -1;
-            }
-        }
-        else
-        {
-            GTP_ERROR("Failed to get sensor_id, No config sent!");
-            pnl_init_error = 1;
-            return -1;
-        }
-        GTP_INFO("Sensor_ID: %d", sensor_id);
-    }
-    
-    cfg_len = cfg_info_len[sensor_id];
-    
-    GTP_INFO("CTP_CONFIG_GROUP%d used, config length: %d", sensor_id + 1, cfg_len);
-    
-    if (cfg_len < GTP_CONFIG_MIN_LENGTH)
-    {
-        GTP_ERROR("CTP_CONFIG_GROUP%d is INVALID CONFIG GROUP! NO Config Sent! You need to check you header file CFG_GROUP section!", sensor_id+1);
-        pnl_init_error = 1;
-        return -1;
-    }
-    
-#if GTP_COMPATIBLE_MODE
-    if (CHIP_TYPE_GT9F == gtp_chip_type)
-    {
-        fixed_config = 0;
-    }
-    else
-#endif
-    {
-        ret = gtp_i2c_read_dbl_check(client, GTP_REG_CONFIG_DATA, &opr_buf[0], 1);
-        
-        if (ret == SUCCESS)
-        {
-            GTP_DEBUG("CFG_CONFIG_GROUP%d Config Version: %d, 0x%02X; IC Config Version: %d, 0x%02X", sensor_id+1, 
-                        send_cfg_buf[sensor_id][0], send_cfg_buf[sensor_id][0], opr_buf[0], opr_buf[0]);
-            
-            if (opr_buf[0] < 90)
-            {
-                grp_cfg_version = send_cfg_buf[sensor_id][0];       // backup group config version
-                send_cfg_buf[sensor_id][0] = 0x00;
-                fixed_config = 0;
-            }
-            else        // treated as fixed config, not send config
-            {
-                GTP_INFO("Ic fixed config with config version(%d)", opr_buf[0]);
-                fixed_config = 1;
-                gtp_get_info(client);
-                return 0;
-            }
-        }
-        else
-        {
-            GTP_ERROR("Failed to get ic config version!No config sent!");
-            return -1;
-        }
-    }
-    
-    memset(&config[GTP_ADDR_LENGTH], 0, GTP_CONFIG_MAX_LENGTH);
-    memcpy(&config[GTP_ADDR_LENGTH], send_cfg_buf[sensor_id], cfg_len);
-
-#if GTP_CUSTOM_CFG
-    config[RESOLUTION_LOC]     = (u8)GTP_MAX_WIDTH;
-    config[RESOLUTION_LOC + 1] = (u8)(GTP_MAX_WIDTH>>8);
-    config[RESOLUTION_LOC + 2] = (u8)GTP_MAX_HEIGHT;
-    config[RESOLUTION_LOC + 3] = (u8)(GTP_MAX_HEIGHT>>8);
-    
-    if (GTP_INT_TRIGGER == 0)  //RISING
-    {
-        config[TRIGGER_LOC] &= 0xfe; 
-    }
-    else if (GTP_INT_TRIGGER == 1)  //FALLING
-    {
-        config[TRIGGER_LOC] |= 0x01;
-    }
-#endif  // GTP_CUSTOM_CFG
-    
-    check_sum = 0;
-    for (i = GTP_ADDR_LENGTH; i < cfg_len; i++)
-    {
-        check_sum += config[i];
-    }
-    config[cfg_len] = (~check_sum) + 1;
-    
-#else // DRIVER NOT SEND CONFIG
-    cfg_len = GTP_CONFIG_MAX_LENGTH;
-    ret = gtp_i2c_read(client, config, cfg_len + GTP_ADDR_LENGTH);
-    if (ret < 0)
-    {
-        GTP_ERROR("Read Config Failed, Using DEFAULT Resolution & INT Trigger!");
-        abs_x_max = GTP_MAX_WIDTH;
-        abs_y_max = GTP_MAX_HEIGHT;
-        int_type = GTP_INT_TRIGGER;
-    }
-#endif // GTP_DRIVER_SEND_CFG
-
-    GTP_DEBUG_FUNC();
-    if ((abs_x_max == 0) && (abs_y_max == 0))
-    {
-        abs_x_max = (config[RESOLUTION_LOC + 1] << 8) + config[RESOLUTION_LOC];
-        abs_y_max = (config[RESOLUTION_LOC + 3] << 8) + config[RESOLUTION_LOC + 2];
-        int_type = (config[TRIGGER_LOC]) & 0x03; 
-    }
-    
-#if GTP_COMPATIBLE_MODE
-    if (CHIP_TYPE_GT9F == gtp_chip_type)
-    {
-        u8 have_key = 0;
-        if (is_950)
-        {
-            driver_num = config[GTP_REG_MATRIX_DRVNUM - GTP_REG_CONFIG_DATA + 2];
-            sensor_num = config[GTP_REG_MATRIX_SENNUM - GTP_REG_CONFIG_DATA + 2];
-        }
-        else
-        {
-            driver_num = (config[CFG_LOC_DRVA_NUM]&0x1F) + (config[CFG_LOC_DRVB_NUM]&0x1F);
-            sensor_num = (config[CFG_LOC_SENS_NUM]&0x0F) + ((config[CFG_LOC_SENS_NUM]>>4)&0x0F);
-        }
-        
-        have_key = config[GTP_REG_HAVE_KEY - GTP_REG_CONFIG_DATA + 2] & 0x01;  // have key or not
-        if (1 == have_key)
-        {
-            driver_num--;
-        }
-        
-        GTP_INFO("Driver * Sensor: %d * %d(Key: %d), X_MAX = %d, Y_MAX = %d, TRIGGER = 0x%02x",
-            driver_num, sensor_num, have_key, abs_x_max,abs_y_max,int_type);
-    }
-    else
-#endif
-    {
-    #if GTP_DRIVER_SEND_CFG
-        ret = gtp_send_cfg(client);
-        if (ret < 0)
-        {
-            GTP_ERROR("Send config error.");
-        }
-        // set config version to CTP_CFG_GROUP
-        // for resume to send config
-        config[GTP_ADDR_LENGTH] = grp_cfg_version;
-        check_sum = 0;
-        for (i = GTP_ADDR_LENGTH; i < cfg_len; i++)
-        {
-            check_sum += config[i];
-        }
-        config[cfg_len] = (~check_sum) + 1;
-    #endif
-        GTP_INFO("X_MAX = %d, Y_MAX = %d, TRIGGER = 0x%02x",
-            abs_x_max,abs_y_max,int_type);
-    }
-    
-    msleep(10);
-    return 0;
-}
-
-static s8 gtp_i2c_test(struct i2c_client *client)
-{
-
-    u8 retry = 0;
-    s8 ret = -1;
-    u32 hw_info = 0;
-
-    GTP_DEBUG_FUNC();
-
-    while (retry++ < 5)
-    {
-        ret = i2c_read_bytes(client, GTP_REG_HW_INFO, (u8 *)&hw_info, sizeof(hw_info));
-
-        if ((!ret) && (hw_info == 0x00900600))              //20121212
-        {
-            return ret;
-        }
-
-        GTP_ERROR("GTP_REG_HW_INFO : %08X", hw_info);
-        GTP_ERROR("GTP i2c test failed time %d.", retry);
-        msleep(10);
-    }
-
-    return -1;
-}
-
-
-
-/*******************************************************
-Function:
-    Set INT pin  as input for FW sync.
-
-Note:
-  If the INT is high, It means there is pull up resistor attached on the INT pin.
-  Pull low the INT pin manaully for FW sync.
-*******************************************************/
-void gtp_int_sync(s32 ms)
-{
-    GTP_GPIO_OUTPUT(GTP_INT_PORT, 0);
-    msleep(ms);
-    GTP_GPIO_AS_INT(GTP_INT_PORT);
-}
-
-void gtp_reset_guitar(struct i2c_client *client, s32 ms)
-{
-    GTP_INFO("GTP RESET!\n");
-    GTP_GPIO_OUTPUT(GTP_RST_PORT, 0);
-    msleep(ms);
-    GTP_GPIO_OUTPUT(GTP_INT_PORT, client->addr == 0x14);
-
-    msleep(2);
-    GTP_GPIO_OUTPUT(GTP_RST_PORT, 1);
-
-    msleep(6);                      //must >= 6ms
-
-#if GTP_COMPATIBLE_MODE
-    if (CHIP_TYPE_GT9F == gtp_chip_type)
-    {
-        return;
-    }
-#endif
-
-    gtp_int_sync(50); 
-#if GTP_ESD_PROTECT
-    gtp_init_ext_watchdog(i2c_client_point);
-#endif
-}
-
-static int tpd_power_on(struct i2c_client *client)
-{
-    int ret = 0;
-    int reset_count = 0;
-
-reset_proc:
-    GTP_GPIO_OUTPUT(GTP_RST_PORT, 0);   
-    GTP_GPIO_OUTPUT(GTP_INT_PORT, 0);
-    msleep(10);
-
-#ifdef MT6573
-    // power on CTP
-    mt_set_gpio_mode(GPIO_CTP_EN_PIN, GPIO_CTP_EN_PIN_M_GPIO);
-    mt_set_gpio_dir(GPIO_CTP_EN_PIN, GPIO_DIR_OUT);
-    mt_set_gpio_out(GPIO_CTP_EN_PIN, GPIO_OUT_ONE);
-
-#else   // ( defined(MT6575) || defined(MT6577) || defined(MT6589) )
-
-    #ifdef TPD_POWER_SOURCE_CUSTOM                           
-      //  hwPowerOn(TPD_POWER_SOURCE_CUSTOM, VOL_2800, "TP");    
-    #else
-        hwPowerOn(MT65XX_POWER_LDO_VGP2, VOL_2800, "TP");
-    #endif
-    #ifdef TPD_POWER_SOURCE_1800
-        hwPowerOn(TPD_POWER_SOURCE_1800, VOL_1800, "TP");
-    #endif
-
-#endif
-
-    gtp_reset_guitar(client, 20);
-
-#if GTP_COMPATIBLE_MODE
-    gtp_get_chip_type(client);
-    
-    if (CHIP_TYPE_GT9F == gtp_chip_type)
-    {
-        ret = gup_fw_download_proc(NULL, GTP_FL_FW_BURN);
-    
-        if(FAIL == ret)
-        {
-            GTP_ERROR("[tpd_power_on]Download fw failed.");
-            if(reset_count++ < TPD_MAX_RESET_COUNT)
-            {
-                goto reset_proc;
-            }
-            else
-            {
-                return -1;
-            }
-        }
-        
-        ret = gtp_fw_startup(client);
-        if(FAIL == ret)
-        {
-            GTP_ERROR("[tpd_power_on]Startup fw failed.");
-            if(reset_count++ < TPD_MAX_RESET_COUNT)
-            {
-                goto reset_proc;
-            }
-            else
-            {
-                return -1;
-            }
-        }
-    }
-    else  
-#endif
-    {
-        ret = gtp_i2c_test(client);
-    
-        if (ret < 0)
-        {
-            GTP_ERROR("I2C communication ERROR!");
-    
-            if (reset_count < TPD_MAX_RESET_COUNT)
-            {
-                reset_count++;
-                goto reset_proc;
-            }
-        }
-    }
-    return ret;
-}
-
-//**************** For GT9XXF Start ********************//
-#if GTP_COMPATIBLE_MODE
-
-
-void gtp_get_chip_type(struct i2c_client *client)
-{
-    u8 opr_buf[10] = {0x00};
-    s32 ret = 0;
-    
-    msleep(10);
-    
-    ret = gtp_i2c_read_dbl_check(client, GTP_REG_CHIP_TYPE, opr_buf, 10);
-    
-    if (FAIL == ret)
-    {
-        GTP_ERROR("Failed to get chip-type, set chip type default: GOODIX_GT9");
-        gtp_chip_type = CHIP_TYPE_GT9;
-        return;
-    }
-    
-    if (!memcmp(opr_buf, "GOODIX_GT9", 10))
-    {
-        gtp_chip_type = CHIP_TYPE_GT9;
-    }
-    else // GT9XXF
-    {
-        gtp_chip_type = CHIP_TYPE_GT9F;
-    }
-    GTP_INFO("Chip Type: %s", (gtp_chip_type == CHIP_TYPE_GT9) ? "GOODIX_GT9" : "GOODIX_GT9F");
-}
-
-static u8 gtp_bak_ref_proc(struct i2c_client *client, u8 mode)
-{
-    s32 i = 0;
-    s32 j = 0;
-    s32 ret = 0;
-    struct file *flp = NULL;
-    u8 *refp = NULL;
-    u32 ref_len = 0;
-    u32 ref_seg_len = 0;
-    s32 ref_grps = 0;
-    s32 ref_chksum = 0;
-    u16 tmp = 0;
-    
-    GTP_DEBUG("[gtp_bak_ref_proc]Driver:%d,Sensor:%d.", driver_num, sensor_num);
-
-    //check file-system mounted 
-    GTP_DEBUG("[gtp_bak_ref_proc]Waiting for FS %d", gtp_ref_retries);        
-    if (gup_check_fs_mounted("/data") == FAIL)        
-    {
-        GTP_DEBUG("[gtp_bak_ref_proc]/data not mounted");
-        if(gtp_ref_retries++ < GTP_CHK_FS_MNT_MAX)
-        {
-            return FAIL;
-        }
-    }
-    else
-    {
-        GTP_DEBUG("[gtp_bak_ref_proc]/data mounted !!!!");
-    }
-    
-    if (is_950)
-    {
-        ref_seg_len = (driver_num * (sensor_num - 1) + 2) * 2;
-        ref_grps = 6;
-        ref_len =  ref_seg_len * 6;  // for GT950, backup-reference for six segments
-    }
-    else
-    {
-        ref_len = driver_num*(sensor_num-2)*2 + 4;
-        ref_seg_len = ref_len;
-        ref_grps = 1;
-    }
-    
-    refp = (u8 *)kzalloc(ref_len, GFP_KERNEL);
-    if(refp == NULL)
-    {
-        GTP_ERROR("Failed to allocate memory for reference buffer!"); 
-        return FAIL;
-    }
-    memset(refp, 0, ref_len);
-    
-    //get ref file data
-    flp = filp_open(GTP_BAK_REF_PATH, O_RDWR | O_CREAT, 0666);
-    if (IS_ERR(flp))
-    {
-        GTP_ERROR("Failed to open/create %s.", GTP_BAK_REF_PATH);
-        if (GTP_BAK_REF_SEND == mode)
-        {
-            goto default_bak_ref;
-        }
-        else
-        {
-            goto exit_ref_proc;
-        }
-    }
-    
-    switch (mode)
-    {
-    case GTP_BAK_REF_SEND:
-        {
-            flp->f_op->llseek(flp, 0, SEEK_SET);
-            ret = flp->f_op->read(flp, (char *)refp, ref_len, &flp->f_pos);
-            if(ret < 0)
-            {
-                GTP_ERROR("Read ref file failed, send default bak ref.");
-                goto default_bak_ref;
-            }
-            //checksum ref file
-            for (j = 0; j < ref_grps; ++j)
-            {
-                ref_chksum = 0;
-                for(i=0; i<ref_seg_len-2; i+=2)
-                {
-                    ref_chksum += ((refp[i + j * ref_seg_len]<<8) + refp[i + 1 + j * ref_seg_len]);
-                }
-            
-                GTP_DEBUG("Reference chksum:0x%04X", ref_chksum&0xFF);
-                tmp = ref_chksum + (refp[ref_seg_len + j * ref_seg_len -2]<<8) + refp[ref_seg_len + j * ref_seg_len -1];
-                if(1 != tmp)
-                {
-                    GTP_DEBUG("Invalid checksum for reference, reset reference.");
-                    memset(&refp[j * ref_seg_len], 0, ref_seg_len);
-                    refp[ref_seg_len - 1 + j * ref_seg_len] = 0x01;
-                }
-                else
-                {
-                    if (j == (ref_grps - 1))
-                    {
-                        GTP_INFO("Reference data in %s used.", GTP_BAK_REF_PATH);
-                    }
-                }
-              
-            }
-            ret = i2c_write_bytes(client, GTP_REG_BAK_REF, refp, ref_len);
-            if(-1 == ret)
-            {
-                GTP_ERROR("Write ref i2c error.");
-                ret = FAIL;
-                goto exit_ref_proc;
-            }
-        }
-        break;
-        
-    case GTP_BAK_REF_STORE:
-        {
-            ret = i2c_read_bytes(client, GTP_REG_BAK_REF, refp, ref_len);
-            if(-1 == ret)
-            {
-                GTP_ERROR("Read ref i2c error.");
-                ret = FAIL;
-                goto exit_ref_proc;
-            }
-            flp->f_op->llseek(flp, 0, SEEK_SET);
-            flp->f_op->write(flp, (char *)refp, ref_len, &flp->f_pos);
-        }
-        break;
-        
-    default:
-        GTP_ERROR("Invalid Argument(%d) for backup reference", mode);
-        ret = FAIL;
-        goto exit_ref_proc;
-    }
-    
-    ret = SUCCESS;
-    goto exit_ref_proc;
-
-default_bak_ref:
-    for (j = 0; j < ref_grps; ++j)
-    {
-        memset(&refp[j * ref_seg_len], 0, ref_seg_len);
-        refp[j * ref_seg_len + ref_seg_len - 1] = 0x01;  // checksum = 1
-    }
-    ret = i2c_write_bytes(client, GTP_REG_BAK_REF, refp, ref_len);
-    if (flp && !IS_ERR(flp))
-    {
-        GTP_INFO("Write backup-reference data into %s", GTP_BAK_REF_PATH);
-        flp->f_op->llseek(flp, 0, SEEK_SET);
-        flp->f_op->write(flp, (char*)refp, ref_len, &flp->f_pos);
-    }
-    if (ret < 0)
-    {
-        GTP_ERROR("Failed to load the default backup reference");
-        ret = FAIL;
-    }
-    else
-    {
-        ret = SUCCESS;
-    }
-exit_ref_proc:
-    if (refp)
-    {
-        kfree(refp);
-    }
-    if (flp && !IS_ERR(flp))
-    {
-        filp_close(flp, NULL);
-    }
-    return ret;
-}
-
-u8 gtp_fw_startup(struct i2c_client *client)
-{
-    u8 wr_buf[4];
-    s32 ret = 0;
-    
-    //init sw WDT
-    wr_buf[0] = 0xAA;
-    ret = i2c_write_bytes(client, 0x8041, wr_buf, 1);
-    if (ret < 0)
-    {
-        GTP_ERROR("I2C error to firmware startup.");
-        return FAIL;
-    }
-    //release SS51 & DSP
-    wr_buf[0] = 0x00;
-    i2c_write_bytes(client, 0x4180, wr_buf, 1);
-    
-    //int sync
-    gtp_int_sync(25);
-    
-    //check fw run status
-    i2c_read_bytes(client, 0x8041, wr_buf, 1);
-    if(0xAA == wr_buf[0])
-    {
-        GTP_ERROR("IC works abnormally,startup failed.");
-        return FAIL;
-    }
-    else
-    {
-        GTP_DEBUG("IC works normally,Startup success.");
-        wr_buf[0] = 0xAA;
-        i2c_write_bytes(client, 0x8041, wr_buf, 1);
-        return SUCCESS;
-    }
-}
-
-
-static void gtp_recovery_reset(struct i2c_client *client)
-{
-#if GTP_ESD_PROTECT
-    gtp_esd_switch(client, SWITCH_OFF);
-#endif
-    force_reset_guitar();
-#if GTP_ESD_PROTECT
-    gtp_esd_switch(client, SWITCH_ON);
-#endif
-}
-
-static u8 gtp_check_clk_legality(u8 *p_clk_buf)
-{
-    u8 i = 0;
-    u8 clk_chksum = p_clk_buf[5];
-    
-    for(i = 0; i < 5; i++)
-    {
-        if((p_clk_buf[i] < 50) || (p_clk_buf[i] > 120) ||
-            (p_clk_buf[i] != p_clk_buf[0]))
-        {
-            break;
-        }
-        clk_chksum += p_clk_buf[i];
-    }
-    
-    if((i == 5) && (clk_chksum == 0))
-    {
-        GTP_DEBUG("Valid main clock data.");
-        return SUCCESS;
-    }
-    GTP_ERROR("Invalid main clock data.");
-    return FAIL;
-}
-
-static u8 gtp_main_clk_proc(struct i2c_client *client)
-{
-    s32 ret = 0;
-    u8  i = 0;
-    u8  clk_cal_result = 0;
-    u8  clk_chksum = 0;
-    u8  gtp_clk_buf[6] = {0};
-    struct file *flp = NULL;
-    
-    GTP_DEBUG("[gtp_main_clk_proc]Waiting for FS %d", gtp_ref_retries);        
-    if (gup_check_fs_mounted("/data") == FAIL)        
-    {            
-        GTP_DEBUG("[gtp_main_clk_proc]/data not mounted");
-        if(gtp_clk_retries++ < GTP_CHK_FS_MNT_MAX)
-        {
-            return FAIL;
-        }
-        else
-        {
-            GTP_ERROR("[gtp_main_clk_proc]Wait for file system timeout,need cal clk");
-        }
-    }
-    else
-    {
-        GTP_DEBUG("[gtp_main_clk_proc]/data mounted !!!!");
-        flp = filp_open(GTP_MAIN_CLK_PATH, O_RDWR | O_CREAT, 0666);
-        if (!IS_ERR(flp))
-        {
-            flp->f_op->llseek(flp, 0, SEEK_SET);
-            ret = flp->f_op->read(flp, (char *)gtp_clk_buf, 6, &flp->f_pos);
-            if(ret > 0)
-            {
-                ret = gtp_check_clk_legality(gtp_clk_buf);
-                if(SUCCESS == ret)
-                {
-                        GTP_DEBUG("[gtp_main_clk_proc]Open & read & check clk file success.");
-                    goto send_main_clk;
-                }
-            }
-        }
-        GTP_ERROR("[gtp_main_clk_proc]Check clk file failed,need cal clk");
-    }
-    
-    //cal clk
-#if GTP_ESD_PROTECT
-    gtp_esd_switch(client, SWITCH_OFF);
-#endif
-    clk_cal_result = gup_clk_calibration();
-    force_reset_guitar();
-    GTP_DEBUG("&&&&&&&&&&clk cal result:%d", clk_cal_result);
-    
-#if GTP_ESD_PROTECT
-    gtp_esd_switch(client, SWITCH_ON);
-#endif  
-
-    if(clk_cal_result < 50 || clk_cal_result > 120)
-    {
-        GTP_ERROR("Invalid main clock: %d", clk_cal_result);
-        ret = FAIL;
-        goto exit_clk_proc;
-    }
-    
-    for(i = 0;i < 5; i++)
-    {
-        gtp_clk_buf[i] = clk_cal_result;
-        clk_chksum += gtp_clk_buf[i];
-    }
-    gtp_clk_buf[5] = 0 - clk_chksum;
-    
-send_main_clk:
-    
-    ret = i2c_write_bytes(client, 0x8020, gtp_clk_buf, 6);
-    
-    if (flp && !IS_ERR(flp))
-    {
-        flp->f_op->llseek(flp, 0, SEEK_SET);
-        flp->f_op->write(flp, (char *)gtp_clk_buf, 6, &flp->f_pos);
-    }
-    
-    if(-1 == ret)
-    {
-        GTP_ERROR("[gtp_main_clk_proc]send main clk i2c error!");
-        ret = FAIL;
-    }
-    else
-    {
-        ret = SUCCESS;
-    }
-    
-exit_clk_proc:
-    if (flp && !IS_ERR(flp))
-    {
-        filp_close(flp, NULL);
-    }
-    return ret;
-}
-
-#endif
-//************* For GT9XXF End **********************//
-
-#if GTP_WITH_PEN
-static void gtp_pen_init(void)
-{
-    s32 ret = 0;
-    
-    pen_dev = input_allocate_device();
-    if (pen_dev == NULL)
-    {
-        GTP_ERROR("Failed to allocate input device for pen/stylus.");
-        return;
-    }
-    
-    pen_dev->evbit[0] = BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS) ;
-    pen_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
-    
-    set_bit(BTN_TOOL_PEN, pen_dev->keybit);
-    set_bit(INPUT_PROP_DIRECT, pen_dev->propbit);
-    //set_bit(INPUT_PROP_POINTER, pen_dev->propbit);
-    
-#if GTP_PEN_HAVE_BUTTON
-    input_set_capability(pen_dev, EV_KEY, BTN_STYLUS);
-    input_set_capability(pen_dev, EV_KEY, BTN_STYLUS2);
-#endif
-
-    input_set_abs_params(pen_dev, ABS_MT_POSITION_X, 0, TPD_RES_X, 0, 0);
-    input_set_abs_params(pen_dev, ABS_MT_POSITION_Y, 0, TPD_RES_Y, 0, 0);
-    input_set_abs_params(pen_dev, ABS_MT_PRESSURE, 0, 255, 0, 0);
-    input_set_abs_params(pen_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
-    input_set_abs_params(pen_dev, ABS_MT_TRACKING_ID, 0, 255, 0, 0);
-    
-    pen_dev->name = "mtk-pen";
-    pen_dev->phys = "input/ts";
-    pen_dev->id.bustype = BUS_I2C;
-    
-    ret = input_register_device(pen_dev);
-    if (ret)
-    {
-        GTP_ERROR("Register %s input device failed", pen_dev->name);
-        return;
-    }
-}
-
-static void gtp_pen_down(s32 x, s32 y, s32 size, s32 id)
-{
-    input_report_key(pen_dev, BTN_TOOL_PEN, 1);
-    input_report_key(pen_dev, BTN_TOUCH, 1);
-    input_report_abs(pen_dev, ABS_MT_POSITION_X, x);
-    input_report_abs(pen_dev, ABS_MT_POSITION_Y, y);
-    if ((!size) && (!id))
-    {
-        input_report_abs(pen_dev, ABS_MT_PRESSURE, 100);
-        input_report_abs(pen_dev, ABS_MT_TOUCH_MAJOR, 100);
-    }
-    else
-    {
-        input_report_abs(pen_dev, ABS_MT_PRESSURE, size);
-        input_report_abs(pen_dev, ABS_MT_TOUCH_MAJOR, size);
-        input_report_abs(pen_dev, ABS_MT_TRACKING_ID, id);
-    }
-    input_mt_sync(pen_dev);
-}
-
-static void gtp_pen_up(void)
-{
-    input_report_key(pen_dev, BTN_TOOL_PEN, 0);
-    input_report_key(pen_dev, BTN_TOUCH, 0);
-}
-#endif
-
-static s32 tpd_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
-{
-    s32 err = 0;
-    s32 ret = 0;
-
-    u16 version_info;
-#if GTP_HAVE_TOUCH_KEY
-    s32 idx = 0;
-#endif
-#ifdef TPD_PROXIMITY
-    struct hwmsen_object obj_ps;
-#endif
-//add at 20150330 by zhu
-#if 1//def MAIERXUN_TP_COM
-    if(touchpanel_flag){
-	return 0;
-     }
-#endif
-//add at 20150330 by zhu end
-    i2c_client_point = client;
-    ret = tpd_power_on(client);
-
-    if (ret < 0)
-    {
-//add at 20150330 by zhu
-#if 1//def MAIERXUN_TP_COM
-       touchpanel_flag=false;
-#endif
-//add at 20150330 by zhu end
-        GTP_ERROR("I2C communication ERROR!");
-	return 0;
-    }
-    
-#ifdef VELOCITY_CUSTOM
-
-    if ((err = misc_register(&tpd_misc_device)))
-    {
-        printk("mtk_tpd: tpd_misc_device register failed\n");
-    }
-
-#endif
-    ret = gtp_read_version(client, &version_info);
-
-    if (ret < 0)
-    {
-        GTP_ERROR("Read version failed.");
-    }    
-    
-    ret = gtp_init_panel(client);
-
-    if (ret < 0)
-    {
-        GTP_ERROR("GTP init panel failed.");
-    }
-    
-    // Create proc file system
-    gt91xx_config_proc = proc_create(GT91XX_CONFIG_PROC_FILE, 0666, NULL, &config_proc_ops);
-    if (gt91xx_config_proc == NULL)
-    {
-        GTP_ERROR("create_proc_entry %s failed\n", GT91XX_CONFIG_PROC_FILE);
-    }
-    else
-    {
-        GTP_INFO("create proc entry %s success", GT91XX_CONFIG_PROC_FILE);
-    }
-
-#if GTP_CREATE_WR_NODE
-    init_wr_node(client);
-#endif
-
-    thread = kthread_run(touch_event_handler, 0, TPD_DEVICE);
-
-    if (IS_ERR(thread))
-    {
-        err = PTR_ERR(thread);
-        GTP_INFO(TPD_DEVICE " failed to create kernel thread: %d\n", err);
-    }
-    
-    
-#if GTP_HAVE_TOUCH_KEY
-
-    for (idx = 0; idx < GTP_MAX_KEY_NUM; idx++)
-    {
-        input_set_capability(tpd->dev, EV_KEY, touch_key_array[idx]);
-    }
-
-#endif
-#if GTP_GESTURE_WAKEUP
-    input_set_capability(tpd->dev, EV_KEY, KEY_POWER);
-#endif
-    
-#if GTP_WITH_PEN
-    gtp_pen_init();
-#endif
-    // set INT mode
-    mt_set_gpio_mode(GPIO_CTP_EINT_PIN, GPIO_CTP_EINT_PIN_M_EINT);
-    mt_set_gpio_dir(GPIO_CTP_EINT_PIN, GPIO_DIR_IN);
-    mt_set_gpio_pull_enable(GPIO_CTP_EINT_PIN, GPIO_PULL_DISABLE);
-
-    msleep(50);
-
-#ifdef MT6572
-    if (!int_type)  //EINTF_TRIGGER
-    {
-        mt_eint_registration(CUST_EINT_TOUCH_PANEL_NUM, EINTF_TRIGGER_RISING, tpd_eint_interrupt_handler, 1);
-    }
-    else
-    {
-        mt_eint_registration(CUST_EINT_TOUCH_PANEL_NUM, EINTF_TRIGGER_FALLING, tpd_eint_interrupt_handler, 1);
-    }
-    
-#else
-   // mt65xx_eint_set_sens(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_SENSITIVE);
-   // mt65xx_eint_set_hw_debounce(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_DEBOUNCE_CN);
-
-    if (!int_type)
-    {
-        mt_eint_registration(CUST_EINT_TOUCH_PANEL_NUM, EINTF_TRIGGER_RISING, tpd_eint_interrupt_handler, 1);
-    }
-    else
-    {
-        mt_eint_registration(CUST_EINT_TOUCH_PANEL_NUM, EINTF_TRIGGER_FALLING, tpd_eint_interrupt_handler, 1);
-    }
-#endif
-
-    mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
-
-#if GTP_AUTO_UPDATE
-    ret = gup_init_update_proc(client);
-
-    if (ret < 0)
-    {
-        GTP_ERROR("Create update thread error.");
-    }
-#endif
-
-#ifdef TPD_PROXIMITY
-    //obj_ps.self = cm3623_obj;
-    obj_ps.polling = 0;         //0--interrupt mode;1--polling mode;
-    obj_ps.sensor_operate = gt9xx_tpd_ps_operate;
-
-    if ((err = hwmsen_attach(ID_PROXIMITY, &obj_ps)))
-    {
-        GTP_ERROR("hwmsen attach fail, return:%d.", err);
-    }
-
-#endif
-
-#if GTP_ESD_PROTECT
-    gtp_esd_switch(client, SWITCH_ON);
-#endif
-   
-    tpd_load_status = 1;
-//add at 20150330 by zhu
-#if 1//def MAIERXUN_TP_COM
-    touchpanel_flag=true;
-#endif
-//add at 20150330 by zhu end
-    return 0;
-}
-
-static void tpd_eint_interrupt_handler(void)
-{
-    TPD_DEBUG_PRINT_INT;
-    
-    tpd_flag = 1;
-    
-    wake_up_interruptible(&waiter);
-}
-static int tpd_i2c_remove(struct i2c_client *client)
-{
-#if GTP_CREATE_WR_NODE
-    uninit_wr_node();
-#endif
-
-#if GTP_ESD_PROTECT
-    destroy_workqueue(gtp_esd_check_workqueue);
-#endif
-
-    return 0;
-}
-#if (GTP_ESD_PROTECT || GTP_COMPATIBLE_MODE)
-static void force_reset_guitar(void)
-{
-    s32 i = 0;
-    s32 ret = 0;
-
-    GTP_INFO("force_reset_guitar");
-    
-    mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
-
-    GTP_GPIO_OUTPUT(GTP_RST_PORT, 0);   
-    GTP_GPIO_OUTPUT(GTP_INT_PORT, 0);
-#ifdef MT6573
-    //Power off TP
-    mt_set_gpio_mode(GPIO_CTP_EN_PIN, GPIO_CTP_EN_PIN_M_GPIO);
-    mt_set_gpio_dir(GPIO_CTP_EN_PIN, GPIO_DIR_OUT);
-    mt_set_gpio_out(GPIO_CTP_EN_PIN, GPIO_OUT_ZERO);  
-    msleep(30);
-    //Power on TP
-    mt_set_gpio_out(GPIO_CTP_EN_PIN, GPIO_OUT_ONE);
-    msleep(30);
-#else           // ( defined(MT6575) || defined(MT6577) || defined(MT6589) )
-    // Power off TP
-    #ifdef TPD_POWER_SOURCE_CUSTOM
-     //   hwPowerDown(TPD_POWER_SOURCE_CUSTOM, "TP");
-    #else
-        hwPowerDown(MT65XX_POWER_LDO_VGP2, "TP");
-    #endif
-        msleep(30); 
-
-    // Power on TP
-    #ifdef TPD_POWER_SOURCE_CUSTOM
-    //    hwPowerOn(TPD_POWER_SOURCE_CUSTOM, VOL_2800, "TP");
-    #else
-        hwPowerOn(MT65XX_POWER_LDO_VGP2, VOL_2800, "TP");
-    #endif
-        msleep(30);
-
-#endif
-
-    for (i = 0; i < 5; i++)
-    {
-    #if GTP_COMPATIBLE_MODE
-        if (CHIP_TYPE_GT9F == gtp_chip_type)
-        {
-            ret = gup_fw_download_proc(NULL, GTP_FL_ESD_RECOVERY);
-            if(FAIL == ret)
-            {
-                GTP_ERROR("[force_reset_guitar]Check & repair fw failed.");
-                continue;
-            }
-            //startup fw
-            ret = gtp_fw_startup(i2c_client_point);
-            if(FAIL == ret)
-            {
-                GTP_ERROR("[force_reset_guitar]Startup fw failed.");
-                continue;
-            }
-            break;
-        }
-        else
-    #endif
-        {
-            //Reset Guitar
-            gtp_reset_guitar(i2c_client_point, 20);
-            msleep(50);
-            //Send config
-            ret = gtp_send_cfg(i2c_client_point);
-    
-            if (ret < 0)
-            {
-                continue;
-            }
-        }
-        break;
-    }
-    mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
-    
-    if (i >= 5)
-    {
-        GTP_ERROR("Failed to reset guitar.");
-        return;
-    }
-    GTP_INFO("Esd recovery successful");
-    return;
-}
-#endif
-
-#if GTP_ESD_PROTECT
-static s32 gtp_init_ext_watchdog(struct i2c_client *client)
-{
-    u8 opr_buffer[2] = {0xAA};
-    GTP_DEBUG("Init external watchdog.");
-    return i2c_write_bytes(client, 0x8041, opr_buffer, 1);
-}
-
-void gtp_esd_switch(struct i2c_client *client, s32 on)
-{
-    spin_lock(&esd_lock);     
-    if (SWITCH_ON == on)     // switch on esd 
-    {
-        if (!esd_running)
-        {
-            esd_running = 1;
-            spin_unlock(&esd_lock);
-            GTP_INFO("Esd started");
-            queue_delayed_work(gtp_esd_check_workqueue, &gtp_esd_check_work, clk_tick_cnt);
-        }
-        else
-        {
-            spin_unlock(&esd_lock);
-        }
-    }
-    else    // switch off esd
-    {
-        if (esd_running)
-        {
-            esd_running = 0;
-            spin_unlock(&esd_lock);
-            GTP_INFO("Esd cancelled");
-            cancel_delayed_work_sync(&gtp_esd_check_work);
-        }
-        else
-        {
-            spin_unlock(&esd_lock);
-        }
-    }
-}
-
-
-static void gtp_esd_check_func(struct work_struct *work)
-{
-    s32 i = 0;
-    s32 ret = -1;
-    u8 esd_buf[3] = {0x00};
-
-    if (tpd_halt)
-    {
-        GTP_INFO("Esd suspended!");
-        return;
-    }
-    for (i = 0; i < 3; i++)
-    {
-        ret = i2c_read_bytes_non_dma(i2c_client_point, 0x8040, esd_buf, 2);
-        
-        GTP_DEBUG("[Esd]0x8040 = 0x%02X, 0x8041 = 0x%02X", esd_buf[0], esd_buf[1]);
-        if (ret < 0)
-        {
-            // IIC communication problem
-            continue;
-        }
-        else 
-        {
-            if ((esd_buf[0] == 0xAA) || (esd_buf[1] != 0xAA))
-            {
-                u8 chk_buf[2] = {0x00};
-                i2c_read_bytes_non_dma(i2c_client_point, 0x8040, chk_buf, 2);
-                
-                GTP_DEBUG("[Check]0x8040 = 0x%02X, 0x8041 = 0x%02X", chk_buf[0], chk_buf[1]);
-                
-                if ( (chk_buf[0] == 0xAA) || (chk_buf[1] != 0xAA) )
-                {
-                    i = 3;          // jump to reset guitar
-                    break;
-                }
-                else
-                {
-                    continue;
-                }
-            }
-            else
-            {
-                // IC works normally, Write 0x8040 0xAA, feed the watchdog
-                esd_buf[0] = 0xAA;
-                i2c_write_bytes_non_dma(i2c_client_point, 0x8040, esd_buf, 1);
-                
-                break;
-            }
-        }
-    }
-
-    if (i >= 3)
-    {   
-    #if GTP_COMPATIBLE_MODE
-        if ((CHIP_TYPE_GT9F == gtp_chip_type) && (1 == rqst_processing))
-        {
-            GTP_INFO("Request Processing, no reset guitar.");
-        }
-        else
-    #endif
-        {
-            GTP_INFO("IC works abnormally! Process reset guitar.");
-            esd_buf[0] = 0x01;
-            esd_buf[1] = 0x01;
-            esd_buf[2] = 0x01;
-            i2c_write_bytes(i2c_client_point, 0x4226, esd_buf, 3);  
-            msleep(50);
-            force_reset_guitar();
-        }
-    }
-
-    if (!tpd_halt)
-    {
-        queue_delayed_work(gtp_esd_check_workqueue, &gtp_esd_check_work, clk_tick_cnt);
-    }
-    else
-    {
-        GTP_INFO("Esd suspended!");
-    }
-
-    return;
-}
-#endif
-
-static void tpd_down(s32 x, s32 y, s32 size, s32 id)
-{
-    if ((!size) && (!id))
-    {
-        input_report_abs(tpd->dev, ABS_MT_PRESSURE, 100);
-        input_report_abs(tpd->dev, ABS_MT_TOUCH_MAJOR, 100);
-    }
-    else
-    {
-        input_report_abs(tpd->dev, ABS_MT_PRESSURE, size);
-        input_report_abs(tpd->dev, ABS_MT_TOUCH_MAJOR, size);
-        /* track id Start 0 */
-        input_report_abs(tpd->dev, ABS_MT_TRACKING_ID, id);
-    }
-
-    input_report_key(tpd->dev, BTN_TOUCH, 1);
-    input_report_abs(tpd->dev, ABS_MT_POSITION_X, x);
-    input_report_abs(tpd->dev, ABS_MT_POSITION_Y, y);
-    input_mt_sync(tpd->dev);
-    TPD_EM_PRINT(x, y, x, y, id, 1);
-
-#if (defined(MT6575)||defined(MT6577))
-
-    if (FACTORY_BOOT == get_boot_mode() || RECOVERY_BOOT == get_boot_mode())
-    {
-        tpd_button(x, y, 1);
-    }
-
-#endif
-}
-
-static void tpd_up(s32 x, s32 y, s32 id)
-{
-    input_report_key(tpd->dev, BTN_TOUCH, 0);
-    input_mt_sync(tpd->dev);
-    TPD_EM_PRINT(x, y, x, y, id, 0);
-
-#if (defined(MT6575) || defined(MT6577))
-
-    if (FACTORY_BOOT == get_boot_mode() || RECOVERY_BOOT == get_boot_mode())
-    {
-        tpd_button(x, y, 0);
-    }
-
-#endif
-}
-#if GTP_CHARGER_SWITCH
-static void gtp_charger_switch(s32 dir_update)
-{
-    u32 chr_status = 0;
-    u8 chr_cmd[3] = {0x80, 0x40};
-    static u8 chr_pluggedin = 0;
-    int ret = 0;
-    
-#ifdef MT6573
-    chr_status = *(volatile u32 *)CHR_CON0;
-    chr_status &= (1 << 13);
-#else   // ( defined(MT6575) || defined(MT6577) || defined(MT6589) )
-    chr_status = upmu_is_chr_det();
-#endif
-    
-    if (chr_status)     // charger plugged in
-    {
-        if (!chr_pluggedin || dir_update)
-        {
-            chr_cmd[2] = 6;
-            ret = gtp_i2c_write(i2c_client_point, chr_cmd, 3);
-            if (ret > 0)
-            {
-                GTP_INFO("Update status for Charger Plugin");
-            }
-            chr_pluggedin = 1;
-        }
-    }
-    else            // charger plugged out
-    {
-        if (chr_pluggedin || dir_update)
-        {
-            chr_cmd[2] = 7;
-            ret = gtp_i2c_write(i2c_client_point, chr_cmd, 3);
-            if (ret > 0)
-            {
-                GTP_INFO("Update status for Charger Plugout");
-            }
-            chr_pluggedin = 0;
-        }
-    }
-}
-#endif
-
-static int touch_event_handler(void *unused)
-{
-    struct sched_param param = { .sched_priority = RTPM_PRIO_TPD };
-    u8  end_cmd[3] = {GTP_READ_COOR_ADDR >> 8, GTP_READ_COOR_ADDR & 0xFF, 0};
-    u8  point_data[2 + 1 + 8 * GTP_MAX_TOUCH + 1] = {GTP_READ_COOR_ADDR >> 8, GTP_READ_COOR_ADDR & 0xFF};
-    u8  touch_num = 0;
-    u8  finger = 0;
-    static u8 pre_touch = 0;
-    static u8 pre_key = 0;
-#if GTP_WITH_PEN
-    u8 pen_active = 0;
-    static u8 pre_pen = 0;
-#endif
-    u8  key_value = 0;
-    u8 *coor_data = NULL;
-    s32 input_x = 0;
-    s32 input_y = 0;
-    s32 input_w = 0;
-    s32 id = 0;
-    s32 i  = 0;
-    s32 ret = -1;
-    
-#if GTP_COMPATIBLE_MODE
-    u8  rqst_data[3] = {(u8)(GTP_REG_RQST >> 8), (u8)(GTP_REG_RQST & 0xFF), 0};
-#endif
-
-#ifdef TPD_PROXIMITY
-    s32 err = 0;
-    hwm_sensor_data sensor_data;
-    u8 proximity_status;
-#endif
-
-#if GTP_GESTURE_WAKEUP
-    u8 doze_buf[3] = {0x81, 0x4B};
-#endif
-
-    sched_setscheduler(current, SCHED_RR, &param);
-    do
-    {
-        set_current_state(TASK_INTERRUPTIBLE);
-        
-        while (tpd_halt)
-        {
-        #if GTP_GESTURE_WAKEUP
-            if (DOZE_ENABLED == doze_status)
-            {
-                break;
-            }
-        #endif
-            tpd_flag = 0;
-            msleep(20);
-        }
-
-        wait_event_interruptible(waiter, tpd_flag != 0);
-        tpd_flag = 0;
-        TPD_DEBUG_SET_TIME;
-        set_current_state(TASK_RUNNING);
-
-    #if GTP_CHARGER_SWITCH
-        gtp_charger_switch(0);
-    #endif
-
-    #if GTP_GESTURE_WAKEUP
-        if (DOZE_ENABLED == doze_status)
-        {
-            ret = gtp_i2c_read(i2c_client_point, doze_buf, 3);
-            GTP_DEBUG("0x814B = 0x%02X", doze_buf[2]);
-            if (ret > 0)
-            {               
-                if ((doze_buf[2] == 'a') || (doze_buf[2] == 'b') || (doze_buf[2] == 'c') ||
-                    (doze_buf[2] == 'd') || (doze_buf[2] == 'e') || (doze_buf[2] == 'g') || 
-                    (doze_buf[2] == 'h') || (doze_buf[2] == 'm') || (doze_buf[2] == 'o') ||
-                    (doze_buf[2] == 'q') || (doze_buf[2] == 's') || (doze_buf[2] == 'v') || 
-                    (doze_buf[2] == 'w') || (doze_buf[2] == 'y') || (doze_buf[2] == 'z') ||
-                    (doze_buf[2] == 0x5E) /* ^ */
-                    )
-                {
-                    if (doze_buf[2] != 0x5E)
-                    {
-                        GTP_INFO("Wakeup by gesture(%c), light up the screen!", doze_buf[2]);
-                    }
-                    else
-                    {
-                        GTP_INFO("Wakeup by gesture(^), light up the screen!");
-                    }
-                    doze_status = DOZE_WAKEUP;
-                    input_report_key(tpd->dev, KEY_POWER, 1);
-                    input_sync(tpd->dev);
-                    input_report_key(tpd->dev, KEY_POWER, 0);
-                    input_sync(tpd->dev);
-                    // clear 0x814B
-                    doze_buf[2] = 0x00;
-                    gtp_i2c_write(i2c_client_point, doze_buf, 3);
-                }
-                else if ( (doze_buf[2] == 0xAA) || (doze_buf[2] == 0xBB) ||
-                    (doze_buf[2] == 0xAB) || (doze_buf[2] == 0xBA) )
-                {
-                    char *direction[4] = {"Right", "Down", "Up", "Left"};
-                    u8 type = ((doze_buf[2] & 0x0F) - 0x0A) + (((doze_buf[2] >> 4) & 0x0F) - 0x0A) * 2;
-                    
-                    GTP_INFO("%s slide to light up the screen!", direction[type]);
-                    doze_status = DOZE_WAKEUP;
-                    input_report_key(tpd->dev, KEY_POWER, 1);
-                    input_sync(tpd->dev);
-                    input_report_key(tpd->dev, KEY_POWER, 0);
-                    input_sync(tpd->dev);
-                    // clear 0x814B
-                    doze_buf[2] = 0x00;
-                    gtp_i2c_write(i2c_client_point, doze_buf, 3);
-                }
-                else if (0xCC == doze_buf[2])
-                {
-                    GTP_INFO("Double click to light up the screen!");
-                    doze_status = DOZE_WAKEUP;
-                    input_report_key(tpd->dev, KEY_POWER, 1);
-                    input_sync(tpd->dev);
-                    input_report_key(tpd->dev, KEY_POWER, 0);
-                    input_sync(tpd->dev);
-                    // clear 0x814B
-                    doze_buf[2] = 0x00;
-                    gtp_i2c_write(i2c_client_point, doze_buf, 3);
-                }
-                else
-                {
-                    // clear 0x814B
-                    doze_buf[2] = 0x00;
-                    gtp_i2c_write(i2c_client_point, doze_buf, 3);
-                    gtp_enter_doze(i2c_client_point);
-                }
-            }
-            continue;
-        }
-    #endif
-        ret = gtp_i2c_read(i2c_client_point, point_data, 12);
-        if (ret < 0)
-        {
-            GTP_ERROR("I2C transfer error. errno:%d\n ", ret);
-            continue;
-        }
-        finger = point_data[GTP_ADDR_LENGTH];
-        
-    #if GTP_COMPATIBLE_MODE
-        if ((finger == 0x00) && (CHIP_TYPE_GT9F == gtp_chip_type))
-        {
-            ret = gtp_i2c_read(i2c_client_point, rqst_data, 3);
-
-            if(ret < 0)
-            {
-                GTP_ERROR("I2C transfer error. errno:%d\n ", ret);
-                continue;
-            }
-            switch (rqst_data[2])
-            {
-                case GTP_RQST_BAK_REF:
-                    GTP_INFO("Request Ref.");
-                    rqst_processing = 1;
-                    ret = gtp_bak_ref_proc(i2c_client_point, GTP_BAK_REF_SEND);
-                    if(SUCCESS == ret)
-                    {
-                        GTP_INFO("Send ref success.");
-                        rqst_data[2] = GTP_RQST_RESPONDED;
-                        gtp_i2c_write(i2c_client_point, rqst_data, 3);
-                        rqst_processing = 0;
-                    }
-                    goto exit_work_func;
-                    
-                case GTP_RQST_CONFIG:
-                    GTP_INFO("Request Config.");
-                    ret = gtp_send_cfg(i2c_client_point);
-                    if (ret < 0)
-                    {
-                        GTP_ERROR("Send config error.");
-                    }
-                    else 
-                    {
-                        GTP_INFO("Send config success.");
-                        rqst_data[2] = GTP_RQST_RESPONDED;
-                        gtp_i2c_write(i2c_client_point, rqst_data, 3);
-                    }
-                    goto exit_work_func;
-                    
-                case GTP_RQST_MAIN_CLOCK:
-                    GTP_INFO("Request main clock.");
-                    rqst_processing = 1;
-                    ret = gtp_main_clk_proc(i2c_client_point);
-                    if(SUCCESS == ret)
-                    {
-                        GTP_INFO("Send main clk success.");
-                        
-                        rqst_data[2] = GTP_RQST_RESPONDED;
-                        gtp_i2c_write(i2c_client_point, rqst_data, 3);
-                        rqst_processing = 0;
-                    }
-                    goto exit_work_func;
-                    
-                case GTP_RQST_RESET:
-                    GTP_INFO("Request Reset.");
-                    gtp_recovery_reset(i2c_client_point);
-                    goto exit_work_func;
-                    
-                default:
-                    GTP_INFO("Undefined request code: 0x%02X", rqst_data[2]);
-                    rqst_data[2] = GTP_RQST_RESPONDED;
-                    gtp_i2c_write(i2c_client_point, rqst_data, 3);
-                    break;
-            }
-        }
-    #endif
-    
-        if (finger == 0x00)
-        {
-            continue;
-        }
-        
-        if ((finger & 0x80) == 0)
-        {
-            goto exit_work_func;
-        }
-        
-    #ifdef TPD_PROXIMITY
-        if (tpd_proximity_flag == 1)
-        {
-            proximity_status = point_data[GTP_ADDR_LENGTH];
-            GTP_DEBUG("REG INDEX[0x814E]:0x%02X\n", proximity_status);
-
-            if (proximity_status & 0x60)                //proximity or large touch detect,enable hwm_sensor.
-            {
-                tpd_proximity_detect = 0;
-                //sensor_data.values[0] = 0;
-            }
-            else
-            {
-                tpd_proximity_detect = 1;
-                //sensor_data.values[0] = 1;
-            }
-
-            //get raw data
-            GTP_DEBUG(" ps change\n");
-            GTP_DEBUG("PROXIMITY STATUS:0x%02X\n", tpd_proximity_detect);
-            //map and store data to hwm_sensor_data
-            sensor_data.values[0] = tpd_get_ps_value();
-            sensor_data.value_divide = 1;
-            sensor_data.status = SENSOR_STATUS_ACCURACY_MEDIUM;
-            //report to the up-layer
-            ret = hwmsen_get_interrupt_data(ID_PROXIMITY, &sensor_data);
-
-            if (ret)
-            {
-                GTP_ERROR("Call hwmsen_get_interrupt_data fail = %d\n", err);
-            }
-        }
-
-    #endif
-
-        touch_num = finger & 0x0f;
-
-        if (touch_num > GTP_MAX_TOUCH)
-        {
-            goto exit_work_func;
-        }
-
-        if (touch_num > 1)
-        {
-            u8 buf[8 * GTP_MAX_TOUCH] = {(GTP_READ_COOR_ADDR + 10) >> 8, (GTP_READ_COOR_ADDR + 10) & 0xff};
-
-            ret = gtp_i2c_read(i2c_client_point, buf, 2 + 8 * (touch_num - 1));
-            memcpy(&point_data[12], &buf[2], 8 * (touch_num - 1));
-        }
-
-    #if (GTP_HAVE_TOUCH_KEY || GTP_PEN_HAVE_BUTTON)
-        key_value = point_data[3 + 8 * touch_num];
-
-        if (key_value || pre_key)
-        {
-        #if GTP_PEN_HAVE_BUTTON
-            if (key_value == 0x40)
-            {
-                GTP_DEBUG("BTN_STYLUS & BTN_STYLUS2 Down.");
-                input_report_key(pen_dev, BTN_STYLUS, 1);
-                input_report_key(pen_dev, BTN_STYLUS2, 1);
-                pen_active = 1;
-            }
-            else if (key_value == 0x10)
-            {
-                GTP_DEBUG("BTN_STYLUS Down, BTN_STYLUS2 Up.");
-                input_report_key(pen_dev, BTN_STYLUS, 1);
-                input_report_key(pen_dev, BTN_STYLUS2, 0);
-                pen_active = 1;
-            }
-            else if (key_value == 0x20)
-            {
-                GTP_DEBUG("BTN_STYLUS Up, BTN_STYLUS2 Down.");
-                input_report_key(pen_dev, BTN_STYLUS, 0);
-                input_report_key(pen_dev, BTN_STYLUS2, 1);
-                pen_active = 1;
-            }
-            else
-            {
-                GTP_DEBUG("BTN_STYLUS & BTN_STYLUS2 Up.");
-                input_report_key(pen_dev, BTN_STYLUS, 0);
-                input_report_key(pen_dev, BTN_STYLUS2, 0);
-                if ( (pre_key == 0x40) || (pre_key == 0x20) ||
-                     (pre_key == 0x10) 
-                   )
-                {
-                    pen_active = 1;
-                }
-            }
-            if (pen_active)
-            {
-                touch_num = 0;      // shield pen point
-                //pre_touch = 0;    // clear last pen status
-            }
-        #endif
-        #if GTP_HAVE_TOUCH_KEY
-            if (!pre_touch)
-            {
-                for (i = 0; i < GTP_MAX_KEY_NUM; i++)
-                {
-                    input_report_key(tpd->dev, touch_key_array[i], key_value & (0x01 << i));
-                }
-                touch_num = 0;  // shiled fingers
-            }
-        #endif
-        }
-    #endif
-        pre_key = key_value;
-
-        GTP_DEBUG("pre_touch:%02x, finger:%02x.", pre_touch, finger);
-        
-        if (touch_num)
-        {
-            for (i = 0; i < touch_num; i++)
-            {
-                coor_data = &point_data[i * 8 + 3];
-
-                id = coor_data[0] & 0x0F;      
-                input_x  = coor_data[1] | coor_data[2] << 8;
-                input_y  = coor_data[3] | coor_data[4] << 8;
-                input_w  = coor_data[5] | coor_data[6] << 8;
-
-                input_x = TPD_WARP_X(abs_x_max, input_x);
-                input_y = TPD_WARP_Y(abs_y_max, input_y);
-
-            #if GTP_WITH_PEN
-                id = coor_data[0];
-                if ((id & 0x80))      // pen/stylus is activated
-                {
-                    GTP_DEBUG("Pen touch DOWN!");
-                    pre_pen = 1;
-                    //id &= 0x7F;
-                    id = 0;
-                    GTP_DEBUG("(%d)(%d, %d)[%d]", id, input_x, input_y, input_w);
-                    gtp_pen_down(input_x, input_y, input_w, id);
-                    pen_active = 1;
-                }
-                else
-            #endif
-                {
-                    GTP_DEBUG(" (%d)(%d, %d)[%d]", id, input_x, input_y, input_w);
-                    tpd_down(input_x, input_y, input_w, id);
-                }
-            }
-        }
-        else
-        {
-            if (pre_touch)
-            {
-            #if GTP_WITH_PEN
-                if (pre_pen)
-                {   
-                    GTP_DEBUG("Pen touch UP!");
-                    gtp_pen_up();
-                    pre_pen = 0;
-                    pen_active = 1;
-                }
-                else
-            #endif
-                {
-                    GTP_DEBUG("Touch Release!");
-                    tpd_up(0, 0, 0);
-                }
-            }
-        }
-        pre_touch = touch_num;
- 
-    #if GTP_WITH_PEN
-        if (pen_active)
-        {
-            pen_active = 0;
-            input_sync(pen_dev);
-        }
-        else
-    #endif
-        {
-            input_sync(tpd->dev);
-        }
-
-exit_work_func:
-
-        if (!gtp_rawdiff_mode)
-        {
-            ret = gtp_i2c_write(i2c_client_point, end_cmd, 3);
-
-            if (ret < 0)
-            {
-                GTP_INFO("I2C write end_cmd  error!");
-            }
-        }
-
-    } while (!kthread_should_stop());
-
-    return 0;
-}
-
-static int tpd_local_init(void)
-{
-#if GTP_ESD_PROTECT
-    clk_tick_cnt = 2 * HZ;   // HZ: clock ticks in 1 second generated by system
-    GTP_DEBUG("Clock ticks for an esd cycle: %d", clk_tick_cnt);
-    INIT_DELAYED_WORK(&gtp_esd_check_work, gtp_esd_check_func);
-    gtp_esd_check_workqueue = create_workqueue("gtp_esd_check");
-    spin_lock_init(&esd_lock);          // 2.6.39 & later
-    // esd_lock = SPIN_LOCK_UNLOCKED;   // 2.6.39 & before
-#endif
-
-#if GTP_SUPPORT_I2C_DMA
-    gpDMABuf_va = (u8 *)dma_alloc_coherent(NULL, GTP_DMA_MAX_TRANSACTION_LENGTH, &gpDMABuf_pa, GFP_KERNEL);
-    if(!gpDMABuf_va){
-        GTP_INFO("[Error] Allocate DMA I2C Buffer failed!\n");
-    }
-    memset(gpDMABuf_va, 0, GTP_DMA_MAX_TRANSACTION_LENGTH);
-#endif
-    if (i2c_add_driver(&tpd_i2c_driver) != 0)
-    {
-        GTP_INFO("unable to add i2c driver.\n");
-        return -1;
-    }
-
-    if (tpd_load_status == 0) //if(tpd_load_status == 0) // disable auto load touch driver for linux3.0 porting
-    {
-        GTP_INFO("add error touch panel driver.\n");
-        i2c_del_driver(&tpd_i2c_driver);
-        return -1;
-    }
-
-#ifdef TPD_HAVE_BUTTON
-    tpd_button_setting(TPD_KEY_COUNT, tpd_keys_local, tpd_keys_dim_local);// initialize tpd button data
-#endif
-
-#if (defined(TPD_WARP_START) && defined(TPD_WARP_END))
-    TPD_DO_WARP = 1;
-    memcpy(tpd_wb_start, tpd_wb_start_local, TPD_WARP_CNT * 4);
-    memcpy(tpd_wb_end, tpd_wb_start_local, TPD_WARP_CNT * 4);
-#endif
-
-#if (defined(TPD_HAVE_CALIBRATION) && !defined(TPD_CUSTOM_CALIBRATION))
-    memcpy(tpd_calmat, tpd_def_calmat_local, 8 * 4);
-    memcpy(tpd_def_calmat, tpd_def_calmat_local, 8 * 4);
-#endif
-
-    // set vendor string
-    tpd->dev->id.vendor = 0x00;
-    tpd->dev->id.product = tpd_info.pid;
-    tpd->dev->id.version = tpd_info.vid;
-
-    GTP_INFO("end %s, %d\n", __FUNCTION__, __LINE__);
-    tpd_type_cap = 1;
-
-    return 0;
-}
-
-#if GTP_GESTURE_WAKEUP
-static s8 gtp_enter_doze(struct i2c_client *client)
-{
-    s8 ret = -1;
-    s8 retry = 0;
-    u8 i2c_control_buf[3] = {(u8)(GTP_REG_SLEEP >> 8), (u8)GTP_REG_SLEEP, 8};
-
-    GTP_DEBUG_FUNC();
-
-    GTP_DEBUG("Entering gesture mode...");
-    while(retry++ < 5)
-    {
-        i2c_control_buf[0] = 0x80;
-        i2c_control_buf[1] = 0x46;
-        ret = gtp_i2c_write(client, i2c_control_buf, 3);
-        if (ret < 0)
-        {
-            GTP_DEBUG("Failed to set gesture flag into 0x8046, %d", retry);
-            continue;
-        }
-        i2c_control_buf[0] = 0x80;
-        i2c_control_buf[1] = 0x40;
-        ret = gtp_i2c_write(client, i2c_control_buf, 3);
-        if (ret > 0)
-        {
-            doze_status = DOZE_ENABLED;
-            GTP_INFO("Gesture mode enabled.");
-            return ret;
-        }
-        msleep(10);
-    }
-    GTP_ERROR("GTP send gesture cmd failed.");
-    return ret;
-}
-
-#else
-/*******************************************************
-Function:
-    Eter sleep function.
-
-Input:
-    client:i2c_client.
-
-Output:
-    Executive outcomes.0--success,non-0--fail.
-*******************************************************/
-static s8 gtp_enter_sleep(struct i2c_client *client)
-{
-#if GTP_COMPATIBLE_MODE
-    if (CHIP_TYPE_GT9F == gtp_chip_type)
-    {
-        u8 i2c_status_buf[3] = {0x80, 0x44, 0x00};
-        s32 ret = 0;
-      
-        ret = gtp_i2c_read(client, i2c_status_buf, 3);
-        if(ret <= 0)
-        {
-             GTP_ERROR("[gtp_enter_sleep]Read ref status reg error.");
-        }
-        
-        if (i2c_status_buf[2] & 0x80)
-        {
-            //Store bak ref
-            ret = gtp_bak_ref_proc(client, GTP_BAK_REF_STORE);
-            if(FAIL == ret)
-            {
-                GTP_ERROR("[gtp_enter_sleep]Store bak ref failed.");
-            }        
-        }
-    }
-#endif
-#if GTP_POWER_CTRL_SLEEP
-
-    GTP_GPIO_OUTPUT(GTP_RST_PORT, 0);   
-    GTP_GPIO_OUTPUT(GTP_INT_PORT, 0);
-    msleep(10);
-
-#ifdef MT6573
-    mt_set_gpio_mode(GPIO_CTP_EN_PIN, GPIO_CTP_EN_PIN_M_GPIO);
-    mt_set_gpio_dir(GPIO_CTP_EN_PIN, GPIO_DIR_OUT);
-    mt_set_gpio_out(GPIO_CTP_EN_PIN, GPIO_OUT_ZERO);  
-    msleep(30);
-#else               // ( defined(MT6575) || defined(MT6577) || defined(MT6589) )
-
-    #ifdef TPD_POWER_SOURCE_1800
-        hwPowerDown(TPD_POWER_SOURCE_1800, "TP");
-    #endif
-    
-    #ifdef TPD_POWER_SOURCE_CUSTOM
-    //    hwPowerDown(TPD_POWER_SOURCE_CUSTOM, "TP");
-    #else
-        hwPowerDown(MT65XX_POWER_LDO_VGP2, "TP");
-    #endif
-#endif
-   
-    GTP_INFO("GTP enter sleep by poweroff!");
-    return 0;
-    
-#else
-    {
-        s8 ret = -1;
-        s8 retry = 0;
-        u8 i2c_control_buf[3] = {(u8)(GTP_REG_SLEEP >> 8), (u8)GTP_REG_SLEEP, 5};
-        
-        
-        GTP_GPIO_OUTPUT(GTP_INT_PORT, 0);
-        msleep(5);
-    
-        while (retry++ < 5)
-        {
-            ret = gtp_i2c_write(client, i2c_control_buf, 3);
-    
-            if (ret > 0)
-            {
-                GTP_INFO("GTP enter sleep!");
-                    
-                return ret;
-            }
-    
-            msleep(10);
-        }
-    
-        GTP_ERROR("GTP send sleep cmd failed.");
-        return ret;
-    }
-#endif
-}
-#endif
-
-/*******************************************************
-Function:
-    Wakeup from sleep mode Function.
-
-Input:
-    client:i2c_client.
-
-Output:
-    Executive outcomes.0--success,non-0--fail.
-*******************************************************/
-static s8 gtp_wakeup_sleep(struct i2c_client *client)
-{
-    u8 retry = 0;
-    s8 ret = -1;
-
-    GTP_DEBUG("GTP wakeup begin.");
-
-#if (GTP_POWER_CTRL_SLEEP)   
-
-#if GTP_COMPATIBLE_MODE
-    if (CHIP_TYPE_GT9F == gtp_chip_type)
-    {
-        force_reset_guitar();
-        GTP_INFO("Esd recovery wakeup.");
-        return 0;
-    }
-#endif
-
-    while (retry++ < 5)
-    {
-        ret = tpd_power_on(client);
-
-        if (ret < 0)
-        {
-            GTP_ERROR("I2C Power on ERROR!");
-            continue;
-        }
-        GTP_INFO("Ic wakeup by poweron");
-        return 0;
-    }
-#else
-
-#if GTP_COMPATIBLE_MODE
-    if (CHIP_TYPE_GT9F == gtp_chip_type)
-    {
-        u8 opr_buf[2] = {0};
-        
-        while (retry++ < 10)
-        {
-            GTP_GPIO_OUTPUT(GTP_INT_PORT, 1);
-            msleep(5);
-            
-            ret = gtp_i2c_test(client);
-    
-            if (ret >= 0)
-            {  
-                // Hold ss51 & dsp
-                opr_buf[0] = 0x0C;
-                ret = i2c_write_bytes(client, 0x4180, opr_buf, 1);
-                if (ret < 0)
-                {
-                    GTP_DEBUG("Hold ss51 & dsp I2C error,retry:%d", retry);
-                    continue;
-                }
-                
-                // Confirm hold
-                opr_buf[0] = 0x00;
-                ret = i2c_read_bytes(client, 0x4180, opr_buf, 1);
-                if (ret < 0)
-                {
-                    GTP_DEBUG("confirm ss51 & dsp hold, I2C error,retry:%d", retry);
-                    continue;
-                }
-                if (0x0C != opr_buf[0])
-                {
-                    GTP_DEBUG("ss51 & dsp not hold, val: %d, retry: %d", opr_buf[0], retry);
-                    continue;
-                }
-                GTP_DEBUG("ss51 & dsp has been hold");
-                
-                ret = gtp_fw_startup(client);
-                if (FAIL == ret)
-                {
-                    GTP_ERROR("[gtp_wakeup_sleep]Startup fw failed.");
-                    continue;
-                }
-                GTP_INFO("flashless wakeup sleep success");
-                return ret;
-            }
-            force_reset_guitar();
-            retry = 0;
-            break;
-        }
-        if (retry >= 10)
-        {
-            GTP_ERROR("wakeup retry timeout, process esd reset");
-            force_reset_guitar();
-        }
-        GTP_ERROR("GTP wakeup sleep failed.");
-        return ret;
-    }
-#endif
-    while (retry++ < 10)
-    {
-    #if GTP_GESTURE_WAKEUP
-        if (DOZE_WAKEUP != doze_status)
-        {
-            GTP_INFO("Powerkey wakeup.");
-        }
-        else
-        {
-            GTP_INFO("Gesture wakeup.");
-        }
-        doze_status = DOZE_DISABLED;
-        
-        mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
-        gtp_reset_guitar(client, 20);
-        mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
-    #else
-    
-        GTP_GPIO_OUTPUT(GTP_INT_PORT, 1);
-        msleep(5);
-    #endif
-        
-        ret = gtp_i2c_test(client);
-
-        if (ret >= 0)
-        {
-            GTP_INFO("GTP wakeup sleep.");
-        #if (!GTP_GESTURE_WAKEUP)
-            {
-                gtp_int_sync(25);
-            #if GTP_ESD_PROTECT
-                gtp_init_ext_watchdog(client);
-            #endif
-            }
-        #endif
-            
-            return ret;
-        }
-        gtp_reset_guitar(client, 20);
-    }
-#endif
-    GTP_ERROR("GTP wakeup sleep failed.");
-    return ret;
-}
-
-/* Function to manage low power suspend */
-static void tpd_suspend(struct early_suspend *h)
-{
-    s32 ret = -1;
-
-    GTP_INFO("System suspend.");
-
-#ifdef TPD_PROXIMITY
-
-    if (tpd_proximity_flag == 1)
-    {
-    	tpd_proximity_flag_one = 1;	//jeff add 20150317
-        return ;
-    }
-
-#endif
-
-    tpd_halt = 1;
-#if GTP_ESD_PROTECT
-    gtp_esd_switch(i2c_client_point, SWITCH_OFF);
-#endif
-    
-#if GTP_GESTURE_WAKEUP
-    ret = gtp_enter_doze(i2c_client_point);
-#else
-    mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
-    ret = gtp_enter_sleep(i2c_client_point);
-#endif
-    if (ret < 0)
-    {
-        GTP_ERROR("GTP early suspend failed.");
-    }
-    // to avoid waking up while not sleeping, delay 48 + 10ms to ensure reliability 
-    msleep(58);
-}
-
-/* Function to manage power-on resume */
-static void tpd_resume(struct early_suspend *h)
-{
-    s32 ret = -1;
-
-    GTP_INFO("System resume.");
-    
-#ifdef TPD_PROXIMITY
-
-    if (tpd_proximity_flag == 1)
-    {
-//        return ;
-	//jeff modify 20150317
-	if(tpd_proximity_flag_one == 1)
-	{
-		tpd_proximity_flag_one = 0;	
-		GTP_INFO(TPD_DEVICE " tpd_proximity_flag_one \n"); 
-		return;
-	}
-    }
-
-#endif
-    ret = gtp_wakeup_sleep(i2c_client_point);
-
-    if (ret < 0)
-    {
-        GTP_ERROR("GTP later resume failed.");
-    }
-    
-#if GTP_COMPATIBLE_MODE
-    if (CHIP_TYPE_GT9F == gtp_chip_type)
-    {
-        // do nothing
-    }
-    else
-#endif
-    {
-        gtp_send_cfg(i2c_client_point);
-    }
-    
-#if GTP_CHARGER_SWITCH
-    gtp_charger_switch(1);  // force update
-#endif
-
-    tpd_halt = 0;
-#if GTP_GESTURE_WAKEUP
-    doze_status = DOZE_DISABLED;
-#else 
-    mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
-#endif
-
-#if GTP_ESD_PROTECT
-    gtp_esd_switch(i2c_client_point, SWITCH_ON);
-#endif
-
-}
-
-static struct tpd_driver_t tpd_device_driver =
-{
-    .tpd_device_name = "gt9xx",
-    .tpd_local_init = tpd_local_init,
-    .suspend = tpd_suspend,
-    .resume = tpd_resume,
-#ifdef TPD_HAVE_BUTTON
-    .tpd_have_button = 1,
-#else
-    .tpd_have_button = 0,
-#endif
-};
-
-/* called when loaded into kernel */
-static int __init tpd_driver_init(void)
-{
-    GTP_INFO("MediaTek gt91xx touch panel driver init\n");
-#ifdef MT6572
-    i2c_register_board_info(I2C_BUS_NUMBER, &i2c_tpd, 1);
-#else
-    i2c_register_board_info(1, &i2c_tpd, 1);
-#endif
-    if (tpd_driver_add(&tpd_device_driver) < 0)
-        GTP_INFO("add generic driver failed\n");
-
-    return 0;
-}
-
-/* should never be called */
-static void __exit tpd_driver_exit(void)
-{
-    GTP_INFO("MediaTek gt91xx touch panel driver exit\n");
-    tpd_driver_remove(&tpd_device_driver);
-}
-
-module_init(tpd_driver_init);
-module_exit(tpd_driver_exit);
-
diff --git a/drivers/input/touchscreen/mediatek/GT915_QHD/tpd_custom_gt9xx.h~ b/drivers/input/touchscreen/mediatek/GT915_QHD/tpd_custom_gt9xx.h~
deleted file mode 100755
index 88e397a..0000000
--- a/drivers/input/touchscreen/mediatek/GT915_QHD/tpd_custom_gt9xx.h~
+++ /dev/null
@@ -1,415 +0,0 @@
-/* Copyright Statement:
- *
- * This software/firmware and related documentation ("MediaTek Software") are
- * protected under relevant copyright laws. The information contained herein
- * is confidential and proprietary to MediaTek Inc. and/or its licensors.
- * Without the prior written permission of MediaTek inc. and/or its licensors,
- * any reproduction, modification, use or disclosure of MediaTek Software,
- * and information contained herein, in whole or in part, shall be strictly prohibited.
- */ 
-/* MediaTek Inc. (C) 2010. All rights reserved.
- * 
- * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
- * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE") 
- * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
- * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
- * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
- * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
- * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
- * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
- * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
- * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
- * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
- * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
- * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
- * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
- * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
- * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
- *
- * The following software/firmware and/or related documentation ("MediaTek Software")
- * have been modified by MediaTek Inc. All revisions are subject to any receiver's
- * applicable license agreements with MediaTek Inc.
- */
-
-#ifndef TPD_CUSTOM_GT9XX_H__
-#define TPD_CUSTOM_GT9XX_H__
-
-#include <linux/hrtimer.h>
-#include <linux/string.h>
-#include <linux/vmalloc.h>
-//#include <linux/io.h>
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/delay.h>
-#include <linux/i2c.h>
-#include <linux/input.h>
-#include <linux/slab.h>
-#include <linux/gpio.h>
-#include <linux/sched.h>
-#include <linux/kthread.h>
-#include <linux/bitops.h>
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/byteorder/generic.h>
-#ifdef CONFIG_HAS_EARLYSUSPEND
-#include <linux/earlysuspend.h>
-#endif
-#include <linux/interrupt.h>
-#include <linux/time.h>
-#include <linux/rtpm_prio.h>
-
-#include <linux/proc_fs.h>
-#include <asm/uaccess.h>
-#ifdef MT6575
-#include <mach/mt6575_pm_ldo.h>
-#include <mach/mt6575_typedefs.h>
-#include <mach/mt6575_boot.h>
-#endif
-#ifdef MT6577
-#include <mach/mt6577_pm_ldo.h>
-#include <mach/mt6577_typedefs.h>
-#include <mach/mt6577_boot.h>
-#endif
-#include <mach/mt_pm_ldo.h>
-#include <mach/mt_typedefs.h>
-#include <mach/mt_boot.h>
-
-#include <linux/rtpm_prio.h>
-//#include "tpd.h"
-#include "cust_gpio_usage.h"
-#include <pmic_drv.h>
-
-#include <cust_eint.h>
-#include <linux/jiffies.h>
-
-/* Pre-defined definition */
-#define TPD_KEY_COUNT   4
-#define key_1           60,850              //auto define  
-#define key_2           180,850
-#define key_3           300,850
-#define key_4           420,850
-
-#define TPD_KEYS        {KEY_BACK, KEY_HOME, KEY_MENU, KEY_SEARCH}
-#define TPD_KEYS_DIM    {{key_1,50,30},{key_2,50,30},{key_3,50,30},{key_4,50,30}}
-extern u16 show_len;
-extern u16 total_len;
-extern u8 gtp_rawdiff_mode;
-
-extern int tpd_halt;
-extern s32 gtp_send_cfg(struct i2c_client *client);
-extern void gtp_reset_guitar(struct i2c_client *client, s32 ms);
-extern void gtp_int_sync(s32 ms);       
-extern u8 gup_init_update_proc(struct i2c_client *client);
-extern u8 gup_init_fw_proc(struct i2c_client *client);
-extern void mt65xx_eint_unmask(unsigned int line);
-extern void mt65xx_eint_mask(unsigned int line);
-extern s32 gtp_i2c_read(struct i2c_client *client, u8 *buf, s32 len);
-extern s32 gtp_i2c_write(struct i2c_client *client,u8 *buf,s32 len);
-extern int i2c_write_bytes(struct i2c_client *client, u16 addr, u8 *txbuf, int len);
-extern int i2c_read_bytes(struct i2c_client *client, u16 addr, u8 *rxbuf, int len);
-extern s32 i2c_read_dbl_check(struct i2c_client *client, u16 addr, u8 *rxbuf, int len);
-extern s32 gtp_i2c_read_dbl_check(struct i2c_client *client, u16 addr, u8 *rxbuf, int len);
-
-//***************************PART1:ON/OFF define*******************************
-#define GTP_CUSTOM_CFG        0
-#define GTP_DRIVER_SEND_CFG   1       // driver send config to TP in intilization
-#define GTP_HAVE_TOUCH_KEY    1
-#define GTP_POWER_CTRL_SLEEP  0       // turn off/on power on suspend/resume
-
-#define GTP_AUTO_UPDATE       0       // auto updated fw by .bin file
-#define GTP_HEADER_FW_UPDATE  0       // auto updated fw by gtp_default_FW in gt9xx_firmware.h, function together with GTP_AUTO_UDPATE
-#define GTP_AUTO_UPDATE_CFG   0       // auto update config by .cfg file, function together with GTP_AUTO_UPDATE
-
-#define GTP_SUPPORT_I2C_DMA   0       // if gt9xxf, better enable it if hardware platform supported
-#define GTP_COMPATIBLE_MODE   0       // compatible with GT9XXF
-
-#define GTP_CREATE_WR_NODE    1
-#define GTP_ESD_PROTECT       0       // esd protection with a cycle of 2 seconds
-#define GTP_CHARGER_SWITCH    0       // charger plugin & plugout detect
-
-#define GTP_WITH_PEN          0      
-#define GTP_PEN_HAVE_BUTTON   0       // active pen has buttons, functions together with GTP_WITH_PEN
-
-#define GTP_GESTURE_WAKEUP    0 
-
-#define TPD_PROXIMITY
-//#define TPD_HAVE_BUTTON             // report key as coordinate,Vibration feedback
-//#define TPD_WARP_X                  // mirrored x coordinate
-//#define TPD_WARP_Y                  // mirrored y coordinate
-#define GTP_DEBUG_ON          1
-#define GTP_DEBUG_ARRAY_ON    0
-#define GTP_DEBUG_FUNC_ON     0
-
-//***************************PART2:TODO define**********************************
-//STEP_1(REQUIRED):Change config table.
-// Sensor_ID Map:
-/* sensor_opt1 sensor_opt2 Sensor_ID 
-    GND         GND         0 
-    VDDIO       GND         1 
-    NC          GND         2 
-    GND         NC/300K     3 
-    VDDIO       NC/300K     4 
-    NC          NC/300K     5 
-*/
-// TODO: define your own default or for Sensor_ID == 0 config here. 
-// The predefined one is just a sample config, which is not suitable for your tp in most cases.
-
-//add clj 20150203 q32  shanghai_youxia
- 
-#if 0
-
-#define CTP_CFG_GROUP1 {\
-    0x43,0xD0,0x02,0x00,0x05,0x05,0x05,0x00,0x01,0x0F,\
-    0x28,0x0F,0x50,0x32,0x03,0x05,0x00,0x00,0xFF,0x7F,\
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x89,0x09,0x0A,\
-    0x2D,0x00,0x0F,0x0A,0x00,0x14,0x01,0x02,0x33,0x1D,\
-    0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x32,0x00,0x28,\
-    0x7A,0x23,0x55,0x94,0xC5,0x02,0x07,0x00,0x00,0x04,\
-    0x95,0x26,0x00,0x80,0x2D,0x00,0x6C,0x36,0x00,0x5C,\
-    0x41,0x00,0x4E,0x4E,0x00,0x4E,0x00,0x00,0x00,0x00,\
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x32,0x02,0x14,\
-    0x1E,0x01,0x1D,0x1E,0x14,0x0F,0x00,0x00,0x01,0x00,\
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x19,0x00,0x00,\
-    0x46,0x32,0x08,0x0A,0x0C,0x0E,0x10,0x12,0x14,0x16,\
-    0x18,0x1A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
-    0x0A,0x00,0x2A,0x29,0x28,0x24,0x22,0x20,0x1F,0x1E,\
-    0x1D,0x00,0x02,0x04,0x05,0x06,0x08,0x0A,0x0C,0x0E,\
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
-    0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\
-    0xFF,0xFF,0xFF,0xFF,0x8A,0x01\
-    }
-#else 
-//add clj q33
-
-#define CTP_CFG_GROUP1 {\
-    0x44,0xD0,0x02,0x00,0x05,0x05,0x05,0x01,0x01,0x0F,\
-0x28,0x0F,0x46,0x32,0x03,0x05,0x00,0x00,0xFF,0x7F,\
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x8B,0x0B,0x0C,\
-0x28,0x2A,0x0F,0x0A,0x00,0x14,0x00,0x03,0x22,0x1D,\
-0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x32,0x00,0x28,\
-0x7B,0x1E,0x50,0x94,0xC5,0x02,0x07,0x00,0x00,0x04,\
-0x98,0x21,0x00,0x80,0x28,0x00,0x6B,0x31,0x00,0x5B,\
-0x3B,0x00,0x4D,0x48,0x00,0x4D,0x38,0x00,0x00,0x00,\
-0xF0,0x30,0x20,0xFF,0xFF,0x27,0x00,0x32,0x02,0x14,\
-0x1E,0x99,0x1D,0x1E,0x14,0x0F,0x00,0x00,0x01,0x00,\
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x19,0x00,0x00,\
-0x46,0x32,0x18,0x16,0x14,0x12,0x10,0x0E,0x0C,0x0A,\
-0x08,0x06,0x04,0x02,0xFF,0xFF,0x00,0x00,0x00,0x00,\
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
-0x0A,0x00,0x02,0x04,0x06,0x08,0x0A,0x0C,0x0F,0x10,\
-0x12,0x13,0x16,0x18,0x1C,0x1D,0x1E,0x1F,0x20,0x21,\
-0x22,0x24,0x26,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x00,\
-0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\
-0xFF,0xAF,0xFF,0xFF,0x85,0x01 \
-    }
-#endif 
-
-
-// TODO: define your config for Sensor_ID == 1 here, if needed
-#define CTP_CFG_GROUP2 {\
-    }
-
-// TODO: define your config for Sensor_ID == 2 here, if needed
-#define CTP_CFG_GROUP3 {\
-    }
-
-// TODO: define your config for Sensor_ID == 3 here, if needed
-#define CTP_CFG_GROUP4 {\
-    }
-
-// TODO: define your config for Sensor_ID == 4 here, if needed
-#define CTP_CFG_GROUP5 {\
-    }
-
-// TODO: define your config for Sensor_ID == 5 here, if needed
-#define CTP_CFG_GROUP6 {\
-    }
-
-// STEP_2(REQUIRED): Customize your I/O ports & I/O operations here
-#define TPD_POWER_SOURCE_CUSTOM     PMIC_APP_CAP_TOUCH_VDD//MT65XX_POWER_LDO_VGP4      // define your power source for tp if needed
-#define GTP_RST_PORT    GPIO_CTP_RST_PIN
-#define GTP_INT_PORT    GPIO_CTP_EINT_PIN
-
-#define GTP_GPIO_AS_INPUT(pin)          do{\
-                                            if(pin == GPIO_CTP_EINT_PIN)\
-                                                mt_set_gpio_mode(pin, GPIO_CTP_EINT_PIN_M_GPIO);\
-                                            else\
-                                                mt_set_gpio_mode(pin, GPIO_CTP_RST_PIN_M_GPIO);\
-                                            mt_set_gpio_dir(pin, GPIO_DIR_IN);\
-                                            mt_set_gpio_pull_enable(pin, GPIO_PULL_DISABLE);\
-                                        }while(0)
-#define GTP_GPIO_AS_INT(pin)            do{\
-                                            mt_set_gpio_mode(pin, GPIO_CTP_EINT_PIN_M_EINT);\
-                                            mt_set_gpio_dir(pin, GPIO_DIR_IN);\
-                                            mt_set_gpio_pull_enable(pin, GPIO_PULL_DISABLE);\
-                                        }while(0)
-#define GTP_GPIO_GET_VALUE(pin)         mt_get_gpio_in(pin)
-#define GTP_GPIO_OUTPUT(pin,level)      do{\
-                                            if(pin == GPIO_CTP_EINT_PIN)\
-                                                mt_set_gpio_mode(pin, GPIO_CTP_EINT_PIN_M_GPIO);\
-                                            else\
-                                                mt_set_gpio_mode(pin, GPIO_CTP_RST_PIN_M_GPIO);\
-                                            mt_set_gpio_dir(pin, GPIO_DIR_OUT);\
-                                            mt_set_gpio_out(pin, level);\
-                                        }while(0)
-#define GTP_GPIO_REQUEST(pin, label)    gpio_request(pin, label)
-#define GTP_GPIO_FREE(pin)              gpio_free(pin)
-#define GTP_IRQ_TAB                     {IRQ_TYPE_EDGE_RISING, IRQ_TYPE_EDGE_FALLING, IRQ_TYPE_LEVEL_LOW, IRQ_TYPE_LEVEL_HIGH}
-
-// STEP_3(optional):Custom set some config by themself,if need.
-#if GTP_CUSTOM_CFG
-  #define GTP_MAX_HEIGHT   960           
-  #define GTP_MAX_WIDTH    540
-  #define GTP_INT_TRIGGER  0    //0:Rising 1:Falling
-#else 
-  #define GTP_MAX_HEIGHT   960  //4096
-  #define GTP_MAX_WIDTH    540
-  #define GTP_INT_TRIGGER  1
-#endif
-#define GTP_MAX_TOUCH      5
-#define VELOCITY_CUSTOM
-#define TPD_VELOCITY_CUSTOM_X 15
-#define TPD_VELOCITY_CUSTOM_Y 15
-
-//STEP_4(optional):If this project have touch key,Set touch key config.                                    
-#if GTP_HAVE_TOUCH_KEY
-    #define GTP_KEY_TAB  {KEY_FINGER, KEY_HOME, KEY_BACK, KEY_SEND}
-#endif
-
-//***************************PART3:OTHER define*********************************
-#define GTP_DRIVER_VERSION          "V2.2<2014/01/14>"
-#define GTP_I2C_NAME                "Goodix-TS"
-#define GT91XX_CONFIG_PROC_FILE     "gt9xx_config"
-#define GTP_POLL_TIME               10
-#define GTP_ADDR_LENGTH             2
-#define GTP_CONFIG_MIN_LENGTH       186
-#define GTP_CONFIG_MAX_LENGTH       240
-#define FAIL                        0
-#define SUCCESS                     1
-#define SWITCH_OFF                  0
-#define SWITCH_ON                   1
-
-#define CFG_GROUP_LEN(p_cfg_grp)  (sizeof(p_cfg_grp) / sizeof(p_cfg_grp[0]))
-
-//******************** For GT9XXF Start **********************//
-#if GTP_COMPATIBLE_MODE
-typedef enum
-{
-    CHIP_TYPE_GT9  = 0,
-    CHIP_TYPE_GT9F = 1,
-} CHIP_TYPE_T;
-#endif
-
-#define GTP_REG_MATRIX_DRVNUM           0x8069
-#define GTP_REG_MATRIX_SENNUM           0x806A
-#define GTP_REG_RQST                    0x8043
-#define GTP_REG_BAK_REF                 0x99D0
-#define GTP_REG_MAIN_CLK                0x8020
-#define GTP_REG_CHIP_TYPE               0x8000
-#define GTP_REG_HAVE_KEY                0x804E
-
-#define GTP_FL_FW_BURN              0x00
-#define GTP_FL_ESD_RECOVERY         0x01
-#define GTP_FL_READ_REPAIR          0x02
-
-#define GTP_BAK_REF_SEND                0
-#define GTP_BAK_REF_STORE               1
-#define CFG_LOC_DRVA_NUM                29
-#define CFG_LOC_DRVB_NUM                30
-#define CFG_LOC_SENS_NUM                31
-
-#define GTP_CHK_FW_MAX                  1000
-#define GTP_CHK_FS_MNT_MAX              300
-#define GTP_BAK_REF_PATH                "/data/gtp_ref.bin"
-#define GTP_MAIN_CLK_PATH               "/data/gtp_clk.bin"
-#define GTP_RQST_CONFIG                 0x01
-#define GTP_RQST_BAK_REF                0x02
-#define GTP_RQST_RESET                  0x03
-#define GTP_RQST_MAIN_CLOCK             0x04
-#define GTP_RQST_RESPONDED              0x00
-#define GTP_RQST_IDLE                   0xFF
-
-//******************** For GT9XXF End **********************//
-
-//Register define
-#define GTP_READ_COOR_ADDR          0x814E
-#define GTP_REG_SLEEP               0x8040
-#define GTP_REG_SENSOR_ID           0x814A
-#define GTP_REG_CONFIG_DATA         0x8047
-#define GTP_REG_VERSION             0x8140
-#define GTP_REG_HW_INFO             0x4220
-
-#define RESOLUTION_LOC              3
-#define TRIGGER_LOC                 8
-
-#define I2C_MASTER_CLOCK                300
-#define I2C_BUS_NUMBER                  1     // I2C Bus for TP, mt6572
-#define GTP_DMA_MAX_TRANSACTION_LENGTH  255   // for DMA mode
-#define GTP_DMA_MAX_I2C_TRANSFER_SIZE   (GTP_DMA_MAX_TRANSACTION_LENGTH - GTP_ADDR_LENGTH)
-#define MAX_TRANSACTION_LENGTH          8
-#define MAX_I2C_TRANSFER_SIZE           (MAX_TRANSACTION_LENGTH - GTP_ADDR_LENGTH)
-#define TPD_MAX_RESET_COUNT             3
-#define TPD_CALIBRATION_MATRIX          {962,0,0,0,1600,0,0,0};
-
-
-#define TPD_RESET_ISSUE_WORKAROUND
-#define TPD_HAVE_CALIBRATION
-#define TPD_NO_GPIO
-#define TPD_RESET_ISSUE_WORKAROUND
-
-#ifdef TPD_WARP_X
-#undef TPD_WARP_X
-#define TPD_WARP_X(x_max, x) ( x_max - 1 - x )
-#else
-#define TPD_WARP_X(x_max, x) x
-#endif
-
-#ifdef TPD_WARP_Y
-#undef TPD_WARP_Y
-#define TPD_WARP_Y(y_max, y) ( y_max - 1 - y )
-#else
-#define TPD_WARP_Y(y_max, y) y
-#endif
-
-//Log define
-#define GTP_INFO(fmt,arg...)           printk("<<-GTP-INFO->> "fmt"\n",##arg)
-#define GTP_ERROR(fmt,arg...)          printk("<<-GTP-ERROR->> "fmt"\n",##arg)
-#define GTP_DEBUG(fmt,arg...)          do{\
-                                         if(GTP_DEBUG_ON)\
-                                         printk("<<-GTP-DEBUG->> [%d]"fmt"\n",__LINE__, ##arg);\
-                                       }while(0)
-#define GTP_DEBUG_ARRAY(array, num)    do{\
-                                         s32 i;\
-                                         u8* a = array;\
-                                         if(GTP_DEBUG_ARRAY_ON)\
-                                         {\
-                                            printk("<<-GTP-DEBUG-ARRAY->>\n");\
-                                            for (i = 0; i < (num); i++)\
-                                            {\
-                                                printk("%02x   ", (a)[i]);\
-                                                if ((i + 1 ) %10 == 0)\
-                                                {\
-                                                    printk("\n");\
-                                                }\
-                                            }\
-                                            printk("\n");\
-                                        }\
-                                       }while(0)
-#define GTP_DEBUG_FUNC()               do{\
-                                         if(GTP_DEBUG_FUNC_ON)\
-                                         printk("<<-GTP-FUNC->> Func:%s@Line:%d\n",__func__,__LINE__);\
-                                       }while(0)
-#define GTP_SWAP(x, y)                 do{\
-                                         typeof(x) z = x;\
-                                         x = y;\
-                                         y = z;\
-                                       }while (0)
-
-
-//*****************************End of Part III********************************
-
-#endif /* TPD_CUSTOM_GT9XX_H__ */
diff --git a/drivers/input/touchscreen/mediatek/Makefile b/drivers/input/touchscreen/mediatek/Makefile
index efbb613..4a8435d 100755
--- a/drivers/input/touchscreen/mediatek/Makefile
+++ b/drivers/input/touchscreen/mediatek/Makefile
@@ -144,6 +144,11 @@ endif
 ifeq ($(CONFIG_MTK_GT911),y)
 obj-y	+=  GT911/
 endif
+
+ifeq ($(CONFIG_TOUCHSCREEN_MTK_FT_ALLINONE_GESTURE),y)
+obj-y	+=  ft_allinone_gesture/
+endif
+
 ifeq ($(CONFIG_MTK_GT915_HD),y)
 obj-y	+=  GT915_HD/
 endif
diff --git a/drivers/input/touchscreen/mediatek/focaltech_hd/Makefile~ b/drivers/input/touchscreen/mediatek/focaltech_hd/Makefile~
deleted file mode 100755
index eb50f3a..0000000
--- a/drivers/input/touchscreen/mediatek/focaltech_hd/Makefile~
+++ /dev/null
@@ -1,18 +0,0 @@
-include $(srctree)/drivers/misc/mediatek/Makefile.custom
-
-# Linux driver folder
-ccflags-y += -I$(srctree)/drivers/misc/mediatek/mach/$(MTK_PLATFORM)/$(ARCH_MTK_PROJECT)/touchpanel/focaltech_hd/
-ccflags-y += -I$(srctree)/arch/arm/mach-$(MTK_PLATFORM)/$(ARCH_MTK_PROJECT)/touchpanel/focaltech_hd/
-ccflags-y += -I$(srctree)/drivers/input/touchscreen/mediatek/focaltech_hd/
-ccflags-y += -I$(srctree)/drivers/input/touchscreen/mediatek/
-
-#obj-y += ft_gesture_lib.o
-#$(obj)/ft_gesture_lib.o: $(srctree)/../$(obj)/touchpanel/ft_gesture_lib.o
-#	cp $(srctree)/../$(obj)/touchpanel/ft_gesture_lib.o $(obj)/ft_gesture_lib.o
-
-obj-y	+=  focaltech_ctl.o
-obj-y	+=  focaltech_driver.o
-obj-y	+=  focaltech_ex_fun.o
-#obj-y	+=  gt1x_tpd.o
-#obj-y	+=  gt1x_update.o
-
diff --git a/drivers/input/touchscreen/mediatek/focaltech_hd/focaltech_driver.c~ b/drivers/input/touchscreen/mediatek/focaltech_hd/focaltech_driver.c~
deleted file mode 100755
index adb804d..0000000
--- a/drivers/input/touchscreen/mediatek/focaltech_hd/focaltech_driver.c~
+++ /dev/null
@@ -1,1162 +0,0 @@
-/*
- * This software is licensed under the terms of the GNU General Public 
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms. 
- * This program is distributed in the hope that it will be useful, 
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
- * GNU General Public License for more details. 
- * * VERSION      	DATE			AUTHOR          Note
- *    1.0		  2013-7-16			Focaltech        initial  based on MTK platform
- * 
- */
-
-#include "tpd.h"
-
-#include "tpd_custom_fts.h"
-#ifdef FTS_CTL_IIC
-#include "focaltech_ctl.h"
-#endif
-#ifdef TPD_SYSFS_DEBUG
-#include "focaltech_ex_fun.h"
-#endif
-#ifdef TPD_PROXIMITY
-#include <linux/hwmsensor.h>
-#include <linux/hwmsen_dev.h>
-#include <linux/sensors_io.h>
-#endif
-#include <mach/eint.h>
-#include "cust_gpio_usage.h"
-
-
-  struct Upgrade_Info fts_updateinfo[] =
-{
-        {0x55,"FT5x06",TPD_MAX_POINTS_5,AUTO_CLB_NEED,50, 30, 0x79, 0x03, 1, 2000},
-        {0x08,"FT5606",TPD_MAX_POINTS_5,AUTO_CLB_NEED,50, 30, 0x79, 0x06, 100, 2000},
-	{0x0a,"FT5x16",TPD_MAX_POINTS_5,AUTO_CLB_NEED,50, 30, 0x79, 0x07, 1, 1500},
-	{0x05,"FT6208",TPD_MAX_POINTS_2,AUTO_CLB_NONEED,60, 30, 0x79, 0x05, 10, 2000},
-	{0x06,"FT6x06",TPD_MAX_POINTS_2,AUTO_CLB_NONEED,100, 30, 0x79, 0x08, 10, 2000},
-	{0x36,"FT6x36",TPD_MAX_POINTS_2,AUTO_CLB_NONEED,100, 30, 0x79, 0x18, 10, 2000},//CHIP ID error
-	{0x55,"FT5x06i",TPD_MAX_POINTS_5,AUTO_CLB_NEED,50, 30, 0x79, 0x03, 1, 2000},
-	{0x14,"FT5336",TPD_MAX_POINTS_5,AUTO_CLB_NONEED,30, 30, 0x79, 0x11, 10, 2000},
-	{0x13,"FT3316",TPD_MAX_POINTS_5,AUTO_CLB_NONEED,30, 30, 0x79, 0x11, 10, 2000},
-	{0x12,"FT5436i",TPD_MAX_POINTS_5,AUTO_CLB_NONEED,30, 30, 0x79, 0x11, 10, 2000},
-	{0x11,"FT5336i",TPD_MAX_POINTS_5,AUTO_CLB_NONEED,30, 30, 0x79, 0x11, 10, 2000},
-};
-				
-struct Upgrade_Info fts_updateinfo_curr;
-
-#ifdef TPD_PROXIMITY
-#define APS_ERR(fmt,arg...)           	printk("<<proximity>> "fmt"\n",##arg)
-#define TPD_PROXIMITY_DEBUG(fmt,arg...) printk("<<proximity>> "fmt"\n",##arg)
-#define TPD_PROXIMITY_DMESG(fmt,arg...) printk("<<proximity>> "fmt"\n",##arg)
-
-static u8 tpd_proximity_flag 			= 0;
-static u8 tpd_proximity_flag_one 		= 0; //add for tpd_proximity by wangdongfang
-static u8 tpd_proximity_detect 		= 1;//0-->close ; 1--> far away
-#endif
-
-#ifdef FTS_GESTRUE
-#define GESTURE_LEFT		0x20
-#define GESTURE_RIGHT		0x21
-#define GESTURE_UP		    0x22
-#define GESTURE_DOWN		0x23
-#define GESTURE_DOUBLECLICK	0x24
-#define GESTURE_O		    0x30
-#define GESTURE_W		    0x31
-#define GESTURE_M		    0x32
-#define GESTURE_E		    0x33
-#define GESTURE_C		    0x34
-#define GESTURE_S		    0x46
-#define GESTURE_V		    0x54
-#define GESTURE_Z		    0x41
-
-#include "ft_gesture_lib.h"
-
-#define FTS_GESTRUE_POINTS 255
-#define FTS_GESTRUE_POINTS_ONETIME  62
-#define FTS_GESTRUE_POINTS_HEADER 8
-#define FTS_GESTURE_OUTPUT_ADRESS 0xD3
-#define FTS_GESTURE_OUTPUT_UNIT_LENGTH 4
-
-//suspend_state_t get_suspend_state(void);
-
-unsigned short coordinate_x[150] = {0};
-unsigned short coordinate_y[150] = {0};
-#endif
-extern struct tpd_device *tpd;
- 
-static struct i2c_client *i2c_client = NULL;
-struct task_struct *thread = NULL;
- 
-static DECLARE_WAIT_QUEUE_HEAD(waiter);
-static DEFINE_MUTEX(i2c_access);
- 
- 
-static void tpd_eint_interrupt_handler(void);
-// start:Here maybe need port to different platform,like MT6575/MT6577
-extern void mt_eint_unmask(unsigned int line);
-extern void mt_eint_mask(unsigned int line);
-extern void mt_eint_set_hw_debounce(unsigned int eint_num, unsigned int ms);
-//extern unsigned int mt65xx_eint_set_sens(unsigned int eint_num, unsigned int sens);
-//extern void mt65xx_eint_registration(unsigned int eint_num, unsigned int is_deb_en, unsigned int pol, void (EINT_FUNC_PTR)(void), unsigned int is_auto_umask);
-extern void mt_eint_registration(unsigned int eint_num, unsigned int flow, void (EINT_FUNC_PTR)(void), unsigned int is_auto_umask);
-// End:Here maybe need port to different platform,like MT6575/MT6577
- 
-static int tpd_probe(struct i2c_client *client, const struct i2c_device_id *id);
-static int tpd_detect (struct i2c_client *client, struct i2c_board_info *info);
-static int tpd_remove(struct i2c_client *client);
-static int touch_event_handler(void *unused);
-
-static int tpd_flag 					= 0;
-static int tpd_halt						= 0;
-static int point_num 					= 0;
-static int p_point_num 					= 0;
-
-
-
-//#define TPD_CLOSE_POWER_IN_SLEEP
-#define TPD_OK 							0
-//register define
-#define DEVICE_MODE 					0x00
-#define GEST_ID 						0x01
-#define TD_STATUS 						0x02
-//point1 info from 0x03~0x08
-//point2 info from 0x09~0x0E
-//point3 info from 0x0F~0x14
-//point4 info from 0x15~0x1A
-//point5 info from 0x1B~0x20
-//register define
-
-#define TPD_RESET_ISSUE_WORKAROUND
-
-#define TPD_MAX_RESET_COUNT 			3
-//extern int tpd_mstar_status ;  // compatible mstar and ft6306 chenzhecong
-
-#ifdef TPD_HAVE_BUTTON 
-static int tpd_keys_local[TPD_KEY_COUNT] = TPD_KEYS;
-static int tpd_keys_dim_local[TPD_KEY_COUNT][4] = TPD_KEYS_DIM;
-#endif
-#if (defined(TPD_WARP_START) && defined(TPD_WARP_END))
-static int tpd_wb_start_local[TPD_WARP_CNT] = TPD_WARP_START;
-static int tpd_wb_end_local[TPD_WARP_CNT]   = TPD_WARP_END;
-#endif
-#if (defined(TPD_HAVE_CALIBRATION) && !defined(TPD_CUSTOM_CALIBRATION))
-static int tpd_calmat_local[8]     = TPD_CALIBRATION_MATRIX;
-static int tpd_def_calmat_local[8] = TPD_CALIBRATION_MATRIX;
-#endif
-
-#define VELOCITY_CUSTOM_FT5206
-#ifdef VELOCITY_CUSTOM_FT5206
-#include <linux/device.h>
-#include <linux/miscdevice.h>
-#include <asm/uaccess.h>
-
-// for magnify velocity********************************************
-
-#ifndef TPD_VELOCITY_CUSTOM_X
-#define TPD_VELOCITY_CUSTOM_X 			10
-#endif
-#ifndef TPD_VELOCITY_CUSTOM_Y
-#define TPD_VELOCITY_CUSTOM_Y 			10
-#endif
-
-#define TOUCH_IOC_MAGIC 				'A'
-
-#define TPD_GET_VELOCITY_CUSTOM_X _IO(TOUCH_IOC_MAGIC,0)
-#define TPD_GET_VELOCITY_CUSTOM_Y _IO(TOUCH_IOC_MAGIC,1)
-
-
-static int g_v_magnify_x =TPD_VELOCITY_CUSTOM_X;
-static int g_v_magnify_y =TPD_VELOCITY_CUSTOM_Y;
-
-static int tpd_misc_open(struct inode *inode, struct file *file)
-{
-/*
-	file->private_data = adxl345_i2c_client;
-
-	if(file->private_data == NULL)
-	{
-		printk("tpd: null pointer!!\n");
-		return -EINVAL;
-	}
-	*/
-	return nonseekable_open(inode, file);
-}
-/*----------------------------------------------------------------------------*/
-static int tpd_misc_release(struct inode *inode, struct file *file)
-{
-	//file->private_data = NULL;
-	return 0;
-}
-/*----------------------------------------------------------------------------*/
-//static int adxl345_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
-//       unsigned long arg)
-static long tpd_unlocked_ioctl(struct file *file, unsigned int cmd,
-       unsigned long arg)
-{
-	//struct i2c_client *client = (struct i2c_client*)file->private_data;
-	//struct adxl345_i2c_data *obj = (struct adxl345_i2c_data*)i2c_get_clientdata(client);	
-	//char strbuf[256];
-	void __user *data;
-	
-	long err = 0;
-	
-	if(_IOC_DIR(cmd) & _IOC_READ)
-	{
-		err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
-	}
-	else if(_IOC_DIR(cmd) & _IOC_WRITE)
-	{
-		err = !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
-	}
-
-	if(err)
-	{
-		printk("tpd: access error: %08X, (%2d, %2d)\n", cmd, _IOC_DIR(cmd), _IOC_SIZE(cmd));
-		return -EFAULT;
-	}
-
-	switch(cmd)
-	{
-		case TPD_GET_VELOCITY_CUSTOM_X:
-			data = (void __user *) arg;
-			if(data == NULL)
-			{
-				err = -EINVAL;
-				break;	  
-			}			
-			
-			if(copy_to_user(data, &g_v_magnify_x, sizeof(g_v_magnify_x)))
-			{
-				err = -EFAULT;
-				break;
-			}				 
-			break;
-
-	   case TPD_GET_VELOCITY_CUSTOM_Y:
-			data = (void __user *) arg;
-			if(data == NULL)
-			{
-				err = -EINVAL;
-				break;	  
-			}			
-			
-			if(copy_to_user(data, &g_v_magnify_y, sizeof(g_v_magnify_y)))
-			{
-				err = -EFAULT;
-				break;
-			}				 
-			break;
-
-		default:
-			printk("tpd: unknown IOCTL: 0x%08x\n", cmd);
-			err = -ENOIOCTLCMD;
-			break;
-	}
-
-	return err;
-}
-
-
-static struct file_operations tpd_fops = {
-//	.owner = THIS_MODULE,
-	.open = tpd_misc_open,
-	.release = tpd_misc_release,
-	.unlocked_ioctl = tpd_unlocked_ioctl,
-};
-/*----------------------------------------------------------------------------*/
-static struct miscdevice tpd_misc_device = {
-	.minor = MISC_DYNAMIC_MINOR,
-	.name = TPD_NAME,
-	.fops = &tpd_fops,
-};
-
-//**********************************************
-#endif
-
-struct touch_info {
-    int y[10];
-    int x[10];
-    int p[10];
-    int id[10];
-};
- 
-static const struct i2c_device_id ft5206_tpd_id[] = {{TPD_NAME,0},{}};
-//unsigned short force[] = {0,0x70,I2C_CLIENT_END,I2C_CLIENT_END}; 
-//static const unsigned short * const forces[] = { force, NULL };
-//static struct i2c_client_address_data addr_data = { .forces = forces, };
-static struct i2c_board_info __initdata ft5206_i2c_tpd={ I2C_BOARD_INFO(TPD_NAME, (0x70>>1))};
- 
-static struct i2c_driver tpd_i2c_driver = {
-  	.driver = {
-	 	.name 	= TPD_NAME,
-	//	.owner 	= THIS_MODULE,
-  	},
-  	.probe 		= tpd_probe,
-  	.remove 	= tpd_remove,
-  	.id_table 	= ft5206_tpd_id,
-  	.detect 	= tpd_detect,
-// 	.shutdown	= tpd_shutdown,
-//  .address_data = &addr_data,
-};
-
-
-static  void tpd_down(int x, int y, int p) {
-	// input_report_abs(tpd->dev, ABS_PRESSURE, p);
-	input_report_key(tpd->dev, BTN_TOUCH, 1);
-	input_report_abs(tpd->dev, ABS_MT_TOUCH_MAJOR, 20);
-	input_report_abs(tpd->dev, ABS_MT_POSITION_X, x);
-	input_report_abs(tpd->dev, ABS_MT_POSITION_Y, y);
-	printk("D[%4d %4d %4d] ", x, y, p);
-	/* track id Start 0 */
-	input_report_abs(tpd->dev, ABS_MT_TRACKING_ID, p); 
-	input_mt_sync(tpd->dev);
-#ifndef MT6572
-    if (FACTORY_BOOT == get_boot_mode()|| RECOVERY_BOOT == get_boot_mode())
-#endif	
-    {   
-      tpd_button(x, y, 1);  
-    }
-	TPD_EM_PRINT(x, y, x, y, p-1, 1);
-}
- 
-static  void tpd_up(int x, int y) {
-	//input_report_abs(tpd->dev, ABS_PRESSURE, 0);
-	input_report_key(tpd->dev, BTN_TOUCH, 0);
-	//input_report_abs(tpd->dev, ABS_MT_TOUCH_MAJOR, 0);
-	//input_report_abs(tpd->dev, ABS_MT_POSITION_X, x);
-	//input_report_abs(tpd->dev, ABS_MT_POSITION_Y, y);
-	printk("U[%4d %4d %4d] ", x, y, 0);
-	input_mt_sync(tpd->dev);
-	TPD_EM_PRINT(x, y, x, y, 0, 0);
-#ifndef MT6572
-    if (FACTORY_BOOT == get_boot_mode()|| RECOVERY_BOOT == get_boot_mode())
-#endif
-    {   
-       tpd_button(x, y, 0); 
-    }   		 
-}
-
-static int tpd_touchinfo(struct touch_info *cinfo, struct touch_info *pinfo)
-{
-	int i = 0;
-//#if (TPD_MAX_POINTS==2)
-//	char data[35] = {0};
-//#else
-//	char data[16] = {0};
-//#endif	
-char data[128] = {0};
-    u16 high_byte,low_byte,reg;
-	u8 report_rate =0;
-
-	p_point_num = point_num;
-	if (tpd_halt)
-	{
-		TPD_DMESG( "tpd_touchinfo return ..\n");
-		return false;
-	}
-	mutex_lock(&i2c_access);
-
-
-    reg = 0x00;
-	fts_i2c_Read(i2c_client, &reg, 1, data, 64);
-	mutex_unlock(&i2c_access);
-	//TPD_DEBUG("received raw data from touch panel as following:\n");
-	//TPD_DEBUG("[data[0]=%x,data[1]= %x ,data[2]=%x ,data[3]=%x ,data[4]=%x ,data[5]=%x]\n",data[0],data[1],data[2],data[3],data[4],data[5]);
-	//TPD_DEBUG("[data[9]=%x,data[10]= %x ,data[11]=%x ,data[12]=%x]\n",data[9],data[10],data[11],data[12]);
-	//TPD_DEBUG("[data[15]=%x,data[16]= %x ,data[17]=%x ,data[18]=%x]\n",data[15],data[16],data[17],data[18]);
-   
-	/*get the number of the touch points*/
-	point_num= data[2] & 0x0f;
-	
-	//TPD_DEBUG("point_num =%d\n",point_num);
-		
-	for(i = 0; i < point_num; i++)  
-	{
-		cinfo->p[i] = data[3+6*i] >> 6; //event flag 
-     	cinfo->id[i] = data[3+6*i+2]>>4; //touch id
-	   	/*get the X coordinate, 2 bytes*/
-		high_byte = data[3+6*i];
-		high_byte <<= 8;
-		high_byte &= 0x0f00;
-		low_byte = data[3+6*i + 1];
-		cinfo->x[i] = high_byte |low_byte;
-		
-		//cinfo->x[i] =  cinfo->x[i] * 480 >> 11; //calibra
-	
-		/*get the Y coordinate, 2 bytes*/
-		
-		high_byte = data[3+6*i+2];
-		high_byte <<= 8;
-		high_byte &= 0x0f00;
-		low_byte = data[3+6*i+3];
-		cinfo->y[i] = high_byte |low_byte;
-
-		if (cinfo->y[i] <= TPD_Y_RES) 	//jeff add 20140820
-		{	
-			cinfo->x[i] = TPD_WARP_X(cinfo->x[i]);
-			cinfo->y[i] = TPD_WARP_Y(cinfo->y[i]);
-		}
-
-		 //cinfo->y[i]=  cinfo->y[i] * 800 >> 11;
-	}
-	TPD_DEBUG(" cinfo->x[0] = %d, cinfo->y[0] = %d, cinfo->p[0] = %d\n", cinfo->x[0], cinfo->y[0], cinfo->p[0]);	
-	//TPD_DEBUG(" cinfo->x[1] = %d, cinfo->y[1] = %d, cinfo->p[1] = %d\n", cinfo->x[1], cinfo->y[1], cinfo->p[1]);		
-	//TPD_DEBUG(" cinfo->x[2]= %d, cinfo->y[2]= %d, cinfo->p[2] = %d\n", cinfo->x[2], cinfo->y[2], cinfo->p[2]);	
-		  
-	return true;
-};
-
-#ifdef TPD_PROXIMITY
-int tpd_read_ps(void)
-{
-	tpd_proximity_detect;
-	return 0;    
-}
-
-static int tpd_get_ps_value(void)
-{
-	return tpd_proximity_detect;
-}
-
-static int tpd_enable_ps(int enable)
-{
-	u8 state;
-	int ret = -1;
-
-	i2c_smbus_read_i2c_block_data(i2c_client, 0xB0, 1, &state);
-	printk("[proxi_5206]read: 999 0xb0's value is 0x%02X\n", state);
-	if (enable){
-		state |= 0x01;
-		tpd_proximity_flag = 1;
-		TPD_PROXIMITY_DEBUG("[proxi_5206]ps function is on\n");	
-	}else{
-		state &= 0x00;	
-		tpd_proximity_flag = 0;
-		TPD_PROXIMITY_DEBUG("[proxi_5206]ps function is off\n");
-	}
-
-	ret = i2c_smbus_write_i2c_block_data(i2c_client, 0xB0, 1, &state);
-	TPD_PROXIMITY_DEBUG("[proxi_5206]write: 0xB0's value is 0x%02X\n", state);
-	return 0;
-}
-
-int tpd_ps_operate(void* self, uint32_t command, void* buff_in, int size_in,
-		void* buff_out, int size_out, int* actualout)
-{
-	int err = 0;
-	int value;
-	
-	hwm_sensor_data *sensor_data;
-	TPD_DEBUG("[proxi_5206]command = 0x%02X\n", command);		
-	switch (command)
-	{
-		case SENSOR_DELAY:
-			if((buff_in == NULL) || (size_in < sizeof(int)))
-			{
-				APS_ERR("Set delay parameter error!\n");
-				err = -EINVAL;
-			}
-			// Do nothing
-			break;
-
-		case SENSOR_ENABLE:
-			if((buff_in == NULL) || (size_in < sizeof(int)))
-			{
-				APS_ERR("Enable sensor parameter error!\n");
-				err = -EINVAL;
-			}
-			else
-			{				
-				value = *(int *)buff_in;
-				if(value)
-				{		
-					if((tpd_enable_ps(1) != 0))
-					{
-						APS_ERR("enable ps fail: %d\n", err); 
-						return -1;
-					}
-				}
-				else
-				{
-					if((tpd_enable_ps(0) != 0))
-					{
-						APS_ERR("disable ps fail: %d\n", err); 
-						return -1;
-					}
-				}
-			}
-			break;
-
-		case SENSOR_GET_DATA:
-			if((buff_out == NULL) || (size_out< sizeof(hwm_sensor_data)))
-			{
-				APS_ERR("get sensor data parameter error!\n");
-				err = -EINVAL;
-			}
-			else
-			{
-				
-				sensor_data = (hwm_sensor_data *)buff_out;				
-				
-				if((err = tpd_read_ps()))
-				{
-					err = -1;;
-				}
-				else
-				{
-					sensor_data->values[0] = tpd_get_ps_value();
-					TPD_PROXIMITY_DEBUG("huang sensor_data->values[0] 1082 = %d\n", sensor_data->values[0]);
-					sensor_data->value_divide = 1;
-					sensor_data->status = SENSOR_STATUS_ACCURACY_MEDIUM;
-				}	
-				
-			}
-			break;
-		default:
-			APS_ERR("proxmy sensor operate function no this parameter %d!\n", command);
-			err = -1;
-			break;
-	}
-	
-	return err;	
-}
-#endif
-
-#ifdef FTS_GESTRUE
-static void check_gesture(int gesture_id)
-{
-	
-    printk("kaka gesture_id==0x%x\n ",gesture_id);
-    
-	switch(gesture_id)
-	{
-		case GESTURE_LEFT:
-		      input_report_key(tpd->dev, KEY_LEFT, 1);
-			    input_sync(tpd->dev);
-			     input_report_key(tpd->dev, KEY_LEFT, 0);
-			    input_sync(tpd->dev);
-			break;
-		case GESTURE_RIGHT:
-		       input_report_key(tpd->dev, KEY_RIGHT, 1);
-			    input_sync(tpd->dev);
-			     input_report_key(tpd->dev, KEY_RIGHT, 0);
-			    input_sync(tpd->dev);
-			    
-			break;
-		case GESTURE_UP:
-			input_report_key(tpd->dev, KEY_UP, 1);
-			    input_sync(tpd->dev);
-			     input_report_key(tpd->dev, KEY_UP, 0);
-			    input_sync(tpd->dev);
-			    
-			break;
-		case GESTURE_DOWN:
-			input_report_key(tpd->dev, KEY_DOWN, 1);
-			    input_sync(tpd->dev);
-			     input_report_key(tpd->dev, KEY_DOWN, 0);
-			    input_sync(tpd->dev);
-			    
-			break;
-		case GESTURE_DOUBLECLICK:
-			input_report_key(tpd->dev, KEY_U, 1);
-			    input_sync(tpd->dev);
-			     input_report_key(tpd->dev, KEY_U, 0);
-			    input_sync(tpd->dev);
-			    
-			break;
-		case GESTURE_O:
-			input_report_key(tpd->dev, KEY_O, 1);
-			    input_sync(tpd->dev);
-			     input_report_key(tpd->dev, KEY_O, 0);
-			    input_sync(tpd->dev);
-			break;
-		case GESTURE_W:
-			input_report_key(tpd->dev, KEY_W, 1);
-			    input_sync(tpd->dev);
-			     input_report_key(tpd->dev, KEY_W, 0);
-			    input_sync(tpd->dev);
-			    
-			break;
-		case GESTURE_M:
-		input_report_key(tpd->dev, KEY_M, 1);
-			    input_sync(tpd->dev);
-			     input_report_key(tpd->dev, KEY_M, 0);
-			    input_sync(tpd->dev);
-			    
-			break;
-		case GESTURE_E:
-			input_report_key(tpd->dev, KEY_E, 1);
-			    input_sync(tpd->dev);
-			     input_report_key(tpd->dev, KEY_E, 0);
-			    input_sync(tpd->dev);
-			    
-			break;
-		case GESTURE_C:
-			input_report_key(tpd->dev, KEY_C, 1);
-			 input_sync(tpd->dev);
-			 input_report_key(tpd->dev, KEY_C, 0);
-			 input_sync(tpd->dev);
-			break;
-
-		case GESTURE_S:
-		input_report_key(tpd->dev, KEY_S, 1);
-		 input_sync(tpd->dev);
-		 input_report_key(tpd->dev, KEY_S, 0);
-		 input_sync(tpd->dev);
-		break;
-
-		case GESTURE_V:
-		input_report_key(tpd->dev, KEY_V, 1);
-		 input_sync(tpd->dev);
-		 input_report_key(tpd->dev, KEY_V, 0);
-		 input_sync(tpd->dev);
-		break;
-
-		case GESTURE_Z:
-		input_report_key(tpd->dev, KEY_Z, 1);
-		 input_sync(tpd->dev);
-		 input_report_key(tpd->dev, KEY_Z, 0);
-		 input_sync(tpd->dev);
-			break;
-		default:
-		
-			break;
-	}
-
-}
-
-static int ft5x0x_read_Touchdata(void)
-{
-    unsigned char buf[FTS_GESTRUE_POINTS * 4] = { 0 };
-    int ret = -1;
-    int i = 0;
-    buf[0] = 0xd3;
-    int gestrue_id = 0;
-    short pointnum = 0;
-    ret = fts_i2c_Read(i2c_client, buf, 1, buf, FTS_GESTRUE_POINTS_HEADER);
-    if (ret < 0)
-    {
-        printk( "%s read touchdata failed.\n", __func__);
-        return ret;
-    }
-    /* FW ????3??? */
-    if (0x24 == buf[0])
-    {
-        gestrue_id = 0x24;
-        check_gesture(gestrue_id);
-        return -1;
-    }
-
-    pointnum = (short)(buf[1]) & 0xff;
-    buf[0] = 0xd3;
-
-    ret = fts_i2c_Read(i2c_client, buf, 1, buf, (pointnum * 4 + 2));
-    if (ret < 0)
-    {
-        printk( "%s read touchdata failed.\n", __func__);
-        return ret;
-    }
-
-   gestrue_id = fetch_object_sample(buf, pointnum);
-   
-    for(i = 0;i < pointnum;i++)
-    {
-        coordinate_x[i] =  (((s16) buf[0 + (4 * i)]) & 0x0F) <<
-            8 | (((s16) buf[1 + (4 * i)])& 0xFF);
-        coordinate_y[i] = (((s16) buf[2 + (4 * i)]) & 0x0F) <<
-            8 | (((s16) buf[3 + (4 * i)]) & 0xFF);
-    }
-	check_gesture(gestrue_id);
-    return -1;
-}
-#endif
- static int touch_event_handler(void *unused)
- { 
-   	struct touch_info cinfo, pinfo;
-	int i=0;
-
-	struct sched_param param = { .sched_priority = RTPM_PRIO_TPD };
-	sched_setscheduler(current, SCHED_RR, &param);
-
-#ifdef TPD_PROXIMITY
-	int err;
-	hwm_sensor_data sensor_data;
-	u8 proximity_status;
-	
-#endif
-   u8 state;
-   
-	do
-	{
-		mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM); 
-		set_current_state(TASK_INTERRUPTIBLE); 
-		wait_event_interruptible(waiter,tpd_flag!=0);
-						 
-		tpd_flag = 0;
-			 
-		set_current_state(TASK_RUNNING);
-#ifdef FTS_GESTRUE
-i2c_smbus_read_i2c_block_data(i2c_client, 0xd0, 1, &state);
-// if((get_suspend_state() == PM_SUSPEND_MEM) && (state ==1))
- if(state ==1)
-     {
-        ft5x0x_read_Touchdata();
-        continue;
-    }
-#endif
-
-#ifdef TPD_PROXIMITY
-		if (tpd_proximity_flag == 1)
-		{
-			i2c_smbus_read_i2c_block_data(i2c_client, 0xB0, 1, &state);
-			TPD_PROXIMITY_DEBUG("proxi_5206 0xB0 state value is 1131 0x%02X\n", state);
-
-			if(!(state&0x01))
-			{
-				tpd_enable_ps(1);
-			}
-
-			i2c_smbus_read_i2c_block_data(i2c_client, 0x01, 1, &proximity_status);
-			TPD_PROXIMITY_DEBUG("proxi_5206 0x01 value is 1139 0x%02X\n", proximity_status);
-			
-			if (proximity_status == 0xC0)
-			{
-				tpd_proximity_detect = 0;	
-			}
-			else if(proximity_status == 0xE0)
-			{
-				tpd_proximity_detect = 1;
-			}
-
-			TPD_PROXIMITY_DEBUG("tpd_proximity_detect 1149 = %d\n", tpd_proximity_detect);
-
-			if ((err = tpd_read_ps()))
-			{
-				TPD_PROXIMITY_DMESG("proxi_5206 read ps data 1156: %d\n", err);	
-			}
-			sensor_data.values[0] = tpd_get_ps_value();
-			sensor_data.value_divide = 1;
-			sensor_data.status = SENSOR_STATUS_ACCURACY_MEDIUM;
-			if ((err = hwmsen_get_interrupt_data(ID_PROXIMITY, &sensor_data)))
-			{
-				TPD_PROXIMITY_DMESG(" proxi_5206 call hwmsen_get_interrupt_data failed= %d\n", err);	
-			}
-		}  
-#endif
-		 
-		if (tpd_touchinfo(&cinfo, &pinfo)) 
-		{
-		    //TPD_DEBUG("point_num = %d\n",point_num);
-			TPD_DEBUG_SET_TIME;
-			if(point_num >0) 
-			{
-			    for(i =0; i<point_num; i++)//only support 3 point
-			    {
-			         tpd_down(cinfo.x[i], cinfo.y[i], cinfo.id[i]);
-			    }
-			    input_sync(tpd->dev);
-			}
-			else  
-    		{
-			    tpd_up(cinfo.x[0], cinfo.y[0]);
-        	    //TPD_DEBUG("release --->\n"); 
-        	    //input_mt_sync(tpd->dev);
-        	    input_sync(tpd->dev);
-        		}
-        	}
-
-        	if(tpd_mode==12)
-        	{
-           //power down for desence debug
-           //power off, need confirm with SA
-#ifdef TPD_POWER_SOURCE_CUSTOM
-			hwPowerDown(TPD_POWER_SOURCE_CUSTOM, "TP");
-#else
-			hwPowerDown(MT65XX_POWER_LDO_VGP2, "TP");
-#endif
-#ifdef TPD_POWER_SOURCE_1800
-			hwPowerDown(TPD_POWER_SOURCE_1800, "TP");
-#endif 
-    		msleep(20);
-    	}
- 	}while(!kthread_should_stop());
- 
-	return 0;
-}
- 
-static int tpd_detect (struct i2c_client *client, struct i2c_board_info *info) 
-{
-	strcpy(info->type, TPD_DEVICE);	
-	return 0;
-}
- 
-static void tpd_eint_interrupt_handler(void)
-{
-	//TPD_DEBUG("TPD interrupt has been triggered\n");
-	TPD_DEBUG_PRINT_INT;
-	tpd_flag = 1;
-	wake_up_interruptible(&waiter);
-}
-
-void focaltech_get_upgrade_array(void)
-{
-
-	u8 chip_id;
-	u32 i;
-
-	i2c_smbus_read_i2c_block_data(i2c_client,FT_REG_CHIP_ID,1,&chip_id);
-
-	printk("%s chip_id = %x\n", __func__, chip_id);
-
-	for(i=0;i<sizeof(fts_updateinfo)/sizeof(struct Upgrade_Info);i++)
-	{
-		if(chip_id==fts_updateinfo[i].CHIP_ID)
-		{
-			memcpy(&fts_updateinfo_curr, &fts_updateinfo[i], sizeof(struct Upgrade_Info));
-			break;
-		}
-	}
-
-	if(i >= sizeof(fts_updateinfo)/sizeof(struct Upgrade_Info))
-	{
-		memcpy(&fts_updateinfo_curr, &fts_updateinfo[0], sizeof(struct Upgrade_Info));
-	}
-}
-
-static int tpd_probe(struct i2c_client *client, const struct i2c_device_id *id)
-{	 
-	int retval = TPD_OK;
-	char data;
-	u8 report_rate=0;
-	int err=0;
-	int reset_count = 0;
-	u8 chip_id,i;
-
-reset_proc:   
-	i2c_client = client;
-//add at 20150330 by zhu
-#if 1//def MAIERXUN_TP_COM
-    if(touchpanel_flag){
-	return 0;
-     }
-#endif
-//add at 20150330 by zhu end   
-	//power on, need confirm with SA
-       mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-       mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-       mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ZERO);  
-	msleep(5);
-	TPD_DMESG(" fts ic reset\n");
-	
-#ifdef TPD_POWER_SOURCE_CUSTOM
-	hwPowerOn(TPD_POWER_SOURCE_CUSTOM, VOL_2800, "TP");
-#else
-	hwPowerOn(MT65XX_POWER_LDO_VGP2, VOL_2800, "TP");
-#endif
-
-#if 0 //def TPD_POWER_SOURCE_1800
-	hwPowerOn(TPD_POWER_SOURCE_1800, VOL_1800, "TP");
-#endif 
-	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-       mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-       mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ONE);
-    
-#ifdef TPD_CLOSE_POWER_IN_SLEEP	 
-	hwPowerDown(TPD_POWER_SOURCE,"TP");
-	hwPowerOn(TPD_POWER_SOURCE,VOL_3300,"TP");
-	msleep(100);
-
-#else
-       mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-       mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-       mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ZERO);  
-	msleep(5);
-	TPD_DMESG(" fts ic reset\n");
-	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-       mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-       mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ONE);
-#endif
-
-	mt_set_gpio_mode(GPIO_CTP_EINT_PIN, GPIO_CTP_EINT_PIN_M_EINT);
-       mt_set_gpio_dir(GPIO_CTP_EINT_PIN, GPIO_DIR_IN);
-       mt_set_gpio_pull_enable(GPIO_CTP_EINT_PIN, GPIO_PULL_ENABLE);
-       mt_set_gpio_pull_select(GPIO_CTP_EINT_PIN, GPIO_PULL_UP);
- 
-//	mt65xx_eint_set_sens(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_SENSITIVE);
-	mt_eint_set_hw_debounce(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_DEBOUNCE_CN);
-//	mt65xx_eint_registration(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_DEBOUNCE_EN, CUST_EINT_TOUCH_PANEL_POLARITY, tpd_eint_interrupt_handler, 1); 
-	mt_eint_registration(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_TYPE, tpd_eint_interrupt_handler, 1); 
-	mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
- 
-	msleep(400);
- 
-	//if((i2c_smbus_read_i2c_block_data(i2c_client, 0x00, 1, &data))< 0)
- ///////////////////////////////////////////////
-	err=i2c_smbus_read_i2c_block_data(i2c_client, 0x00, 1, &data);
-
-	TPD_DMESG("gao_i2c:err %d,data:%d\n", err,data);
-	if(err< 0 || data!=0)// reg0 data running state is 0; other state is not 0
-	{
-		TPD_DMESG("I2C transfer error, line: %d\n", __LINE__);
-#ifdef TPD_RESET_ISSUE_WORKAROUND
-        if ( reset_count < TPD_MAX_RESET_COUNT )
-        {
-            reset_count++;
-            goto reset_proc;
-        }
-#endif
-//add at 20150330 by zhu
-#if 1//def MAIERXUN_TP_COM
-	    touchpanel_flag=false;
-#endif
-//add at 20150330 by zhu end
-		   return -1; 
-	}
-
-	tpd_load_status = 1;
- //   tpd_mstar_status =0 ;  // compatible mstar and ft6306 chenzhecong
- 
-        focaltech_get_upgrade_array();
-
-	#ifdef FTS_APK_DEBUG
-	ft5x0x_create_apk_debug_channel(client);
-        #endif
-	#ifdef TPD_SYSFS_DEBUG
-	fts_create_sysfs(i2c_client);
-	#endif
-
-	#ifdef FTS_CTL_IIC
-	if (ft_rw_iic_drv_init(i2c_client) < 0)
-		printk("eroor\n");
-		//TPD_DMESG(TPD_DEVICE, "%s:[FTS] create fts control iic driver failed\n",__func__);
-	#endif
-
-	#ifdef FTS_GESTRUE
-	init_para(1080,1920,60,0,0);
-    //fts_write_reg(i2c_client, 0xd0, 0x01);
-        #endif
-	
-	#ifdef VELOCITY_CUSTOM_FT5206
-	if((err = misc_register(&tpd_misc_device)))
-	{
-		printk("mtk_tpd: tpd_misc_device register failed\n");
-		
-	}
-	#endif
-
-	#ifdef TPD_AUTO_UPGRADE
-	printk("********************Enter CTP Auto Upgrade********************\n");
-	fts_ctpm_auto_upgrade(i2c_client);
-	#endif
-	thread = kthread_run(touch_event_handler, 0, TPD_DEVICE);
-	if (IS_ERR(thread))
-	{ 
-		retval = PTR_ERR(thread);
-		TPD_DMESG(" failed to create kernel thread: %d\n", retval);
-	}
-
-	TPD_DMESG("FTS Touch Panel Device Probe %s\n", (retval < TPD_OK) ? "FAIL" : "PASS");
-
-#ifdef TPD_PROXIMITY
-	struct hwmsen_object obj_ps;
-	
-	obj_ps.polling = 0;//interrupt mode
-	obj_ps.sensor_operate = tpd_ps_operate;
-	if((err = hwmsen_attach(ID_PROXIMITY, &obj_ps)))
-	{
-		APS_ERR("proxi_fts attach fail = %d\n", err);
-	}
-	else
-	{
-		APS_ERR("proxi_fts attach ok = %d\n", err);
-	}		
-#endif
-//add at 20150330 by zhu
-#if 1//def MAIERXUN_TP_COM
-    touchpanel_flag=true;
-#endif
-//add at 20150330 by zhu end
-   return 0;
-   
- }
-
- static int tpd_remove(struct i2c_client *client)
-{
-
-        #ifdef FTS_APK_DEBUG
-	ft5x0x_release_apk_debug_channel();
-	#endif
-   	#ifdef TPD_SYSFS_DEBUG
-	fts_release_sysfs(client);
-	#endif
-
-	#ifdef FTS_CTL_IIC
-	ft_rw_iic_drv_exit();
-	#endif
-	
-	TPD_DEBUG("TPD removed\n");
- 
-   	return 0;
-}
- 
-static int tpd_local_init(void)
-{
-  	TPD_DMESG("FTS I2C Touchscreen Driver (Built %s @ %s)\n", __DATE__, __TIME__);
- 
-   	if(i2c_add_driver(&tpd_i2c_driver)!=0)
-   	{
-  		TPD_DMESG("FTS unable to add i2c driver.\n");
-      	return -1;
-    }
-    if(tpd_load_status == 0) 
-    {
-    	TPD_DMESG("FTS add error touch panel driver.\n");
-    	i2c_del_driver(&tpd_i2c_driver);
-    	return -1;
-    }
-	
-#ifdef TPD_HAVE_BUTTON     
-	//if(TPD_RES_Y > 854)
-	{
-	    tpd_button_setting(TPD_KEY_COUNT, tpd_keys_local, tpd_keys_dim_local);// initialize tpd button data
-	}
-	//else
-	{
-	    //tpd_button_setting(TPD_KEY_COUNT, tpd_keys_local, tpd_keys_dim_local_fwvga);// initialize tpd button data
-	}
-#endif   
-  
-#if (defined(TPD_WARP_START) && defined(TPD_WARP_END))    
-    TPD_DO_WARP = 1;
-    memcpy(tpd_wb_start, tpd_wb_start_local, TPD_WARP_CNT*4);
-    memcpy(tpd_wb_end, tpd_wb_start_local, TPD_WARP_CNT*4);
-#endif 
-
-#if (defined(TPD_HAVE_CALIBRATION) && !defined(TPD_CUSTOM_CALIBRATION))
-    memcpy(tpd_calmat, tpd_def_calmat_local, 8*4);
-    memcpy(tpd_def_calmat, tpd_def_calmat_local, 8*4);	
-#endif  
-    TPD_DMESG("end %s, %d\n", __FUNCTION__, __LINE__);  
-    tpd_type_cap = 1;
-    return 0; 
- }
-
- static void tpd_resume( struct early_suspend *h )
- {
-  //int retval = TPD_OK;
-  //char data;
-#ifdef TPD_PROXIMITY	
-	if (tpd_proximity_flag == 1)
-	{
-		if(tpd_proximity_flag_one == 1)
-		{
-			tpd_proximity_flag_one = 0;	
-			TPD_DMESG(" tpd_proximity_flag_one \n"); 
-			return;
-		}
-	}
-#endif	
- 
-   	TPD_DMESG("TPD wake up\n");
-
- #ifdef FTS_GESTRUE
-            fts_write_reg(i2c_client,0xD0,0x00);
-	    fts_write_reg(i2c_client,0xD1,0x00);
-	    fts_write_reg(i2c_client,0xD2,0x00);
-	   // return;
-#endif
-            #ifdef TPD_CLOSE_POWER_IN_SLEEP	
-        	hwPowerOn(TPD_POWER_SOURCE,VOL_3300,"TP");
-
-#else
-
-	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-    mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-    mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ZERO);  
-    msleep(2);  
-   // mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-   // mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-    mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ONE);
-#endif
-	mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);  
-	msleep(30);
-	tpd_halt = 0;
-	/* for resume debug
-	if((i2c_smbus_read_i2c_block_data(i2c_client, 0x00, 1, &data))< 0)
-	{
-		TPD_DMESG("resume I2C transfer error, line: %d\n", __LINE__);
-	}
-	*/
-	tpd_up(0,0);
-	input_sync(tpd->dev);
-	TPD_DMESG("TPD wake up done\n");
-	 //return retval;
- }
-
- static void tpd_suspend( struct early_suspend *h )
- {
-	// int retval = TPD_OK;
-	 static char data = 0x3;
-
-#ifdef TPD_PROXIMITY
-	if (tpd_proximity_flag == 1)
-	{
-		tpd_proximity_flag_one = 1;	
-		return;
-	}
-#endif
-#ifdef FTS_GESTRUE
-         fts_write_reg(i2c_client, 0xd0, 0x01);
-        fts_write_reg(i2c_client, 0xd1, 0x1f);
-        fts_write_reg(i2c_client, 0xd2, 0x1f);
-        return;
-#endif
-     	 tpd_halt = 1;
-
-	 TPD_DMESG("TPD enter sleep\n");
-	 mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
-#ifdef TPD_CLOSE_POWER_IN_SLEEP	
-	hwPowerDown(TPD_POWER_SOURCE,"TP");
-#else
-	mutex_lock(&i2c_access);
-	i2c_smbus_write_i2c_block_data(i2c_client, 0xA5, 1, &data);  //TP enter sleep mode
-	mutex_unlock(&i2c_access);
-#endif
-	TPD_DMESG("TPD enter sleep done\n");
-	//return retval;
- } 
-
-
- static struct tpd_driver_t tpd_device_driver = {
-	.tpd_device_name = TPD_NAME,
-	.tpd_local_init = tpd_local_init,
-	.suspend = tpd_suspend,
-	.resume = tpd_resume,
-#ifdef TPD_HAVE_BUTTON
-	.tpd_have_button = 1,
-#else
-	.tpd_have_button = 0,
-#endif		
- };
- /* called when loaded into kernel */
-static int __init tpd_driver_init(void) {
-	printk("MediaTek FTS touch panel driver init\n");
-	i2c_register_board_info(IIC_PORT, &ft5206_i2c_tpd, 1);
-	if(tpd_driver_add(&tpd_device_driver) < 0)
-		TPD_DMESG("add FTS driver failed\n");
-	 return 0;
- }
- 
- /* should never be called */
-static void __exit tpd_driver_exit(void) {
-	TPD_DMESG("MediaTek FTS touch panel driver exit\n");
-	//input_unregister_device(tpd->dev);
-	tpd_driver_remove(&tpd_device_driver);
-}
- 
-module_init(tpd_driver_init);
-module_exit(tpd_driver_exit);
-
-
diff --git a/drivers/input/touchscreen/mediatek/focaltech_hd/focaltech_ex_fun.c~ b/drivers/input/touchscreen/mediatek/focaltech_hd/focaltech_ex_fun.c~
deleted file mode 100755
index 9e84698..0000000
--- a/drivers/input/touchscreen/mediatek/focaltech_hd/focaltech_ex_fun.c~
+++ /dev/null
@@ -1,1349 +0,0 @@
-/*
- *drivers/input/touchscreen/ft5x06_ex_fun.c
- *
- *FocalTech IC driver expand function for debug.
- *
- *Copyright (c) 2010  Focal tech Ltd.
- *
- *This software is licensed under the terms of the GNU General Public
- *License version 2, as published by the Free Software Foundation, and
- *may be copied, distributed, and modified under those terms.
- *
- *This program is distributed in the hope that it will be useful,
- *but WITHOUT ANY WARRANTY; without even the implied warranty of
- *MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *GNU General Public License for more details.
- *
- *Note:the error code of EIO is the general error in this file.
- */
-
-#include "tpd.h"
-
-#include "tpd_custom_fts.h"
-
-#include "focaltech_ex_fun.h"
-
-#include <linux/netdevice.h>
-#include <linux/mount.h>
-//#include <linux/netdevice.h>
-#include <linux/proc_fs.h>
-
-
-extern void mt_eint_unmask(unsigned int line);
-extern void mt_eint_mask(unsigned int line);
-
-u8 *I2CDMABuf_va = NULL;
-//volatile u32 I2CDMABuf_pa = NULL;
-volatile char I2CDMABuf_pa = NULL;
-extern struct Upgrade_Info fts_updateinfo_curr;
-
-struct i2c_client * wxt_client;
-int fts_ctpm_fw_upgrade(struct i2c_client *client, u8 *pbt_buf,
-			  u32 dw_lenth);
-
-//#include "ft_app.i"
-//#include "SHT047584_B82L_DGW_20141021_app.i"   //jeff modify 20141101
-static unsigned char CTPM_FW[] = {
-	#include "SHT047584_B25L_DGW_720_1280_20141020_app.i"
-};
-
-static DEFINE_MUTEX(g_device_mutex);
-
-/*
-*fts_i2c_Read-read data and write data by i2c
-*@client: handle of i2c
-*@writebuf: Data that will be written to the slave
-*@writelen: How many bytes to write
-*@readbuf: Where to store data read from slave
-*@readlen: How many bytes to read
-*
-*Returns negative errno, else the number of messages executed
-*
-*
-*/
-int fts_i2c_Read(struct i2c_client *client, char *writebuf,
-		    int writelen, char *readbuf, int readlen)
-{
-	int ret,i;
-	
-#if 0//for normal I2c transfer
-	if (writelen > 0) {
-		struct i2c_msg msgs[] = {
-			{
-			 .addr = client->addr,
-			 .flags = 0,
-			 .len = writelen,
-			 .buf = writebuf,
-			 },
-			{
-			 .addr = client->addr,
-			 .flags = I2C_M_RD,
-			 .len = readlen,
-			 .buf = readbuf,
-			 },
-		};
-		ret = i2c_transfer(client->adapter, msgs, 2);
-		if (ret < 0)
-			dev_err(&client->dev, "f%s: i2c read error.\n",
-				__func__);
-	} else {
-		struct i2c_msg msgs[] = {
-			{
-			 .addr = client->addr,
-			 .flags = I2C_M_RD,
-			 .len = readlen,
-			 .buf = readbuf,
-			 },
-		};
-		ret = i2c_transfer(client->adapter, msgs, 1);
-		if (ret < 0)
-			dev_err(&client->dev, "%s:i2c read error.\n", __func__);
-	}
-#else// for DMA I2c transfer
-	if(writelen!=0)
-	{
-		//DMA Write
-		if(0)//if(writelen < 8  )
-		{
-			
-			//MSE_ERR("Sensor non-dma write timing is %x!\r\n", this_client->timing);
-			ret= i2c_master_send(client, writebuf, writelen);
-		}
-		else
-		{
-			for(i = 0 ; i < writelen; i++)
-			{
-				I2CDMABuf_va[i] = writebuf[i];
-			}
-
-			client->addr = client->addr & I2C_MASK_FLAG | I2C_DMA_FLAG;
-		
-			if((ret=i2c_master_send(client, (unsigned char *)I2CDMABuf_pa, writelen))!=writelen)
-				printk("error\n");
-				//dev_err(&client->dev, "###%s i2c write len=%d,buffaddr=%d\n", __func__,ret,I2CDMABuf_pa);
-			//MSE_ERR("Sensor dma timing is %x!\r\n", this_client->timing);
-			//return ret;
-			client->addr = client->addr & I2C_MASK_FLAG &(~ I2C_DMA_FLAG);
-
-		}
-	}
-	//DMA Read 
-	if(readlen!=0)
-	{
-		if(0)//if (readlen <8) {
-		{
-			ret = i2c_master_recv(client, (unsigned char *)readbuf, readlen);
-		}
-		else
-		{
-
-			client->addr = client->addr & I2C_MASK_FLAG | I2C_DMA_FLAG;
-			ret = i2c_master_recv(client, (unsigned char *)I2CDMABuf_pa, readlen);
-
-			for(i = 0; i < readlen; i++)
-	        {
-	            readbuf[i] = I2CDMABuf_va[i];
-	        }
-		client->addr = client->addr & I2C_MASK_FLAG &(~ I2C_DMA_FLAG);
-
-		}
-	}
-	#endif
-	return ret;
-}
-/*write data by i2c*/
-
-int fts_i2c_Write(struct i2c_client *client, char *writebuf, int writelen)
-{
-	int ret;
-	int i = 0;
-	//printk("fts_i2c_Write  %d  %x  %x %x %x",writelen,writebuf,I2CDMABuf_va,I2CDMABuf_pa,client);
-	
-   client->addr = client->addr & I2C_MASK_FLAG;
-  // client->ext_flag |= I2C_DIRECTION_FLAG; 
-  // client->timing = 100;
-    #if 0
-	struct i2c_msg msg[] = {
-		{
-		 .addr = client->addr,
-		 .flags = 0,
-		 .len = writelen,
-		 .buf = writebuf,
-		 },
-	};
-
-	ret = i2c_transfer(client->adapter, msg, 1);
-	if (ret < 0)
-		dev_err(&client->dev, "%s i2c write error.\n", __func__);
-	#else
-	
-	if(0)//if(writelen < 8)
-	{
-		
-		//MSE_ERR("Sensor non-dma write timing is %x!\r\n", this_client->timing);
-		ret = i2c_master_send(client, writebuf, writelen);
-	}
-	else
-	{
-		for(i = 0 ; i < writelen; i++)
-		{
-			I2CDMABuf_va[i] = writebuf[i];
-		}
-
-		client->addr = client->addr & I2C_MASK_FLAG | I2C_DMA_FLAG;
-
-		if((ret=i2c_master_send(client, (unsigned char *)I2CDMABuf_pa, writelen))!=writelen)
-			//dev_err(&client->dev, "###%s i2c write len=%d,buffaddr=%d\n", __func__,ret,I2CDMABuf_pa);
-			printk("error\n");
-		//MSE_ERR("Sensor dma timing is %x!\r\n", this_client->timing);
-		client->addr = client->addr & I2C_MASK_FLAG &(~ I2C_DMA_FLAG);
-
-	} 
-	#endif
-	return ret;
-
-}
-
-int fts_write_reg(struct i2c_client *client, u8 regaddr, u8 regvalue)
-{
-	unsigned char buf[2] = {0};
-	buf[0] = regaddr;
-	buf[1] = regvalue;
-
-	return fts_i2c_Write(client, buf, sizeof(buf));
-}
-
-
-int fts_read_reg(struct i2c_client *client, u8 regaddr, u8 *regvalue)
-{
-	return fts_i2c_Read(client, &regaddr, 1, regvalue, 1);
-}
-
-int fts_ctpm_auto_clb(struct i2c_client *client)
-{
-	unsigned char uc_temp = 0x00;
-	unsigned char i = 0;
-
-	/*start auto CLB */
-	msleep(200);
-
-	fts_write_reg(client, 0, FTS_FACTORYMODE_VALUE);
-	/*make sure already enter factory mode */
-	msleep(100);
-	/*write command to start calibration */
-	fts_write_reg(client, 2, 0x4);
-	msleep(300);
-	if ((fts_updateinfo_curr.CHIP_ID==0x11) ||(fts_updateinfo_curr.CHIP_ID==0x12) ||(fts_updateinfo_curr.CHIP_ID==0x13) ||(fts_updateinfo_curr.CHIP_ID==0x14)) //5x36,5x36i
-	{
-		for(i=0;i<100;i++)
-		{
-			fts_read_reg(client, 0x02, &uc_temp);
-			if (0x02 == uc_temp ||
-				0xFF == uc_temp)
-			{
-				/*if 0x02, then auto clb ok, else 0xff, auto clb failure*/
-			    break;
-			}
-			msleep(20);	    
-		}
-	} else {
-		for(i=0;i<100;i++)
-		{
-				fts_read_reg(client, 0, &uc_temp);
-			if (0x0 == ((uc_temp&0x70)>>4))  /*return to normal mode, calibration finish*/
-			{
-			    break;
-			}
-			msleep(20);	    
-		}
-	}
-	/*calibration OK*/
-	fts_write_reg(client, 0, 0x40);  /*goto factory mode for store*/
-	msleep(200);   /*make sure already enter factory mode*/
-	fts_write_reg(client, 2, 0x5);  /*store CLB result*/
-	msleep(300);
-	fts_write_reg(client, 0, FTS_WORKMODE_VALUE);	/*return to normal mode */
-	msleep(300);
-
-	/*store CLB result OK */
-	return 0;
-}
-
-
-/*
-upgrade with *.i file
-*/
-int fts_ctpm_fw_upgrade_with_i_file(struct i2c_client *client)
-{
-	u8 *pbt_buf = NULL;
-	int i_ret;
-	int fw_len = sizeof(CTPM_FW);
-
-	/*judge the fw that will be upgraded
-	* if illegal, then stop upgrade and return.
-	*/
-	if (fw_len < 8 || fw_len > 32 * 1024) {
-		dev_err(&client->dev, "%s:FW length error\n", __func__);
-		return -EIO;
-	}
-
-	if (((CTPM_FW[fw_len - 8] ^ CTPM_FW[fw_len - 6]) == 0xFF
-		&& (CTPM_FW[fw_len - 7] ^ CTPM_FW[fw_len - 5]) == 0xFF
-		&& (CTPM_FW[fw_len - 3] ^ CTPM_FW[fw_len - 4]) == 0xFF)
-		||((CTPM_FW[0x104] ^ CTPM_FW[0x105]) == 0xFF
-		&& (CTPM_FW[0x106] ^ CTPM_FW[0x107]) == 0xFF))
-		{
-		/*FW upgrade */
-		pbt_buf = CTPM_FW;
-		/*call the upgrade function */
-		i_ret = fts_ctpm_fw_upgrade(client, pbt_buf, sizeof(CTPM_FW));
-		if (i_ret != 0)
-			dev_err(&client->dev, "%s:upgrade failed. err.\n",
-					__func__);
-		else if(fts_updateinfo_curr.AUTO_CLB==AUTO_CLB_NEED)
-			fts_ctpm_auto_clb(client);	/*start auto CLB */
-
-	} else {
-		dev_err(&client->dev, "%s:FW format error\n", __func__);
-		return -EBADFD;
-	}
-
-	return i_ret;
-}
-
-u8 fts_ctpm_get_i_file_ver(void)
-{
-	u16 ui_sz;
-	ui_sz = sizeof(CTPM_FW);
-	if (ui_sz > 2)
-	{
-	    if(fts_updateinfo_curr.CHIP_ID==0x36)
-                return CTPM_FW[0x10a];
-	    else
-		return CTPM_FW[ui_sz - 2];
-
-	}
-
-	return 0x00;	/*default value */
-}
-
-u8 fts_ctpm_get_i_file_vendor(void)
-{
-	u16 ui_sz;
-	ui_sz = sizeof(CTPM_FW);
-	if (ui_sz > 1)
-	{
-	    if(fts_updateinfo_curr.CHIP_ID==0x36)
-                return CTPM_FW[0x108];
-	    else
-		return CTPM_FW[ui_sz - 1];
-
-	}
-
-	return 0x00;	/*default value */
-}
-
-/*update project setting
-*only update these settings for COB project, or for some special case
-*/
-int fts_ctpm_update_project_setting(struct i2c_client *client)
-{
-	u8 uc_i2c_addr;	/*I2C slave address (7 bit address)*/
-	u8 uc_io_voltage;	/*IO Voltage 0---3.3v;	1----1.8v*/
-	u8 uc_panel_factory_id;	/*TP panel factory ID*/
-	u8 buf[FTS_SETTING_BUF_LEN];
-	u8 reg_val[2] = {0};
-	u8 auc_i2c_write_buf[10] = {0};
-	u8 packet_buf[FTS_SETTING_BUF_LEN + 6];
-	u32 i = 0;
-	int i_ret;
-
-	uc_i2c_addr = client->addr;
-	uc_io_voltage = 0x0;
-	uc_panel_factory_id = 0x5a;
-
-
-	/*Step 1:Reset  CTPM
-	*write 0xaa to register 0xfc
-	*/
-	fts_write_reg(client, 0xfc, 0xaa);
-	msleep(50);
-
-	/*write 0x55 to register 0xfc */
-	fts_write_reg(client, 0xfc, 0x55);
-	msleep(30);
-
-	/*********Step 2:Enter upgrade mode *****/
-	auc_i2c_write_buf[0] = 0x55;
-	auc_i2c_write_buf[1] = 0xaa;
-	do {
-		i++;
-		i_ret = fts_i2c_Write(client, auc_i2c_write_buf, 2);
-		msleep(5);
-	} while (i_ret <= 0 && i < 5);
-
-
-	/*********Step 3:check READ-ID***********************/
-	auc_i2c_write_buf[0] = 0x90;
-	auc_i2c_write_buf[1] = auc_i2c_write_buf[2] = auc_i2c_write_buf[3] =
-			0x00;
-
-	fts_i2c_Read(client, auc_i2c_write_buf, 4, reg_val, 2);
-
-	if (reg_val[0] == 0x79 && reg_val[1] == 0x3)
-		dev_dbg(&client->dev, "[FTS] Step 3: CTPM ID,ID1 = 0x%x,ID2 = 0x%x\n",
-			 reg_val[0], reg_val[1]);
-	else
-		return -EIO;
-
-	auc_i2c_write_buf[0] = 0xcd;
-	fts_i2c_Read(client, auc_i2c_write_buf, 1, reg_val, 1);
-	dev_dbg(&client->dev, "bootloader version = 0x%x\n", reg_val[0]);
-
-	/*--------- read current project setting  ---------- */
-	/*set read start address */
-	buf[0] = 0x3;
-	buf[1] = 0x0;
-	buf[2] = 0x78;
-	buf[3] = 0x0;
-
-	fts_i2c_Read(client, buf, 4, buf, FTS_SETTING_BUF_LEN);
-	dev_dbg(&client->dev, "[FTS] old setting: uc_i2c_addr = 0x%x,\
-			uc_io_voltage = %d, uc_panel_factory_id = 0x%x\n",
-			buf[0], buf[2], buf[4]);
-
-	 /*--------- Step 4:erase project setting --------------*/
-	auc_i2c_write_buf[0] = 0x63;
-	fts_i2c_Write(client, auc_i2c_write_buf, 1);
-	msleep(100);
-
-	/*----------  Set new settings ---------------*/
-	buf[0] = uc_i2c_addr;
-	buf[1] = ~uc_i2c_addr;
-	buf[2] = uc_io_voltage;
-	buf[3] = ~uc_io_voltage;
-	buf[4] = uc_panel_factory_id;
-	buf[5] = ~uc_panel_factory_id;
-	packet_buf[0] = 0xbf;
-	packet_buf[1] = 0x00;
-	packet_buf[2] = 0x78;
-	packet_buf[3] = 0x0;
-	packet_buf[4] = 0;
-	packet_buf[5] = FTS_SETTING_BUF_LEN;
-
-	for (i = 0; i < FTS_SETTING_BUF_LEN; i++)
-		packet_buf[6 + i] = buf[i];
-
-	fts_i2c_Write(client, packet_buf, FTS_SETTING_BUF_LEN + 6);
-	msleep(100);
-
-	/********* reset the new FW***********************/
-	auc_i2c_write_buf[0] = 0x07;
-	fts_i2c_Write(client, auc_i2c_write_buf, 1);
-
-	msleep(200);
-	return 0;
-}
-
-int fts_ctpm_auto_upgrade(struct i2c_client *client)
-{
-	u8 uc_host_fm_ver = FT_REG_FW_VER;
-	u8 uc_tp_fm_ver;
-	u8 uc_host_vendor_id = FT_REG_VENDOR_ID;
-	u8 uc_tp_vendor_id;
-	int i_ret;
-
-        fts_read_reg(client, FT_REG_VENDOR_ID, &uc_tp_vendor_id);
-	uc_host_vendor_id = fts_ctpm_get_i_file_vendor();
-	if(uc_tp_vendor_id!=uc_host_vendor_id)return 0;
-	
-	fts_read_reg(client, FT_REG_FW_VER, &uc_tp_fm_ver);
-	uc_host_fm_ver = fts_ctpm_get_i_file_ver();
-
-      // printk("[FTS] uc_tp_fm_ver = 0x%x, uc_host_fm_ver = 0x%x\n",uc_tp_fm_ver, uc_host_fm_ver);
-	   
-	if (/* if tp_fm_ver > 0x80, then, the tp's fm is QHD config, so it must be upgraded for HD. jeff add 20141101*/
-		uc_tp_fm_ver > 0x80 ||
-		/*the firmware in touch panel maybe corrupted */
-		uc_tp_fm_ver == FT_REG_FW_VER ||
-		/*the firmware in host flash is new, need upgrade */
-	     uc_tp_fm_ver < uc_host_fm_ver
-	    ) {
-		msleep(100);
-		//dev_dbg(&client->dev, "[FTS] uc_tp_fm_ver = 0x%x, uc_host_fm_ver = 0x%x\n",
-		//		uc_tp_fm_ver, uc_host_fm_ver);
-		i_ret = fts_ctpm_fw_upgrade_with_i_file(client);
-		if (i_ret == 0)	{
-			msleep(300);
-			uc_host_fm_ver = fts_ctpm_get_i_file_ver();
-			//dev_dbg(&client->dev, "[FTS] upgrade to new version 0x%x\n",
-			//		uc_host_fm_ver);
-		} else {
-			//pr_err("[FTS] upgrade failed ret=%d.\n", i_ret);
-			return -EIO;
-		}
-	}
-
-	return 0;
-}
-
-void delay_qt_ms(unsigned long  w_ms)
-{
-	unsigned long i;
-	unsigned long j;
-
-	for (i = 0; i < w_ms; i++)
-	{
-		for (j = 0; j < 1000; j++)
-		{
-			 udelay(1);
-		}
-	}
-}
-
-extern void focaltech_get_upgrade_array(void);
-
-int fts_ctpm_fw_upgrade(struct i2c_client *client, u8 *pbt_buf,
-			  u32 dw_lenth)
-{
-	u8 reg_val[2] = {0};
-	u32 i = 0;
-	u8 is_5336_new_bootloader = 0;
-	u8 is_5336_fwsize_30 = 0;
-	u32 packet_number;
-	u32 j=0;
-	u32 temp;
-	u32 lenght;
-	u8 packet_buf[FTS_PACKET_LENGTH + 6];
-	u8 auc_i2c_write_buf[10];
-	u8 bt_ecc;
-	int i_ret;
-      // struct Upgrade_Info upgradeinfo;
-	   
-	//fts_get_upgrade_info(&upgradeinfo);
-	
-	focaltech_get_upgrade_array();
-	
-	if(*(pbt_buf+dw_lenth-12) == 30)
-	{
-		is_5336_fwsize_30 = 1;
-	}
-	else 
-	{
-		is_5336_fwsize_30 = 0;
-	}
-	for (i = 0; i < FTS_UPGRADE_LOOP; i++) 
-	{
-	        msleep(100);
-		printk("[FTS] Step 1:Reset  CTPM\n");
-		/*********Step 1:Reset  CTPM *****/
-		/*write 0xaa to register 0xfc */
-		//if (DEVICE_IC_TYPE == IC_FT6208 || DEVICE_IC_TYPE == IC_FT6x06)
-		if(fts_updateinfo_curr.CHIP_ID==0x06 || fts_updateinfo_curr.CHIP_ID==0x36) 
-			fts_write_reg(client, 0xbc, FT_UPGRADE_AA);
-		else
-			fts_write_reg(client, 0xfc, FT_UPGRADE_AA);
-		msleep(fts_updateinfo_curr.delay_aa);
-
-
-		/*write 0x55 to register 0xfc */
-		//if(DEVICE_IC_TYPE == IC_FT6208 || DEVICE_IC_TYPE == IC_FT6x06)
-		if(fts_updateinfo_curr.CHIP_ID==0x06 || fts_updateinfo_curr.CHIP_ID==0x36 )
-			fts_write_reg(client, 0xbc, FT_UPGRADE_55);
-		else
-			fts_write_reg(client, 0xfc, FT_UPGRADE_55);
-		if(i<=15)
-		{
-		msleep(fts_updateinfo_curr.delay_55+i*3);
-		}
-		else
-		{
-		msleep(fts_updateinfo_curr.delay_55-(i-15)*2);
-		}
-
-   
-		/*********Step 2:Enter upgrade mode *****/
-		printk("[FTS] Step 2:Enter upgrade mode \n");
-		#if 0
-			auc_i2c_write_buf[0] = FT_UPGRADE_55;
-			auc_i2c_write_buf[1] = FT_UPGRADE_AA;
-			do {
-				j++;
-				i_ret = fts_i2c_Write(client, auc_i2c_write_buf, 2);
-				msleep(5);
-			} while (i_ret <= 0 && j < 5);
-		#else
-			auc_i2c_write_buf[0] = FT_UPGRADE_55;
-			fts_i2c_Write(client, auc_i2c_write_buf, 1);
-			msleep(5);
-			auc_i2c_write_buf[0] = FT_UPGRADE_AA;
-			fts_i2c_Write(client, auc_i2c_write_buf, 1);
-		#endif
-
-#if 1
-		/*********Step 3:check READ-ID***********************/
-		msleep(fts_updateinfo_curr.delay_readid);
-		auc_i2c_write_buf[0] = 0x90;
-		auc_i2c_write_buf[1] = auc_i2c_write_buf[2] = auc_i2c_write_buf[3] =0x00;
-		fts_i2c_Read(client, auc_i2c_write_buf, 4, reg_val, 2);
-
-		printk("[FTS] Step 3: CTPM ID,ID1 = 0x%x,ID2 = 0x%x\n",reg_val[0], reg_val[1]);
-		if (reg_val[0] == fts_updateinfo_curr.upgrade_id_1
-			&& reg_val[1] == fts_updateinfo_curr.upgrade_id_2) {
-			//dev_dbg(&client->dev, "[FTS] Step 3: CTPM ID,ID1 = 0x%x,ID2 = 0x%x\n",
-				//reg_val[0], reg_val[1]);
-			DBG("[FTS] Step 3: CTPM ID,ID1 = 0x%x,ID2 = 0x%x\n",
-				reg_val[0], reg_val[1]);
-			break;
-		} else {
-			dev_err(&client->dev, "[FTS] Step 3: CTPM ID,ID1 = 0x%x,ID2 = 0x%x\n",
-				reg_val[0], reg_val[1]);
-		}
-#endif	
-	}
-	if (i >= FTS_UPGRADE_LOOP)
-		return -EIO;
-	
-	auc_i2c_write_buf[0] = 0xcd;
-	fts_i2c_Read(client, auc_i2c_write_buf, 1, reg_val, 1);
-	/*********0705 mshl ********************/
-	/*if (reg_val[0] > 4)
-		is_5336_new_bootloader = 1;*/
-
-	if (reg_val[0] <= 4)
-	{
-		is_5336_new_bootloader = BL_VERSION_LZ4 ;
-	}
-	else if(reg_val[0] == 7)
-	{
-		is_5336_new_bootloader = BL_VERSION_Z7 ;
-	}
-	else if(reg_val[0] >= 0x0f && ((fts_updateinfo_curr.CHIP_ID==0x11) ||(fts_updateinfo_curr.CHIP_ID==0x12) ||(fts_updateinfo_curr.CHIP_ID==0x13) ||(fts_updateinfo_curr.CHIP_ID==0x14)))
-	{
-		is_5336_new_bootloader = BL_VERSION_GZF ;
-	}
-	else
-	{
-		is_5336_new_bootloader = BL_VERSION_LZ4 ;
-	}
-
-
-	printk("[FTS] Step 4:erase app and panel paramenter area\n");
-	/*Step 4:erase app and panel paramenter area*/
-	DBG("Step 4:erase app and panel paramenter area\n");
-	auc_i2c_write_buf[0] = 0x61;
-	fts_i2c_Write(client, auc_i2c_write_buf, 1);	/*erase app area */
-	msleep(fts_updateinfo_curr.delay_earse_flash);
-	/*erase panel parameter area */
-	if(is_5336_fwsize_30)
-	{
-	    auc_i2c_write_buf[0] = 0x63;
-	    fts_i2c_Write(client, auc_i2c_write_buf, 1);
-	}
-	msleep(100);
-
-	printk("[FTS] Step 5:write firmware(FW) to ctpm flash\n");
-	/*********Step 5:write firmware(FW) to ctpm flash*********/
-	bt_ecc = 0;
-	DBG("Step 5:write firmware(FW) to ctpm flash\n");
-
-	//dw_lenth = dw_lenth - 8;
-	if(is_5336_new_bootloader == BL_VERSION_LZ4 || is_5336_new_bootloader == BL_VERSION_Z7 )
-	{
-		dw_lenth = dw_lenth - 8;
-	}
-	else if(is_5336_new_bootloader == BL_VERSION_GZF) 
-	{
-	      dw_lenth = dw_lenth - 14;
-	}
-	packet_number = (dw_lenth) / FTS_PACKET_LENGTH;
-	packet_buf[0] = 0xbf;
-	packet_buf[1] = 0x00;
-
-	for (j = 0; j < packet_number; j++) {
-		temp = j * FTS_PACKET_LENGTH;
-		packet_buf[2] = (u8) (temp >> 8);
-		packet_buf[3] = (u8) temp;
-		lenght = FTS_PACKET_LENGTH;
-		packet_buf[4] = (u8) (lenght >> 8);
-		packet_buf[5] = (u8) lenght;
-
-		for (i = 0; i < FTS_PACKET_LENGTH; i++) {
-			packet_buf[6 + i] = pbt_buf[j * FTS_PACKET_LENGTH + i];
-			bt_ecc ^= packet_buf[6 + i];
-		}
-		
-		fts_i2c_Write(client, packet_buf, FTS_PACKET_LENGTH + 6);
-		msleep(FTS_PACKET_LENGTH / 6 + 1);
-		if((((j+1) * FTS_PACKET_LENGTH)%1024)==0)
-		DBG("write bytes:0x%04x\n", (j+1) * FTS_PACKET_LENGTH);
-		//delay_qt_ms(FTS_PACKET_LENGTH / 6 + 1);
-	}
-
-	if ((dw_lenth) % FTS_PACKET_LENGTH > 0) {
-		temp = packet_number * FTS_PACKET_LENGTH;
-		packet_buf[2] = (u8) (temp >> 8);
-		packet_buf[3] = (u8) temp;
-		temp = (dw_lenth) % FTS_PACKET_LENGTH;
-		packet_buf[4] = (u8) (temp >> 8);
-		packet_buf[5] = (u8) temp;
-
-		for (i = 0; i < temp; i++) {
-			packet_buf[6 + i] = pbt_buf[packet_number * FTS_PACKET_LENGTH + i];
-			bt_ecc ^= packet_buf[6 + i];
-		}
-
-		fts_i2c_Write(client, packet_buf, temp + 6);
-		msleep(20);
-	}
-#if 0
-	/*send the last six byte*/
-	for (i = 0; i<6; i++)
-	{
-		if (is_5336_new_bootloader && ((fts_updateinfo_curr.CHIP_ID==0x11) ||(fts_updateinfo_curr.CHIP_ID==0x12) ||(fts_updateinfo_curr.CHIP_ID==0x13) ||(fts_updateinfo_curr.CHIP_ID==0x14)))//5x36,5x36i 
-			temp = 0x7bfa + i;
-		else
-			temp = 0x6ffa + i;
-		packet_buf[2] = (u8)(temp>>8);
-		packet_buf[3] = (u8)temp;
-		temp =1;
-		packet_buf[4] = (u8)(temp>>8);
-		packet_buf[5] = (u8)temp;
-		packet_buf[6] = pbt_buf[ dw_lenth + i]; 
-		bt_ecc ^= packet_buf[6];
-		fts_i2c_Write(client, packet_buf, 7);
-		msleep(20);
-	}
-#else
-	/*send the last six byte*/
-	if(is_5336_new_bootloader == BL_VERSION_LZ4 || is_5336_new_bootloader == BL_VERSION_Z7 )
-	{
-		for (i = 0; i<6; i++)
-		{
-			if (is_5336_new_bootloader  == BL_VERSION_Z7 ) 
-			{
-				temp = 0x7bfa + i;
-			}
-			else if(is_5336_new_bootloader == BL_VERSION_LZ4)
-			{
-				temp = 0x6ffa + i;
-			}
-			packet_buf[2] = (u8)(temp>>8);
-			packet_buf[3] = (u8)temp;
-			temp =1;
-			packet_buf[4] = (u8)(temp>>8);
-			packet_buf[5] = (u8)temp;
-			packet_buf[6] = pbt_buf[ dw_lenth + i]; 
-			bt_ecc ^= packet_buf[6];
-  
-			fts_i2c_Write(client, packet_buf, 7);
-			msleep(20);
-		}
-	}
-	else if(is_5336_new_bootloader == BL_VERSION_GZF)
-	{
-	    
-		for (i = 0; i<12; i++)
-		{
-			if (is_5336_fwsize_30) 
-			{
-				temp = 0x7ff4 + i;
-			}
-			else 
-			{
-				temp = 0x7bf4 + i;
-			}
-			packet_buf[2] = (u8)(temp>>8);
-			packet_buf[3] = (u8)temp;
-			temp =1;
-			packet_buf[4] = (u8)(temp>>8);
-			packet_buf[5] = (u8)temp;
-			packet_buf[6] = pbt_buf[ dw_lenth + i]; 
-			bt_ecc ^= packet_buf[6];
-  
-			fts_i2c_Write(client, packet_buf, 7);
-			msleep(20);
-
-		}
-	}
-
-#endif
-	printk("[FTS] Step 6: read out checksum\n");
-	/*********Step 6: read out checksum***********************/
-	/*send the opration head */
-	DBG("Step 6: read out checksum\n");
-	auc_i2c_write_buf[0] = 0xcc;
-	fts_i2c_Read(client, auc_i2c_write_buf, 1, reg_val, 1);
-	if (reg_val[0] != bt_ecc) {
-		dev_err(&client->dev, "[FTS]--ecc error! FW=%02x bt_ecc=%02x\n",
-					reg_val[0],
-					bt_ecc);
-		return -EIO;
-	}
-
-	printk("[FTS] Step 7: reset the new FW\n");
-	/*********Step 7: reset the new FW***********************/
-	DBG("Step 7: reset the new FW\n");
-	auc_i2c_write_buf[0] = 0x07;
-	fts_i2c_Write(client, auc_i2c_write_buf, 1);
-	msleep(300);	/*make sure CTP startup normally */
-
-	return 0;
-}
-
-/*sysfs debug*/
-
-/*
-*get firmware size
-
-@firmware_name:firmware name
-*note:the firmware default path is sdcard.
-	if you want to change the dir, please modify by yourself.
-*/
-static int fts_GetFirmwareSize(char *firmware_name)
-{
-	struct file *pfile = NULL;
-	struct inode *inode;
-	unsigned long magic;
-	off_t fsize = 0;
-	char filepath[128];
-	memset(filepath, 0, sizeof(filepath));
-
-	sprintf(filepath, "%s", firmware_name);
-
-	if (NULL == pfile)
-		pfile = filp_open(filepath, O_RDONLY, 0);
-
-	if (IS_ERR(pfile)) {
-		pr_err("error occured while opening file %s.\n", filepath);
-		return -EIO;
-	}
-
-	inode = pfile->f_dentry->d_inode;
-	magic = inode->i_sb->s_magic;
-	fsize = inode->i_size;
-	filp_close(pfile, NULL);
-	return fsize;
-}
-
-
-
-/*
-*read firmware buf for .bin file.
-
-@firmware_name: fireware name
-@firmware_buf: data buf of fireware
-
-note:the firmware default path is sdcard.
-	if you want to change the dir, please modify by yourself.
-*/
-static int fts_ReadFirmware(char *firmware_name,
-			       unsigned char *firmware_buf)
-{
-	struct file *pfile = NULL;
-	struct inode *inode;
-	unsigned long magic;
-	off_t fsize;
-	char filepath[128];
-	loff_t pos;
-	mm_segment_t old_fs;
-
-	memset(filepath, 0, sizeof(filepath));
-	sprintf(filepath, "%s", firmware_name);
-	if (NULL == pfile)
-		pfile = filp_open(filepath, O_RDONLY, 0);
-	if (IS_ERR(pfile)) {
-		pr_err("error occured while opening file %s.\n", filepath);
-		return -EIO;
-	}
-
-	inode = pfile->f_dentry->d_inode;
-	magic = inode->i_sb->s_magic;
-	fsize = inode->i_size;
-	old_fs = get_fs();
-	set_fs(KERNEL_DS);
-	pos = 0;
-	vfs_read(pfile, firmware_buf, fsize, &pos);
-	filp_close(pfile, NULL);
-	set_fs(old_fs);
-
-	return 0;
-}
-
-
-
-/*
-upgrade with *.bin file
-*/
-
-int fts_ctpm_fw_upgrade_with_app_file(struct i2c_client *client,
-				       char *firmware_name)
-{
-	u8 *pbt_buf = NULL;
-	int i_ret=0;
-	int fwsize = fts_GetFirmwareSize(firmware_name);
-
-	if (fwsize <= 0) {
-		dev_err(&client->dev, "%s ERROR:Get firmware size failed\n",
-					__func__);
-		return -EIO;
-	}
-
-	if (fwsize < 8 || fwsize > 32 * 1024) {
-		dev_dbg(&client->dev, "%s:FW length error\n", __func__);
-		return -EIO;
-	}
-	
-    
-	/*=========FW upgrade========================*/
-	pbt_buf = kmalloc(fwsize + 1, GFP_ATOMIC);
-
-	if (fts_ReadFirmware(firmware_name, pbt_buf)) {
-		dev_err(&client->dev, "%s() - ERROR: request_firmware failed\n",
-					__func__);
-		kfree(pbt_buf);
-		//return -EIO;
-		i_ret = -EIO;
-		goto err_ret;
-	}
-	
-	/*call the upgrade function */
-	i_ret = fts_ctpm_fw_upgrade(client, pbt_buf, fwsize);
-	if (i_ret != 0)
-		dev_err(&client->dev, "%s() - ERROR:[FTS] upgrade failed..\n",
-					__func__);
-	else if(fts_updateinfo_curr.AUTO_CLB==AUTO_CLB_NEED)
-		fts_ctpm_auto_clb(client);
-
-err_ret:
-	
-	
-	
-	kfree(pbt_buf);
-    
-	return i_ret;
-}
-
-static ssize_t fts_tpfwver_show(struct device *dev,
-					struct device_attribute *attr,
-					char *buf)
-{
-	ssize_t num_read_chars = 0;
-	u8 fwver = 0;
-	struct i2c_client *client = container_of(dev, struct i2c_client, dev);
-
-	mutex_lock(&g_device_mutex);
-
-	if (fts_read_reg(client, FT_REG_FW_VER, &fwver) < 0)
-		num_read_chars = snprintf(buf, PAGE_SIZE,
-					"get tp fw version fail!\n");
-	else
-		num_read_chars = snprintf(buf, PAGE_SIZE, "%02X\n", fwver);
-
-	mutex_unlock(&g_device_mutex);
-
-	return num_read_chars;
-}
-
-static ssize_t fts_tpfwver_store(struct device *dev,
-					struct device_attribute *attr,
-					const char *buf, size_t count)
-{
-	/*place holder for future use*/
-	return -EPERM;
-}
-
-
-
-static ssize_t fts_tprwreg_show(struct device *dev,
-					struct device_attribute *attr,
-					char *buf)
-{
-	/*place holder for future use*/
-	return -EPERM;
-}
-
-static ssize_t fts_tprwreg_store(struct device *dev,
-					struct device_attribute *attr,
-					const char *buf, size_t count)
-{
-	struct i2c_client *client = container_of(dev, struct i2c_client, dev);
-	ssize_t num_read_chars = 0;
-	int retval;
-	long unsigned int wmreg = 0;
-	u8 regaddr = 0xff, regvalue = 0xff;
-	u8 valbuf[5] = {0};
-
-	memset(valbuf, 0, sizeof(valbuf));
-	mutex_lock(&g_device_mutex);
-	num_read_chars = count - 1;
-
-	if (num_read_chars != 2) {
-		if (num_read_chars != 4) {
-			pr_info("please input 2 or 4 character\n");
-			goto error_return;
-		}
-	}
-
-	memcpy(valbuf, buf, num_read_chars);
-	retval = strict_strtoul(valbuf, 16, &wmreg);
-
-	if (0 != retval) {
-		dev_err(&client->dev, "%s() - ERROR: Could not convert the "\
-						"given input to a number." \
-						"The given input was: \"%s\"\n",
-						__func__, buf);
-		goto error_return;
-	}
-
-	if (2 == num_read_chars) {
-		/*read register*/
-		regaddr = wmreg;
-		if (fts_read_reg(client, regaddr, &regvalue) < 0)
-			dev_err(&client->dev, "Could not read the register(0x%02x)\n",
-						regaddr);
-		else
-			pr_info("the register(0x%02x) is 0x%02x\n",
-					regaddr, regvalue);
-	} else {
-		regaddr = wmreg >> 8;
-		regvalue = wmreg;
-		if (fts_write_reg(client, regaddr, regvalue) < 0)
-			dev_err(&client->dev, "Could not write the register(0x%02x)\n",
-							regaddr);
-		else
-			dev_err(&client->dev, "Write 0x%02x into register(0x%02x) successful\n",
-							regvalue, regaddr);
-	}
-
-error_return:
-	mutex_unlock(&g_device_mutex);
-
-	return count;
-}
-
-static ssize_t fts_fwupdate_show(struct device *dev,
-					struct device_attribute *attr,
-					char *buf)
-{
-	/* place holder for future use */
-	return -EPERM;
-}
-
-/*upgrade from *.i*/
-static ssize_t fts_fwupdate_store(struct device *dev,
-					struct device_attribute *attr,
-					const char *buf, size_t count)
-{
-	struct fts_ts_data *data = NULL;
-	u8 uc_host_fm_ver;
-	int i_ret;
-	struct i2c_client *client = container_of(dev, struct i2c_client, dev);
-
-	data = (struct fts_ts_data *)i2c_get_clientdata(client);
-
-	mutex_lock(&g_device_mutex);
-
-	//disable_irq(client->irq);
-	mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
-	i_ret = fts_ctpm_fw_upgrade_with_i_file(client);
-	if (i_ret == 0) {
-		msleep(300);
-		uc_host_fm_ver = fts_ctpm_get_i_file_ver();
-		pr_info("%s [FTS] upgrade to new version 0x%x\n", __func__,
-					 uc_host_fm_ver);
-	} else
-		dev_err(&client->dev, "%s ERROR:[FTS] upgrade failed.\n",
-					__func__);
-
-	//enable_irq(client->irq);
-	mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
-	mutex_unlock(&g_device_mutex);
-
-	return count;
-}
-
-static ssize_t fts_fwupgradeapp_show(struct device *dev,
-					struct device_attribute *attr,
-					char *buf)
-{
-	/*place holder for future use*/
-	return -EPERM;
-}
-
-
-/*upgrade from app.bin*/
-static ssize_t fts_fwupgradeapp_store(struct device *dev,
-					struct device_attribute *attr,
-					const char *buf, size_t count)
-{
-	ssize_t num_read_chars = 0;
-	char fwname[128];
-	struct i2c_client *client = container_of(dev, struct i2c_client, dev);
-
-	memset(fwname, 0, sizeof(fwname));
-	sprintf(fwname, "%s", buf);
-	fwname[count - 1] = '\0';
-
-	mutex_lock(&g_device_mutex);
-	//disable_irq(client->irq);
-       mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
-	if(0==fts_ctpm_fw_upgrade_with_app_file(client, fwname))
-	{
-		num_read_chars = snprintf(buf, PAGE_SIZE,
-					"FTP firmware upgrade success!\n");
-	}
-	else
-	{
-		num_read_chars = snprintf(buf, PAGE_SIZE,
-					"FTP firmware upgrade fail!\n");
-	}
-
-	//enable_irq(client->irq);
-	mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
-	mutex_unlock(&g_device_mutex);
-
-	return num_read_chars;
-}
-
-
-/*sysfs */
-/*get the fw version
-*example:cat ftstpfwver
-*/
-static DEVICE_ATTR(ftstpfwver, S_IRUGO | S_IWUSR, fts_tpfwver_show,
-			fts_tpfwver_store);
-
-/*upgrade from *.i
-*example: echo 1 > ftsfwupdate
-*/
-static DEVICE_ATTR(ftsfwupdate, S_IRUGO | S_IWUSR, fts_fwupdate_show,
-			fts_fwupdate_store);
-
-/*read and write register
-*read example: echo 88 > ftstprwreg ---read register 0x88
-*write example:echo 8807 > ftstprwreg ---write 0x07 into register 0x88
-*
-*note:the number of input must be 2 or 4.if it not enough,please fill in the 0.
-*/
-static DEVICE_ATTR(ftstprwreg, S_IRUGO | S_IWUSR, fts_tprwreg_show,
-			fts_tprwreg_store);
-
-
-/*upgrade from app.bin
-*example:echo "*_app.bin" > ftsfwupgradeapp
-*/
-static DEVICE_ATTR(ftsfwupgradeapp, S_IRUGO | S_IWUSR, fts_fwupgradeapp_show,
-			fts_fwupgradeapp_store);
-
-
-/*add your attr in here*/
-static struct attribute *fts_attributes[] = {
-	&dev_attr_ftstpfwver.attr,
-	&dev_attr_ftsfwupdate.attr,
-	&dev_attr_ftstprwreg.attr,
-	&dev_attr_ftsfwupgradeapp.attr,
-	NULL
-};
-
-static struct attribute_group fts_attribute_group = {
-	.attrs = fts_attributes
-};
-
-/*create sysfs for debug*/
-int fts_create_sysfs(struct i2c_client *client)
-{
-	int err;
-	I2CDMABuf_va = (u8 *)dma_alloc_coherent(NULL, FTS_DMA_BUF_SIZE, &I2CDMABuf_pa, GFP_KERNEL);
-	
-    if(!I2CDMABuf_va)
-	{
-		dev_dbg(&client->dev,"%s Allocate DMA I2C Buffer failed!\n",__func__);
-		return -EIO;
-	}
-	//printk("FTP: I2CDMABuf_pa=%d,val=%d val2=%d\n",&I2CDMABuf_pa,I2CDMABuf_pa,(unsigned char *)I2CDMABuf_pa);
-	err = sysfs_create_group(&client->dev.kobj, &fts_attribute_group);
-	if (0 != err) {
-		dev_err(&client->dev,
-					 "%s() - ERROR: sysfs_create_group() failed.\n",
-					 __func__);
-		sysfs_remove_group(&client->dev.kobj, &fts_attribute_group);
-		return -EIO;
-	} else {
-		mutex_init(&g_device_mutex);
-		pr_info("ft6x06:%s() - sysfs_create_group() succeeded.\n",
-				__func__);
-	}
-	return err;
-}
-
-void fts_release_sysfs(struct i2c_client *client)
-{
-	sysfs_remove_group(&client->dev.kobj, &fts_attribute_group);
-	mutex_destroy(&g_device_mutex);
-	if(I2CDMABuf_va)
-	{
-		dma_free_coherent(NULL, FTS_DMA_BUF_SIZE, I2CDMABuf_va, I2CDMABuf_pa);
-		I2CDMABuf_va = NULL;
-		I2CDMABuf_pa = 0;
-	}
-	
-}
-/*create apk debug channel*/
-
-#define PROC_UPGRADE			0
-#define PROC_READ_REGISTER		1
-#define PROC_WRITE_REGISTER	2
-#define PROC_RAWDATA			3
-#define PROC_AUTOCLB			4
-
-#define PROC_NAME	"ft5x0x-debug"
-static unsigned char proc_operate_mode = PROC_RAWDATA;
-static struct proc_dir_entry *ft5x0x_proc_entry;
-/*interface of write proc*/
-static int ft5x0x_debug_write(struct file *filp, 
-	const char __user *buff, unsigned long len, void *data)
-{
-	struct i2c_client *client = wxt_client;
-	unsigned char writebuf[FTS_PACKET_LENGTH];
-	int buflen = len;
-	int writelen = 0;
-	int ret = 0;
-	
-	if (copy_from_user(&writebuf, buff, buflen)) {
-		dev_err(&client->dev, "%s:copy from user error\n", __func__);
-		return -EFAULT;
-	}
-	proc_operate_mode = writebuf[0];
-	
-	switch (proc_operate_mode) {
-	case PROC_UPGRADE:
-		{
-			char upgrade_file_path[128];
-			memset(upgrade_file_path, 0, sizeof(upgrade_file_path));
-			sprintf(upgrade_file_path, "%s", writebuf + 1);
-			upgrade_file_path[buflen-1] = '\0';
-			DBG("%s\n", upgrade_file_path);
-			disable_irq(client->irq);
-
-			ret = fts_ctpm_fw_upgrade_with_app_file(client, upgrade_file_path);
-
-			enable_irq(client->irq);
-			if (ret < 0) {
-				dev_err(&client->dev, "%s:upgrade failed.\n", __func__);
-				return ret;
-			}
-		}
-		break;
-	case PROC_READ_REGISTER:
-		writelen = 1;
-		DBG("%s:register addr=0x%02x\n", __func__, writebuf[1]);
-		ret = fts_i2c_Write(client, writebuf + 1, writelen);
-		if (ret < 0) {
-			dev_err(&client->dev, "%s:write iic error\n", __func__);
-			return ret;
-		}
-		break;
-	case PROC_WRITE_REGISTER:
-		writelen = 2;
-		ret = fts_i2c_Write(client, writebuf + 1, writelen);
-		if (ret < 0) {
-			dev_err(&client->dev, "%s:write iic error\n", __func__);
-			return ret;
-		}
-		break;
-	case PROC_RAWDATA:
-		break;
-	case PROC_AUTOCLB:
-		fts_ctpm_auto_clb(client);
-		break;
-	
-	default:
-		break;
-	}
-	
-
-	return len;
-}
-
-/*interface of read proc*/
-static int ft5x0x_debug_read( char *page, char **start,
-	off_t off, int count, int *eof, void *data )
-{
-	struct i2c_client *client = wxt_client;
-	int ret = 0, err = 0;
-	u8 tx = 0, rx = 0;
-	int i, j;
-	unsigned char buf[PAGE_SIZE];
-	int num_read_chars = 0;
-	int readlen = 0;
-	u8 regvalue = 0x00, regaddr = 0x00;
-	switch (proc_operate_mode) {
-	case PROC_UPGRADE:
-		/*after calling ft5x0x_debug_write to upgrade*/
-		regaddr = 0xA6;
-		ret = fts_read_reg(client, regaddr, &regvalue);
-		if (ret < 0)
-			num_read_chars = sprintf(buf, "%s", "get fw version failed.\n");
-		else
-			num_read_chars = sprintf(buf, "current fw version:0x%02x\n", regvalue);
-		break;
-	case PROC_READ_REGISTER:
-		readlen = 1;
-		ret = fts_i2c_Read(client, NULL, 0, buf, readlen);
-		if (ret < 0) {
-			dev_err(&client->dev, "%s:read iic error\n", __func__);
-			return ret;
-		} else
-			DBG("%s:value=0x%02x\n", __func__, buf[0]);
-		num_read_chars = 1;
-		break;
-	case PROC_RAWDATA:
-		break;
-	default:
-		break;
-	}
-	
-	memcpy(page, buf, num_read_chars);
-
-	return num_read_chars;
-}
-static const struct file_operations ft5x0x_config_proc_ops = {
-  //  .owner = THIS_MODULE,
-    .read = ft5x0x_debug_read,
-    .write = ft5x0x_debug_write,
-};
-int ft5x0x_create_apk_debug_channel(struct i2c_client * client)
-{
-#if 0
-	ft5x0x_proc_entry = create_proc_entry(PROC_NAME, 0777, NULL);
-	if (NULL == ft5x0x_proc_entry) {
-		dev_err(&client->dev, "Couldn't create proc entry!\n");
-		return -ENOMEM;
-	} else {
-		dev_info(&client->dev, "Create proc entry success!\n");
-		ft5x0x_proc_entry->data = client;
-		ft5x0x_proc_entry->write_proc = ft5x0x_debug_write;
-		ft5x0x_proc_entry->read_proc = ft5x0x_debug_read;
-	}
-#else
-	wxt_client=client;
-	ft5x0x_proc_entry = proc_create(PROC_NAME, 0777, NULL, &ft5x0x_config_proc_ops);
-    if (ft5x0x_proc_entry == NULL)
-    {
-        DBG("create_proc_entry %s failed\n", PROC_NAME);
-    }
-    else
-    {
-        DBG("create proc entry %s success", PROC_NAME);
-    }
-#endif
-	return 0;
-}
-
-void ft5x0x_release_apk_debug_channel(void)
-{
-	if (ft5x0x_proc_entry)
-		remove_proc_entry(PROC_NAME, NULL);
-}
-
diff --git a/drivers/input/touchscreen/mediatek/focaltech_qhd/Makefile~ b/drivers/input/touchscreen/mediatek/focaltech_qhd/Makefile~
deleted file mode 100755
index ce6bcb0..0000000
--- a/drivers/input/touchscreen/mediatek/focaltech_qhd/Makefile~
+++ /dev/null
@@ -1,18 +0,0 @@
-include $(srctree)/drivers/misc/mediatek/Makefile.custom
-
-# Linux driver folder
-ccflags-y += -I$(srctree)/drivers/misc/mediatek/mach/$(MTK_PLATFORM)/$(ARCH_MTK_PROJECT)/touchpanel/focaltech_qhd/
-ccflags-y += -I$(srctree)/arch/arm/mach-$(MTK_PLATFORM)/$(ARCH_MTK_PROJECT)/touchpanel/focaltech_qhd/
-ccflags-y += -I$(srctree)/drivers/input/touchscreen/mediatek/focaltech_qhd/
-ccflags-y += -I$(srctree)/drivers/input/touchscreen/mediatek/
-
-#obj-y += ft_gesture_lib.o
-#$(obj)/ft_gesture_lib.o: $(srctree)/../$(obj)/touchpanel/ft_gesture_lib.o
-#	cp $(srctree)/../$(obj)/touchpanel/ft_gesture_lib.o $(obj)/ft_gesture_lib.o
-
-obj-y	+=  focaltech_ctl.o
-obj-y	+=  focaltech_driver.o
-obj-y	+=  focaltech_ex_fun.o
-obj-y	+=  ft_gesture_lib.a
-#obj-y	+=  gt1x_update.o
-
diff --git a/drivers/input/touchscreen/mediatek/focaltech_qhd/focaltech_driver.c~ b/drivers/input/touchscreen/mediatek/focaltech_qhd/focaltech_driver.c~
deleted file mode 100755
index ed9c73c..0000000
--- a/drivers/input/touchscreen/mediatek/focaltech_qhd/focaltech_driver.c~
+++ /dev/null
@@ -1,1162 +0,0 @@
-/*
- * This software is licensed under the terms of the GNU General Public 
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms. 
- * This program is distributed in the hope that it will be useful, 
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
- * GNU General Public License for more details. 
- * * VERSION      	DATE			AUTHOR          Note
- *    1.0		  2013-7-16			Focaltech        initial  based on MTK platform
- * 
- */
-
-#include "tpd.h"
-
-#include "tpd_custom_fts.h"
-#ifdef FTS_CTL_IIC
-#include "focaltech_ctl.h"
-#endif
-#ifdef TPD_SYSFS_DEBUG
-#include "focaltech_ex_fun.h"
-#endif
-#ifdef TPD_PROXIMITY
-#include <linux/hwmsensor.h>
-#include <linux/hwmsen_dev.h>
-#include <linux/sensors_io.h>
-#endif
-#include <mach/eint.h>
-#include "cust_gpio_usage.h"
-
-
-  struct Upgrade_Info fts_updateinfo[] =
-{
-        {0x55,"FT5x06",TPD_MAX_POINTS_5,AUTO_CLB_NEED,50, 30, 0x79, 0x03, 1, 2000},
-        {0x08,"FT5606",TPD_MAX_POINTS_5,AUTO_CLB_NEED,50, 30, 0x79, 0x06, 100, 2000},
-	{0x0a,"FT5x16",TPD_MAX_POINTS_5,AUTO_CLB_NEED,50, 30, 0x79, 0x07, 1, 1500},
-	{0x05,"FT6208",TPD_MAX_POINTS_2,AUTO_CLB_NONEED,60, 30, 0x79, 0x05, 10, 2000},
-	{0x06,"FT6x06",TPD_MAX_POINTS_2,AUTO_CLB_NONEED,100, 30, 0x79, 0x08, 10, 2000},
-	{0x36,"FT6x36",TPD_MAX_POINTS_2,AUTO_CLB_NONEED,100, 30, 0x79, 0x18, 10, 2000},//CHIP ID error
-	{0x55,"FT5x06i",TPD_MAX_POINTS_5,AUTO_CLB_NEED,50, 30, 0x79, 0x03, 1, 2000},
-	{0x14,"FT5336",TPD_MAX_POINTS_5,AUTO_CLB_NONEED,30, 30, 0x79, 0x11, 10, 2000},
-	{0x13,"FT3316",TPD_MAX_POINTS_5,AUTO_CLB_NONEED,30, 30, 0x79, 0x11, 10, 2000},
-	{0x12,"FT5436i",TPD_MAX_POINTS_5,AUTO_CLB_NONEED,30, 30, 0x79, 0x11, 10, 2000},
-	{0x11,"FT5336i",TPD_MAX_POINTS_5,AUTO_CLB_NONEED,30, 30, 0x79, 0x11, 10, 2000},
-};
-				
-struct Upgrade_Info fts_updateinfo_curr;
-
-#ifdef TPD_PROXIMITY
-#define APS_ERR(fmt,arg...)           	printk("<<proximity>> "fmt"\n",##arg)
-#define TPD_PROXIMITY_DEBUG(fmt,arg...) printk("<<proximity>> "fmt"\n",##arg)
-#define TPD_PROXIMITY_DMESG(fmt,arg...) printk("<<proximity>> "fmt"\n",##arg)
-
-static u8 tpd_proximity_flag 			= 0;
-static u8 tpd_proximity_flag_one 		= 0; //add for tpd_proximity by wangdongfang
-static u8 tpd_proximity_detect 		= 1;//0-->close ; 1--> far away
-#endif
-
-#ifdef FTS_GESTRUE
-#define GESTURE_LEFT		0x20
-#define GESTURE_RIGHT		0x21
-#define GESTURE_UP		    0x22
-#define GESTURE_DOWN		0x23
-#define GESTURE_DOUBLECLICK	0x24
-#define GESTURE_O		    0x30
-#define GESTURE_W		    0x31
-#define GESTURE_M		    0x32
-#define GESTURE_E		    0x33
-#define GESTURE_C		    0x34
-#define GESTURE_S		    0x46
-#define GESTURE_V		    0x54
-#define GESTURE_Z		    0x41
-
-#include "ft_gesture_lib.h"
-
-#define FTS_GESTRUE_POINTS 255
-#define FTS_GESTRUE_POINTS_ONETIME  62
-#define FTS_GESTRUE_POINTS_HEADER 8
-#define FTS_GESTURE_OUTPUT_ADRESS 0xD3
-#define FTS_GESTURE_OUTPUT_UNIT_LENGTH 4
-
-//suspend_state_t get_suspend_state(void);
-
-unsigned short coordinate_x[150] = {0};
-unsigned short coordinate_y[150] = {0};
-#endif
-extern struct tpd_device *tpd;
- 
-static struct i2c_client *i2c_client = NULL;
-struct task_struct *thread = NULL;
- 
-static DECLARE_WAIT_QUEUE_HEAD(waiter);
-static DEFINE_MUTEX(i2c_access);
- 
- 
-static void tpd_eint_interrupt_handler(void);
-// start:Here maybe need port to different platform,like MT6575/MT6577
-extern void mt_eint_unmask(unsigned int line);
-extern void mt_eint_mask(unsigned int line);
-extern void mt_eint_set_hw_debounce(unsigned int eint_num, unsigned int ms);
-//extern unsigned int mt65xx_eint_set_sens(unsigned int eint_num, unsigned int sens);
-//extern void mt65xx_eint_registration(unsigned int eint_num, unsigned int is_deb_en, unsigned int pol, void (EINT_FUNC_PTR)(void), unsigned int is_auto_umask);
-extern void mt_eint_registration(unsigned int eint_num, unsigned int flow, void (EINT_FUNC_PTR)(void), unsigned int is_auto_umask);
-// End:Here maybe need port to different platform,like MT6575/MT6577
- 
-static int tpd_probe(struct i2c_client *client, const struct i2c_device_id *id);
-static int tpd_detect (struct i2c_client *client, struct i2c_board_info *info);
-static int tpd_remove(struct i2c_client *client);
-static int touch_event_handler(void *unused);
-
-static int tpd_flag 					= 0;
-static int tpd_halt						= 0;
-static int point_num 					= 0;
-static int p_point_num 					= 0;
-
-
-
-//#define TPD_CLOSE_POWER_IN_SLEEP
-#define TPD_OK 							0
-//register define
-#define DEVICE_MODE 					0x00
-#define GEST_ID 						0x01
-#define TD_STATUS 						0x02
-//point1 info from 0x03~0x08
-//point2 info from 0x09~0x0E
-//point3 info from 0x0F~0x14
-//point4 info from 0x15~0x1A
-//point5 info from 0x1B~0x20
-//register define
-
-#define TPD_RESET_ISSUE_WORKAROUND
-
-#define TPD_MAX_RESET_COUNT 			3
-//extern int tpd_mstar_status ;  // compatible mstar and ft6306 chenzhecong
-
-#ifdef TPD_HAVE_BUTTON 
-static int tpd_keys_local[TPD_KEY_COUNT] = TPD_KEYS;
-static int tpd_keys_dim_local[TPD_KEY_COUNT][4] = TPD_KEYS_DIM;
-#endif
-#if (defined(TPD_WARP_START) && defined(TPD_WARP_END))
-static int tpd_wb_start_local[TPD_WARP_CNT] = TPD_WARP_START;
-static int tpd_wb_end_local[TPD_WARP_CNT]   = TPD_WARP_END;
-#endif
-#if (defined(TPD_HAVE_CALIBRATION) && !defined(TPD_CUSTOM_CALIBRATION))
-static int tpd_calmat_local[8]     = TPD_CALIBRATION_MATRIX;
-static int tpd_def_calmat_local[8] = TPD_CALIBRATION_MATRIX;
-#endif
-
-#define VELOCITY_CUSTOM_FT5206
-#ifdef VELOCITY_CUSTOM_FT5206
-#include <linux/device.h>
-#include <linux/miscdevice.h>
-#include <asm/uaccess.h>
-
-// for magnify velocity********************************************
-
-#ifndef TPD_VELOCITY_CUSTOM_X
-#define TPD_VELOCITY_CUSTOM_X 			10
-#endif
-#ifndef TPD_VELOCITY_CUSTOM_Y
-#define TPD_VELOCITY_CUSTOM_Y 			10
-#endif
-
-#define TOUCH_IOC_MAGIC 				'A'
-
-#define TPD_GET_VELOCITY_CUSTOM_X _IO(TOUCH_IOC_MAGIC,0)
-#define TPD_GET_VELOCITY_CUSTOM_Y _IO(TOUCH_IOC_MAGIC,1)
-
-
-static int g_v_magnify_x =TPD_VELOCITY_CUSTOM_X;
-static int g_v_magnify_y =TPD_VELOCITY_CUSTOM_Y;
-
-static int tpd_misc_open(struct inode *inode, struct file *file)
-{
-/*
-	file->private_data = adxl345_i2c_client;
-
-	if(file->private_data == NULL)
-	{
-		printk("tpd: null pointer!!\n");
-		return -EINVAL;
-	}
-	*/
-	return nonseekable_open(inode, file);
-}
-/*----------------------------------------------------------------------------*/
-static int tpd_misc_release(struct inode *inode, struct file *file)
-{
-	//file->private_data = NULL;
-	return 0;
-}
-/*----------------------------------------------------------------------------*/
-//static int adxl345_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
-//       unsigned long arg)
-static long tpd_unlocked_ioctl(struct file *file, unsigned int cmd,
-       unsigned long arg)
-{
-	//struct i2c_client *client = (struct i2c_client*)file->private_data;
-	//struct adxl345_i2c_data *obj = (struct adxl345_i2c_data*)i2c_get_clientdata(client);	
-	//char strbuf[256];
-	void __user *data;
-	
-	long err = 0;
-	
-	if(_IOC_DIR(cmd) & _IOC_READ)
-	{
-		err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
-	}
-	else if(_IOC_DIR(cmd) & _IOC_WRITE)
-	{
-		err = !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
-	}
-
-	if(err)
-	{
-		printk("tpd: access error: %08X, (%2d, %2d)\n", cmd, _IOC_DIR(cmd), _IOC_SIZE(cmd));
-		return -EFAULT;
-	}
-
-	switch(cmd)
-	{
-		case TPD_GET_VELOCITY_CUSTOM_X:
-			data = (void __user *) arg;
-			if(data == NULL)
-			{
-				err = -EINVAL;
-				break;	  
-			}			
-			
-			if(copy_to_user(data, &g_v_magnify_x, sizeof(g_v_magnify_x)))
-			{
-				err = -EFAULT;
-				break;
-			}				 
-			break;
-
-	   case TPD_GET_VELOCITY_CUSTOM_Y:
-			data = (void __user *) arg;
-			if(data == NULL)
-			{
-				err = -EINVAL;
-				break;	  
-			}			
-			
-			if(copy_to_user(data, &g_v_magnify_y, sizeof(g_v_magnify_y)))
-			{
-				err = -EFAULT;
-				break;
-			}				 
-			break;
-
-		default:
-			printk("tpd: unknown IOCTL: 0x%08x\n", cmd);
-			err = -ENOIOCTLCMD;
-			break;
-	}
-
-	return err;
-}
-
-
-static struct file_operations tpd_fops = {
-//	.owner = THIS_MODULE,
-	.open = tpd_misc_open,
-	.release = tpd_misc_release,
-	.unlocked_ioctl = tpd_unlocked_ioctl,
-};
-/*----------------------------------------------------------------------------*/
-static struct miscdevice tpd_misc_device = {
-	.minor = MISC_DYNAMIC_MINOR,
-	.name = TPD_NAME,
-	.fops = &tpd_fops,
-};
-
-//**********************************************
-#endif
-
-struct touch_info {
-    int y[10];
-    int x[10];
-    int p[10];
-    int id[10];
-};
- 
-static const struct i2c_device_id ft5206_tpd_id[] = {{TPD_NAME,0},{}};
-//unsigned short force[] = {0,0x70,I2C_CLIENT_END,I2C_CLIENT_END}; 
-//static const unsigned short * const forces[] = { force, NULL };
-//static struct i2c_client_address_data addr_data = { .forces = forces, };
-static struct i2c_board_info __initdata ft5206_i2c_tpd={ I2C_BOARD_INFO(TPD_NAME, (0x70>>1))};
- 
-static struct i2c_driver tpd_i2c_driver = {
-  	.driver = {
-	 	.name 	= TPD_NAME,
-	//	.owner 	= THIS_MODULE,
-  	},
-  	.probe 		= tpd_probe,
-  	.remove 	= tpd_remove,
-  	.id_table 	= ft5206_tpd_id,
-  	.detect 	= tpd_detect,
-// 	.shutdown	= tpd_shutdown,
-//  .address_data = &addr_data,
-};
-
-
-static  void tpd_down(int x, int y, int p) {
-	// input_report_abs(tpd->dev, ABS_PRESSURE, p);
-	input_report_key(tpd->dev, BTN_TOUCH, 1);
-	input_report_abs(tpd->dev, ABS_MT_TOUCH_MAJOR, 20);
-	input_report_abs(tpd->dev, ABS_MT_POSITION_X, x);
-	input_report_abs(tpd->dev, ABS_MT_POSITION_Y, y);
-	printk("D[%4d %4d %4d] ", x, y, p);
-	/* track id Start 0 */
-	input_report_abs(tpd->dev, ABS_MT_TRACKING_ID, p); 
-	input_mt_sync(tpd->dev);
-#ifndef MT6572
-    if (FACTORY_BOOT == get_boot_mode()|| RECOVERY_BOOT == get_boot_mode())
-#endif	
-    {   
-      tpd_button(x, y, 1);  
-    }
-	TPD_EM_PRINT(x, y, x, y, p-1, 1);
-}
- 
-static  void tpd_up(int x, int y) {
-	//input_report_abs(tpd->dev, ABS_PRESSURE, 0);
-	input_report_key(tpd->dev, BTN_TOUCH, 0);
-	//input_report_abs(tpd->dev, ABS_MT_TOUCH_MAJOR, 0);
-	//input_report_abs(tpd->dev, ABS_MT_POSITION_X, x);
-	//input_report_abs(tpd->dev, ABS_MT_POSITION_Y, y);
-	printk("U[%4d %4d %4d] ", x, y, 0);
-	input_mt_sync(tpd->dev);
-	TPD_EM_PRINT(x, y, x, y, 0, 0);
-#ifndef MT6572
-    if (FACTORY_BOOT == get_boot_mode()|| RECOVERY_BOOT == get_boot_mode())
-#endif
-    {   
-       tpd_button(x, y, 0); 
-    }   		 
-}
-
-static int tpd_touchinfo(struct touch_info *cinfo, struct touch_info *pinfo)
-{
-	int i = 0;
-//#if (TPD_MAX_POINTS==2)
-//	char data[35] = {0};
-//#else
-//	char data[16] = {0};
-//#endif	
-char data[128] = {0};
-    u16 high_byte,low_byte,reg;
-	u8 report_rate =0;
-
-	p_point_num = point_num;
-	if (tpd_halt)
-	{
-		TPD_DMESG( "tpd_touchinfo return ..\n");
-		return false;
-	}
-	mutex_lock(&i2c_access);
-
-
-    reg = 0x00;
-	fts_i2c_Read(i2c_client, &reg, 1, data, 64);
-	mutex_unlock(&i2c_access);
-	//TPD_DEBUG("received raw data from touch panel as following:\n");
-	//TPD_DEBUG("[data[0]=%x,data[1]= %x ,data[2]=%x ,data[3]=%x ,data[4]=%x ,data[5]=%x]\n",data[0],data[1],data[2],data[3],data[4],data[5]);
-	//TPD_DEBUG("[data[9]=%x,data[10]= %x ,data[11]=%x ,data[12]=%x]\n",data[9],data[10],data[11],data[12]);
-	//TPD_DEBUG("[data[15]=%x,data[16]= %x ,data[17]=%x ,data[18]=%x]\n",data[15],data[16],data[17],data[18]);
-   
-	/*get the number of the touch points*/
-	point_num= data[2] & 0x0f;
-	
-	//TPD_DEBUG("point_num =%d\n",point_num);
-		
-	for(i = 0; i < point_num; i++)  
-	{
-		cinfo->p[i] = data[3+6*i] >> 6; //event flag 
-     	cinfo->id[i] = data[3+6*i+2]>>4; //touch id
-	   	/*get the X coordinate, 2 bytes*/
-		high_byte = data[3+6*i];
-		high_byte <<= 8;
-		high_byte &= 0x0f00;
-		low_byte = data[3+6*i + 1];
-		cinfo->x[i] = high_byte |low_byte;
-		
-		//cinfo->x[i] =  cinfo->x[i] * 480 >> 11; //calibra
-	
-		/*get the Y coordinate, 2 bytes*/
-		
-		high_byte = data[3+6*i+2];
-		high_byte <<= 8;
-		high_byte &= 0x0f00;
-		low_byte = data[3+6*i+3];
-		cinfo->y[i] = high_byte |low_byte;
-
-		if (cinfo->y[i] <= TPD_Y_RES) 	//jeff add 20140820
-		{	
-			cinfo->x[i] = TPD_WARP_X(cinfo->x[i]);
-			cinfo->y[i] = TPD_WARP_Y(cinfo->y[i]);
-		}
-
-		 //cinfo->y[i]=  cinfo->y[i] * 800 >> 11;
-	}
-	TPD_DEBUG(" cinfo->x[0] = %d, cinfo->y[0] = %d, cinfo->p[0] = %d\n", cinfo->x[0], cinfo->y[0], cinfo->p[0]);	
-	//TPD_DEBUG(" cinfo->x[1] = %d, cinfo->y[1] = %d, cinfo->p[1] = %d\n", cinfo->x[1], cinfo->y[1], cinfo->p[1]);		
-	//TPD_DEBUG(" cinfo->x[2]= %d, cinfo->y[2]= %d, cinfo->p[2] = %d\n", cinfo->x[2], cinfo->y[2], cinfo->p[2]);	
-		  
-	return true;
-};
-
-#ifdef TPD_PROXIMITY
-int tpd_read_ps(void)
-{
-	tpd_proximity_detect;
-	return 0;    
-}
-
-static int tpd_get_ps_value(void)
-{
-	return tpd_proximity_detect;
-}
-
-static int tpd_enable_ps(int enable)
-{
-	u8 state;
-	int ret = -1;
-
-	i2c_smbus_read_i2c_block_data(i2c_client, 0xB0, 1, &state);
-	printk("[proxi_5206]read: 999 0xb0's value is 0x%02X\n", state);
-	if (enable){
-		state |= 0x01;
-		tpd_proximity_flag = 1;
-		TPD_PROXIMITY_DEBUG("[proxi_5206]ps function is on\n");	
-	}else{
-		state &= 0x00;	
-		tpd_proximity_flag = 0;
-		TPD_PROXIMITY_DEBUG("[proxi_5206]ps function is off\n");
-	}
-
-	ret = i2c_smbus_write_i2c_block_data(i2c_client, 0xB0, 1, &state);
-	TPD_PROXIMITY_DEBUG("[proxi_5206]write: 0xB0's value is 0x%02X\n", state);
-	return 0;
-}
-
-int tpd_ps_operate(void* self, uint32_t command, void* buff_in, int size_in,
-		void* buff_out, int size_out, int* actualout)
-{
-	int err = 0;
-	int value;
-	
-	hwm_sensor_data *sensor_data;
-	TPD_DEBUG("[proxi_5206]command = 0x%02X\n", command);		
-	switch (command)
-	{
-		case SENSOR_DELAY:
-			if((buff_in == NULL) || (size_in < sizeof(int)))
-			{
-				APS_ERR("Set delay parameter error!\n");
-				err = -EINVAL;
-			}
-			// Do nothing
-			break;
-
-		case SENSOR_ENABLE:
-			if((buff_in == NULL) || (size_in < sizeof(int)))
-			{
-				APS_ERR("Enable sensor parameter error!\n");
-				err = -EINVAL;
-			}
-			else
-			{				
-				value = *(int *)buff_in;
-				if(value)
-				{		
-					if((tpd_enable_ps(1) != 0))
-					{
-						APS_ERR("enable ps fail: %d\n", err); 
-						return -1;
-					}
-				}
-				else
-				{
-					if((tpd_enable_ps(0) != 0))
-					{
-						APS_ERR("disable ps fail: %d\n", err); 
-						return -1;
-					}
-				}
-			}
-			break;
-
-		case SENSOR_GET_DATA:
-			if((buff_out == NULL) || (size_out< sizeof(hwm_sensor_data)))
-			{
-				APS_ERR("get sensor data parameter error!\n");
-				err = -EINVAL;
-			}
-			else
-			{
-				
-				sensor_data = (hwm_sensor_data *)buff_out;				
-				
-				if((err = tpd_read_ps()))
-				{
-					err = -1;;
-				}
-				else
-				{
-					sensor_data->values[0] = tpd_get_ps_value();
-					TPD_PROXIMITY_DEBUG("huang sensor_data->values[0] 1082 = %d\n", sensor_data->values[0]);
-					sensor_data->value_divide = 1;
-					sensor_data->status = SENSOR_STATUS_ACCURACY_MEDIUM;
-				}	
-				
-			}
-			break;
-		default:
-			APS_ERR("proxmy sensor operate function no this parameter %d!\n", command);
-			err = -1;
-			break;
-	}
-	
-	return err;	
-}
-#endif
-
-#ifdef FTS_GESTRUE
-static void check_gesture(int gesture_id)
-{
-	
-    printk("kaka gesture_id==0x%x\n ",gesture_id);
-    
-	switch(gesture_id)
-	{
-		case GESTURE_LEFT:
-		      input_report_key(tpd->dev, KEY_LEFT, 1);
-			    input_sync(tpd->dev);
-			     input_report_key(tpd->dev, KEY_LEFT, 0);
-			    input_sync(tpd->dev);
-			break;
-		case GESTURE_RIGHT:
-		       input_report_key(tpd->dev, KEY_RIGHT, 1);
-			    input_sync(tpd->dev);
-			     input_report_key(tpd->dev, KEY_RIGHT, 0);
-			    input_sync(tpd->dev);
-			    
-			break;
-		case GESTURE_UP:
-			input_report_key(tpd->dev, KEY_UP, 1);
-			    input_sync(tpd->dev);
-			     input_report_key(tpd->dev, KEY_UP, 0);
-			    input_sync(tpd->dev);
-			    
-			break;
-		case GESTURE_DOWN:
-			input_report_key(tpd->dev, KEY_DOWN, 1);
-			    input_sync(tpd->dev);
-			     input_report_key(tpd->dev, KEY_DOWN, 0);
-			    input_sync(tpd->dev);
-			    
-			break;
-		case GESTURE_DOUBLECLICK:
-			input_report_key(tpd->dev, KEY_U, 1);
-			    input_sync(tpd->dev);
-			     input_report_key(tpd->dev, KEY_U, 0);
-			    input_sync(tpd->dev);
-			    
-			break;
-		case GESTURE_O:
-			input_report_key(tpd->dev, KEY_O, 1);
-			    input_sync(tpd->dev);
-			     input_report_key(tpd->dev, KEY_O, 0);
-			    input_sync(tpd->dev);
-			break;
-		case GESTURE_W:
-			input_report_key(tpd->dev, KEY_W, 1);
-			    input_sync(tpd->dev);
-			     input_report_key(tpd->dev, KEY_W, 0);
-			    input_sync(tpd->dev);
-			    
-			break;
-		case GESTURE_M:
-		input_report_key(tpd->dev, KEY_M, 1);
-			    input_sync(tpd->dev);
-			     input_report_key(tpd->dev, KEY_M, 0);
-			    input_sync(tpd->dev);
-			    
-			break;
-		case GESTURE_E:
-			input_report_key(tpd->dev, KEY_E, 1);
-			    input_sync(tpd->dev);
-			     input_report_key(tpd->dev, KEY_E, 0);
-			    input_sync(tpd->dev);
-			    
-			break;
-		case GESTURE_C:
-			input_report_key(tpd->dev, KEY_C, 1);
-			 input_sync(tpd->dev);
-			 input_report_key(tpd->dev, KEY_C, 0);
-			 input_sync(tpd->dev);
-			break;
-
-		case GESTURE_S:
-		input_report_key(tpd->dev, KEY_S, 1);
-		 input_sync(tpd->dev);
-		 input_report_key(tpd->dev, KEY_S, 0);
-		 input_sync(tpd->dev);
-		break;
-
-		case GESTURE_V:
-		input_report_key(tpd->dev, KEY_V, 1);
-		 input_sync(tpd->dev);
-		 input_report_key(tpd->dev, KEY_V, 0);
-		 input_sync(tpd->dev);
-		break;
-
-		case GESTURE_Z:
-		input_report_key(tpd->dev, KEY_Z, 1);
-		 input_sync(tpd->dev);
-		 input_report_key(tpd->dev, KEY_Z, 0);
-		 input_sync(tpd->dev);
-			break;
-		default:
-		
-			break;
-	}
-
-}
-
-static int ft5x0x_read_Touchdata(void)
-{
-    unsigned char buf[FTS_GESTRUE_POINTS * 4] = { 0 };
-    int ret = -1;
-    int i = 0;
-    buf[0] = 0xd3;
-    int gestrue_id = 0;
-    short pointnum = 0;
-    ret = fts_i2c_Read(i2c_client, buf, 1, buf, FTS_GESTRUE_POINTS_HEADER);
-    if (ret < 0)
-    {
-        printk( "%s read touchdata failed.\n", __func__);
-        return ret;
-    }
-    /* FW ????3??? */
-    if (0x24 == buf[0])
-    {
-        gestrue_id = 0x24;
-        check_gesture(gestrue_id);
-        return -1;
-    }
-
-    pointnum = (short)(buf[1]) & 0xff;
-    buf[0] = 0xd3;
-
-    ret = fts_i2c_Read(i2c_client, buf, 1, buf, (pointnum * 4 + 2));
-    if (ret < 0)
-    {
-        printk( "%s read touchdata failed.\n", __func__);
-        return ret;
-    }
-
-   gestrue_id = fetch_object_sample(buf, pointnum);
-   
-    for(i = 0;i < pointnum;i++)
-    {
-        coordinate_x[i] =  (((s16) buf[0 + (4 * i)]) & 0x0F) <<
-            8 | (((s16) buf[1 + (4 * i)])& 0xFF);
-        coordinate_y[i] = (((s16) buf[2 + (4 * i)]) & 0x0F) <<
-            8 | (((s16) buf[3 + (4 * i)]) & 0xFF);
-    }
-	check_gesture(gestrue_id);
-    return -1;
-}
-#endif
- static int touch_event_handler(void *unused)
- { 
-   	struct touch_info cinfo, pinfo;
-	int i=0;
-
-	struct sched_param param = { .sched_priority = RTPM_PRIO_TPD };
-	sched_setscheduler(current, SCHED_RR, &param);
-
-#ifdef TPD_PROXIMITY
-	int err;
-	hwm_sensor_data sensor_data;
-	u8 proximity_status;
-	
-#endif
-   u8 state;
-   
-	do
-	{
-		mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM); 
-		set_current_state(TASK_INTERRUPTIBLE); 
-		wait_event_interruptible(waiter,tpd_flag!=0);
-						 
-		tpd_flag = 0;
-			 
-		set_current_state(TASK_RUNNING);
-#ifdef FTS_GESTRUE
-i2c_smbus_read_i2c_block_data(i2c_client, 0xd0, 1, &state);
-// if((get_suspend_state() == PM_SUSPEND_MEM) && (state ==1))
- if(state ==1)
-     {
-        ft5x0x_read_Touchdata();
-        continue;
-    }
-#endif
-
-#ifdef TPD_PROXIMITY
-		if (tpd_proximity_flag == 1)
-		{
-			i2c_smbus_read_i2c_block_data(i2c_client, 0xB0, 1, &state);
-			TPD_PROXIMITY_DEBUG("proxi_5206 0xB0 state value is 1131 0x%02X\n", state);
-
-			if(!(state&0x01))
-			{
-				tpd_enable_ps(1);
-			}
-
-			i2c_smbus_read_i2c_block_data(i2c_client, 0x01, 1, &proximity_status);
-			TPD_PROXIMITY_DEBUG("proxi_5206 0x01 value is 1139 0x%02X\n", proximity_status);
-			
-			if (proximity_status == 0xC0)
-			{
-				tpd_proximity_detect = 0;	
-			}
-			else if(proximity_status == 0xE0)
-			{
-				tpd_proximity_detect = 1;
-			}
-
-			TPD_PROXIMITY_DEBUG("tpd_proximity_detect 1149 = %d\n", tpd_proximity_detect);
-
-			if ((err = tpd_read_ps()))
-			{
-				TPD_PROXIMITY_DMESG("proxi_5206 read ps data 1156: %d\n", err);	
-			}
-			sensor_data.values[0] = tpd_get_ps_value();
-			sensor_data.value_divide = 1;
-			sensor_data.status = SENSOR_STATUS_ACCURACY_MEDIUM;
-			if ((err = hwmsen_get_interrupt_data(ID_PROXIMITY, &sensor_data)))
-			{
-				TPD_PROXIMITY_DMESG(" proxi_5206 call hwmsen_get_interrupt_data failed= %d\n", err);	
-			}
-		}  
-#endif
-		 
-		if (tpd_touchinfo(&cinfo, &pinfo)) 
-		{
-		    //TPD_DEBUG("point_num = %d\n",point_num);
-			TPD_DEBUG_SET_TIME;
-			if(point_num >0) 
-			{
-			    for(i =0; i<point_num; i++)//only support 3 point
-			    {
-			         tpd_down(cinfo.x[i], cinfo.y[i], cinfo.id[i]);
-			    }
-			    input_sync(tpd->dev);
-			}
-			else  
-    		{
-			    tpd_up(cinfo.x[0], cinfo.y[0]);
-        	    //TPD_DEBUG("release --->\n"); 
-        	    //input_mt_sync(tpd->dev);
-        	    input_sync(tpd->dev);
-        		}
-        	}
-
-        	if(tpd_mode==12)
-        	{
-           //power down for desence debug
-           //power off, need confirm with SA
-#ifdef TPD_POWER_SOURCE_CUSTOM
-			hwPowerDown(TPD_POWER_SOURCE_CUSTOM, "TP");
-#else
-			hwPowerDown(MT65XX_POWER_LDO_VGP2, "TP");
-#endif
-#ifdef TPD_POWER_SOURCE_1800
-			hwPowerDown(TPD_POWER_SOURCE_1800, "TP");
-#endif 
-    		msleep(20);
-    	}
- 	}while(!kthread_should_stop());
- 
-	return 0;
-}
- 
-static int tpd_detect (struct i2c_client *client, struct i2c_board_info *info) 
-{
-	strcpy(info->type, TPD_DEVICE);	
-	return 0;
-}
- 
-static void tpd_eint_interrupt_handler(void)
-{
-	//TPD_DEBUG("TPD interrupt has been triggered\n");
-	TPD_DEBUG_PRINT_INT;
-	tpd_flag = 1;
-	wake_up_interruptible(&waiter);
-}
-
-void focaltech_get_upgrade_array(void)
-{
-
-	u8 chip_id;
-	u32 i;
-
-	i2c_smbus_read_i2c_block_data(i2c_client,FT_REG_CHIP_ID,1,&chip_id);
-
-	printk("%s chip_id = %x\n", __func__, chip_id);
-
-	for(i=0;i<sizeof(fts_updateinfo)/sizeof(struct Upgrade_Info);i++)
-	{
-		if(chip_id==fts_updateinfo[i].CHIP_ID)
-		{
-			memcpy(&fts_updateinfo_curr, &fts_updateinfo[i], sizeof(struct Upgrade_Info));
-			break;
-		}
-	}
-
-	if(i >= sizeof(fts_updateinfo)/sizeof(struct Upgrade_Info))
-	{
-		memcpy(&fts_updateinfo_curr, &fts_updateinfo[0], sizeof(struct Upgrade_Info));
-	}
-}
-
-static int tpd_probe(struct i2c_client *client, const struct i2c_device_id *id)
-{	 
-	int retval = TPD_OK;
-	char data;
-	u8 report_rate=0;
-	int err=0;
-	int reset_count = 0;
-	u8 chip_id,i;
-
-reset_proc:   
-	i2c_client = client;
-//add at 20150330 by zhu
-#if 1//def MAIERXUN_TP_COM
-    if(touchpanel_flag){
-	return 0;
-     }
-#endif
-//add at 20150330 by zhu end   
-	//power on, need confirm with SA
-       mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-       mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-       mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ZERO);  
-	msleep(5);
-	TPD_DMESG(" fts ic reset\n");
-	
-#ifdef TPD_POWER_SOURCE_CUSTOM
-	hwPowerOn(TPD_POWER_SOURCE_CUSTOM, VOL_2800, "TP");
-#else
-	hwPowerOn(MT65XX_POWER_LDO_VGP2, VOL_2800, "TP");
-#endif
-
-#if 0 //def TPD_POWER_SOURCE_1800
-	hwPowerOn(TPD_POWER_SOURCE_1800, VOL_1800, "TP");
-#endif 
-	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-       mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-       mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ONE);
-    
-#ifdef TPD_CLOSE_POWER_IN_SLEEP	 
-	hwPowerDown(TPD_POWER_SOURCE,"TP");
-	hwPowerOn(TPD_POWER_SOURCE,VOL_3300,"TP");
-	msleep(100);
-
-#else
-       mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-       mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-       mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ZERO);  
-	msleep(5);
-	TPD_DMESG(" fts ic reset\n");
-	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-       mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-       mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ONE);
-#endif
-
-	mt_set_gpio_mode(GPIO_CTP_EINT_PIN, GPIO_CTP_EINT_PIN_M_EINT);
-       mt_set_gpio_dir(GPIO_CTP_EINT_PIN, GPIO_DIR_IN);
-       mt_set_gpio_pull_enable(GPIO_CTP_EINT_PIN, GPIO_PULL_ENABLE);
-       mt_set_gpio_pull_select(GPIO_CTP_EINT_PIN, GPIO_PULL_UP);
- 
-//	mt65xx_eint_set_sens(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_SENSITIVE);
-	//mt_eint_set_hw_debounce(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_DEBOUNCE_CN);
-//	mt65xx_eint_registration(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_DEBOUNCE_EN, CUST_EINT_TOUCH_PANEL_POLARITY, tpd_eint_interrupt_handler, 1); 
-	mt_eint_registration(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_TYPE, tpd_eint_interrupt_handler, 1); 
-	mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
- 
-	msleep(400);
- 
-	//if((i2c_smbus_read_i2c_block_data(i2c_client, 0x00, 1, &data))< 0)
- ///////////////////////////////////////////////
-	err=i2c_smbus_read_i2c_block_data(i2c_client, 0x00, 1, &data);
-
-	TPD_DMESG("gao_i2c:err %d,data:%d\n", err,data);
-	if(err< 0 || data!=0)// reg0 data running state is 0; other state is not 0
-	{
-		TPD_DMESG("I2C transfer error, line: %d\n", __LINE__);
-#ifdef TPD_RESET_ISSUE_WORKAROUND
-        if ( reset_count < TPD_MAX_RESET_COUNT )
-        {
-            reset_count++;
-            goto reset_proc;
-        }
-#endif
-//add at 20150330 by zhu
-#if 1//def MAIERXUN_TP_COM
-	    touchpanel_flag=false;
-#endif
-//add at 20150330 by zhu end
-		   return -1; 
-	}
-
-	tpd_load_status = 1;
- //   tpd_mstar_status =0 ;  // compatible mstar and ft6306 chenzhecong
- 
-        focaltech_get_upgrade_array();
-
-	#ifdef FTS_APK_DEBUG
-	ft5x0x_create_apk_debug_channel(client);
-        #endif
-	#ifdef TPD_SYSFS_DEBUG
-	fts_create_sysfs(i2c_client);
-	#endif
-
-	#ifdef FTS_CTL_IIC
-	if (ft_rw_iic_drv_init(i2c_client) < 0)
-		printk("eroor\n");
-		//TPD_DMESG(TPD_DEVICE, "%s:[FTS] create fts control iic driver failed\n",__func__);
-	#endif
-
-	#ifdef FTS_GESTRUE
-	init_para(1080,1920,60,0,0);
-    //fts_write_reg(i2c_client, 0xd0, 0x01);
-        #endif
-	
-	#ifdef VELOCITY_CUSTOM_FT5206
-	if((err = misc_register(&tpd_misc_device)))
-	{
-		printk("mtk_tpd: tpd_misc_device register failed\n");
-		
-	}
-	#endif
-
-	#ifdef TPD_AUTO_UPGRADE
-	printk("********************Enter CTP Auto Upgrade********************\n");
-	fts_ctpm_auto_upgrade(i2c_client);
-	#endif
-	thread = kthread_run(touch_event_handler, 0, TPD_DEVICE);
-	if (IS_ERR(thread))
-	{ 
-		retval = PTR_ERR(thread);
-		TPD_DMESG(" failed to create kernel thread: %d\n", retval);
-	}
-
-	TPD_DMESG("FTS Touch Panel Device Probe %s\n", (retval < TPD_OK) ? "FAIL" : "PASS");
-
-#ifdef TPD_PROXIMITY
-	struct hwmsen_object obj_ps;
-	
-	obj_ps.polling = 0;//interrupt mode
-	obj_ps.sensor_operate = tpd_ps_operate;
-	if((err = hwmsen_attach(ID_PROXIMITY, &obj_ps)))
-	{
-		APS_ERR("proxi_fts attach fail = %d\n", err);
-	}
-	else
-	{
-		APS_ERR("proxi_fts attach ok = %d\n", err);
-	}		
-#endif
-//add at 20150330 by zhu
-#if 1//def MAIERXUN_TP_COM
-    touchpanel_flag=true;
-#endif
-//add at 20150330 by zhu end
-   return 0;
-   
- }
-
- static int tpd_remove(struct i2c_client *client)
-{
-
-        #ifdef FTS_APK_DEBUG
-	ft5x0x_release_apk_debug_channel();
-	#endif
-   	#ifdef TPD_SYSFS_DEBUG
-	fts_release_sysfs(client);
-	#endif
-
-	#ifdef FTS_CTL_IIC
-	ft_rw_iic_drv_exit();
-	#endif
-	
-	TPD_DEBUG("TPD removed\n");
- 
-   	return 0;
-}
- 
-static int tpd_local_init(void)
-{
-  	TPD_DMESG("FTS I2C Touchscreen Driver (Built %s @ %s)\n", __DATE__, __TIME__);
- 
-   	if(i2c_add_driver(&tpd_i2c_driver)!=0)
-   	{
-  		TPD_DMESG("FTS unable to add i2c driver.\n");
-      	return -1;
-    }
-    if(tpd_load_status == 0) 
-    {
-    	TPD_DMESG("FTS add error touch panel driver.\n");
-    	i2c_del_driver(&tpd_i2c_driver);
-    	return -1;
-    }
-	
-#ifdef TPD_HAVE_BUTTON     
-	//if(TPD_RES_Y > 854)
-	{
-	    tpd_button_setting(TPD_KEY_COUNT, tpd_keys_local, tpd_keys_dim_local);// initialize tpd button data
-	}
-	//else
-	{
-	    //tpd_button_setting(TPD_KEY_COUNT, tpd_keys_local, tpd_keys_dim_local_fwvga);// initialize tpd button data
-	}
-#endif   
-  
-#if (defined(TPD_WARP_START) && defined(TPD_WARP_END))    
-    TPD_DO_WARP = 1;
-    memcpy(tpd_wb_start, tpd_wb_start_local, TPD_WARP_CNT*4);
-    memcpy(tpd_wb_end, tpd_wb_start_local, TPD_WARP_CNT*4);
-#endif 
-
-#if (defined(TPD_HAVE_CALIBRATION) && !defined(TPD_CUSTOM_CALIBRATION))
-    memcpy(tpd_calmat, tpd_def_calmat_local, 8*4);
-    memcpy(tpd_def_calmat, tpd_def_calmat_local, 8*4);	
-#endif  
-    TPD_DMESG("end %s, %d\n", __FUNCTION__, __LINE__);  
-    tpd_type_cap = 1;
-    return 0; 
- }
-
- static void tpd_resume( struct early_suspend *h )
- {
-  //int retval = TPD_OK;
-  //char data;
-#ifdef TPD_PROXIMITY	
-	if (tpd_proximity_flag == 1)
-	{
-		if(tpd_proximity_flag_one == 1)
-		{
-			tpd_proximity_flag_one = 0;	
-			TPD_DMESG(" tpd_proximity_flag_one \n"); 
-			return;
-		}
-	}
-#endif	
- 
-   	TPD_DMESG("TPD wake up\n");
-
- #ifdef FTS_GESTRUE
-            fts_write_reg(i2c_client,0xD0,0x00);
-	    fts_write_reg(i2c_client,0xD1,0x00);
-	    fts_write_reg(i2c_client,0xD2,0x00);
-	   // return;
-#endif
-            #ifdef TPD_CLOSE_POWER_IN_SLEEP	
-        	hwPowerOn(TPD_POWER_SOURCE,VOL_3300,"TP");
-
-#else
-
-	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-    mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-    mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ZERO);  
-    msleep(2);  
-   // mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-   // mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-    mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ONE);
-#endif
-	mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);  
-	msleep(30);
-	tpd_halt = 0;
-	/* for resume debug
-	if((i2c_smbus_read_i2c_block_data(i2c_client, 0x00, 1, &data))< 0)
-	{
-		TPD_DMESG("resume I2C transfer error, line: %d\n", __LINE__);
-	}
-	*/
-	tpd_up(0,0);
-	input_sync(tpd->dev);
-	TPD_DMESG("TPD wake up done\n");
-	 //return retval;
- }
-
- static void tpd_suspend( struct early_suspend *h )
- {
-	// int retval = TPD_OK;
-	 static char data = 0x3;
-
-#ifdef TPD_PROXIMITY
-	if (tpd_proximity_flag == 1)
-	{
-		tpd_proximity_flag_one = 1;	
-		return;
-	}
-#endif
-#ifdef FTS_GESTRUE
-         fts_write_reg(i2c_client, 0xd0, 0x01);
-        fts_write_reg(i2c_client, 0xd1, 0x1f);
-        fts_write_reg(i2c_client, 0xd2, 0x1f);
-        return;
-#endif
-     	 tpd_halt = 1;
-
-	 TPD_DMESG("TPD enter sleep\n");
-	 mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
-#ifdef TPD_CLOSE_POWER_IN_SLEEP	
-	hwPowerDown(TPD_POWER_SOURCE,"TP");
-#else
-	mutex_lock(&i2c_access);
-	i2c_smbus_write_i2c_block_data(i2c_client, 0xA5, 1, &data);  //TP enter sleep mode
-	mutex_unlock(&i2c_access);
-#endif
-	TPD_DMESG("TPD enter sleep done\n");
-	//return retval;
- } 
-
-
- static struct tpd_driver_t tpd_device_driver = {
-	.tpd_device_name = TPD_NAME,
-	.tpd_local_init = tpd_local_init,
-	.suspend = tpd_suspend,
-	.resume = tpd_resume,
-#ifdef TPD_HAVE_BUTTON
-	.tpd_have_button = 1,
-#else
-	.tpd_have_button = 0,
-#endif		
- };
- /* called when loaded into kernel */
-static int __init tpd_driver_init(void) {
-	printk("MediaTek FTS touch panel driver init\n");
-	i2c_register_board_info(IIC_PORT, &ft5206_i2c_tpd, 1);
-	if(tpd_driver_add(&tpd_device_driver) < 0)
-		TPD_DMESG("add FTS driver failed\n");
-	 return 0;
- }
- 
- /* should never be called */
-static void __exit tpd_driver_exit(void) {
-	TPD_DMESG("MediaTek FTS touch panel driver exit\n");
-	//input_unregister_device(tpd->dev);
-	tpd_driver_remove(&tpd_device_driver);
-}
- 
-module_init(tpd_driver_init);
-module_exit(tpd_driver_exit);
-
-
diff --git a/drivers/input/touchscreen/mediatek/focaltech_qhd/tpd_custom_fts.h~ b/drivers/input/touchscreen/mediatek/focaltech_qhd/tpd_custom_fts.h~
deleted file mode 100755
index 3146cb1..0000000
--- a/drivers/input/touchscreen/mediatek/focaltech_qhd/tpd_custom_fts.h~
+++ /dev/null
@@ -1,162 +0,0 @@
-#ifndef TOUCHPANEL_H__
-#define TOUCHPANEL_H__
-
-#include <linux/hrtimer.h>
-#include <linux/string.h>
-#include <linux/vmalloc.h>
-//#include <linux/io.h>
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/delay.h>
-#include <linux/i2c.h>
-#include <linux/input.h>
-#include <linux/slab.h>
-#include <linux/gpio.h>
-#include <linux/sched.h>
-#include <linux/kthread.h>
-#include <linux/bitops.h>
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/byteorder/generic.h>
-#ifdef CONFIG_HAS_EARLYSUSPEND
-#include <linux/earlysuspend.h>
-#endif
-#include <linux/interrupt.h>
-#include <linux/time.h>
-#include <linux/rtpm_prio.h>
-
-#include <linux/proc_fs.h>
-#include <asm/uaccess.h>
-
-#include <mach/mt_pm_ldo.h>
-#include <mach/mt_typedefs.h>
-#include <mach/mt_boot.h>
-
-#include <linux/rtpm_prio.h>
-//#include "tpd.h"
-#include "cust_gpio_usage.h"
-#include <pmic_drv.h>
-#include <cust_eint.h>
-#include <linux/jiffies.h>
-
-struct Upgrade_Info {
-        u8 CHIP_ID;
-        u8 FTS_NAME[20];
-        u8 TPD_MAX_POINTS;
-        u8 AUTO_CLB;
-	u16 delay_aa;		/*delay of write FT_UPGRADE_AA */
-	u16 delay_55;		/*delay of write FT_UPGRADE_55 */
-	u8 upgrade_id_1;	/*upgrade id 1 */
-	u8 upgrade_id_2;	/*upgrade id 2 */
-	u16 delay_readid;	/*delay of read id */
-	u16 delay_earse_flash; /*delay of earse flash*/
-};
-//extern Upgrade_Info fts_updateinfo_curr;
-
-/**********************Custom define begin**********************************************/
-
-
-#define TPD_POWER_SOURCE_CUSTOM         PMIC_APP_CAP_TOUCH_VDD//MT6323_POWER_LDO_VGP1
-#define IIC_PORT                                            1//0  // 1   modify by jeff 20141112  //MT6572: 1  MT6589:0 , Based on the I2C index you choose for TPM
-
-//#define FTS_GESTRUE                                  // if need the gesture funtion,enable this MACRO
-#define TPD_PROXIMITY					// if need the PS funtion,enable this MACRO
-
-/*
-///// ***** virtual key  definition  ***** /////
-
-Below are the recommend  virtual key definition for different resolution TPM. 
-
-HVGA  320x480    2key ( (80,530);(240,530) )           3key  ( (80,530);(160;530);(240,530) )          4key   ( (40,530);(120;530);(200,530);(280,530)  ) 
-WVGA  480x800   2key ( (80,900);(400,900) )           3key  ( (80,900);(240,900);(400,900) )          4key   ( (60,900);(180;900);(300,900);(420,900)  ) 
-FWVGA 480x854  2key ( (80,900);(400,900) )           3key  ( (80,900);(240,900);(400,900) )          4key   ( (60,900);(180;900);(300,900);(420,900)  ) 
-QHD  540x960     2key ( (90,1080);(450,1080) )           3key  ( (90,1080);(270,1080);(450,1080) )          4key   ( (90,1080);(180;1080);(360,1080);(450,1080)  ) 
-HD    1280x720    2key ( (120,1350);(600,1350) )           3key  ( (120,1350);(360,1350);(600,1350) )          4key   ( (120,1080);(240;1080);(480,1080);(600,1080)  )
-FHD   1920x1080  2key ( (160,2100);(920,2100) )           3key  ( (160,2100);(540,2100);(920,2100) )          4key   ( (160,2100);(320;1080);(600,1080);(920,2100)  )
-*/
-#define TPD_HAVE_BUTTON	// if have virtual key,need define the MACRO
-#define TPD_BUTTON_WIDTH        (200)  //100
-#define TPD_BUTTON_HEIGH	(200)
-#define TPD_KEY_COUNT           1    //  4
-//#define TPD_KEYS                { KEY_FAKE_FINGERPRINT_UNLOCK/*KEY_MENU*/, KEY_HOMEPAGE, KEY_BACK}
-#define TPD_KEYS                {KEY_FINGER}
-//#define TPD_KEYS_DIM            	{{80,900,20,TPD_BUTTON_HEIGH}, {240,900,20,TPD_BUTTON_HEIGH}, {400,900,20,TPD_BUTTON_HEIGH}}
-#define TPD_KEYS_DIM            	{{60,1035,TPD_BUTTON_WIDTH,TPD_BUTTON_HEIGH}}
-/*********************Custom Define end*************************************************/
-
-#define TPD_NAME    "FT"
-
-/* Pre-defined definition */
-#define TPD_TYPE_CAPACITIVE
-#define TPD_TYPE_RESISTIVE
-#define TPD_POWER_SOURCE         
-#define TPD_I2C_NUMBER           		1//0
-#define TPD_WAKEUP_TRIAL         		60
-#define TPD_WAKEUP_DELAY         		100
-
-#define TPD_VELOCITY_CUSTOM_X 			15
-#define TPD_VELOCITY_CUSTOM_Y 			20
-
-
-
-
-#define TPD_DELAY                		(2*HZ/100)
-//#define TPD_RES_X                		480
-//#define TPD_RES_Y                		800
-#define TPD_CALIBRATION_MATRIX  		{962,0,0,0,1600,0,0,0};
-
-#define TPD_X_RES 	(540)
-#define TPD_Y_RES 	(960)
-#if 0
-#define TPD_WARP_Y(y) 	(TPD_RES_Y - y)
-#define TPD_WARP_X(x) 	(TPD_RES_X - x)
-#else
-#define TPD_WARP_Y(y) 	(y)
-#define TPD_WARP_X(x) 	(x)
-#endif
-
-//#define TPD_HAVE_CALIBRATION
-//#define TPD_HAVE_TREMBLE_ELIMINATION
-
-#define TPD_SYSFS_DEBUG
-#define FTS_CTL_IIC
-#define FTS_APK_DEBUG
-#ifdef TPD_SYSFS_DEBUG
-//#define TPD_AUTO_UPGRADE				// if need upgrade CTP FW when POWER ON,pls enable this MACRO
-#endif
-
-
-/******************************************************************************/
-/*Chip Device Type*/
-#define IC_FT5X06						0	/*x=2,3,4*/
-#define IC_FT5606						1	/*ft5506/FT5606/FT5816*/
-#define IC_FT5316						2	/*ft5x16*/
-#define IC_FT6208						3  	/*ft6208*/
-#define IC_FT6x06     					       4	/*ft6206/FT6306*/
-#define IC_FT5x06i     					5	/*ft5306i*/
-#define IC_FT5x36     					       6	/*ft5336/ft5436/FT5436i*/
-
-
-/*register address*/
-#define FT_REG_CHIP_ID				0xA3    //chip ID 
-#define FT_REG_FW_VER				0xA6   //FW  version 
-// TPA6A6
-#define FT_REG_VENDOR_ID			0xA8   // TP vendor ID 
-
-
-#define TPD_MAX_POINTS_2                        2
-#define TPD_MAX_POINTS_5                        5
-#define TPD_MAXPOINTS_10                        10
-#define AUTO_CLB_NEED                              1
-#define AUTO_CLB_NONEED                          0
-
-
-#define FTS_DBG
-#ifdef FTS_DBG
-#define DBG(fmt, args...) 				printk("[FTS]" fmt, ## args)
-#else
-#define DBG(fmt, args...) 				do{}while(0)
-#endif
-
-#endif /* TOUCHPANEL_H__ */
diff --git a/drivers/input/touchscreen/mediatek/focaltech_qhd_bat/Makefile~ b/drivers/input/touchscreen/mediatek/focaltech_qhd_bat/Makefile~
deleted file mode 100755
index 415dfce..0000000
--- a/drivers/input/touchscreen/mediatek/focaltech_qhd_bat/Makefile~
+++ /dev/null
@@ -1,18 +0,0 @@
-include $(srctree)/drivers/misc/mediatek/Makefile.custom
-
-
-#ccflags-y += -I$(MTK_PROJECT_PATH_ROOT)/touchpanel/ft6x36/
-# Linux driver folder
-#ccflags-y += -I$(srctree)/drivers/input/touchscreen/mediatek/$(MTK_PLATFORM)/$(ARCH_MTK_PROJECT)/ft6x36/
-#ccflags-y += -I$(srctree)/drivers/input/touchscreen/mediatek/
-ccflags-y += -I$(srctree)/drivers/misc/mediatek/mach/$(MTK_PLATFORM)/$(ARCH_MTK_PROJECT)/touchpanel/focaltech_qhd/
-ccflags-y += -I$(srctree)/arch/arm/mach-$(MTK_PLATFORM)/$(ARCH_MTK_PROJECT)/touchpanel/focaltech_qhd/
-ccflags-y += -I$(srctree)/drivers/input/touchscreen/mediatek/focaltech_qhd/
-ccflags-y += -I$(srctree)/drivers/input/touchscreen/mediatek/
-
-
-#obj-y := $(patsubst %.c,%.o,$(subst $(path)/,,$(call wildcard2,$(path)/*.c)))
-obj-y += focaltech_ctl.o
-obj-y += focaltech_driver.o
-obj-y += focaltech_ex_fun.o
-obj-y += ft_gesture_lib.a
diff --git a/drivers/input/touchscreen/mediatek/focaltech_qhd_bat/tpd_custom_fts.h~ b/drivers/input/touchscreen/mediatek/focaltech_qhd_bat/tpd_custom_fts.h~
deleted file mode 100755
index 17c3e2e..0000000
--- a/drivers/input/touchscreen/mediatek/focaltech_qhd_bat/tpd_custom_fts.h~
+++ /dev/null
@@ -1,170 +0,0 @@
-#ifndef TOUCHPANEL_H__
-#define TOUCHPANEL_H__
-
-#include <linux/hrtimer.h>
-#include <linux/string.h>
-#include <linux/vmalloc.h>
-//#include <linux/io.h>
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/delay.h>
-#include <linux/i2c.h>
-#include <linux/input.h>
-#include <linux/slab.h>
-#include <linux/gpio.h>
-#include <linux/sched.h>
-#include <linux/kthread.h>
-#include <linux/bitops.h>
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/byteorder/generic.h>
-#ifdef CONFIG_HAS_EARLYSUSPEND
-#include <linux/earlysuspend.h>
-#endif
-#include <linux/interrupt.h>
-#include <linux/time.h>
-#include <linux/rtpm_prio.h>
-
-#include <linux/proc_fs.h>
-#include <asm/uaccess.h>
-
-#include <mach/mt_pm_ldo.h>
-#include <mach/mt_typedefs.h>
-#include <mach/mt_boot.h>
-
-#include <cust_eint.h>
-#include <linux/jiffies.h>
-#include <pmic_drv.h>
-
-struct Upgrade_Info {
-        u8 CHIP_ID;
-        u8 FTS_NAME[20];
-        u8 TPD_MAX_POINTS;
-        u8 AUTO_CLB;
-	u16 delay_aa;		/*delay of write FT_UPGRADE_AA */
-	u16 delay_55;		/*delay of write FT_UPGRADE_55 */
-	u8 upgrade_id_1;	/*upgrade id 1 */
-	u8 upgrade_id_2;	/*upgrade id 2 */
-	u16 delay_readid;	/*delay of read id */
-	u16 delay_earse_flash; /*delay of earse flash*/
-};
-
-extern struct Upgrade_Info fts_updateinfo_curr;
-
-extern int fts_i2c_Read(struct i2c_client *client, char *writebuf,int writelen, char *readbuf, int readlen);
-extern int fts_i2c_Write(struct i2c_client *client, char *writebuf, int writelen);
-extern int fts_write_reg(struct i2c_client *client, u8 regaddr, u8 regvalue);
-extern int fts_read_reg(struct i2c_client *client, u8 regaddr, u8 *regvalue);
-extern void focaltech_get_upgrade_array(void);
-extern void fts_reset_tp(int HighOrLow);
-
-/**********************Custom define begin**********************************************/
-
-
-#define TPD_POWER_SOURCE_CUSTOM       PMIC_APP_CAP_TOUCH_VDD //ugrec_tky  MT6331_POWER_LDO_VGP1
-#define IIC_PORT                   1//MT6572: 1  MT6589:0 , Based on the I2C index you choose for TPM
-
-//#define FTS_GESTRUE                                  // if need the gesture funtion,enable this MACRO
-//#define TPD_PROXIMITY					// if need the PS funtion,enable this MACRO
-
-/*
-///// ***** virtual key  definition  ***** /////
-
-Below are the recommend  virtual key definition for different resolution TPM. 
-
-HVGA  320x480    2key ( (80,530);(240,530) )           3key  ( (80,530);(160;530);(240,530) )          4key   ( (40,530);(120;530);(200,530);(280,530)  ) 
-WVGA  480x800   2key ( (80,900);(400,900) )           3key  ( (80,900);(240,900);(400,900) )          4key   ( (60,900);(180;900);(300,900);(420,900)  ) 
-FWVGA 480x854  2key ( (80,900);(400,900) )           3key  ( (80,900);(240,900);(400,900) )          4key   ( (60,900);(180;900);(300,900);(420,900)  ) 
-QHD  540x960     2key ( (90,1080);(450,1080) )           3key  ( (90,1080);(270,1080);(450,1080) )          4key   ( (90,1080);(180;1080);(360,1080);(450,1080)  ) 
-HD    1280x720    2key ( (120,1350);(600,1350) )           3key  ( (120,1350);(360,1350);(600,1350) )          4key   ( (120,1080);(240;1080);(480,1080);(600,1080)  )
-FHD   1920x1080  2key ( (160,2100);(920,2100) )           3key  ( (160,2100);(540,2100);(920,2100) )          4key   ( (160,2100);(320;1080);(600,1080);(920,2100)  )
-*/
-#define TPD_HAVE_BUTTON	// if have virtual key,need define the MACRO
-#define TPD_BUTTON_HEIGH        (40)  //100
-#define TPD_KEY_COUNT           3    //  4
-#define TPD_KEYS                { KEY_MENU, KEY_HOMEPAGE, KEY_BACK}
-#define TPD_KEYS_DIM            	{{90,1350,20,TPD_BUTTON_HEIGH}, {360,1350,20,TPD_BUTTON_HEIGH}, {630,1350,20,TPD_BUTTON_HEIGH}}
-
-/*********************Custom Define end*************************************************/
-
-#define TPD_NAME    "FTS"
-
-/* Pre-defined definition */
-#define TPD_TYPE_CAPACITIVE
-#define TPD_TYPE_RESISTIVE
-#define TPD_POWER_SOURCE         
-#define TPD_I2C_NUMBER           		0
-#define TPD_WAKEUP_TRIAL         		60
-#define TPD_WAKEUP_DELAY         		100
-
-#define TPD_VELOCITY_CUSTOM_X 			15
-#define TPD_VELOCITY_CUSTOM_Y 			20
-
-#define CFG_MAX_TOUCH_POINTS	5
-#define MT_MAX_TOUCH_POINTS	10
-#define FT_MAX_ID	0x0F
-#define FT_TOUCH_STEP	6
-#define FT_FACE_DETECT_POS		1
-#define FT_TOUCH_X_H_POS		3
-#define FT_TOUCH_X_L_POS		4
-#define FT_TOUCH_Y_H_POS		5
-#define FT_TOUCH_Y_L_POS		6
-#define FT_TOUCH_EVENT_POS		3
-#define FT_TOUCH_ID_POS			5
-
-#define POINT_READ_BUF	(3 + FT_TOUCH_STEP * CFG_MAX_TOUCH_POINTS)
-
-
-#define TPD_DELAY                		(2*HZ/100)
-#define TPD_RES_X                		1080
-#define TPD_RES_Y                		1920
-#define TPD_CALIBRATION_MATRIX  		{962,0,0,0,1600,0,0,0};
-
-//#define TPD_HAVE_CALIBRATION
-//#define TPD_HAVE_TREMBLE_ELIMINATION
-
-#define TPD_SYSFS_DEBUG
-#define FTS_CTL_IIC
-#define FTS_APK_DEBUG
-#ifdef TPD_SYSFS_DEBUG
-//#define TPD_AUTO_UPGRADE				// if need upgrade CTP FW when POWER ON,pls enable this MACRO
-#endif
-
-//#define TPD_CLOSE_POWER_IN_SLEEP
-
-
-/******************************************************************************/
-/*Chip Device Type*/
-#define IC_FT5X06						0	/*x=2,3,4*/
-#define IC_FT5606						1	/*ft5506/FT5606/FT5816*/
-#define IC_FT5316						2	/*ft5x16*/
-#define IC_FT6208						3  	/*ft6208*/
-#define IC_FT6x06     					4	/*ft6206/FT6306*/
-#define IC_FT5x06i     					5	/*ft5306i*/
-#define IC_FT5x36     					6	/*ft5336/ft5436/FT5436i*/
-
-
-
-/*register address*/
-#define FTS_REG_CHIP_ID				0xA3    //chip ID 
-#define FTS_REG_FW_VER				0xA6   //FW  version 
-#define FTS_REG_VENDOR_ID			0xA8   // TP vendor ID 
-#define FTS_REG_POINT_RATE			0x88   //report rate	
-
-
-#define TPD_MAX_POINTS_2                        2
-#define TPD_MAX_POINTS_5                        5
-#define TPD_MAXPOINTS_10                        10
-#define AUTO_CLB_NEED                           1
-#define AUTO_CLB_NONEED                         0
-
-
-#define FTS_DBG
-#ifdef FTS_DBG
-#define DBG(fmt, args...) 				printk("[FTS]" fmt, ## args)
-#else
-#define DBG(fmt, args...) 				do{}while(0)
-#endif
-
-#endif /* TOUCHPANEL_H__ */
diff --git a/drivers/input/touchscreen/mediatek/ft6x06_qhd/Makefile~ b/drivers/input/touchscreen/mediatek/ft6x06_qhd/Makefile~
deleted file mode 100755
index 777c360..0000000
--- a/drivers/input/touchscreen/mediatek/ft6x06_qhd/Makefile~
+++ /dev/null
@@ -1,16 +0,0 @@
-include $(srctree)/drivers/misc/mediatek/Makefile.custom
-
-# Linux driver folder
-#ccflags-y += -I$(srctree)/drivers/misc/mediatek/mach/$(MTK_PLATFORM)/$(ARCH_MTK_PROJECT)/touchpanel/focaltech_hd/
-#ccflags-y += -I$(srctree)/arch/arm/mach-$(MTK_PLATFORM)/$(ARCH_MTK_PROJECT)/touchpanel/focaltech_hd/
-ccflags-y += -I$(srctree)/drivers/input/touchscreen/mediatek/ft6x06_qhd/
-ccflags-y += -I$(srctree)/drivers/input/touchscreen/mediatek/
-
-#obj-y += ft_gesture_lib.o
-#$(obj)/ft_gesture_lib.o: $(srctree)/../$(obj)/touchpanel/ft_gesture_lib.o
-#	cp $(srctree)/../$(obj)/touchpanel/ft_gesture_lib.o $(obj)/ft_gesture_lib.o
-
-obj-y	+=  ft6x06_driver.o
-#obj-y	+=  gt1x_tpd.o
-#obj-y	+=  gt1x_update.o
-
diff --git a/drivers/input/touchscreen/mediatek/ft6x06_qhd/ft6x06_driver.c~ b/drivers/input/touchscreen/mediatek/ft6x06_qhd/ft6x06_driver.c~
deleted file mode 100755
index b3e7cb9..0000000
--- a/drivers/input/touchscreen/mediatek/ft6x06_qhd/ft6x06_driver.c~
+++ /dev/null
@@ -1,1359 +0,0 @@
-//************************//
-//base on ft5206 from other people
-//************************//
-
-#include "tpd.h"
-#include <linux/interrupt.h>
-#include <cust_eint.h>
-#include <linux/i2c.h>
-#include <linux/sched.h>
-#include <linux/kthread.h>
-#include <linux/rtpm_prio.h>
-#include <linux/wait.h>
-#include <linux/time.h>
-#include <linux/delay.h>
-
-#include "tpd_custom_ft6x06.h"
-#ifdef MT6575
-#include <mach/mt6575_pm_ldo.h>
-#include <mach/mt6575_typedefs.h>
-#include <mach/mt6575_boot.h>
-#endif
-#include <mach/mt_pm_ldo.h>
-#include <mach/mt_typedefs.h>
-#include <mach/mt_boot.h>
-
-#include "cust_gpio_usage.h"
-
-
-#define TPD_PROXIMITY		//huangxi add 20130605
-
-#ifdef TPD_PROXIMITY
-#include <linux/hwmsensor.h>
-#include <linux/hwmsen_dev.h>
-#include <linux/sensors_io.h>
-  
-#define TPD_PROXIMITY_DEBUG
-#define TPD_PROXIMITY_DEVICE            "proximity-ft6x06"
-#define TPD_PROXIMITY_DMESG(a,arg...) printk(TPD_PROXIMITY_DEVICE ": " a,##arg)
-#if defined(TPD_PROXIMITY_DEBUG)
-#undef TPD_PROXIMITY_DEBUG
-#define TPD_PROXIMITY_DEBUG(a,arg...) printk(TPD_PROXIMITY_DEVICE ": " a,##arg)
-#else
-#define TPD_PROXIMITY_DEBUG(arg...) 
-#endif
-#define TPD_PROXIMITY_ENABLE_REG	0xB0
-static u8 tpd_proximity_flag = 0;
-static u8 tpd_proximity_detect = 1;//0-->close ; 1--> far away
-#endif
-
-
-
- #if defined(TPD_DEBUG)
-#undef TPD_DEBUG
-#define TPD_DEBUG(a,arg...) printk(TPD_DEVICE ": " a,##arg)
-#else
-#define TPD_DEBUG(arg...) 
-#endif
-
- 
-extern struct tpd_device *tpd;
- 
-struct i2c_client *i2c_client = NULL;
-struct task_struct *thread = NULL; 
- 
-static DECLARE_WAIT_QUEUE_HEAD(waiter);
- 
- 
-static void tpd_eint_interrupt_handler(void);
- 
- #if 0
- extern void mt65xx_eint_unmask(unsigned int line);
- extern void mt65xx_eint_mask(unsigned int line);
- extern void mt65xx_eint_set_hw_debounce(kal_uint8 eintno, kal_uint32 ms);
- extern kal_uint32 mt65xx_eint_set_sens(kal_uint8 eintno, kal_bool sens);
- extern void mt65xx_eint_registration(kal_uint8 eintno, kal_bool Dbounce_En,
-									  kal_bool ACT_Polarity, void (EINT_FUNC_PTR)(void),
-									  kal_bool auto_umask);
-
- #endif
-//#define TP_PROXIMITY_SENSOR		//jeff open 20140117
-
-#ifdef TP_PROXIMITY_SENSOR
-#define TPD_PROXIMITY_DEBUG
-#define TPD_PROXIMITY_DEVICE            "mtk-tpd-ft6x06"
-#define TPD_PROXIMITY_DMESG(a,arg...) printk(TPD_PROXIMITY_DEVICE ": " a,##arg)
-#if defined(TPD_PROXIMITY_DEBUG)
-#undef TPD_PROXIMITY_DEBUG
-#define TPD_PROXIMITY_DEBUG(a,arg...) printk(TPD_PROXIMITY_DEVICE ": " a,##arg)
-#else
-#define TPD_PROXIMITY_DEBUG(arg...)
-#endif
-#include <linux/hwmsensor.h>
-#include <linux/hwmsen_dev.h>
-#include <linux/sensors_io.h>
-static u8 tpd_proximity_flag = 0;
-static u8 tpd_proximity_detect = 1;//0-->close ; 1--> far away
-int CTP_NORMAL_FLAG = 1;
-u8 ft5206_proximity_stop_by_powerkey = 0;
-#endif
-
-//#define GT9XX_TP_PS	//jeff add 20140423
-#ifdef GT9XX_TP_PS
-#include <linux/hwmsensor.h>
-#include <linux/hwmsen_dev.h>
-#include <linux/sensors_io.h>
-
-//#define TPD_PROXIMITY_VALID_REG                   0x814E
-#define TPD_PROXIMITY_ENABLE_REG                  0xB0
-//0x8042
-static u8 tpd_proximity_flag = 0;
-static u8 tpd_proximity_detect = 1;//0-->close ; 1--> far away
-static u8 tpd_deep_sleep = 1;
-#endif
-
-
-static int tpd_probe(struct i2c_client *client, const struct i2c_device_id *id);
-static int tpd_detect(struct i2c_client *client, int kind, struct i2c_board_info *info);
-static int  tpd_remove(struct i2c_client *client);
-static int touch_event_handler(void *unused);
- 
-
-static int tpd_flag = 0;
-static int point_num = 0;
-static int p_point_num = 0;
-
-//#define TPD_CLOSE_POWER_IN_SLEEP
- 
-#define TPD_OK 0
-//register define
-#define tpd_lcd_width                TPD_RES_X
-//480
-#define tpd_lcd_height                TPD_RES_Y
-//854
-
-#define DEVICE_MODE 0x00
-#define GEST_ID 0x01
-#define TD_STATUS 0x02
-
-#define TOUCH1_XH 0x03
-#define TOUCH1_XL 0x04
-#define TOUCH1_YH 0x05
-#define TOUCH1_YL 0x06
-
-#define TOUCH2_XH 0x09
-#define TOUCH2_XL 0x0A
-#define TOUCH2_YH 0x0B
-#define TOUCH2_YL 0x0C
-
-#define TOUCH3_XH 0x0F
-#define TOUCH3_XL 0x10
-#define TOUCH3_YH 0x11
-#define TOUCH3_YL 0x12
-
-#ifdef TPD_HAVE_BUTTON 
-static int tpd_keys_local[TPD_KEY_COUNT] = TPD_KEYS;
-static int tpd_keys_dim_local[TPD_KEY_COUNT][4] = TPD_KEYS_DIM;
-#endif
-#if (defined(TPD_WARP_START) && defined(TPD_WARP_END))
-static int tpd_wb_start_local[TPD_WARP_CNT] = TPD_WARP_START;
-static int tpd_wb_end_local[TPD_WARP_CNT]   = TPD_WARP_END;
-#endif
-#if (defined(TPD_HAVE_CALIBRATION) && !defined(TPD_CUSTOM_CALIBRATION))
-static int tpd_calmat_local[8]     = TPD_CALIBRATION_MATRIX;
-static int tpd_def_calmat_local[8] = TPD_CALIBRATION_MATRIX;
-#endif
-//register define
-
-#define FSYSINFO	//jeff add 20140611
-#ifdef FSYSINFO
-static struct kobject *fsensor_sys_device;
-
-static unsigned short TPD_PROXIMITY_SWITCH_FLAG = 0;  // 0-->OFF   1-->ON
-
-//static u16 camera_i2c_id = 0x78; //OV5645_I2C_ADDR;
-//static unsigned long s_write_addr;
-//static DEVICE_ATTR(fwrite, 0666, write_camera_addr_show, write_camera_reg_store);
-//static unsigned long s_read_addr;
-static ssize_t read_camera_addr_show(struct device *dev,
-                struct device_attribute *attr,
-                char *buf)
-{
-    ssize_t rc = 0;
-//    kal_uint16 get_byte=0;
-
-//    iReadReg((u16) s_read_addr ,(u8*)&get_byte, camera_i2c_id);
-    sprintf(buf, "%d", TPD_PROXIMITY_SWITCH_FLAG);
-printk("Flag jeff tpd_ps TPD_PROXIMITY_SWITCH_FLAG=%d \n", TPD_PROXIMITY_SWITCH_FLAG);
-    rc = strlen(buf) + 1;
-
-    return rc;
-}
-static ssize_t read_camera_addr_store(struct device *dev,
-                struct device_attribute *attr,
-                const char *buf, size_t size)
-{
-    int rc = 0;
-
-    rc = kstrtoul(buf, 0, &TPD_PROXIMITY_SWITCH_FLAG);
-	printk("jeff tpd_ps SWITCH_FLAG=%d\n", TPD_PROXIMITY_SWITCH_FLAG);
-    if (rc)
-        return rc;
-
-    return size;
-}
-static DEVICE_ATTR(switch, 0666, read_camera_addr_show, read_camera_addr_store);
-//static DEVICE_ATTR(fsetid, 0666, set_id_camera_addr_show, set_id_camera_addr_store);
-
-static int init_sys_device_name(void)
-{
-    int rc = 0;
-    static int is_first_in = 1;
-
-    if (!is_first_in) {
-        return 0;
-    }
-	printk("jeff tpd_ps device reg.\n");
-    is_first_in = 0;
-    fsensor_sys_device = kobject_create_and_add("tpd_ps", NULL);	//"fsensor"
-    if (fsensor_sys_device == NULL) {
-        pr_info("%s: subsystem_register failed\n", __func__);
-        rc = -ENXIO;
-        return rc ;
-    }
-    rc = sysfs_create_file(fsensor_sys_device, &dev_attr_switch.attr);
-    if (rc) {
-        pr_info("%s: sysfs_create_file failed\n", __func__);
-        kobject_del(fsensor_sys_device);
-    }
-    return rc;
-}
-#endif
-
- 
-#ifdef TP_PROXIMITY_SENSOR
-static int tpd_get_ps_value(void)
-{
-	printk("tpd_proximity_detect=%d \r\n",tpd_proximity_detect);
-	return tpd_proximity_detect;
-}
-
-static int tpd_enable_ps(int enable)
-{
-	 static char wdata = 0x01;
-	 static char rdata = 0x00;
-//	 printk("[kktest]tpd_enable_ps:en=%d\r\n",enable);
-	if (enable)
-	{
-		i2c_smbus_write_i2c_block_data(i2c_client, 0xB0, 1, &wdata);
-		tpd_proximity_flag = 1;
-		ft5206_proximity_stop_by_powerkey = 0;   //clear ft5206_proximity_stop_by_powerkey by xuke 
-	}
-	else
-	{
-		 i2c_smbus_write_i2c_block_data(i2c_client, 0xB0, 1, &(rdata)); 
-		 tpd_proximity_flag = 0;
-	}
-	msleep(20);
-	return 0;
-}
-
-void ft5206_tpd_close_ps()
-{
-	hwm_sensor_data sensor_data;
-	s32 ret = -1;
-	if (tpd_proximity_detect == 0)
-	{
-//		printk("kktest ft5206_proximity_stop_by_powerkey set  1\n");
-		ft5206_proximity_stop_by_powerkey = 1;
-
-		tpd_proximity_detect = 1;	
-		
-		//tpd_eint_interrupt_handler();
-	}
-}
-
-static int tpd_ps_operate(void* self, uint32_t command, void* buff_in, int size_in,
-				   void* buff_out, int size_out, int* actualout)
-{
-	int err = 0;
-	int value;
-	hwm_sensor_data *sensor_data;
-
-	switch (command)
-	{
-	printk("tpd_ps_operate: command=%d, buff_in=%d\r\n",command,*(int *)buff_in);
-	case SENSOR_DELAY:
-		if((buff_in == NULL) || (size_in < sizeof(int)))
-		{
-			err = -EINVAL;
-		}
-		// Do nothing
-		break;
-
-	case SENSOR_ENABLE:
-		if((buff_in == NULL) || (size_in < sizeof(int)))
-		{
-			err = -EINVAL;
-		}
-		else
-		{
-			value = *(int *)buff_in;
-			if(value)
-			{
-				if((tpd_enable_ps(1) != 0))
-				{
-					TPD_PROXIMITY_DMESG("enable ps fail: %d\n", err);
-					return -1;
-				}
-			}
-			else
-			{
-				if((tpd_enable_ps(0) != 0))
-				{
-					TPD_PROXIMITY_DMESG("disable ps fail: %d\n", err);
-					return -1;
-				}
-			}
-		}
-		break;
-
-	case SENSOR_GET_DATA:
-		if((buff_out == NULL) || (size_out< sizeof(hwm_sensor_data)))
-		{
-			TPD_PROXIMITY_DMESG("get sensor data parameter error!\n");
-			err = -EINVAL;
-		}
-		else
-		{
-			sensor_data = (hwm_sensor_data *)buff_out;
-
-			sensor_data->values[0] = tpd_get_ps_value();
-			sensor_data->value_divide = 1;
-			sensor_data->status = SENSOR_STATUS_ACCURACY_MEDIUM;
-		}
-		break;
-
-	default:
-		TPD_PROXIMITY_DMESG("proxmy sensor operate function no this parameter %d!\n", command);
-		err = -1;
-		break;
-	}
-
-	return err;
-
-}
-#endif
-
-
-#ifdef GT9XX_TP_PS
-static s32 tpd_get_ps_value(void)
-{
-    return tpd_proximity_detect;
-}
-
-static int ft5x0x_i2c_txdata(char *txdata, int length)
-{
-    int ret;
-    struct i2c_msg msg[] =
-    {
-        {
-            .addr   = i2c_client->addr,
-            .flags  = 0,
-            .len    = length,
-            .buf    = txdata,
-        },
-    };
-    //msleep(1);
-    ret = i2c_transfer(i2c_client->adapter, msg, 1);
-
-    if(ret < 0)
-    {
-        pr_err("%s i2c write error: %d\n", __func__, ret);
-    }
-
-    return ret;
-}
-
-static int ft5x0x_write_reg(u8 addr, u8 para)
-{
-    u8 buf[3];
-    int ret = -1;
-    buf[0] = addr;
-    buf[1] = para;
-    ret = ft5x0x_i2c_txdata(buf, 2);
-
-    if(ret < 0)
-    {
-        pr_err("write reg failed! %#x ret: %d", buf[0], ret);
-        return -1;
-    }
-
-    return 0;
-}
-
-static s32 tpd_enable_ps(s32 enable)
-{
-    u8  state;
-    s32 ret = -1;
-
-    if (enable)
-    {
-        state = 1;
-        tpd_proximity_flag = 1;
-        printk("gt9xx jeff TPD proximity function to be on.\n");
-    }
-    else
-    {
-        state = 0;
-        tpd_proximity_flag = 0;
-        printk("gt9xx jeff TPD proximity function to be off.\n");
-    }
-
-//    ret = i2c_write_bytes(i2c_client_point, TPD_PROXIMITY_ENABLE_REG, &state, 1);
-	ret = ft5x0x_write_reg(TPD_PROXIMITY_ENABLE_REG, state);
-
-    if (ret < 0)
-    {
-        printk("gt9xx jeff TPD %s proximity cmd failed.", state ? "enable" : "disable");
-        return ret;
-    }
-
-    printk("gt9xx jeff TPD proximity function %s success.", state ? "enable" : "disable");
-    return 0;
-}
-
-s32 tpd_ps_operate(void *self, u32 command, void *buff_in, s32 size_in,
-                   void *buff_out, s32 size_out, s32 *actualout)
-{
-    s32 err = 0;
-    s32 value;
-    hwm_sensor_data *sensor_data;
-
-    switch (command)
-    {
-        case SENSOR_DELAY:
-            if ((buff_in == NULL) || (size_in < sizeof(int)))
-            {
-                printk("gt9xx jeff Set delay parameter error!");
-                err = -EINVAL;
-            }
-
-            // Do nothing
-            break;
-
-        case SENSOR_ENABLE:
-            if ((buff_in == NULL) || (size_in < sizeof(int)))
-            {
-                printk("gt9xx jeff Enable sensor parameter error!");
-                err = -EINVAL;
-            }
-            else
-            {
-                value = *(int *)buff_in;
-	#ifdef FSYSINFO	//jeff add 20140611
-		if (TPD_PROXIMITY_SWITCH_FLAG == 0){
-			printk("Flag jeff disable tpd_ps!!!00000000000!!!\n");
-			err = tpd_enable_ps(0);
-		} else {
-			printk("Flag jeff enable tpd_ps!!!11111111111!!!\n");
-			err = tpd_enable_ps(value);
-		}
-	#else
-                err = tpd_enable_ps(value);
-	#endif
-            }
-
-            break;
-
-        case SENSOR_GET_DATA:
-            if ((buff_out == NULL) || (size_out < sizeof(hwm_sensor_data)))
-            {
-                printk("gt9xx jeff Get sensor data parameter error!");
-                err = -EINVAL;
-            }
-            else
-            {
-                sensor_data = (hwm_sensor_data *)buff_out;
-                sensor_data->values[0] = tpd_get_ps_value();
-                sensor_data->value_divide = 1;
-                sensor_data->status = SENSOR_STATUS_ACCURACY_MEDIUM;
-            }
-
-            break;
-
-        default:
-            printk("gt9xx jeff proxmy sensor operate function no this parameter %d!\n", command);
-            err = -1;
-            break;
-    }
-
-    return err;
-}
-#endif
-
-
-struct touch_info {
-    int y[3];
-    int x[3];
-    int p[3];
-    int count;
-};
- 
- static const struct i2c_device_id tpd_id[] = {{TPD_DEVICE,0},{}};
- unsigned short force[] = {0,0x70,I2C_CLIENT_END,I2C_CLIENT_END}; 
- static const unsigned short * const forces[] = { force, NULL };
- //static struct i2c_client_address_data addr_data = { .forces = forces, };
- static struct i2c_board_info __initdata i2c_tpd={ I2C_BOARD_INFO(TPD_DEVICE, (0x70>>1))};
-  
- static struct i2c_driver tpd_i2c_driver = {
-	 .probe = tpd_probe,								   
-	 .remove = tpd_remove,							 
-	 .detect = tpd_detect,							 
-	 .driver.name = TPD_DEVICE, 
-	 .id_table = tpd_id,							 
-	 .address_list = (const unsigned short*) forces,					 
- };
-  
-
-#ifdef TPD_PROXIMITY
-static int ft5x0x_i2c_txdata(char *txdata, int length)
-{
-    int ret;
-    struct i2c_msg msg[] =
-    {
-        {
-            .addr   = i2c_client->addr,
-            .flags  = 0,
-            .len    = length,
-            .buf    = txdata,
-        },
-    };
-    //msleep(1);
-    ret = i2c_transfer(i2c_client->adapter, msg, 1);
-
-    if(ret < 0)
-    {
-        pr_err("%s i2c write error: %d\n", __func__, ret);
-    }
-
-    return ret;
-}
-
-static int ft5x0x_write_reg(u8 addr, u8 para)
-{
-    u8 buf[3];
-    int ret = -1;
-    buf[0] = addr;
-    buf[1] = para;
-    ret = ft5x0x_i2c_txdata(buf, 2);
-
-    if(ret < 0)
-    {
-        pr_err("write reg failed! %#x ret: %d", buf[0], ret);
-        return -1;
-    }
-
-    return 0;
-}
-
-static int tpd_get_ps_value(void)
-{
-	return tpd_proximity_detect;
-}
-
-static int tpd_enable_ps(int enable)
-{
-	u8 state;
-	int ret = -1;
-	if (enable){
-		state = 1;
-		tpd_proximity_flag = 1;
-		TPD_PROXIMITY_DEBUG("tpd-ps function is on\n");
-	}else{
-		state = 0;	
-		tpd_proximity_flag = 0;
-		TPD_PROXIMITY_DEBUG("tpd-ps function is off\n");
-	}
-	ft5x0x_write_reg(TPD_PROXIMITY_ENABLE_REG, state);
-	return 0;
-}
-
-int tpd_ps_operate(void* self, uint32_t command, void* buff_in, int size_in,
-		void* buff_out, int size_out, int* actualout)
-{
-	int err = 0;
-	int value;
-	hwm_sensor_data *sensor_data;
-	
-	switch (command)
-	{
-		case SENSOR_DELAY:
-			if((buff_in == NULL) || (size_in < sizeof(int)))
-			{
-				TPD_PROXIMITY_DMESG("Set delay parameter error!\n");
-				err = -EINVAL;
-			}
-			// Do nothing
-			TPD_PROXIMITY_DMESG("Set delay do nothing!\n");	//huangxi add 20130609
-			break;
-
-		case SENSOR_ENABLE:
-			if((buff_in == NULL) || (size_in < sizeof(int)))
-			{
-				TPD_PROXIMITY_DMESG("Enable sensor parameter error!\n");
-				err = -EINVAL;
-			}
-			else
-			{				
-				value = *(int *)buff_in;
-				if(value)
-				{
-					if((tpd_enable_ps(1) != 0))
-					{
-						TPD_PROXIMITY_DMESG("enable ps fail: %d\n", err); 
-						return -1;
-					}
-//					set_bit(CMC_BIT_PS, &obj->enable);
-				}
-				else
-				{
-					if((tpd_enable_ps(0) != 0))
-					{
-						TPD_PROXIMITY_DMESG("disable ps fail: %d\n", err); 
-						return -1;
-					}
-//					clear_bit(CMC_BIT_PS, &obj->enable);
-				}
-			}
-			break;
-
-		case SENSOR_GET_DATA:
-			if((buff_out == NULL) || (size_out< sizeof(hwm_sensor_data)))
-			{
-				TPD_PROXIMITY_DMESG("get sensor data parameter error!\n");
-				err = -EINVAL;
-			}
-			else
-			{
-				sensor_data = (hwm_sensor_data *)buff_out;				
-				
-				sensor_data->values[0] = tpd_get_ps_value();
-				sensor_data->value_divide = 1;
-				sensor_data->status = SENSOR_STATUS_ACCURACY_MEDIUM;		
-			}
-			break;
-			
-		default:
-			TPD_PROXIMITY_DMESG("proxmy sensor operate function no this parameter %d!\n", command);
-			err = -1;
-			break;
-	}
-	
-	return err;
-	
-}
-#endif
-
- 
-static  void tpd_down(int x, int y, int p) {
-	// input_report_abs(tpd->dev, ABS_PRESSURE, p);
-        if(y>0){//by zhu
-	 input_report_key(tpd->dev, BTN_TOUCH, 1);
-	 input_report_abs(tpd->dev, ABS_MT_TOUCH_MAJOR, 1);
-	 input_report_abs(tpd->dev, ABS_MT_POSITION_X, x);
-	 input_report_abs(tpd->dev, ABS_MT_POSITION_Y, y);
-	 //printk("D[%4d %4d %4d] ", x, y, p);
-	 input_mt_sync(tpd->dev);
-      }
-//remove at 20150327 by zhu for button
- //  if (FACTORY_BOOT == get_boot_mode()|| RECOVERY_BOOT == get_boot_mode())
-//remove at 20150327 by zhu for button end
-   {   
-       tpd_button(x, y, 1);  
-   }	 
-	 TPD_DOWN_DEBUG_TRACK(x,y);
- }
- 
-static  int tpd_up(int x, int y,int *count) {
-	 //if(*count>0) 
-	 if(y>0){//by zhu
-		 input_report_abs(tpd->dev, ABS_PRESSURE, 0);
-		 input_report_key(tpd->dev, BTN_TOUCH, 0);
-		 input_report_abs(tpd->dev, ABS_MT_TOUCH_MAJOR, 0);
-		 input_report_abs(tpd->dev, ABS_MT_POSITION_X, x);
-		 input_report_abs(tpd->dev, ABS_MT_POSITION_Y, y);
-		 //printk("U[%4d %4d %4d] ", x, y, 0);
-		 input_mt_sync(tpd->dev);
-		 TPD_UP_DEBUG_TRACK(x,y);
-	//	 (*count)--;
-	}
-//remove at 20150327 by zhu for button
- //    if (FACTORY_BOOT == get_boot_mode()|| RECOVERY_BOOT == get_boot_mode())
-//remove at 20150327 by zhu for button end
-     {   
-        tpd_button(x, y, 0); 
-     }   		 
-		 return 1;
-	 //} 
-          return 0;
- }
-
- static int tpd_touchinfo(struct touch_info *cinfo, struct touch_info *pinfo)
- {
- #ifdef TPD_PROXIMITY
-	int err;
-	hwm_sensor_data sensor_data;
-#endif
-
-	int i = 0;
-	char data[30] = {0};
-	u16 high_byte,low_byte;
-
-	p_point_num = point_num;
-
-	i2c_smbus_read_i2c_block_data(i2c_client, 0x00, 8, &(data[0]));
-	i2c_smbus_read_i2c_block_data(i2c_client, 0x08, 8, &(data[8]));
-	i2c_smbus_read_i2c_block_data(i2c_client, 0x10, 8, &(data[16]));
-	i2c_smbus_read_i2c_block_data(i2c_client, 0xa6, 1, &(data[24]));
-	TPD_DEBUG("FW version=%x]\n",data[24]);
-	
-	TPD_DEBUG("received raw data from touch panel as following:\n");
-	TPD_DEBUG("[data[0]=%x,data[1]= %x ,data[2]=%x ,data[3]=%x ,data[4]=%x ,data[5]=%x]\n",data[0],data[1],data[2],data[3],data[4],data[5]);
-	TPD_DEBUG("[data[9]=%x,data[10]= %x ,data[11]=%x ,data[12]=%x]\n",data[9],data[10],data[11],data[12]);
-	TPD_DEBUG("[data[15]=%x,data[16]= %x ,data[17]=%x ,data[18]=%x]\n",data[15],data[16],data[17],data[18]);
-
-#ifdef TPD_PROXIMITY	/* added by huangxi 20130607 */
-	if (tpd_proximity_flag == 1)
-	{
-		TPD_PROXIMITY_DEBUG("data[1]'s value is 0x%02X\n", data[1]);
-		if (data[1] == 0xC0)	//close to
-		{
-			tpd_proximity_detect = 0;
-		}
-		else if (data[1] == 0xE0)	//leave
-		{
-			tpd_proximity_detect = 1;
-		}
-		else
-		{
-			TPD_PROXIMITY_DMESG("ps read data error. data[1]=0x%02X \n", data[1]);
-		}
-		//get raw data
-		TPD_PROXIMITY_DEBUG(" ps change\n");
-		//map and store data to hwm_sensor_data
-	#if 0
-		sensor_data.values[0] = tpd_get_ps_value();
-		sensor_data.value_divide = 1;
-		sensor_data.status = SENSOR_STATUS_ACCURACY_MEDIUM;
-		//let up layer to know
-		if((err = hwmsen_get_interrupt_data(ID_PROXIMITY, &sensor_data)))
-		{
-			TPD_PROXIMITY_DMESG("call hwmsen_get_interrupt_data fail = %d\n", err);
-		}
-	#endif
-	}
-/*end of added*/   
-#endif	
-
-
-	
-	/* Device Mode[2:0] == 0 :Normal operating Mode*/
-	if(data[0] & 0x70 != 0) return false; 
-
-	/*get the number of the touch points*/
-	point_num= data[2] & 0x0f;
-	
-	TPD_DEBUG("point_num =%d\n",point_num);
-	
-//	if(point_num == 0) return false;
-
-	   TPD_DEBUG("Procss raw data...\n");
-
-		
-		for(i = 0; i < point_num; i++)
-		{
-			cinfo->p[i] = data[3+6*i] >> 6; //event flag 
-
-	       /*get the X coordinate, 2 bytes*/
-			high_byte = data[3+6*i];
-			high_byte <<= 8;
-			high_byte &= 0x0f00;
-			low_byte = data[3+6*i + 1];
-			cinfo->x[i] = high_byte |low_byte;
-
-				//cinfo->x[i] =  cinfo->x[i] * 480 >> 11; //calibra
-		
-			/*get the Y coordinate, 2 bytes*/
-			
-			high_byte = data[3+6*i+2];
-			high_byte <<= 8;
-			high_byte &= 0x0f00;
-			low_byte = data[3+6*i+3];
-			cinfo->y[i] = high_byte |low_byte;
-
-			  //cinfo->y[i]=  cinfo->y[i] * 800 >> 11;
-		
-			cinfo->count++;
-
-			if (cinfo->y[i] <= TPD_RES_Y) 	//jeff add 20140827
-			{	
-				cinfo->x[i] = TPD_WARP_X(cinfo->x[i]);
-				cinfo->y[i] = TPD_WARP_Y(cinfo->y[i]);
-			}
-			
-		}
-		TPD_DEBUG(" cinfo->x[0] = %d, cinfo->y[0] = %d, cinfo->p[0] = %d\n", cinfo->x[0], cinfo->y[0], cinfo->p[0]);	
-		TPD_DEBUG(" cinfo->x[1] = %d, cinfo->y[1] = %d, cinfo->p[1] = %d\n", cinfo->x[1], cinfo->y[1], cinfo->p[1]);		
-		TPD_DEBUG(" cinfo->x[2]= %d, cinfo->y[2]= %d, cinfo->p[2] = %d\n", cinfo->x[2], cinfo->y[2], cinfo->p[2]);	
-		  
-	 return true;
-
- };
-
-static u8 reset_tpd_ps = 5;
-
- static int touch_event_handler(void *unused)
- {
-  
-    struct touch_info cinfo, pinfo;
-	#ifdef TP_PROXIMITY_SENSOR
-	int err;
-	hwm_sensor_data sensor_data;
-	static char rdata = 0x00;
-	#endif
-
-#ifdef GT9XX_TP_PS
-	s32 err = 0;
-	int ret;
-	hwm_sensor_data sensor_data;
-	u8 proximity_status;
-	static char rdata = 0x00;
-#endif
-
-	 struct sched_param param = { .sched_priority = RTPM_PRIO_TPD };
-	 sched_setscheduler(current, SCHED_RR, &param);
- 
-	 do
-	 {
-	  mt65xx_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM); 
-
-	        printk("FT5206 touch_event_handler \r\n");
-		 set_current_state(TASK_INTERRUPTIBLE); 
-		  wait_event_interruptible(waiter,tpd_flag!=0);
-						 
-			 tpd_flag = 0;
-			 
-		 set_current_state(TASK_RUNNING);
-		 
-
-#ifdef TP_PROXIMITY_SENSOR
-
-//						if (tpd_proximity_flag == 1) {printk("[kktest] ps enable \r\n");}
-						if (ft5206_proximity_stop_by_powerkey == 1)
-						{
-//							printk("[kktest]PROXIMITY STATUS:0x%02X\n", tpd_proximity_detect);
-							sensor_data.values[0] = 1;
-							sensor_data.value_divide = 1;
-							sensor_data.status = SENSOR_STATUS_ACCURACY_MEDIUM;
-							hwmsen_get_interrupt_data(ID_PROXIMITY, &sensor_data);
-							ft5206_proximity_stop_by_powerkey = 2;		
-						}
-						else if (ft5206_proximity_stop_by_powerkey == 2)
-						{
-							tpd_enable_ps(0);
-							ft5206_proximity_stop_by_powerkey = 3;
-//							printk("[kktest] tpd_enable_ps : 0 \n");
-						}
-						else if (ft5206_proximity_stop_by_powerkey == 3)
-						{
-						}						
-						else
-						{
-						  if (tpd_proximity_flag == 1)
-						  {
-						         i2c_smbus_read_i2c_block_data(i2c_client, 0x01, 1, &rdata);
-
-//							  printk("[kktest] ft5206 0x01=%x  i2c_client = %d \r\n",rdata,i2c_client);
-							  
-							  if((rdata == 0xe0) ||(rdata == 0xc0))
-							  {
-								  if(rdata == 0xe0)// leave
-								  {
-									  tpd_proximity_detect = 1;
-								  }
-								  else  if(rdata == 0xc0) // close to
-								  {
-									  tpd_proximity_detect = 0;
-								  }
-								  //get raw data
-								  TPD_PROXIMITY_DEBUG(" ps change\n");
-								  //map and store data to hwm_sensor_data
-								  sensor_data.values[0] = tpd_get_ps_value();
-								  sensor_data.value_divide = 1;
-								  sensor_data.status = SENSOR_STATUS_ACCURACY_MEDIUM;
-								  //let up layer to know
-								  if((err = hwmsen_get_interrupt_data(ID_PROXIMITY, &sensor_data)))
-								  {
-									  //TPD_PROXIMITY_DMESG("call hwmsen_get_interrupt_data fail = %d\n", err);
-								  }
-								  if (rdata == 0xe0)
-								  	{
-								  			 static char wdata = 0x01;
-											 static char rdata = 0x00;
-											  i2c_smbus_write_i2c_block_data(i2c_client, 0xB0, 1, &(rdata)); 
-											  msleep(40);
-											  i2c_smbus_write_i2c_block_data(i2c_client, 0xB0, 1, &wdata);
-											  msleep(40);
-
-//											  printk("[kktest] tp reset for rdata == 0xe0 start reset tpd_ps \r\n");
-	 
-								  	}
-								  //return  false;
-							  }		
-							  else if (rdata == 0x00)
-							  	{
-								  			 static char wdata = 0x01;
-											 static char rdata = 0x00;
-											  i2c_smbus_write_i2c_block_data(i2c_client, 0xB0, 1, &(rdata)); 
-											  msleep(40);
-											  i2c_smbus_write_i2c_block_data(i2c_client, 0xB0, 1, &wdata);
-											  msleep(40);
-
-//											  printk("[kktest] tp reset for rdata == 0x0 start reset tpd_ps \r\n");
-							  	}
-						  }
-						}
-#endif
-
-
-#ifdef GT9XX_TP_PS
-	if (tpd_proximity_flag == 1)
-	{
-	//	proximity_status = point_data[GTP_ADDR_LENGTH];
-	//	GTP_DEBUG("REG INDEX[0x814E]:0x%02X\n", proximity_status);
-
-	//	if (proximity_status & 0x60)                //proximity or large touch detect,enable hwm_sensor.
-	//	{
-	//		tpd_proximity_detect = 0;
-			//sensor_data.values[0] = 0;
-	//	}
-	//	else
-	//	{
-	//		tpd_proximity_detect = 1;
-			//sensor_data.values[0] = 1;
-	//	}
-		i2c_smbus_read_i2c_block_data(i2c_client, 0x01, 1, &rdata);
-		if(rdata == 0xe0)// leave
-		{
-			tpd_proximity_detect = 1;
-		}
-		else  if(rdata == 0xc0) // close to
-		{
-			tpd_proximity_detect = 0;
-		}
-
-		//get raw data
-		printk("gt9xx jeff  ps change\n");
-		printk("gt9xx jeff PROXIMITY STATUS:0x%02X\n", tpd_proximity_detect);
-		//map and store data to hwm_sensor_data
-		sensor_data.values[0] = tpd_get_ps_value();
-		sensor_data.value_divide = 1;
-		sensor_data.status = SENSOR_STATUS_ACCURACY_MEDIUM;
-		//report to the up-layer
-		ret = hwmsen_get_interrupt_data(ID_PROXIMITY, &sensor_data);
-
-		if (ret)
-		{
-			printk("gt9xx jeff Call hwmsen_get_interrupt_data fail = %d\n", err);
-		}
-	}
-
-#endif
-
-
-
-		  if (tpd_touchinfo(&cinfo, &pinfo)) {
-		  TPD_DEBUG("point_num = %d\n",point_num);
-		  
-		if(point_num >0){
-			tpd_down(tpd_lcd_width-cinfo.x[0], tpd_lcd_height - cinfo.y[0], 1);
-		if(point_num>1){
-			tpd_down(tpd_lcd_width-cinfo.x[1], tpd_lcd_height - cinfo.y[1], 1);
-		if(point_num >2)
-			tpd_down(tpd_lcd_width-cinfo.x[2], tpd_lcd_height - cinfo.y[2], 1);
-				}
-		input_sync(tpd->dev);
-		TPD_DEBUG("press --->\n");
-
-		} else  {
-		tpd_up(tpd_lcd_width-cinfo.x[0], tpd_lcd_height - cinfo.y[0]	, 0);
-		TPD_DEBUG("release --->\n"); 
-		input_mt_sync(tpd->dev);
-		input_sync(tpd->dev);
-		} 
-        }
-
- }while(!kthread_should_stop());
- 
-	 return 0;
- }
- 
- static int tpd_detect (struct i2c_client *client, int kind, struct i2c_board_info *info) 
- {
-	 strcpy(info->type, TPD_DEVICE);	
-	  return 0;
- }
- 
- static void tpd_eint_interrupt_handler(void)
- {
-	// TPD_DEBUG("TPD interrupt has been triggered\n");
-//	printk("[kktest] --- %s ---\n", __func__);
-	//printk("FT5206 TPD interrupt has been triggered\n");
-	 tpd_flag = 1;
-	 wake_up_interruptible(&waiter);
-	 
- }
- #ifdef TPD_AUTO_UPGRADE_SUPPORT
- extern int tpd_auto_upgrade(struct i2c_client *client);
- #endif
- static int tpd_probe(struct i2c_client *client, const struct i2c_device_id *id)
- {	
- #ifdef TPD_PROXIMITY
-	int err;
-	struct hwmsen_object obj_ps;
-#endif
-
-	int retval = TPD_OK;
-	char data;
-#ifdef TP_PROXIMITY_SENSOR
-	int err=0;
-		struct hwmsen_object obj_ps;
-#endif
-
-#ifdef GT9XX_TP_PS
-	int err;
-	struct hwmsen_object obj_ps;
-#endif
-
-	i2c_client = client;
-	printk("FT5206 tpd_probe \r'\n");
-      hwPowerOn(PMIC_APP_CAP_TOUCH_VDD, VOL_2800, "TP");
-#ifdef MT6575
-    //power on, need confirm with SA
-    hwPowerOn(PMIC_APP_CAP_TOUCH_VDD, VOL_2800, "TP");
-    hwPowerOn(PMIC_APP_CAP_TOUCH_VDD, VOL_1800, "TP");      
-#endif	
-	#ifdef TPD_CLOSE_POWER_IN_SLEEP	 
-	hwPowerDown(TPD_POWER_SOURCE,"TP");
-	hwPowerOn(TPD_POWER_SOURCE,VOL_3300,"TP");
-	msleep(100);
-	#else
-	#ifdef MT6573
-	mt_set_gpio_mode(GPIO_CTP_EN_PIN, GPIO_CTP_EN_PIN_M_GPIO);
-  mt_set_gpio_dir(GPIO_CTP_EN_PIN, GPIO_DIR_OUT);
-	mt_set_gpio_out(GPIO_CTP_EN_PIN, GPIO_OUT_ONE);
-	msleep(100);
-	#endif
-	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-    mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-    mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ONE);
-	#endif
-
-	// reset
-	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-	mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-	mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ZERO);
-	msleep(1);
-
-	mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ONE);
-	msleep(50);
-      // set deep sleep off
-      mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-      mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-      mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ONE);  
-      msleep(10);  
-
-
-	mt_set_gpio_mode(GPIO_CTP_EINT_PIN, GPIO_CTP_EINT_PIN_M_EINT);
-    mt_set_gpio_dir(GPIO_CTP_EINT_PIN, GPIO_DIR_IN);
-    mt_set_gpio_pull_enable(GPIO_CTP_EINT_PIN, GPIO_PULL_ENABLE);
-    mt_set_gpio_pull_select(GPIO_CTP_EINT_PIN, GPIO_PULL_UP);
- 
-	  mt65xx_eint_set_sens(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_SENSITIVE);
-	  mt65xx_eint_set_hw_debounce(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_DEBOUNCE_CN);
-	  mt65xx_eint_registration(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_DEBOUNCE_EN, CUST_EINT_TOUCH_PANEL_POLARITY, tpd_eint_interrupt_handler, 1); 
-	  
-	  //mt65xx_eint_registration(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_DEBOUNCE_EN, CUST_EINT_POLARITY_HIGH, tpd_eint_interrupt_handler, 1); 
-	  
-	  mt65xx_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
-
-	msleep(100);
-	
-#ifdef TPD_PROXIMITY
-//	if(!(obj2 = kzalloc(sizeof(*obj2), GFP_KERNEL)))
-//	{
-//		err = -ENOMEM;
-	//	goto exit;
-//	}
-//	memset(obj2, 0, sizeof(struct wxt_proximity_priv));
-
-//	obj_ps.polling = 0;//interrupt mode
-//	obj_ps.self = obj2;	//huangxi add 20130608
-	obj_ps.polling = 1;//polling mode	//huangxi modify 20130608
-	obj_ps.sensor_operate = tpd_ps_operate;
-	if((err = hwmsen_attach(ID_PROXIMITY, &obj_ps)))
-	{
-		TPD_PROXIMITY_DMESG("attach fail = %d\n", err);
-//		goto exit_create_attr_failed;
-	}		
-#endif
-
-	
- #if 0
-	if((i2c_smbus_read_i2c_block_data(i2c_client, 0x00, 1, &data))< 0)
-	   {
-		   TPD_DMESG("FT5206 I2C transfer error, line: %d\n", __LINE__);
-		   return -1; 
-	   }
-#endif
-	tpd_load_status = 1;
-#ifdef TPD_AUTO_UPGRADE_SUPPORT
-	//tpd_auto_upgrade(i2c_client);
-#endif
-
-	thread = kthread_run(touch_event_handler, 0, TPD_DEVICE);
-	 if (IS_ERR(thread))
-		 { 
-		  retval = PTR_ERR(thread);
-		  TPD_DMESG(TPD_DEVICE " failed to create kernel thread: %d\n", retval);
-		}
-
-	TPD_DMESG("Touch Panel Device Probe %s\n", (retval < TPD_OK) ? "FAIL" : "PASS");
-#ifdef TP_PROXIMITY_SENSOR
-		obj_ps.polling = 0;//interrupt mode
-		obj_ps.sensor_operate = tpd_ps_operate;
-		if((err = hwmsen_attach(ID_PROXIMITY, &obj_ps)))
-		{
-			printk("zhuoshineng gt868 proximity attach fail = %d\n", err);
-			//		goto exit_create_attr_failed;
-		}
-#endif
-
-#ifdef GT9XX_TP_PS
-    //obj_ps.self = cm3623_obj;
-    obj_ps.polling = 0;         //0--interrupt mode;1--polling mode;
-    obj_ps.sensor_operate = tpd_ps_operate;
-
-    if ((err = hwmsen_attach(ID_PROXIMITY, &obj_ps)))
-    {
-        printk("gt9xx jeff hwmsen attach fail, return:%d.", err);
-    }
-
-#endif
-
-#ifdef FSYSINFO
-	init_sys_device_name();
-#endif
-
-   return 0;
-   
- }
-
- static int  tpd_remove(struct i2c_client *client)
- 
- {
-
-	 TPD_DEBUG("TPD removed\n");
- 
-   return 0;
- }
- 
- 
- static int tpd_local_init(void)
- {
-
-
-  TPD_DMESG("Focaltech FT5206 I2C Touchscreen Driver (Built %s @ %s)\n", __DATE__, __TIME__);
- 
- 
-   if(i2c_add_driver(&tpd_i2c_driver)!=0)
-   	{
-  		TPD_DMESG("unable to add i2c driver.\n");
-      	return -1;
-    }
-#ifdef TPD_HAVE_BUTTON     
-    tpd_button_setting(TPD_KEY_COUNT, tpd_keys_local, tpd_keys_dim_local);// initialize tpd button data
-#endif   
-  
-#if (defined(TPD_WARP_START) && defined(TPD_WARP_END))    
-    TPD_DO_WARP = 1;
-    memcpy(tpd_wb_start, tpd_wb_start_local, TPD_WARP_CNT*4);
-    memcpy(tpd_wb_end, tpd_wb_start_local, TPD_WARP_CNT*4);
-#endif 
-
-#if (defined(TPD_HAVE_CALIBRATION) && !defined(TPD_CUSTOM_CALIBRATION))
-    memcpy(tpd_calmat, tpd_def_calmat_local, 8*4);
-    memcpy(tpd_def_calmat, tpd_def_calmat_local, 8*4);	
-#endif  
-		TPD_DMESG("end %s, %d\n", __FUNCTION__, __LINE__);  
-		tpd_type_cap = 1;
-    return 0; 
- }
-
- static int tpd_resume(struct i2c_client *client)
- {
-  int retval = TPD_OK;
-#ifdef TPD_PROXIMITY
-	if ((tpd_proximity_flag == 1) || (tpd_proximity_detect == 0))
-	{
-		TPD_PROXIMITY_DMESG("TPD wake up, but don't anything. flag=%d, detect=%d.\n", tpd_proximity_flag, tpd_proximity_detect);
-		return 0;
-	}
-#endif
-
-#ifdef GT9XX_TP_PS
-//    if (tpd_proximity_flag == 1)
-//    {
-//    	printk("jeff TPD wake up, but don't anything. flag=%d, detect=%d.\n", tpd_proximity_flag, tpd_proximity_detect);
-//        return 0;
-//    }
-    if (tpd_deep_sleep == 0)	//the system didn't really go into deep sleep. So, return directly.
-        return 0;
-#endif
-
-   printk("[jeff test] --- %s --- wake up! tpd_ps_flag=%d, tpd_ps_detect=%d \n", __func__, tpd_proximity_flag, tpd_proximity_detect);	//jeff modify 20140807
-   TPD_DEBUG("TPD wake up\n");
-#ifdef TPD_CLOSE_POWER_IN_SLEEP	
-	hwPowerOn(TPD_POWER_SOURCE,VOL_3300,"TP"); 
-#else
-#ifdef MT6573
-	mt_set_gpio_mode(GPIO_CTP_EN_PIN, GPIO_CTP_EN_PIN_M_GPIO);
-    mt_set_gpio_dir(GPIO_CTP_EN_PIN, GPIO_DIR_OUT);
-	mt_set_gpio_out(GPIO_CTP_EN_PIN, GPIO_OUT_ONE);
-#endif	
-	msleep(100);
-#ifdef TP_PROXIMITY_SENSOR
-if(CTP_NORMAL_FLAG ==1)
-{
-	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-	mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-	mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ZERO);  
-	msleep(1);  
-	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-	mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-	mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ONE);
-
-	mt65xx_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);  	
-
-	CTP_NORMAL_FLAG = 0;
-
-}
-
-#else
-	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-	mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-	mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ZERO);  
-	msleep(1);  
-	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-	mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-	mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ONE);
-	mt65xx_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);  
-
-#endif
-   
-#endif	
-	
-	 return retval;
- }
- 
- static int tpd_suspend(struct i2c_client *client, pm_message_t message)
- {
-	 int retval = TPD_OK;
-	 static char data = 0x3;
- #ifdef TPD_PROXIMITY
-	if ((tpd_proximity_flag == 1) || (tpd_proximity_detect == 0))
-	{
-		TPD_PROXIMITY_DMESG("TPD don't enter sleep. flag=%d, detect=%d.\n", tpd_proximity_flag, tpd_proximity_detect);
-		return 0;
-	}
-#endif
-//printk("[kktest] --- %s ---\n", __func__);
-
-#ifdef GT9XX_TP_PS
-
-    if (tpd_proximity_flag == 1)
-    {
-    	printk("jeff TPD don't enter sleep. flag=%d, detect=%d.\n", tpd_proximity_flag, tpd_proximity_detect);
-    	tpd_deep_sleep = 0;
-        return 0;
-    }
-    tpd_deep_sleep = 1;
-#endif
-
-   printk("[jeff test] -%s- enter sleep! tpd_ps_flag=%d, tpd_ps_detect=%d \n", __func__, tpd_proximity_flag, tpd_proximity_detect);	//jeff modify 20140807
-	 
-#ifdef TPD_CLOSE_POWER_IN_SLEEP	
-	hwPowerDown(TPD_POWER_SOURCE,"TP");
-#else
-#ifdef TP_PROXIMITY_SENSOR
-if(tpd_proximity_flag == 0)
-{
-	mt65xx_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
-
-	
-	i2c_smbus_write_i2c_block_data(i2c_client, 0xA5, 1, &data);  //TP enter sleep mode
-	CTP_NORMAL_FLAG =1;
-}
-#else
-	 TPD_DEBUG("TPD enter sleep\n");
-	 mt65xx_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
-
-	i2c_smbus_write_i2c_block_data(i2c_client, 0xA5, 1, &data);  //TP enter sleep mode
-#endif
-#ifdef MT6573
-mt_set_gpio_mode(GPIO_CTP_EN_PIN, GPIO_CTP_EN_PIN_M_GPIO);
-mt_set_gpio_dir(GPIO_CTP_EN_PIN, GPIO_DIR_OUT);
-mt_set_gpio_out(GPIO_CTP_EN_PIN, GPIO_OUT_ZERO);
-#endif
-
-#endif
-	 return retval;
- } 
-
-
- static struct tpd_driver_t tpd_device_driver = {
-		 .tpd_device_name = "FT5206",
-		 .tpd_local_init = tpd_local_init,
-		 .suspend = tpd_suspend,
-		 .resume = tpd_resume,
-#ifdef TPD_HAVE_BUTTON
-		 .tpd_have_button = 1,
-#else
-		 .tpd_have_button = 0,
-#endif		
- };
- /* called when loaded into kernel */
- static int __init tpd_driver_init(void) {
-
-	 printk("MediaTek FT5206 touch panel driver init\n");
-	   i2c_register_board_info(1, &i2c_tpd, 1);
-		 if(tpd_driver_add(&tpd_device_driver) < 0)
-			 TPD_DMESG("add FT5206 driver failed\n");
-	 return 0;
- }
- 
- /* should never be called */
- static void __exit tpd_driver_exit(void) {
- 
-	 TPD_DMESG("MediaTek FT5206 touch panel driver exit\n");
-	 //input_unregister_device(tpd->dev);
-	 tpd_driver_remove(&tpd_device_driver);
- }
- 
-
- 
- module_init(tpd_driver_init);
- module_exit(tpd_driver_exit);
-
-
diff --git a/drivers/input/touchscreen/mediatek/ft6x06_qhd/tpd_custom_ft6x06.h~ b/drivers/input/touchscreen/mediatek/ft6x06_qhd/tpd_custom_ft6x06.h~
deleted file mode 100755
index d2081d9..0000000
--- a/drivers/input/touchscreen/mediatek/ft6x06_qhd/tpd_custom_ft6x06.h~
+++ /dev/null
@@ -1,55 +0,0 @@
-#ifndef TOUCHPANEL_H__
-#define TOUCHPANEL_H__
-#include <linux/rtpm_prio.h>
-//#include "tpd.h"
-#include "cust_gpio_usage.h"
-#include <pmic_drv.h>
-#include <cust_eint.h>
-/* Pre-defined definition */
-#define TPD_TYPE_CAPACITIVE
-#define TPD_TYPE_RESISTIVE
-#define TPD_POWER_SOURCE         
-#define TPD_I2C_NUMBER           1	//0
-#define TPD_WAKEUP_TRIAL         60
-#define TPD_WAKEUP_DELAY         100
-
-#define TPD_VELOCITY_CUSTOM_X 12
-#define TPD_VELOCITY_CUSTOM_Y 16
-
-
-#define TPD_DELAY                (2*HZ/100)
-#define TPD_RES_X                540		//huangxi modify 20130510
-#define TPD_RES_Y                960
-#define TPD_CALIBRATION_MATRIX  {962,0,0,0,1600,0,0,0};
-
-//huangxi add 20130716
-//#define TPD_X_RES (480)
-//#define TPD_Y_RES (800)
-#define TPD_WARP_Y(y) 	(TPD_RES_Y - y)
-#define TPD_WARP_X(x) 	(TPD_RES_X - x)
-
-
-//huangxi add 20130510
-#define TPD_DEVICE	"ft6x06"
-
-
-//#define TPD_HAVE_CALIBRATION
-//add at 20150327 by zhu for tp buttom
-#define TPD_HAVE_BUTTON
-//add at 20150327 by zhu for tp buttom end
-//#define TPD_HAVE_TREMBLE_ELIMINATION
-//#define TPD_HAVE_BUTTON
-#define TPD_BUTTON_HEIGH        (100)
-#define TPD_KEY_COUNT           1 //3
-//add at 20150327 by zhu for tp buttom
-//#define TPD_KEYS                { KEY_MENU, KEY_BACK}
-#define TPD_KEYS                { KEY_FINGER}
-//add at 20150327 by zhu for tp buttom end
-//  480 -60,   480- 380        854-1030
-//add at 20150327 by zhu for tp buttom
-//#define TPD_KEYS_DIM            {{TPD_RES_X - 60,TPD_RES_Y - 1030,160,TPD_BUTTON_HEIGH},{TPD_RES_X - 380,TPD_RES_Y - 1030,160,TPD_BUTTON_HEIGH}}   //S05  new saihua  4.68
-#define TPD_KEYS_DIM            {{60,1035,TPD_BUTTON_WIDTH,TPD_BUTTON_HEIGH}}
-//add at 20150327 by zhu for tp buttom end
-//#define TPD_KEYS_DIM            {{60,900,160,TPD_BUTTON_HEIGH},{420,900,160,TPD_BUTTON_HEIGH}}   //S05  new saihua  4.63
-
-#endif /* TOUCHPANEL_H__ */
diff --git a/drivers/input/touchscreen/mediatek/ft_allinone_gesture/Makefile b/drivers/input/touchscreen/mediatek/ft_allinone_gesture/Makefile
new file mode 100644
index 0000000..a906b6e
--- /dev/null
+++ b/drivers/input/touchscreen/mediatek/ft_allinone_gesture/Makefile
@@ -0,0 +1,12 @@
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+
+# Linux driver folder
+ccflags-y += -I$(srctree)/drivers/misc/mediatek/mach/$(MTK_PLATFORM)/$(ARCH_MTK_PROJECT)/touchpanel/ft_allinone_gesture/
+ccflags-y += -I$(srctree)/arch/arm/mach-$(MTK_PLATFORM)/$(ARCH_MTK_PROJECT)/touchpanel/ft_allinone_gesture/
+ccflags-y += -I$(srctree)/drivers/input/touchscreen/mediatek/ft_allinone_gesture/
+ccflags-y += -I$(srctree)/drivers/input/touchscreen/mediatek/
+
+obj-y	+=  focaltech_ctl.o
+obj-y	+=  focaltech_driver.o
+obj-y	+=  focaltech_ex_fun.o 
+obj-y   +=  ft_gesture_lib.a
diff --git a/drivers/input/touchscreen/mediatek/ft_allinone_gesture/focaltech_ctl.c b/drivers/input/touchscreen/mediatek/ft_allinone_gesture/focaltech_ctl.c
new file mode 100644
index 0000000..7a47d20
--- /dev/null
+++ b/drivers/input/touchscreen/mediatek/ft_allinone_gesture/focaltech_ctl.c
@@ -0,0 +1,284 @@
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/kernel.h>
+#include <linux/semaphore.h>
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+
+#include "tpd_custom_fts.h"
+#include "focaltech_ctl.h"
+#include "focaltech_ex_fun.h"
+#include <linux/netdevice.h>
+
+
+extern u8 *I2CDMABuf_va ;
+extern volatile u32 I2CDMABuf_pa;
+
+
+static int ft_rw_iic_drv_major = FT_RW_IIC_DRV_MAJOR;
+struct ft_rw_i2c_dev 
+{
+    struct cdev cdev;
+    struct semaphore ft_rw_i2c_sem;
+    struct i2c_client *client;
+};
+struct ft_rw_i2c_dev *ft_rw_i2c_dev_tt;
+static struct class *fts_class;
+
+static int ft_rw_iic_drv_myread(struct i2c_client *client, u8 *buf, int length)
+{
+    int ret = 0;    
+    ret = fts_i2c_Read(client, NULL, 0, buf, length);
+
+    if(ret<0)
+        dev_err(&client->dev, "%s:IIC Read failed\n",
+                __func__);
+    return ret;
+}
+
+static int ft_rw_iic_drv_mywrite(struct i2c_client *client, u8 *buf, int length)
+{
+    int ret = 0;
+    ret = fts_i2c_Write(client, buf, length);
+    if(ret<0)
+        dev_err(&client->dev, "%s:IIC Write failed\n",
+                __func__);
+    return ret;
+}
+
+static int ft_rw_iic_drv_RDWR(struct i2c_client *client, unsigned long arg)
+{
+    struct ft_rw_i2c_queue i2c_rw_queue;
+    u8 __user **data_ptrs;
+    struct ft_rw_i2c * i2c_rw_msg;
+    int ret = 0;
+    int i;
+
+    if (!access_ok(VERIFY_READ, (struct ft_rw_i2c_queue *)arg, sizeof(struct ft_rw_i2c_queue)))
+        return -EFAULT;
+
+    if (copy_from_user(&i2c_rw_queue,
+        (struct ft_rw_i2c_queue *)arg, 
+        sizeof(struct ft_rw_i2c_queue)))
+        return -EFAULT;
+
+    if (i2c_rw_queue.queuenum > FT_I2C_RDWR_MAX_QUEUE)
+        return -EINVAL;
+
+
+    i2c_rw_msg = (struct ft_rw_i2c*)
+        kmalloc(i2c_rw_queue.queuenum *sizeof(struct ft_rw_i2c),
+        GFP_KERNEL);
+    if (!i2c_rw_msg)
+        return -ENOMEM;
+
+    if (copy_from_user(i2c_rw_msg, i2c_rw_queue.i2c_queue,
+            i2c_rw_queue.queuenum*sizeof(struct ft_rw_i2c))) {
+        kfree(i2c_rw_msg);
+        return -EFAULT;
+    }
+
+    data_ptrs = kmalloc(i2c_rw_queue.queuenum * sizeof(u8 __user *), GFP_KERNEL);
+    if (data_ptrs == NULL) {
+        kfree(i2c_rw_msg);
+        return -ENOMEM;
+    }
+    
+    ret = 0;
+    for (i=0; i< i2c_rw_queue.queuenum; i++) {
+        if ((i2c_rw_msg[i].length > 8192)||
+            (i2c_rw_msg[i].flag & I2C_M_RECV_LEN)) {
+            ret = -EINVAL;
+            break;
+        }
+        data_ptrs[i] = (u8 __user *)i2c_rw_msg[i].buf;
+        i2c_rw_msg[i].buf = kmalloc(i2c_rw_msg[i].length, GFP_KERNEL);
+        if (i2c_rw_msg[i].buf == NULL) {
+            ret = -ENOMEM;
+            break;
+        }
+
+        if (copy_from_user(i2c_rw_msg[i].buf, data_ptrs[i], i2c_rw_msg[i].length)) {
+            ++i;
+            ret = -EFAULT;
+            break;
+        }
+    }
+//printk("ft_rw_iic_drv_RDWR 6  %d %x  %x\n",ret,data_ptrs,i2c_rw_msg);
+    if (ret < 0) {
+        int j;
+        for (j=0; j<i; ++j)
+            kfree(i2c_rw_msg[j].buf);
+        kfree(data_ptrs);
+        kfree(i2c_rw_msg);
+        return ret;
+    }
+//printk("ft_rw_iic_drv_RDWR 7\n");
+    for (i=0; i< i2c_rw_queue.queuenum; i++) {
+        //printk("ft_rw_iic_drv_RDWR 8  %d  %x  %x  %d\n",i2c_rw_msg[i].flag,i2c_rw_msg[i].buf,data_ptrs[i],i2c_rw_msg[i].length);
+        if (i2c_rw_msg[i].flag) {
+            ret = ft_rw_iic_drv_myread(client,
+                    i2c_rw_msg[i].buf, i2c_rw_msg[i].length);
+            if (ret>=0)
+                ret = copy_to_user(data_ptrs[i], i2c_rw_msg[i].buf, i2c_rw_msg[i].length);
+        }
+        else
+            ret = ft_rw_iic_drv_mywrite(client,
+                    i2c_rw_msg[i].buf, i2c_rw_msg[i].length);
+    }
+//printk("ft_rw_iic_drv_RDWR 10\n");
+    return ret;
+    
+}
+
+/*
+*char device open function interface 
+*/
+static int ft_rw_iic_drv_open(struct inode *inode, struct file *filp)
+{
+    filp->private_data = ft_rw_i2c_dev_tt;
+    return 0;
+}
+
+/*
+*char device close function interface 
+*/
+static int ft_rw_iic_drv_release(struct inode *inode, struct file *filp)
+{
+
+    return 0;
+}
+
+static int ft_rw_iic_drv_ioctl(struct file *filp, unsigned
+  int cmd, unsigned long arg)
+{
+    int ret = 0;
+    struct ft_rw_i2c_dev *ftdev = filp->private_data;
+    ftdev = filp->private_data;
+    //printk("ft_rw_iic_drv_ioctl\n");
+//  down(&ft_rw_i2c_dev_tt->ft_rw_i2c_sem);
+    //printk("====ft_rw_iic_drv_ioctl: client = %x\n",ftdev->client);
+    switch (cmd)
+    {
+    case FT_I2C_RW:
+        ret = ft_rw_iic_drv_RDWR(ftdev->client, arg);   
+        break; 
+    default:
+        ret =  -ENOTTY;
+        break;
+    }
+//  up(&ft_rw_i2c_dev_tt->ft_rw_i2c_sem);
+    //printk("++++ft_rw_iic_drv_ioctl\n");
+    return ret; 
+}
+
+
+/*    
+*char device file operation which will be put to register the char device
+*/
+static const struct file_operations ft_rw_iic_drv_fops = {
+    .owner          = THIS_MODULE,
+    .open           = ft_rw_iic_drv_open,
+    .release        = ft_rw_iic_drv_release,
+    .unlocked_ioctl = ft_rw_iic_drv_ioctl,
+};
+
+
+static void ft_rw_iic_drv_setup_cdev(struct ft_rw_i2c_dev *dev, int index)
+{
+    int err, devno = MKDEV(ft_rw_iic_drv_major, index);
+
+    cdev_init(&dev->cdev, &ft_rw_iic_drv_fops);
+    dev->cdev.owner = THIS_MODULE;
+    dev->cdev.ops = &ft_rw_iic_drv_fops;
+    dev->client = ft_rw_i2c_dev_tt->client;
+    //printk("%s: 2.client=%x  \n",__func__,dev->client);
+    err = cdev_add(&dev->cdev, devno, 1);
+    if (err)
+        printk(KERN_NOTICE "Error %d adding LED%d", err, index);
+}
+
+static int ft_rw_iic_drv_myinitdev(struct i2c_client *client)
+{
+    int err = 0;
+    dev_t devno = MKDEV(ft_rw_iic_drv_major, 0);
+
+    if (ft_rw_iic_drv_major)
+        err = register_chrdev_region(devno, 1, FT_RW_IIC_DRV);
+    else {
+        err = alloc_chrdev_region(&devno, 0, 1, FT_RW_IIC_DRV);
+        ft_rw_iic_drv_major = MAJOR(devno);
+    }
+    if (err < 0) {
+        dev_err(&client->dev, "%s:ft_rw_iic_drv failed  error code=%d---\n",
+                __func__, err);
+        return err;
+    }
+
+    ft_rw_i2c_dev_tt = kmalloc(sizeof(struct ft_rw_i2c_dev), GFP_KERNEL);
+    if (!ft_rw_i2c_dev_tt){
+        err = -ENOMEM;
+        unregister_chrdev_region(devno, 1);
+        dev_err(&client->dev, "%s:ft_rw_iic_drv failed\n",
+                __func__);
+        return err;
+    }
+    
+    ft_rw_i2c_dev_tt->client = client;
+    //printk("ft_rw_iic_drv_myinitdev: client=%x \n",ft_rw_i2c_dev_tt->client);
+    mutex_init(&ft_rw_i2c_dev_tt->ft_rw_i2c_sem);
+
+    cdev_init(&ft_rw_i2c_dev_tt->cdev, &ft_rw_iic_drv_fops);
+    ft_rw_i2c_dev_tt->client = client;
+    ft_rw_i2c_dev_tt->cdev.owner = THIS_MODULE;
+    ft_rw_i2c_dev_tt->cdev.ops = &ft_rw_iic_drv_fops;
+     //printk("%s: 2.client=%x  \n",__func__,ft_rw_i2c_dev_tt->client);
+    err = cdev_add(&ft_rw_i2c_dev_tt->cdev, devno, 1);
+    //printk("%s: client=%x  \n",__func__,ft_rw_i2c_dev_tt->client);
+    if (err)
+        printk(KERN_NOTICE "Error %d adding LED", err);
+    
+    
+    //ft_rw_iic_drv_setup_cdev(ft_rw_i2c_dev_tt, 0); 
+    //printk("===ft_rw_iic_drv_myinitdev: client=%x \n",ft_rw_i2c_dev_tt->client);
+
+    fts_class = class_create(THIS_MODULE, "fts_class");
+    if (IS_ERR(fts_class)) {
+        dev_dbg(&client->dev, "%s:failed in creating class.\n",
+                __func__);
+        return -1; 
+    } 
+    /*create device node*/
+    device_create(fts_class, NULL, MKDEV(ft_rw_iic_drv_major, 0), 
+            NULL, FT_RW_IIC_DRV);
+
+    
+    return 0;
+}
+
+int ft_rw_iic_drv_init(struct i2c_client *client)
+{
+    dev_dbg(&client->dev, "[FTS]----ft_rw_iic_drv init ---\n");
+	return ft_rw_iic_drv_myinitdev(client);
+}
+
+void  ft_rw_iic_drv_exit(void)
+{
+	device_destroy(fts_class, MKDEV(ft_rw_iic_drv_major, 0)); 
+	/*delete class created by us*/
+	class_destroy(fts_class); 
+	/*delet the cdev*/
+	cdev_del(&ft_rw_i2c_dev_tt->cdev);
+	kfree(ft_rw_i2c_dev_tt);
+	unregister_chrdev_region(MKDEV(ft_rw_iic_drv_major, 0), 1); 
+}
+
diff --git a/drivers/input/touchscreen/mediatek/ft_allinone_gesture/focaltech_ctl.h b/drivers/input/touchscreen/mediatek/ft_allinone_gesture/focaltech_ctl.h
new file mode 100644
index 0000000..c729522
--- /dev/null
+++ b/drivers/input/touchscreen/mediatek/ft_allinone_gesture/focaltech_ctl.h
@@ -0,0 +1,27 @@
+#ifndef __FOCALTECH_CTL_H__
+#define __FOCALTECH_CTL_H__
+/*****************************************************************************/
+#define FT_RW_IIC_DRV                        "ft_rw_iic_drv"
+#define FT_RW_IIC_DRV_MAJOR             210   /*ft_rw_iic_drv*/
+
+#define FT_I2C_RDWR_MAX_QUEUE        36
+#define FT_I2C_SLAVEADDR                    11
+#define FT_I2C_RW                                  12
+
+typedef struct ft_rw_i2c
+{
+    u8 *buf;    
+    u8 flag;                            /*0-write 1-read*/
+    __u16 length;                       /*the length of data*/
+}*pft_rw_i2c;
+
+typedef struct ft_rw_i2c_queue
+{
+    struct ft_rw_i2c __user *i2c_queue;
+    int queuenum;   
+}*pft_rw_i2c_queue;
+
+int ft_rw_iic_drv_init(struct i2c_client *client);
+void  ft_rw_iic_drv_exit(void);
+/*****************************************************************************/
+#endif
\ No newline at end of file
diff --git a/drivers/input/touchscreen/mediatek/ft_allinone_gesture/focaltech_driver.c b/drivers/input/touchscreen/mediatek/ft_allinone_gesture/focaltech_driver.c
new file mode 100644
index 0000000..d4a2a8c
--- /dev/null
+++ b/drivers/input/touchscreen/mediatek/ft_allinone_gesture/focaltech_driver.c
@@ -0,0 +1,1459 @@
+/*
+ * This software is licensed under the terms of the GNU General Public 
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms. 
+ * This program is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
+ * GNU General Public License for more details. 
+ * * VERSION      	DATE			AUTHOR          Note
+ *    1.0		  2013-7-16			Focaltech        initial  based on MTK platform
+ * 
+ */
+
+#include "tpd.h"
+
+#include "tpd_custom_fts.h"
+#ifdef FTS_CTL_IIC
+#include "focaltech_ctl.h"
+#endif
+#ifdef TPD_SYSFS_DEBUG
+#include "focaltech_ex_fun.h"
+#endif
+#ifdef TPD_PROXIMITY
+#include <linux/hwmsensor.h>
+#include <linux/hwmsen_dev.h>
+#include <linux/sensors_io.h>
+#endif
+
+#include "cust_gpio_usage.h"
+#ifdef CONFIG_OF_TOUCH
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#endif
+#include <mach/battery_common.h>
+
+#include <linux/dma-mapping.h>
+
+#if defined(CONFIG_HCT_TP_GESTRUE)
+#define GTP_GESTURE_WAKEUP    1
+#else
+#define GTP_GESTURE_WAKEUP    0
+#endif
+
+#if GTP_GESTURE_WAKEUP
+static char tpgesture_value[10]={};
+static char tpgesture_status_value[5] = {};
+static char tpgesture_status = 1;
+#endif
+
+struct Upgrade_Info fts_updateinfo[] =
+{
+	{0x55,"FT5x06",TPD_MAX_POINTS_5,AUTO_CLB_NEED,50, 30, 0x79, 0x03, 1, 2000},
+	{0x08,"FT5606",TPD_MAX_POINTS_5,AUTO_CLB_NEED,50, 30, 0x79, 0x06, 100, 2000},
+	{0x0a,"FT5x16",TPD_MAX_POINTS_5,AUTO_CLB_NEED,50, 30, 0x79, 0x07, 1, 1500},
+	{0x05,"FT6208",TPD_MAX_POINTS_2,AUTO_CLB_NONEED,60, 30, 0x79, 0x05, 10, 2000},
+	{0x06,"FT6x06",TPD_MAX_POINTS_2,AUTO_CLB_NONEED,100, 30, 0x79, 0x08, 10, 2000},
+	{0x55,"FT5x06i",TPD_MAX_POINTS_5,AUTO_CLB_NEED,50, 30, 0x79, 0x03, 1, 2000},
+	{0x14,"FT5336",TPD_MAX_POINTS_5,AUTO_CLB_NEED,30, 30, 0x79, 0x11, 10, 2000},
+	{0x13,"FT3316",TPD_MAX_POINTS_5,AUTO_CLB_NEED,30, 30, 0x79, 0x11, 10, 2000},
+	{0x12,"FT5436i",TPD_MAX_POINTS_5,AUTO_CLB_NEED,30, 30, 0x79, 0x11, 10, 2000},
+	{0x11,"FT5336i",TPD_MAX_POINTS_5,AUTO_CLB_NEED,30, 30, 0x79, 0x11, 10, 2000},
+};
+				
+struct Upgrade_Info fts_updateinfo_curr;
+
+#ifdef TPD_PROXIMITY
+#define APS_ERR(fmt,arg...)           	printk("<<proximity>> "fmt"\n",##arg)
+#define TPD_PROXIMITY_DEBUG(fmt,arg...) printk("<<proximity>> "fmt"\n",##arg)
+#define TPD_PROXIMITY_DMESG(fmt,arg...) printk("<<proximity>> "fmt"\n",##arg)
+
+static u8 tpd_proximity_flag 			= 0;
+static u8 tpd_proximity_flag_one 		= 0; //add for tpd_proximity by wangdongfang
+static u8 tpd_proximity_detect 		= 1;//0-->close ; 1--> far away
+#endif
+
+#ifdef FTS_GESTRUE
+#define GESTURE_LEFT			0x20
+#define GESTURE_RIGHT			0x21
+#define GESTURE_UP		    	0x22
+#define GESTURE_DOWN			0x23
+#define GESTURE_DOUBLECLICK		0x24
+#define GESTURE_O		    0x30
+#define GESTURE_W		    0x31
+#define GESTURE_M		    0x32
+#define GESTURE_E		    0x33
+#define GESTURE_C		    0x34
+#define GESTURE_S		    0x46
+#define GESTURE_V		    0x54
+#define GESTURE_Z		    0x41
+
+#include "ft_gesture_lib.h"
+
+#define FTS_GESTRUE_POINTS 255
+#define FTS_GESTRUE_POINTS_ONETIME  62
+#define FTS_GESTRUE_POINTS_HEADER 8
+#define FTS_GESTURE_OUTPUT_ADRESS 0xD3
+#define FTS_GESTURE_OUTPUT_UNIT_LENGTH 4
+
+//suspend_state_t get_suspend_state(void);
+
+unsigned short coordinate_x[150] = {0};
+unsigned short coordinate_y[150] = {0};
+#endif
+extern struct tpd_device *tpd;
+ 
+static struct i2c_client *i2c_client = NULL;
+static struct task_struct *thread = NULL;
+ 
+static DECLARE_WAIT_QUEUE_HEAD(waiter);
+static DEFINE_MUTEX(i2c_access);
+ #ifdef CONFIG_OF_TOUCH
+unsigned int touch_irq = 0;
+u8 int_type = 0;
+#endif
+ 
+#ifdef CONFIG_OF_TOUCH
+static irqreturn_t tpd_eint_interrupt_handler(unsigned irq, struct irq_desc *desc);
+#else
+static void tpd_eint_interrupt_handler(void);
+#endif
+ 
+static int tpd_probe(struct i2c_client *client, const struct i2c_device_id *id);
+static int tpd_detect (struct i2c_client *client, struct i2c_board_info *info);
+static int  tpd_remove(struct i2c_client *client);
+static int touch_event_handler(void *unused);
+
+static int tpd_flag 					= 0;
+static int tpd_halt						= 0;
+static int point_num 					= 0;
+static int p_point_num 					= 0;
+
+u8 *I2CDMABuf_va = NULL;
+//volatile u32 I2CDMABuf_pa = NULL;
+dma_addr_t I2CDMABuf_pa = 0;
+
+//#define TPD_CLOSE_POWER_IN_SLEEP
+#define TPD_OK 							0
+//register define
+#define DEVICE_MODE 					0x00
+#define GEST_ID 						0x01
+#define TD_STATUS 						0x02
+//point1 info from 0x03~0x08
+//point2 info from 0x09~0x0E
+//point3 info from 0x0F~0x14
+//point4 info from 0x15~0x1A
+//point5 info from 0x1B~0x20
+//register define
+
+#define TPD_RESET_ISSUE_WORKAROUND
+
+#define TPD_MAX_RESET_COUNT 			3
+//extern int tpd_mstar_status ;  // compatible mstar and ft6306 chenzhecong
+
+#ifdef TPD_HAVE_BUTTON 
+static int tpd_keys_local[TPD_KEY_COUNT] = TPD_KEYS;
+static int tpd_keys_dim_local_fwvga[TPD_KEY_COUNT][4] = TPD_KEYS_DIM_FWVGA;
+static int tpd_keys_dim_local_qhd[TPD_KEY_COUNT][4] = TPD_KEYS_DIM_QHD;
+#endif
+#if (defined(TPD_WARP_START) && defined(TPD_WARP_END))
+static int tpd_wb_start_local[TPD_WARP_CNT] = TPD_WARP_START;
+static int tpd_wb_end_local[TPD_WARP_CNT]   = TPD_WARP_END;
+#endif
+#if (defined(TPD_HAVE_CALIBRATION) && !defined(TPD_CUSTOM_CALIBRATION))
+static int tpd_calmat_local[8]     = TPD_CALIBRATION_MATRIX;
+static int tpd_def_calmat_local[8] = TPD_CALIBRATION_MATRIX;
+#endif
+
+#define VELOCITY_CUSTOM_FT5206
+#ifdef VELOCITY_CUSTOM_FT5206
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+#include <asm/uaccess.h>
+
+// for magnify velocity********************************************
+
+#ifndef TPD_VELOCITY_CUSTOM_X
+#define TPD_VELOCITY_CUSTOM_X 			10
+#endif
+#ifndef TPD_VELOCITY_CUSTOM_Y
+#define TPD_VELOCITY_CUSTOM_Y 			10
+#endif
+
+#define TOUCH_IOC_MAGIC 				'A'
+
+#define TPD_GET_VELOCITY_CUSTOM_X _IO(TOUCH_IOC_MAGIC,0)
+#define TPD_GET_VELOCITY_CUSTOM_Y _IO(TOUCH_IOC_MAGIC,1)
+
+
+static int g_v_magnify_x =TPD_VELOCITY_CUSTOM_X;
+static int g_v_magnify_y =TPD_VELOCITY_CUSTOM_Y;
+
+static int tpd_misc_open(struct inode *inode, struct file *file)
+{
+/*
+	file->private_data = adxl345_i2c_client;
+
+	if(file->private_data == NULL)
+	{
+		printk("tpd: null pointer!!\n");
+		return -EINVAL;
+	}
+	*/
+	return nonseekable_open(inode, file);
+}
+/*----------------------------------------------------------------------------*/
+static int tpd_misc_release(struct inode *inode, struct file *file)
+{
+	//file->private_data = NULL;
+	return 0;
+}
+/*----------------------------------------------------------------------------*/
+//static int adxl345_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+//       unsigned long arg)
+static long tpd_unlocked_ioctl(struct file *file, unsigned int cmd,
+       unsigned long arg)
+{
+	//struct i2c_client *client = (struct i2c_client*)file->private_data;
+	//struct adxl345_i2c_data *obj = (struct adxl345_i2c_data*)i2c_get_clientdata(client);	
+	//char strbuf[256];
+	void __user *data;
+	
+	long err = 0;
+	
+	if(_IOC_DIR(cmd) & _IOC_READ)
+	{
+		err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
+	}
+	else if(_IOC_DIR(cmd) & _IOC_WRITE)
+	{
+		err = !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
+	}
+
+	if(err)
+	{
+		printk("tpd: access error: %08X, (%2d, %2d)\n", cmd, _IOC_DIR(cmd), _IOC_SIZE(cmd));
+		return -EFAULT;
+	}
+
+	switch(cmd)
+	{
+		case TPD_GET_VELOCITY_CUSTOM_X:
+			data = (void __user *) arg;
+			if(data == NULL)
+			{
+				err = -EINVAL;
+				break;	  
+			}			
+			
+			if(copy_to_user(data, &g_v_magnify_x, sizeof(g_v_magnify_x)))
+			{
+				err = -EFAULT;
+				break;
+			}				 
+			break;
+
+	   case TPD_GET_VELOCITY_CUSTOM_Y:
+			data = (void __user *) arg;
+			if(data == NULL)
+			{
+				err = -EINVAL;
+				break;	  
+			}			
+			
+			if(copy_to_user(data, &g_v_magnify_y, sizeof(g_v_magnify_y)))
+			{
+				err = -EFAULT;
+				break;
+			}				 
+			break;
+
+		default:
+			printk("tpd: unknown IOCTL: 0x%08x\n", cmd);
+			err = -ENOIOCTLCMD;
+			break;
+	}
+
+	return err;
+}
+
+
+static struct file_operations tpd_fops = {
+//	.owner = THIS_MODULE,
+	.open = tpd_misc_open,
+	.release = tpd_misc_release,
+	.unlocked_ioctl = tpd_unlocked_ioctl,
+};
+/*----------------------------------------------------------------------------*/
+static struct miscdevice tpd_misc_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = TPD_NAME,
+	.fops = &tpd_fops,
+};
+
+//**********************************************
+#endif
+
+struct touch_info {
+    int y[10];
+    int x[10];
+    int p[10];
+    int id[10];
+};
+ 
+static const struct i2c_device_id ft5206_tpd_id[] = {{TPD_NAME,0},{}};
+//unsigned short force[] = {0,0x70,I2C_CLIENT_END,I2C_CLIENT_END}; 
+//static const unsigned short * const forces[] = { force, NULL };
+//static struct i2c_client_address_data addr_data = { .forces = forces, };
+static struct i2c_board_info __initdata ft5206_i2c_tpd={ I2C_BOARD_INFO(TPD_NAME, (0x70>>1))};
+ 
+static struct i2c_driver tpd_i2c_driver = {
+  	.driver = {
+	 	.name 	= TPD_NAME,
+	//	.owner 	= THIS_MODULE,
+  	},
+  	.probe 		= tpd_probe,
+  	.remove 	= tpd_remove,
+  	.id_table 	= ft5206_tpd_id,
+  	.detect 	= tpd_detect,
+// 	.shutdown	= tpd_shutdown,
+//  .address_data = &addr_data,
+};
+
+
+static  void tpd_down(int x, int y, int p) {
+	// input_report_abs(tpd->dev, ABS_PRESSURE, p);
+	input_report_key(tpd->dev, BTN_TOUCH, 1);
+	input_report_abs(tpd->dev, ABS_MT_TOUCH_MAJOR, 20);
+#if defined(HCT_TPD_ROTATION)
+	if(y<TPD_RES_Y)
+	{
+		input_report_abs(tpd->dev, ABS_MT_POSITION_X, TPD_RES_X-x);
+		input_report_abs(tpd->dev, ABS_MT_POSITION_Y, TPD_RES_Y-y);
+	}
+	else
+	{
+	    input_report_abs(tpd->dev, ABS_MT_POSITION_X, x);
+    	input_report_abs(tpd->dev, ABS_MT_POSITION_Y, y);
+	}
+#else	
+	input_report_abs(tpd->dev, ABS_MT_POSITION_X, x);
+	input_report_abs(tpd->dev, ABS_MT_POSITION_Y, y);
+#endif
+	//printk("D[%4d %4d %4d] ", x, y, p);
+	/* track id Start 0 */
+	input_report_abs(tpd->dev, ABS_MT_TRACKING_ID, p); 
+	input_mt_sync(tpd->dev);
+#if 1//ndef MT6572
+    if (FACTORY_BOOT == get_boot_mode()|| RECOVERY_BOOT == get_boot_mode())
+#endif	
+    {   
+      tpd_button(x, y, 1);  
+    }
+	TPD_EM_PRINT(x, y, x, y, p-1, 1);
+}
+ 
+static  void tpd_up(int x, int y) {
+	//input_report_abs(tpd->dev, ABS_PRESSURE, 0);
+	input_report_key(tpd->dev, BTN_TOUCH, 0);
+	//input_report_abs(tpd->dev, ABS_MT_TOUCH_MAJOR, 0);
+	//input_report_abs(tpd->dev, ABS_MT_POSITION_X, x);
+	//input_report_abs(tpd->dev, ABS_MT_POSITION_Y, y);
+	//printk("U[%4d %4d %4d] ", x, y, 0);
+	input_mt_sync(tpd->dev);
+	TPD_EM_PRINT(x, y, x, y, 0, 0);
+#if 1//ndef MT6572
+    if (FACTORY_BOOT == get_boot_mode()|| RECOVERY_BOOT == get_boot_mode())
+#endif
+    {   
+       tpd_button(x, y, 0); 
+    }   		 
+}
+
+static int tpd_touchinfo(struct touch_info *cinfo, struct touch_info *pinfo)
+{
+	int i = 0;
+//#if (TPD_MAX_POINTS==2)
+//	char data[35] = {0};
+//#else
+//	char data[16] = {0};
+//#endif	
+    char data[128] = {0};
+    u16 high_byte,low_byte,reg;
+	u8 report_rate =0;
+
+	p_point_num = point_num;
+	if (tpd_halt)
+	{
+		TPD_DMESG( "tpd_touchinfo return ..\n");
+		return false;
+	}
+	mutex_lock(&i2c_access);
+
+
+    reg = 0x00;
+	fts_i2c_Read(i2c_client, &reg, 1, data, 64);
+	mutex_unlock(&i2c_access);
+	//TPD_DEBUG("received raw data from touch panel as following:\n");
+	//TPD_DEBUG("[data[0]=%x,data[1]= %x ,data[2]=%x ,data[3]=%x ,data[4]=%x ,data[5]=%x]\n",data[0],data[1],data[2],data[3],data[4],data[5]);
+	//TPD_DEBUG("[data[9]=%x,data[10]= %x ,data[11]=%x ,data[12]=%x]\n",data[9],data[10],data[11],data[12]);
+	//TPD_DEBUG("[data[15]=%x,data[16]= %x ,data[17]=%x ,data[18]=%x]\n",data[15],data[16],data[17],data[18]);
+   
+	/*get the number of the touch points*/
+	point_num= data[2] & 0x0f;
+	
+	//TPD_DEBUG("point_num =%d\n",point_num);
+		
+	for(i = 0; i < point_num; i++)  
+	{
+		cinfo->p[i] = data[3+6*i] >> 6; //event flag 
+     	cinfo->id[i] = data[3+6*i+2]>>4; //touch id
+	   	/*get the X coordinate, 2 bytes*/
+		high_byte = data[3+6*i];
+		high_byte <<= 8;
+		high_byte &= 0x0f00;
+		low_byte = data[3+6*i + 1];
+		cinfo->x[i] = high_byte |low_byte;
+
+		//cinfo->x[i] =  cinfo->x[i] * 480 >> 11; //calibra
+	
+		/*get the Y coordinate, 2 bytes*/
+		
+		high_byte = data[3+6*i+2];
+		high_byte <<= 8;
+		high_byte &= 0x0f00;
+		low_byte = data[3+6*i+3];
+		cinfo->y[i] = high_byte |low_byte;
+
+		 //cinfo->y[i]=  cinfo->y[i] * 800 >> 11;
+	}
+	TPD_DEBUG(" cinfo->x[0] = %d, cinfo->y[0] = %d, cinfo->p[0] = %d\n", cinfo->x[0], cinfo->y[0], cinfo->p[0]);	
+	//TPD_DEBUG(" cinfo->x[1] = %d, cinfo->y[1] = %d, cinfo->p[1] = %d\n", cinfo->x[1], cinfo->y[1], cinfo->p[1]);		
+	//TPD_DEBUG(" cinfo->x[2]= %d, cinfo->y[2]= %d, cinfo->p[2] = %d\n", cinfo->x[2], cinfo->y[2], cinfo->p[2]);	
+		  
+	return true;
+};
+
+#ifdef TPD_PROXIMITY
+int tpd_read_ps(void)
+{
+	tpd_proximity_detect;
+	return 0;    
+}
+
+static int tpd_get_ps_value(void)
+{
+	return tpd_proximity_detect;
+}
+
+static int tpd_enable_ps(int enable)
+{
+	u8 state;
+	int ret = -1;
+
+	i2c_smbus_read_i2c_block_data(i2c_client, 0xB0, 1, &state);
+	printk("[proxi_5206]read: 999 0xb0's value is 0x%02X\n", state);
+	if (enable){
+		state |= 0x01;
+		tpd_proximity_flag = 1;
+		TPD_PROXIMITY_DEBUG("[proxi_5206]ps function is on\n");	
+	}else{
+		state &= 0x00;	
+		tpd_proximity_flag = 0;
+		TPD_PROXIMITY_DEBUG("[proxi_5206]ps function is off\n");
+	}
+
+	ret = i2c_smbus_write_i2c_block_data(i2c_client, 0xB0, 1, &state);
+	TPD_PROXIMITY_DEBUG("[proxi_5206]write: 0xB0's value is 0x%02X\n", state);
+	return 0;
+}
+
+int tpd_ps_operate(void* self, uint32_t command, void* buff_in, int size_in,
+		void* buff_out, int size_out, int* actualout)
+{
+	int err = 0;
+	int value;
+	
+	hwm_sensor_data *sensor_data;
+	TPD_DEBUG("[proxi_5206]command = 0x%02X\n", command);		
+	switch (command)
+	{
+		case SENSOR_DELAY:
+			if((buff_in == NULL) || (size_in < sizeof(int)))
+			{
+				APS_ERR("Set delay parameter error!\n");
+				err = -EINVAL;
+			}
+			// Do nothing
+			break;
+
+		case SENSOR_ENABLE:
+			if((buff_in == NULL) || (size_in < sizeof(int)))
+			{
+				APS_ERR("Enable sensor parameter error!\n");
+				err = -EINVAL;
+			}
+			else
+			{				
+				value = *(int *)buff_in;
+				if(value)
+				{		
+					if((tpd_enable_ps(1) != 0))
+					{
+						APS_ERR("enable ps fail: %d\n", err); 
+						return -1;
+					}
+				}
+				else
+				{
+					if((tpd_enable_ps(0) != 0))
+					{
+						APS_ERR("disable ps fail: %d\n", err); 
+						return -1;
+					}
+				}
+			}
+			break;
+
+		case SENSOR_GET_DATA:
+			if((buff_out == NULL) || (size_out< sizeof(hwm_sensor_data)))
+			{
+				APS_ERR("get sensor data parameter error!\n");
+				err = -EINVAL;
+			}
+			else
+			{
+				
+				sensor_data = (hwm_sensor_data *)buff_out;				
+				
+				if((err = tpd_read_ps()))
+				{
+					err = -1;;
+				}
+				else
+				{
+					sensor_data->values[0] = tpd_get_ps_value();
+					TPD_PROXIMITY_DEBUG("huang sensor_data->values[0] 1082 = %d\n", sensor_data->values[0]);
+					sensor_data->value_divide = 1;
+					sensor_data->status = SENSOR_STATUS_ACCURACY_MEDIUM;
+				}	
+				
+			}
+			break;
+		default:
+			APS_ERR("proxmy sensor operate function no this parameter %d!\n", command);
+			err = -1;
+			break;
+	}
+	
+	return err;	
+}
+#endif
+
+#ifdef FTS_GESTRUE
+/*
+static void check_gesture(int gesture_id)
+{
+	
+    printk("kaka gesture_id==0x%x\n ",gesture_id);
+    
+	switch(gesture_id)
+	{
+		case GESTURE_LEFT:		     
+			input_report_key(tpd->dev, KEY_POWER, 1);
+			    input_sync(tpd->dev);
+			     input_report_key(tpd->dev, KEY_POWER, 0);
+			    input_sync(tpd->dev);
+		     	    input_report_key(tpd->dev, KEY_LEFT, 1);
+			    input_sync(tpd->dev);
+			     input_report_key(tpd->dev, KEY_LEFT, 0);
+			    input_sync(tpd->dev);
+			break;
+		case GESTURE_RIGHT:	
+			input_report_key(tpd->dev, KEY_POWER, 1);
+			    input_sync(tpd->dev);
+			     input_report_key(tpd->dev, KEY_POWER, 0);
+			    input_sync(tpd->dev);
+  			input_report_key(tpd->dev, KEY_RIGHT, 1);
+			    input_sync(tpd->dev);
+			     input_report_key(tpd->dev, KEY_RIGHT, 0);
+			    input_sync(tpd->dev);
+ 
+			break;
+		case GESTURE_UP:	
+			input_report_key(tpd->dev, KEY_POWER, 1);
+			    input_sync(tpd->dev);
+			     input_report_key(tpd->dev, KEY_POWER, 0);
+			    input_sync(tpd->dev);
+			input_report_key(tpd->dev, KEY_UP, 1);
+			    input_sync(tpd->dev);
+			     input_report_key(tpd->dev, KEY_UP, 0);
+			    input_sync(tpd->dev);
+			    
+			break;
+		case GESTURE_DOWN:	
+			input_report_key(tpd->dev, KEY_POWER, 1);
+			    input_sync(tpd->dev);
+			     input_report_key(tpd->dev, KEY_POWER, 0);
+			    input_sync(tpd->dev);		
+				input_report_key(tpd->dev, KEY_DOWN, 1);
+			    input_sync(tpd->dev);
+			     input_report_key(tpd->dev, KEY_DOWN, 0);
+			    input_sync(tpd->dev);
+		    
+			break;
+		case GESTURE_DOUBLECLICK:	
+				input_report_key(tpd->dev, KEY_POWER, 1);
+			    input_sync(tpd->dev);
+			     input_report_key(tpd->dev, KEY_POWER, 0);
+			    input_sync(tpd->dev);
+	//		input_report_key(tpd->dev, KEY_U, 1);
+	//		    input_sync(tpd->dev);
+	//		     input_report_key(tpd->dev, KEY_U, 0);
+	//		    input_sync(tpd->dev);
+			    
+			break;
+		case GESTURE_O:	
+			input_report_key(tpd->dev, KEY_POWER, 1);
+			    input_sync(tpd->dev);
+			     input_report_key(tpd->dev, KEY_POWER, 0);
+			    input_sync(tpd->dev);
+					input_report_key(tpd->dev, KEY_O, 1);
+			    input_sync(tpd->dev);
+			    input_report_key(tpd->dev, KEY_O, 0);
+			    input_sync(tpd->dev);
+			break;
+		case GESTURE_W:			
+			input_report_key(tpd->dev, KEY_POWER, 1);
+			    input_sync(tpd->dev);
+			     input_report_key(tpd->dev, KEY_POWER, 0);
+			    input_sync(tpd->dev);
+				input_report_key(tpd->dev, KEY_W, 1);
+			    input_sync(tpd->dev);
+			     input_report_key(tpd->dev, KEY_W, 0);
+			    input_sync(tpd->dev);
+			    
+			break;
+		case GESTURE_M:		
+			input_report_key(tpd->dev, KEY_POWER, 1);
+			    input_sync(tpd->dev);
+			     input_report_key(tpd->dev, KEY_POWER, 0);
+			    input_sync(tpd->dev);
+				input_report_key(tpd->dev, KEY_M, 1);
+			    input_sync(tpd->dev);
+			     input_report_key(tpd->dev, KEY_M, 0);
+			    input_sync(tpd->dev);
+			    
+			break;
+		case GESTURE_E:		
+				input_report_key(tpd->dev, KEY_POWER, 1);
+			    input_sync(tpd->dev);
+			     input_report_key(tpd->dev, KEY_POWER, 0);
+			    input_sync(tpd->dev);
+				input_report_key(tpd->dev, KEY_E, 1);
+			    input_sync(tpd->dev);
+			     input_report_key(tpd->dev, KEY_E, 0);
+			    input_sync(tpd->dev);
+			    
+			break;
+		case GESTURE_C:		
+			input_report_key(tpd->dev, KEY_POWER, 1);
+			    input_sync(tpd->dev);
+			     input_report_key(tpd->dev, KEY_POWER, 0);
+			    input_sync(tpd->dev);
+				input_report_key(tpd->dev, KEY_C, 1);
+			 input_sync(tpd->dev);
+			 input_report_key(tpd->dev, KEY_C, 0);
+			 input_sync(tpd->dev);
+			break;
+
+		case GESTURE_S:		
+			input_report_key(tpd->dev, KEY_POWER, 1);
+			    input_sync(tpd->dev);
+			     input_report_key(tpd->dev, KEY_POWER, 0);
+			    input_sync(tpd->dev);
+			input_report_key(tpd->dev, KEY_S, 1);
+		 input_sync(tpd->dev);
+		 input_report_key(tpd->dev, KEY_S, 0);
+		 input_sync(tpd->dev);
+		break;
+
+		case GESTURE_V:
+			input_report_key(tpd->dev, KEY_POWER, 1);
+			    input_sync(tpd->dev);
+			     input_report_key(tpd->dev, KEY_POWER, 0);
+			    input_sync(tpd->dev);
+				input_report_key(tpd->dev, KEY_V, 1);
+		 input_sync(tpd->dev);
+		 input_report_key(tpd->dev, KEY_V, 0);
+		 input_sync(tpd->dev);
+		break;
+
+		case GESTURE_Z:	
+			input_report_key(tpd->dev, KEY_POWER, 1);
+			    input_sync(tpd->dev);
+			     input_report_key(tpd->dev, KEY_POWER, 0);
+			    input_sync(tpd->dev);
+		input_report_key(tpd->dev, KEY_Z, 1);
+		 input_sync(tpd->dev);
+		 input_report_key(tpd->dev, KEY_Z, 0);
+		 input_sync(tpd->dev);
+			break;
+		default:
+		
+			break;
+	}
+}
+*/
+extern void tpgesture_hander();
+static void check_gesture(int gesture_id)
+{	
+    printk("kaka gesture_id==0x%x\n ",gesture_id);
+    
+	switch(gesture_id)
+	{
+		case GESTURE_DOUBLECLICK:
+            		sprintf(tpgesture_value,"DOUBCLICK");
+			tpgesture_hander();
+			break;
+
+		case GESTURE_UP:
+            		sprintf(tpgesture_value,"UP");
+			tpgesture_hander();
+			break;
+
+		case GESTURE_DOWN:
+			sprintf(tpgesture_value,"DOWN");
+			tpgesture_hander();
+			break;
+
+		case GESTURE_LEFT:
+			sprintf(tpgesture_value,"LEFT");
+			tpgesture_hander();
+			break;
+
+		case GESTURE_RIGHT:
+			sprintf(tpgesture_value,"RIGHT");
+			tpgesture_hander();
+			break;
+
+		case GESTURE_C:
+			sprintf(tpgesture_value,"c");
+			tpgesture_hander();
+			break;
+
+		case GESTURE_O:
+			sprintf(tpgesture_value,"o");
+			tpgesture_hander();
+			break;
+
+		case GESTURE_W:
+			sprintf(tpgesture_value,"w");
+			tpgesture_hander();
+			break;
+
+		case GESTURE_E:
+			sprintf(tpgesture_value,"e");
+			tpgesture_hander();
+			break;
+
+		case GESTURE_V:
+			sprintf(tpgesture_value,"v");
+			tpgesture_hander();
+			break;
+
+		case GESTURE_M:
+			sprintf(tpgesture_value,"m");
+			tpgesture_hander();
+			break;
+
+		case GESTURE_Z:
+			sprintf(tpgesture_value,"z");
+			tpgesture_hander();
+			break;
+		case GESTURE_S:
+			sprintf(tpgesture_value,"s");
+			tpgesture_hander();
+			break;
+		default:		
+			break;
+	}
+}
+
+static int ft5x0x_read_Touchdata(void)
+{
+    unsigned char buf[FTS_GESTRUE_POINTS * 4] = { 0 };
+    int ret = -1;
+    int i = 0;
+    buf[0] = 0xd3;
+    int gestrue_id = 0;
+    short pointnum = 0;
+    ret = fts_i2c_Read(i2c_client, buf, 1, buf, FTS_GESTRUE_POINTS_HEADER);
+    if (ret < 0)
+    {
+        printk( "%s read touchdata failed.\n", __func__);
+        return ret;
+    }
+    /* FW ????3??? */
+  //  if (0x24 == buf[0] || 0x20 == buf[0] || 0x21 == buf[0] || 0x22 == buf[0] || 0x23 == buf[0])
+     printk("%s lsm--buf[0]=%x .\n",__func__,buf[0]);
+    if(buf[0]!=0xfe)
+    {
+        gestrue_id =  buf[0];
+        check_gesture(gestrue_id);
+        return -1;
+    }
+
+    pointnum = (short)(buf[1]) & 0xff;
+    buf[0] = 0xd3;
+    if((pointnum * 4 + 2+6)<255)
+    {
+    ret = fts_i2c_Read(i2c_client, buf, 1, buf, (pointnum * 4 + 2 + 6));
+    }
+    else
+    {
+         ret = fts_i2c_Read(i2c_client, buf, 1, buf, 255);
+          ret = fts_i2c_Read(i2c_client, buf, 0, buf+255, (pointnum * 4 + 2 +6)-255);
+
+    }
+    if (ret < 0)
+    {
+        printk( "%s read touchdata failed.\n", __func__);
+        return ret;
+    }
+    gestrue_id = fetch_object_sample(buf, pointnum);
+    for(i = 0;i < pointnum;i++)
+    {
+        coordinate_x[i] =  (((s16) buf[0 + (4 * i)]) & 0x0F) <<
+            8 | (((s16) buf[1 + (4 * i)])& 0xFF);
+        coordinate_y[i] = (((s16) buf[2 + (4 * i)]) & 0x0F) <<
+            8 | (((s16) buf[3 + (4 * i)]) & 0xFF);
+    }
+	check_gesture(gestrue_id);
+    return -1;
+}
+#endif
+ static int touch_event_handler(void *unused)
+ { 
+   	struct touch_info cinfo, pinfo;
+	int i=0;
+
+	struct sched_param param = { .sched_priority = RTPM_PRIO_TPD };
+	sched_setscheduler(current, SCHED_RR, &param);
+
+#ifdef TPD_PROXIMITY
+	int err;
+	hwm_sensor_data sensor_data;
+	u8 proximity_status;
+
+#endif
+ 	u8 state;
+	do
+	{
+#ifdef CONFIG_OF_TOUCH
+	enable_irq(touch_irq);
+#else
+	  mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
+#endif 
+		set_current_state(TASK_INTERRUPTIBLE); 
+		wait_event_interruptible(waiter,tpd_flag!=0);
+						 
+		tpd_flag = 0;
+			 
+		set_current_state(TASK_RUNNING);
+#ifdef FTS_GESTRUE
+		i2c_smbus_read_i2c_block_data(i2c_client, 0xd0, 1, &state);
+	  printk("%s lsm--state=%x .\n",__func__,state);
+//		if((get_suspend_state() == PM_SUSPEND_MEM) && (state ==1))
+		if(state ==1)
+		{
+			ft5x0x_read_Touchdata();
+			continue;
+		}
+#endif
+#ifdef TPD_PROXIMITY
+		if (tpd_proximity_flag == 1)
+		{
+			i2c_smbus_read_i2c_block_data(i2c_client, 0xB0, 1, &state);
+			TPD_PROXIMITY_DEBUG("proxi_5206 0xB0 state value is 1131 0x%02X\n", state);
+
+			if(!(state&0x01))
+			{
+				tpd_enable_ps(1);
+			}
+
+			i2c_smbus_read_i2c_block_data(i2c_client, 0x01, 1, &proximity_status);
+			TPD_PROXIMITY_DEBUG("proxi_5206 0x01 value is 1139 0x%02X\n", proximity_status);
+			
+			if (proximity_status == 0xC0)
+			{
+				tpd_proximity_detect = 0;	
+			}
+			else if(proximity_status == 0xE0)
+			{
+				tpd_proximity_detect = 1;
+			}
+
+			TPD_PROXIMITY_DEBUG("tpd_proximity_detect 1149 = %d\n", tpd_proximity_detect);
+
+			if ((err = tpd_read_ps()))
+			{
+				TPD_PROXIMITY_DMESG("proxi_5206 read ps data 1156: %d\n", err);	
+			}
+			sensor_data.values[0] = tpd_get_ps_value();
+			sensor_data.value_divide = 1;
+			sensor_data.status = SENSOR_STATUS_ACCURACY_MEDIUM;
+			if ((err = hwmsen_get_interrupt_data(ID_PROXIMITY, &sensor_data)))
+			{
+				TPD_PROXIMITY_DMESG(" proxi_5206 call hwmsen_get_interrupt_data failed= %d\n", err);	
+			}
+		}  
+#endif
+		 
+		if (tpd_touchinfo(&cinfo, &pinfo)) 
+		{
+		    //TPD_DEBUG("point_num = %d\n",point_num);
+			TPD_DEBUG_SET_TIME;
+			if(point_num >0) 
+			{
+			    for(i =0; i<point_num; i++)//only support 3 point
+			    {
+			         tpd_down(cinfo.x[i], cinfo.y[i], cinfo.id[i]);
+			    }
+			    input_sync(tpd->dev);
+			}
+			else  
+    		{
+			    tpd_up(cinfo.x[0], cinfo.y[0]);
+        	    //TPD_DEBUG("release --->\n"); 
+        	    //input_mt_sync(tpd->dev);
+        	    input_sync(tpd->dev);
+        		}
+        	}
+
+        	if(tpd_mode==12)
+        	{
+           //power down for desence debug
+           //power off, need confirm with SA
+#ifdef TPD_POWER_SOURCE_CUSTOM
+			hwPowerDown(TPD_POWER_SOURCE_CUSTOM, "TP");
+#else
+			hwPowerDown(MT65XX_POWER_LDO_VGP2, "TP");
+#endif
+#ifdef TPD_POWER_SOURCE_1800
+			hwPowerDown(TPD_POWER_SOURCE_1800, "TP");
+#endif 
+    		msleep(20);
+    	}
+ 	}while(!kthread_should_stop());
+ 
+	return 0;
+}
+ 
+static int tpd_detect (struct i2c_client *client, struct i2c_board_info *info) 
+{
+	strcpy(info->type, TPD_DEVICE);	
+	return 0;
+}
+ 
+#ifdef CONFIG_OF_TOUCH
+static irqreturn_t tpd_eint_interrupt_handler(unsigned irq, struct irq_desc *desc)
+{
+	TPD_DEBUG_PRINT_INT;
+		
+	tpd_flag = 1;
+	/* enter EINT handler disable INT, make sure INT is disable when handle touch event including top/bottom half */
+	/* use _nosync to avoid deadlock */
+	disable_irq_nosync(touch_irq);
+	wake_up_interruptible(&waiter);
+    return IRQ_HANDLED;
+}
+#else
+static void tpd_eint_interrupt_handler(void)
+{
+	//TPD_DEBUG("TPD interrupt has been triggered\n");
+	TPD_DEBUG_PRINT_INT;
+	tpd_flag = 1;
+	wake_up_interruptible(&waiter);
+}
+#endif
+
+void focaltech_get_upgrade_array(void)
+{
+
+	u8 chip_id;
+	u32 i;
+
+	i2c_smbus_read_i2c_block_data(i2c_client,FT_REG_CHIP_ID,1,&chip_id);
+
+	printk("%s chip_id = %x\n", __func__, chip_id);
+
+	for(i=0;i<sizeof(fts_updateinfo)/sizeof(struct Upgrade_Info);i++)
+	{
+		if(chip_id==fts_updateinfo[i].CHIP_ID)
+		{
+			memcpy(&fts_updateinfo_curr, &fts_updateinfo[i], sizeof(struct Upgrade_Info));
+			break;
+		}
+	}
+
+	if(i >= sizeof(fts_updateinfo)/sizeof(struct Upgrade_Info))
+	{
+		memcpy(&fts_updateinfo_curr, &fts_updateinfo[0], sizeof(struct Upgrade_Info));
+	}
+}
+
+#ifdef CONFIG_OF_TOUCH 
+static int tpd_irq_registration(void)
+{
+	struct device_node *node = NULL;
+	int ret = 0;
+	u32 ints[2] = {0,0};
+	GTP_INFO("Device Tree Tpd_irq_registration!");
+	
+	node = of_find_compatible_node(NULL, NULL, "mediatek, TOUCH_PANEL-eint");
+	if(node){
+		of_property_read_u32_array(node , "debounce", ints, ARRAY_SIZE(ints));
+		gpio_set_debounce(ints[0], ints[1]);
+
+		touch_irq = irq_of_parse_and_map(node, 0);
+		
+		if (!int_type)	//EINTF_TRIGGER
+		{
+			ret = request_irq(touch_irq, (irq_handler_t)tpd_eint_interrupt_handler, EINTF_TRIGGER_RISING, "TOUCH_PANEL-eint", NULL);
+            //gtp_eint_trigger_type = EINTF_TRIGGER_RISING;
+			if(ret > 0){
+			    ret = -1;
+			    GTP_ERROR("tpd request_irq IRQ LINE NOT AVAILABLE!.");
+			}
+		}
+		else
+		{
+			ret = request_irq(touch_irq, (irq_handler_t)tpd_eint_interrupt_handler, EINTF_TRIGGER_FALLING, "TOUCH_PANEL-eint", NULL);
+            //gtp_eint_trigger_type = EINTF_TRIGGER_FALLING;
+			if(ret > 0){
+			    ret = -1;
+			    GTP_ERROR("tpd request_irq IRQ LINE NOT AVAILABLE!.");
+			}
+		}
+	}else{
+		GTP_ERROR("tpd request_irq can not find touch eint device node!.");
+		ret = -1;
+	}
+	GTP_INFO("[%s]irq:%d, debounce:%d-%d:", __FUNCTION__, touch_irq, ints[0], ints[1]);
+	return ret;
+}
+#endif
+
+static int tpd_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{	 
+	int retval = TPD_OK;
+	char data;
+	u8 report_rate=0;
+	int err=0;
+	int reset_count = 0;
+	u8 chip_id,i;
+
+reset_proc:   
+	i2c_client = client;
+   
+	//power on, need confirm with SA
+	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
+	mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
+	mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ZERO);  
+	msleep(5);
+	TPD_DMESG(" fts ic reset\n");
+	
+#ifdef TPD_POWER_SOURCE_CUSTOM
+	hwPowerOn(TPD_POWER_SOURCE_CUSTOM, VOL_2800, "TP");
+#else
+	hwPowerOn(MT65XX_POWER_LDO_VGP2, VOL_2800, "TP");
+#endif
+
+#if 0 //def TPD_POWER_SOURCE_1800
+	hwPowerOn(TPD_POWER_SOURCE_1800, VOL_1800, "TP");
+#endif 
+	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
+	mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
+	mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ONE);
+    
+#ifdef TPD_CLOSE_POWER_IN_SLEEP	 
+	hwPowerDown(TPD_POWER_SOURCE,"TP");
+	hwPowerOn(TPD_POWER_SOURCE,VOL_3300,"TP");
+	msleep(100);
+
+#else
+       mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
+       mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
+       mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ZERO);  
+	msleep(5);
+	TPD_DMESG(" fts ic reset\n");
+	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
+       mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
+       mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ONE);
+#endif
+
+	mt_set_gpio_mode(GPIO_CTP_EINT_PIN, GPIO_CTP_EINT_PIN_M_EINT);
+       mt_set_gpio_dir(GPIO_CTP_EINT_PIN, GPIO_DIR_IN);
+       mt_set_gpio_pull_enable(GPIO_CTP_EINT_PIN, GPIO_PULL_ENABLE);
+       mt_set_gpio_pull_select(GPIO_CTP_EINT_PIN, GPIO_PULL_UP);
+ 
+#ifdef CONFIG_OF_TOUCH
+	/* EINT device tree, default EINT enable */
+	tpd_irq_registration();
+	enable_irq(touch_irq);
+#else
+	  mt_eint_set_hw_debounce(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_DEBOUNCE_CN);
+	  mt_eint_registration(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINTF_TRIGGER_FALLING, tpd_eint_interrupt_handler, 1);
+	  mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
+#endif 
+	msleep(400);
+ 
+	if((i2c_smbus_read_i2c_block_data(i2c_client, 0x00, 1, &data))< 0)
+	{
+		TPD_DMESG("I2C transfer error, line: %d\n", __LINE__);
+#ifdef TPD_RESET_ISSUE_WORKAROUND
+        if ( reset_count < TPD_MAX_RESET_COUNT )
+        {
+            reset_count++;
+            goto reset_proc;
+        }
+#endif
+		   return -1; 
+	}
+
+	tpd_load_status = 1;
+ //   tpd_mstar_status =0 ;  // compatible mstar and ft6306 chenzhecong
+ 
+        focaltech_get_upgrade_array();
+
+	#ifdef FTS_APK_DEBUG
+	ft5x0x_create_apk_debug_channel(client);
+        #endif
+	#ifdef TPD_SYSFS_DEBUG
+	fts_create_sysfs(i2c_client);
+	#endif
+
+/*
+	#ifdef FTS_CTL_IIC
+	if (ft_rw_iic_drv_init(i2c_client) < 0)
+		TPD_DMESG(TPD_DEVICE, "%s:[FTS] create fts control iic driver failed\n",__func__);
+	#endif
+#ifdef FTS_GESTRUE
+	init_para(480,854,60,0,0);
+	//fts_write_reg(i2c_client, 0xd0, 0x01);
+#endif
+*/	
+	#ifdef VELOCITY_CUSTOM_FT5206
+	if((err = misc_register(&tpd_misc_device)))
+	{
+		printk("mtk_tpd: tpd_misc_device register failed\n");
+		
+	}
+	#endif
+
+	#ifdef TPD_AUTO_UPGRADE
+	printk("********************Enter CTP Auto Upgrade********************\n");
+	fts_ctpm_auto_upgrade(i2c_client);
+	#endif
+	thread = kthread_run(touch_event_handler, 0, TPD_DEVICE);
+	if (IS_ERR(thread))
+	{ 
+		retval = PTR_ERR(thread);
+		TPD_DMESG(TPD_DEVICE " failed to create kernel thread: %d\n", retval);
+	}
+
+	TPD_DMESG("FTS Touch Panel Device Probe %s\n", (retval < TPD_OK) ? "FAIL" : "PASS");
+
+#ifdef TPD_PROXIMITY
+	struct hwmsen_object obj_ps;
+	
+	obj_ps.polling = 0;//interrupt mode
+	obj_ps.sensor_operate = tpd_ps_operate;
+	if((err = hwmsen_attach(ID_PROXIMITY, &obj_ps)))
+	{
+		APS_ERR("proxi_fts attach fail = %d\n", err);
+	}
+	else
+	{
+		APS_ERR("proxi_fts attach ok = %d\n", err);
+	}		
+#endif
+   return 0;
+   
+ }
+
+ static int tpd_remove(struct i2c_client *client)
+{
+
+        #ifdef FTS_APK_DEBUG
+	ft5x0x_release_apk_debug_channel();
+	#endif
+   	#ifdef TPD_SYSFS_DEBUG
+	fts_release_sysfs(client);
+	#endif
+
+	#ifdef FTS_CTL_IIC
+	ft_rw_iic_drv_exit();
+	#endif
+	
+	TPD_DEBUG("TPD removed\n");
+ 
+   	return 0;
+}
+ 
+ #define IIC_DMA_MAX_TRANSFER_SIZE     250
+static int tpd_local_init(void)
+{
+  	TPD_DMESG("FTS I2C Touchscreen Driver (Built %s @ %s)\n", __DATE__, __TIME__);
+ #if 1//TPD_SUPPORT_I2C_DMA
+	//mutex_init(&dma_mutex);
+	tpd->dev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
+	I2CDMABuf_va = (u8 *) dma_alloc_coherent(&tpd->dev->dev, IIC_DMA_MAX_TRANSFER_SIZE, &I2CDMABuf_pa, GFP_KERNEL);
+	if (!I2CDMABuf_va) {
+		TPD_DMESG("Allocate DMA I2C Buffer failed!");
+		return -1;
+	}
+	memset(I2CDMABuf_va, 0, IIC_DMA_MAX_TRANSFER_SIZE);
+#endif
+   	if(i2c_add_driver(&tpd_i2c_driver)!=0)
+   	{
+  		TPD_DMESG("FTS unable to add i2c driver.\n");
+      	return -1;
+    }
+    if(tpd_load_status == 0) 
+    {
+    	TPD_DMESG("FTS add error touch panel driver.\n");
+    	i2c_del_driver(&tpd_i2c_driver);
+    	return -1;
+    }
+	
+#ifdef TPD_HAVE_BUTTON     
+	if(TPD_RES_Y > 854)
+	{
+	    tpd_button_setting(TPD_KEY_COUNT, tpd_keys_local, tpd_keys_dim_local_qhd);// initialize tpd button data
+	}
+	else
+	{
+	    tpd_button_setting(TPD_KEY_COUNT, tpd_keys_local, tpd_keys_dim_local_fwvga);// initialize tpd button data
+	}
+#endif   
+  
+#if (defined(TPD_WARP_START) && defined(TPD_WARP_END))    
+    TPD_DO_WARP = 1;
+    memcpy(tpd_wb_start, tpd_wb_start_local, TPD_WARP_CNT*4);
+    memcpy(tpd_wb_end, tpd_wb_start_local, TPD_WARP_CNT*4);
+#endif 
+
+#if (defined(TPD_HAVE_CALIBRATION) && !defined(TPD_CUSTOM_CALIBRATION))
+    memcpy(tpd_calmat, tpd_def_calmat_local, 8*4);
+    memcpy(tpd_def_calmat, tpd_def_calmat_local, 8*4);	
+#endif  
+    TPD_DMESG("end %s, %d\n", __FUNCTION__, __LINE__);  
+    tpd_type_cap = 1;
+    return 0; 
+ }
+
+ static void tpd_resume( struct early_suspend *h )
+ {
+  //int retval = TPD_OK;
+  //char data;
+#ifdef TPD_PROXIMITY	
+	if (tpd_proximity_flag == 1)
+	{
+		if(tpd_proximity_flag_one == 1)
+		{
+			tpd_proximity_flag_one = 0;	
+			TPD_DMESG(TPD_DEVICE " tpd_proximity_flag_one \n"); 
+			return;
+		}
+	}
+#endif	
+ 
+   	TPD_DMESG("TPD wake up\n");
+#ifdef FTS_GESTRUE
+	if((g_call_state != CALL_ACTIVE)&&(tpgesture_status))
+	{
+            fts_write_reg(i2c_client,0xD0,0x00);
+	    //fts_write_reg(i2c_client,0xD1,0x00);
+	    //fts_write_reg(i2c_client,0xD2,0x00);
+	    tpd_halt = 0;
+	   // return;
+	}
+#endif
+#ifdef TPD_CLOSE_POWER_IN_SLEEP	
+	hwPowerOn(TPD_POWER_SOURCE,VOL_3300,"TP");
+
+#else
+
+	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
+    mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
+    mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ZERO);  
+    msleep(2);  
+
+#ifdef TPD_POWER_SOURCE_CUSTOM
+	hwPowerOn(TPD_POWER_SOURCE_CUSTOM, VOL_2800, "TP");
+#else
+	hwPowerOn(MT65XX_POWER_LDO_VGP2, VOL_2800, "TP");
+#endif
+   // mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
+   // mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
+    mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ONE);
+#endif
+#ifdef CONFIG_OF_TOUCH
+	enable_irq(touch_irq);
+#else
+	  mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
+#endif 
+	msleep(30);
+	tpd_halt = 0;
+	/* for resume debug
+	if((i2c_smbus_read_i2c_block_data(i2c_client, 0x00, 1, &data))< 0)
+	{
+		TPD_DMESG("resume I2C transfer error, line: %d\n", __LINE__);
+	}
+	*/
+	tpd_up(0,0);
+	input_sync(tpd->dev);
+	TPD_DMESG("TPD wake up done\n");
+	 //return retval;
+ }
+
+ static void tpd_suspend( struct early_suspend *h )
+ {
+	// int retval = TPD_OK;
+	 static char data = 0x3;
+
+#ifdef TPD_PROXIMITY
+	if (tpd_proximity_flag == 1)
+	{
+		tpd_proximity_flag_one = 1;	
+		return;
+	}
+#endif
+
+#if GTP_GESTURE_WAKEUP
+	printk("[xy-tp]%d\n", tpgesture_status);
+
+	if((g_call_state != CALL_ACTIVE)&&(tpgesture_status)) 
+	{
+	printk("[xy-tp]:gesture mode\n");
+		msleep(200);
+		mutex_lock(&i2c_access);
+		fts_write_reg(i2c_client, 0xd0, 0x01);
+	//	if (fts_updateinfo_curr.CHIP_ID==0x54) 
+	//	{
+			fts_write_reg(i2c_client, 0xd1, 0xff);
+			fts_write_reg(i2c_client, 0xd2, 0xff);
+			fts_write_reg(i2c_client, 0xd5, 0xff);
+			fts_write_reg(i2c_client, 0xd6, 0xff);
+			fts_write_reg(i2c_client, 0xd7, 0xff);
+			fts_write_reg(i2c_client, 0xd8, 0xff);
+	//	}
+		 mutex_unlock(&i2c_access);
+		tpd_halt = 1;
+		return;
+	} 
+	else 
+	{
+#endif
+	tpd_halt = 1;
+	 TPD_DMESG("TPD enter sleep\n");
+#ifdef CONFIG_OF_TOUCH
+		disable_irq(touch_irq);
+#else
+		mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
+#endif
+#ifdef TPD_CLOSE_POWER_IN_SLEEP	
+	hwPowerDown(TPD_POWER_SOURCE,"TP");
+#else
+	mutex_lock(&i2c_access);
+	i2c_smbus_write_i2c_block_data(i2c_client, 0xA5, 1, &data);  //TP enter sleep mode
+	mutex_unlock(&i2c_access);
+#endif
+  #ifdef TPD_POWER_SOURCE_CUSTOM
+        hwPowerDown(TPD_POWER_SOURCE_CUSTOM, "TP");
+    #else
+        hwPowerDown(MT65XX_POWER_LDO_VGP2, "TP");
+    #endif
+	TPD_DMESG("TPD enter sleep done\n");
+	//return retval;
+	#if GTP_GESTURE_WAKEUP
+	}
+	#endif
+ } 
+#if GTP_GESTURE_WAKEUP
+static ssize_t show_tpgesture_value(struct device* dev, struct device_attribute *attr, char *buf)
+{
+	 printk("show tp gesture value is %s \n",tpgesture_value);
+	 return scnprintf(buf, PAGE_SIZE, "%s\n", tpgesture_value);
+}
+ 
+static ssize_t show_tpgesture_status_value(struct device* dev, struct device_attribute *attr, char *buf)
+{
+	 printk("show tp gesture status is %s \n",tpgesture_status_value);
+	 return scnprintf(buf, PAGE_SIZE, "%s\n", tpgesture_status_value);
+}
+ 
+static ssize_t store_tpgesture_status_value(struct device* dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	 if(!strncmp(buf, "on", 2))
+	 {
+		 sprintf(tpgesture_status_value,"on");
+		 tpgesture_status = 1;//status --- on
+	 }
+	 else
+	 {
+		 sprintf(tpgesture_status_value,"off");
+		 tpgesture_status = 0;//status --- off
+	 }
+ 
+	 return count;
+}
+ 
+static DEVICE_ATTR(tpgesture,	0664, show_tpgesture_value, NULL);
+static DEVICE_ATTR(tpgesture_status,  0666, show_tpgesture_status_value, store_tpgesture_status_value);
+static struct device_attribute *tpd_attr_list[] = {
+	 &dev_attr_tpgesture,
+	 &dev_attr_tpgesture_status,
+};
+#endif
+
+
+ static struct tpd_driver_t tpd_device_driver = {
+	.tpd_device_name = TPD_NAME,
+	.tpd_local_init = tpd_local_init,
+	.suspend = tpd_suspend,
+	.resume = tpd_resume,
+#ifdef TPD_HAVE_BUTTON
+	.tpd_have_button = 1,
+#else
+	.tpd_have_button = 0,
+#endif		
+#if GTP_GESTURE_WAKEUP
+	.attrs = {
+		.attr = &tpd_attr_list,
+		.num = (int)(sizeof(tpd_attr_list)/sizeof(tpd_attr_list[0])),
+	},
+#endif
+ };
+ /* called when loaded into kernel */
+static int __init tpd_driver_init(void) {
+	printk("MediaTek FTS touch panel driver init\n");
+	i2c_register_board_info(IIC_PORT, &ft5206_i2c_tpd, 1);
+	if(tpd_driver_add(&tpd_device_driver) < 0)
+		TPD_DMESG("add FTS driver failed\n");
+	 return 0;
+ }
+ 
+ /* should never be called */
+static void __exit tpd_driver_exit(void) {
+	TPD_DMESG("MediaTek FTS touch panel driver exit\n");
+	//input_unregister_device(tpd->dev);
+	tpd_driver_remove(&tpd_device_driver);
+}
+ 
+module_init(tpd_driver_init);
+module_exit(tpd_driver_exit);
+
+
diff --git a/drivers/input/touchscreen/mediatek/ft_allinone_gesture/focaltech_ex_fun.c b/drivers/input/touchscreen/mediatek/ft_allinone_gesture/focaltech_ex_fun.c
new file mode 100644
index 0000000..6dbeb55
--- /dev/null
+++ b/drivers/input/touchscreen/mediatek/ft_allinone_gesture/focaltech_ex_fun.c
@@ -0,0 +1,2251 @@
+/*
+ *drivers/input/touchscreen/ft5x06_ex_fun.c
+ *
+ *FocalTech IC driver expand function for debug.
+ *
+ *Copyright (c) 2010  Focal tech Ltd.
+ *
+ *This software is licensed under the terms of the GNU General Public
+ *License version 2, as published by the Free Software Foundation, and
+ *may be copied, distributed, and modified under those terms.
+ *
+ *This program is distributed in the hope that it will be useful,
+ *but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *GNU General Public License for more details.
+ *
+ *Note:the error code of EIO is the general error in this file.
+ */
+
+#include "tpd.h"
+
+#include "tpd_custom_fts.h"
+
+#include "focaltech_ex_fun.h"
+
+#include <linux/netdevice.h>
+#include <linux/mount.h>
+#include <linux/slab.h>
+//#include <linux/netdevice.h>
+#include <../fs/proc/internal.h>
+#include <linux/proc_fs.h>
+#ifdef FTS_SCAP_TEST
+#include "scap_test_lib.h"
+extern struct i2c_client *g_focalclient;
+#endif
+
+extern void mt_eint_unmask(unsigned int line);
+extern void mt_eint_mask(unsigned int line);
+
+extern u8 *I2CDMABuf_va;
+extern dma_addr_t I2CDMABuf_pa;
+
+extern struct Upgrade_Info fts_updateinfo_curr;
+
+int  fts_5x46_ctpm_fw_upgrade(struct i2c_client * client, u8* pbt_buf, u32 dw_lenth);
+
+
+int fts_ctpm_fw_upgrade(struct i2c_client *client, u8 *pbt_buf,
+			  u32 dw_lenth);
+			  
+	int fts_6x36_ctpm_fw_upgrade(struct i2c_client *client, u8 *pbt_buf,
+			  u32 dw_lenth);
+		
+
+
+static DEFINE_MUTEX(g_device_mutex);
+ 
+
+
+
+/*
+*fts_i2c_Read-read data and write data by i2c
+*@client: handle of i2c
+*@writebuf: Data that will be written to the slave
+*@writelen: How many bytes to write
+*@readbuf: Where to store data read from slave
+*@readlen: How many bytes to read
+*
+*Returns negative errno, else the number of messages executed
+*
+*
+*/
+int fts_i2c_Read(struct i2c_client *client, char *writebuf,
+		    int writelen, char *readbuf, int readlen)
+{
+	int ret,i;
+	
+#if 0//for normal I2c transfer
+	if (writelen > 0) {
+		struct i2c_msg msgs[] = {
+			{
+			 .addr = client->addr,
+			 .flags = 0,
+			 .len = writelen,
+			 .buf = writebuf,
+			 },
+			{
+			 .addr = client->addr,
+			 .flags = I2C_M_RD,
+			 .len = readlen,
+			 .buf = readbuf,
+			 },
+		};
+		ret = i2c_transfer(client->adapter, msgs, 2);
+		if (ret < 0)
+			dev_err(&client->dev, "f%s: i2c read error.\n",
+				__func__);
+	} else {
+		struct i2c_msg msgs[] = {
+			{
+			 .addr = client->addr,
+			 .flags = I2C_M_RD,
+			 .len = readlen,
+			 .buf = readbuf,
+			 },
+		};
+		ret = i2c_transfer(client->adapter, msgs, 1);
+		if (ret < 0)
+			dev_err(&client->dev, "%s:i2c read error.\n", __func__);
+	}
+#else// for DMA I2c transfer
+	if(writelen!=0)
+	{
+		//DMA Write
+		if(0)//if(writelen < 8  )
+		{
+			
+			//MSE_ERR("Sensor non-dma write timing is %x!\r\n", this_client->timing);
+			ret= i2c_master_send(client, writebuf, writelen);
+		}
+		else
+		{
+			for(i = 0 ; i < writelen; i++)
+			{
+				I2CDMABuf_va[i] = writebuf[i];
+			}
+
+			client->addr = client->addr & I2C_MASK_FLAG | I2C_DMA_FLAG;
+		
+			if((ret=i2c_master_send(client, (unsigned char *)I2CDMABuf_pa, writelen))!=writelen)
+				dev_err(&client->dev, "###%s i2c write len=%x,buffaddr=%x\n", __func__,ret,I2CDMABuf_pa);
+			//MSE_ERR("Sensor dma timing is %x!\r\n", this_client->timing);
+			//return ret;
+			client->addr = client->addr & I2C_MASK_FLAG &(~ I2C_DMA_FLAG);
+
+		}
+	}
+	//DMA Read 
+	if(readlen!=0)
+	{
+		if(0)//if (readlen <8) {
+		{
+			ret = i2c_master_recv(client, (unsigned char *)readbuf, readlen);
+		}
+		else
+		{
+
+			client->addr = client->addr & I2C_MASK_FLAG | I2C_DMA_FLAG;
+			ret = i2c_master_recv(client, (unsigned char *)I2CDMABuf_pa, readlen);
+
+			for(i = 0; i < readlen; i++)
+	        {
+	            readbuf[i] = I2CDMABuf_va[i];
+	        }
+		client->addr = client->addr & I2C_MASK_FLAG &(~ I2C_DMA_FLAG);
+
+		}
+	}
+	#endif
+	return ret;
+}
+/*write data by i2c*/
+
+int fts_i2c_Write(struct i2c_client *client, char *writebuf, int writelen)
+{
+	int ret;
+	int i = 0;
+	//printk("fts_i2c_Write  %d  %x  %x %x %x",writelen,writebuf,I2CDMABuf_va,I2CDMABuf_pa,client);
+	
+   client->addr = client->addr & I2C_MASK_FLAG;
+  // client->ext_flag |= I2C_DIRECTION_FLAG; 
+  // client->timing = 100;
+    #if 0
+	struct i2c_msg msg[] = {
+		{
+		 .addr = client->addr,
+		 .flags = 0,
+		 .len = writelen,
+		 .buf = writebuf,
+		 },
+	};
+
+	ret = i2c_transfer(client->adapter, msg, 1);
+	if (ret < 0)
+		dev_err(&client->dev, "%s i2c write error.\n", __func__);
+	#else
+	
+	if(0)//if(writelen < 8)
+	{
+		
+		//MSE_ERR("Sensor non-dma write timing is %x!\r\n", this_client->timing);
+		ret = i2c_master_send(client, writebuf, writelen);
+	}
+	else
+	{
+		for(i = 0 ; i < writelen; i++)
+		{
+			I2CDMABuf_va[i] = writebuf[i];
+		}
+
+		client->addr = client->addr & I2C_MASK_FLAG | I2C_DMA_FLAG;
+
+		if((ret=i2c_master_send(client, (unsigned char *)I2CDMABuf_pa, writelen))!=writelen)
+			dev_err(&client->dev, "###%s i2c write len=%x,buffaddr=%x\n", __func__,ret,I2CDMABuf_pa);
+		//MSE_ERR("Sensor dma timing is %x!\r\n", this_client->timing);
+		client->addr = client->addr & I2C_MASK_FLAG &(~ I2C_DMA_FLAG);
+
+	} 
+	#endif
+	return ret;
+
+}
+
+int fts_write_reg(struct i2c_client *client, u8 regaddr, u8 regvalue)
+{
+	unsigned char buf[2] = {0};
+	buf[0] = regaddr;
+	buf[1] = regvalue;
+
+	return fts_i2c_Write(client, buf, sizeof(buf));
+}
+
+
+int fts_read_reg(struct i2c_client *client, u8 regaddr, u8 *regvalue)
+{
+	return fts_i2c_Read(client, &regaddr, 1, regvalue, 1);
+}
+
+int fts_ctpm_auto_clb(struct i2c_client *client)
+{
+	unsigned char uc_temp = 0x00;
+	unsigned char i = 0;
+
+	/*start auto CLB */
+	msleep(200);
+
+	fts_write_reg(client, 0, FTS_FACTORYMODE_VALUE);
+	/*make sure already enter factory mode */
+	msleep(100);
+	/*write command to start calibration */
+	fts_write_reg(client, 2, 0x4);
+	msleep(300);
+	if ((fts_updateinfo_curr.CHIP_ID==0x11) ||(fts_updateinfo_curr.CHIP_ID==0x12) ||(fts_updateinfo_curr.CHIP_ID==0x13) ||(fts_updateinfo_curr.CHIP_ID==0x14)) //5x36,5x36i
+	{
+		for(i=0;i<100;i++)
+		{
+			fts_read_reg(client, 0x02, &uc_temp);
+			if (0x02 == uc_temp ||
+				0xFF == uc_temp)
+			{
+				/*if 0x02, then auto clb ok, else 0xff, auto clb failure*/
+			    break;
+			}
+			msleep(20);	    
+		}
+	} else {
+		for(i=0;i<100;i++)
+		{
+				fts_read_reg(client, 0, &uc_temp);
+			if (0x0 == ((uc_temp&0x70)>>4))  /*return to normal mode, calibration finish*/
+			{
+			    break;
+			}
+			msleep(20);	    
+		}
+	}
+	/*calibration OK*/
+	fts_write_reg(client, 0, 0x40);  /*goto factory mode for store*/
+	msleep(200);   /*make sure already enter factory mode*/
+	fts_write_reg(client, 2, 0x5);  /*store CLB result*/
+	msleep(300);
+	fts_write_reg(client, 0, FTS_WORKMODE_VALUE);	/*return to normal mode */
+	msleep(300);
+
+	/*store CLB result OK */
+	return 0;
+}
+
+#ifdef TPD_AUTO_UPGRADE
+static unsigned char CTPM_FW[] = {
+//	#include "FT6336_V9_S4153_TH0464F00A_0x11_app.i"
+};
+
+/*
+upgrade with *.i file
+*/
+int fts_ctpm_fw_upgrade_with_i_file(struct i2c_client *client)
+{
+	u8 *pbt_buf = NULL;
+	int i_ret;
+	int fw_len = sizeof(CTPM_FW);
+
+	/*judge the fw that will be upgraded
+	* if illegal, then stop upgrade and return.
+	*/
+	if ((fts_updateinfo_curr.CHIP_ID==0x54))
+	{
+		if (fw_len < 8 || fw_len > 54 * 1024) 
+		{
+			dev_err(&client->dev, "%s:FW length error\n", __func__);
+			return -EIO;
+		}
+
+		pbt_buf = CTPM_FW;
+		i_ret = fts_5x46_ctpm_fw_upgrade(client, pbt_buf, sizeof(CTPM_FW));
+		if (i_ret != 0)
+			dev_err(&client->dev, "%s:upgrade failed. err.\n",
+					__func__);
+		return i_ret;
+	}
+
+	 if ((fts_updateinfo_curr.CHIP_ID==0x36))
+	{
+		i_ret = fts_6x36_ctpm_fw_upgrade(client, pbt_buf, sizeof(CTPM_FW));
+		if (i_ret != 0)
+			dev_err(&client->dev, "%s:upgrade failed. err.\n",
+					__func__);
+		return i_ret;
+	}
+	
+	if (fw_len < 8 || fw_len > 32 * 1024) {
+		dev_err(&client->dev, "%s:FW length error\n", __func__);
+		return -EIO;
+	}
+
+	if (((CTPM_FW[fw_len - 8] ^ CTPM_FW[fw_len - 6]) == 0xFF
+		&& (CTPM_FW[fw_len - 7] ^ CTPM_FW[fw_len - 5]) == 0xFF
+		&& (CTPM_FW[fw_len - 3] ^ CTPM_FW[fw_len - 4]) == 0xFF)
+		||((CTPM_FW[0x104] ^ CTPM_FW[0x105]) == 0xFF
+		&& (CTPM_FW[0x106] ^ CTPM_FW[0x107]) == 0xFF))
+		{
+		/*FW upgrade */
+		pbt_buf = CTPM_FW;
+		/*call the upgrade function */
+		i_ret = fts_ctpm_fw_upgrade(client, pbt_buf, sizeof(CTPM_FW));
+		if (i_ret != 0)
+			dev_err(&client->dev, "%s:upgrade failed. err.\n",
+					__func__);
+		else if(fts_updateinfo_curr.AUTO_CLB==AUTO_CLB_NEED)
+			fts_ctpm_auto_clb(client);	/*start auto CLB */
+
+	} else {
+		dev_err(&client->dev, "%s:FW format error\n", __func__);
+		return -EBADFD;
+	}
+
+	return i_ret;
+}
+
+u8 fts_ctpm_get_i_file_ver(void)
+{
+	u16 ui_sz;
+	ui_sz = sizeof(CTPM_FW);
+	if (ui_sz > 2)
+	{
+	    if(fts_updateinfo_curr.CHIP_ID==0x36)
+                return CTPM_FW[0x10a];
+	    else
+		return CTPM_FW[ui_sz - 2];
+
+	}
+
+	return 0x00;	/*default value */
+}
+
+u8 fts_ctpm_get_i_file_vendor(void)
+{
+	u16 ui_sz;
+	ui_sz = sizeof(CTPM_FW);
+	if (ui_sz > 1)
+	{
+	    if(fts_updateinfo_curr.CHIP_ID==0x36)
+                return CTPM_FW[0x108];
+	    else
+		return CTPM_FW[ui_sz - 1];
+
+	}
+
+	return 0x00;	/*default value */
+}
+
+int fts_ctpm_auto_upgrade(struct i2c_client *client)
+{
+	u8 uc_host_fm_ver = FT_REG_FW_VER;
+	u8 uc_tp_fm_ver;
+	u8 uc_host_vendor_id = FT_REG_VENDOR_ID;
+	u8 uc_tp_vendor_id;
+	int i_ret;
+
+        fts_read_reg(client, FT_REG_VENDOR_ID, &uc_tp_vendor_id);
+	uc_host_vendor_id = fts_ctpm_get_i_file_vendor();
+	if(uc_tp_vendor_id!=uc_host_vendor_id)return 0;
+	
+	fts_read_reg(client, FT_REG_FW_VER, &uc_tp_fm_ver);
+	uc_host_fm_ver = fts_ctpm_get_i_file_ver();
+
+       printk("[FTS] uc_tp_fm_ver = 0x%x, uc_host_fm_ver = 0x%x\n",uc_tp_fm_ver, uc_host_fm_ver);
+	   
+	if (/*the firmware in touch panel maybe corrupted */
+		uc_tp_fm_ver == FT_REG_FW_VER ||
+		/*the firmware in host flash is new, need upgrade */
+	     uc_tp_fm_ver < uc_host_fm_ver
+	    ) {
+		msleep(100);
+		dev_dbg(&client->dev, "[FTS] uc_tp_fm_ver = 0x%x, uc_host_fm_ver = 0x%x\n",
+				uc_tp_fm_ver, uc_host_fm_ver);
+		i_ret = fts_ctpm_fw_upgrade_with_i_file(client);
+		if (i_ret == 0)	{
+			msleep(300);
+			uc_host_fm_ver = fts_ctpm_get_i_file_ver();
+			dev_dbg(&client->dev, "[FTS] upgrade to new version 0x%x\n",
+					uc_host_fm_ver);
+		} else {
+			pr_err("[FTS] upgrade failed ret=%d.\n", i_ret);
+			return -EIO;
+		}
+	}
+
+	return 0;
+}
+#endif
+/*update project setting
+*only update these settings for COB project, or for some special case
+*/
+int fts_ctpm_update_project_setting(struct i2c_client *client)
+{
+	u8 uc_i2c_addr;	/*I2C slave address (7 bit address)*/
+	u8 uc_io_voltage;	/*IO Voltage 0---3.3v;	1----1.8v*/
+	u8 uc_panel_factory_id;	/*TP panel factory ID*/
+	u8 buf[FTS_SETTING_BUF_LEN];
+	u8 reg_val[2] = {0};
+	u8 auc_i2c_write_buf[10] = {0};
+	u8 packet_buf[FTS_SETTING_BUF_LEN + 6];
+	u32 i = 0;
+	int i_ret;
+
+	uc_i2c_addr = client->addr;
+	uc_io_voltage = 0x0;
+	uc_panel_factory_id = 0x5a;
+
+
+	/*Step 1:Reset  CTPM
+	*write 0xaa to register 0xfc
+	*/
+	fts_write_reg(client, 0xfc, 0xaa);
+	msleep(50);
+
+	/*write 0x55 to register 0xfc */
+	fts_write_reg(client, 0xfc, 0x55);
+	msleep(30);
+
+	/*********Step 2:Enter upgrade mode *****/
+	auc_i2c_write_buf[0] = 0x55;
+	auc_i2c_write_buf[1] = 0xaa;
+	do {
+		i++;
+		i_ret = fts_i2c_Write(client, auc_i2c_write_buf, 2);
+		msleep(5);
+	} while (i_ret <= 0 && i < 5);
+
+
+	/*********Step 3:check READ-ID***********************/
+	auc_i2c_write_buf[0] = 0x90;
+	auc_i2c_write_buf[1] = auc_i2c_write_buf[2] = auc_i2c_write_buf[3] =
+			0x00;
+
+	fts_i2c_Read(client, auc_i2c_write_buf, 4, reg_val, 2);
+
+	if (reg_val[0] == 0x79 && reg_val[1] == 0x3)
+		dev_dbg(&client->dev, "[FTS] Step 3: CTPM ID,ID1 = 0x%x,ID2 = 0x%x\n",
+			 reg_val[0], reg_val[1]);
+	else
+		return -EIO;
+
+	auc_i2c_write_buf[0] = 0xcd;
+	fts_i2c_Read(client, auc_i2c_write_buf, 1, reg_val, 1);
+	dev_dbg(&client->dev, "bootloader version = 0x%x\n", reg_val[0]);
+
+	/*--------- read current project setting  ---------- */
+	/*set read start address */
+	buf[0] = 0x3;
+	buf[1] = 0x0;
+	buf[2] = 0x78;
+	buf[3] = 0x0;
+
+	fts_i2c_Read(client, buf, 4, buf, FTS_SETTING_BUF_LEN);
+	dev_dbg(&client->dev, "[FTS] old setting: uc_i2c_addr = 0x%x,\
+			uc_io_voltage = %d, uc_panel_factory_id = 0x%x\n",
+			buf[0], buf[2], buf[4]);
+
+	 /*--------- Step 4:erase project setting --------------*/
+	auc_i2c_write_buf[0] = 0x63;
+	fts_i2c_Write(client, auc_i2c_write_buf, 1);
+	msleep(100);
+
+	/*----------  Set new settings ---------------*/
+	buf[0] = uc_i2c_addr;
+	buf[1] = ~uc_i2c_addr;
+	buf[2] = uc_io_voltage;
+	buf[3] = ~uc_io_voltage;
+	buf[4] = uc_panel_factory_id;
+	buf[5] = ~uc_panel_factory_id;
+	packet_buf[0] = 0xbf;
+	packet_buf[1] = 0x00;
+	packet_buf[2] = 0x78;
+	packet_buf[3] = 0x0;
+	packet_buf[4] = 0;
+	packet_buf[5] = FTS_SETTING_BUF_LEN;
+
+	for (i = 0; i < FTS_SETTING_BUF_LEN; i++)
+		packet_buf[6 + i] = buf[i];
+
+	fts_i2c_Write(client, packet_buf, FTS_SETTING_BUF_LEN + 6);
+	msleep(100);
+
+	/********* reset the new FW***********************/
+	auc_i2c_write_buf[0] = 0x07;
+	fts_i2c_Write(client, auc_i2c_write_buf, 1);
+
+	msleep(200);
+	return 0;
+}
+
+
+void delay_qt_ms(unsigned long  w_ms)
+{
+	unsigned long i;
+	unsigned long j;
+
+	for (i = 0; i < w_ms; i++)
+	{
+		for (j = 0; j < 1000; j++)
+		{
+			 udelay(1);
+		}
+	}
+}
+
+extern void focaltech_get_upgrade_array(void);
+
+
+int hid_to_i2c(struct i2c_client * client)
+{
+	u8 auc_i2c_write_buf[5] = {0};
+	int bRet = 0;
+
+	auc_i2c_write_buf[0] = 0xeb;
+	auc_i2c_write_buf[1] = 0xaa;
+	auc_i2c_write_buf[2] = 0x09;
+
+	fts_i2c_Write(client, auc_i2c_write_buf, 3);
+
+	msleep(10);
+
+	auc_i2c_write_buf[0] = auc_i2c_write_buf[1] = auc_i2c_write_buf[2] = 0;
+
+	fts_i2c_Read(client, auc_i2c_write_buf, 0, auc_i2c_write_buf, 3);
+
+	if(0xeb==auc_i2c_write_buf[0] && 0xaa==auc_i2c_write_buf[1] && 0x08==auc_i2c_write_buf[2])
+	{
+		bRet = 1;		
+	}
+	else bRet = 0;
+
+	return bRet;
+	
+}
+
+
+int fts_6x36_ctpm_fw_upgrade(struct i2c_client *client, u8 *pbt_buf,
+			  u32 dw_lenth)
+{
+	u8 reg_val[2] = {0};
+	u32 i = 0;
+	u32 packet_number;
+	u32 j;
+	u32 temp;
+	u32 lenght;
+	u32 fw_length;
+	u8 packet_buf[FTS_PACKET_LENGTH + 6];
+	u8 auc_i2c_write_buf[10];
+	u8 bt_ecc;
+	int i_ret;
+
+
+	if(pbt_buf[0] != 0x02)
+	{
+		DBG("[FTS] FW first byte is not 0x02. so it is invalid \n");
+		return -1;
+	}
+
+	if(dw_lenth > 0x11f)
+	{
+		fw_length = ((u32)pbt_buf[0x100]<<8) + pbt_buf[0x101];
+		if(dw_lenth < fw_length)
+		{
+			DBG("[FTS] Fw length is invalid \n");
+			return -1;
+		}
+	}
+	else
+	{
+		DBG("[FTS] Fw length is invalid \n");
+		return -1;
+	}
+	
+	for (i = 0; i < FTS_UPGRADE_LOOP; i++) {
+		/*********Step 1:Reset  CTPM *****/
+		/*write 0xaa to register 0xbc */
+		
+		fts_write_reg(client, 0xbc, FT_UPGRADE_AA);
+		msleep(fts_updateinfo_curr.delay_aa);
+
+		/*write 0x55 to register 0xbc */
+		fts_write_reg(client, 0xbc, FT_UPGRADE_55);
+
+		msleep(fts_updateinfo_curr.delay_55);
+
+		/*********Step 2:Enter upgrade mode *****/
+		auc_i2c_write_buf[0] = FT_UPGRADE_55;
+		fts_i2c_Write(client, auc_i2c_write_buf, 1);
+
+		auc_i2c_write_buf[0] = FT_UPGRADE_AA;
+		fts_i2c_Write(client, auc_i2c_write_buf, 1);
+		msleep(fts_updateinfo_curr.delay_readid);
+
+		/*********Step 3:check READ-ID***********************/		
+		auc_i2c_write_buf[0] = 0x90;
+		auc_i2c_write_buf[1] = auc_i2c_write_buf[2] = auc_i2c_write_buf[3] =
+			0x00;
+		reg_val[0] = 0x00;
+		reg_val[1] = 0x00;
+		fts_i2c_Read(client, auc_i2c_write_buf, 4, reg_val, 2);
+
+
+		if (reg_val[0] == fts_updateinfo_curr.upgrade_id_1
+			&& reg_val[1] == fts_updateinfo_curr.upgrade_id_2) {
+			DBG("[FTS] Step 3: GET CTPM ID OK,ID1 = 0x%x,ID2 = 0x%x\n",
+				reg_val[0], reg_val[1]);
+			break;
+		} else {
+			dev_err(&client->dev, "[FTS] Step 3: GET CTPM ID FAIL,ID1 = 0x%x,ID2 = 0x%x\n",
+				reg_val[0], reg_val[1]);
+		}
+	}
+	if (i >= FTS_UPGRADE_LOOP)
+		return -EIO;
+
+	auc_i2c_write_buf[0] = 0x90;
+	auc_i2c_write_buf[1] = 0x00;
+	auc_i2c_write_buf[2] = 0x00;
+	auc_i2c_write_buf[3] = 0x00;
+	auc_i2c_write_buf[4] = 0x00;
+	fts_i2c_Write(client, auc_i2c_write_buf, 5);
+	
+	//auc_i2c_write_buf[0] = 0xcd;
+	//fts_i2c_Read(client, auc_i2c_write_buf, 1, reg_val, 1);
+
+
+	/*Step 4:erase app and panel paramenter area*/
+	DBG("Step 4:erase app and panel paramenter area\n");
+	auc_i2c_write_buf[0] = 0x61;
+	fts_i2c_Write(client, auc_i2c_write_buf, 1);	/*erase app area */
+	msleep(fts_updateinfo_curr.delay_earse_flash);
+
+	for(i = 0;i < 200;i++)
+	{
+		auc_i2c_write_buf[0] = 0x6a;
+		auc_i2c_write_buf[1] = 0x00;
+		auc_i2c_write_buf[2] = 0x00;
+		auc_i2c_write_buf[3] = 0x00;
+		reg_val[0] = 0x00;
+		reg_val[1] = 0x00;
+		fts_i2c_Read(client, auc_i2c_write_buf, 4, reg_val, 2);
+		if(0xb0 == reg_val[0] && 0x02 == reg_val[1])
+		{
+			DBG("[FTS] erase app finished \n");
+			break;
+		}
+		msleep(50);
+	}
+
+	/*********Step 5:write firmware(FW) to ctpm flash*********/
+	bt_ecc = 0;
+	DBG("Step 5:write firmware(FW) to ctpm flash\n");
+
+	dw_lenth = fw_length;
+	packet_number = (dw_lenth) / FTS_PACKET_LENGTH;
+	packet_buf[0] = 0xbf;
+	packet_buf[1] = 0x00;
+
+	for (j = 0; j < packet_number; j++) {
+		temp = j * FTS_PACKET_LENGTH;
+		packet_buf[2] = (u8) (temp >> 8);
+		packet_buf[3] = (u8) temp;
+		lenght = FTS_PACKET_LENGTH;
+		packet_buf[4] = (u8) (lenght >> 8);
+		packet_buf[5] = (u8) lenght;
+
+		for (i = 0; i < FTS_PACKET_LENGTH; i++) {
+			packet_buf[6 + i] = pbt_buf[j * FTS_PACKET_LENGTH + i];
+			bt_ecc ^= packet_buf[6 + i];
+		}
+		
+		fts_i2c_Write(client, packet_buf, FTS_PACKET_LENGTH + 6);
+		
+		for(i = 0;i < 30;i++)
+		{
+			auc_i2c_write_buf[0] = 0x6a;
+			auc_i2c_write_buf[1] = 0x00;
+			auc_i2c_write_buf[2] = 0x00;
+			auc_i2c_write_buf[3] = 0x00;
+			reg_val[0] = 0x00;
+			reg_val[1] = 0x00;
+			fts_i2c_Read(client, auc_i2c_write_buf, 4, reg_val, 2);
+			if(0xb0 == (reg_val[0] & 0xf0) && (0x03 + (j % 0x0ffd)) == (((reg_val[0] & 0x0f) << 8) |reg_val[1]))
+			{
+				DBG("[FTS] write a block data finished \n");
+				break;
+			}
+			msleep(1);
+		}
+	}
+
+	if ((dw_lenth) % FTS_PACKET_LENGTH > 0) {
+		temp = packet_number * FTS_PACKET_LENGTH;
+		packet_buf[2] = (u8) (temp >> 8);
+		packet_buf[3] = (u8) temp;
+		temp = (dw_lenth) % FTS_PACKET_LENGTH;
+		packet_buf[4] = (u8) (temp >> 8);
+		packet_buf[5] = (u8) temp;
+
+		for (i = 0; i < temp; i++) {
+			packet_buf[6 + i] = pbt_buf[packet_number * FTS_PACKET_LENGTH + i];
+			bt_ecc ^= packet_buf[6 + i];
+		}
+
+		fts_i2c_Write(client, packet_buf, temp + 6);
+
+		for(i = 0;i < 30;i++)
+		{
+			auc_i2c_write_buf[0] = 0x6a;
+			auc_i2c_write_buf[1] = 0x00;
+			auc_i2c_write_buf[2] = 0x00;
+			auc_i2c_write_buf[3] = 0x00;
+			reg_val[0] = 0x00;
+			reg_val[1] = 0x00;
+			fts_i2c_Read(client, auc_i2c_write_buf, 4, reg_val, 2);
+			if(0xb0 == (reg_val[0] & 0xf0) && (0x03 + (j % 0x0ffd)) == (((reg_val[0] & 0x0f) << 8) |reg_val[1]))
+			{
+				DBG("[FTS] write a block data finished \n");
+				break;
+			}
+			msleep(1);
+		}
+	}
+
+
+	/*********Step 6: read out checksum***********************/
+	/*send the opration head */
+	DBG("Step 6: read out checksum\n");
+	auc_i2c_write_buf[0] = 0xcc;
+	fts_i2c_Read(client, auc_i2c_write_buf, 1, reg_val, 1);
+	if (reg_val[0] != bt_ecc) {
+		dev_err(&client->dev, "[FTS]--ecc error! FW=%02x bt_ecc=%02x\n",
+					reg_val[0],
+					bt_ecc);
+		return -EIO;
+	}
+
+	/*********Step 7: reset the new FW***********************/
+	DBG("Step 7: reset the new FW\n");
+	auc_i2c_write_buf[0] = 0x07;
+	fts_i2c_Write(client, auc_i2c_write_buf, 1);
+	msleep(300);	/*make sure CTP startup normally */
+
+	return 0;
+}
+
+int  fts_5x46_ctpm_fw_upgrade(struct i2c_client * client, u8* pbt_buf, u32 dw_lenth)
+{
+	
+	u8 reg_val[4] = {0};
+	u32 i = 0;
+	u32 packet_number;
+	u32 j;
+	u32 temp;
+	u32 lenght;
+	u8 packet_buf[FTS_PACKET_LENGTH + 6];
+	u8 auc_i2c_write_buf[10];
+	u8 bt_ecc;
+	int i_ret;
+
+	i_ret = hid_to_i2c(client);
+
+	if(i_ret == 0)
+	{
+		DBG("[FTS] hid change to i2c fail ! \n");
+	}
+
+	for (i = 0; i < FTS_UPGRADE_LOOP; i++) {
+		/*********Step 1:Reset  CTPM *****/
+		/*write 0xaa to register 0xfc */
+		fts_write_reg(client, 0xfc, FT_UPGRADE_AA);
+		msleep(fts_updateinfo_curr.delay_aa);
+
+		//write 0x55 to register 0xfc 
+		fts_write_reg(client, 0xfc, FT_UPGRADE_55);
+		msleep(200);
+		/*********Step 2:Enter upgrade mode *****/
+		i_ret = hid_to_i2c(client);
+
+		if(i_ret == 0)
+		{
+			DBG("[FTS] hid change to i2c fail ! \n");
+			continue;
+		}
+		msleep(10);
+		auc_i2c_write_buf[0] = FT_UPGRADE_55;
+		auc_i2c_write_buf[1] = FT_UPGRADE_AA;
+		i_ret = fts_i2c_Write(client, auc_i2c_write_buf, 2);
+		if(i_ret < 0)
+		{
+			DBG("[FTS] failed writing  0x55 and 0xaa ! \n");
+			continue;
+		}
+
+		/*********Step 3:check READ-ID***********************/
+		msleep(1);
+		auc_i2c_write_buf[0] = 0x90;
+		auc_i2c_write_buf[1] = auc_i2c_write_buf[2] = auc_i2c_write_buf[3] =
+			0x00;
+		
+		reg_val[0] = reg_val[1] = 0x00;
+		
+		fts_i2c_Read(client, auc_i2c_write_buf, 4, reg_val, 2);
+
+		if (reg_val[0] == fts_updateinfo_curr.upgrade_id_1
+			&& reg_val[1] == fts_updateinfo_curr.upgrade_id_2) {
+			DBG("[FTS] Step 3: READ OK CTPM ID,ID1 = 0x%x,ID2 = 0x%x\n",
+				reg_val[0], reg_val[1]);
+			break;
+		} else {
+			dev_err(&client->dev, "[FTS] Step 3: CTPM ID,ID1 = 0x%x,ID2 = 0x%x\n",
+				reg_val[0], reg_val[1]);
+			
+			continue;
+		}
+	}
+	if (i >= FTS_UPGRADE_LOOP )
+		return -EIO;
+
+	/*Step 4:erase app and panel paramenter area*/
+	DBG("Step 4:erase app and panel paramenter area\n");
+	auc_i2c_write_buf[0] = 0x61;
+	fts_i2c_Write(client, auc_i2c_write_buf, 1);	//erase app area 
+	msleep(1350);
+
+	for(i = 0;i < 15;i++)
+	{
+		auc_i2c_write_buf[0] = 0x6a;
+		reg_val[0] = reg_val[1] = 0x00;
+		fts_i2c_Read(client, auc_i2c_write_buf, 1, reg_val, 2);
+
+		if(0xF0==reg_val[0] && 0xAA==reg_val[1])
+		{
+			break;
+		}
+		msleep(50);
+		
+	}
+
+	auc_i2c_write_buf[0] = 0xB0;
+	auc_i2c_write_buf[1] = (u8) ((dw_lenth >> 16) & 0xFF);
+	auc_i2c_write_buf[2] = (u8) ((dw_lenth >> 8) & 0xFF);
+	auc_i2c_write_buf[3] = (u8) (dw_lenth & 0xFF);
+
+	fts_i2c_Write(client, auc_i2c_write_buf, 4);
+
+	/*********Step 5:write firmware(FW) to ctpm flash*********/
+	bt_ecc = 0;
+	DBG("Step 5:write firmware(FW) to ctpm flash\n");
+	temp = 0;
+	packet_number = (dw_lenth) / FTS_PACKET_LENGTH;
+	packet_buf[0] = 0xbf;
+	packet_buf[1] = 0x00;
+
+	for (j = 0; j < packet_number; j++) {
+		temp = j * FTS_PACKET_LENGTH;
+		packet_buf[2] = (u8) (temp >> 8);
+		packet_buf[3] = (u8) temp;
+		lenght = FTS_PACKET_LENGTH;
+		packet_buf[4] = (u8) (lenght >> 8);
+		packet_buf[5] = (u8) lenght;
+
+		for (i = 0; i < FTS_PACKET_LENGTH; i++) {
+			packet_buf[6 + i] = pbt_buf[j * FTS_PACKET_LENGTH + i];
+			bt_ecc ^= packet_buf[6 + i];
+		}
+		fts_i2c_Write(client, packet_buf, FTS_PACKET_LENGTH + 6);
+
+		for(i = 0;i < 30;i++)
+		{
+			auc_i2c_write_buf[0] = 0x6a;
+			reg_val[0] = reg_val[1] = 0x00;
+			fts_i2c_Read(client, auc_i2c_write_buf, 1, reg_val, 2);
+
+			if ((j + 0x1000) == (((reg_val[0]) << 8) | reg_val[1]))
+			{
+				break;
+			}
+			msleep(1);
+			
+		}
+	}
+
+	if ((dw_lenth) % FTS_PACKET_LENGTH > 0) {
+		temp = packet_number * FTS_PACKET_LENGTH;
+		packet_buf[2] = (u8) (temp >> 8);
+		packet_buf[3] = (u8) temp;
+		temp = (dw_lenth) % FTS_PACKET_LENGTH;
+		packet_buf[4] = (u8) (temp >> 8);
+		packet_buf[5] = (u8) temp;
+
+		for (i = 0; i < temp; i++) {
+			packet_buf[6 + i] = pbt_buf[packet_number * FTS_PACKET_LENGTH + i];
+			bt_ecc ^= packet_buf[6 + i];
+		}	
+		fts_i2c_Write(client, packet_buf, temp + 6);
+
+		for(i = 0;i < 30;i++)
+		{
+			auc_i2c_write_buf[0] = 0x6a;
+			reg_val[0] = reg_val[1] = 0x00;
+			fts_i2c_Read(client, auc_i2c_write_buf, 1, reg_val, 2);
+
+			if ((j + 0x1000) == (((reg_val[0]) << 8) | reg_val[1]))
+			{
+				break;
+			}
+			msleep(1);
+			
+		}
+	}
+
+	msleep(50);
+	
+	/*********Step 6: read out checksum***********************/
+	/*send the opration head */
+	DBG("Step 6: read out checksum\n");
+	auc_i2c_write_buf[0] = 0x64;
+	fts_i2c_Write(client, auc_i2c_write_buf, 1); 
+	msleep(300);
+
+	temp = 0;
+	auc_i2c_write_buf[0] = 0x65;
+	auc_i2c_write_buf[1] = (u8)(temp >> 16);
+	auc_i2c_write_buf[2] = (u8)(temp >> 8);
+	auc_i2c_write_buf[3] = (u8)(temp);
+	temp = dw_lenth;
+	auc_i2c_write_buf[4] = (u8)(temp >> 8);
+	auc_i2c_write_buf[5] = (u8)(temp);
+	i_ret = fts_i2c_Write(client, auc_i2c_write_buf, 6); 
+	msleep(dw_lenth/256);
+
+	for(i = 0;i < 100;i++)
+	{
+		auc_i2c_write_buf[0] = 0x6a;
+		reg_val[0] = reg_val[1] = 0x00;
+		fts_i2c_Read(client, auc_i2c_write_buf, 1, reg_val, 2);
+
+		if (0xF0==reg_val[0] && 0x55==reg_val[1])
+		{
+			break;
+		}
+		msleep(1);
+			
+	}
+	auc_i2c_write_buf[0] = 0x66;
+	fts_i2c_Read(client, auc_i2c_write_buf, 1, reg_val, 1);
+	if (reg_val[0] != bt_ecc) 
+	{
+		dev_err(&client->dev, "[FTS]--ecc error! FW=%02x bt_ecc=%02x\n",
+					reg_val[0],
+					bt_ecc);
+				
+		return -EIO;
+	}
+	printk(KERN_WARNING "checksum %X %X \n",reg_val[0],bt_ecc);	
+	/*********Step 7: reset the new FW***********************/
+	DBG("Step 7: reset the new FW\n");
+	auc_i2c_write_buf[0] = 0x07;
+	fts_i2c_Write(client, auc_i2c_write_buf, 1);
+	msleep(130);	//make sure CTP startup normally 
+
+	return 0;
+}
+
+int fts_ctpm_fw_upgrade(struct i2c_client *client, u8 *pbt_buf,
+			  u32 dw_lenth)
+{
+	u8 reg_val[2] = {0};
+	u32 i = 0;
+	u8 is_5336_new_bootloader = 0;
+	u8 is_5336_fwsize_30 = 0;
+	u32 packet_number;
+	u32 j=0;
+	u32 temp;
+	u32 lenght;
+	u8 packet_buf[FTS_PACKET_LENGTH + 6];
+	u8 auc_i2c_write_buf[10];
+	u8 bt_ecc;
+	int i_ret;
+      // struct Upgrade_Info upgradeinfo;
+	   
+	//fts_get_upgrade_info(&upgradeinfo);
+	
+	focaltech_get_upgrade_array();
+	
+	if(*(pbt_buf+dw_lenth-12) == 30)
+	{
+		is_5336_fwsize_30 = 1;
+	}
+	else 
+	{
+		is_5336_fwsize_30 = 0;
+	}
+	for (i = 0; i < FTS_UPGRADE_LOOP; i++) 
+	{
+	        msleep(100);
+		printk("[FTS] Step 1:Reset  CTPM\n");
+		/*********Step 1:Reset  CTPM *****/
+		/*write 0xaa to register 0xfc */
+		//if (DEVICE_IC_TYPE == IC_FT6208 || DEVICE_IC_TYPE == IC_FT6x06)
+#if 1
+		if(fts_updateinfo_curr.CHIP_ID==0x06 || fts_updateinfo_curr.CHIP_ID==0x36) 
+			fts_write_reg(client, 0xbc, FT_UPGRADE_AA);
+		else
+			fts_write_reg(client, 0xfc, FT_UPGRADE_AA);
+		msleep(fts_updateinfo_curr.delay_aa);
+
+
+		/*write 0x55 to register 0xfc */
+		//if(DEVICE_IC_TYPE == IC_FT6208 || DEVICE_IC_TYPE == IC_FT6x06)
+		if(fts_updateinfo_curr.CHIP_ID==0x06 || fts_updateinfo_curr.CHIP_ID==0x36 )
+			fts_write_reg(client, 0xbc, FT_UPGRADE_55);
+		else
+			fts_write_reg(client, 0xfc, FT_UPGRADE_55);
+#else
+	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
+    mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
+    mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ZERO);  
+    msleep(2);  
+   // mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
+   // mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
+    mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ONE);
+#endif
+		if(i<=15)
+		{
+		msleep(fts_updateinfo_curr.delay_55+i*3);
+		}
+		else
+		{
+		msleep(fts_updateinfo_curr.delay_55-(i-15)*2);
+		}
+
+   
+		/*********Step 2:Enter upgrade mode *****/
+		printk("[FTS] Step 2:Enter upgrade mode \n");
+		#if 0
+			auc_i2c_write_buf[0] = FT_UPGRADE_55;
+			auc_i2c_write_buf[1] = FT_UPGRADE_AA;
+			do {
+				j++;
+				i_ret = fts_i2c_Write(client, auc_i2c_write_buf, 2);
+				msleep(5);
+			} while (i_ret <= 0 && j < 5);
+		#else
+			auc_i2c_write_buf[0] = FT_UPGRADE_55;
+			fts_i2c_Write(client, auc_i2c_write_buf, 1);
+			msleep(5);
+			auc_i2c_write_buf[0] = FT_UPGRADE_AA;
+			fts_i2c_Write(client, auc_i2c_write_buf, 1);
+		#endif
+
+#if 1
+		/*********Step 3:check READ-ID***********************/
+		msleep(fts_updateinfo_curr.delay_readid);
+		auc_i2c_write_buf[0] = 0x90;
+		auc_i2c_write_buf[1] = auc_i2c_write_buf[2] = auc_i2c_write_buf[3] =0x00;
+		fts_i2c_Read(client, auc_i2c_write_buf, 4, reg_val, 2);
+
+		printk("[FTS] Step 3: CTPM ID,ID1 = 0x%x,ID2 = 0x%x\n",reg_val[0], reg_val[1]);
+		if (reg_val[0] == fts_updateinfo_curr.upgrade_id_1
+			&& reg_val[1] == fts_updateinfo_curr.upgrade_id_2) {
+			//dev_dbg(&client->dev, "[FTS] Step 3: CTPM ID,ID1 = 0x%x,ID2 = 0x%x\n",
+				//reg_val[0], reg_val[1]);
+			DBG("[FTS] Step 3: CTPM ID,ID1 = 0x%x,ID2 = 0x%x\n",
+				reg_val[0], reg_val[1]);
+			break;
+		} else {
+			dev_err(&client->dev, "[FTS] Step 3: CTPM ID,ID1 = 0x%x,ID2 = 0x%x\n",
+				reg_val[0], reg_val[1]);
+		}
+#endif	
+	}
+	if (i >= FTS_UPGRADE_LOOP)
+		return -EIO;
+	
+	auc_i2c_write_buf[0] = 0xcd;
+	fts_i2c_Read(client, auc_i2c_write_buf, 1, reg_val, 1);
+	/*********0705 mshl ********************/
+	/*if (reg_val[0] > 4)
+		is_5336_new_bootloader = 1;*/
+
+	if (reg_val[0] <= 4)
+	{
+		is_5336_new_bootloader = BL_VERSION_LZ4 ;
+	}
+	else if(reg_val[0] == 7)
+	{
+		is_5336_new_bootloader = BL_VERSION_Z7 ;
+	}
+	else if(reg_val[0] >= 0x0f && ((fts_updateinfo_curr.CHIP_ID==0x11) ||(fts_updateinfo_curr.CHIP_ID==0x12) ||(fts_updateinfo_curr.CHIP_ID==0x13) ||(fts_updateinfo_curr.CHIP_ID==0x14)))
+	{
+		is_5336_new_bootloader = BL_VERSION_GZF ;
+	}
+	else
+	{
+		is_5336_new_bootloader = BL_VERSION_LZ4 ;
+	}
+
+
+	printk("[FTS] Step 4:erase app and panel paramenter area\n");
+	/*Step 4:erase app and panel paramenter area*/
+	DBG("Step 4:erase app and panel paramenter area\n");
+	auc_i2c_write_buf[0] = 0x61;
+	fts_i2c_Write(client, auc_i2c_write_buf, 1);	/*erase app area */
+	msleep(fts_updateinfo_curr.delay_earse_flash);
+	/*erase panel parameter area */
+	if(is_5336_fwsize_30)
+	{
+	    auc_i2c_write_buf[0] = 0x63;
+	    fts_i2c_Write(client, auc_i2c_write_buf, 1);
+	}
+	msleep(100);
+
+	printk("[FTS] Step 5:write firmware(FW) to ctpm flash\n");
+	/*********Step 5:write firmware(FW) to ctpm flash*********/
+	bt_ecc = 0;
+	DBG("Step 5:write firmware(FW) to ctpm flash\n");
+
+	//dw_lenth = dw_lenth - 8;
+	if(is_5336_new_bootloader == BL_VERSION_LZ4 || is_5336_new_bootloader == BL_VERSION_Z7 )
+	{
+		dw_lenth = dw_lenth - 8;
+	}
+	else if(is_5336_new_bootloader == BL_VERSION_GZF) 
+	{
+	      dw_lenth = dw_lenth - 14;
+	}
+	packet_number = (dw_lenth) / FTS_PACKET_LENGTH;
+	packet_buf[0] = 0xbf;
+	packet_buf[1] = 0x00;
+
+	for (j = 0; j < packet_number; j++) {
+		temp = j * FTS_PACKET_LENGTH;
+		packet_buf[2] = (u8) (temp >> 8);
+		packet_buf[3] = (u8) temp;
+		lenght = FTS_PACKET_LENGTH;
+		packet_buf[4] = (u8) (lenght >> 8);
+		packet_buf[5] = (u8) lenght;
+
+		for (i = 0; i < FTS_PACKET_LENGTH; i++) {
+			packet_buf[6 + i] = pbt_buf[j * FTS_PACKET_LENGTH + i];
+			bt_ecc ^= packet_buf[6 + i];
+		}
+		
+		fts_i2c_Write(client, packet_buf, FTS_PACKET_LENGTH + 6);
+		msleep(FTS_PACKET_LENGTH / 6 + 1);
+		if((((j+1) * FTS_PACKET_LENGTH)%1024)==0)
+		DBG("write bytes:0x%04x\n", (j+1) * FTS_PACKET_LENGTH);
+		//delay_qt_ms(FTS_PACKET_LENGTH / 6 + 1);
+	}
+
+	if ((dw_lenth) % FTS_PACKET_LENGTH > 0) {
+		temp = packet_number * FTS_PACKET_LENGTH;
+		packet_buf[2] = (u8) (temp >> 8);
+		packet_buf[3] = (u8) temp;
+		temp = (dw_lenth) % FTS_PACKET_LENGTH;
+		packet_buf[4] = (u8) (temp >> 8);
+		packet_buf[5] = (u8) temp;
+
+		for (i = 0; i < temp; i++) {
+			packet_buf[6 + i] = pbt_buf[packet_number * FTS_PACKET_LENGTH + i];
+			bt_ecc ^= packet_buf[6 + i];
+		}
+
+		fts_i2c_Write(client, packet_buf, temp + 6);
+		msleep(20);
+	}
+#if 0
+	/*send the last six byte*/
+	for (i = 0; i<6; i++)
+	{
+		if (is_5336_new_bootloader && ((fts_updateinfo_curr.CHIP_ID==0x11) ||(fts_updateinfo_curr.CHIP_ID==0x12) ||(fts_updateinfo_curr.CHIP_ID==0x13) ||(fts_updateinfo_curr.CHIP_ID==0x14)))//5x36,5x36i 
+			temp = 0x7bfa + i;
+		else
+			temp = 0x6ffa + i;
+		packet_buf[2] = (u8)(temp>>8);
+		packet_buf[3] = (u8)temp;
+		temp =1;
+		packet_buf[4] = (u8)(temp>>8);
+		packet_buf[5] = (u8)temp;
+		packet_buf[6] = pbt_buf[ dw_lenth + i]; 
+		bt_ecc ^= packet_buf[6];
+		fts_i2c_Write(client, packet_buf, 7);
+		msleep(20);
+	}
+#else
+	/*send the last six byte*/
+	if(is_5336_new_bootloader == BL_VERSION_LZ4 || is_5336_new_bootloader == BL_VERSION_Z7 )
+	{
+		for (i = 0; i<6; i++)
+		{
+			if (is_5336_new_bootloader  == BL_VERSION_Z7 ) 
+			{
+				temp = 0x7bfa + i;
+			}
+			else if(is_5336_new_bootloader == BL_VERSION_LZ4)
+			{
+				temp = 0x6ffa + i;
+			}
+			packet_buf[2] = (u8)(temp>>8);
+			packet_buf[3] = (u8)temp;
+			temp =1;
+			packet_buf[4] = (u8)(temp>>8);
+			packet_buf[5] = (u8)temp;
+			packet_buf[6] = pbt_buf[ dw_lenth + i]; 
+			bt_ecc ^= packet_buf[6];
+  
+			fts_i2c_Write(client, packet_buf, 7);
+			msleep(20);
+		}
+	}
+	else if(is_5336_new_bootloader == BL_VERSION_GZF)
+	{
+	    
+		for (i = 0; i<12; i++)
+		{
+			if (is_5336_fwsize_30) 
+			{
+				temp = 0x7ff4 + i;
+			}
+			else 
+			{
+				temp = 0x7bf4 + i;
+			}
+			packet_buf[2] = (u8)(temp>>8);
+			packet_buf[3] = (u8)temp;
+			temp =1;
+			packet_buf[4] = (u8)(temp>>8);
+			packet_buf[5] = (u8)temp;
+			packet_buf[6] = pbt_buf[ dw_lenth + i]; 
+			bt_ecc ^= packet_buf[6];
+  
+			fts_i2c_Write(client, packet_buf, 7);
+			msleep(20);
+
+		}
+	}
+
+#endif
+	printk("[FTS] Step 6: read out checksum\n");
+	/*********Step 6: read out checksum***********************/
+	/*send the opration head */
+	DBG("Step 6: read out checksum\n");
+	auc_i2c_write_buf[0] = 0xcc;
+	fts_i2c_Read(client, auc_i2c_write_buf, 1, reg_val, 1);
+	if (reg_val[0] != bt_ecc) {
+		printk(&client->dev, "[FTS]--ecc error! FW=%02x bt_ecc=%02x\n",
+					reg_val[0],
+					bt_ecc);
+		return -EIO;
+	}
+
+	printk("[FTS] Step 7: reset the new FW\n");
+	/*********Step 7: reset the new FW***********************/
+	DBG("Step 7: reset the new FW\n");
+	auc_i2c_write_buf[0] = 0x07;
+	fts_i2c_Write(client, auc_i2c_write_buf, 1);
+	msleep(300);	/*make sure CTP startup normally */
+
+	return 0;
+}
+
+/*sysfs debug*/
+
+/*
+*get firmware size
+
+@firmware_name:firmware name
+*note:the firmware default path is sdcard.
+	if you want to change the dir, please modify by yourself.
+*/
+static int fts_GetFirmwareSize(char *firmware_name)
+{
+	struct file *pfile = NULL;
+	struct inode *inode;
+	unsigned long magic;
+	off_t fsize = 0;
+	char filepath[128];
+	memset(filepath, 0, sizeof(filepath));
+
+	sprintf(filepath, "%s", firmware_name);
+
+	if (NULL == pfile)
+		pfile = filp_open(filepath, O_RDONLY, 0);
+
+	if (IS_ERR(pfile)) {
+		pr_err("error occured while opening file %s.\n", filepath);
+		return -EIO;
+	}
+
+	inode = pfile->f_dentry->d_inode;
+	magic = inode->i_sb->s_magic;
+	fsize = inode->i_size;
+	filp_close(pfile, NULL);
+	return fsize;
+}
+
+
+
+/*
+*read firmware buf for .bin file.
+
+@firmware_name: fireware name
+@firmware_buf: data buf of fireware
+
+note:the firmware default path is sdcard.
+	if you want to change the dir, please modify by yourself.
+*/
+static int fts_ReadFirmware(char *firmware_name,
+			       unsigned char *firmware_buf)
+{
+	struct file *pfile = NULL;
+	struct inode *inode;
+	unsigned long magic;
+	off_t fsize;
+	char filepath[128];
+	loff_t pos;
+	mm_segment_t old_fs;
+
+	memset(filepath, 0, sizeof(filepath));
+	sprintf(filepath, "%s", firmware_name);
+	if (NULL == pfile)
+		pfile = filp_open(filepath, O_RDONLY, 0);
+	if (IS_ERR(pfile)) {
+		pr_err("error occured while opening file %s.\n", filepath);
+		return -EIO;
+	}
+
+	inode = pfile->f_dentry->d_inode;
+	magic = inode->i_sb->s_magic;
+	fsize = inode->i_size;
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	pos = 0;
+	vfs_read(pfile, firmware_buf, fsize, &pos);
+	filp_close(pfile, NULL);
+	set_fs(old_fs);
+
+	return 0;
+}
+
+
+
+/*
+upgrade with *.bin file
+*/
+
+int fts_ctpm_fw_upgrade_with_app_file(struct i2c_client *client,
+				       char *firmware_name)
+{
+	u8 *pbt_buf = NULL;
+	int i_ret=0;
+	int fwsize = fts_GetFirmwareSize(firmware_name);
+
+	if (fwsize <= 0) {
+		dev_err(&client->dev, "%s ERROR:Get firmware size failed\n",
+					__func__);
+		return -EIO;
+	}
+
+	if (fwsize < 8 || fwsize > 54 * 1024) {
+		dev_dbg(&client->dev, "%s:FW length error\n", __func__);
+		return -EIO;
+	}
+	
+    
+	/*=========FW upgrade========================*/
+	pbt_buf = kmalloc(fwsize + 1, GFP_ATOMIC);
+
+	if (fts_ReadFirmware(firmware_name, pbt_buf)) {
+		dev_err(&client->dev, "%s() - ERROR: request_firmware failed\n",
+					__func__);
+		kfree(pbt_buf);
+		//return -EIO;
+		i_ret = -EIO;
+		goto err_ret;
+	}
+	
+	/*call the upgrade function */
+	if ((fts_updateinfo_curr.CHIP_ID==0x54))
+	{
+		i_ret = fts_5x46_ctpm_fw_upgrade(client, pbt_buf, fwsize);
+	}
+	else if ((fts_updateinfo_curr.CHIP_ID==0x36))
+	{
+		i_ret = fts_6x36_ctpm_fw_upgrade(client, pbt_buf, fwsize);
+	}
+	else
+	{
+	        i_ret = fts_ctpm_fw_upgrade(client, pbt_buf, fwsize);
+	}
+	if (i_ret != 0)
+		dev_err(&client->dev, "%s() - ERROR:[FTS] upgrade failed..\n",
+					__func__);
+	else if(fts_updateinfo_curr.AUTO_CLB==AUTO_CLB_NEED)
+		fts_ctpm_auto_clb(client);
+
+err_ret:
+	
+	
+	
+	kfree(pbt_buf);
+    
+	return i_ret;
+}
+
+static ssize_t fts_tpfwver_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	ssize_t num_read_chars = 0;
+	u8 fwver = 0;
+	struct i2c_client *client = container_of(dev, struct i2c_client, dev);
+
+	mutex_lock(&g_device_mutex);
+
+	if (fts_read_reg(client, FT_REG_FW_VER, &fwver) < 0)
+		num_read_chars = snprintf(buf, PAGE_SIZE,
+					"get tp fw version fail!\n");
+	else
+		num_read_chars = snprintf(buf, PAGE_SIZE, "0x%02X\n", fwver);
+
+	mutex_unlock(&g_device_mutex);
+
+	return num_read_chars;
+}
+
+static ssize_t fts_tpfwver_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	/*place holder for future use*/
+	return -EPERM;
+}
+
+
+
+static ssize_t fts_tprwreg_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	/*place holder for future use*/
+	return -EPERM;
+}
+
+static ssize_t fts_tprwreg_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct i2c_client *client = container_of(dev, struct i2c_client, dev);
+	ssize_t num_read_chars = 0;
+	int retval;
+	long unsigned int wmreg = 0;
+	u8 regaddr = 0xff, regvalue = 0xff;
+	u8 valbuf[5] = {0};
+
+	memset(valbuf, 0, sizeof(valbuf));
+	mutex_lock(&g_device_mutex);
+	num_read_chars = count - 1;
+
+	if (num_read_chars != 2) {
+		if (num_read_chars != 4) {
+			printk("please input 2 or 4 character\n");
+			goto error_return;
+		}
+	}
+
+	memcpy(valbuf, buf, num_read_chars);
+	retval = strict_strtoul(valbuf, 16, &wmreg);
+
+	if (0 != retval) {
+		printk(&client->dev, "%s() - ERROR: Could not convert the "\
+						"given input to a number." \
+						"The given input was: \"%s\"\n",
+						__func__, buf);
+		goto error_return;
+	}
+
+	if (2 == num_read_chars) {
+		/*read register*/
+		regaddr = wmreg;
+		if (fts_read_reg(client, regaddr, &regvalue) < 0)
+			printk(&client->dev, "Could not read the register(0x%02x)\n",
+						regaddr);
+		else
+			printk("the register(0x%02x) is 0x%02x\n",
+					regaddr, regvalue);
+	} else {
+		regaddr = wmreg >> 8;
+		regvalue = wmreg;
+		if (fts_write_reg(client, regaddr, regvalue) < 0)
+			printk(&client->dev, "Could not write the register(0x%02x)\n",
+							regaddr);
+		else
+			printk(&client->dev, "Write 0x%02x into register(0x%02x) successful\n",
+							regvalue, regaddr);
+	}
+
+error_return:
+	mutex_unlock(&g_device_mutex);
+
+	return count;
+}
+
+static ssize_t fts_fwupdate_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	/* place holder for future use */
+	return -EPERM;
+}
+
+/*upgrade from *.i*/
+static ssize_t fts_fwupdate_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	#if 0
+	struct fts_ts_data *data = NULL;
+	u8 uc_host_fm_ver;
+	int i_ret;
+	struct i2c_client *client = container_of(dev, struct i2c_client, dev);
+
+	data = (struct fts_ts_data *)i2c_get_clientdata(client);
+
+	mutex_lock(&g_device_mutex);
+
+	//disable_irq(client->irq);
+	mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
+	i_ret = fts_ctpm_fw_upgrade_with_i_file(client);
+	if (i_ret == 0) {
+		msleep(300);
+		uc_host_fm_ver = fts_ctpm_get_i_file_ver();
+		pr_info("%s [FTS] upgrade to new version 0x%x\n", __func__,
+					 uc_host_fm_ver);
+	} else
+		dev_err(&client->dev, "%s ERROR:[FTS] upgrade failed.\n",
+					__func__);
+
+	//enable_irq(client->irq);
+	mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
+	mutex_unlock(&g_device_mutex);
+
+	return count;
+	#endif
+}
+
+static ssize_t fts_fwupgradeapp_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	/*place holder for future use*/
+	return -EPERM;
+}
+
+
+/*upgrade from app.bin*/
+static ssize_t fts_fwupgradeapp_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	ssize_t num_read_chars = 0;
+	char fwname[128];
+	struct i2c_client *client = container_of(dev, struct i2c_client, dev);
+
+	memset(fwname, 0, sizeof(fwname));
+	sprintf(fwname, "%s", buf);
+	fwname[count - 1] = '\0';
+
+	mutex_lock(&g_device_mutex);
+	//disable_irq(client->irq);
+       mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
+	if(0==fts_ctpm_fw_upgrade_with_app_file(client, fwname))
+	{
+		num_read_chars = snprintf(buf, PAGE_SIZE,
+					"FTP firmware upgrade success!\n");
+	}
+	else
+	{
+		num_read_chars = snprintf(buf, PAGE_SIZE,
+					"FTP firmware upgrade fail!\n");
+	}
+
+	//enable_irq(client->irq);
+	mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
+	mutex_unlock(&g_device_mutex);
+
+	return num_read_chars;
+}
+
+#ifdef FTS_SCAP_TEST
+// lxh:add for raw data test 0417
+#define FT5X0X_INI_FILEPATH "/mnt/sdcard/"
+static int ft5x0x_GetInISize(char *config_name)
+{
+	struct file *pfile = NULL;
+	struct inode *inode;
+	unsigned long magic;
+	off_t fsize = 0;
+	char filepath[128];
+	memset(filepath, 0, sizeof(filepath));
+
+	sprintf(filepath, "%s%s", FT5X0X_INI_FILEPATH, config_name);
+
+	if (NULL == pfile)
+		pfile = filp_open(filepath, O_RDONLY, 0);
+
+	if (IS_ERR(pfile)) {
+		pr_err("error occured while opening file %s.\n", filepath);
+		return -EIO;
+	}
+
+	inode = pfile->f_dentry->d_inode;
+	magic = inode->i_sb->s_magic;
+	fsize = inode->i_size;
+	filp_close(pfile, NULL);
+	return fsize;
+}
+
+static int ft5x0x_ReadInIData(char *config_name,
+			      char *config_buf)
+{
+	struct file *pfile = NULL;
+	struct inode *inode;
+	unsigned long magic;
+	off_t fsize;
+	char filepath[128];
+	loff_t pos;
+	mm_segment_t old_fs;
+
+	memset(filepath, 0, sizeof(filepath));
+	sprintf(filepath, "%s%s", FT5X0X_INI_FILEPATH, config_name);
+	if (NULL == pfile)
+		pfile = filp_open(filepath, O_RDONLY, 0);
+	if (IS_ERR(pfile)) {
+		pr_err("error occured while opening file %s.\n", filepath);
+		return -EIO;
+	}
+
+	inode = pfile->f_dentry->d_inode;
+	magic = inode->i_sb->s_magic;
+	fsize = inode->i_size;
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	pos = 0;
+	vfs_read(pfile, config_buf, fsize, &pos);
+	filp_close(pfile, NULL);
+	set_fs(old_fs);
+
+	return 0;
+}
+static int ft5x0x_get_testparam_from_ini(char *config_name)
+{
+	char *filedata = NULL;
+  	int inisize;
+
+  	printk("lxh:*** %s  _1 *** \n", __func__);  // lxh:test
+
+	inisize = ft5x0x_GetInISize(config_name);
+
+  	printk("lxh:*** %s  _ 2 *** \n", __func__);  // lxh:test
+	
+
+	printk("lxh:*** inisize = %d  *** \n ", inisize);  // lxh:test
+	
+	if (inisize <= 0) {
+		printk("lxh: *** %s ERROR:Get firmware size failed *** \n",
+					__func__);
+		return -EIO;
+	}
+
+	filedata = kmalloc(inisize + 1, GFP_ATOMIC);
+		
+	if (ft5x0x_ReadInIData(config_name, filedata)) {
+		printk(" lxh: *** %s() - ERROR: request_firmware failed ***\n",
+					__func__);
+		kfree(filedata);
+		return -EIO;
+	} else {
+		printk("lxh:*** ft5x0x_ReadInIData successful *** \n");
+	}
+
+	SetParamData(filedata);
+	return 0;
+}
+
+#if 0
+ int focal_i2c_Read(unsigned char *writebuf, int writelen, unsigned char *readbuf, int readlen)
+ {
+ 	fts_i2c_Read(g_focalclient,writebuf,writelen,readbuf,readlen);
+ }
+int focal_i2c_Write(unsigned char *writebuf, int writelen)
+{
+	fts_i2c_Write(g_focalclient,writebuf,writelen);	
+}
+#else
+int focal_i2c_Read(unsigned char *writebuf,
+		    int writelen, unsigned char *readbuf, int readlen)
+{
+	int ret;
+
+	if (writelen > 0) {
+		struct i2c_msg msgs[] = {
+			{
+			 .addr = g_focalclient->addr,
+			 .flags = 0,
+			 .len = writelen,
+			 .buf = writebuf,
+			 },
+			{
+			 .addr = g_focalclient->addr,
+			 .flags = I2C_M_RD,
+			 .len = readlen,
+			 .buf = readbuf,
+			 },
+		};
+		ret = i2c_transfer(g_focalclient->adapter, msgs, 2);
+		if (ret < 0)
+			dev_err(&g_focalclient->dev, "f%s: i2c read error.\n",
+				__func__);
+	} else {
+		struct i2c_msg msgs[] = {
+			{
+			 .addr = g_focalclient->addr,
+			 .flags = I2C_M_RD,
+			 .len = readlen,
+			 .buf = readbuf,
+			 },
+		};
+		ret = i2c_transfer(g_focalclient->adapter, msgs, 1);
+		if (ret < 0)
+			dev_err(&g_focalclient->dev, "%s:i2c read error.\n", __func__);
+	}
+	return ret;
+}
+/*write data by i2c*/
+int focal_i2c_Write(unsigned char *writebuf, int writelen)
+{
+	int ret;
+
+	struct i2c_msg msg[] = {
+		{
+		 .addr = g_focalclient->addr,
+		 .flags = 0,
+		 .len = writelen,
+		 .buf = writebuf,
+		 },
+	};
+
+	ret = i2c_transfer(g_focalclient->adapter, msg, 1);
+	if (ret < 0)
+		dev_err(&g_focalclient->dev, "%s i2c write error.\n", __func__);
+
+	return ret;
+}
+#endif
+
+enum  {
+   SCAP_ORG_STATUS = 0,	
+   GET_INIT_FILE_FAIL,
+   GET_TP_VENDOR_FAIL,
+   UNKNOWN_TP_VENDOR,	
+   SCAP_TEST_PASS,
+   SCAP_TEST_FAIL,
+};
+
+static int scap_test_ret = SCAP_ORG_STATUS;
+
+static ssize_t ft5x0x_ftsscaptest_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{	
+	    int ret_num = 0;	
+
+	   switch (scap_test_ret) {
+		case SCAP_ORG_STATUS:
+			ret_num = sprintf(buf, "%s", "test haven't done \n");
+		break;
+
+	        case   GET_INIT_FILE_FAIL:
+			 ret_num = sprintf(buf, "%s", "get init file fail \n");
+		break;
+
+	         case   SCAP_TEST_PASS:
+			  ret_num = sprintf(buf, "%s", "test pass \n");
+		break;
+
+		case   SCAP_TEST_FAIL:
+		  	ret_num = sprintf(buf, "%s", "test fail \n");
+		break;
+		
+		case  GET_TP_VENDOR_FAIL:
+			ret_num = sprintf(buf, "%s", "get tp vendor id fail \n");  	
+		break;
+		
+		case UNKNOWN_TP_VENDOR:
+			ret_num = sprintf(buf, "%s", "unknown tp vendor \n");		
+		break;
+
+		default:
+			 scap_test_ret = SCAP_ORG_STATUS;
+			 ret_num = sprintf(buf, "%s", "unknow status \n");
+		break;
+	   } 
+
+	return ret_num;
+}
+
+static ssize_t ft5x0x_ftsscaptest_store(struct device *dev,
+					struct device_attribute *attr,
+						const char *buf, size_t count)
+{
+	/* place holder for future use */
+	char  cfgname[128];
+  //  	u8     vendor_id;
+    	int     ret , i = 0;	
+//	struct i2c_client *client = container_of(dev, struct i2c_client, dev);
+	memset(cfgname, 0, sizeof(cfgname));
+	sprintf(cfgname, "%s", buf);
+
+	 printk(" lxh:*** cfgname_1 is: %s *** \n", cfgname); //lxh:test
+	 printk(" lxh:***  count is: %d *** \n", count); //lxh:test
+	 cfgname[count -1] = '\0';
+
+
+ #if 0 
+    /**  get tp vendor id  **/ 
+          do {
+		  ret = fts_read_reg(client, FT6x06_REG_VENDOR_ID, &vendor_id);
+		  if ((ret < 0) || ((vendor_id != FTS_VENDOR_OFM) && (vendor_id != FTS_VENDOR_XQH)))  {
+		    	i ++;
+			msleep(50);	
+		  } else {
+			 printk(" lxh:*** vendor id is: 0x%x *** \n",  vendor_id); //lxh:test	
+			 break;
+		  }	
+          }  while (i < 3 );
+
+	if (i >=3) { 
+	  	scap_test_ret = GET_TP_VENDOR_FAIL; 
+		 printk(" lxh:***  get vendor id fail...  *** \n"); //lxh:test
+		return -1;	  
+	 }	  
+      /**  rename scap_test to scap_test_ofm.ini  or ..xqh.ini  **/
+  	 if (vendor_id == FTS_VENDOR_OFM) {
+	   	sprintf(cfgname+count -1, "%s", "_ofm.ini");
+ 	} else if (vendor_id == FTS_VENDOR_XQH) {
+   	         sprintf(cfgname+count -1, "%s", "_xqh.ini");
+         }  else {
+		scap_test_ret = UNKNOWN_TP_VENDOR;
+		return -1;
+	}   
+		 
+	cfgname[count+8-1] = '\0';
+
+	
+
+          printk(" lxh:*** cfgname_2 is: %s *** \n", cfgname); //lxh:test
+ #endif
+
+	mutex_lock(&g_device_mutex);
+
+	Init_I2C_Write_Func(focal_i2c_Write);  
+	Init_I2C_Read_Func(focal_i2c_Read);
+	if(ft5x0x_get_testparam_from_ini(cfgname) <0)  {
+		printk("lxh:***get testparam from ini failure ***\n");
+		scap_test_ret = GET_INIT_FILE_FAIL;
+	} else {
+	 	printk("lxh:***get testparam from ini OK, begin to test... ***\n");
+		if(true == StartTestTP()) {
+			printk("lxh:*** tp test pass ***\n");
+			scap_test_ret = SCAP_TEST_PASS;
+		} else {
+	  		printk("lxh:*** tp test failure ***\n");
+	            	 scap_test_ret = SCAP_TEST_FAIL;		
+		}
+	    printk("lxh:***  test finished, going to FreeTestParamData()... ***\n");
+		FreeTestParamData();
+	}
+	
+	mutex_unlock(&g_device_mutex);
+
+	return count;
+}
+
+static DEVICE_ATTR(ftsscaptest, S_IRUGO|S_IWUSR, ft5x0x_ftsscaptest_show, ft5x0x_ftsscaptest_store);
+
+#endif
+/*sysfs */
+/*get the fw version
+*example:cat ftstpfwver
+*/
+static DEVICE_ATTR(ftstpfwver, S_IRUGO | S_IWUSR, fts_tpfwver_show,
+			fts_tpfwver_store);
+
+/*upgrade from *.i
+*example: echo 1 > ftsfwupdate
+*/
+static DEVICE_ATTR(ftsfwupdate, S_IRUGO | S_IWUSR, fts_fwupdate_show,
+			fts_fwupdate_store);
+
+/*read and write register
+*read example: echo 88 > ftstprwreg ---read register 0x88
+*write example:echo 8807 > ftstprwreg ---write 0x07 into register 0x88
+*
+*note:the number of input must be 2 or 4.if it not enough,please fill in the 0.
+*/
+static DEVICE_ATTR(ftstprwreg, S_IRUGO | S_IWUSR, fts_tprwreg_show,
+			fts_tprwreg_store);
+
+
+/*upgrade from app.bin
+*example:echo "*_app.bin" > ftsfwupgradeapp
+*/
+static DEVICE_ATTR(ftsfwupgradeapp, S_IRUGO | S_IWUSR, fts_fwupgradeapp_show,
+			fts_fwupgradeapp_store);
+
+
+
+
+/*add your attr in here*/
+static struct attribute *fts_attributes[] = {
+	&dev_attr_ftstpfwver.attr,
+	&dev_attr_ftsfwupdate.attr,
+	&dev_attr_ftstprwreg.attr,
+	&dev_attr_ftsfwupgradeapp.attr,
+	#ifdef FTS_SCAP_TEST
+	&dev_attr_ftsscaptest.attr,
+	#endif
+	NULL
+};
+
+static struct attribute_group fts_attribute_group = {
+	.attrs = fts_attributes
+};
+
+/*create sysfs for debug*/
+int fts_create_sysfs(struct i2c_client *client)
+{
+	int err;
+	I2CDMABuf_va = (u8 *)dma_alloc_coherent(NULL, FTS_DMA_BUF_SIZE, &I2CDMABuf_pa, GFP_KERNEL);
+	
+    if(!I2CDMABuf_va)
+	{
+		dev_dbg(&client->dev,"%s Allocate DMA I2C Buffer failed!\n",__func__);
+		return -EIO;
+	}
+//	printk("FTP: I2CDMABuf_pa=%x,val=%x val2=%x\n",&I2CDMABuf_pa,I2CDMABuf_pa,(unsigned char *)I2CDMABuf_pa);
+	err = sysfs_create_group(&client->dev.kobj, &fts_attribute_group);
+	if (0 != err) {
+		dev_err(&client->dev,
+					 "%s() - ERROR: sysfs_create_group() failed.\n",
+					 __func__);
+		sysfs_remove_group(&client->dev.kobj, &fts_attribute_group);
+		return -EIO;
+	} else {
+		mutex_init(&g_device_mutex);
+		pr_info("ft6x06:%s() - sysfs_create_group() succeeded.\n",
+				__func__);
+	}
+	return err;
+}
+
+void fts_release_sysfs(struct i2c_client *client)
+{
+	sysfs_remove_group(&client->dev.kobj, &fts_attribute_group);
+	mutex_destroy(&g_device_mutex);
+	if(I2CDMABuf_va)
+	{
+		dma_free_coherent(NULL, FTS_DMA_BUF_SIZE, I2CDMABuf_va, I2CDMABuf_pa);
+		I2CDMABuf_va = NULL;
+		I2CDMABuf_pa = 0;
+	}
+	
+}
+/*create apk debug channel*/
+
+#define PROC_UPGRADE			0
+#define PROC_READ_REGISTER		1
+#define PROC_WRITE_REGISTER	2
+#define PROC_RAWDATA			3
+#define PROC_AUTOCLB			4
+#define PROC_UPGRADE_INFO		5
+#define PROC_WRITE_DATA		6
+#define PROC_READ_DATA			7
+
+#define PROC_NAME	"ft5x0x-debug"
+static unsigned char proc_operate_mode = PROC_RAWDATA;
+static struct proc_dir_entry *ft5x0x_proc_entry = NULL;
+static struct i2c_client *fts_proc_entry_i2c_client = NULL;
+/*interface of write proc*/
+static int ft5x0x_debug_write(struct file *filp, 
+	const char __user *buff, unsigned long len, void *data)
+{
+	struct i2c_client *client = fts_proc_entry_i2c_client;
+	//struct i2c_client *client = (struct i2c_client *)ft5x0x_proc_entry->data;
+	unsigned char writebuf[FTS_PACKET_LENGTH];
+	int buflen = len;
+	int writelen = 0;
+	int ret = 0;
+	
+	if (copy_from_user(&writebuf, buff, buflen)) {
+		dev_err(&client->dev, "%s:copy from user error\n", __func__);
+		return -EFAULT;
+	}
+	proc_operate_mode = writebuf[0];
+	
+	switch (proc_operate_mode) {
+	case PROC_UPGRADE:
+		{
+			char upgrade_file_path[128];
+			memset(upgrade_file_path, 0, sizeof(upgrade_file_path));
+			sprintf(upgrade_file_path, "%s", writebuf + 1);
+			upgrade_file_path[buflen-1] = '\0';
+			DBG("%s\n", upgrade_file_path);
+			disable_irq(client->irq);
+
+			ret = fts_ctpm_fw_upgrade_with_app_file(client, upgrade_file_path);
+
+			enable_irq(client->irq);
+			if (ret < 0) {
+				dev_err(&client->dev, "%s:upgrade failed.\n", __func__);
+				return ret;
+			}
+		}
+		break;
+	case PROC_READ_REGISTER:
+		writelen = 1;
+		DBG("%s:register addr=0x%02x\n", __func__, writebuf[1]);
+		ret = fts_i2c_Write(client, writebuf + 1, writelen);
+		if (ret < 0) {
+			dev_err(&client->dev, "%s:write iic error\n", __func__);
+			return ret;
+		}
+		break;
+	case PROC_WRITE_REGISTER:
+		writelen = 2;
+		ret = fts_i2c_Write(client, writebuf + 1, writelen);
+		if (ret < 0) {
+			dev_err(&client->dev, "%s:write iic error\n", __func__);
+			return ret;
+		}
+		break;
+	case PROC_RAWDATA:
+		break;
+	case PROC_AUTOCLB:
+		fts_ctpm_auto_clb(client);
+		break;
+	case PROC_READ_DATA:
+	case PROC_WRITE_DATA:
+		writelen = len - 1;
+		ret = fts_i2c_Write(client, writebuf + 1, writelen);
+		if (ret < 0) {
+			dev_err(&client->dev, "%s:write iic error\n", __func__);
+			return ret;
+		}
+		break;
+	default:
+		break;
+	}
+	
+
+	return len;
+}
+
+#if 1//enable this case for MTK 6732/6752 and late new platform
+/*interface of read proc*/
+/*static int ft5x0x_debug_read( char *page, char **start,
+	off_t off, int count, int *eof, void *data )*/
+static int ft5x0x_debug_read(struct file *filp, 
+	const char __user *buff, unsigned long len, void *data)
+{
+	struct i2c_client *client = fts_proc_entry_i2c_client;
+	//struct i2c_client *client = (struct i2c_client *)ft5x0x_proc_entry->data;
+	int ret = 0, err = 0;
+	u8 tx = 0, rx = 0;
+	int i, j;
+	unsigned char buf[PAGE_SIZE];
+	int num_read_chars = 0;
+	int readlen = 0;
+	u8 regvalue = 0x00, regaddr = 0x00;
+	switch (proc_operate_mode) {
+	case PROC_UPGRADE:
+		/*after calling ft5x0x_debug_write to upgrade*/
+		regaddr = 0xA6;
+		ret = fts_read_reg(client, regaddr, &regvalue);
+		if (ret < 0)
+			num_read_chars = sprintf(buf, "%s", "get fw version failed.\n");
+		else
+			num_read_chars = sprintf(buf, "current fw version:0x%02x\n", regvalue);
+		break;
+	case PROC_READ_REGISTER:
+		readlen = 1;
+		ret = fts_i2c_Read(client, NULL, 0, buf, readlen);
+		if (ret < 0) {
+			dev_err(&client->dev, "%s:read iic error\n", __func__);
+			return ret;
+		} else
+			DBG("%s:value=0x%02x\n", __func__, buf[0]);
+		num_read_chars = 1;
+		break;
+	case PROC_RAWDATA:
+		break;
+	case PROC_READ_DATA:
+		readlen = len;
+		ret = fts_i2c_Read(client, NULL, 0, buf, readlen);
+		if (ret < 0) {
+			dev_err(&client->dev, "%s:read iic error\n", __func__);
+			return ret;
+		}
+		
+		num_read_chars = readlen;
+		break;
+	case PROC_WRITE_DATA:
+		break;
+	default:
+		break;
+	}
+	
+	memcpy(buff, buf, num_read_chars);
+
+	return num_read_chars;
+}
+static const struct file_operations ft5x0x_proc_fops = {
+		.write = ft5x0x_debug_write,
+		.read = ft5x0x_debug_read,
+};
+int ft5x0x_create_apk_debug_channel(struct i2c_client * client)
+{
+	ft5x0x_proc_entry = proc_create(PROC_NAME, 0777, NULL, &ft5x0x_proc_fops);
+	if (NULL == ft5x0x_proc_entry) {
+		dev_err(&client->dev, "Couldn't create proc entry!\n");
+		return -ENOMEM;
+	} else {
+		dev_info(&client->dev, "Create proc entry success!\n");
+		//ft5x0x_proc_entry->data = client;
+		fts_proc_entry_i2c_client = client;
+		//ft5x0x_proc_entry->write_proc = ft5x0x_debug_write;
+		//ft5x0x_proc_entry->read_proc = ft5x0x_debug_read;
+	}
+	return 0;
+}
+#else //this case for MTK old platform
+/*interface of read proc*/
+static int ft5x0x_debug_read( char *page, char **start,
+	off_t off, int count, int *eof, void *data )
+{
+	struct i2c_client *client = (struct i2c_client *)ft5x0x_proc_entry->data;
+	int ret = 0, err = 0;
+	u8 tx = 0, rx = 0;
+	int i, j;
+	unsigned char buf[PAGE_SIZE];
+	int num_read_chars = 0;
+	int readlen = 0;
+	u8 regvalue = 0x00, regaddr = 0x00;
+	switch (proc_operate_mode) {
+	case PROC_UPGRADE:
+		/*after calling ft5x0x_debug_write to upgrade*/
+		regaddr = 0xA6;
+		ret = fts_read_reg(client, regaddr, &regvalue);
+		if (ret < 0)
+			num_read_chars = sprintf(buf, "%s", "get fw version failed.\n");
+		else
+			num_read_chars = sprintf(buf, "current fw version:0x%02x\n", regvalue);
+		break;
+	case PROC_READ_REGISTER:
+		readlen = 1;
+		ret = fts_i2c_Read(client, NULL, 0, buf, readlen);
+		if (ret < 0) {
+			dev_err(&client->dev, "%s:read iic error\n", __func__);
+			return ret;
+		} else
+			DBG("%s:value=0x%02x\n", __func__, buf[0]);
+		num_read_chars = 1;
+		break;
+	case PROC_RAWDATA:
+		break;
+	case PROC_READ_DATA:
+		readlen = len;
+		ret = fts_i2c_Read(client, NULL, 0, buf, readlen);
+		if (ret < 0) {
+			dev_err(&client->dev, "%s:read iic error\n", __func__);
+			return ret;
+		}
+		
+		num_read_chars = readlen;
+		break;
+	case PROC_WRITE_DATA:
+		break;
+	default:
+		break;
+	}
+	
+	memcpy(page, buf, num_read_chars);
+
+	return num_read_chars;
+}
+int ft5x0x_create_apk_debug_channel(struct i2c_client * client)
+{
+	ft5x0x_proc_entry = create_proc_entry(PROC_NAME, 0777, NULL);
+	if (NULL == ft5x0x_proc_entry) {
+		dev_err(&client->dev, "Couldn't create proc entry!\n");
+		return -ENOMEM;
+	} else {
+		dev_info(&client->dev, "Create proc entry success!\n");
+		ft5x0x_proc_entry->data = client;
+		ft5x0x_proc_entry->write_proc = ft5x0x_debug_write;
+		ft5x0x_proc_entry->read_proc = ft5x0x_debug_read;
+	}
+	return 0;
+}
+#endif
+void ft5x0x_release_apk_debug_channel(void)
+{
+	if (ft5x0x_proc_entry)
+		remove_proc_entry(PROC_NAME, NULL);
+}
+
diff --git a/drivers/input/touchscreen/mediatek/ft_allinone_gesture/focaltech_ex_fun.h b/drivers/input/touchscreen/mediatek/ft_allinone_gesture/focaltech_ex_fun.h
new file mode 100644
index 0000000..a79f724
--- /dev/null
+++ b/drivers/input/touchscreen/mediatek/ft_allinone_gesture/focaltech_ex_fun.h
@@ -0,0 +1,62 @@
+#ifndef __FOCALTECH_EX_FUN_H__
+#define __FOCALTECH_EX_FUN_H__
+
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/semaphore.h>
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+#include <mach/irqs.h>
+
+#include <linux/syscalls.h>
+#include <asm/unistd.h>
+#include <asm/uaccess.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+
+#define FT_UPGRADE_AA					0xAA
+#define FT_UPGRADE_55 					0x55
+
+/***********************0705 mshl*/
+#define    BL_VERSION_LZ4        0
+#define    BL_VERSION_Z7        1
+#define    BL_VERSION_GZF        2
+
+/*****************************************************************************/
+#define PAGE_SIZE                                        1016
+#define FTS_PACKET_LENGTH        		       128
+#define FTS_SETTING_BUF_LEN      		128
+#define FTS_DMA_BUF_SIZE 				1024
+
+#define FTS_UPGRADE_LOOP				30
+
+#define FTS_FACTORYMODE_VALUE			0x40
+#define FTS_WORKMODE_VALUE			0x00
+
+/*create sysfs for debug*/
+int fts_create_sysfs(struct i2c_client * client);
+
+void fts_release_sysfs(struct i2c_client * client);
+int ft5x0x_create_apk_debug_channel(struct i2c_client *client);
+void ft5x0x_release_apk_debug_channel(void);
+
+int fts_ctpm_auto_upgrade(struct i2c_client *client);
+
+/*
+*fts_write_reg- write register
+*@client: handle of i2c
+*@regaddr: register address
+*@regvalue: register value
+*
+*/
+int fts_i2c_Read(struct i2c_client *client, char *writebuf,int writelen, char *readbuf, int readlen);
+
+int fts_i2c_Write(struct i2c_client *client, char *writebuf, int writelen);
+
+int fts_write_reg(struct i2c_client * client,u8 regaddr, u8 regvalue);
+
+int fts_read_reg(struct i2c_client * client,u8 regaddr, u8 *regvalue);
+
+#endif
diff --git a/drivers/input/touchscreen/mediatek/ft_allinone_gesture/ft_gesture_lib.a_shipped b/drivers/input/touchscreen/mediatek/ft_allinone_gesture/ft_gesture_lib.a_shipped
new file mode 100644
index 0000000000000000000000000000000000000000..5a7f3c30d435b950b00a0eccc2906b099859f79f
GIT binary patch
literal 27542
zcmdU&4|J5}o$sH?Ou`UT9T6#7YF}yAQj2uJh|%TRky4~ymPU-2vaXr@L(l+27!WL{
zM*b*G;ocOnS{81`Uhm$XJ)WLaw3}MgL8GNeH3};AvhGa6i)g(ot?riX_H6F=^Um|&
zYpSc=J!kja=bSIU=lMO)^ZWli?>nPsa{i2_j+Vt&RDRKWf16s9ti9y2sTWVJ^}J*-
z75>-rrq$Ni4e3f_%<0BNe)w;}l4VP>jhUv7Cezy1(y=y^HH(%kYi(TGw5DlU>(V95
zOzZMh&FyWCE$vHMZZS(*+m>aQELz*Rcy(j@l4WgXQCqfUapUslo7-BljVqg$X0&u#
zd)w-^c2gR)Hf5U{v&$QoE$>*`)V}1lCChHorl#zwjyBlYj;3WR7ilicT-qd|BlfS%
z%ATf<){=ydww0^evw_@IZ2bcxOk3m1Y=>zxUmO|O_lNlpM#Q_+(v^#{jW@Ne3`}ib
z(mZAP7c0M5N`hPBeOQ*JCX>@^l%Q#sCNG&5tWH<n{*}42Baw)bRcaA4$-Fl*W?e(T
zFRuy6By*aHn-k`uHxj8`{-k`5KdG+AH<^|~B;8twnk~moa+4p=Z1H2MO@38+i=Xhe
z_$SO`$Il!7V$rHFC(gL&jTPy)k7Y7%AB*NI2BXPQgF7#-E_@=jad3MqR>-E_K308A
zt{AB+AB?18gBw$u3K7jkP5sdDgvj7<l^MLCDOdd5id^xt##BbSb3+w%t%K)0k}ICG
zUHf|f>tLk&tApR@ef!wj?zfL!|3I#|U{kI*Dl@w9$?Lj`73tFo<7RCxuBv<c*o<`f
zAo{BEcNU}4HzOSztlGP&_-1~x>=IA<s}gq<qf<8)Yvk{n$<Gd+A^m0NZz-HVCRdD_
z&SE^V-cOgU_fMQr@-x<*E1uDt8;aHChRRa8q1T3o-^6$P-sAQ7dy+kVJiX0-r+Zs5
z-LcJ&n6D4T2mWlZuXVk@N62T_`~AZC#=Kflmn&AJWP4sPLQdmO`IyWN#e3He#=5uq
zQDfdT;#XyI#hB*G)3WQ#zkI!+yT`9E*A%1YfA953U2bn&{YWbJqcU@Su`CZ=SS&NS
zy)kc>A4zUdeCHS68Xn$1UiS6XZ}9ib+TiE=H~9Ur4SsxJ>!9-wU-rd}NtYRuNL}>C
z##E2Lkv-MheUrG`H)j5j@tPmn8<}6si+8p$e;pgaPlz|5xdXB7ej=D_E|^GXq0{7w
z|1v!Mt1^=sJj2utnPl#6V{#h?YBt_;K&Upky9Z($HyscXosS*Y+>pkSv(Yb&vCf#2
zU%BXw8Q1psGd9Ss%ss_h(@z|$FbjsX{@}??j~$+LvG}oj{5{q8lx+5z3s=hCsm45-
z7r$TpSPoyB3l&p06=L4qemr@PfA#mt`TSyGeUE>=d^kF-$4}3^&%b-zQ-x=~^yR{a
z<c2~;vZb&x`NT0}t{tk#Ts0<|xvK2pX+3B6PU|VZH8VU;sMwv^e5Me&HS@%=sJVV9
zL#`9KVyEdW;D5K|R;nLO<c7%aDCMq7Ia(y0Whv!a_CynR43?StVl361FH5x!81>&B
z9)9(ZVj>@p=lkV{e8G<@lP>Hxb;W0ghabhC8_MqX)6?$p_uh{`b;au>cf54QQ}=wN
zFV2U)%%(GiQ$8%SKCCzE10M#azTbz4>JA@TwJz*KO!1Ttz49UFd>F7kgk!Qs^3r1z
z>kC4$PPY_RE4N0ub+Mi^wdd?vQ$IY`s=Zf}dwcw-mm8|gDaMK~XQC><WpK3S6m!|R
zQ}gQwBj(y-B+=3vO*G{yl>_4YvbF6{%}ainIcw+@lZ&2ja%T~9coFel63??dd~h*&
zn6sZyj6ckWl<FmQRarJQJWi<SODV>wO_6MhI;kJR_BFbP-fw&T$F}{&knM5Vc~EwK
zHe`EDycfiqXnC9^&N^+ub=O_TnUAZ_T}FNf?(gvvy1U-V>?mfQ*&*MrA374-;hTM3
zek7ke*j~})@6LC<&?dWe_Y4``PqAdKxbr(b{!Nc}4NfNZb)AK$>vX4eZYdbEsjyFL
z;%2K~mET;5<+u9ryzZy;#=!%5-F=a+LR`F<c=3i#KVG-XhhLQzuc@oB^IPII-0AQ9
z`JJNOS|>T_T^e`$<#p=|5p(BYRsIg$HC=&D_9AEJ&pZ97o-r}xPty3DPM>Fvd?=Q6
za^G@4USIsQ{D>Q!8QrPevAXMuWp(MCscY`7;(krH=c>|8y%BTWP{b@actZ8ksJu-x
z*B^Xcck3weM~S~z{iym;^^00lrn4T&Zz;sC=_=$UKd>vlNp@`t>^Q7vi0a{3R`*JS
zo*}Bsq4qnwf;c~v>MDLhcFl#K{PJK_&&Fq;pE=le#`?iUpP4zRJ5<l2hy0j)h^2b<
zOt`ift9ww-===SX!^7vURZS#9_j`;4s~u6^<LY-tdi;}LyXcL!=Q{&gRVl?=HEld{
z`F%e)zsdXkf0nEU)kDMiJ^n-9j$%iGb9v3sJaX^N9PCIBAB&{#9Gr27o=dXvrW?Bk
zqpAB|k9zmKj&0aAenpS$%K0(xLI1ascZT*~q5Uz{TA7}w?{wc=G}?d1H}4ws(z&5>
z*)qB}S3Fa76iq63`_}tAKhM3bdoeLekDmEMvBZ5x^(;L%QnzVvRo$>`sxPk6dD?l-
z2I+~P9W!4qCS+H&?*7x{SB2uw9h@;w9E<1~RF=#gR1Eh<P40#0ROQ~2p7GmMTlXHt
zzryga-gb2c6L%!`CUR%S$FDydTNIzOV&15;u?HKl<!|lUh_^n0Jx_YMGqGvs=Qo^<
zP118#Ecu>IuMQ9YHTgOD-yb_pE@<S3+&rMmDx>>^_p#&`q(k!OncP!ydcW?6V%40x
z{oL0d^6PY8)MbQpk6$kTV)Bogh$v<;vq!c)q<FO!B8j#_r{?a^ny9(!^=RVGATKG^
zn(n=zPQveURkEYzG-I;D3Dw8RiK-JlLnd<{B)1ifo?T;;Tm9qWnZ#Bfo+mn9yx)B(
zH&iV;LE{73cVMR0bnj9=w))??cw-@!+2tGE7u>}u-NSLMO{qpAY3}B&davB-m*r$<
zr~K&^>V$mBw}|wP>Q>+Tv1<M&ek{|cccl5so1QUVOD>jt)GssF>D=ai#F>sJZ|WVD
zY{^A<o@O=_RwRaX*Zz4i+MD~)DCKpO-kB20GiNlaGkRRH@V52%qxIZOD%N8YyYzg$
zrg)L+bh6I$7sMN{cdFB*bCP((!IbZMgS#YRgtU;szCQnm?m_GsZ5oPYnY#+n^qqxm
zWnSU#rzRJ+oppZUAEfK5j$CnebFO%AMYM3``j&z*4MSrj_q!Dpg?mShD$H$OT~I#H
ziX?N<)R<cfx~ud^yLPBGmpe=M)w!)+ZfINF1kYriMfaIf|5Dzsa=GGI*=ytj{(nP$
zlB@6GV{(^YE&IMAS+zQU<YRa0TSe8_!E))JB;Ew}>7D0>vTOZe$<thPGIxpU6~D`s
zhpNt9exgq6@Lztr7{pS#v%N?BqbXw0r}|Y+<bPCg-q!KC_r(DJQ)Rj0cTHR|SRBM)
zbe&?D+T}m5`?Fg<5s$gsGN)p3)tJ@q#X`@sQ6pk8dPFQ9lbp(AXW^-2u87Y+(YQRd
zv2a@N#zL#tGFUBL>%DImxbIY}k5qeGAMuh~ADPg-^^qUicl?KS7Je*nE)-XDyAD}K
zea`HOFB#LTK4&Ga*u_`KZ=IDr_4oRH8}Ie|TkrMr58UhTPTpILceWKObBhWqJ?@}}
zp-5+Lcf>3lisW*;xko;$_;c5<>>fVWpXl-Xbq~y&a@XKHz27PBQ9N(b{W$tN>t(BX
z^Dk|_M{_5dQNHY|j3u`pjm!UXuSM~`PUl@`U-4aEmb;(3FP6ObXw1ZPZWa_PwJvHF
z6)Lp$S9*WkcA6=`W1W-vrs{?9Jk@|)t#p0W$*I0x9V%ng#@8M@uK72)*MhNX#XWO~
zk*7)Sw+r<dppF{-b<e%~<i~au{Z3u<ABJ_BZw;-PtA33zL5PL;Z&?|KEZy_3$owE(
z5B!nqKS&0=jUhSh>emZ1gleHmV9mRF;X5KY8U42Zpy+mCozN=G6>5YD0&8QUZ=GSx
zA%XE8(FYX+qt89RtU0K&cGl28=&W|=T=3bPJNhN@d7u5I_){%^K>Sz4Pl*33@#`(W
zPyCm~|DPB47LSR4mF4FwKc)4)__Hm4v-s%co%5vlD=j}`*TdIk6#cU0H(0(W{%^(q
zish%o$4=g{4~w6){7H5_{DSx?%TL(#`1`8((=7j_&L8&R@4Mo!u>6AMBj+9QGnT(k
zeDq?^-->^U<@Z`X_WvL8FSh*qET8!No%okpey8OV&m-d3SpH)1i6?dria*ox>+E{s
z`I`9CEuZ_CyrB0@@vpUfqccT5$6I;mIjZ?tZr<+0zt_dDv;5<_Kahw1H^iTB`2&_u
zoQ{isjpg@=f7q`7jrh%$pR;`Q{!aW>%inDI*!xf7w^%;!FUUduuf=b&{07U%&bP%+
zTYk#&$-_U3-)8xf#K(U4|0w=-mY)!xxFWwO{*{)mlMvj)i~mZ`wPbGS9zFN^YP$SA
zLSE<>+NbONy0**j`_ujYPlQK>p9*_~$Arg)CxpDPS9nr*O6V7!7M>A)ChQY_F6<Yc
z6%Gi$5S|mB7Y2kEgt2-SyeJy!*85p+u6R)WL&8hK%fc(doQT=qcZt5cDA&8b_wB(*
z;x~G3>!|77nfLFPYF-V_M)#lelt&V|=yRWXvK-$dUM~957xtHvU-}2sCl~aeQlEU$
z->W_`q~EVTbw~dR^{HjvG300Y%T~`MtLGOXJ+El3)00=<=^0Sp>3LRtr{{U~ot_uf
zcY5S|`72gWzPjX3Ur5h0TI=-uOns+kpZZSE&(#m~$Zo~6{IHdmvGN`b$@^(Y-s2&8
zdqVOa3&~SWl>gGo^Q^q5L-O{A<h|_V$qwaOkHxPKoxHf`rQO|KFVymmn9dEorSGav
zOX>4RM)0VCt^VlbA$|Tm<R6Om_*MNIiWT|J*H06#vT(@n*Y{heAKg&=W^(vgMPbwH
zeM71X@z&+_IV*G5An(qPBsUkUOs@ENesfXZ+Z^M$e5>9m%JiA1UC)A;KKI1*IrpeO
zk4Exe9c=xq-LLOLjNaKE>fWI5H#g`z(ctsm&;?g)(05MXc|8@==VJ5h>+~b$X`QdT
zEw9v%>7BibcW%wa^f~9(_WfXjbndC%;rETzcLe5c)oybk6}hHZ&}V?neD^kMo8RBB
z&sO?=E0%08JQ>mVFZymOulMUaMf-K1$ITA^o!%YA^q3v~^IzI9NbDl!&xdxWyNZ0@
zV8(a(M`B%mW}MEhXnw5DwP?TS4#j%se4U+?-pO^&BAxQf=sN}>ruW|OF5jf@d)3eD
z-BNitU+*39;GO20gP$Z%W|u!|g+ANqyd9~z%g<bJm+p_PPe=6*9oM^XRCX%v_s5Z;
zwR%@8>N8C+U#0mn&6jB&9elsQXZkYP5S1-ieHW<j00zn5I(^PRO*)$8Gw*4mmBU!_
z5yj=l(ov_lrU#5^$(Q6c4JeNJ7Jc_}Q17fJuXpX#t~b!v{$0gmv*OUN7#vkBY#jPp
zcLaIJ*YD6>w?lR<C|0DK6OnW-%KKn>U5h@S=Az}|Pmv9LZYY-x)X%J9kDolP%WsJE
z_;-q5ug~M!H&nMmpE1uD^o;3E|2O6Bx?-x38(L`eIj%i7^m}~{{hPw(;zOpZNUka*
z_ZrPVRM=AVw68pxEAIBT1Uml4Y%V4wXScrFK<C)dd*dI}h~kvhdue!0RJI0Vy<75m
zp3l9=c|gyDjh^oOI(?R@TVLF%@pg?p*}przzSyntMS1n}vhV-u`+L1(<LmB1S5cqE
z-!z`ScS`DWYMnmwrS-W+F+UaKYWw`CSFN>n`Tt92N}q>@!glf8IT$nMmjd6bo&1b3
zhxM5tdAc#(`m$)7z#6?no9*hm_hCL$@Y!OwUZQzd9uPIUMI3EqliIQ2;bDDNA7)zO
z4OFj!W}Kz^zGqlxeOTWo1sD|lM}c*;@q#DtpYO0?f&h>Czt=i__6_7ScdnrC?~Lk0
z@9L%YJIyQ3!_3R2Kn{C<BObb(Ud3`)pBVzZ*oO`ppP5t_0mXiWAlS!V^uuE<IxiQd
z3rRZ`G04OQbYcT*@d5wg>A!Cb>-(DF*92nqd!fqCi<pUmCty4Nu@9Zt50Fi4&J(5y
z*ia*20}cJiBnHHqy~x5R=3W+F6o>=9Aq)M0hOO8MJfT`(4R+%{eC$H!48hIArxCx2
z!X$y*kQdev2XtT;HW72=unt-HLBl5M2OrRj|H#9?S^=G`r9Tp41#<BLx#S2N0Ao*J
zj*lV8#V*z$N8j-UjoLgSkRxi1m}5)WX7&McfV}Yn@@UxV@`A0%o-SZNHn5(208hX+
z=2HR<oq#x?mzWW!3k2en60R2Ng$2TVp-z}9(8BR2_ULrBVk7d1J+?E4UBojb(D0Y|
zyBcOa{^1v~VlA<P0_Pt-&{&5|Y=z=4c|?vU5F59DviitozD%IuH+36V|6BndSm(h0
zSwe%bNN5+92^oQgJ}^c=2609QF>t;*{m8;z=2=f;J$i{Z^Z4u#jz6()6|%x@!tDah
z>90~BpThF+1z-z0S;KkY{=;t#1DnYcYn;zer+cpY^}-E8T4)xC1E5j6hlJ;Z1D0~v
zaek>MVnV!W<k{WD1M0&g9_X4Q5aXML)xsJ9U-23K)xyjWW~)!5cG0(A=oj)9jJbQ<
zJ<45zZfxBrJSnihLLg?;C$Yj7@-<69AN^W^m|S2nNtCrTWTGE`&`Auq>)dmRHRvD~
z*nmCUhpb~RA&^64Qq$<gSK@(wYMy#PH#q|Iv4=+Ph@q>s8R{d4F>A2X?PZ-O;4Ao`
z78etl=s^blW6uJiS!fr?%Q}JP>_-Rdi4`^wM`r`R0c2u>gStUIQj=lC#IF>_3Z8%;
z$V&;>QZFnNXw=;^0<kCV#Ms>>+%426`DUIx!DC+q|EQr0J=jOwW(sw}B4M?~&7%0v
z9J%lW&MXbN<eqwGO#H|-b?Nd<9dh2vG>2Z!0d}ez<Q|#C%<1KP6JPYFg*gJYc>-}k
z4xl9jPaxLLw$s(e2JSWd8!wO_<|hbMg7bf(`oxzyBevKu-}cEpabeFmfqmgTX?SWc
z`SAp|2EFWIKQ)1T`tag{(@z|*6PvLG8(BY3xItJb%n`U7tA%p~7Xx*JvrGPn12G}L
z$i#naVLiU1n?5`m^H9#gWWm)fab^r3Td@mYu#vn0`ouwOL+-hEsKLX+n*wW)k3FoT
zPfd;l`)NE2un*n%?+N(BK77R%;yYWoQMg&i3N-W`5#0R)eNAw6j_v5B{#eU>#k&Sz
zKXvMCCNI<qKtDOc2l~XG7*Qh)LaRWdwx1KIb?o5T!aii-JGzMn`Z*)$0_bHwF?PNq
zpT3JbeqShDF3b@Y3i!T8xLu&(k2`1FsfPr3=p#?W5YTsHVp19GF69+lsSSK2_teXH
zfm*?T8ZnqCkRNIh(75Ma40xuv=MVKjE?yO|hnjS8z&7H<ekk@~6San3^dtrRChyqf
z&LB222cJe9sXKf}f4}X+W6sH^9vEYb%QySsvj#uM3N8lZf%sz+`6L#^2tK;W6^*_4
zg@5=(&e_9W{D2}C8LT5-*ui?S0)L6OlS#g@0X>|DS;9P_PM9mq7G?;<hDPkDF>;G7
zF2~r5ZWpU5>U#pVVI%9*4RTE`X9^8My^s>%xg4OMyJ)dRv*?WiEhgYw+=9A7cS0a%
z=*3oSMy4k)=jx9!exiSY&?>AJZWhpqP0)5>jj&GmriDllQ{v9qBCfn&0Q$rmJrgX(
zutANSvz|Wop&P#!3FyuW_&8s<TEKtC8R0e|tRLOnH=M!!!oCm~b2q#!U=uotdzoYq
zFPh62W9%bmlLTTvLzp9A+d>OsL><7VQO}13^l;|f`E%5r3G5mWSc|>vV?R1Q;X;9$
zrrzoV^pIm>LhOkN@yCBaoM_ZBz8w-cgPcEfI$#sF9TD8Qqh?FH-}{_PuHciev4SUH
z({v#vQ1{qIOr{CU(eQ`6oIJ3fdL)*oTTq)c<~S!%>T_JcE$N!9z9*oY+Q1)jhwa>7
z$VLuzgguvAhy?Fn_)U(<FY?JR>#+lw^x-+UIkAHLW9uXVpU4M|Sdp*CEv240x5VZG
zf%>3fD|ZTKAK&pUA)G5vOXCG(qJud%j~p6nJ%P2%5hMJ-A96_UTzs+L<pz6c?3*mq
z2-wdUefUT$u!|bkFt7o;uzv~+HGD!Rai=En2a3PMoi*6bK2IPA<j%zjUbO&)N4#ms
zb--@;*v?vPy+WW7XZ+**;wyEG4cLSI<dA*n1;mp$5o;Rr@Q499K|c05|B>TBjbjUT
z5+@q*2k`M1ThLDqhzq*VOT1<XR||E*Jb^}Bh&#GjgMN7I!+&%-{m66vu*Nm~<QyLn
z@E>rlup^uU{B&`E(%?-L$SE}eWsaQT6S>C*;PkVe9MI59zR~CEeUJKif%EsGfF0xy
zUD%Cm{GgFD*17wQwbUHG;}`lFqn}*ADzNrRf&Hu@{@66l0w2f`Ag?opg~H83#?n?%
z+H2a+`9~&q2ImHUh`F-?zp=sTXMMlGeplzL#V=y#3C>SyiMSH4S;Aa_8lX?ZA9NxI
zo#+AhOYYFg{Xl%Nk+`D&kih<!;NnV5sT*`tQ<n?#gd2qpAuHhb0%5*DLoWL98NKkR
z{V-e|U?cg&4#3)KVTOQDoJr!1J>&rWbA%fN^sf_c6Uf10!8Kwx63k%(IYh^F0X+b@
zfad1NF@E76^3wu7Vw1C@L49gqjc~g_qki!V|Eay#EL;u5w1)aR*8<-Fd8K&*w&CYO
z0l(1SEYu0JEa;O5^sg42esYX1>VVjiTh0UZO+CWnTvG$s%6TAG<b+0yDg|uBrU`;4
z5Pxz(-C-XwND0_UO<)g=efV>paG@|wU@dWDA2NtB^T?;h(MeoraRDBAVxBm8g42(@
zS_@>7r`f{Q0*!h_zbCK<&>t%>S0T_igPaLsz?p!;XWsdM?-K>=b-v&OHG^Js;(NWN
zB7yDL&0cg*5r~<K0ek7=$0UJu*oM!vG7I8CEU+1SSi@Rpi<29Ufu@7~_)sYzGaN@^
zjz8#Szl$X{A&17DL2Xb!+`rV$qe8Fn10g4TUwBaXvB3So*?mr6KQ=p^P9JeVC%I2r
z5EJr9EW-N91@*~&M7=@_0(^2tT=0v!KrTKYBPGyA`cB-a2V#fsVOu`Pf6fo*mvhTq
z#(BXG&JVHRJi#MA#EE!uhInpBd{D<OZ^U7w{%{<qC2S}5F8(9ymzWVN=2?r))S@Tg
z7qLJeaiMYNViWcJmOzbDQ!ZxM!+IA>#>54gH2UNSedL8YIZq(o#1MP10h^egBh(4?
z!Ur{UlN0u%19{Xi_7ET9K^#&74Vepsc44v5AfyEJV%IEzdH4$j)~ylT{pbA0ck&2a
z9JDNm6Zs-8jIja#u!DyG_%~C)FLYfkU>AIHfDN++e4i)G7g+aEjX2=<IKdN$hm)C7
zpEgGD1m;|f(dA-{E<n5idI9mEp#vG@3csKLzmQog;0yT$^Z|a+sC&-+%Yr*|)DzD#
z&LVuCFVqiyOcRLJT!B_8B!uw-`aJ>N#FzY`-{~GnHFfI0AB4|6wags=4{-LdhqH<u
zF0Sn79K?kxfjBrDpv1uwE)b|g7Y7#uu?+G#>pv9!hroTu-S@b_Jpg@Bfd7ENTwdS~
zWPeyU@gWZAb@6v~Om3$O#NFAUZt(eydk0<Q0Y9l<;Btd5?jme;^W=#A=qLW?3g`r$
zfDO(L{Kt-wxezP(?^oRA{Q{I&bA~uq+;P~!{mk3}fq8i3f&H{H!R5i#JN6I@;0fV+
z!2gs$!#3=~KK78?f0695qU^y3YK$|C9{B8`wp?@iS%*I7J2g-(Ae*><Q2lX6(1Toj
zKzEfWdnXFi6wT=;$6@{GW{-OwV84q2y2(4b$vtO>I&@Gs;LR4T7iJ2~VLvvwMt-q{
z{j6;e(gKZKaaI7e!5My6U=A7Bi#+@xzR03xu$#tOWRPR(k2<5i0q26cbanUl>JtZi
z#b@@9lusOy&zchg&rD|@_XxG)YK#5<+4`{+n>~R#Ax|>|YK6R!Kk9?nkymOY-2T1s
z|M%+uxbY(g;n@F2=kLSx|FQ9N_2ugK<HnCOK<#rr!|gv?|A(C)?pMwmXJ+L2;S4$-
z@Za5AJQFx?+|it6&Mx5Y<~h#&;LfniKldf~6!#9bPW^Mwa27m)`;VA$p3w`i&F%jn
zeLN?)GhP$8k2voV5y)}&GNw6s<dggA<J!Ys+6U<$=`Z#oAKgxWxPHR%Bi@GvWPF_X
z5gYcqd=X<}{c-nW|3~R__M>a0{lt&lU<36{olg>y0=WeA;kh$_4CnvH)sOrS(*I%k
z3hQI<ht&_ZFi$;Ezkh7}KTN-?Uw2<1pIEtgNoCL&yZHWF>hI(3562@M|Btf&qs|}a
zi*t6wg1dq{&AlJ;PDBiNexZvR3F~+7Ox5CZ2h<AgJ&ETZ^}{<7``JqkP&=-EkjcA+
zd%tk@5*MB~oCkM*(TB&Jwgk=HS%<}YMtD@{6ZY6Kd}@Ms32MmIAe2V^BA*z9eJ9`e
zHcp`K0k&da*njRO?nL%-XYCX6!s8a$^rFB#w!2z!{$m^S?CZCn@9aiCwz!zlKPk97
zkzDZ%XP!KH0{8GN3*t}hU_1V>7d!A<!{GlDMFt>7@Tg;#bMi)?c%hSe!I#(UT4bZE
zUTC$LFPaiKL*$jc<O$!g0X}<Z@BuzBcDg<FSw~HA|Il~$5AukENKjMgpvI;N_zq>g
zCty1|X<=Q|0zBf6FCbiBG0m~p<(@cD3)sh;)6W?GL;*Xg`74AO0<p&~Pe2xRGqRBv
z&jMY@!d~pdUh;%pfId9t$Ty9(BlV}mn<-!i@gPUY{-F0yazfsT12xAp%he&Zd%*Ht
zojJdqerJER<O6cS86ig03pTs>qQlwGJPpcvPasy<OYE?{Rv?!b2*jUQk8JSK%Nlav
z)?p{-GOV8%x_iLcPfmy*F+#V?ANuK|ANj0dt=p$=(D3PHizA}M3BOs#eMj7}3mGmp
z;rexFiWnh>coTO(F1S<B5w@F{0UGBK9|3*j!6#P4g1F#YSU)x6_LG11ARmw)#_pb?
zX0Us*fFF#BE%%7JLCwz+U1&j{n6U>vtfgLw9kIX`&NORi%sVi~E_AS#b<_a$0Hr?g
zDQrJ6CsuvJ4}|-KE}_$6v*>q)2ZUbXVd2LX5*2)ZL(GXYF~oQBgMY;HHQ{ApKzLCg
z7p%c%_Ky+p34frR2Yi4}?6JLGxLH^&bO?)tW`TBCa?p(q>hoQ}$tG^t0ndRw<aR6_
zHDW<bxO>or9pnif@gi<>1@hA_pdVXW1scBdyy_R|bGPF+`tb8DftrTzK%HP4`>~aL
z;p=n(JIFmTU=4Ao7A_aCW3hl8&i^X)+0R+|Ah4gaM_lo1vVc!l2sGjVA744Y@Ml}f
z7`uoCaw-HGwxO3sAHD-)5EqCoHlZJ%(2Y!dNeQ&De(ahhqy%cWTEK2(IQjUBJnEZ9
ze91fc=bfKge$s+Ibw`bd>u|ru<f|m1bSGgeKH@9!m?lsUvxRxW4FY-Z5Y`Ca6lmlW
z9Zv5)^|6IIrv}{pfSuTZjp)t`?B|YU9Wlc%my4wOF6Rr?ZxzrFZWI;>v{$tk{nQ>5
zKdC=zkC>4MD2=-bdpR?lMR@2Xro@?eUueNuBwy2olrUF7C#bg&3GC<GqnA9m+Gnm(
z7$=Y`<Wn<c0x`j7b%S~I;%}{h&w$uFgmbV+{AEH`prM<1<3D*PuEdu(6C397o3n&o
zmj~xR_XBgpfjYxhe4ipv1Jo;ar37L??AwJk0u4XNA#%}!4tyl;fId1-2*d}Q4hh(&
zsURlAW}@I?PAo>o9lfo>;t<q5_5ZBk54A@fx;nrnXAeGN19chBKRkTEMr@@P&K1rR
zJOR6?2^WJ|>N}_#=qKmI8QJIz%fdHLKqlvl8Xzvjo952{WcBgc<sW^-o*XcT9jv9M
zuoHhoPJRDM4d6F%z(4L>&H!tjPWr?H`<P?D(~q8%Fjtso>D8ihgp`0S<Oe^f6MUc{
z3m_LB^-k=n1>y$iQ&;Tu1ZoRkX`bM8&s0CG2fMKuicIzqpOkQgKqC$=7TCo)bRyHm
zlUULZ10D^ZQo?-U2BA*i+`%U{<Y|n65A2^Ku&!00VIOPo9XnY|&ha-K2W$`9<m_iH
zvR$0m&wT}4ZZ1%tb(I3oOL9luYIsWb>FTqdb;KF{&IV6?{NY^H3NwV1Kw}NM@oloe
ze*B=J4_WBPc6>kwwz-Bq^wB>~z-RWb4quQ(Y@FTHCHDXjJJ{oivWNT;OY|aZqJYiV
zJ6pI~m}SS<OC$cyPS#&2um_6I0Q-qCzF`Zs>h52BA{XrO1pJ_3KYN**Co~Hk!Wv<j
zut=aG3*aBV5>MiYeKod^98bVU<cH&j&E&-S#y-}u1`r4K<M#rgUBHIh1sZm;2H!3a
z*iXEm=qGRZhE2qP_1H-qXwGi-C+wK>OkBwy`D8CL=LmBx#U2{Ek&6x&Lu9!)5}TOD
z$o2&Cf=#so4LyK{P1uJ{d}bYb$-(6UdmQkO#(GbfBEW+Z2V#i*l@_cc*32U-CD8Cc
ze1{NoY$cD*26VD#B*Z$kmKYExz&>;#W4wTF;^g!rFD202S>_o6IM>9CSYW@i1G~er
ziBU>zn%cz|Up#&K^h+<TrCoN}Wlc>@&1x+zEv>DsZM2)z7B8N0#T8fFc;k($Z@J}`
zxl2oJ+46s-Wil&Ptmx=iS!x$vxN6m{x2{#Y?Y7&3n47D<{N>BNNiErBH(fM!O6`=X
z7tOx%^IpxAOQuXUS6(Uuo7$S1mzaotr_7XJIseb5PQ7&c)eC1|bgiiv9gmETRF;j2
zjg6cg`DAo_<ebR4WuJ<kS7xTHT)Q;e)GV6qDAC2P*U{EKCEK<pYo_pf%4SOQ%9UnH
z%krg5^>fT-%ChCzwkcQ5yY3?WNV0yUd5RQHY073hmNc)*wyl&2AG>`<D<cB6K&ufp
zo)dI~f2e2Lrv&{Z-l<mAW=u|#@Yv5f^7toq92KSYN!D13+BPTe3mUWDtvjF}eC?(f
zZFB25XUK=rSVx_>#vHiJQpZ28b>YSu+E)eX%mf4d!#ZlzHMdSb>vYOC=DY^|s)$=8
z>efNaLj0PA60RRZ<1F4J;0JCIC+DlW=7A<-+CmH`kGXIQ^JC`M!E?mTM^9N%;zZx4
z0e!LHT)FjFt=}&U`5Ou5Q>PY`=4(zVEzQ@4#_WI3;nIB7sQ{Gr?+lGO*AIlo?0-wY
ztx#&E{V`X3*1m$`7oI;68nb`RsX{F6-x3-#A0zldE6tA$jhP?+2|F!)*p~{8nXf<n
z{qu`M<3N9C%zl3VtJF&V_rnZYN&ddjnEf+Oov+e*yI3R|+@XxAn~27q?YlAeE$7CK
zIj>craY}va&CSnYtn)_-kca;FTFiXS4od4|<}Wm+@5Z;NkG=*8h=|*vep-DuUaN7R
z7Q6L4tM`P)n>5ac#^2VsKQ#W1#{5=C$v*w6i^c~+^Z#4pfzY^D<3k!#64<jxl;5-K
zR*f>=uW`HTNvvS}qG(2AH($^ghur*e4f)Lvr~kK1YrNgcD;M3V`f}s5G*0TbLfroI
zH0JjRQ`(3A&uN?ujguPl+agXrXNlh%apRQ6eHx1d`}G@C<|m<XoyL!b#tj<(G&D|Y
zyeBkXtnp)^aYp0EL*q3XKM@*tYMc*^H*35%G$w9OhQ{}4{8VV1)3`r0{(;6%hsM1c
zKNA}FY5cR$IIr=((0HH5KM#!uG~OQ?AJ+KU(72%SfzbH4#=i)SPiXvHXna!R=R;!>
zF%TNZHGUy9PH6mMXgprygQ2mf@uARolEyEE#z~D|4vlLyekC+cY0PibxbrkyV}7s3
zjpu5-SqECgP+tqw=?ab08gB`Wwd_=jo_ea6SW$k|Ce)%jMK>c@EhUVRhOEZ)PulT1
zjcXONLw5Xaja`#k^F58Z|L;?u{eLxLp5N5r{!i;!$9%u~-1l!uCgZ=;nEQRF9siTY
z+~=FEywkOh`+Kt8{~1y4>q&O~pK8qgoYsLv-d8o|zTG1ojQ>L8?f=D?Z%E#mCTdzV
z<{h<DJjQ0kpL}RB)lH_l)vRe;+0xYBX4YETrazJ4c=R1VyR>m-`|_-rr@v@1Ypv1y
zSV#8M!qUhs4gN638WWJUMt^UkagEX6+u&dI#ZiB)$t+*8EZf+!e3jnw5T4ba*qC~%
zXIhpoTeRe+#+JoR9VJQjPjIYps^7<T2CX&v6CZ7|zx4MytP!QZ&>{VSNp`f>+^WC%
z(b&<HU9#NRzq+x;btJE~V{K!0u~};A%69$^$W&9J(=5H%(&?67YH6*dms#3mX|ts*
zmbO~jX6a3q>TiSu`f4n_#L}dtt1Z37(z%u{wRD-K%Pq}Vy28>9OIKRD$kJ7o-fF4h
z5ZG~B5V}$T*OtP#rjb9PqIY(ch<ZUVmo9H@QwBcb@2)g92A?4sS1oB>vikjhg~d$;
zGynhnNfw<q-m%Mc+-5*^R(Z#S8l872_bxOoI^kyB2X>r;YF}EI(5}zlS_92mTB|FK
zG4GV@e;2B?zqezqK=?;>$3Tx;`j(|f^{i(<@0851vvi}Sn=R#?lKHr$RhA|!<r$6~
zo`nIeD$xN;dFNz*wWX7wvNLJNwRSwijvp39PQlW+?l{Kdq01x(y1ewPn2<4Mmd2l6
zq34DudTxM9eybg?fhv~kEbX*(qotcI-C}9CrQ0pN&(fWi<}7`{(jQp*pryT*K5S{9
zrF$&RTiS2wK1&Z+I$-G`OAlLm#L|MLM=d>W>06ebu=HI^Pg?qWOO4*yiAT)RxTRH=
zCM+Fm>3B;gSn63?ZRsRSCtI4dw8qj}OJ`V`vUHZEb1a=}X`Q9@mNr;=gQaOpTP<B|
zX}hHvOS6`)v2>lKotAF2bhD*fEbX>*yQTM8y3^8}r4Ly814|#YwAa#yE$y?E&qmbe
z9(@p*uvqtkzAT!sMCbLBqN?xo_!7-P^<iV3=%@9KMh?1E@5*+*R-d8Z^H~acDNAQr
UI@i)VOY1F7Lpc|A+-}GJ4}z^-`Tzg`

literal 0
HcmV?d00001

diff --git a/drivers/input/touchscreen/mediatek/ft_allinone_gesture/ft_gesture_lib.h b/drivers/input/touchscreen/mediatek/ft_allinone_gesture/ft_gesture_lib.h
new file mode 100644
index 0000000..ac434e3
--- /dev/null
+++ b/drivers/input/touchscreen/mediatek/ft_allinone_gesture/ft_gesture_lib.h
@@ -0,0 +1,24 @@
+/************************************************************************
+* Copyright (C) 2012-2015, Focaltech Systems (R)All Rights Reserved.
+*
+* File Name: focaltech_ctl.c
+*
+* Author:
+*
+* Created: 2015-01-01
+*
+* Abstract: function for hand recognition
+*
+************************************************************************/
+#ifndef __LINUX_FT_GESTURE_LIB_H__
+#define __LINUX_FT_GESTURE_LIB_H__
+
+//int fetch_object_sample(unsigned short *datax,unsigned short *datay,unsigned char *dataxy,short pointnum,unsigned long time_stamp);
+
+int fetch_object_sample(unsigned char *buf,short pointnum);
+
+void init_para(int x_pixel,int y_pixel,int time_slot,int cut_x_pixel,int cut_y_pixel);
+
+//ft_gesture_lib_v1.0_20140820.a
+
+#endif
diff --git a/drivers/input/touchscreen/mediatek/ft_allinone_gesture/tpd_custom_fts.h b/drivers/input/touchscreen/mediatek/ft_allinone_gesture/tpd_custom_fts.h
new file mode 100644
index 0000000..b6d083a
--- /dev/null
+++ b/drivers/input/touchscreen/mediatek/ft_allinone_gesture/tpd_custom_fts.h
@@ -0,0 +1,151 @@
+#ifndef TOUCHPANEL_H__
+#define TOUCHPANEL_H__
+
+#include <linux/hrtimer.h>
+#include <linux/string.h>
+#include <linux/vmalloc.h>
+//#include <linux/io.h>
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/bitops.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/byteorder/generic.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+#include <linux/interrupt.h>
+#include <linux/time.h>
+#include <linux/rtpm_prio.h>
+
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
+
+#include <mach/mt_pm_ldo.h>
+#include <mach/mt_typedefs.h>
+#include <mach/mt_boot.h>
+
+#include <cust_eint.h>
+#include <linux/jiffies.h>
+
+#include <mach/mt_gpio.h>
+#include <pmic_drv.h>
+//#include <cust_i2c.h>
+
+#define MTK_Driver_Version 0x11
+
+struct Upgrade_Info {
+        u8 CHIP_ID;
+        u8 FTS_NAME[20];
+        u8 TPD_MAX_POINTS;
+        u8 AUTO_CLB;
+	u16 delay_aa;		/*delay of write FT_UPGRADE_AA */
+	u16 delay_55;		/*delay of write FT_UPGRADE_55 */
+	u8 upgrade_id_1;	/*upgrade id 1 */
+	u8 upgrade_id_2;	/*upgrade id 2 */
+	u16 delay_readid;	/*delay of read id */
+	u16 delay_earse_flash; /*delay of earse flash*/
+};
+//extern Upgrade_Info fts_updateinfo_curr;
+
+/**********************Custom define begin**********************************************/
+#if defined(CONFIG_HCT_TP_GESTRUE)
+#define FTS_GESTRUE
+#endif
+
+//#define TPD_PROXIMITY
+#define TPD_POWER_SOURCE_CUSTOM         	PMIC_APP_CAP_TOUCH_VDD
+#define IIC_PORT                        1
+#define TPD_HAVE_BUTTON									// if have virtual key,need define the MACRO
+#define TPD_BUTTON_HEIGH        				(40)  			//100
+#define TPD_KEY_COUNT           4    //  4
+#define TPD_KEYS                { KEY_MENU, KEY_BACK, KEY_SEARCH,KEY_HOMEPAGE}
+
+#if defined(CONFIG_TPD_PROXIMITY)
+	#define TPD_PROXIMITY					// if need the PS funtion,enable this MACRO
+#endif
+
+
+//QHD
+
+#define TPD_KEYS_DIM_QHD               {{160,2000,60,TPD_BUTTON_HEIGH}, {950,2000,60,TPD_BUTTON_HEIGH}, {200,2000,60,TPD_BUTTON_HEIGH}, {540,2000,60,TPD_BUTTON_HEIGH}}
+#define TPD_KEYS_DIM_FWVGA             {{66,880,60,TPD_BUTTON_HEIGH},  {418,880,60,TPD_BUTTON_HEIGH},  {200,880,60,TPD_BUTTON_HEIGH},  {300,880,60,TPD_BUTTON_HEIGH}}
+
+
+//#define TPD_RES_X                					540 //480
+//#define TPD_RES_Y                					960 //800
+/*********************Custom Define end*************************************************/
+
+#define TPD_NAME    "FT"
+
+/* Pre-defined definition */
+#define TPD_TYPE_CAPACITIVE
+#define TPD_TYPE_RESISTIVE
+#define TPD_POWER_SOURCE         
+#define TPD_I2C_NUMBER           		1
+#define TPD_WAKEUP_TRIAL         		60
+#define TPD_WAKEUP_DELAY         		100
+
+#define TPD_VELOCITY_CUSTOM_X 			15
+#define TPD_VELOCITY_CUSTOM_Y 			20
+
+
+
+
+#define TPD_DELAY                		(2*HZ/100)
+//#define TPD_RES_X                		480
+//#define TPD_RES_Y                		800
+#define TPD_CALIBRATION_MATRIX  		{962,0,0,0,1600,0,0,0};
+
+//#define TPD_HAVE_CALIBRATION
+//#define TPD_HAVE_TREMBLE_ELIMINATION
+
+#define TPD_SYSFS_DEBUG
+#define FTS_CTL_IIC
+#define FTS_APK_DEBUG
+#ifdef TPD_SYSFS_DEBUG
+//#define TPD_AUTO_UPGRADE				// if need upgrade CTP FW when POWER ON,pls enable this MACRO
+//#define FT6x36_DOWNLOAD
+#endif
+
+
+/******************************************************************************/
+/*Chip Device Type*/
+#define IC_FT5X06						0	/*x=2,3,4*/
+#define IC_FT5606						1	/*ft5506/FT5606/FT5816*/
+#define IC_FT5316						2	/*ft5x16*/
+#define IC_FT6208						3  	/*ft6208*/
+#define IC_FT6x06     					       4	/*ft6206/FT6306*/
+#define IC_FT5x06i     					5	/*ft5306i*/
+#define IC_FT5x36     					       6	/*ft5336/ft5436/FT5436i*/
+
+
+/*register address*/
+#define FT_REG_CHIP_ID				0xA3    //chip ID 
+#define FT_REG_FW_VER				0xA6   //FW  version 
+#define FT_REG_VENDOR_ID			0xA8   // TP vendor ID 
+
+
+#define TPD_MAX_POINTS_2                        2
+#define TPD_MAX_POINTS_5                        5
+#define TPD_MAXPOINTS_10                        10
+#define AUTO_CLB_NEED                              1
+#define AUTO_CLB_NONEED                          0
+
+
+#define FTS_DBG
+#ifdef FTS_DBG
+#define DBG(fmt, args...) 				printk("[FTS]" fmt, ## args)
+#else
+#define DBG(fmt, args...) 				do{}while(0)
+#endif
+
+#endif /* TOUCHPANEL_H__ */
diff --git a/drivers/misc/mediatek/Makefile~ b/drivers/misc/mediatek/Makefile~
deleted file mode 100755
index bde142e..0000000
--- a/drivers/misc/mediatek/Makefile~
+++ /dev/null
@@ -1,327 +0,0 @@
-#$(call all-subdir-src-or-makefile)
-include $(srctree)/drivers/misc/mediatek/Makefile.custom
-
-# For MT6795 FPGA bring-up
-ifeq ($(CONFIG_ARCH_MT6795),y)
-include $(srctree)/drivers/misc/mediatek/Makefile.mt6795
-else
-
-ifneq (,$(filter $(CONFIG_ARCH_MT6735) $(CONFIG_ARCH_MT6735M) $(CONFIG_ARCH_MT6753), y))
-include $(srctree)/drivers/misc/mediatek/Makefile.mt6735
-else
-
-ifneq (,$(filter $(CONFIG_ARCH_MT6580), y))
-include $(srctree)/drivers/misc/mediatek/Makefile.mt6580
-else
-
-
-ifeq ($(CONFIG_MTK_L2C_SHARE),y)
-obj-y   += l2c_share/
-endif
-
-ifeq ($(CONFIG_MTK_SYS_CIRQ),y)
-obj-y += cirq/
-else
-obj-$(CONFIG_MTK_CIRQ) += cirq/
-endif
-
-ifneq ($(CONFIG_MTK_GIC),y)
-obj-y   += irq/
-endif
-
-obj-$(CONFIG_MTK_CPU_STRESS)	+= cpu_stress/
-obj-$(CONFIG_MTK_LASTPC)	    += lastpc/
-obj-$(CONFIG_MTK_DBG_DUMP) += dbg_dump/
-
-ifeq ($(CONFIG_MTK_EXTMEM),y)
-obj-y	+= exm/
-endif
-
-obj-$(CONFIG_MTK_SYSTRACKER)   += systracker/
-obj-y   += cqdma/
-
-obj-y   += watchpoint/
-obj-$(CONFIG_MTK_ETM)   += etm/
-obj-y	+= mach/
-obj-y	+= kernel/
-obj-y	+= aee/
-obj-$(CONFIG_MTK_EMI_MPU)	+= emi_mpu/
-obj-$(CONFIG_MTK_EMI_BWL)	+= emi_bwl/
-
-obj-$(CONFIG_MTK_FMRADIO)	+= fmradio/
-obj-$(CONFIG_MTK_GPS)	    += gps/
-
-obj-y	+= m4u/
-#obj-y	+= mhl/
-obj-y	+= mtprof/
-obj-y	+= sched/
-obj-$(CONFIG_MTK_CMDQ) += cmdq/
-obj-y	+= mmp/
-obj-y	+= dispsys/
-obj-$(CONFIG_MTK_VIDEOX) += videox/
-
-obj-y	+= auxadc/
-
-#obj-y	+= bthid/
-
-ifdef CONFIG_CUSTOM_KERNEL_EXTMD
-ifneq ($(strip $(CONFIG_CUSTOM_KERNEL_EXTMD)),"")
-obj-y	+= emd_ctl/
-endif
-endif
-
-obj-$(CONFIG_MTK_WFD_SUPPORT)  += uibc/
-
-ifneq ($(wildcard $(srctree)/$(src)/met/),)
- 
-endif
-
-obj-$(CONFIG_MTK_XHCI)   +=  xhci/
-
-#obj-y	+=  hdmitx/
-obj-y	+= ram_console/
-obj-y	+= thermal/
-obj-y	+= videocodec/
-obj-$(CONFIG_MTK_MJC_DRIVER)   += mjc/
-obj-y	+= xlog/
-ifneq ($(filter y, $(CONFIG_ARM_PSCI) $(CONFIG_ARM64)),)
-	obj-y   +=  atf_log/
-endif
-obj-y   += wdk/
-#obj-y	+= evdo_support/
-obj-$(CONFIG_MTK_MT_LOGGER)	+= mt_logger/
-obj-$(CONFIG_MD32_SUPPORT)   += md32/
-obj-y += dramc/
-obj-y	+= lcm/
-
-ifeq ($(CONFIG_MTK_SENSOR_SUPPORT),y)
-obj-$(CONFIG_MTK_HWMON)	    += hwmon/
-obj-$(CONFIG_CUSTOM_KERNEL_ALSPS) += alsps/
-obj-$(CONFIG_CUSTOM_KERNEL_ACCELEROMETER) += accelerometer/
-obj-$(CONFIG_CUSTOM_KERNEL_GYROSCOPE) += gyroscope/
-obj-$(CONFIG_CUSTOM_KERNEL_MAGNETOMETER) += magnetometer/
-obj-$(CONFIG_CUSTOM_KERNEL_BAROMETER) += barometer/
-
-ifneq ($(CONFIG_CUSTOM_KERNEL_SENSORHUB),"")
-obj-y	+= sensorHub/
-ifneq ($(CONFIG_CUSTOM_KERNEL_STEP_COUNTER),"")
-obj-y	+= step_counter/
-endif
-ifneq ($(CONFIG_CUSTOM_KERNEL_SIGNIFICANT_MOTION_SENSOR),"")
-obj-y	+= step_counter/
-endif
-ifneq ($(CONFIG_CUSTOM_KERNEL_ACTIVITY_SENSOR),"")
-obj-y	+= activity_sensor/
-endif
-ifneq ($(CONFIG_CUSTOM_KERNEL_PICK_UP_SENSOR),"")
-obj-y	+= pick_up_sensor/
-endif
-ifneq ($(CONFIG_CUSTOM_KERNEL_SHAKE_SENSOR),"")
-obj-y	+= shake_sensor/
-endif
-ifneq ($(CONFIG_CUSTOM_KERNEL_FACE_DOWN_SENSOR),"")
-obj-y	+= face_down_sensor/
-endif
-ifneq ($(CONFIG_CUSTOM_KERNEL_IN_POCKET_SENSOR),"")
-obj-y	+= in_pocket_sensor/
-endif
-ifneq ($(CONFIG_CUSTOM_KERNEL_PEDOMETER),"")
-obj-y	+= pedometer/
-endif
-ifneq ($(CONFIG_CUSTOM_KERNEL_HEART_RATE_SENSOR),"")
-obj-y	+= heart_rate_sensor/
-endif
-ifneq ($(CONFIG_CUSTOM_KERNEL_TILT_DETECTOR_SENSOR),"")
-obj-y	+= tilt_detector_sensor/
-endif
-ifneq ($(CONFIG_CUSTOM_KERNEL_WAKE_GESTURE_SENSOR),"")
-obj-y	+= wake_gesture_sensor/
-endif
-ifneq ($(CONFIG_CUSTOM_KERNEL_GLANCE_GESTURE_SENSOR),"")
-obj-y	+= glance_gesture_sensor/
-endif
-endif
-endif
-
-#obj-y	+= matv/
-#obj-y	+= touchpanel/
-# 
-
-obj-$(CONFIG_MTK_VOW_SUPPORT)	+= vow/
-
-subdir-ccflags-y += -I$(srctree)/drivers/misc/mediatek/mach/$(MTK_PLATFORM)/include
-obj-$(CONFIG_MTK_COMBO)			+= connectivity/
-obj-$(CONFIG_MTK_CONN_MD)	+= conn_md/
-
-obj-y	+=  ccci_util/
-obj-$(CONFIG_MTK_NET_CCMNI) +=  ccmni/
-obj-$(CONFIG_MTK_CCCI_DRIVER)  +=  ccci/
-obj-$(CONFIG_MTK_CCCI_EXT)     +=  dual_ccci/
-obj-$(CONFIG_MTK_ECCCI_DRIVER) +=  eccci/
-obj-$(CONFIG_MTK_EEMCS_DRIVER) +=  eemcs/
-obj-$(CONFIG_MTK_IRTX) += irtx/
-obj-$(CONFIG_MTK_NFC) += nfc/
-obj-$(CONFIG_ZRAM)	+= mlog/
-
-#obj-y	+= cam_cal/src/$(MTK_PLATFORM)/dummy_eeprom/
-
-obj-y	+= lens/
-obj-y	+= imgsensor/src/
-
-
-ifeq ($(wildcard $(srctree)/drivers/misc/mediatek/mach/$(MTK_PLATFORM)/$(ARCH_MTK_PROJECT)/cam_cal),)
-obj-$(CONFIG_MTK_CAM_CAL)	+= cam_cal/src/
-endif
-
-#exclude mt6735
-ifeq (,$(filter $(CONFIG_MTK_PLATFORM), "mt6735"))
-obj-y	+=  flashlight/src/
-endif
-
-obj-y	+= sync/
-
-#rtc must compile before power, because they are both in fs_initcall, rtc need initial first for PMIC alarm call back
-obj-y	+= rtc/
-obj-y	+= boot/
-obj-y	+= boot_reason/
-obj-y	+= chip/
-obj-y	+= gpio/
-obj-y	+= eint/
-obj-y	+= uart/
-obj-y	+= pmic_wrap/
-
-ifeq ($(CONFIG_MTK_HDMI_SUPPORT),y)
-obj-y	+= hdmi/
-obj-y	+= ext_disp/
-endif
-
-obj-$(CONFIG_MTK_HIBERNATION) += hibcore/
-ifeq ($(CONFIG_CUSTOM_KERNEL_FLASHLIGHT),"dummy_flashlight")
-#obj-y	+= flashlight/dummy_flashlight/
-endif
-
-obj-y	+= accdet/
-obj-y	+= keypad/
-obj-$(CONFIG_MTK_DUM_CHAR)	+= dum-char/
-obj-$(CONFIG_MTK_SYSENV)	+= sysenv/
-
-ifdef CONFIG_CUSTOM_KERNEL_SSW
-ifneq ($(strip $(CONFIG_CUSTOM_KERNEL_SSW)),"")
-obj-y	+= ssw/
-endif
-endif
-
-#obj-$(CONFIG_MTK_CMMB) += cmmbdrv/
-obj-y	+= devapc/
-obj-y	+= devinfo/
-obj-y	+= gpu/
-
-ifneq (,$(filter $(CONFIG_MTK_PLATFORM), "mt6582" "mt6592" "mt6595" "mt6752" "mt6795" "mt6735" "mt8127"  "mt8163"))
-obj-y	+= jpeg/
-endif
-
-obj-y	+= leds/
-ifneq (,$(filter $(CONFIG_MTK_PLATFORM), "mt6572" "mt6582" "mt6592" "mt6595" "mt6752" "mt6795" "mt8127" "mt8163"))
-obj-y	+= masp/
-endif
-obj-$(CONFIG_MTK_MMC)	+= mmc-host/
-obj-$(CONFIG_MTK_MMC)	+= pmt/
-obj-$(CONFIG_MTK_MTD_NAND)	+= nand/
-obj-$(CONFIG_MTK_GPT_SCHEME_SUPPORT)	+= partition/
-obj-$(CONFIG_MTK_SOUND) += smartpa/
-
-#charge pump
-ifeq ($(CONFIG_CUSTOM_KERNEL_CHARGEPUMP),y)
-obj-y	+= chargepump/
-endif
-
-obj-y	+= power/
-obj-y	+= i2c/
-obj-y	+= pwm/
-obj-$(CONFIG_MTK_SMI)	+= smi/
-obj-$(CONFIG_MTK_BTCVSD) += btcvsd/
-obj-$(CONFIG_MTK_SOUND)	+= sound/
-obj-$(CONFIG_MTK_SPI)	+= spi/
-obj-y	+= spm/
-
-# USB need to after gpio
-obj-$(CONFIG_USB_MTK_HDRC)	+= usb20/
-obj-y	+= usb11/
-obj-$(CONFIG_USB_MU3D_DRV)	+= mu3d/
-obj-$(CONFIG_USB_MU3D_DRV)	+= mu3phy/
-
-obj-$(CONFIG_MTK_TEST_XHCI)   +=  xhci_test/
-
-obj-y	+= vibrator/
-obj-y	+= wdt/
-obj-y	+= freqhopping/
-obj-y	+= selinux_warning/
-# MTK PASR SW flow
-obj-$(CONFIG_MTKPASR)	+= mtkpasr/
-
-obj-$(CONFIG_MTK_TC1_FEATURE)	+= tc1_interface/
-
-obj-$(CONFIG_MTK_SWITCH_TX_POWER) += sw_tx_power/
-
-#charge pump
-#obj-y	+= chargepump/
-
-#obj-$(CONFIG_MTK_SOUND)	+= smartpa/
-
-obj-$(CONFIG_MTK_BTIF)	+= btif/
-obj-$(CONFIG_MTK_POWER_GS)	+= power_gs/
-obj-$(CONFIG_MTK_VIDEO) += video/
-obj-$(CONFIG_MTK_AEE_MRDUMP)	+= mrdump/
-obj-$(CONFIG_MTK_WMT_CCCI)	+= wmt_ccci/
-obj-$(CONFIG_MTK_VCOREFS)	+= vcorefs/
-
-obj-$(CONFIG_TRUSTONIC_TEE_SUPPORT) += gud/
-obj-$(CONFIG_TRUSTONIC_TEE_SUPPORT) += secmem/
-obj-$(CONFIG_MTK_C2K_SUPPORT) += c2k_ccci/
-obj-$(CONFIG_MTK_SCHED_CMP_POWER_AWARE_CONTROLLER)	+=  pa/
-obj-$(CONFIG_HMP_POWER_AWARE_CONTROLLER)	+=  pa_hmp/
-
-obj-$(CONFIG_MTK_IN_HOUSE_TEE_SUPPORT) += trustzone/
-
-#power-loss-test
-obj-$(CONFIG_PWR_LOSS_MTK_TEST) += power-loss-test/
-
-endif           # end of CONFIG_ARCH_MT6735
-endif		# end of CONFIG_ARCH_MT6795
-endif       # end of CONFIG_ARCH_MT6580
-
-ifeq (,$(filter $(CONFIG_MTK_PLATFORM), "mt8163"))
-obj-n   +=  irrx/
-endif
-
-ifneq (,$(filter $(CONFIG_MTK_PLATFORM), "mt6752"))
-obj-y	+= ddr/$(MTK_PLATFORM)/
-endif
-
-ifneq (,$(filter $(CONFIG_MTK_PLATFORM), "mt6735"))
-obj-y += gcpu/
-endif
-
-# gator driver is platform-independent
-ifeq ($(CONFIG_GATOR_DRIVER),y)
- ifneq ($(wildcard $(srctree)/$(src)/gator-driver/),)
-  obj-$(CONFIG_GATOR_DRIVER) += gator-driver/
- endif # gator-driver folder exist
-endif  # COFNIG_GATOR_DRIVER is set
-
-obj-$(CONFIG_MTK_MULTIBRIDGE_SUPPORT) += multibridge/
-
-#widevine drm
-#Classic DRM
-$(info "CONFIG_TRUSTONIC_TEE_SUPPORT = $(CONFIG_TRUSTONIC_TEE_SUPPORT)")
-obj-$(CONFIG_TRUSTONIC_TEE_SUPPORT) += secwidevine/
-
-ifneq (,$(filter $(CONFIG_MTK_PLATFORM), "mt2601"))
-ifneq ($(CONFIG_CUSTOM_KERNEL_SENSORHUB),"")
-obj-y	+= sensorHub/
-endif
-endif
-###########
-obj-y += custeint/
-obj-y += fingerprint/
-#obj-y += mac_fingerprint/
diff --git a/drivers/misc/mediatek/accelerometer/KXTJ2_1009_auto/kxtj2_1009.c~ b/drivers/misc/mediatek/accelerometer/KXTJ2_1009_auto/kxtj2_1009.c~
deleted file mode 100644
index bd0fd58..0000000
--- a/drivers/misc/mediatek/accelerometer/KXTJ2_1009_auto/kxtj2_1009.c~
+++ /dev/null
@@ -1,2189 +0,0 @@
-/* Copyright Statement:
- *
- * This software/firmware and related documentation ("MediaTek Software") are
- * protected under relevant copyright laws. The information contained herein
- * is confidential and proprietary to MediaTek Inc. and/or its licensors.
- * Without the prior written permission of MediaTek inc. and/or its licensors,
- * any reproduction, modification, use or disclosure of MediaTek Software,
- * and information contained herein, in whole or in part, shall be strictly prohibited.
- */
-/* MediaTek Inc. (C) 2010. All rights reserved.
- *
- * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
- * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
- * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
- * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
- * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
- * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
- * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
- * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
- * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
- * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
- * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
- * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
- * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
- * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
- * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
- * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
- *
- * The following software/firmware and/or related documentation ("MediaTek Software")
- * have been modified by MediaTek Inc. All revisions are subject to any receiver's
- * applicable license agreements with MediaTek Inc.
- */
-
-/* KXTJ2_1009 motion sensor driver
- *
- *
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/interrupt.h>
-#include <linux/i2c.h>
-#include <linux/slab.h>
-#include <linux/irq.h>
-#include <linux/miscdevice.h>
-#include <asm/uaccess.h>
-#include <linux/delay.h>
-#include <linux/input.h>
-#include <linux/workqueue.h>
-#include <linux/kobject.h>
-#include <linux/earlysuspend.h>
-#include <linux/platform_device.h>
-#include <asm/atomic.h>
-
-//jeff add 20130926 begin
-#include <cust_acc.h>
-#include <linux/hwmsensor.h>
-#include <linux/hwmsen_dev.h>
-#include <linux/sensors_io.h>
-
-#include <linux/hwmsen_helper.h>
-//jeff add 20130926 end
-
-#ifdef MT6573
-#include <mach/mt6573_devs.h>
-#include <mach/mt6573_typedefs.h>
-#include <mach/mt6573_gpio.h>
-#include <mach/mt6573_pll.h>
-#endif
-
-#ifdef MT6575
-#include <mach/mt6575_devs.h>
-#include <mach/mt6575_typedefs.h>
-#include <mach/mt6575_gpio.h>
-#include <mach/mt6575_pm_ldo.h>
-#endif
-
-#ifdef MT6577
-#include <mach/mt6577_devs.h>
-#include <mach/mt6577_typedefs.h>
-#include <mach/mt6577_gpio.h>
-#include <mach/mt6577_pm_ldo.h>
-#endif
-
-#ifdef MT6572
-#include <mach/mt_typedefs.h>
-#include <mach/mt_gpio.h>
-#include <mach/mt_pm_ldo.h>
-#endif
-
-#include <mach/mt_typedefs.h>
-#include <mach/mt_gpio.h>
-#include <mach/mt_pm_ldo.h>
-
-#ifdef MT6573
-#define POWER_NONE_MACRO MT65XX_POWER_NONE
-#endif
-
-#ifdef MT6575
-#define POWER_NONE_MACRO MT65XX_POWER_NONE
-#endif
-
-#ifdef MT6577
-#define POWER_NONE_MACRO MT65XX_POWER_NONE
-#endif
-
-#ifdef MT6572
-#define POWER_NONE_MACRO MT65XX_POWER_NONE
-#endif
-
-#define POWER_NONE_MACRO MT65XX_POWER_NONE
-
-#include <cust_acc.h>
-#include <linux/hwmsensor.h>
-#include <linux/hwmsen_dev.h>
-#include <linux/sensors_io.h>
-#include "kxtj2_1009.h"
-#include <linux/hwmsen_helper.h>
-/*----------------------------------------------------------------------------*/
-#define I2C_DRIVERID_KXTJ2_1009 150
-/*----------------------------------------------------------------------------*/
-#define DEBUG 1
-/*----------------------------------------------------------------------------*/
-//#define CONFIG_KXTJ2_1009_LOWPASS   /*apply low pass filter on output*/       
-#define SW_CALIBRATION
-
-/*----------------------------------------------------------------------------*/
-#define KXTJ2_1009_AXIS_X          0
-#define KXTJ2_1009_AXIS_Y          1
-#define KXTJ2_1009_AXIS_Z          2
-#define KXTJ2_1009_AXES_NUM        3
-#define KXTJ2_1009_DATA_LEN        6
-#define KXTJ2_1009_DEV_NAME        "KXTJ2_1009"
-/*----------------------------------------------------------------------------*/
-
-/*----------------------------------------------------------------------------*/
-static const struct i2c_device_id kxtj2_1009_i2c_id[] = {{KXTJ2_1009_DEV_NAME,0},{}};
-static struct i2c_board_info __initdata i2c_kxtj2_1009={ I2C_BOARD_INFO(KXTJ2_1009_DEV_NAME, /*(KXTJ2_1009_I2C_SLAVE_ADDR>>1)*/ 0x0E)};
-/*the adapter id will be available in customization*/
-//static unsigned short kxtj2_1009_force[] = {0x00, KXTJ2_1009_I2C_SLAVE_ADDR, I2C_CLIENT_END, I2C_CLIENT_END};
-//static const unsigned short *const kxtj2_1009_forces[] = { kxtj2_1009_force, NULL };
-//static struct i2c_client_address_data kxtj2_1009_addr_data = { .forces = kxtj2_1009_forces,};
-
-/*----------------------------------------------------------------------------*/
-static int  kxtj2_1009_local_init(void);	//jeff add 20130926
-static int kxtj2_1009_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id); 
-static int kxtj2_1009_i2c_remove(struct i2c_client *client);
-//static int kxtj2_1009_i2c_detect(struct i2c_client *client, int kind, struct i2c_board_info *info);	//jeff del
-static int kxtj2_1009_remove(struct platform_device *pdev);	//jeff add 20130926
-
-//jeff add 20130926
-static struct sensor_init_info kxtj2_1009_init_info = {
-        .name = "kxtj2_1009",
-        .init = kxtj2_1009_local_init,
-        .uninit = kxtj2_1009_remove,
-};
-
-static int kxtj2_1009_init_flag =0;
-
-/*----------------------------------------------------------------------------*/
-typedef enum {
-    ADX_TRC_FILTER  = 0x01,
-    ADX_TRC_RAWDATA = 0x02,
-    ADX_TRC_IOCTL   = 0x04,
-    ADX_TRC_CALI	= 0X08,
-    ADX_TRC_INFO	= 0X10,
-} ADX_TRC;
-/*----------------------------------------------------------------------------*/
-struct scale_factor{
-    u8  whole;
-    u8  fraction;
-};
-/*----------------------------------------------------------------------------*/
-struct data_resolution {
-    struct scale_factor scalefactor;
-    int                 sensitivity;
-};
-/*----------------------------------------------------------------------------*/
-#define C_MAX_FIR_LENGTH (32)
-/*----------------------------------------------------------------------------*/
-struct data_filter {
-    s16 raw[C_MAX_FIR_LENGTH][KXTJ2_1009_AXES_NUM];
-    int sum[KXTJ2_1009_AXES_NUM];
-    int num;
-    int idx;
-};
-/*----------------------------------------------------------------------------*/
-struct kxtj2_1009_i2c_data {
-    struct i2c_client *client;
-    struct acc_hw *hw;
-    struct hwmsen_convert   cvt;
-    
-    /*misc*/
-    struct data_resolution *reso;
-    atomic_t                trace;
-    atomic_t                suspend;
-    atomic_t                selftest;
-	atomic_t				filter;
-    s16                     cali_sw[KXTJ2_1009_AXES_NUM+1];
-
-    /*data*/
-    s8                      offset[KXTJ2_1009_AXES_NUM+1];  /*+1: for 4-byte alignment*/
-    s16                     data[KXTJ2_1009_AXES_NUM+1];
-
-#if defined(CONFIG_KXTJ2_1009_LOWPASS)
-    atomic_t                firlen;
-    atomic_t                fir_en;
-    struct data_filter      fir;
-#endif 
-    /*early suspend*/
-#if defined(CONFIG_HAS_EARLYSUSPEND)
-    struct early_suspend    early_drv;
-#endif     
-};
-/*----------------------------------------------------------------------------*/
-static struct i2c_driver kxtj2_1009_i2c_driver = {
-    .driver = {
-//        .owner          = THIS_MODULE,
-        .name           = KXTJ2_1009_DEV_NAME,
-    },
-	.probe      		= kxtj2_1009_i2c_probe,
-	.remove    			= kxtj2_1009_i2c_remove,
-//	.detect				= kxtj2_1009_i2c_detect,		//jeff del
-#if !defined(CONFIG_HAS_EARLYSUSPEND)    
-    .suspend            = kxtj2_1009_suspend,
-    .resume             = kxtj2_1009_resume,
-#endif
-	.id_table = kxtj2_1009_i2c_id,
-//	.address_data = &kxtj2_1009_addr_data,
-};
-
-/*----------------------------------------------------------------------------*/
-static struct i2c_client *kxtj2_1009_i2c_client = NULL;
-//static struct platform_driver kxtj2_1009_gsensor_driver;	//jeff del 20130926
-static struct kxtj2_1009_i2c_data *obj_i2c_data = NULL;
-static bool sensor_power = true;
-static GSENSOR_VECTOR3D gsensor_gain;
-static char selftestRes[8]= {0}; 	//keep the same //jeff del 20130926
-
-
-/*----------------------------------------------------------------------------*/
-#define GSE_TAG                  "[Gsensor] "
-#define GSE_FUN(f)               printk( GSE_TAG"%s\n", __FUNCTION__)
-#define GSE_ERR(fmt, args...)    printk(KERN_ERR GSE_TAG"%s %d : "fmt, __FUNCTION__, __LINE__, ##args)
-#define GSE_LOG(fmt, args...)    printk( GSE_TAG fmt, ##args)
-/*----------------------------------------------------------------------------*/
-static struct data_resolution kxtj2_1009_data_resolution[1] = {
- /* combination by {FULL_RES,RANGE}*/
-    {{ 0, 9}, 1024}, // dataformat +/-2g  in 12-bit resolution;  { 3, 9} = 3.9 = (2*2*1000)/(2^12);  256 = (2^12)/(2*2)          
-};
-/*----------------------------------------------------------------------------*/
-static struct data_resolution kxtj2_1009_offset_resolution = {{15, 6}, 64};
-/*----------------------------------------------------------------------------*/
-static int KXTJ2_1009_SetPowerMode(struct i2c_client *client, bool enable);
-/*--------------------KXTJ2_1009 power control function----------------------------------*/
-static void KXTJ2_1009_power(struct acc_hw *hw, unsigned int on) 
-{
-	static unsigned int power_on = 0;
-//huangxi add 20130315 begin
-	if (on) {		//GPIO99  //GPIO145
-		mt_set_gpio_dir(GPIO6, GPIO_DIR_OUT);
-		mt_set_gpio_out(GPIO6, GPIO_OUT_ONE);
-	} else {
-		mt_set_gpio_dir(GPIO6, GPIO_DIR_OUT);
-		mt_set_gpio_out(GPIO6, GPIO_OUT_ZERO);
-	}  
-//huangxi add 20130315 end
-	if(hw->power_id != POWER_NONE_MACRO)		// have externel LDO
-	{        
-		GSE_LOG("power %s\n", on ? "on" : "off");
-		if(power_on == on)	// power status not change
-		{
-			GSE_LOG("ignore power control: %d\n", on);
-		}
-		else if(on)	// power on
-		{
-			if(!hwPowerOn(hw->power_id, hw->power_vol, "KXTJ2_1009"))
-			{
-				GSE_ERR("power on fails!!\n");
-			}
-		}
-		else	// power off
-		{
-			if (!hwPowerDown(hw->power_id, "KXTJ2_1009"))
-			{
-				GSE_ERR("power off fail!!\n");
-			}			  
-		}
-	}
-	power_on = on;    
-}
-/*----------------------------------------------------------------------------*/
-
-/*----------------------------------------------------------------------------*/
-static int KXTJ2_1009_SetDataResolution(struct kxtj2_1009_i2c_data *obj)
-{
-	int err;
-	u8  databuf[2], reso;
-
-	KXTJ2_1009_SetPowerMode(obj->client, false);
-
-	if(hwmsen_read_block(obj->client, KXTJ2_1009_REG_DATA_RESOLUTION, databuf, 0x01))
-	{
-		printk("kxtj2_1009 read Dataformat failt \n");
-		return KXTJ2_1009_ERR_I2C;
-	}
-
-	databuf[0] &= ~KXTJ2_1009_RANGE_DATA_RESOLUTION_MASK;
-	databuf[0] |= KXTJ2_1009_RANGE_DATA_RESOLUTION_MASK;//12bit
-	databuf[1] = databuf[0];
-	databuf[0] = KXTJ2_1009_REG_DATA_RESOLUTION;
-
-
-	err = i2c_master_send(obj->client, databuf, 0x2);
-
-	if(err <= 0)
-	{
-		return KXTJ2_1009_ERR_I2C;
-	}
-
-	KXTJ2_1009_SetPowerMode(obj->client, true);
-
-	//kxtj2_1009_data_resolution[0] has been set when initialize: +/-2g  in 8-bit resolution:  15.6 mg/LSB*/   
-	obj->reso = &kxtj2_1009_data_resolution[0];
-
-	return 0;
-}
-/*----------------------------------------------------------------------------*/
-static int KXTJ2_1009_ReadData(struct i2c_client *client, s16 data[KXTJ2_1009_AXES_NUM])
-{
-	struct kxtj2_1009_i2c_data *priv = i2c_get_clientdata(client);        
-	u8 addr = KXTJ2_1009_REG_DATAX0;		//keep the same //jeff del 20130926
-	u8 buf[KXTJ2_1009_DATA_LEN] = {0};
-	int err = 0;
-	int i;
-	int tmp=0;
-	u8 ofs[3];
-
-
-
-	if(NULL == client)
-	{
-		err = -EINVAL;
-	}
-	else if(err = hwmsen_read_block(client, addr, buf, 0x06))
-	{
-		GSE_ERR("error: %d\n", err);
-	}
-	else
-	{
-		data[KXTJ2_1009_AXIS_X] = (s16)((buf[KXTJ2_1009_AXIS_X*2] >> 4) |
-		         (buf[KXTJ2_1009_AXIS_X*2+1] << 4));
-		data[KXTJ2_1009_AXIS_Y] = (s16)((buf[KXTJ2_1009_AXIS_Y*2] >> 4) |
-		         (buf[KXTJ2_1009_AXIS_Y*2+1] << 4));
-		data[KXTJ2_1009_AXIS_Z] = (s16)((buf[KXTJ2_1009_AXIS_Z*2] >> 4) |
-		         (buf[KXTJ2_1009_AXIS_Z*2+1] << 4));
-
-		for(i=0;i<3;i++)				
-		{								//because the data is store in binary complement number formation in computer system
-			if ( data[i] == 0x0800 )	//so we want to calculate actual number here
-				data[i]= -2048;			//10bit resolution, 512= 2^(12-1)
-			else if ( data[i] & 0x0800 )//transfor format
-			{							//printk("data 0 step %x \n",data[i]);
-				data[i] -= 0x1; 		//printk("data 1 step %x \n",data[i]);
-				data[i] = ~data[i]; 	//printk("data 2 step %x \n",data[i]);
-				data[i] &= 0x07ff;		//printk("data 3 step %x \n\n",data[i]);
-				data[i] = -data[i]; 	
-			}
-		}	
-
-
-		if(atomic_read(&priv->trace) & ADX_TRC_RAWDATA)
-		{
-			GSE_LOG("[%08X %08X %08X] => [%5d %5d %5d]\n", data[KXTJ2_1009_AXIS_X], data[KXTJ2_1009_AXIS_Y], data[KXTJ2_1009_AXIS_Z],
-		                               data[KXTJ2_1009_AXIS_X], data[KXTJ2_1009_AXIS_Y], data[KXTJ2_1009_AXIS_Z]);
-		}
-#ifdef CONFIG_KXTJ2_1009_LOWPASS
-		if(atomic_read(&priv->filter))
-		{
-			if(atomic_read(&priv->fir_en) && !atomic_read(&priv->suspend))
-			{
-				int idx, firlen = atomic_read(&priv->firlen);   
-				if(priv->fir.num < firlen)
-				{                
-					priv->fir.raw[priv->fir.num][KXTJ2_1009_AXIS_X] = data[KXTJ2_1009_AXIS_X];
-					priv->fir.raw[priv->fir.num][KXTJ2_1009_AXIS_Y] = data[KXTJ2_1009_AXIS_Y];
-					priv->fir.raw[priv->fir.num][KXTJ2_1009_AXIS_Z] = data[KXTJ2_1009_AXIS_Z];
-					priv->fir.sum[KXTJ2_1009_AXIS_X] += data[KXTJ2_1009_AXIS_X];
-					priv->fir.sum[KXTJ2_1009_AXIS_Y] += data[KXTJ2_1009IK_AXIS_Y];
-					priv->fir.sum[KXTJ2_1009_AXIS_Z] += data[KXTJ2_1009_AXIS_Z];
-					if(atomic_read(&priv->trace) & ADX_TRC_FILTER)
-					{
-						GSE_LOG("add [%2d] [%5d %5d %5d] => [%5d %5d %5d]\n", priv->fir.num,
-							priv->fir.raw[priv->fir.num][KXTJ2_1009_AXIS_X], priv->fir.raw[priv->fir.num][KXTJ2_1009_AXIS_Y], priv->fir.raw[priv->fir.num][KXTJ2_1009_AXIS_Z],
-							priv->fir.sum[KXTJ2_1009_AXIS_X], priv->fir.sum[KXTJ2_1009_AXIS_Y], priv->fir.sum[KXTJ2_1009_AXIS_Z]);
-					}
-					priv->fir.num++;
-					priv->fir.idx++;
-				}
-				else
-				{
-					idx = priv->fir.idx % firlen;
-					priv->fir.sum[KXTJ2_1009_AXIS_X] -= priv->fir.raw[idx][KXTJ2_1009_AXIS_X];
-					priv->fir.sum[KXTJ2_1009_AXIS_Y] -= priv->fir.raw[idx][KXTJ2_1009_AXIS_Y];
-					priv->fir.sum[KXTJ2_1009_AXIS_Z] -= priv->fir.raw[idx][KXTJ2_1009_AXIS_Z];
-					priv->fir.raw[idx][KXTJ2_1009_AXIS_X] = data[KXTJ2_1009_AXIS_X];
-					priv->fir.raw[idx][KXTJ2_1009_AXIS_Y] = data[KXTJ2_1009_AXIS_Y];
-					priv->fir.raw[idx][KXTJ2_1009_AXIS_Z] = data[KXTJ2_1009_AXIS_Z];
-					priv->fir.sum[KXTJ2_1009_AXIS_X] += data[KXTJ2_1009_AXIS_X];
-					priv->fir.sum[KXTJ2_1009_AXIS_Y] += data[KXTJ2_1009_AXIS_Y];
-					priv->fir.sum[KXTJ2_1009_AXIS_Z] += data[KXTJ2_1009_AXIS_Z];
-					priv->fir.idx++;
-					data[KXTJ2_1009_AXIS_X] = priv->fir.sum[KXTJ2_1009_AXIS_X]/firlen;
-					data[KXTJ2_1009_AXIS_Y] = priv->fir.sum[KXTJ2_1009_AXIS_Y]/firlen;
-					data[KXTJ2_1009_AXIS_Z] = priv->fir.sum[KXTJ2_1009_AXIS_Z]/firlen;
-					if(atomic_read(&priv->trace) & ADX_TRC_FILTER)
-					{
-						GSE_LOG("add [%2d] [%5d %5d %5d] => [%5d %5d %5d] : [%5d %5d %5d]\n", idx,
-						priv->fir.raw[idx][KXTJ2_1009_AXIS_X], priv->fir.raw[idx][KXTJ2_1009_AXIS_Y], priv->fir.raw[idx][KXTJ2_1009_AXIS_Z],
-						priv->fir.sum[KXTJ2_1009_AXIS_X], priv->fir.sum[KXTJ2_1009_AXIS_Y], priv->fir.sum[KXTJ2_1009_AXIS_Z],
-						data[KXTJ2_1009_AXIS_X], data[KXTJ2_1009_AXIS_Y], data[KXTJ2_1009_AXIS_Z]);
-					}
-				}
-			}
-		}	
-#endif         
-	}
-	return err;
-}
-/*----------------------------------------------------------------------------*/
-static int KXTJ2_1009_ReadOffset(struct i2c_client *client, s8 ofs[KXTJ2_1009_AXES_NUM])
-{    
-	int err;
-
-	ofs[1]=ofs[2]=ofs[0]=0x00;
-
-	printk("offesx=%x, y=%x, z=%x",ofs[0],ofs[1],ofs[2]);
-	
-	return err;    
-}
-/*----------------------------------------------------------------------------*/
-static int KXTJ2_1009_ResetCalibration(struct i2c_client *client)
-{
-	struct kxtj2_1009_i2c_data *obj = i2c_get_clientdata(client);
-	u8 ofs[4]={0,0,0,0};
-	int err;
-
-	memset(obj->cali_sw, 0x00, sizeof(obj->cali_sw));
-	memset(obj->offset, 0x00, sizeof(obj->offset));
-	return err;    
-}
-/*----------------------------------------------------------------------------*/
-static int KXTJ2_1009_ReadCalibration(struct i2c_client *client, int dat[KXTJ2_1009_AXES_NUM])
-{
-    struct kxtj2_1009_i2c_data *obj = i2c_get_clientdata(client);
-    int err;
-    int mul;
-
-	#ifdef SW_CALIBRATION
-		mul = 0;//only SW Calibration, disable HW Calibration
-	#else
-	    if ((err = KXTJ2_1009_ReadOffset(client, obj->offset))) {
-        GSE_ERR("read offset fail, %d\n", err);
-        return err;
-    	}    
-    	mul = obj->reso->sensitivity/kxtj2_1009_offset_resolution.sensitivity;
-	#endif
-
-    dat[obj->cvt.map[KXTJ2_1009_AXIS_X]] = obj->cvt.sign[KXTJ2_1009_AXIS_X]*(obj->offset[KXTJ2_1009_AXIS_X]*mul + obj->cali_sw[KXTJ2_1009_AXIS_X]);
-    dat[obj->cvt.map[KXTJ2_1009_AXIS_Y]] = obj->cvt.sign[KXTJ2_1009_AXIS_Y]*(obj->offset[KXTJ2_1009_AXIS_Y]*mul + obj->cali_sw[KXTJ2_1009_AXIS_Y]);
-    dat[obj->cvt.map[KXTJ2_1009_AXIS_Z]] = obj->cvt.sign[KXTJ2_1009_AXIS_Z]*(obj->offset[KXTJ2_1009_AXIS_Z]*mul + obj->cali_sw[KXTJ2_1009_AXIS_Z]);                        
-                                       
-    return 0;
-}
-/*----------------------------------------------------------------------------*/
-static int KXTJ2_1009_ReadCalibrationEx(struct i2c_client *client, int act[KXTJ2_1009_AXES_NUM], int raw[KXTJ2_1009_AXES_NUM])
-{  
-	/*raw: the raw calibration data; act: the actual calibration data*/
-	struct kxtj2_1009_i2c_data *obj = i2c_get_clientdata(client);
-	int err;
-	int mul;
-
- 
-
-	#ifdef SW_CALIBRATION
-		mul = 0;//only SW Calibration, disable HW Calibration
-	#else
-		if(err = KXTJ2_1009_ReadOffset(client, obj->offset))
-		{
-			GSE_ERR("read offset fail, %d\n", err);
-			return err;
-		}   
-		mul = obj->reso->sensitivity/kxtj2_1009_offset_resolution.sensitivity;
-	#endif
-	
-	raw[KXTJ2_1009_AXIS_X] = obj->offset[KXTJ2_1009_AXIS_X]*mul + obj->cali_sw[KXTJ2_1009_AXIS_X];
-	raw[KXTJ2_1009_AXIS_Y] = obj->offset[KXTJ2_1009_AXIS_Y]*mul + obj->cali_sw[KXTJ2_1009_AXIS_Y];
-	raw[KXTJ2_1009_AXIS_Z] = obj->offset[KXTJ2_1009_AXIS_Z]*mul + obj->cali_sw[KXTJ2_1009_AXIS_Z];
-
-	act[obj->cvt.map[KXTJ2_1009_AXIS_X]] = obj->cvt.sign[KXTJ2_1009_AXIS_X]*raw[KXTJ2_1009_AXIS_X];
-	act[obj->cvt.map[KXTJ2_1009_AXIS_Y]] = obj->cvt.sign[KXTJ2_1009_AXIS_Y]*raw[KXTJ2_1009_AXIS_Y];
-	act[obj->cvt.map[KXTJ2_1009_AXIS_Z]] = obj->cvt.sign[KXTJ2_1009_AXIS_Z]*raw[KXTJ2_1009_AXIS_Z];                        
-	                       
-	return 0;
-}
-/*----------------------------------------------------------------------------*/
-static int KXTJ2_1009_WriteCalibration(struct i2c_client *client, int dat[KXTJ2_1009_AXES_NUM])
-{
-	struct kxtj2_1009_i2c_data *obj = i2c_get_clientdata(client);
-	int err;
-	int cali[KXTJ2_1009_AXES_NUM], raw[KXTJ2_1009_AXES_NUM];
-	int lsb = kxtj2_1009_offset_resolution.sensitivity;
-	int divisor = obj->reso->sensitivity/lsb;
-
-	if(err = KXTJ2_1009_ReadCalibrationEx(client, cali, raw))	/*offset will be updated in obj->offset*/
-	{ 
-		GSE_ERR("read offset fail, %d\n", err);
-		return err;
-	}
-
-	GSE_LOG("OLDOFF: (%+3d %+3d %+3d): (%+3d %+3d %+3d) / (%+3d %+3d %+3d)\n", 
-		raw[KXTJ2_1009_AXIS_X], raw[KXTJ2_1009_AXIS_Y], raw[KXTJ2_1009_AXIS_Z],
-		obj->offset[KXTJ2_1009_AXIS_X], obj->offset[KXTJ2_1009_AXIS_Y], obj->offset[KXTJ2_1009_AXIS_Z],
-		obj->cali_sw[KXTJ2_1009_AXIS_X], obj->cali_sw[KXTJ2_1009_AXIS_Y], obj->cali_sw[KXTJ2_1009_AXIS_Z]);
-
-	/*calculate the real offset expected by caller*/
-	cali[KXTJ2_1009_AXIS_X] += dat[KXTJ2_1009_AXIS_X];
-	cali[KXTJ2_1009_AXIS_Y] += dat[KXTJ2_1009_AXIS_Y];
-	cali[KXTJ2_1009_AXIS_Z] += dat[KXTJ2_1009_AXIS_Z];
-
-	GSE_LOG("UPDATE: (%+3d %+3d %+3d)\n", 
-		dat[KXTJ2_1009_AXIS_X], dat[KXTJ2_1009_AXIS_Y], dat[KXTJ2_1009_AXIS_Z]);
-
-#ifdef SW_CALIBRATION
-	obj->cali_sw[KXTJ2_1009_AXIS_X] = obj->cvt.sign[KXTJ2_1009_AXIS_X]*(cali[obj->cvt.map[KXTJ2_1009_AXIS_X]]);
-	obj->cali_sw[KXTJ2_1009_AXIS_Y] = obj->cvt.sign[KXTJ2_1009_AXIS_Y]*(cali[obj->cvt.map[KXTJ2_1009_AXIS_Y]]);
-	obj->cali_sw[KXTJ2_1009_AXIS_Z] = obj->cvt.sign[KXTJ2_1009_AXIS_Z]*(cali[obj->cvt.map[KXTJ2_1009_AXIS_Z]]);	
-#else
-	obj->offset[KXTJ2_1009_AXIS_X] = (s8)(obj->cvt.sign[KXTJ2_1009_AXIS_X]*(cali[obj->cvt.map[KXTJ2_1009_AXIS_X]])/(divisor));
-	obj->offset[KXTJ2_1009_AXIS_Y] = (s8)(obj->cvt.sign[KXTJ2_1009_AXIS_Y]*(cali[obj->cvt.map[KXTJ2_1009_AXIS_Y]])/(divisor));
-	obj->offset[KXTJ2_1009_AXIS_Z] = (s8)(obj->cvt.sign[KXTJ2_1009_AXIS_Z]*(cali[obj->cvt.map[KXTJ2_1009_AXIS_Z]])/(divisor));
-
-	/*convert software calibration using standard calibration*/
-	obj->cali_sw[KXTJ2_1009_AXIS_X] = obj->cvt.sign[KXTJ2_1009_AXIS_X]*(cali[obj->cvt.map[KXTJ2_1009_AXIS_X]])%(divisor);
-	obj->cali_sw[KXTJ2_1009_AXIS_Y] = obj->cvt.sign[KXTJ2_1009_AXIS_Y]*(cali[obj->cvt.map[KXTJ2_1009_AXIS_Y]])%(divisor);
-	obj->cali_sw[KXTJ2_1009_AXIS_Z] = obj->cvt.sign[KXTJ2_1009_AXIS_Z]*(cali[obj->cvt.map[KXTJ2_1009_AXIS_Z]])%(divisor);
-
-	GSE_LOG("NEWOFF: (%+3d %+3d %+3d): (%+3d %+3d %+3d) / (%+3d %+3d %+3d)\n", 
-		obj->offset[KXTJ2_1009_AXIS_X]*divisor + obj->cali_sw[KXTJ2_1009_AXIS_X], 
-		obj->offset[KXTJ2_1009_AXIS_Y]*divisor + obj->cali_sw[KXTJ2_1009_AXIS_Y], 
-		obj->offset[KXTJ2_1009_AXIS_Z]*divisor + obj->cali_sw[KXTJ2_1009_AXIS_Z], 
-		obj->offset[KXTJ2_1009_AXIS_X], obj->offset[KXTJ2_1009_AXIS_Y], obj->offset[KXTJ2_1009_AXIS_Z],
-		obj->cali_sw[KXTJ2_1009_AXIS_X], obj->cali_sw[KXTJ2_1009_AXIS_Y], obj->cali_sw[KXTJ2_1009_AXIS_Z]);
-
-	if(err = hwmsen_write_block(obj->client, KXTJ2_1009_REG_OFSX, obj->offset, KXTJ2_1009_AXES_NUM))
-	{
-		GSE_ERR("write offset fail: %d\n", err);
-		return err;
-	}
-#endif
-
-	return err;
-}
-/*----------------------------------------------------------------------------*/
-static int KXTJ2_1009_CheckDeviceID(struct i2c_client *client)
-{
-	u8 databuf[10];    
-	int res = 0;
-
-//	return KXTJ2_1009_SUCCESS;	//jeff add 20130926
-	printk("jeff KXTJ2_1009_CheckDeviceID()\n");
-
-	memset(databuf, 0, sizeof(u8)*10);    
-	databuf[0] = KXTJ2_1009_REG_DEVID;   
-
-	res = i2c_master_send(client, databuf, 0x1);
-	if(res <= 0)
-	{
-		goto exit_KXTJ2_1009_CheckDeviceID;
-	}
-	
-	udelay(500);
-
-	databuf[0] = 0x0;        
-	res = i2c_master_recv(client, databuf, 0x01);
-	if(res <= 0)
-	{
-		goto exit_KXTJ2_1009_CheckDeviceID;
-	}
-	
-
-	if(false)
-	{
-		printk("KXTJ2_1009_CheckDeviceID 0x%x failt!\n ", databuf[0]);
-		return KXTJ2_1009_ERR_IDENTIFICATION;
-	}
-	else
-	{
-		printk("KXTJ2_1009_CheckDeviceID 0x%x pass!\n ", databuf[0]);
-	}
-	
-	exit_KXTJ2_1009_CheckDeviceID:
-	if (res <= 0)
-	{
-		return KXTJ2_1009_ERR_I2C;
-	}
-	
-	return KXTJ2_1009_SUCCESS;
-}
-/*----------------------------------------------------------------------------*/
-static int KXTJ2_1009_SetPowerMode(struct i2c_client *client, bool enable)
-{
-	u8 databuf[2];    
-	int res = 0;
-	u8 addr = KXTJ2_1009_REG_POWER_CTL;
-	struct kxtj2_1009_i2c_data *obj = i2c_get_clientdata(client);
-	
-	
-	if(enable == sensor_power)
-	{
-		GSE_LOG("Sensor power status is newest!\n");
-		return KXTJ2_1009_SUCCESS;
-	}
-
-	if(hwmsen_read_block(client, addr, databuf, 0x01))
-	{
-		GSE_ERR("read power ctl register err!\n");
-		return KXTJ2_1009_ERR_I2C;
-	}
-
-	
-	if(enable == TRUE)
-	{
-		databuf[0] |= KXTJ2_1009_MEASURE_MODE;
-	}
-	else
-	{
-		databuf[0] &= ~KXTJ2_1009_MEASURE_MODE;
-	}
-	databuf[1] = databuf[0];
-	databuf[0] = KXTJ2_1009_REG_POWER_CTL;
-	
-
-	res = i2c_master_send(client, databuf, 0x2);
-
-	if(res <= 0)
-	{
-		return KXTJ2_1009_ERR_I2C;
-	}
-
-
-	GSE_LOG("KXTJ2_1009_SetPowerMode %d!\n ",enable);
-
-
-	sensor_power = enable;
-
-	mdelay(5);
-	
-	return KXTJ2_1009_SUCCESS;    
-}
-/*----------------------------------------------------------------------------*/
-static int KXTJ2_1009_SetDataFormat(struct i2c_client *client, u8 dataformat)
-{
-	struct kxtj2_1009_i2c_data *obj = i2c_get_clientdata(client);
-	u8 databuf[10];    
-	int res = 0;
-
-	memset(databuf, 0, sizeof(u8)*10);  
-
-	KXTJ2_1009_SetPowerMode(client, false);
-
-	if(hwmsen_read_block(client, KXTJ2_1009_REG_DATA_FORMAT, databuf, 0x01))
-	{
-		printk("kxtj2_1009 read Dataformat failt \n");
-		return KXTJ2_1009_ERR_I2C;
-	}
-
-	databuf[0] &= ~KXTJ2_1009_RANGE_MASK;
-	databuf[0] |= dataformat;
-	databuf[1] = databuf[0];
-	databuf[0] = KXTJ2_1009_REG_DATA_FORMAT;
-
-
-	res = i2c_master_send(client, databuf, 0x2);
-
-	if(res <= 0)
-	{
-		return KXTJ2_1009_ERR_I2C;
-	}
-
-	KXTJ2_1009_SetPowerMode(client, true);
-	
-	printk("KXTJ2_1009_SetDataFormat OK! \n");
-	
-
-	return KXTJ2_1009_SetDataResolution(obj);    
-}
-/*----------------------------------------------------------------------------*/
-static int KXTJ2_1009_SetBWRate(struct i2c_client *client, u8 bwrate)
-{
-	u8 databuf[10];    
-	int res = 0;
-
-	memset(databuf, 0, sizeof(u8)*10);    
-
-	
-	KXTJ2_1009_SetPowerMode(client, false);
-
-	if(hwmsen_read_block(client, KXTJ2_1009_REG_BW_RATE, databuf, 0x01))
-	{
-		printk("kxtj2_1009 read rate failt \n");
-		return KXTJ2_1009_ERR_I2C;
-	}
-
-	databuf[0] &= 0xf0;
-	databuf[0] |= bwrate;
-	databuf[1] = databuf[0];
-	databuf[0] = KXTJ2_1009_REG_BW_RATE;
-
-
-	res = i2c_master_send(client, databuf, 0x2);
-
-	if(res <= 0)
-	{
-		return KXTJ2_1009_ERR_I2C;
-	}
-
-	
-	KXTJ2_1009_SetPowerMode(client, true);
-	printk("KXTJ2_1009_SetBWRate OK! \n");
-	
-	return KXTJ2_1009_SUCCESS;    
-}
-/*----------------------------------------------------------------------------*/
-static int KXTJ2_1009_SetIntEnable(struct i2c_client *client, u8 intenable)
-{
-	u8 databuf[10];    
-	int res = 0;
-
-	memset(databuf, 0, sizeof(u8)*10);    
-	databuf[0] = KXTJ2_1009_REG_INT_ENABLE;    
-	databuf[1] = 0x00;
-
-	res = i2c_master_send(client, databuf, 0x2);
-
-	if(res <= 0)
-	{
-		return KXTJ2_1009_ERR_I2C;
-	}
-	
-	return KXTJ2_1009_SUCCESS;    
-}
-/*----------------------------------------------------------------------------*/
-static int kxtj2_1009_init_client(struct i2c_client *client, int reset_cali)
-{
-	struct kxtj2_1009_i2c_data *obj = i2c_get_clientdata(client);
-	int res = 0;
-
-	printk("jeff kxtj2_1009_init_client begin\n");
-
-	res = KXTJ2_1009_CheckDeviceID(client); 
-	if(res != KXTJ2_1009_SUCCESS)
-	{
-		GSE_ERR("KXTJ2_1009_CheckDeviceID failed  jeff err=%d\n", res);
-		return res;
-	}	
-
-	res = KXTJ2_1009_SetPowerMode(client, false);
-	if(res != KXTJ2_1009_SUCCESS)
-	{
-		GSE_ERR("KXTJ2_1009_SetPowerMode failed  jeff err=%d\n", res);
-		return res;
-	}
-	
-
-	res = KXTJ2_1009_SetBWRate(client, KXTJ2_1009_BW_100HZ);
-	if(res != KXTJ2_1009_SUCCESS ) //0x2C->BW=100Hz
-	{
-		GSE_ERR("KXTJ2_1009_SetBWRate failed  jeff err=%d\n", res);
-		return res;
-	}
-
-	res = KXTJ2_1009_SetDataFormat(client, KXTJ2_1009_RANGE_2G);
-	if(res != KXTJ2_1009_SUCCESS) //0x2C->BW=100Hz
-	{
-		GSE_ERR("KXTJ2_1009_SetDataFormat failed  jeff err=%d\n", res);
-		return res;
-	}
-
-	gsensor_gain.x = gsensor_gain.y = gsensor_gain.z = obj->reso->sensitivity;
-
-
-	res = KXTJ2_1009_SetIntEnable(client, 0x00);        
-	if(res != KXTJ2_1009_SUCCESS)//0x2E->0x80
-	{
-		GSE_ERR("KXTJ2_1009_SetIntEnable failed  jeff err=%d\n", res);
-		return res;
-	}
-
-	if(0 != reset_cali)
-	{ 
-		/*reset calibration only in power on*/
-		res = KXTJ2_1009_ResetCalibration(client);
-		if(res != KXTJ2_1009_SUCCESS)
-		{
-			GSE_ERR("KXTJ2_1009_ResetCalibration failed  jeff err=%d\n", res);
-			return res;
-		}
-	}
-	printk("kxtj2_1009_init_client OK!\n");
-#ifdef CONFIG_KXTJ2_1009_LOWPASS
-	memset(&obj->fir, 0x00, sizeof(obj->fir));  
-#endif
-
-	return KXTJ2_1009_SUCCESS;
-}
-/*----------------------------------------------------------------------------*/
-static int KXTJ2_1009_ReadChipInfo(struct i2c_client *client, char *buf, int bufsize)
-{
-	u8 databuf[10];    
-
-	memset(databuf, 0, sizeof(u8)*10);
-
-	if((NULL == buf)||(bufsize<=30))
-	{
-		return -1;
-	}
-	
-	if(NULL == client)
-	{
-		*buf = 0;
-		return -2;
-	}
-
-	sprintf(buf, "KXTJ2_1009 Chip");
-	return 0;
-}
-/*----------------------------------------------------------------------------*/
-static int KXTJ2_1009_ReadSensorData(struct i2c_client *client, char *buf, int bufsize)
-{
-	struct kxtj2_1009_i2c_data *obj = (struct kxtj2_1009_i2c_data*)i2c_get_clientdata(client);
-	u8 databuf[20];
-	int acc[KXTJ2_1009_AXES_NUM];
-	int res = 0;
-	memset(databuf, 0, sizeof(u8)*10);
-
-	if(NULL == buf)
-	{
-		return -1;
-	}
-	if(NULL == client)
-	{
-		*buf = 0;
-		return -2;
-	}
-
-	if(sensor_power == FALSE)
-	{
-		res = KXTJ2_1009_SetPowerMode(client, true);
-		if(res)
-		{
-			GSE_ERR("Power on kxtj2_1009 error %d!\n", res);
-		}
-	}
-
-	if(res = KXTJ2_1009_ReadData(client, obj->data))
-	{        
-		GSE_ERR("I2C error: ret value=%d", res);
-		return -3;
-	}
-	else
-	{
-		//printk("raw data x=%d, y=%d, z=%d \n",obj->data[KXTJ2_1009_AXIS_X],obj->data[KXTJ2_1009_AXIS_Y],obj->data[KXTJ2_1009_AXIS_Z]);
-		obj->data[KXTJ2_1009_AXIS_X] += obj->cali_sw[KXTJ2_1009_AXIS_X];
-		obj->data[KXTJ2_1009_AXIS_Y] += obj->cali_sw[KXTJ2_1009_AXIS_Y];
-		obj->data[KXTJ2_1009_AXIS_Z] += obj->cali_sw[KXTJ2_1009_AXIS_Z];
-		
-		//printk("cali_sw x=%d, y=%d, z=%d \n",obj->cali_sw[KXTJ2_1009_AXIS_X],obj->cali_sw[KXTJ2_1009_AXIS_Y],obj->cali_sw[KXTJ2_1009_AXIS_Z]);
-		
-		/*remap coordinate*/
-		acc[obj->cvt.map[KXTJ2_1009_AXIS_X]] = obj->cvt.sign[KXTJ2_1009_AXIS_X]*obj->data[KXTJ2_1009_AXIS_X];
-		acc[obj->cvt.map[KXTJ2_1009_AXIS_Y]] = obj->cvt.sign[KXTJ2_1009_AXIS_Y]*obj->data[KXTJ2_1009_AXIS_Y];
-		acc[obj->cvt.map[KXTJ2_1009_AXIS_Z]] = obj->cvt.sign[KXTJ2_1009_AXIS_Z]*obj->data[KXTJ2_1009_AXIS_Z];
-		//printk("cvt x=%d, y=%d, z=%d \n",obj->cvt.sign[KXTJ2_1009_AXIS_X],obj->cvt.sign[KXTJ2_1009_AXIS_Y],obj->cvt.sign[KXTJ2_1009_AXIS_Z]);
-
-
-		//GSE_LOG("Mapped gsensor data: %d, %d, %d!\n", acc[KXTJ2_1009_AXIS_X], acc[KXTJ2_1009_AXIS_Y], acc[KXTJ2_1009_AXIS_Z]);
-
-		//Out put the mg
-		//printk("mg acc=%d, GRAVITY=%d, sensityvity=%d \n",acc[KXTJ2_1009_AXIS_X],GRAVITY_EARTH_1000,obj->reso->sensitivity);
-		acc[KXTJ2_1009_AXIS_X] = acc[KXTJ2_1009_AXIS_X] * GRAVITY_EARTH_1000 / obj->reso->sensitivity;
-		acc[KXTJ2_1009_AXIS_Y] = acc[KXTJ2_1009_AXIS_Y] * GRAVITY_EARTH_1000 / obj->reso->sensitivity;
-		acc[KXTJ2_1009_AXIS_Z] = acc[KXTJ2_1009_AXIS_Z] * GRAVITY_EARTH_1000 / obj->reso->sensitivity;		
-		
-	
-
-		sprintf(buf, "%04x %04x %04x", acc[KXTJ2_1009_AXIS_X], acc[KXTJ2_1009_AXIS_Y], acc[KXTJ2_1009_AXIS_Z]);
-		if(atomic_read(&obj->trace) & ADX_TRC_IOCTL)
-		{
-			GSE_LOG("gsensor data: %s!\n", buf);
-		}
-	}
-	
-	return 0;
-}
-/*----------------------------------------------------------------------------*/
-static int KXTJ2_1009_ReadRawData(struct i2c_client *client, char *buf)
-{
-	struct kxtj2_1009_i2c_data *obj = (struct kxtj2_1009_i2c_data*)i2c_get_clientdata(client);
-	int res = 0;
-
-	if (!buf || !client)
-	{
-		return EINVAL;
-	}
-	
-	if(res = KXTJ2_1009_ReadData(client, obj->data))
-	{        
-		GSE_ERR("I2C error: ret value=%d", res);
-		return EIO;
-	}
-	else
-	{
-		sprintf(buf, "KXTJ2_1009_ReadRawData %04x %04x %04x", obj->data[KXTJ2_1009_AXIS_X], 
-			obj->data[KXTJ2_1009_AXIS_Y], obj->data[KXTJ2_1009_AXIS_Z]);
-	
-	}
-	
-	return 0;
-}
-/*----------------------------------------------------------------------------*/
-static int KXTJ2_1009_InitSelfTest(struct i2c_client *client)
-{
-	int res = 0;
-	u8  data,result;
-	
-	res = hwmsen_read_byte(client, KXTJ2_1009_REG_CTL_REG3, &data);
-	if(res != KXTJ2_1009_SUCCESS)
-	{
-		return res;
-	}
-//enable selftest bit
-	res = hwmsen_write_byte(client, KXTJ2_1009_REG_CTL_REG3,  KXTJ2_1009_SELF_TEST|data);
-	if(res != KXTJ2_1009_SUCCESS) //0x2C->BW=100Hz
-	{
-		return res;
-	}
-//step 1
-	res = hwmsen_read_byte(client, KXTJ2_1009_DCST_RESP, &result);
-	if(res != KXTJ2_1009_SUCCESS)
-	{
-		return res;
-	}
-	printk("step1: result = %x",result);
-	if(result != 0xaa)
-		return -EINVAL;
-
-//step 2
-	res = hwmsen_write_byte(client, KXTJ2_1009_REG_CTL_REG3,  KXTJ2_1009_SELF_TEST|data);
-	if(res != KXTJ2_1009_SUCCESS) //0x2C->BW=100Hz
-	{
-		return res;
-	}
-//step 3
-	res = hwmsen_read_byte(client, KXTJ2_1009_DCST_RESP, &result);
-	if(res != KXTJ2_1009_SUCCESS)
-	{
-		return res;
-	}
-	printk("step3: result = %x",result);
-	if(result != 0xAA)
-		return -EINVAL;
-		
-//step 4
-	res = hwmsen_read_byte(client, KXTJ2_1009_DCST_RESP, &result);
-	if(res != KXTJ2_1009_SUCCESS)
-	{
-		return res;
-	}
-	printk("step4: result = %x",result);
-	if(result != 0x55)
-		return -EINVAL;
-	else
-		return KXTJ2_1009_SUCCESS;
-}
-/*----------------------------------------------------------------------------*/
-static int KXTJ2_1009_JudgeTestResult(struct i2c_client *client, s32 prv[KXTJ2_1009_AXES_NUM], s32 nxt[KXTJ2_1009_AXES_NUM])
-{
-
-    int res=0;
-	u8 test_result=0;
-    if(res = hwmsen_read_byte(client, 0x0c, &test_result))
-        return res;
-
-	printk("test_result = %x \n",test_result);
-    if ( test_result != 0xaa ) 
-	{
-        GSE_ERR("KXTJ2_1009_JudgeTestResult failt\n");
-        res = -EINVAL;
-    }
-    return res;
-}
-/*----------------------------------------------------------------------------*/
-static ssize_t show_chipinfo_value(struct device_driver *ddri, char *buf)
-{
-	struct i2c_client *client = kxtj2_1009_i2c_client;
-	char strbuf[KXTJ2_1009_BUFSIZE];
-	if(NULL == client)
-	{
-		GSE_ERR("i2c client is null!!\n");
-		return 0;
-	}
-	
-	KXTJ2_1009_ReadChipInfo(client, strbuf, KXTJ2_1009_BUFSIZE);
-	return snprintf(buf, PAGE_SIZE, "%s\n", strbuf);        
-}
-
-static ssize_t gsensor_init(struct device_driver *ddri, char *buf, size_t count)
-	{
-		struct i2c_client *client = kxtj2_1009_i2c_client;
-		char strbuf[KXTJ2_1009_BUFSIZE];
-		
-		if(NULL == client)
-		{
-			GSE_ERR("i2c client is null!!\n");
-			return 0;
-		}
-		kxtj2_1009_init_client(client, 1);
-		return snprintf(buf, PAGE_SIZE, "%s\n", strbuf);			
-	}
-
-
-
-/*----------------------------------------------------------------------------*/
-static ssize_t show_sensordata_value(struct device_driver *ddri, char *buf)
-{
-	struct i2c_client *client = kxtj2_1009_i2c_client;
-	char strbuf[KXTJ2_1009_BUFSIZE];
-	
-	if(NULL == client)
-	{
-		GSE_ERR("i2c client is null!!\n");
-		return 0;
-	}
-	KXTJ2_1009_ReadSensorData(client, strbuf, KXTJ2_1009_BUFSIZE);
-	//KXTJ2_1009_ReadRawData(client, strbuf);
-	return snprintf(buf, PAGE_SIZE, "%s\n", strbuf);            
-}
-
-static ssize_t show_sensorrawdata_value(struct device_driver *ddri, char *buf, size_t count)
-	{
-		struct i2c_client *client = kxtj2_1009_i2c_client;
-		char strbuf[KXTJ2_1009_BUFSIZE];
-		
-		if(NULL == client)
-		{
-			GSE_ERR("i2c client is null!!\n");
-			return 0;
-		}
-		//KXTJ2_1009_ReadSensorData(client, strbuf, KXTJ2_1009_BUFSIZE);
-		KXTJ2_1009_ReadRawData(client, strbuf);
-		return snprintf(buf, PAGE_SIZE, "%s\n", strbuf);			
-	}
-
-/*----------------------------------------------------------------------------*/
-static ssize_t show_cali_value(struct device_driver *ddri, char *buf)
-{
-	struct i2c_client *client = kxtj2_1009_i2c_client;
-	struct kxtj2_1009_i2c_data *obj;
-	int err, len = 0, mul;
-	int tmp[KXTJ2_1009_AXES_NUM];
-
-	if(NULL == client)
-	{
-		GSE_ERR("i2c client is null!!\n");
-		return 0;
-	}
-
-	obj = i2c_get_clientdata(client);
-
-
-
-	if(err = KXTJ2_1009_ReadOffset(client, obj->offset))
-	{
-		return -EINVAL;
-	}
-	else if(err = KXTJ2_1009_ReadCalibration(client, tmp))
-	{
-		return -EINVAL;
-	}
-	else
-	{    
-		mul = obj->reso->sensitivity/kxtj2_1009_offset_resolution.sensitivity;
-		len += snprintf(buf+len, PAGE_SIZE-len, "[HW ][%d] (%+3d, %+3d, %+3d) : (0x%02X, 0x%02X, 0x%02X)\n", mul,                        
-			obj->offset[KXTJ2_1009_AXIS_X], obj->offset[KXTJ2_1009_AXIS_Y], obj->offset[KXTJ2_1009_AXIS_Z],
-			obj->offset[KXTJ2_1009_AXIS_X], obj->offset[KXTJ2_1009_AXIS_Y], obj->offset[KXTJ2_1009_AXIS_Z]);
-		len += snprintf(buf+len, PAGE_SIZE-len, "[SW ][%d] (%+3d, %+3d, %+3d)\n", 1, 
-			obj->cali_sw[KXTJ2_1009_AXIS_X], obj->cali_sw[KXTJ2_1009_AXIS_Y], obj->cali_sw[KXTJ2_1009_AXIS_Z]);
-
-		len += snprintf(buf+len, PAGE_SIZE-len, "[ALL]    (%+3d, %+3d, %+3d) : (%+3d, %+3d, %+3d)\n", 
-			obj->offset[KXTJ2_1009_AXIS_X]*mul + obj->cali_sw[KXTJ2_1009_AXIS_X],
-			obj->offset[KXTJ2_1009_AXIS_Y]*mul + obj->cali_sw[KXTJ2_1009_AXIS_Y],
-			obj->offset[KXTJ2_1009_AXIS_Z]*mul + obj->cali_sw[KXTJ2_1009_AXIS_Z],
-			tmp[KXTJ2_1009_AXIS_X], tmp[KXTJ2_1009_AXIS_Y], tmp[KXTJ2_1009_AXIS_Z]);
-		
-		return len;
-    }
-}
-/*----------------------------------------------------------------------------*/
-static ssize_t store_cali_value(struct device_driver *ddri, char *buf, size_t count)
-{
-	struct i2c_client *client = kxtj2_1009_i2c_client;  
-	int err, x, y, z;
-	int dat[KXTJ2_1009_AXES_NUM];
-
-	if(!strncmp(buf, "rst", 3))
-	{
-		if(err = KXTJ2_1009_ResetCalibration(client))
-		{
-			GSE_ERR("reset offset err = %d\n", err);
-		}	
-	}
-	else if(3 == sscanf(buf, "0x%02X 0x%02X 0x%02X", &x, &y, &z))
-	{
-		dat[KXTJ2_1009_AXIS_X] = x;
-		dat[KXTJ2_1009_AXIS_Y] = y;
-		dat[KXTJ2_1009_AXIS_Z] = z;
-		if(err = KXTJ2_1009_WriteCalibration(client, dat))
-		{
-			GSE_ERR("write calibration err = %d\n", err);
-		}		
-	}
-	else
-	{
-		GSE_ERR("invalid format\n");
-	}
-	
-	return count;
-}
-/*----------------------------------------------------------------------------*/
-static ssize_t show_self_value(struct device_driver *ddri, char *buf)
-{
-	struct i2c_client *client = kxtj2_1009_i2c_client;
-	struct kxtj2_1009_i2c_data *obj;
-
-	if(NULL == client)
-	{
-		GSE_ERR("i2c client is null!!\n");
-		return 0;
-	}
-
-	//obj = i2c_get_clientdata(client);
-	
-    return snprintf(buf, 8, "%s\n", selftestRes);
-}
-/*----------------------------------------------------------------------------*/
-static ssize_t store_self_value(struct device_driver *ddri, char *buf, size_t count)
-{   /*write anything to this register will trigger the process*/
-	struct item{
-	s16 raw[KXTJ2_1009_AXES_NUM];
-	};
-	
-	struct i2c_client *client = kxtj2_1009_i2c_client;  
-	int idx, res, num;
-	struct item *prv = NULL, *nxt = NULL;
-	s32 avg_prv[KXTJ2_1009_AXES_NUM] = {0, 0, 0};
-	s32 avg_nxt[KXTJ2_1009_AXES_NUM] = {0, 0, 0};
-	u8 data;
-
-
-	if(1 != sscanf(buf, "%d", &num))
-	{
-		GSE_ERR("parse number fail\n");
-		return count;
-	}
-	else if(num == 0)
-	{
-		GSE_ERR("invalid data count\n");
-		return count;
-	}
-
-	prv = kzalloc(sizeof(*prv) * num, GFP_KERNEL);
-	nxt = kzalloc(sizeof(*nxt) * num, GFP_KERNEL);
-	if (!prv || !nxt)
-	{
-		goto exit;
-	}
-
-
-	GSE_LOG("NORMAL:\n");
-	KXTJ2_1009_SetPowerMode(client,true); 
-
-	/*initial setting for self test*/
-	if(!KXTJ2_1009_InitSelfTest(client))
-	{
-		GSE_LOG("SELFTEST : PASS\n");
-		strcpy(selftestRes,"y");
-	}	
-	else
-	{
-		GSE_LOG("SELFTEST : FAIL\n");		
-		strcpy(selftestRes,"n");
-	}
-
-	res = hwmsen_read_byte(client, KXTJ2_1009_REG_CTL_REG3, &data);
-	if(res != KXTJ2_1009_SUCCESS)
-	{
-		return res;
-	}
-
-	res = hwmsen_write_byte(client, KXTJ2_1009_REG_CTL_REG3,  ~KXTJ2_1009_SELF_TEST&data);
-	if(res != KXTJ2_1009_SUCCESS) //0x2C->BW=100Hz
-	{
-		return res;
-	}
-	
-	exit:
-	/*restore the setting*/    
-	kxtj2_1009_init_client(client, 0);
-	kfree(prv);
-	kfree(nxt);
-	return count;
-}
-/*----------------------------------------------------------------------------*/
-static ssize_t show_selftest_value(struct device_driver *ddri, char *buf)
-{
-	struct i2c_client *client = kxtj2_1009_i2c_client;
-	struct kxtj2_1009_i2c_data *obj;
-
-	if(NULL == client)
-	{
-		GSE_ERR("i2c client is null!!\n");
-		return 0;
-	}
-
-	obj = i2c_get_clientdata(client);
-	return snprintf(buf, PAGE_SIZE, "%d\n", atomic_read(&obj->selftest));
-}
-/*----------------------------------------------------------------------------*/
-static ssize_t store_selftest_value(struct device_driver *ddri, char *buf, size_t count)
-{
-	struct kxtj2_1009_i2c_data *obj = obj_i2c_data;
-	int tmp;
-
-	if(NULL == obj)
-	{
-		GSE_ERR("i2c data obj is null!!\n");
-		return 0;
-	}
-	
-	
-	if(1 == sscanf(buf, "%d", &tmp))
-	{        
-		if(atomic_read(&obj->selftest) && !tmp)
-		{
-			/*enable -> disable*/
-			kxtj2_1009_init_client(obj->client, 0);
-		}
-		else if(!atomic_read(&obj->selftest) && tmp)
-		{
-			/*disable -> enable*/
-			KXTJ2_1009_InitSelfTest(obj->client);            
-		}
-		
-		GSE_LOG("selftest: %d => %d\n", atomic_read(&obj->selftest), tmp);
-		atomic_set(&obj->selftest, tmp); 
-	}
-	else
-	{ 
-		GSE_ERR("invalid content: '%s', length = %d\n", buf, count);   
-	}
-	return count;
-}
-/*----------------------------------------------------------------------------*/
-static ssize_t show_firlen_value(struct device_driver *ddri, char *buf)
-{
-#ifdef CONFIG_KXTJ2_1009_LOWPASS
-	struct i2c_client *client = kxtj2_1009_i2c_client;
-	struct kxtj2_1009_i2c_data *obj = i2c_get_clientdata(client);
-	if(atomic_read(&obj->firlen))
-	{
-		int idx, len = atomic_read(&obj->firlen);
-		GSE_LOG("len = %2d, idx = %2d\n", obj->fir.num, obj->fir.idx);
-
-		for(idx = 0; idx < len; idx++)
-		{
-			GSE_LOG("[%5d %5d %5d]\n", obj->fir.raw[idx][KXTJ2_1009_AXIS_X], obj->fir.raw[idx][KXTJ2_1009_AXIS_Y], obj->fir.raw[idx][KXTJ2_1009_AXIS_Z]);
-		}
-		
-		GSE_LOG("sum = [%5d %5d %5d]\n", obj->fir.sum[KXTJ2_1009_AXIS_X], obj->fir.sum[KXTJ2_1009_AXIS_Y], obj->fir.sum[KXTJ2_1009_AXIS_Z]);
-		GSE_LOG("avg = [%5d %5d %5d]\n", obj->fir.sum[KXTJ2_1009_AXIS_X]/len, obj->fir.sum[KXTJ2_1009_AXIS_Y]/len, obj->fir.sum[KXTJ2_1009_AXIS_Z]/len);
-	}
-	return snprintf(buf, PAGE_SIZE, "%d\n", atomic_read(&obj->firlen));
-#else
-	return snprintf(buf, PAGE_SIZE, "not support\n");
-#endif
-}
-/*----------------------------------------------------------------------------*/
-static ssize_t store_firlen_value(struct device_driver *ddri, char *buf, size_t count)
-{
-#ifdef CONFIG_KXTJ2_1009_LOWPASS
-	struct i2c_client *client = kxtj2_1009_i2c_client;  
-	struct kxtj2_1009_i2c_data *obj = i2c_get_clientdata(client);
-	int firlen;
-
-	if(1 != sscanf(buf, "%d", &firlen))
-	{
-		GSE_ERR("invallid format\n");
-	}
-	else if(firlen > C_MAX_FIR_LENGTH)
-	{
-		GSE_ERR("exceeds maximum filter length\n");
-	}
-	else
-	{ 
-		atomic_set(&obj->firlen, firlen);
-		if(NULL == firlen)
-		{
-			atomic_set(&obj->fir_en, 0);
-		}
-		else
-		{
-			memset(&obj->fir, 0x00, sizeof(obj->fir));
-			atomic_set(&obj->fir_en, 1);
-		}
-	}
-#endif    
-	return count;
-}
-/*----------------------------------------------------------------------------*/
-static ssize_t show_trace_value(struct device_driver *ddri, char *buf)
-{
-	ssize_t res;
-	struct kxtj2_1009_i2c_data *obj = obj_i2c_data;
-	if (obj == NULL)
-	{
-		GSE_ERR("i2c_data obj is null!!\n");
-		return 0;
-	}
-	
-	res = snprintf(buf, PAGE_SIZE, "0x%04X\n", atomic_read(&obj->trace));     
-	return res;    
-}
-/*----------------------------------------------------------------------------*/
-static ssize_t store_trace_value(struct device_driver *ddri, char *buf, size_t count)
-{
-	struct kxtj2_1009_i2c_data *obj = obj_i2c_data;
-	int trace;
-	if (obj == NULL)
-	{
-		GSE_ERR("i2c_data obj is null!!\n");
-		return 0;
-	}
-	
-	if(1 == sscanf(buf, "0x%x", &trace))
-	{
-		atomic_set(&obj->trace, trace);
-	}	
-	else
-	{
-		GSE_ERR("invalid content: '%s', length = %d\n", buf, count);
-	}
-	
-	return count;    
-}
-/*----------------------------------------------------------------------------*/
-static ssize_t show_status_value(struct device_driver *ddri, char *buf)
-{
-	ssize_t len = 0;    
-	struct kxtj2_1009_i2c_data *obj = obj_i2c_data;
-	if (obj == NULL)
-	{
-		GSE_ERR("i2c_data obj is null!!\n");
-		return 0;
-	}	
-	
-	if(obj->hw)
-	{
-		len += snprintf(buf+len, PAGE_SIZE-len, "CUST: %d %d (%d %d)\n", 
-	            obj->hw->i2c_num, obj->hw->direction, obj->hw->power_id, obj->hw->power_vol);   
-	}
-	else
-	{
-		len += snprintf(buf+len, PAGE_SIZE-len, "CUST: NULL\n");
-	}
-	return len;    
-}
-/*----------------------------------------------------------------------------*/
-static ssize_t show_power_status_value(struct device_driver *ddri, char *buf)
-{
-	if(sensor_power)
-		printk("G sensor is in work mode, sensor_power = %d\n", sensor_power);
-	else
-		printk("G sensor is in standby mode, sensor_power = %d\n", sensor_power);
-
-	return 0;
-}
-
-/*----------------------------------------------------------------------------*/
-static DRIVER_ATTR(chipinfo,   S_IWUSR | S_IRUGO, show_chipinfo_value,      NULL);
-static DRIVER_ATTR(sensordata, S_IWUSR | S_IRUGO, show_sensordata_value,    NULL);
-static DRIVER_ATTR(cali,       S_IWUSR | S_IRUGO, show_cali_value,          store_cali_value);
-static DRIVER_ATTR(selftest, S_IWUSR | S_IRUGO, show_self_value,  store_self_value);
-static DRIVER_ATTR(self,   S_IWUSR | S_IRUGO, show_selftest_value,      store_selftest_value);
-static DRIVER_ATTR(firlen,     S_IWUSR | S_IRUGO, show_firlen_value,        store_firlen_value);
-static DRIVER_ATTR(trace,      S_IWUSR | S_IRUGO, show_trace_value,         store_trace_value);
-static DRIVER_ATTR(status,               S_IRUGO, show_status_value,        NULL);
-static DRIVER_ATTR(powerstatus,               S_IRUGO, show_power_status_value,        NULL);
-
-
-/*----------------------------------------------------------------------------*/
-static u8 i2c_dev_reg =0 ;
-
-static ssize_t show_register(struct device_driver *pdri, char *buf)
-{
-	int input_value;
-		
-	printk("i2c_dev_reg is 0x%2x \n", i2c_dev_reg);
-
-	return 0;
-}
-
-static ssize_t store_register(struct device_driver *ddri, char *buf, size_t count)
-{
-	unsigned long input_value;
-
-	i2c_dev_reg = simple_strtoul(buf, NULL, 16);
-	printk("set i2c_dev_reg = 0x%2x \n", i2c_dev_reg);
-
-	return 0;
-}
-static ssize_t store_register_value(struct device_driver *ddri, char *buf, size_t count)
-{
-	struct kxtj2_1009_i2c_data *obj = obj_i2c_data;
-	u8 databuf[2];  
-	unsigned long input_value;
-	int res;
-	
-	memset(databuf, 0, sizeof(u8)*2);    
-
-	input_value = simple_strtoul(buf, NULL, 16);
-	printk("input_value = 0x%2x \n", input_value);
-
-	if(NULL == obj)
-	{
-		GSE_ERR("i2c data obj is null!!\n");
-		return 0;
-	}
-
-	databuf[0] = i2c_dev_reg;
-	databuf[1] = input_value;
-	printk("databuf[0]=0x%2x  databuf[1]=0x%2x \n", databuf[0],databuf[1]);
-
-	res = i2c_master_send(obj->client, databuf, 0x2);
-
-	if(res <= 0)
-	{
-		return KXTJ2_1009_ERR_I2C;
-	}
-	return 0;
-	
-}
-
-static ssize_t show_register_value(struct device_driver *ddri, char *buf)
-{
-		struct kxtj2_1009_i2c_data *obj = obj_i2c_data;
-		u8 databuf[1];	
-		
-		memset(databuf, 0, sizeof(u8)*1);	 
-	
-		if(NULL == obj)
-		{
-			GSE_ERR("i2c data obj is null!!\n");
-			return 0;
-		}
-		
-		if(hwmsen_read_block(obj->client, i2c_dev_reg, databuf, 0x01))
-		{
-			GSE_ERR("read power ctl register err!\n");
-			return KXTJ2_1009_ERR_I2C;
-		}
-
-		printk("i2c_dev_reg=0x%2x  data=0x%2x \n", i2c_dev_reg,databuf[0]);
-	
-		return 0;
-		
-}
-
-
-static DRIVER_ATTR(i2c,      S_IWUSR | S_IRUGO, show_register_value,         store_register_value);
-static DRIVER_ATTR(register,      S_IWUSR | S_IRUGO, show_register,         store_register);
-
-
-/*----------------------------------------------------------------------------*/
-static struct driver_attribute *kxtj2_1009_attr_list[] = {
-	&driver_attr_chipinfo,     /*chip information*/
-	&driver_attr_sensordata,   /*dump sensor data*/
-	&driver_attr_cali,         /*show calibration data*/
-	&driver_attr_self,         /*self test demo*/
-	&driver_attr_selftest,     /*self control: 0: disable, 1: enable*/
-	&driver_attr_firlen,       /*filter length: 0: disable, others: enable*/
-	&driver_attr_trace,        /*trace log*/
-	&driver_attr_status,
-	&driver_attr_powerstatus,
-	&driver_attr_register,
-	&driver_attr_i2c,
-};
-/*----------------------------------------------------------------------------*/
-static int kxtj2_1009_create_attr(struct device_driver *driver) 
-{
-	int idx, err = 0;
-	int num = (int)(sizeof(kxtj2_1009_attr_list)/sizeof(kxtj2_1009_attr_list[0]));
-	if (driver == NULL)
-	{
-		return -EINVAL;
-	}
-
-	for(idx = 0; idx < num; idx++)
-	{
-		if(err = driver_create_file(driver, kxtj2_1009_attr_list[idx]))
-		{            
-			GSE_ERR("driver_create_file (%s) = %d\n", kxtj2_1009_attr_list[idx]->attr.name, err);
-			break;
-		}
-	}    
-	return err;
-}
-/*----------------------------------------------------------------------------*/
-static int kxtj2_1009_delete_attr(struct device_driver *driver)
-{
-	int idx ,err = 0;
-	int num = (int)(sizeof(kxtj2_1009_attr_list)/sizeof(kxtj2_1009_attr_list[0]));
-
-	if(driver == NULL)
-	{
-		return -EINVAL;
-	}
-	
-
-	for(idx = 0; idx < num; idx++)
-	{
-		driver_remove_file(driver, kxtj2_1009_attr_list[idx]);
-	}
-	
-
-	return err;
-}
-
-/*----------------------------------------------------------------------------*/
-//jeff modify fun name 20130926
-int kxtj2_1009_operate(void* self, uint32_t command, void* buff_in, int size_in,
-		void* buff_out, int size_out, int* actualout)
-{
-	int err = 0;
-	int value, sample_delay;	
-	struct kxtj2_1009_i2c_data *priv = (struct kxtj2_1009_i2c_data*)self;
-	hwm_sensor_data* gsensor_data;
-	char buff[KXTJ2_1009_BUFSIZE];
-	
-	//GSE_FUN(f);
-	switch (command)
-	{
-		case SENSOR_DELAY:
-			if((buff_in == NULL) || (size_in < sizeof(int)))
-			{
-				GSE_ERR("Set delay parameter error!\n");
-				err = -EINVAL;
-			}
-			else
-			{
-				value = *(int *)buff_in;
-				if(value <= 5)
-				{
-					sample_delay = KXTJ2_1009_BW_200HZ;
-				}
-				else if(value <= 10)
-				{
-					sample_delay = KXTJ2_1009_BW_100HZ;
-				}
-				else
-				{
-					sample_delay = KXTJ2_1009_BW_50HZ;
-				}
-				
-				err = KXTJ2_1009_SetBWRate(priv->client, sample_delay);
-				if(err != KXTJ2_1009_SUCCESS ) //0x2C->BW=100Hz
-				{
-					GSE_ERR("Set delay parameter error!\n");
-				}
-
-				if(value >= 50)
-				{
-					atomic_set(&priv->filter, 0);
-				}
-				else
-				{	
-				#if defined(CONFIG_KXTJ2_1009_LOWPASS)
-					priv->fir.num = 0;
-					priv->fir.idx = 0;
-					priv->fir.sum[KXTJ2_1009_AXIS_X] = 0;
-					priv->fir.sum[KXTJ2_1009_AXIS_Y] = 0;
-					priv->fir.sum[KXTJ2_1009_AXIS_Z] = 0;
-					atomic_set(&priv->filter, 1);
-				#endif
-				}
-			}
-			break;
-
-		case SENSOR_ENABLE:
-			if((buff_in == NULL) || (size_in < sizeof(int)))
-			{
-				GSE_ERR("Enable sensor parameter error!\n");
-				err = -EINVAL;
-			}
-			else
-			{
-				value = *(int *)buff_in;
-				if(((value == 0) && (sensor_power == false)) ||((value == 1) && (sensor_power == true)))
-				{
-					GSE_LOG("Gsensor device have updated!\n");
-				}
-				else
-				{
-					err = KXTJ2_1009_SetPowerMode( priv->client, !sensor_power);
-				}
-			}
-			break;
-
-		case SENSOR_GET_DATA:
-			if((buff_out == NULL) || (size_out< sizeof(hwm_sensor_data)))
-			{
-				GSE_ERR("get sensor data parameter error!\n");
-				err = -EINVAL;
-			}
-			else
-			{
-				gsensor_data = (hwm_sensor_data *)buff_out;
-				KXTJ2_1009_ReadSensorData(priv->client, buff, KXTJ2_1009_BUFSIZE);
-				sscanf(buff, "%x %x %x", &gsensor_data->values[0], 
-					&gsensor_data->values[1], &gsensor_data->values[2]);				
-				gsensor_data->status = SENSOR_STATUS_ACCURACY_MEDIUM;				
-				gsensor_data->value_divide = 1000;
-			//	printk("kxtj2_1009 x=%d, y=%d, z=%d.\n",gsensor_data->values[0], 
-			//		gsensor_data->values[1], gsensor_data->values[2]);	//jeff add 20131017
-			}
-			break;
-		default:
-			GSE_ERR("gsensor operate function no this parameter %d!\n", command);
-			err = -1;
-			break;
-	}
-	
-	return err;
-}
-
-/****************************************************************************** 
- * Function Configuration
-******************************************************************************/
-static int kxtj2_1009_open(struct inode *inode, struct file *file)
-{
-	file->private_data = kxtj2_1009_i2c_client;
-
-	if(file->private_data == NULL)
-	{
-		GSE_ERR("null pointer!!\n");
-		return -EINVAL;
-	}
-	return nonseekable_open(inode, file);
-}
-/*----------------------------------------------------------------------------*/
-static int kxtj2_1009_release(struct inode *inode, struct file *file)
-{
-	file->private_data = NULL;
-	return 0;
-}
-/*----------------------------------------------------------------------------*/
-//static int kxtj2_1009_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
-//       unsigned long arg)
-static long kxtj2_1009_unlocked_ioctl(struct file *file, unsigned int cmd,unsigned long arg)
-{
-	struct i2c_client *client = (struct i2c_client*)file->private_data;
-	struct kxtj2_1009_i2c_data *obj = (struct kxtj2_1009_i2c_data*)i2c_get_clientdata(client);	
-	char strbuf[KXTJ2_1009_BUFSIZE];
-	void __user *data;
-	SENSOR_DATA sensor_data;
-	long err = 0;
-	int cali[3];
-
-	//GSE_FUN(f);
-	if(_IOC_DIR(cmd) & _IOC_READ)
-	{
-		err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
-	}
-	else if(_IOC_DIR(cmd) & _IOC_WRITE)
-	{
-		err = !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
-	}
-
-	if(err)
-	{
-		GSE_ERR("access error: %08X, (%2d, %2d)\n", cmd, _IOC_DIR(cmd), _IOC_SIZE(cmd));
-		return -EFAULT;
-	}
-
-	switch(cmd)
-	{
-		case GSENSOR_IOCTL_INIT:
-			kxtj2_1009_init_client(client, 0);			
-			break;
-
-		case GSENSOR_IOCTL_READ_CHIPINFO:
-			data = (void __user *) arg;
-			if(data == NULL)
-			{
-				err = -EINVAL;
-				break;	  
-			}
-			
-			KXTJ2_1009_ReadChipInfo(client, strbuf, KXTJ2_1009_BUFSIZE);
-			if(copy_to_user(data, strbuf, strlen(strbuf)+1))
-			{
-				err = -EFAULT;
-				break;
-			}				 
-			break;	  
-
-		case GSENSOR_IOCTL_READ_SENSORDATA:
-			data = (void __user *) arg;
-			if(data == NULL)
-			{
-				err = -EINVAL;
-				break;	  
-			}
-			
-			KXTJ2_1009_ReadSensorData(client, strbuf, KXTJ2_1009_BUFSIZE);
-			if(copy_to_user(data, strbuf, strlen(strbuf)+1))
-			{
-				err = -EFAULT;
-				break;	  
-			}				 
-			break;
-
-		case GSENSOR_IOCTL_READ_GAIN:
-			data = (void __user *) arg;
-			if(data == NULL)
-			{
-				err = -EINVAL;
-				break;	  
-			}			
-			
-			if(copy_to_user(data, &gsensor_gain, sizeof(GSENSOR_VECTOR3D)))
-			{
-				err = -EFAULT;
-				break;
-			}				 
-			break;
-
-		case GSENSOR_IOCTL_READ_RAW_DATA:
-			data = (void __user *) arg;
-			if(data == NULL)
-			{
-				err = -EINVAL;
-				break;	  
-			}
-			KXTJ2_1009_ReadRawData(client, strbuf);
-			if(copy_to_user(data, &strbuf, strlen(strbuf)+1))
-			{
-				err = -EFAULT;
-				break;	  
-			}
-			break;	  
-
-		case GSENSOR_IOCTL_SET_CALI:
-			data = (void __user*)arg;
-			if(data == NULL)
-			{
-				err = -EINVAL;
-				break;	  
-			}
-			if(copy_from_user(&sensor_data, data, sizeof(sensor_data)))
-			{
-				err = -EFAULT;
-				break;	  
-			}
-			if(atomic_read(&obj->suspend))
-			{
-				GSE_ERR("Perform calibration in suspend state!!\n");
-				err = -EINVAL;
-			}
-			else
-			{
-				cali[KXTJ2_1009_AXIS_X] = sensor_data.x * obj->reso->sensitivity / GRAVITY_EARTH_1000;
-				cali[KXTJ2_1009_AXIS_Y] = sensor_data.y * obj->reso->sensitivity / GRAVITY_EARTH_1000;
-				cali[KXTJ2_1009_AXIS_Z] = sensor_data.z * obj->reso->sensitivity / GRAVITY_EARTH_1000;			  
-				err = KXTJ2_1009_WriteCalibration(client, cali);			 
-			}
-			break;
-
-		case GSENSOR_IOCTL_CLR_CALI:
-			err = KXTJ2_1009_ResetCalibration(client);
-			break;
-
-		case GSENSOR_IOCTL_GET_CALI:
-			data = (void __user*)arg;
-			if(data == NULL)
-			{
-				err = -EINVAL;
-				break;	  
-			}
-			if(err = KXTJ2_1009_ReadCalibration(client, cali))
-			{
-				break;
-			}
-			
-			sensor_data.x = cali[KXTJ2_1009_AXIS_X] * GRAVITY_EARTH_1000 / obj->reso->sensitivity;
-			sensor_data.y = cali[KXTJ2_1009_AXIS_Y] * GRAVITY_EARTH_1000 / obj->reso->sensitivity;
-			sensor_data.z = cali[KXTJ2_1009_AXIS_Z] * GRAVITY_EARTH_1000 / obj->reso->sensitivity;
-			if(copy_to_user(data, &sensor_data, sizeof(sensor_data)))
-			{
-				err = -EFAULT;
-				break;
-			}		
-			break;
-		
-
-		default:
-			GSE_ERR("unknown IOCTL: 0x%08x\n", cmd);
-			err = -ENOIOCTLCMD;
-			break;
-			
-	}
-
-	return err;
-}
- 
-
-/*----------------------------------------------------------------------------*/
-static struct file_operations kxtj2_1009_fops = {
-	.owner = THIS_MODULE,
-	.open = kxtj2_1009_open,
-	.release = kxtj2_1009_release,
-	.unlocked_ioctl = kxtj2_1009_unlocked_ioctl,
-	//.ioctl = kxtj2_1009_ioctl,
-};
-/*----------------------------------------------------------------------------*/
-static struct miscdevice kxtj2_1009_device = {
-	.minor = MISC_DYNAMIC_MINOR,
-	.name = "gsensor",
-	.fops = &kxtj2_1009_fops,
-};
-/*----------------------------------------------------------------------------*/
-#ifndef CONFIG_HAS_EARLYSUSPEND
-/*----------------------------------------------------------------------------*/
-static int kxtj2_1009_suspend(struct i2c_client *client, pm_message_t msg) 
-{
-	struct kxtj2_1009_i2c_data *obj = i2c_get_clientdata(client);    
-	int err = 0;
-	GSE_FUN();    
-
-	if(msg.event == PM_EVENT_SUSPEND)
-	{   
-		if(obj == NULL)
-		{
-			GSE_ERR("null pointer!!\n");
-			return -EINVAL;
-		}
-		atomic_set(&obj->suspend, 1);
-		if(err = KXTJ2_1009_SetPowerMode(obj->client, false))
-		{
-			GSE_ERR("write power control fail!!\n");
-			return;
-		}
-
-		sensor_power = false;      
-		KXTJ2_1009_power(obj->hw, 0);
-	}
-	return err;
-}
-/*----------------------------------------------------------------------------*/
-static int kxtj2_1009_resume(struct i2c_client *client)
-{
-	struct kxtj2_1009_i2c_data *obj = i2c_get_clientdata(client);        
-	int err;
-	GSE_FUN();
-
-	if(obj == NULL)
-	{
-		GSE_ERR("null pointer!!\n");
-		return -EINVAL;
-	}
-
-	KXTJ2_1009_power(obj->hw, 1);
-	if(err = kxtj2_1009_init_client(client, 0))
-	{
-		GSE_ERR("initialize client fail!!\n");
-		return err;        
-	}
-	atomic_set(&obj->suspend, 0);
-
-	return 0;
-}
-/*----------------------------------------------------------------------------*/
-#else /*CONFIG_HAS_EARLY_SUSPEND is defined*/
-/*----------------------------------------------------------------------------*/
-static void kxtj2_1009_early_suspend(struct early_suspend *h) 
-{
-	struct kxtj2_1009_i2c_data *obj = container_of(h, struct kxtj2_1009_i2c_data, early_drv);   
-	int err;
-	GSE_FUN();    
-
-	if(obj == NULL)
-	{
-		GSE_ERR("null pointer!!\n");
-		return;
-	}
-	atomic_set(&obj->suspend, 1); 
-	if(err = KXTJ2_1009_SetPowerMode(obj->client, false))
-	{
-		GSE_ERR("write power control fail!!\n");
-		return;
-	}
-
-	sensor_power = false;
-	
-	KXTJ2_1009_power(obj->hw, 0);
-}
-/*----------------------------------------------------------------------------*/
-static void kxtj2_1009_late_resume(struct early_suspend *h)
-{
-	struct kxtj2_1009_i2c_data *obj = container_of(h, struct kxtj2_1009_i2c_data, early_drv);         
-	int err;
-	GSE_FUN();
-
-	if(obj == NULL)
-	{
-		GSE_ERR("null pointer!!\n");
-		return;
-	}
-
-	KXTJ2_1009_power(obj->hw, 1);
-	if(err = kxtj2_1009_init_client(obj->client, 0))
-	{
-		GSE_ERR("initialize client fail!!\n");
-		return;        
-	}
-	atomic_set(&obj->suspend, 0);    
-}
-/*----------------------------------------------------------------------------*/
-#endif /*CONFIG_HAS_EARLYSUSPEND*/
-/*----------------------------------------------------------------------------*/
-/*		//jeff del 20130926
-static int kxtj2_1009_i2c_detect(struct i2c_client *client, int kind, struct i2c_board_info *info) 
-{    
-	strcpy(info->type, KXTJ2_1009_DEV_NAME);
-	return 0;
-}
-*/
-/*----------------------------------------------------------------------------*/
-static int kxtj2_1009_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
-{
-	struct i2c_client *new_client;
-	struct kxtj2_1009_i2c_data *obj;
-	struct hwmsen_object sobj;
-	int err = 0;
-	GSE_FUN();
-
-	if(!(obj = kzalloc(sizeof(*obj), GFP_KERNEL)))
-	{
-		err = -ENOMEM;
-		goto exit;
-	}
-	
-	memset(obj, 0, sizeof(struct kxtj2_1009_i2c_data));
-
-	obj->hw = kxtj2_1009_get_cust_acc_hw();
-	
-	if(err = hwmsen_get_convert(obj->hw->direction, &obj->cvt))
-	{
-		GSE_ERR("invalid direction: %d\n", obj->hw->direction);
-		goto exit;
-	}
-
-	printk("jeff kxtj2_1009_i2c_probe  1111\n");
-
-	obj_i2c_data = obj;
-	obj->client = client;
-	new_client = obj->client;
-	i2c_set_clientdata(new_client,obj);
-	
-	atomic_set(&obj->trace, 0);
-	atomic_set(&obj->suspend, 0);
-	
-#ifdef CONFIG_KXTJ2_1009_LOWPASS
-	if(obj->hw->firlen > C_MAX_FIR_LENGTH)
-	{
-		atomic_set(&obj->firlen, C_MAX_FIR_LENGTH);
-	}	
-	else
-	{
-		atomic_set(&obj->firlen, obj->hw->firlen);
-	}
-	
-	if(atomic_read(&obj->firlen) > 0)
-	{
-		atomic_set(&obj->fir_en, 1);
-	}
-	
-#endif
-	printk("jeff kxtj2_1009_i2c_probe  2222\n");
-
-	kxtj2_1009_i2c_client = new_client;	
-
-	if(err = kxtj2_1009_init_client(new_client, 1))
-	{
-		GSE_ERR("kxtj2_1009_init_client failed  jeff err=%d\n", err);
-		goto exit_init_failed;
-	}
-	
-
-	if(err = misc_register(&kxtj2_1009_device))
-	{
-		GSE_ERR("kxtj2_1009_device register failed\n");
-		goto exit_misc_device_register_failed;
-	}
-
-	if(err = kxtj2_1009_create_attr(&(kxtj2_1009_init_info.platform_diver_addr->driver)))		//jeff modify 20130926
-//	if(err = kxtj2_1009_create_attr(&kxtj2_1009_gsensor_driver.driver))
-	{
-		GSE_ERR("create attribute err = %d\n", err);
-		goto exit_create_attr_failed;
-	}
-
-	printk("jeff kxtj2_1009_i2c_probe  3333\n");
-
-	sobj.self = obj;
-    sobj.polling = 1;
-    sobj.sensor_operate = kxtj2_1009_operate;	//jeff modify fun name 20130926
-	if(err = hwmsen_attach(ID_ACCELEROMETER, &sobj))
-	{
-		GSE_ERR("attach fail = %d\n", err);
-		goto exit_kfree;
-	}
-
-#ifdef CONFIG_HAS_EARLYSUSPEND
-	obj->early_drv.level    = EARLY_SUSPEND_LEVEL_DISABLE_FB - 1,
-	obj->early_drv.suspend  = kxtj2_1009_early_suspend,
-	obj->early_drv.resume   = kxtj2_1009_late_resume,    
-	register_early_suspend(&obj->early_drv);
-#endif 
-
-	GSE_LOG("%s: OK\n", __func__);    
-	kxtj2_1009_init_flag = 0;	//jeff add 20131019
-	return 0;
-
-	exit_create_attr_failed:
-	misc_deregister(&kxtj2_1009_device);
-	exit_misc_device_register_failed:
-	exit_init_failed:
-	//i2c_detach_client(new_client);
-	exit_kfree:
-	kfree(obj);
-	exit:
-	GSE_ERR("%s: err = %d\n", __func__, err);  
-	kxtj2_1009_init_flag = -1;	//jeff add 20131019
-	return err;
-}
-
-/*----------------------------------------------------------------------------*/
-static int kxtj2_1009_i2c_remove(struct i2c_client *client)
-{
-	int err = 0;	
-
-	if(err = kxtj2_1009_delete_attr(&(kxtj2_1009_init_info.platform_diver_addr->driver)))	//jeff modify 20130926
-//	if(err = kxtj2_1009_delete_attr(&kxtj2_1009_gsensor_driver.driver))
-	{
-		GSE_ERR("kxtj2_1009_delete_attr fail: %d\n", err);
-	}
-	
-	if(err = misc_deregister(&kxtj2_1009_device))
-	{
-		GSE_ERR("misc_deregister fail: %d\n", err);
-	}
-
-	if(err = hwmsen_detach(ID_ACCELEROMETER))
-	    
-
-	kxtj2_1009_i2c_client = NULL;
-	i2c_unregister_device(client);
-	kfree(i2c_get_clientdata(client));
-	return 0;
-}
-
-//jeff add 20130926
-static int  kxtj2_1009_local_init(void)
-{
-    struct acc_hw *hw = kxtj2_1009_get_cust_acc_hw();
-    GSE_FUN();
-
-    KXTJ2_1009_power(hw, 1);
-//    AFA750_force[0] = hw->i2c_num;
-   if(i2c_add_driver(&kxtj2_1009_i2c_driver))
-    {
-        GSE_ERR("add driver error\n");
-        return -1;
-    }
-    if(-1 == kxtj2_1009_init_flag)		//jeff add 20131019)
-    {
-       return -1;
-    }
-    return 0;
-}
-
-
-/*----------------------------------------------------------------------------*/
-static int kxtj2_1009_probe(struct platform_device *pdev) 
-{
-	struct acc_hw *hw = kxtj2_1009_get_cust_acc_hw();
-	GSE_FUN();
-
-	KXTJ2_1009_power(hw, 1);
-	//kxtj2_1009_force[0] = hw->i2c_num;
-	if(i2c_add_driver(&kxtj2_1009_i2c_driver))
-	{
-		GSE_ERR("add driver error\n");
-		return -1;
-	}
-	return 0;
-}
-/*----------------------------------------------------------------------------*/
-static int kxtj2_1009_remove(struct platform_device *pdev)
-{
-    struct acc_hw *hw = kxtj2_1009_get_cust_acc_hw();
-
-    GSE_FUN();    
-    KXTJ2_1009_power(hw, 0);    
-    i2c_del_driver(&kxtj2_1009_i2c_driver);
-    return 0;
-}
-/*----------------------------------------------------------------------------*/
-static struct platform_driver kxtj2_1009_gsensor_driver = {
-	.probe      = kxtj2_1009_probe,
-	.remove     = kxtj2_1009_remove,    
-	.driver     = {
-		.name  = "gsensor",
-		.owner = THIS_MODULE,
-	}
-};
-
-/*----------------------------------------------------------------------------*/
-static int __init kxtj2_1009_init(void)
-{
-		struct acc_hw *hw = kxtj2_1009_get_cust_acc_hw();
-	GSE_FUN();
-//	i2c_register_board_info(0, &i2c_kxtj2_1009, 1);	//jeff modify mt6515  20131023
-	GSE_LOG("%s: i2c_number=%d\n", __func__,hw->i2c_num);		//jeff add  20131023
-	i2c_register_board_info(hw->i2c_num, &i2c_kxtj2_1009, 1);	//jeff add mt6572  20131023
-	hwmsen_gsensor_add(&kxtj2_1009_init_info);	//jeff add 20130926
-#if 0
-	if(platform_driver_register(&kxtj2_1009_gsensor_driver))
-	{
-		GSE_ERR("failed to register driver");
-		return -ENODEV;
-	}
-#endif
-	return 0;    
-}
-/*----------------------------------------------------------------------------*/
-static void __exit kxtj2_1009_exit(void)
-{
-	GSE_FUN();
-//	platform_driver_unregister(&kxtj2_1009_gsensor_driver);	//jeff del 20130927
-}
-/*----------------------------------------------------------------------------*/
-module_init(kxtj2_1009_init);
-module_exit(kxtj2_1009_exit);
-/*----------------------------------------------------------------------------*/
-MODULE_LICENSE("GPL");
-MODULE_DESCRIPTION("KXTJ2_1009 I2C driver");
-MODULE_AUTHOR("Dexiang.Liu@mediatek.com");
diff --git a/drivers/misc/mediatek/accelerometer/mc3xxx/mc3xxx.c~ b/drivers/misc/mediatek/accelerometer/mc3xxx/mc3xxx.c~
deleted file mode 100755
index 6a333c2..0000000
--- a/drivers/misc/mediatek/accelerometer/mc3xxx/mc3xxx.c~
+++ /dev/null
@@ -1,4105 +0,0 @@
-/*****************************************************************************
- *
- * Copyright (c) 2014 mCube, Inc.  All rights reserved.
- *
- * This source is subject to the mCube Software License.
- * This software is protected by Copyright and the information and source code
- * contained herein is confidential. The software including the source code
- * may not be copied and the information contained herein may not be used or
- * disclosed except with the written permission of mCube Inc.
- *
- * All other rights reserved.
- *
- * This code and information are provided "as is" without warranty of any
- * kind, either expressed or implied, including but not limited to the
- * implied warranties of merchantability and/or fitness for a
- * particular purpose.
- *
- * The following software/firmware and/or related documentation ("mCube Software")
- * have been modified by mCube Inc. All revisions are subject to any receiver's
- * applicable license agreements with mCube Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- *
- *****************************************************************************/
-
-/*****************************************************************************
- *** HEADER FILES
- *****************************************************************************/
-#include <linux/interrupt.h>
-#include <linux/i2c.h>
-#include <linux/slab.h>
-#include <linux/irq.h>
-#include <linux/miscdevice.h>
-#include <asm/uaccess.h>
-#include <linux/delay.h>
-#include <linux/input.h>
-#include <linux/workqueue.h>
-#include <linux/kobject.h>
-#include <linux/earlysuspend.h>
-#include <linux/platform_device.h>
-#include <asm/atomic.h>
-
-#ifdef MT6573
-#include <mach/mt6573_devs.h>
-#include <mach/mt6573_typedefs.h>
-#include <mach/mt6573_gpio.h>
-#include <mach/mt6573_pll.h>
-#endif
-
-#ifdef MT6575
-#include <mach/mt6575_devs.h>
-#include <mach/mt6575_typedefs.h>
-#include <mach/mt6575_gpio.h>
-#include <mach/mt6575_pm_ldo.h>
-#endif
-
-#ifdef MT6577
-#include <mach/mt6577_devs.h>
-#include <mach/mt6577_typedefs.h>
-#include <mach/mt6577_gpio.h>
-#include <mach/mt6577_pm_ldo.h>
-#endif
-
-//jeff add for 72 begin
-#include <mach/mt_typedefs.h>
-#include <mach/mt_gpio.h>
-#include <mach/mt_pm_ldo.h>
-//jeff add for 72 end
-
-#include <cust_acc.h>
-#include <linux/hwmsensor.h>
-#include <linux/hwmsen_dev.h>
-#include <linux/sensors_io.h>
-#include <linux/hwmsen_helper.h>
-
-#include <linux/ioctl.h>
-#include <linux/wakelock.h>
-
-#include "mc3xxx.h"
-
-/*****************************************************************************
- *** CONFIGURATION
- *****************************************************************************/
-#define _MC3XXX_SUPPORT_AUTO_DETECT_		//jeff open 20141106
-//#define _MC3XXX_SUPPORT_DOT_CALIBRATION_		//jeff del 20141106
-#define _MC3XXX_SUPPORT_LPF_
-#define _MC3XXX_SUPPORT_CONCURRENCY_PROTECTION_
-//#define _MC3XXX_SUPPORT_APPLY_AVERAGE_AGORITHM_
-//#define _MC3XXX_SUPPORT_PERIODIC_DOC_
-//#define _MC3XXX_SUPPORT_VPROXIMITY_SENSOR_
-#define _MC3XXX_SUPPORT_LRF_
-//#define _MC3XXX_SUPPORT_POWER_SAVING_SHUTDOWN_POWER_
-
-#define C_MAX_FIR_LENGTH    (32)
-
-#define VIRTUAL_Z    0
-
-/*****************************************************************************
- *** CONSTANT / DEFINITION
- *****************************************************************************/
-/**************************
- *** CONFIGURATION
- **************************/
-#define MC3XXX_DEV_NAME                        "MC3XXX"
-#define MC3XXX_DEV_DRIVER_VERSION              "2.1.6"
-#define MC3XXX_DEV_DRIVER_VERSION_VIRTUAL_Z    "1.0.1"
-
-/**************************
- *** COMMON
- **************************/
-#define MC3XXX_AXIS_X      0
-#define MC3XXX_AXIS_Y      1
-#define MC3XXX_AXIS_Z      2
-#define MC3XXX_AXES_NUM    3
-#define MC3XXX_DATA_LEN    6
-
-#define MC3XXX_RESOLUTION_LOW     1
-#define MC3XXX_RESOLUTION_HIGH    2
-
-#define MC3XXX_LOW_REOLUTION_DATA_SIZE     3
-#define MC3XXX_HIGH_REOLUTION_DATA_SIZE    6
-
-#define MC3XXX_INIT_SUCC    (0)
-#define MC3XXX_INIT_FAIL    (-1)
-
-#define MC3XXX_REGMAP_LENGTH    (64)
-
-/**************************
- *** DEBUG
- **************************/
-    /*********************
-     *** G-Sensor
-     *********************/
-    #if 0  //jeff open for debug
-        #define GSE_TAG                  "[Gsensor] "
-        #define GSE_FUN(f)               printk(KERN_INFO GSE_TAG"%s\n", __FUNCTION__)
-        #define GSE_ERR(fmt, args...)    printk(KERN_ERR GSE_TAG"%s %d : "fmt, __FUNCTION__, __LINE__, ##args)
-        #define GSE_LOG(fmt, args...)    printk(KERN_INFO GSE_TAG fmt, ##args)
-    #else
-        #define GSE_TAG
-        #define GSE_FUN(f)               do {} while (0)
-        #define GSE_ERR(fmt, args...)    do {} while (0)
-        #define GSE_LOG(fmt, args...)    do {} while (0)
-    #endif
-    
-    /*********************
-     *** vProximity Sensor
-     *********************/
-    #if 0
-        #define PS_TAG                  "[mCube/Psensor] "
-        #define PS_FUN(f)               printk(KERN_INFO PS_TAG"%s\n", __FUNCTION__)
-        #define PS_ERR(fmt, args...)    printk(KERN_ERR  PS_TAG"%s %d : "fmt, __FUNCTION__, __LINE__, ##args)
-        #define PS_LOG(fmt, args...)    printk(KERN_ERR PS_TAG fmt, ##args)
-    #else
-        #define PS_TAG
-        #define PS_FUN(f)               do {} while (0)
-        #define PS_ERR(fmt, args...)    do {} while (0)
-        #define PS_LOG(fmt, args...)    do {} while (0)
-    #endif       
-
-/*****************************************************************************
- *** DATA TYPE / STRUCTURE DEFINITION / ENUM
- *****************************************************************************/
-typedef enum
-{
-    MCUBE_TRC_FILTER  = 0x01,
-    MCUBE_TRC_RAWDATA = 0x02,
-    MCUBE_TRC_IOCTL   = 0x04,
-    MCUBE_TRC_CALI    = 0X08,
-    MCUBE_TRC_INFO    = 0X10,
-    MCUBE_TRC_REGXYZ  = 0X20,
-}   MCUBE_TRC;
-
-struct scale_factor
-{
-    u8    whole;
-    u8    fraction;
-};
-
-struct data_resolution
-{
-    struct scale_factor    scalefactor;
-    int                    sensitivity;
-};
-
-struct data_filter
-{
-    s16    raw[C_MAX_FIR_LENGTH][MC3XXX_AXES_NUM];
-    int    sum[MC3XXX_AXES_NUM];
-    int    num;
-    int    idx;
-};
-
-struct mc3xxx_i2c_data
-{
-    //================================================
-    struct i2c_client          *client;
-    struct acc_hw              *hw;
-    struct hwmsen_convert       cvt;
-
-    //================================================
-    struct data_resolution     *reso;
-    atomic_t                    trace;
-    atomic_t                    suspend;
-    atomic_t                    selftest;
-    atomic_t                    filter;
-    s16                         cali_sw[MC3XXX_AXES_NUM + 1];
-    
-    //================================================
-    s16                         offset[MC3XXX_AXES_NUM + 1];
-    s16                         data[MC3XXX_AXES_NUM + 1];
-    
-    //================================================
-    #if defined(_MC3XXX_SUPPORT_LPF_)
-        atomic_t                firlen;
-        atomic_t                fir_en;
-        struct data_filter      fir;
-    #endif 
-
-    //================================================
-    #if defined(CONFIG_HAS_EARLYSUSPEND)
-        struct early_suspend    early_drv;
-    #endif     
-};
-
-#ifdef _MC3XXX_SUPPORT_LRF_
-    typedef struct
-    {
-        s16    nIsNewRound;
-        s16    nPreDiff;
-        s16    nPreValue;
-        s16    nMaxValue;
-        s16    nMinValue;
-        s16    nRepValue;
-        s16    nNewDataMonitorCount;
-    }   S_LRF_CB;
-#endif
-
-/*****************************************************************************
- *** EXTERNAL FUNCTION
- *****************************************************************************/
-extern struct acc_hw*    mc3xxx_get_cust_acc_hw(void);
-
-/*****************************************************************************
- *** STATIC FUNCTION
- *****************************************************************************/
-static int mc3xxx_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id);
-static int mc3xxx_i2c_remove(struct i2c_client *client);
-
-static int _mc3xxx_i2c_auto_probe(struct i2c_client *client);
-
-#ifndef CONFIG_HAS_EARLYSUSPEND
-    static int mc3xxx_suspend(struct i2c_client *client, pm_message_t msg);
-    static int mc3xxx_resume(struct i2c_client *client);
-#endif
-
-#ifdef _MC3XXX_SUPPORT_AUTO_DETECT_
-    static int mc3xxx_local_init(void);
-    static int mc3xxx_remove(void);
-#endif
-
-static int MC3XXX_SetPowerMode(struct i2c_client *client, bool enable);
-static int MC3XXX_WriteCalibration(struct i2c_client *client, int dat[MC3XXX_AXES_NUM]);
-
-static void MC3XXX_SetGain(void);
-
-/*****************************************************************************
- *** STATIC VARIBLE & CONTROL BLOCK DECLARATION
- *****************************************************************************/
-static unsigned char    s_bResolution = 0x00;
-static unsigned char    s_bPCODE      = 0x00;
-static unsigned char    s_bPCODER     = 0x00;
-static unsigned char    s_bHWID       = 0x00;
-static unsigned char    s_bMPOL       = 0x00;
-
-static int    s_nInitFlag = MC3XXX_INIT_FAIL;
-
-#ifdef _MC3XXX_SUPPORT_AUTO_DETECT_
-    static struct sensor_init_info  mc3xxx_init_info =
-    {
-        .name   = MC3XXX_DEV_NAME,
-        .init   = mc3xxx_local_init,
-        .uninit = mc3xxx_remove,
-    };
-#else
-    static struct platform_driver    mc3xxx_gsensor_driver;
-#endif
-
-
-static const struct i2c_device_id                mc3xxx_i2c_id[]              = { {MC3XXX_DEV_NAME, 0}, {} };
-static       struct i2c_board_info __initdata    mc3xxx_i2c_board_info        = { I2C_BOARD_INFO(MC3XXX_DEV_NAME, 0x4C) };
-static       unsigned short                      mc3xxx_i2c_auto_probe_addr[] = { 0x4C, 0x6C, 0x4E, 0x6D, 0x6E, 0x6F };
-
-static struct i2c_driver    mc3xxx_i2c_driver = {
-                                                    .driver = {
-                                                                  .name = MC3XXX_DEV_NAME,
-                                                              },
-                                                    .probe  = mc3xxx_i2c_probe,
-                                                    .remove = mc3xxx_i2c_remove,
-
-                                                    #if !defined(CONFIG_HAS_EARLYSUSPEND)    
-                                                        .suspend = mc3xxx_suspend,
-                                                        .resume  = mc3xxx_resume,
-                                                    #endif
-
-                                                    .id_table = mc3xxx_i2c_id,
-                                                };
-
-static struct i2c_client        *mc3xxx_i2c_client = NULL;
-static struct mc3xxx_i2c_data   *mc3xxx_obj_i2c_data = NULL;
-
-static struct data_resolution    mc3xxx_offset_resolution = { {7, 8}, 256 };
-
-static bool    mc3xxx_sensor_power = false;
-
-static GSENSOR_VECTOR3D    gsensor_gain, gsensor_offset;
-
-static char    selftestRes[10] = {0};
-
-static struct file* fd_file = NULL;
-static mm_segment_t oldfs;
-static unsigned char offset_buf[6]; 
-static signed int    offset_data[3];
-static signed int    gain_data[3];
-static unsigned char    s_baOTP_OffsetData[6] = { 0 };
-static signed int    s_nIsRBM_Enabled = false;
-
-#ifdef _MC3XXX_SUPPORT_LRF_
-    static S_LRF_CB    s_taLRF_CB[MC3XXX_AXES_NUM];
-#endif
-
-#ifdef _MC3XXX_SUPPORT_CONCURRENCY_PROTECTION_
-    static struct semaphore    s_tSemaProtect;
-#endif
-
-#ifdef _MC3XXX_SUPPORT_DOT_CALIBRATION_
-    static int    s_nIsCaliLoaded = false;
-    static int    LPF_FirstRun = 1;
-#endif
-
-static int             LPF_SamplingRate = 5;
-static int             LPF_CutoffFrequency = 0x00000004;
-static unsigned int    iAReal0_X;
-static unsigned int    iAcc0Lpf0_X;
-static unsigned int    iAcc0Lpf1_X;
-static unsigned int    iAcc1Lpf0_X;
-static unsigned int    iAcc1Lpf1_X;
-
-static unsigned int    iAReal0_Y;
-static unsigned int    iAcc0Lpf0_Y;
-static unsigned int    iAcc0Lpf1_Y;
-static unsigned int    iAcc1Lpf0_Y;
-static unsigned int    iAcc1Lpf1_Y;
-
-static unsigned int    iAReal0_Z;
-static unsigned int    iAcc0Lpf0_Z;
-static unsigned int    iAcc0Lpf1_Z;
-static unsigned int    iAcc1Lpf0_Z;
-static unsigned int    iAcc1Lpf1_Z;
-
-static signed char    s_bAccuracyStatus = SENSOR_STATUS_ACCURACY_MEDIUM;
-
-#ifdef _MC3XXX_SUPPORT_PERIODIC_DOC_
-    static DECLARE_WAIT_QUEUE_HEAD(wq_mc3xxx_open_status);
-
-    static atomic_t    s_t_mc3xxx_open_status = ATOMIC_INIT(0);
-
-    static unsigned char    s_bIsPDOC_Enabled = false;
-#endif
-
-#ifdef _MC3XXX_SUPPORT_VPROXIMITY_SENSOR_
-    static int    P_STATUS;
-    static int    prev_P_STATUS = 0;
-#endif
-
-/*****************************************************************************
- *** MACRO
- *****************************************************************************/
-#ifdef _MC3XXX_SUPPORT_CONCURRENCY_PROTECTION_
-    #define MC3XXX_MUTEX_INIT()   sema_init(&s_tSemaProtect, 1)
-
-    #define MC3XXX_MUTEX_LOCK()                             \
-                if (down_interruptible(&s_tSemaProtect))    \
-                    return (-ERESTARTSYS)
-
-    #define MC3XXX_MUTEX_LOCK_RETURN_VOID()                 \
-                if (down_interruptible(&s_tSemaProtect))    \
-                    return
-
-    #define MC3XXX_MUTEX_UNLOCK()   up(&s_tSemaProtect)
-#else
-    #define MC3XXX_MUTEX_INIT()                do {} while (0)
-    #define MC3XXX_MUTEX_LOCK()                do {} while (0)
-    #define MC3XXX_MUTEX_LOCK_RETURN_VOID()    do {} while (0)
-    #define MC3XXX_MUTEX_UNLOCK()              do {} while (0)
-#endif
-
-#define MCUBE_RREMAP(nDataX, nDataY)                                                  \
-            if (MC3XXX_PCODE_3250 == s_bPCODE)                                        \
-            {                                                                         \
-                int    _nTemp = 0;                                                    \
-                                                                                      \
-                _nTemp = nDataX;                                                      \
-                nDataX = nDataY;                                                      \
-                nDataY = -_nTemp;                                                     \
-                GSE_LOG("[%s] 3250 read remap\n", __FUNCTION__);                      \
-            }                                                                         \
-            else                                                                      \
-            {                                                                         \
-                if (s_bMPOL & 0x01)    nDataX = -nDataX;                              \
-                if (s_bMPOL & 0x02)    nDataY = -nDataY;                              \
-                GSE_LOG("[%s] 35X0 remap [s_bMPOL: %d]\n", __FUNCTION__, s_bMPOL);    \
-            }
-
-#define MCUBE_WREMAP(nDataX, nDataY)                                                  \
-            if (MC3XXX_PCODE_3250 == s_bPCODE)                                        \
-            {                                                                         \
-                int    _nTemp = 0;                                                    \
-                                                                                      \
-                _nTemp = nDataX;                                                      \
-                nDataX = -nDataY;                                                     \
-                nDataY = _nTemp;                                                      \
-                GSE_LOG("[%s] 3250 write remap\n", __FUNCTION__);                     \
-            }                                                                         \
-            else                                                                      \
-            {                                                                         \
-                if (s_bMPOL & 0x01)    nDataX = -nDataX;                              \
-                if (s_bMPOL & 0x02)    nDataY = -nDataY;                              \
-                GSE_LOG("[%s] 35X0 remap [s_bMPOL: %d]\n", __FUNCTION__, s_bMPOL);    \
-            }
-
-#define IS_MCFM12()    ((0xC0 <= s_bHWID) && (s_bHWID <= 0xCF))
-#define IS_MCFM3X()    ((0x20 == s_bHWID) || ((0x22 <= s_bHWID) && (s_bHWID <= 0x2F)))
-
-/*****************************************************************************
- *** TODO
- *****************************************************************************/
-#define DATA_PATH              "/sdcard2/mcube-register-map.txt"
-
-#ifdef _MC3XXX_SUPPORT_DOT_CALIBRATION_
-    static char    file_path[MC3XXX_BUF_SIZE]        = "/data/data/com.mcube.acc/files/mcube-calib.txt";
-    static char    backup_file_path[MC3XXX_BUF_SIZE] = "/data/misc/sensors/mcube-calib.txt";
-#endif
-
-/*****************************************************************************
- *** FUNCTION
- *****************************************************************************/
-
-/*****************************************
- *** GetLowPassFilter
- *****************************************/
-static unsigned int GetLowPassFilter(unsigned int X0,unsigned int Y1)
-{
-    unsigned int lTemp;
-    
-    lTemp = Y1;
-    lTemp *= LPF_CutoffFrequency;    // 4HZ LPF RC=0.04
-    X0 *= LPF_SamplingRate;		
-    lTemp += X0;
-    lTemp += LPF_CutoffFrequency;
-    lTemp /= (LPF_CutoffFrequency + LPF_SamplingRate);		
-    Y1 = lTemp;
-    
-    return Y1;
-}
-
-/*****************************************
- *** openFile
- *****************************************/
-static struct file *openFile(char *path,int flag,int mode) 
-{ 
-    struct file *fp = NULL; 
-    
-    fp = filp_open(path, flag, mode); 
-
-    if (IS_ERR(fp) || !fp->f_op) 
-    {
-        GSE_LOG("Calibration File filp_open return NULL\n");
-        return NULL; 
-    }
-    else 
-    {
-        return fp; 
-    }
-} 
- 
-/*****************************************
- *** readFile
- *****************************************/
-#ifdef _MC3XXX_SUPPORT_DOT_CALIBRATION_
-static int readFile(struct file *fp,char *buf,int readlen) 
-{ 
-    if (fp->f_op && fp->f_op->read) 
-        return fp->f_op->read(fp,buf,readlen, &fp->f_pos); 
-    else 
-        return -1; 
-} 
-#endif
-
-/*****************************************
- *** writeFile
- *****************************************/
-static int writeFile(struct file *fp,char *buf,int writelen) 
-{ 
-    if (fp->f_op && fp->f_op->write) 
-        return fp->f_op->write(fp,buf,writelen, &fp->f_pos); 
-    else 
-        return -1; 
-}
- 
-/*****************************************
- *** closeFile
- *****************************************/
-static int closeFile(struct file *fp) 
-{ 
-    filp_close(fp,NULL); 
-    return 0; 
-} 
-
-/*****************************************
- *** initKernelEnv
- *****************************************/
-static void initKernelEnv(void) 
-{ 
-    oldfs = get_fs(); 
-    set_fs(KERNEL_DS);
-    printk(KERN_INFO "initKernelEnv\n");
-} 
-
-/*****************************************
- *** mcube_write_log_data
- *****************************************/
-static int mcube_write_log_data(struct i2c_client *client, u8 data[0x3f])
-{
-    #define _WRT_LOG_DATA_BUFFER_SIZE    (66 * 50)
-    
-    s16 rbm_data[3] = {0}, raw_data[3] = {0};
-    int err = 0;
-    char *_pszBuffer = NULL;
-    int n = 0, i = 0;
-
-    initKernelEnv();
-    fd_file = openFile(DATA_PATH ,O_RDWR | O_CREAT,0); 
-    if (fd_file == NULL) 
-    {
-        GSE_LOG("mcube_write_log_data fail to open\n");	
-    }
-    else
-    {
-        rbm_data[MC3XXX_AXIS_X] = (s16)((data[0x0d]) | (data[0x0e] << 8));
-        rbm_data[MC3XXX_AXIS_Y] = (s16)((data[0x0f]) | (data[0x10] << 8));
-        rbm_data[MC3XXX_AXIS_Z] = (s16)((data[0x11]) | (data[0x12] << 8));
-        
-        raw_data[MC3XXX_AXIS_X] = (rbm_data[MC3XXX_AXIS_X] + offset_data[0]/2)*gsensor_gain.x/gain_data[0];
-        raw_data[MC3XXX_AXIS_Y] = (rbm_data[MC3XXX_AXIS_Y] + offset_data[1]/2)*gsensor_gain.y/gain_data[1];
-        raw_data[MC3XXX_AXIS_Z] = (rbm_data[MC3XXX_AXIS_Z] + offset_data[2]/2)*gsensor_gain.z/gain_data[2];
-        
-        _pszBuffer = kzalloc(_WRT_LOG_DATA_BUFFER_SIZE, GFP_KERNEL);
-
-        if (NULL == _pszBuffer)
-        {
-            GSE_ERR("fail to allocate memory for buffer\n");
-            return -1;
-        }
-
-        memset(_pszBuffer, 0, _WRT_LOG_DATA_BUFFER_SIZE); 
-        
-        n += sprintf(_pszBuffer+n, "G-sensor RAW X = %d  Y = %d  Z = %d\n", raw_data[0] ,raw_data[1] ,raw_data[2]);
-        n += sprintf(_pszBuffer+n, "G-sensor RBM X = %d  Y = %d  Z = %d\n", rbm_data[0] ,rbm_data[1] ,rbm_data[2]);
-
-        for (i = 0; i < 64; i++)
-        {
-            n += sprintf(_pszBuffer+n, "mCube register map Register[%x] = 0x%x\n",i,data[i]);
-        }
-
-        msleep(50);		
-
-        if ((err = writeFile(fd_file,_pszBuffer,n)) > 0) 
-            GSE_LOG("buf:%s\n",_pszBuffer); 
-        else 
-            GSE_LOG("write file error %d\n",err); 
-        
-        kfree(_pszBuffer);
-        set_fs(oldfs); 
-        closeFile(fd_file); 
-    }
-
-    return 0;
-}
-
-#ifdef _MC3XXX_SUPPORT_DOT_CALIBRATION_
-/*****************************************
- *** mcube_read_cali_file
- *****************************************/
-static int mcube_read_cali_file(struct i2c_client *client)
-{
-    int cali_data[3] = {0},cali_data1[3] = {0};
-    int err = 0;
-    char buf[64] = {0};
-
-    GSE_LOG("[%s] sizeof(buf): %d\n",__func__, sizeof(buf));
-
-    initKernelEnv();
-    fd_file = openFile(file_path,O_RDONLY,0); 
-
-    if (fd_file == NULL) 
-    {
-        GSE_LOG("%s:fail to open calibration file: %s\n", __func__, file_path);
-        fd_file = openFile(backup_file_path,O_RDONLY,0); 
-
-        if(fd_file == NULL)	
-        {	
-            GSE_LOG("%s:fail to open calibration file: %s\n", __func__, backup_file_path);
-            cali_data[0] = 0;
-            cali_data[1] = 0;
-            cali_data[2] = 0;
-            return (-1);
-        }
-        else
-        {		
-            GSE_LOG("Open backup calibration file successfully: %s\n", backup_file_path);
-        }
-    }
-    else
-    {
-        GSE_LOG("Open calibration file successfully: %s\n", file_path);
-    }
-			
-    memset(buf, 0, sizeof(buf)); 
-
-    if ((err = readFile(fd_file, buf, sizeof(buf))) > 0) 
-        GSE_LOG("cali_file: buf:%s\n",buf); 
-    else 
-        GSE_LOG("read file error %d\n",err); 
-    
-    set_fs(oldfs); 
-    closeFile(fd_file); 
-
-    sscanf(buf, "%d %d %d",&cali_data[MC3XXX_AXIS_X], &cali_data[MC3XXX_AXIS_Y], &cali_data[MC3XXX_AXIS_Z]);
-    GSE_LOG("cali_data: %d %d %d\n", cali_data[MC3XXX_AXIS_X], cali_data[MC3XXX_AXIS_Y], cali_data[MC3XXX_AXIS_Z]); 	
-    
-    cali_data1[MC3XXX_AXIS_X] = cali_data[MC3XXX_AXIS_X] * gsensor_gain.x / GRAVITY_EARTH_1000;
-    cali_data1[MC3XXX_AXIS_Y] = cali_data[MC3XXX_AXIS_Y] * gsensor_gain.y / GRAVITY_EARTH_1000;
-    cali_data1[MC3XXX_AXIS_Z] = cali_data[MC3XXX_AXIS_Z] * gsensor_gain.z / GRAVITY_EARTH_1000;
-    
-    GSE_LOG("cali_data1: %d %d %d\n", cali_data1[MC3XXX_AXIS_X], cali_data1[MC3XXX_AXIS_Y], cali_data1[MC3XXX_AXIS_Z]); 	
-    
-    MC3XXX_WriteCalibration(client, cali_data1);
-    
-    return 0;
-}
-
-/*****************************************
- *** mcube_load_cali
- *****************************************/
-static void    mcube_load_cali(struct i2c_client *pt_i2c_client)
-{
-    if (false == s_nIsCaliLoaded)
-    {
-        GSE_LOG("[%s] loading cali file...\n", __FUNCTION__);
-        
-        if (MC3XXX_RETCODE_SUCCESS == mcube_read_cali_file(pt_i2c_client))
-            s_nIsCaliLoaded = true;
-    }
-}
-
-#endif // _MC3XXX_SUPPORT_DOT_CALIBRATION_
-
-/*****************************************
- *** hwmsen_read_byte_sr
- *****************************************/
-static int hwmsen_read_byte_sr(struct i2c_client *client, u8 addr, u8 *data)
-{
-    u8 buf = 0;
-    int ret = 0;
-    
-    client->addr = ((client->addr) & (I2C_MASK_FLAG | I2C_WR_FLAG |I2C_RS_FLAG));
-    buf = addr;
-    ret = i2c_master_send(client, (const char*)&buf, 1<<8 | 1);
-
-    if (ret < 0) {
-        HWM_ERR("send command error!!\n");
-        return -EFAULT;
-    }
-    
-    *data = buf;
-    client->addr = client->addr& I2C_MASK_FLAG;
-
-    return 0;
-}
-
-/*****************************************
- *** mcube_psensor_ioctl
- *****************************************/
-#ifdef _MC3XXX_SUPPORT_VPROXIMITY_SENSOR_
-static long mcube_psensor_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
-{ 
-    int err=0;
-    void __user *data;
-    int pSensor=0;
-    
-	if(_IOC_DIR(cmd) & _IOC_READ)
-	{
-		err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
-	}
-	else if(_IOC_DIR(cmd) & _IOC_WRITE)
-	{
-		err = !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
-	}
-
-	if(err)
-	{
-		PS_ERR("access error: %08X, (%2d, %2d)\n", cmd, _IOC_DIR(cmd), _IOC_SIZE(cmd));
-		return -EFAULT;
-	}
-
-	switch(cmd)
-	{
-		case PSENSOR_IOCTL_SET_POSTURE:
-			data = (void __user*)arg;
-			if(data == NULL)
-			{
-				err = -EINVAL;
-				break;	  
-			}
-			
-			if(copy_from_user(&pSensor, data, sizeof(int)))
-			{
-				err = -EFAULT;
-				break;	  
-			}
-			
-			P_STATUS = pSensor;
-			PS_LOG("IOCTL Get P_STATUS = %d",pSensor);		
-			break;
-		default:
-			
-			PS_ERR("unknown IOCTL: 0x%08x\n", cmd);
-			//err = -ENOIOCTLCMD;
-			break;	
-	}       
-	return err;
-}
-
-/*****************************************
- *** STATIC STRUCTURE:: fops
- *****************************************/
-static struct file_operations mcube_psensor_fops = {
-	.owner = THIS_MODULE,
-	.unlocked_ioctl = mcube_psensor_ioctl,
-};
-
-/*****************************************
- *** STATIC STRUCTURE:: misc-device
- *****************************************/
-static struct miscdevice mcube_psensor_device = {
-	.minor = MISC_DYNAMIC_MINOR,
-	.name = "psensor",
-	.fops  = &mcube_psensor_fops,
-};
-
-/*****************************************
- *** psensor_ps_operate
- *****************************************/
-static int psensor_ps_operate(void* self, uint32_t command, void* buff_in, int size_in,
-		void* buff_out /*sensor_data*/, int size_out, int* actualout)
-{
-	int err = 0;
-	int value;
-	int val=-1;
-	hwm_sensor_data* sensor_data;
-	//struct mcube_psensor_priv *obj = (struct mcube_psensor_priv *)self;
-	
-	//PS_FUN(f);
-	switch (command)
-	{
-		case SENSOR_DELAY:
-			if((buff_in == NULL) || (size_in < sizeof(int)))
-			{
-				PS_ERR("Set delay parameter error!\n");
-				err = -EINVAL;
-			}
-			// Do nothing
-			break;
-
-		case SENSOR_ENABLE:
-			value = *(int *)buff_in;
-			if(value)
-			{
-				if((buff_in == NULL) || (size_in < sizeof(int)))
-				{
-					PS_ERR("Enable sensor parameter error!\n");
-					err = -EINVAL;
-				}
-				
-				else
-				{				
-					value = *(int *)buff_in;
-					//obj->enable = 1;
-					PS_ERR("enable ps \n"); 
-				}
-			}
-			else
-			{
-				//obj->enable = 0;
-				PS_ERR("disable ps \n"); 
-			}
-			break;
-		case SENSOR_GET_DATA:
-			PS_LOG("fwq get ps data !!!!!!\n");
-			if((buff_out == NULL) || (size_out< sizeof(hwm_sensor_data)))
-			{
-				PS_ERR("get sensor data parameter error!\n");
-				err = -EINVAL;
-			}
-			else
-			{
-				sensor_data = (hwm_sensor_data *)buff_out;				
-				PS_LOG("mcube sensor data P_STATUS=%d\n",P_STATUS);
-				
-				if(prev_P_STATUS != P_STATUS )
-				{
-					if(P_STATUS == 0)
-					{
-						PS_LOG("TURN ON LCD\n");
-						val=1;
-						PS_LOG("Set val = 1, Proximity sensor far away\n");
-					}
-					else if (P_STATUS == 1)
-					{	
-						PS_LOG("TURN OFF LCD\n");
-						val=0;
-						PS_LOG("Set val = 0, Proximity sensor close\n");
-					}
-					PS_LOG("mcube sensor data prev_P_STATUS=%d, P_STATUS=%d\n",prev_P_STATUS,P_STATUS);
-					prev_P_STATUS = P_STATUS;	
-				}
-				else
-				{
-					PS_LOG("P_STATUS %5d=>%5d\n",prev_P_STATUS,P_STATUS);
-					prev_P_STATUS = P_STATUS;
-					val= (P_STATUS==0)? (1):(0);
-				}	
-				sensor_data->values[0] = val;	
-				sensor_data->value_divide = 1;
-				sensor_data->status = SENSOR_STATUS_ACCURACY_MEDIUM;
-				prev_P_STATUS = P_STATUS;	
-			}
-			break;
-		default:
-			PS_ERR("proxmy sensor operate function has no this command %d!\n", command);
-			err = -1;
-			break;
-	}
-	
-	return err;
-}
-#endif  // end of _MC3XXX_SUPPORT_VPROXIMITY_SENSOR_
-
-/*****************************************
- *** MC3XXX_power
- *****************************************/
-static void MC3XXX_power(struct acc_hw *hw, unsigned int on) 
-{
-	static unsigned int power_on = 0;
-
-	if(hw->power_id != MT65XX_POWER_NONE)		// have externel LDO
-	{        
-		GSE_LOG("power %s\n", on ? "on" : "off");
-		if(power_on == on)	// power status not change
-		{
-			GSE_LOG("ignore power control: %d\n", on);
-		}
-		else if(on)	// power on
-		{
-			if(!hwPowerOn(hw->power_id, hw->power_vol, MC3XXX_DEV_NAME))
-			{
-				GSE_ERR("power on fails!!\n");
-			}
-		}
-		else	// power off
-		{
-			if (!hwPowerDown(hw->power_id, "MC3XXX"))
-			{
-				GSE_ERR("power off fail!!\n");
-			}			  
-		}
-	}
-	power_on = on;    
-}
-
-#ifdef _MC3XXX_SUPPORT_DOT_CALIBRATION_
-/*****************************************
- *** MC3XXX_rbm
- *****************************************/
-static void MC3XXX_rbm(struct i2c_client *client, int enable)
-{
-    u8    _baDataBuf[3] = { 0 };
-    
-    _baDataBuf[0] = 0x43; 
-    hwmsen_write_block(client, 0x07, _baDataBuf, 0x01);
-    
-    hwmsen_read_block(client, 0x04, _baDataBuf, 0x01);
-    
-    //GSE_LOG("[%s] REG(0x04): 0x%X, enable: %d\n", __FUNCTION__, _baDataBuf[0], enable);
-    
-    if (0x00 == (_baDataBuf[0] & 0x40))
-    {
-        _baDataBuf[0] = 0x6D; 
-        hwmsen_write_block(client, 0x1B, _baDataBuf, 0x01);
-
-        _baDataBuf[0] = 0x43; 
-        hwmsen_write_block(client, 0x1B, _baDataBuf, 0x01);
-    }
-    
-    //hwmsen_read_block(client, 0x04, _baDataBuf, 0x01);
-    //GSE_LOG("BEGIN - REG(0x04): 0x%X\n", _baDataBuf[0]);
-    
-    if (1 == enable)
-    {
-        _baDataBuf[0] = 0x00;
-        hwmsen_write_block(client, 0x3B, _baDataBuf, 0x01);
-        
-        _baDataBuf[0] = 0x02; 
-        hwmsen_write_block(client, 0x14, _baDataBuf, 0x01);
-        
-        if (MC3XXX_RESOLUTION_LOW == s_bResolution)
-        {
-            gsensor_gain.x = gsensor_gain.y = gsensor_gain.z = 1024;
-        }
-
-        s_nIsRBM_Enabled = 1;
-        LPF_FirstRun = 1;
-        
-        GSE_LOG("set rbm!!\n");
-    }
-    else if (0 == enable)
-    {
-        _baDataBuf[0] = 0x00; 
-        hwmsen_write_block(client, 0x14, _baDataBuf, 0x01);
-        
-        _baDataBuf[0] = s_bPCODER; 
-        hwmsen_write_block(client, 0x3B, _baDataBuf, 0x01);
-        
-        MC3XXX_SetGain();
-
-        s_nIsRBM_Enabled = 0;
-        
-        GSE_LOG("clear rbm!!\n");
-    }
-    
-    hwmsen_read_block(client, 0x04, _baDataBuf, 0x01);
-    
-    //GSE_LOG("RBM CONTROL DONE - REG(0x04): 0x%X\n", _baDataBuf[0]);
-    
-    if (_baDataBuf[0] & 0x40)
-    {
-        _baDataBuf[0] = 0x6D; 
-        hwmsen_write_block(client, 0x1B, _baDataBuf, 0x01);
-        
-        _baDataBuf[0] = 0x43; 
-        hwmsen_write_block(client, 0x1B, _baDataBuf, 0x01);
-    }
-    
-    //hwmsen_read_block(client, 0x04, _baDataBuf, 0x01);
-    //GSE_LOG("END - REG(0x04): 0x%X\n", _baDataBuf[0]);
-    
-    _baDataBuf[0] = 0x41; 
-    hwmsen_write_block(client, 0x07, _baDataBuf, 0x01);
-    
-    msleep(220);
-}
-
-/*****************************************
- *** MC3XXX_ReadData_RBM
- *****************************************/
-static int MC3XXX_ReadData_RBM(struct i2c_client *client, int data[MC3XXX_AXES_NUM])
-{
-	u8 addr = 0x0d;
-	u8 rbm_buf[MC3XXX_DATA_LEN] = {0};
-	int err = 0;
-
-	if(NULL == client)
-	{
-		err = -EINVAL;
-		return err;
-	}
-	
-/********************************************/
-	
-	if((err = hwmsen_read_block(client, addr, rbm_buf, 0x06)))
-    {
-    	GSE_ERR("error: %d\n", err);
-    	return err;
-    }
-
-	data[MC3XXX_AXIS_X] = (s16)((rbm_buf[0]) | (rbm_buf[1] << 8));
-	data[MC3XXX_AXIS_Y] = (s16)((rbm_buf[2]) | (rbm_buf[3] << 8));
-	data[MC3XXX_AXIS_Z] = (s16)((rbm_buf[4]) | (rbm_buf[5] << 8));
-
-	GSE_LOG("rbm_buf<<<<<[%02x %02x %02x %02x %02x %02x]\n",rbm_buf[0], rbm_buf[2], rbm_buf[2], rbm_buf[3], rbm_buf[4], rbm_buf[5]);
-	GSE_LOG("RBM<<<<<[%04x %04x %04x]\n", data[MC3XXX_AXIS_X], data[MC3XXX_AXIS_Y], data[MC3XXX_AXIS_Z]);
-	GSE_LOG("RBM<<<<<[%04d %04d %04d]\n", data[MC3XXX_AXIS_X], data[MC3XXX_AXIS_Y], data[MC3XXX_AXIS_Z]);
-
-
-/********************************************/
-    MCUBE_RREMAP(data[0], data[1]);
-
-	return err;
-}
-#endif // _MC3XXX_SUPPORT_DOT_CALIBRATION_
-
-/*****************************************
- *** MC3XXX_ValidateSensorIC
- *****************************************/
-static int MC3XXX_ValidateSensorIC(unsigned char *pbPCode, unsigned char *pbHwID)
-{
-    GSE_LOG("[%s] *pbPCode: 0x%02X, *pbHwID: 0x%02X\n", __FUNCTION__, *pbPCode, *pbHwID);
-
-    if (   (0x01 == *pbHwID)
-        || (0x03 == *pbHwID)
-        || ((0x04 <= *pbHwID) && (*pbHwID <= 0x0F)))
-    {
-        if ((MC3XXX_PCODE_3210 == *pbPCode) || (MC3XXX_PCODE_3230 == *pbPCode) || (MC3XXX_PCODE_3250 == *pbPCode))
-            return (MC3XXX_RETCODE_SUCCESS);
-    }
-    else if (   (0x02 == *pbHwID)
-             || (0x21 == *pbHwID)
-             || ((0x10 <= *pbHwID) && (*pbHwID <= 0x1F)))
-    {
-        if (   (MC3XXX_PCODE_3210 == *pbPCode) || (MC3XXX_PCODE_3230  == *pbPCode)
-            || (MC3XXX_PCODE_3250 == *pbPCode)
-            || (MC3XXX_PCODE_3410 == *pbPCode) || (MC3XXX_PCODE_3410N == *pbPCode)
-            || (MC3XXX_PCODE_3430 == *pbPCode) || (MC3XXX_PCODE_3430N == *pbPCode))
-        {
-            return (MC3XXX_RETCODE_SUCCESS);
-        }
-    }
-    else if ((0xC0 <= *pbHwID) && (*pbHwID <= 0xCF))
-    {
-        *pbPCode = (*pbPCode & 0x71);
-
-        if ((MC3XXX_PCODE_3510 == *pbPCode) || (MC3XXX_PCODE_3530 == *pbPCode))
-            return (MC3XXX_RETCODE_SUCCESS);
-    }
-    else if ((0x20 == *pbHwID) || ((0x22 <= *pbHwID) && (*pbHwID <= 0x2F)))
-    {
-        *pbPCode = (*pbPCode & 0xF1);
-
-        if (   (MC3XXX_PCODE_3210      == *pbPCode) || (MC3XXX_PCODE_3216      == *pbPCode) || (MC3XXX_PCODE_3236      == *pbPCode)
-            || (MC3XXX_PCODE_RESERVE_1 == *pbPCode) || (MC3XXX_PCODE_RESERVE_2 == *pbPCode) || (MC3XXX_PCODE_RESERVE_3 == *pbPCode)
-            || (MC3XXX_PCODE_RESERVE_4 == *pbPCode) || (MC3XXX_PCODE_RESERVE_5 == *pbPCode) || (MC3XXX_PCODE_RESERVE_6 == *pbPCode)
-            || (MC3XXX_PCODE_RESERVE_7 == *pbPCode) || (MC3XXX_PCODE_RESERVE_8 == *pbPCode) || (MC3XXX_PCODE_RESERVE_9 == *pbPCode))
-        {
-            return (MC3XXX_RETCODE_SUCCESS);
-        }
-    }
-
-    return (MC3XXX_RETCODE_ERROR_IDENTIFICATION);
-}
-
-/*****************************************
- *** MC3XXX_Read_Chip_ID
- *****************************************/
-static int MC3XXX_Read_Chip_ID(struct i2c_client *client, char *buf)
-{
-    u8     _bChipID[4] = { 0 };
-
-    GSE_LOG("[%s]\n", __func__);
-
-    if (!buf || !client)
-        return EINVAL;
-
-    if (hwmsen_read_block(client, 0x3C, _bChipID, 4))
-    {
-        GSE_ERR("[%s] i2c read fail\n", __func__);
-        _bChipID[0] = 0;
-        _bChipID[1] = 0;
-        _bChipID[2] = 0;
-        _bChipID[3] = 0;
-    }
-
-    GSE_LOG("[%s] %02X-%02X-%02X-%02X\n", __func__, _bChipID[3], _bChipID[2], _bChipID[1], _bChipID[0]);
-
-    return sprintf(buf, "%02X-%02X-%02X-%02X\n", _bChipID[3], _bChipID[2], _bChipID[1], _bChipID[0]);
-}
-
-/*****************************************
- *** MC3XXX_Read_Reg_Map
- *****************************************/
-static int MC3XXX_Read_Reg_Map(struct i2c_client *p_i2c_client, u8 *pbUserBuf)
-{
-    u8     _baData[MC3XXX_REGMAP_LENGTH] = { 0 };
-    int    _nIndex = 0;
-
-    GSE_LOG("[%s]\n", __func__);
-
-    if(NULL == p_i2c_client)
-        return (-EINVAL);
-
-    for(_nIndex = 0; _nIndex < MC3XXX_REGMAP_LENGTH; _nIndex++)
-    {
-        hwmsen_read_block(p_i2c_client, _nIndex, &_baData[_nIndex], 1);
-
-        if (NULL != pbUserBuf)
-            pbUserBuf[_nIndex] = _baData[_nIndex];
-
-        printk(KERN_INFO "[Gsensor] REG[0x%02X] = 0x%02X\n", _nIndex, _baData[_nIndex]);
-    }
-
-    mcube_write_log_data(p_i2c_client, _baData);
-
-    return (0);
-}
-
-/*****************************************
- *** MC3XXX_SaveDefaultOffset
- *****************************************/
-static void MC3XXX_SaveDefaultOffset(struct i2c_client *p_i2c_client)
-{
-    GSE_LOG("[%s]\n", __func__);
-
-    hwmsen_read_block(p_i2c_client, 0x21, &s_baOTP_OffsetData[0], 3);
-    hwmsen_read_block(p_i2c_client, 0x24, &s_baOTP_OffsetData[3], 3);
-
-    GSE_LOG("s_baOTP_OffsetData: 0x%02X - 0x%02X - 0x%02X - 0x%02X - 0x%02X - 0x%02X\n",
-            s_baOTP_OffsetData[0], s_baOTP_OffsetData[1], s_baOTP_OffsetData[2],
-            s_baOTP_OffsetData[3], s_baOTP_OffsetData[4], s_baOTP_OffsetData[5]);
-}
-
-/*****************************************
- *** MC3XXX_LPF
- *****************************************/
-#ifdef _MC3XXX_SUPPORT_LPF_
-static void MC3XXX_LPF(struct mc3xxx_i2c_data *priv, s16 data[MC3XXX_AXES_NUM])
-{
-    if(atomic_read(&priv->filter))
-    {
-        if(atomic_read(&priv->fir_en) && !atomic_read(&priv->suspend))
-        {
-            int idx, firlen = atomic_read(&priv->firlen);   
-            if(priv->fir.num < firlen)
-            {                
-                priv->fir.raw[priv->fir.num][MC3XXX_AXIS_X] = data[MC3XXX_AXIS_X];
-                priv->fir.raw[priv->fir.num][MC3XXX_AXIS_Y] = data[MC3XXX_AXIS_Y];
-                priv->fir.raw[priv->fir.num][MC3XXX_AXIS_Z] = data[MC3XXX_AXIS_Z];
-                priv->fir.sum[MC3XXX_AXIS_X] += data[MC3XXX_AXIS_X];
-                priv->fir.sum[MC3XXX_AXIS_Y] += data[MC3XXX_AXIS_Y];
-                priv->fir.sum[MC3XXX_AXIS_Z] += data[MC3XXX_AXIS_Z];
-                if(atomic_read(&priv->trace) & MCUBE_TRC_FILTER)
-                {
-                    GSE_LOG("add [%2d] [%5d %5d %5d] => [%5d %5d %5d]\n", priv->fir.num,
-                    priv->fir.raw[priv->fir.num][MC3XXX_AXIS_X], priv->fir.raw[priv->fir.num][MC3XXX_AXIS_Y], priv->fir.raw[priv->fir.num][MC3XXX_AXIS_Z],
-                    priv->fir.sum[MC3XXX_AXIS_X], priv->fir.sum[MC3XXX_AXIS_Y], priv->fir.sum[MC3XXX_AXIS_Z]);
-                }
-                priv->fir.num++;
-                priv->fir.idx++;
-            }
-            else
-            {
-                idx = priv->fir.idx % firlen;
-                priv->fir.sum[MC3XXX_AXIS_X] -= priv->fir.raw[idx][MC3XXX_AXIS_X];
-                priv->fir.sum[MC3XXX_AXIS_Y] -= priv->fir.raw[idx][MC3XXX_AXIS_Y];
-                priv->fir.sum[MC3XXX_AXIS_Z] -= priv->fir.raw[idx][MC3XXX_AXIS_Z];
-                priv->fir.raw[idx][MC3XXX_AXIS_X] = data[MC3XXX_AXIS_X];
-                priv->fir.raw[idx][MC3XXX_AXIS_Y] = data[MC3XXX_AXIS_Y];
-                priv->fir.raw[idx][MC3XXX_AXIS_Z] = data[MC3XXX_AXIS_Z];
-                priv->fir.sum[MC3XXX_AXIS_X] += data[MC3XXX_AXIS_X];
-                priv->fir.sum[MC3XXX_AXIS_Y] += data[MC3XXX_AXIS_Y];
-                priv->fir.sum[MC3XXX_AXIS_Z] += data[MC3XXX_AXIS_Z];
-                priv->fir.idx++;
-                data[MC3XXX_AXIS_X] = priv->fir.sum[MC3XXX_AXIS_X]/firlen;
-                data[MC3XXX_AXIS_Y] = priv->fir.sum[MC3XXX_AXIS_Y]/firlen;
-                data[MC3XXX_AXIS_Z] = priv->fir.sum[MC3XXX_AXIS_Z]/firlen;
-                if(atomic_read(&priv->trace) & MCUBE_TRC_FILTER)
-                {
-                    GSE_LOG("add [%2d] [%5d %5d %5d] => [%5d %5d %5d] : [%5d %5d %5d]\n", idx,
-                    priv->fir.raw[idx][MC3XXX_AXIS_X], priv->fir.raw[idx][MC3XXX_AXIS_Y], priv->fir.raw[idx][MC3XXX_AXIS_Z],
-                    priv->fir.sum[MC3XXX_AXIS_X], priv->fir.sum[MC3XXX_AXIS_Y], priv->fir.sum[MC3XXX_AXIS_Z],
-                    data[MC3XXX_AXIS_X], data[MC3XXX_AXIS_Y], data[MC3XXX_AXIS_Z]);
-                }
-            }
-        }
-    }	
-}
-#endif    // END OF #ifdef _MC3XXX_SUPPORT_LPF_
-
-#ifdef _MC3XXX_SUPPORT_LRF_
-/*****************************************
- *** _MC3XXX_LowResFilter
- *****************************************/
-static void _MC3XXX_LowResFilter(s16 nAxis, s16 naData[MC3XXX_AXES_NUM])
-{
-    #define _LRF_DIFF_COUNT_POS                  2
-    #define _LRF_DIFF_COUNT_NEG                  (-_LRF_DIFF_COUNT_POS)
-    #define _LRF_DIFF_BOUNDARY_POS               (_LRF_DIFF_COUNT_POS + 1)
-    #define _LRF_DIFF_BOUNDARY_NEG               (_LRF_DIFF_COUNT_NEG - 1)
-    #define _LRF_DIFF_DATA_UNCHANGE_MAX_COUNT    11
-    
-    signed int    _nCurrDiff = 0;
-    signed int    _nSumDiff  = 0;
-    s16           _nCurrData = naData[nAxis];
-    
-    _nCurrDiff = (_nCurrData - s_taLRF_CB[nAxis].nRepValue);
-    
-    if ((_LRF_DIFF_COUNT_NEG < _nCurrDiff) && (_nCurrDiff < _LRF_DIFF_COUNT_POS))
-    {
-        if (s_taLRF_CB[nAxis].nIsNewRound)
-        {
-            s_taLRF_CB[nAxis].nMaxValue = _nCurrData;
-            s_taLRF_CB[nAxis].nMinValue = _nCurrData;
-            
-            s_taLRF_CB[nAxis].nIsNewRound = 0;
-            s_taLRF_CB[nAxis].nNewDataMonitorCount = 0;
-        }
-        else
-        {
-            if (_nCurrData > s_taLRF_CB[nAxis].nMaxValue)
-                s_taLRF_CB[nAxis].nMaxValue = _nCurrData;
-            else if (_nCurrData < s_taLRF_CB[nAxis].nMinValue)
-                s_taLRF_CB[nAxis].nMinValue = _nCurrData;
-            
-            if (s_taLRF_CB[nAxis].nMinValue != s_taLRF_CB[nAxis].nMaxValue)
-            {
-                if (_nCurrData == s_taLRF_CB[nAxis].nPreValue)
-                    s_taLRF_CB[nAxis].nNewDataMonitorCount++;
-                else
-                    s_taLRF_CB[nAxis].nNewDataMonitorCount = 0;
-            }
-        }
-        
-        if (1 != (s_taLRF_CB[nAxis].nMaxValue - s_taLRF_CB[nAxis].nMinValue))
-            s_taLRF_CB[nAxis].nRepValue = ((s_taLRF_CB[nAxis].nMaxValue + s_taLRF_CB[nAxis].nMinValue) / 2);
-        
-        _nSumDiff = (_nCurrDiff + s_taLRF_CB[nAxis].nPreDiff);
-        
-        if (_nCurrDiff)
-            s_taLRF_CB[nAxis].nPreDiff = _nCurrDiff;
-        
-        if ((_LRF_DIFF_BOUNDARY_NEG < _nSumDiff) && (_nSumDiff < _LRF_DIFF_BOUNDARY_POS))
-        {
-            if (_LRF_DIFF_DATA_UNCHANGE_MAX_COUNT > s_taLRF_CB[nAxis].nNewDataMonitorCount)
-            {
-                naData[nAxis] = s_taLRF_CB[nAxis].nRepValue;
-                goto _LRF_RETURN;
-            }
-        }
-    }
-    
-    s_taLRF_CB[nAxis].nRepValue   = _nCurrData;
-    s_taLRF_CB[nAxis].nPreDiff    = 0;
-    s_taLRF_CB[nAxis].nIsNewRound = 1;
-    
-_LRF_RETURN:
-    
-    GSE_LOG(">>>>> [_MC3XXX_LowResFilter][%d] _nCurrDiff: %4d       _nSumDiff: %4d         _nCurrData:    %4d         Rep:    %4d\n", nAxis, _nCurrDiff, _nSumDiff, _nCurrData, s_taLRF_CB[nAxis].nRepValue);
-    
-    s_taLRF_CB[nAxis].nPreValue = _nCurrData;
-    
-    #undef _LRF_DIFF_COUNT_POS
-    #undef _LRF_DIFF_COUNT_NEG
-    #undef _LRF_DIFF_BOUNDARY_POS
-    #undef _LRF_DIFF_BOUNDARY_NEG
-    #undef _LRF_DIFF_DATA_UNCHANGE_MAX_COUNT
-}
-#endif    // END OF #ifdef _MC3XXX_SUPPORT_LRF_
-
-/*****************************************
- *** _MC3XXX_ReadData_RBM2RAW
- *****************************************/
-static void    _MC3XXX_ReadData_RBM2RAW(s16 waData[MC3XXX_AXES_NUM])
-{
-    waData[MC3XXX_AXIS_X] = (waData[MC3XXX_AXIS_X] + offset_data[MC3XXX_AXIS_X] / 2) * 1024 / gain_data[MC3XXX_AXIS_X] + 8096;
-    waData[MC3XXX_AXIS_Y] = (waData[MC3XXX_AXIS_Y] + offset_data[MC3XXX_AXIS_Y] / 2) * 1024 / gain_data[MC3XXX_AXIS_Y] + 8096;
-    waData[MC3XXX_AXIS_Z] = (waData[MC3XXX_AXIS_Z] + offset_data[MC3XXX_AXIS_Z] / 2) * 1024 / gain_data[MC3XXX_AXIS_Z] + 8096;
-
-    GSE_LOG("RBM->RAW <<<<<[%08d %08d %08d]\n", waData[MC3XXX_AXIS_X], waData[MC3XXX_AXIS_Y], waData[MC3XXX_AXIS_Z]);
-
-    iAReal0_X             = (0x0010 * waData[MC3XXX_AXIS_X]);
-    iAcc1Lpf0_X           = GetLowPassFilter(iAReal0_X,iAcc1Lpf1_X);
-    iAcc0Lpf0_X           = GetLowPassFilter(iAcc1Lpf0_X,iAcc0Lpf1_X);
-    waData[MC3XXX_AXIS_X] = (iAcc0Lpf0_X / 0x0010);
-    
-    iAReal0_Y             = (0x0010 * waData[MC3XXX_AXIS_Y]);
-    iAcc1Lpf0_Y           = GetLowPassFilter(iAReal0_Y,iAcc1Lpf1_Y);
-    iAcc0Lpf0_Y           = GetLowPassFilter(iAcc1Lpf0_Y,iAcc0Lpf1_Y);
-    waData[MC3XXX_AXIS_Y] = (iAcc0Lpf0_Y / 0x0010);
-    
-    iAReal0_Z             = (0x0010 * waData[MC3XXX_AXIS_Z]);
-    iAcc1Lpf0_Z           = GetLowPassFilter(iAReal0_Z,iAcc1Lpf1_Z);
-    iAcc0Lpf0_Z           = GetLowPassFilter(iAcc1Lpf0_Z,iAcc0Lpf1_Z);
-    waData[MC3XXX_AXIS_Z] = (iAcc0Lpf0_Z / 0x0010);
-    
-    GSE_LOG("RBM->RAW->LPF <<<<<[%08d %08d %08d]\n", waData[MC3XXX_AXIS_X], waData[MC3XXX_AXIS_Y], waData[MC3XXX_AXIS_Z]);	
-
-    waData[MC3XXX_AXIS_X] = (waData[MC3XXX_AXIS_X] - 8096) * gsensor_gain.x / 1024;
-    waData[MC3XXX_AXIS_Y] = (waData[MC3XXX_AXIS_Y] - 8096) * gsensor_gain.y / 1024;
-    waData[MC3XXX_AXIS_Z] = (waData[MC3XXX_AXIS_Z] - 8096) * gsensor_gain.z / 1024;
-
-    GSE_LOG("RBM->RAW->LPF->RAW <<<<<[%08d %08d %08d]\n", waData[MC3XXX_AXIS_X], waData[MC3XXX_AXIS_Y], waData[MC3XXX_AXIS_Z]);
-
-    iAcc0Lpf1_X=iAcc0Lpf0_X;
-    iAcc1Lpf1_X=iAcc1Lpf0_X;
-    iAcc0Lpf1_Y=iAcc0Lpf0_Y;
-    iAcc1Lpf1_Y=iAcc1Lpf0_Y;
-    iAcc0Lpf1_Z=iAcc0Lpf0_Z;
-    iAcc1Lpf1_Z=iAcc1Lpf0_Z;
-}
-
-/*****************************************
- *** MC3XXX_ReadData
- *****************************************/
-static int    MC3XXX_ReadData(struct i2c_client *pt_i2c_client, s16 waData[MC3XXX_AXES_NUM])
-{
-    u8    _baData[MC3XXX_DATA_LEN] = { 0 };
-
-    GSE_LOG("[%s] s_nIsRBM_Enabled: %d\n", __FUNCTION__, s_nIsRBM_Enabled);
-
-    if (NULL == pt_i2c_client)
-    {
-        GSE_ERR("ERR: Null Pointer\n");	
-
-        return (MC3XXX_RETCODE_ERROR_NULL_POINTER);
-    }
-	
-    if (!s_nIsRBM_Enabled)
-    {
-        if (MC3XXX_RESOLUTION_LOW == s_bResolution)
-        {
-            if (hwmsen_read_block(pt_i2c_client, MC3XXX_REG_XOUT, _baData, MC3XXX_LOW_REOLUTION_DATA_SIZE))
-            {
-                GSE_ERR("ERR: fail to read data via I2C!\n");
-
-                return (MC3XXX_RETCODE_ERROR_I2C);
-            }
-    
-            waData[MC3XXX_AXIS_X] = ((s8) _baData[0]);
-            waData[MC3XXX_AXIS_Y] = ((s8) _baData[1]);
-            waData[MC3XXX_AXIS_Z] = ((s8) _baData[2]);	 
-    
-            GSE_LOG("[%s][low] X: %d, Y: %d, Z: %d\n", __FUNCTION__, waData[MC3XXX_AXIS_X], waData[MC3XXX_AXIS_Y], waData[MC3XXX_AXIS_Z]);
-
-
-            #ifdef _MC3XXX_SUPPORT_LRF_
-                _MC3XXX_LowResFilter(MC3XXX_AXIS_X, waData);
-                _MC3XXX_LowResFilter(MC3XXX_AXIS_Y, waData);
-                _MC3XXX_LowResFilter(MC3XXX_AXIS_Z, waData);
-            #endif
-        }
-        else if (MC3XXX_RESOLUTION_HIGH == s_bResolution)
-        {
-            if (hwmsen_read_block(pt_i2c_client, MC3XXX_REG_XOUT_EX_L, _baData, MC3XXX_HIGH_REOLUTION_DATA_SIZE))
-            {
-                GSE_ERR("ERR: fail to read data via I2C!\n");
-
-                return (MC3XXX_RETCODE_ERROR_I2C);
-            }
-        
-            waData[MC3XXX_AXIS_X] = ((signed short) ((_baData[0]) | (_baData[1]<<8)));
-            waData[MC3XXX_AXIS_Y] = ((signed short) ((_baData[2]) | (_baData[3]<<8)));
-            waData[MC3XXX_AXIS_Z] = ((signed short) ((_baData[4]) | (_baData[5]<<8)));
-        
-            GSE_LOG("[%s][high] X: %d, Y: %d, Z: %d\n", __FUNCTION__, waData[MC3XXX_AXIS_X], waData[MC3XXX_AXIS_Y], waData[MC3XXX_AXIS_Z]);
-        }
-
-        GSE_LOG("RAW<<<<<[%04d %04d %04d]\n", waData[MC3XXX_AXIS_X], waData[MC3XXX_AXIS_Y], waData[MC3XXX_AXIS_Z]);
-
-        #ifdef _MC3XXX_SUPPORT_LPF_
-        {
-            struct mc3xxx_i2c_data   *_ptPrivData = i2c_get_clientdata(pt_i2c_client);  
-
-            MC3XXX_LPF(_ptPrivData, waData);
-            GSE_LOG("LPF<<<<<[%04d %04d %04d]\n", waData[MC3XXX_AXIS_X], waData[MC3XXX_AXIS_Y], waData[MC3XXX_AXIS_Z]);
-        }
-        #endif
-    }
-    else
-    {
-        if (hwmsen_read_block(pt_i2c_client, MC3XXX_REG_XOUT_EX_L, _baData, MC3XXX_HIGH_REOLUTION_DATA_SIZE))
-        {
-            GSE_ERR("ERR: fail to read data via I2C!\n");
-
-            return (MC3XXX_RETCODE_ERROR_I2C);
-        }
-
-        waData[MC3XXX_AXIS_X] = ((s16)((_baData[0]) | (_baData[1] << 8)));
-        waData[MC3XXX_AXIS_Y] = ((s16)((_baData[2]) | (_baData[3] << 8)));
-        waData[MC3XXX_AXIS_Z] = ((s16)((_baData[4]) | (_baData[5] << 8)));
-
-        GSE_LOG("RBM<<<<<[%08d %08d %08d]\n", waData[MC3XXX_AXIS_X], waData[MC3XXX_AXIS_Y], waData[MC3XXX_AXIS_Z]);
-
-        _MC3XXX_ReadData_RBM2RAW(waData);
-    }
-
-    MCUBE_RREMAP(waData[MC3XXX_AXIS_X], waData[MC3XXX_AXIS_Y]);
-
-    return (MC3XXX_RETCODE_SUCCESS);
-}
-
-/*****************************************
- *** MC3XXX_ReadOffset
- *****************************************/
-static int MC3XXX_ReadOffset(struct i2c_client *client, s16 ofs[MC3XXX_AXES_NUM])
-{    
-	int err=0;
-	u8 off_data[6]={0};
-	
-
-	if (MC3XXX_RESOLUTION_HIGH == s_bResolution)
-	{
-		if ((err = hwmsen_read_block(client, MC3XXX_REG_XOUT_EX_L, off_data, MC3XXX_DATA_LEN))) 
-    	{
-    		GSE_ERR("error: %d\n", err);
-    		return err;
-    	}
-		ofs[MC3XXX_AXIS_X] = ((s16)(off_data[0]))|((s16)(off_data[1])<<8);
-		ofs[MC3XXX_AXIS_Y] = ((s16)(off_data[2]))|((s16)(off_data[3])<<8);
-		ofs[MC3XXX_AXIS_Z] = ((s16)(off_data[4]))|((s16)(off_data[5])<<8);
-	}
-	else if (MC3XXX_RESOLUTION_LOW == s_bResolution) 
-	{
-		if ((err = hwmsen_read_block(client, 0, off_data, 3))) 
-    	{
-    		GSE_ERR("error: %d\n", err);
-    		return err;
-    	}
-		ofs[MC3XXX_AXIS_X] = (s8)off_data[0];
-		ofs[MC3XXX_AXIS_Y] = (s8)off_data[1];
-		ofs[MC3XXX_AXIS_Z] = (s8)off_data[2];			
-	}
-
-	GSE_LOG("MC3XXX_ReadOffset %d %d %d \n",ofs[MC3XXX_AXIS_X] ,ofs[MC3XXX_AXIS_Y],ofs[MC3XXX_AXIS_Z]);
-
-    MCUBE_RREMAP(ofs[0], ofs[1]);
-
-    return err;  
-}
-
-/*****************************************
- *** MC3XXX_ResetCalibration
- *****************************************/
-static int MC3XXX_ResetCalibration(struct i2c_client *client)
-{
-	struct mc3xxx_i2c_data *obj = i2c_get_clientdata(client);
-	u8 buf[MC3XXX_AXES_NUM] = {0x00, 0x00, 0x00};
-	s16 tmp=0;
-	int err=0;
-
-    u8  bMsbFilter       = 0x3F;
-    s16 wSignBitMask     = 0x2000;
-    s16 wSignPaddingBits = 0xC000;
-
-	buf[0] = 0x43;
-	
-	if((err = hwmsen_write_block(client, 0x07, buf, 1)))
-	{
-		GSE_ERR("error 0x07: %d\n", err);
-	}
-
-
-	if((err = hwmsen_write_block(client, 0x21, offset_buf, 6))) // add by liang for writing offset register as OTP value 
-	{
-		GSE_ERR("error: %d\n", err);
-	}
-	
-	buf[0] = 0x41;
-
-	if((err = hwmsen_write_block(client, 0x07, buf, 1)))
-	{
-		GSE_ERR("error: %d\n", err);
-	}
-
-	msleep(20);
-
-    if (IS_MCFM12() || IS_MCFM3X())
-    {
-        bMsbFilter       = 0x7F;
-        wSignBitMask     = 0x4000;
-        wSignPaddingBits = 0x8000;
-    }
-
-	tmp = ((offset_buf[1] & bMsbFilter) << 8) + offset_buf[0];  // add by Liang for set offset_buf as OTP value 
-	if (tmp & wSignBitMask)
-		tmp |= wSignPaddingBits;
-	offset_data[0] = tmp;
-				
-	tmp = ((offset_buf[3] & bMsbFilter) << 8) + offset_buf[2];  // add by Liang for set offset_buf as OTP value 
-		if (tmp & wSignBitMask)
-			tmp |= wSignPaddingBits;
-	offset_data[1] = tmp;
-				
-	tmp = ((offset_buf[5] & bMsbFilter) << 8) + offset_buf[4];  // add by Liang for set offset_buf as OTP value 
-	if (tmp & wSignBitMask)
-		tmp |= wSignPaddingBits;
-	offset_data[2] = tmp;	
-
-	memset(obj->cali_sw, 0x00, sizeof(obj->cali_sw));
-
-	return err;  
-}
-
-/*****************************************
- *** MC3XXX_ReadCalibration
- *****************************************/
-static int MC3XXX_ReadCalibration(struct i2c_client *client, int dat[MC3XXX_AXES_NUM])
-{
-    struct mc3xxx_i2c_data *obj = i2c_get_clientdata(client);
-    int err =0;
-	
-    if ((err = MC3XXX_ReadOffset(client, obj->offset))) {
-        GSE_ERR("read offset fail, %d\n", err);
-        return err;
-    }    
-    
-    dat[MC3XXX_AXIS_X] = obj->offset[MC3XXX_AXIS_X];
-    dat[MC3XXX_AXIS_Y] = obj->offset[MC3XXX_AXIS_Y];
-    dat[MC3XXX_AXIS_Z] = obj->offset[MC3XXX_AXIS_Z];  
-
-	GSE_LOG("MC3XXX_ReadCalibration %d %d %d \n",dat[obj->cvt.map[MC3XXX_AXIS_X]] ,dat[obj->cvt.map[MC3XXX_AXIS_Y]],dat[obj->cvt.map[MC3XXX_AXIS_Z]]);
-                                      
-    return 0;
-}
-
-/*****************************************
- *** MC3XXX_WriteCalibration
- *****************************************/
-static int MC3XXX_WriteCalibration(struct i2c_client *client, int dat[MC3XXX_AXES_NUM])
-{
-    struct mc3xxx_i2c_data *obj = i2c_get_clientdata(client);
-    int err = 0;
-    u8 buf[9] ={ 0};
-    s16 tmp = 0, x_gain = 0, y_gain = 0, z_gain = 0;
-    s32 x_off = 0, y_off = 0, z_off = 0;
-    int cali[MC3XXX_AXES_NUM] = {0};
-    
-    u8  bMsbFilter       = 0x3F;
-    s16 wSignBitMask     = 0x2000;
-    s16 wSignPaddingBits = 0xC000;
-    s32 dwRangePosLimit  = 0x1FFF;
-    s32 dwRangeNegLimit  = -0x2000;
-    
-    GSE_LOG("UPDATE dat: (%+3d %+3d %+3d)\n", dat[MC3XXX_AXIS_X], dat[MC3XXX_AXIS_Y], dat[MC3XXX_AXIS_Z]);
-    
-    cali[MC3XXX_AXIS_X] = obj->cvt.sign[MC3XXX_AXIS_X]*(dat[obj->cvt.map[MC3XXX_AXIS_X]]);
-    cali[MC3XXX_AXIS_Y] = obj->cvt.sign[MC3XXX_AXIS_Y]*(dat[obj->cvt.map[MC3XXX_AXIS_Y]]);
-    cali[MC3XXX_AXIS_Z] = obj->cvt.sign[MC3XXX_AXIS_Z]*(dat[obj->cvt.map[MC3XXX_AXIS_Z]]);	
-    
-    MCUBE_WREMAP(cali[MC3XXX_AXIS_X], cali[MC3XXX_AXIS_Y]);
-    
-    GSE_LOG("UPDATE dat: (%+3d %+3d %+3d)\n", cali[MC3XXX_AXIS_X], cali[MC3XXX_AXIS_Y], cali[MC3XXX_AXIS_Z]);
-    
-    // read registers 0x21~0x29
-    if ((err = hwmsen_read_block(client, 0x21, buf, 3))) 
-    {
-        GSE_ERR("error: %d\n", err);
-        return err;
-    }
-    if ((err = hwmsen_read_block(client, 0x24, &buf[3], 3))) 
-    {
-        GSE_ERR("error: %d\n", err);
-        return err;
-    }
-    if ((err = hwmsen_read_block(client, 0x27, &buf[6], 3))) 
-    {
-        GSE_ERR("error: %d\n", err);
-        return err;
-    }
-    
-    if (IS_MCFM12() || IS_MCFM3X())
-    {
-        bMsbFilter       = 0x7F;
-        wSignBitMask     = 0x4000;
-        wSignPaddingBits = 0x8000;
-        dwRangePosLimit  = 0x3FFF;
-        dwRangeNegLimit  = -0x4000;
-    }
-    
-    // get x,y,z offset
-    tmp = ((buf[1] & bMsbFilter) << 8) + buf[0];
-    if (tmp & wSignBitMask)
-        tmp |= wSignPaddingBits;
-    x_off = tmp;
-    
-    tmp = ((buf[3] & bMsbFilter) << 8) + buf[2];
-    if (tmp & wSignBitMask)
-        tmp |= wSignPaddingBits;
-    y_off = tmp;
-    
-    tmp = ((buf[5] & bMsbFilter) << 8) + buf[4];
-    if (tmp & wSignBitMask)
-        tmp |= wSignPaddingBits;
-    z_off = tmp;
-    
-    // get x,y,z gain
-    x_gain = ((buf[1] >> 7) << 8) + buf[6];
-    y_gain = ((buf[3] >> 7) << 8) + buf[7];
-    z_gain = ((buf[5] >> 7) << 8) + buf[8];
-    
-    // prepare new offset
-    x_off = x_off + 16 * cali[MC3XXX_AXIS_X] * 256 * 128 / 3 / gsensor_gain.x / (40 + x_gain);
-    y_off = y_off + 16 * cali[MC3XXX_AXIS_Y] * 256 * 128 / 3 / gsensor_gain.y / (40 + y_gain);
-    z_off = z_off + 16 * cali[MC3XXX_AXIS_Z] * 256 * 128 / 3 / gsensor_gain.z / (40 + z_gain);
-    
-    //add for over range 
-    if( x_off > dwRangePosLimit) 
-    {
-        x_off = dwRangePosLimit;
-    }
-    else if( x_off < dwRangeNegLimit)
-    {
-        x_off = dwRangeNegLimit;
-    }
-    
-    if( y_off > dwRangePosLimit) 
-    {
-        y_off = dwRangePosLimit;
-    }
-    else if( y_off < dwRangeNegLimit)
-    {
-        y_off = dwRangeNegLimit;
-    }
-    
-    if( z_off > dwRangePosLimit) 
-    {
-        z_off = dwRangePosLimit;
-    }
-    else if( z_off < dwRangeNegLimit)
-    {
-        z_off = dwRangeNegLimit;
-    }
-    
-    //storege the cerrunt offset data with DOT format
-    offset_data[0] = x_off;
-    offset_data[1] = y_off;
-    offset_data[2] = z_off;
-    
-    //storege the cerrunt Gain data with GOT format
-    gain_data[0] = 256*8*128/3/(40+x_gain);
-    gain_data[1] = 256*8*128/3/(40+y_gain);
-    gain_data[2] = 256*8*128/3/(40+z_gain);
-    
-    buf[0]=0x43;
-    hwmsen_write_block(client, 0x07, buf, 1);
-    
-    buf[0] = x_off & 0xff;
-    buf[1] = ((x_off >> 8) & bMsbFilter) | (x_gain & 0x0100 ? 0x80 : 0);
-    buf[2] = y_off & 0xff;
-    buf[3] = ((y_off >> 8) & bMsbFilter) | (y_gain & 0x0100 ? 0x80 : 0);
-    buf[4] = z_off & 0xff;
-    buf[5] = ((z_off >> 8) & bMsbFilter) | (z_gain & 0x0100 ? 0x80 : 0);
-    
-    hwmsen_write_block(client, 0x21, buf, 6);
-    
-    buf[0]=0x41;
-    hwmsen_write_block(client, 0x07, buf, 1);		
-    
-    msleep(50);
-    
-    return err;
-}
-
-/*****************************************
- *** MC3XXX_SetPowerMode
- *****************************************/
-static int MC3XXX_SetPowerMode(struct i2c_client *client, bool enable)
-{
-    u8 databuf[2] = {0};    
-    int res = 0;
-    u8 addr = MC3XXX_REG_MODE_FEATURE;
-    struct mc3xxx_i2c_data *obj = i2c_get_clientdata(client);
-    
-    if(enable == mc3xxx_sensor_power)
-        GSE_LOG("Sensor power status should not be set again!!!\n");
-    
-    if(hwmsen_read_byte_sr(client, addr, databuf))
-    {
-        GSE_ERR("read power ctl register err!\n");
-        return MC3XXX_RETCODE_ERROR_I2C;
-    }
-
-    GSE_LOG("set power read MC3XXX_REG_MODE_FEATURE =%x\n", databuf[0]);   
-    
-    if(enable)
-    {
-        databuf[1] = 0x41;
-        databuf[0] = MC3XXX_REG_MODE_FEATURE;
-        res = i2c_master_send(client, databuf, 0x2);
-    
-        #ifdef _MC3XXX_SUPPORT_DOT_CALIBRATION_
-            mcube_load_cali(client);
-        #endif
-    }
-    else
-    {
-        databuf[1] = 0x43;
-        databuf[0] = MC3XXX_REG_MODE_FEATURE;
-        res = i2c_master_send(client, databuf, 0x2);
-    }
-    
-    if(res <= 0)
-    {
-        GSE_LOG("fwq set power mode failed!\n");
-        return MC3XXX_RETCODE_ERROR_I2C;
-    }
-    else if(atomic_read(&obj->trace) & MCUBE_TRC_INFO)
-    {
-        GSE_LOG("fwq set power mode ok %d!\n", databuf[1]);
-    }
-    
-    mc3xxx_sensor_power = enable;
-
-    return MC3XXX_RETCODE_SUCCESS;    
-}
-
-/*****************************************
- *** MC3XXX_SetResolution
- *****************************************/
-static void MC3XXX_SetResolution(void)
-{
-    GSE_LOG("[%s]\n", __FUNCTION__);
-
-    switch (s_bPCODE)
-    {
-    case MC3XXX_PCODE_3230:
-    case MC3XXX_PCODE_3430:
-    case MC3XXX_PCODE_3430N:
-    case MC3XXX_PCODE_3530:
-    case MC3XXX_PCODE_3236:
-         s_bResolution = MC3XXX_RESOLUTION_LOW;
-         break;
-
-    case MC3XXX_PCODE_3210:
-    case MC3XXX_PCODE_3250:
-    case MC3XXX_PCODE_3410:
-    case MC3XXX_PCODE_3410N:
-    case MC3XXX_PCODE_3510:
-    case MC3XXX_PCODE_3216:
-         s_bResolution = MC3XXX_RESOLUTION_HIGH;
-         break;
-
-    // === RESERVED ==================================BGN===
-    // === (move to normal section once it is confirmed) ===
-    case MC3XXX_PCODE_RESERVE_10:
-         GSE_ERR("RESERVED ONLINE!\n");
-         // TODO: should have a default configuration...
-         break;
-
-    case MC3XXX_PCODE_RESERVE_1:
-    case MC3XXX_PCODE_RESERVE_3:
-    case MC3XXX_PCODE_RESERVE_4:
-    case MC3XXX_PCODE_RESERVE_5:
-    case MC3XXX_PCODE_RESERVE_6:
-    case MC3XXX_PCODE_RESERVE_8:
-    case MC3XXX_PCODE_RESERVE_9:
-         GSE_ERR("RESERVED ONLINE!\n");
-         s_bResolution = MC3XXX_RESOLUTION_LOW;
-         break;
-
-    case MC3XXX_PCODE_RESERVE_2:
-    case MC3XXX_PCODE_RESERVE_7:
-         GSE_ERR("RESERVED ONLINE!\n");
-         s_bResolution = MC3XXX_RESOLUTION_HIGH;
-         break;
-    // === RESERVED ==================================END===
-
-    default:
-         GSE_ERR("ERR: no resolution assigned!\n");
-         break;
-    }
-
-    GSE_LOG("[%s] s_bResolution: %d\n", __FUNCTION__, s_bResolution);
-}
-
-/*****************************************
- *** MC3XXX_SetSampleRate
- *****************************************/
-static void MC3XXX_SetSampleRate(struct i2c_client *pt_i2c_client)
-{
-    unsigned char    _baDataBuf[2] = { 0 };
-
-    GSE_LOG("[%s]\n", __FUNCTION__);
-
-    _baDataBuf[0] = MC3XXX_REG_SAMPLE_RATE;
-    _baDataBuf[1] = 0x00;
-
-    if (IS_MCFM12() || IS_MCFM3X())
-    {
-        unsigned char    _baData2Buf[2] = { 0 };
-
-        _baData2Buf[0] = 0x2A;
-        i2c_master_send(pt_i2c_client, &(_baData2Buf[0]), 1);
-        i2c_master_recv(pt_i2c_client, &(_baData2Buf[0]), 1);
-
-        GSE_LOG("[%s] REG(0x2A) = 0x%02X\n", __FUNCTION__, _baData2Buf[0]);
-
-        _baData2Buf[0] = (_baData2Buf[0] & 0xC0);
-
-        switch (_baData2Buf[0])
-        {
-        case 0x00:    _baDataBuf[1] = 0x00;                                                    break;
-        case 0x40:    _baDataBuf[1] = 0x08;                                                    break;
-        case 0x80:    _baDataBuf[1] = 0x09;                                                    break;
-        case 0xC0:    _baDataBuf[1] = 0x0A;                                                    break;
-
-        default:      GSE_ERR("[%s] no chance to get here... check code!\n", __FUNCTION__);    break;
-        }
-    }
-
-    i2c_master_send(pt_i2c_client, _baDataBuf, 0x2);
-}
-
-/*****************************************
- *** MC3XXX_ConfigRegRange
- *****************************************/
-static void MC3XXX_ConfigRegRange(struct i2c_client *pt_i2c_client)
-{
-    unsigned char    _baDataBuf[2] = { 0 };
-
-    _baDataBuf[0] = MC3XXX_REG_RANGE_CONTROL;
-    _baDataBuf[1] = 0x3F;
-
-    if (MC3XXX_RESOLUTION_LOW == s_bResolution)
-        _baDataBuf[1] = 0x32;
-
-    if (IS_MCFM12() || IS_MCFM3X())
-    {
-        if (MC3XXX_RESOLUTION_LOW == s_bResolution)
-            _baDataBuf[1] = 0x02;
-        else
-            _baDataBuf[1] = 0x25;
-    }
-
-    i2c_master_send(pt_i2c_client, _baDataBuf, 0x2);
-
-    GSE_LOG("[%s] set 0x%X\n", __FUNCTION__, _baDataBuf[1]);
-}
-
-/*****************************************
- *** MC3XXX_SetGain
- *****************************************/
-static void MC3XXX_SetGain(void)
-{
-    gsensor_gain.x = gsensor_gain.y = gsensor_gain.z = 1024;
-
-    if (MC3XXX_RESOLUTION_LOW == s_bResolution)
-    {
-        gsensor_gain.x = gsensor_gain.y = gsensor_gain.z = 86;
-
-        if (IS_MCFM12() || IS_MCFM3X())
-        {
-            gsensor_gain.x = gsensor_gain.y = gsensor_gain.z = 64;
-        }
-    }
-    
-    GSE_LOG("[%s] gain: %d / %d / %d\n", __FUNCTION__, gsensor_gain.x, gsensor_gain.y, gsensor_gain.z);
-}
-
-/*****************************************
- *** MC3XXX_Init
- *****************************************/
-static int MC3XXX_Init(struct i2c_client *client, int reset_cali)
-{
-    unsigned char    _baDataBuf[2] = { 0 };
-
-    GSE_LOG("[%s]\n", __FUNCTION__);
-
-    #ifdef _MC3XXX_SUPPORT_POWER_SAVING_SHUTDOWN_POWER_
-        if (MC3XXX_RETCODE_SUCCESS != _mc3xxx_i2c_auto_probe(client))
-        {
-            //GSE_ERR("ERR: fail to probe mCube sensor!\n");
-            return (MC3XXX_RETCODE_ERROR_I2C);
-        }
-    
-        //GSE_LOG("[%s] confirmed i2c addr: 0x%X\n", __FUNCTION__, client->addr);
-    #endif
-
-    _baDataBuf[0] = MC3XXX_REG_MODE_FEATURE;
-    _baDataBuf[1] = 0x43;
-    i2c_master_send(client, _baDataBuf, 0x2);
-
-    MC3XXX_SetResolution();
-    MC3XXX_SetSampleRate(client);
-    MC3XXX_ConfigRegRange(client);
-    MC3XXX_SetGain();
-    
-    _baDataBuf[0] = MC3XXX_REG_TAP_DETECTION_ENABLE;
-    _baDataBuf[1] = 0x00;
-    i2c_master_send(client, _baDataBuf, 0x2);
-    
-    _baDataBuf[0] = MC3XXX_REG_INTERRUPT_ENABLE;
-    _baDataBuf[1] = 0x00;
-    i2c_master_send(client, _baDataBuf, 0x2);
-
-    _baDataBuf[0] = 0x2A;
-    i2c_master_send(client, &(_baDataBuf[0]), 1);
-    i2c_master_recv(client, &(_baDataBuf[0]), 1);
-    s_bMPOL = (_baDataBuf[0] & 0x03);
-
-    #ifdef _MC3XXX_SUPPORT_DOT_CALIBRATION_
-        MC3XXX_rbm(client,0);
-    #endif
-
-    #ifdef _MC3XXX_SUPPORT_LPF_
-    {
-        struct mc3xxx_i2c_data   *_pt_i2c_data = i2c_get_clientdata(client);
-
-        memset(&_pt_i2c_data->fir, 0x00, sizeof(_pt_i2c_data->fir));
-    }
-    #endif
-
-    #ifdef _MC3XXX_SUPPORT_LRF_
-        memset(&s_taLRF_CB, 0, sizeof(s_taLRF_CB));
-    #endif
-
-    #ifdef _MC3XXX_SUPPORT_PERIODIC_DOC_
-        init_waitqueue_head(&wq_mc3xxx_open_status);
-    #endif
-
-    GSE_LOG("[%s] init ok.\n", __FUNCTION__);
-
-    return (MC3XXX_RETCODE_SUCCESS);
-}
-
-/*****************************************
- *** MC3XXX_ReadChipInfo
- *****************************************/
-static int MC3XXX_ReadChipInfo(struct i2c_client *client, char *buf, int bufsize)
-{
-	if((NULL == buf)||(bufsize<=30))
-	{
-		return -1;
-	}
-	
-	if(NULL == client)
-	{
-		*buf = 0;
-		return -2;
-	}
-
-	sprintf(buf, "MC3XXX Chip");
-	return 0;
-}
-
-/*****************************************
- *** MC3XXX_ReadSensorData
- *****************************************/
-static int MC3XXX_ReadSensorData(struct i2c_client *pt_i2c_client, char *pbBuf, int nBufSize)
-{
-    int                       _naAccelData[MC3XXX_AXES_NUM] = { 0 };
-    struct mc3xxx_i2c_data   *_pt_i2c_obj = ((struct mc3xxx_i2c_data*) i2c_get_clientdata(pt_i2c_client));
-
-    GSE_LOG("[%s]\n", __FUNCTION__);	
-
-    if ((NULL == pt_i2c_client) || (NULL == pbBuf))
-    {
-        GSE_ERR("ERR: Null Pointer, pt_i2c_client: 0x%X, pbBuf: 0x%X\n", (unsigned int) pt_i2c_client, (unsigned int) pbBuf);	
-
-        return (MC3XXX_RETCODE_ERROR_NULL_POINTER);
-    }
-
-    if (false == mc3xxx_sensor_power)
-    {
-        if (MC3XXX_RETCODE_SUCCESS != MC3XXX_SetPowerMode(pt_i2c_client, true))
-            GSE_ERR("ERR: fail to set power mode!\n");
-    }
-
-    #ifdef _MC3XXX_SUPPORT_DOT_CALIBRATION_
-        mcube_load_cali(pt_i2c_client);
-    
-        if ((s_nIsRBM_Enabled) && (1 == LPF_FirstRun))
-        {
-            int    _nLoopIndex = 0;
-            
-            LPF_FirstRun = 0;
-            
-            for (_nLoopIndex = 0; _nLoopIndex < (LPF_SamplingRate + LPF_CutoffFrequency); _nLoopIndex++)
-                MC3XXX_ReadData(pt_i2c_client, _pt_i2c_obj->data);
-        }
-    #endif
-
-    if (MC3XXX_RETCODE_SUCCESS != MC3XXX_ReadData(pt_i2c_client, _pt_i2c_obj->data))
-    {        
-        GSE_ERR("ERR: fail to read data!\n");
-
-        return (MC3XXX_RETCODE_ERROR_I2C);
-    }
-
-    //output format: mg
-    GSE_LOG("[%s] raw data: %d, %d, %d\n", __FUNCTION__, _pt_i2c_obj->data[MC3XXX_AXIS_X], _pt_i2c_obj->data[MC3XXX_AXIS_Y], _pt_i2c_obj->data[MC3XXX_AXIS_Z]);
-    _naAccelData[(_pt_i2c_obj->cvt.map[MC3XXX_AXIS_X])] = (_pt_i2c_obj->cvt.sign[MC3XXX_AXIS_X] * _pt_i2c_obj->data[MC3XXX_AXIS_X]);
-    _naAccelData[(_pt_i2c_obj->cvt.map[MC3XXX_AXIS_Y])] = (_pt_i2c_obj->cvt.sign[MC3XXX_AXIS_Y] * _pt_i2c_obj->data[MC3XXX_AXIS_Y]);
-    _naAccelData[(_pt_i2c_obj->cvt.map[MC3XXX_AXIS_Z])] = (_pt_i2c_obj->cvt.sign[MC3XXX_AXIS_Z] * _pt_i2c_obj->data[MC3XXX_AXIS_Z]);
-    
-    GSE_LOG("[%s] map data: %d, %d, %d!\n", __FUNCTION__, _naAccelData[MC3XXX_AXIS_X], _naAccelData[MC3XXX_AXIS_Y], _naAccelData[MC3XXX_AXIS_Z]);
-    
-    _naAccelData[MC3XXX_AXIS_X] = (_naAccelData[MC3XXX_AXIS_X] * GRAVITY_EARTH_1000 / gsensor_gain.x);
-    _naAccelData[MC3XXX_AXIS_Y] = (_naAccelData[MC3XXX_AXIS_Y] * GRAVITY_EARTH_1000 / gsensor_gain.y);
-    _naAccelData[MC3XXX_AXIS_Z] = (_naAccelData[MC3XXX_AXIS_Z] * GRAVITY_EARTH_1000 / gsensor_gain.z);	
-    GSE_LOG("[%s] accel data: %d, %d, %d!\n", __FUNCTION__, _naAccelData[MC3XXX_AXIS_X], _naAccelData[MC3XXX_AXIS_Y], _naAccelData[MC3XXX_AXIS_Z]);
-		
-    sprintf(pbBuf, "%04x %04x %04x", _naAccelData[MC3XXX_AXIS_X], _naAccelData[MC3XXX_AXIS_Y], _naAccelData[MC3XXX_AXIS_Z]);
-
-    return (MC3XXX_RETCODE_SUCCESS);
-}
-
-/*****************************************
- *** _MC3XXX_ReadAverageData
- *****************************************/
-#ifdef _MC3XXX_SUPPORT_APPLY_AVERAGE_AGORITHM_
-static int _MC3XXX_ReadAverageData(struct i2c_client *client, char *buf)
-{
-	struct mc3xxx_i2c_data *obj = (struct mc3xxx_i2c_data*)i2c_get_clientdata(client);
-	int acc[MC3XXX_AXES_NUM]={0};
-	s16 sensor_data[3]={0};
-	s16 sensor_data_max[3]={0};
-	s16 sensor_data_mini[3]={0};
-	s32 sensor_data_sum[3]={0};
-
-	int i = 0,j=0;
-
-	MC3XXX_ReadData(client, sensor_data);
-	GSE_LOG("MC3XXX_ReadRawData MC3XXX_ReadData: %d, %d, %d!\n", sensor_data[MC3XXX_AXIS_X], sensor_data[MC3XXX_AXIS_Y], sensor_data[MC3XXX_AXIS_Z]);
-	sensor_data_max[MC3XXX_AXIS_X]=sensor_data[MC3XXX_AXIS_X];
-	sensor_data_max[MC3XXX_AXIS_Y]=sensor_data[MC3XXX_AXIS_Y];
-	sensor_data_max[MC3XXX_AXIS_Z]=sensor_data[MC3XXX_AXIS_Z];
-	
-	sensor_data_mini[MC3XXX_AXIS_X]=sensor_data[MC3XXX_AXIS_X];
-	sensor_data_mini[MC3XXX_AXIS_Y]=sensor_data[MC3XXX_AXIS_Y];
-	sensor_data_mini[MC3XXX_AXIS_Z]=sensor_data[MC3XXX_AXIS_Z];
-	
-	sensor_data_sum[MC3XXX_AXIS_X]+=sensor_data[MC3XXX_AXIS_X];
-	sensor_data_sum[MC3XXX_AXIS_Y]+=sensor_data[MC3XXX_AXIS_Y];
-	sensor_data_sum[MC3XXX_AXIS_Z]+=sensor_data[MC3XXX_AXIS_Z];
-	
-	for(i=0; i<11 ; i++)
-	{
-		MC3XXX_ReadData(client, sensor_data);
-		GSE_LOG("MC3XXX_ReadRawData MC3XXX_ReadData: %d, %d, %d!\n", sensor_data[MC3XXX_AXIS_X], sensor_data[MC3XXX_AXIS_Y], sensor_data[MC3XXX_AXIS_Z]);
-		
-		sensor_data_sum[MC3XXX_AXIS_X]+=sensor_data[MC3XXX_AXIS_X];
-		sensor_data_sum[MC3XXX_AXIS_Y]+=sensor_data[MC3XXX_AXIS_Y];
-		sensor_data_sum[MC3XXX_AXIS_Z]+=sensor_data[MC3XXX_AXIS_Z];
-		for(j=0; j<3 ; j++)
-		{
-			if(sensor_data[j]>sensor_data_max[j])
-			{
-				sensor_data_max[j]=sensor_data[j];
-			}
-			if(sensor_data[j]<sensor_data_mini[j])
-			{
-				sensor_data_mini[j]=sensor_data[j];
-			}
-		}
-	}
-	GSE_LOG("MC3XXX_ReadRawData sensor_data_max: %d, %d, %d!\n", sensor_data_max[MC3XXX_AXIS_X], sensor_data_max[MC3XXX_AXIS_Y], sensor_data_max[MC3XXX_AXIS_Z]);
-	GSE_LOG("MC3XXX_ReadRawData sensor_data_mini: %d, %d, %d!\n", sensor_data_mini[MC3XXX_AXIS_X], sensor_data_mini[MC3XXX_AXIS_Y], sensor_data_mini[MC3XXX_AXIS_Z]);
-	sensor_data[MC3XXX_AXIS_X] = (s16)((sensor_data_sum[MC3XXX_AXIS_X]-sensor_data_max[MC3XXX_AXIS_X]-sensor_data_mini[MC3XXX_AXIS_X])/10);
-	sensor_data[MC3XXX_AXIS_Y] = (s16)((sensor_data_sum[MC3XXX_AXIS_Y]-sensor_data_max[MC3XXX_AXIS_Y]-sensor_data_mini[MC3XXX_AXIS_Y])/10);
-	sensor_data[MC3XXX_AXIS_Z] = (s16)((sensor_data_sum[MC3XXX_AXIS_Z]-sensor_data_max[MC3XXX_AXIS_Z]-sensor_data_mini[MC3XXX_AXIS_Z])/10);
-	GSE_LOG("MC3XXX_ReadRawData sensor_data: %d, %d, %d!\n", sensor_data[MC3XXX_AXIS_X], sensor_data[MC3XXX_AXIS_Y], sensor_data[MC3XXX_AXIS_Z]);
-	
-	acc[(obj->cvt.map[MC3XXX_AXIS_X])] = obj->cvt.sign[MC3XXX_AXIS_X] * sensor_data[MC3XXX_AXIS_X];
-	acc[(obj->cvt.map[MC3XXX_AXIS_Y])] = obj->cvt.sign[MC3XXX_AXIS_Y] * sensor_data[MC3XXX_AXIS_Y];
-	acc[(obj->cvt.map[MC3XXX_AXIS_Z])] = obj->cvt.sign[MC3XXX_AXIS_Z] * sensor_data[MC3XXX_AXIS_Z];
-	
-	GSE_LOG("MC3XXX_ReadRawData mapdata: %d, %d, %d!\n", acc[MC3XXX_AXIS_X], acc[MC3XXX_AXIS_Y], acc[MC3XXX_AXIS_Z]);
-	
-	acc[MC3XXX_AXIS_X] = (acc[MC3XXX_AXIS_X]*GRAVITY_EARTH_1000/gsensor_gain.x);
-	acc[MC3XXX_AXIS_Y] = (acc[MC3XXX_AXIS_Y]*GRAVITY_EARTH_1000/gsensor_gain.y);
-	acc[MC3XXX_AXIS_Z] = (acc[MC3XXX_AXIS_Z]*GRAVITY_EARTH_1000/gsensor_gain.z);	
-	
-	GSE_LOG("MC3XXX_ReadRawData mapdata1: %d, %d, %d!\n", acc[MC3XXX_AXIS_X], acc[MC3XXX_AXIS_Y], acc[MC3XXX_AXIS_Z]);
-	
-	sprintf(buf, "%04x %04x %04x", acc[MC3XXX_AXIS_X], acc[MC3XXX_AXIS_Y], acc[MC3XXX_AXIS_Z]);
-
-	return 0;
-}
-#endif    // END OF #ifdef _MC3XXX_SUPPORT_APPLY_AVERAGE_AGORITHM_
-
-/*****************************************
- *** MC3XXX_ReadRawData
- *****************************************/
-static int MC3XXX_ReadRawData(struct i2c_client *client, char *buf)
-{
-	int res = 0;
-
-	if (!buf || !client)
-	{
-		return EINVAL;
-	}
-
-	if(mc3xxx_sensor_power == false)
-	{
-		res = MC3XXX_SetPowerMode(client, true);
-		if(res)
-		{
-			GSE_ERR("Power on mc3xxx error %d!\n", res);
-		}
-	}
-
-	#ifdef _MC3XXX_SUPPORT_APPLY_AVERAGE_AGORITHM_
-		return (_MC3XXX_ReadAverageData(client, buf));
-	#else
-	{
-		s16 sensor_data[3]={0};
-	
-		if((res = MC3XXX_ReadData(client, sensor_data)))
-		{        
-			GSE_ERR("I2C error: ret value=%d", res);
-			return EIO;
-		}
-		else
-		{
-			sprintf(buf, "%04x %04x %04x", sensor_data[MC3XXX_AXIS_X], 
-			sensor_data[MC3XXX_AXIS_Y], sensor_data[MC3XXX_AXIS_Z]);
-		}
-	}
-	#endif
-	
-	return 0;
-}
-
-#ifdef _MC3XXX_SUPPORT_DOT_CALIBRATION_
-/*****************************************
- *** MC3XXX_ReadRBMData
- *****************************************/
-static int MC3XXX_ReadRBMData(struct i2c_client *client, char *buf)
-{
-	int res = 0;
-	int data[3] = { 0 };
-
-	if (!buf || !client)
-	{
-		return EINVAL;
-	}
-
-	if(mc3xxx_sensor_power == false)
-	{
-		res = MC3XXX_SetPowerMode(client, true);
-		if(res)
-		{
-			GSE_ERR("Power on mc3xxx error %d!\n", res);
-		}
-	}
-	
-	if((res = MC3XXX_ReadData_RBM(client, data)))
-	{        
-		GSE_ERR("I2C error: ret value=%d", res);
-		return EIO;
-	}
-	else
-	{
-		sprintf(buf, "%04x %04x %04x", data[MC3XXX_AXIS_X], 
-			data[MC3XXX_AXIS_Y], data[MC3XXX_AXIS_Z]);
-	
-	}
-	
-	return res;
-}
-#endif // _MC3XXX_SUPPORT_DOT_CALIBRATION_
-
-/*****************************************
- *** MC3XXX_JudgeTestResult
- *****************************************/
-static int MC3XXX_JudgeTestResult(struct i2c_client *client)
-{
-    int    res                  = 0;
-    int    self_result          = 0;
-    s16    acc[MC3XXX_AXES_NUM] = { 0 };
-	
-    if((res = MC3XXX_ReadData(client, acc)))
-    {        
-        GSE_ERR("I2C error: ret value=%d", res);
-        return EIO;
-    }
-    else
-    {			
-        acc[MC3XXX_AXIS_X] = acc[MC3XXX_AXIS_X] * 1000 / gsensor_gain.x;
-        acc[MC3XXX_AXIS_Y] = acc[MC3XXX_AXIS_Y] * 1000 / gsensor_gain.y;
-        acc[MC3XXX_AXIS_Z] = acc[MC3XXX_AXIS_Z] * 1000 / gsensor_gain.z;
-        
-        self_result = (  (acc[MC3XXX_AXIS_X] * acc[MC3XXX_AXIS_X])
-                       + (acc[MC3XXX_AXIS_Y] * acc[MC3XXX_AXIS_Y])
-                       + (acc[MC3XXX_AXIS_Z] * acc[MC3XXX_AXIS_Z]));
-        
-        if ( (self_result > 475923) && (self_result < 2185360) )    //between 0.7g and 1.5g 
-        {												 
-            GSE_ERR("MC3XXX_JudgeTestResult successful\n");
-            return MC3XXX_RETCODE_SUCCESS;
-        }
-        else
-        {
-            GSE_ERR("MC3XXX_JudgeTestResult failt\n");
-            return -EINVAL;
-        }
-    }
-}
-
-/*****************************************
- *** MC3XXX_SelfCheck
- *****************************************/
-static void MC3XXX_SelfCheck(struct i2c_client *client, u8 *pUserBuf)
-{
-    u8    _bRData1 = 0;
-    u8    _bRData2 = 0;
-    u8    _bRData3 = 0;
-    u8    _baDataBuf[2] = { 0 };
-
-    hwmsen_read_block(client, 0x20, &_bRData1, 1);
-    hwmsen_read_block(client, 0x3B, &_bRData2, 1);
-
-    _baDataBuf[0] = 0x43;
-    hwmsen_write_block(client, 0x07, _baDataBuf, 1);
-
-    mdelay(10);
-
-    for ( ; ; )
-    {
-        _baDataBuf[0] = 0x6D;
-        hwmsen_write_block(client, 0x1B, _baDataBuf, 1);
-        
-        _baDataBuf[0] = 0x43;
-        hwmsen_write_block(client, 0x1B, _baDataBuf, 1);
-
-        _bRData3 = 0x00;
-        hwmsen_read_block(client, 0x04, &_bRData3, 1);
-
-        if (_bRData3 & 0x40)
-            break;
-    }
-
-    _baDataBuf[0] = (_bRData2 & 0xFE);
-    hwmsen_write_block(client, 0x3B, _baDataBuf, 1);
-
-    _baDataBuf[0] = 0x03;
-    hwmsen_write_block(client, 0x20, _baDataBuf, 1);
-
-    _baDataBuf[0] = 0x40;
-    hwmsen_write_block(client, 0x14, _baDataBuf, 1);
-
-    mdelay(10);
-
-    _baDataBuf[0] = pUserBuf[0];
-    hwmsen_write_block(client, 0x00, _baDataBuf, 1);
-
-    _baDataBuf[0] = 0x41;
-    hwmsen_write_block(client, 0x07, _baDataBuf, 1);
-
-    mdelay(10);
-
-    _baDataBuf[0] = 0x43;
-    hwmsen_write_block(client, 0x07, _baDataBuf, 1);
-
-    mdelay(10);
-
-    MC3XXX_Read_Reg_Map(client, pUserBuf);
-
-    mdelay(10);
-
-    _baDataBuf[0] = 0x00;
-    hwmsen_write_block(client, 0x14, _baDataBuf, 1);
-
-    _baDataBuf[0] = _bRData1;
-    hwmsen_write_block(client, 0x20, _baDataBuf, 1);
-
-    _baDataBuf[0] = _bRData2;
-    hwmsen_write_block(client, 0x3B, _baDataBuf, 1);
-
-    mdelay(10);
-
-    for ( ; ; )
-    {
-        _baDataBuf[0] = 0x6D;
-        hwmsen_write_block(client, 0x1B, _baDataBuf, 1);
-        
-        _baDataBuf[0] = 0x43;
-        hwmsen_write_block(client, 0x1B, _baDataBuf, 1);
-
-        _bRData3 = 0xFF;
-        hwmsen_read_block(client, 0x04, &_bRData3, 1);
-        
-        if (!(_bRData3 & 0x40))
-            break;
-    }
-
-    mdelay(10);
-}
-
-/*****************************************
- *** MC3XXX_GetOpenStatus
- *****************************************/
-#ifdef _MC3XXX_SUPPORT_PERIODIC_DOC_
-static int    MC3XXX_GetOpenStatus(void)
-{
-    //GSE_LOG("[%s] %d\n", __FUNCTION__, atomic_read(&s_t_mc3xxx_open_status));
-
-    wait_event_interruptible(wq_mc3xxx_open_status, (atomic_read(&s_t_mc3xxx_open_status) != 0));
-
-    //GSE_LOG("[%s] pass wait_event_interruptible: %d\n", __FUNCTION__, atomic_read(&s_t_mc3xxx_open_status));
-    
-    return (atomic_read(&s_t_mc3xxx_open_status));
-}
-#endif
-
-/*****************************************
- *** show_chipinfo_value
- *****************************************/
-static ssize_t show_chipinfo_value(struct device_driver *ddri, char *buf)
-{
-	struct i2c_client *client = mc3xxx_i2c_client;
-	char strbuf[MC3XXX_BUF_SIZE]={0};
-    GSE_LOG("fwq show_chipinfo_value \n");
-	if(NULL == client)
-	{
-		GSE_ERR("i2c client is null!!\n");
-		return 0;
-	}
-	
-	MC3XXX_ReadChipInfo(client, strbuf, MC3XXX_BUF_SIZE);
-	return snprintf(buf, PAGE_SIZE, "%s\n", strbuf);        
-}
-
-/*****************************************
- *** show_sensordata_value
- *****************************************/
-static ssize_t show_sensordata_value(struct device_driver *ddri, char *buf)
-{
-	struct i2c_client *client = mc3xxx_i2c_client;
-	char strbuf[MC3XXX_BUF_SIZE] = { 0 };
-	
-	if(NULL == client)
-	{
-		GSE_ERR("i2c client is null!!\n");
-		return 0;
-	}
-
-    MC3XXX_MUTEX_LOCK();
-	MC3XXX_ReadSensorData(client, strbuf, MC3XXX_BUF_SIZE);
-    MC3XXX_MUTEX_UNLOCK();
-	return snprintf(buf, PAGE_SIZE, "%s\n", strbuf);            
-}
-
-/*****************************************
- *** show_cali_value
- *****************************************/
-static ssize_t show_cali_value(struct device_driver *ddri, char *buf)
-{
-	struct i2c_client *client = mc3xxx_i2c_client;
-	struct mc3xxx_i2c_data *obj;
-	int err = 0;
-	int len = 0;
-	int mul = 0;
-	int tmp[MC3XXX_AXES_NUM] = { 0 };
-
-    GSE_LOG("fwq show_cali_value \n");
-
-	if(NULL == client)
-	{
-		GSE_ERR("i2c client is null!!\n");
-		return 0;
-	}
-
-	obj = (struct mc3xxx_i2c_data*) i2c_get_clientdata(client);
-
-	
-	if((err = MC3XXX_ReadOffset(client, obj->offset)))
-	{
-		return -EINVAL;
-	}
-	else if((err = MC3XXX_ReadCalibration(client, tmp)))
-	{
-		return -EINVAL;
-	}
-	else
-	{    
-// +++ 20130104 -- obj->reso is no longer used, replaced by gensor_gain to avoid system crash		
-		//mul = obj->reso->sensitivity/mc3xxx_offset_resolution.sensitivity;
-		mul = gsensor_gain.x /mc3xxx_offset_resolution.sensitivity;
-		/*len += snprintf(buf+len, PAGE_SIZE-len, "[HW ][%d] (%+3d, %+3d, %+3d) : (0x%02X, 0x%02X, 0x%02X)\n", mul,                        
-			obj->offset[MC3XXX_AXIS_X], obj->offset[MC3XXX_AXIS_Y], obj->offset[MC3XXX_AXIS_Z],
-			obj->offset[MC3XXX_AXIS_X], obj->offset[MC3XXX_AXIS_Y], obj->offset[MC3XXX_AXIS_Z]);
-		*/	
-// +++ 20130104 -- obj->reso is no longer used, replaced by gensor_gain to avoid system crash
-		len += snprintf(buf+len, PAGE_SIZE-len, "[HW] (%+3d, %+3d, %+3d) : (0x%02X, 0x%02X, 0x%02X)\n",                        
-			obj->offset[MC3XXX_AXIS_X], obj->offset[MC3XXX_AXIS_Y], obj->offset[MC3XXX_AXIS_Z],
-			obj->offset[MC3XXX_AXIS_X], obj->offset[MC3XXX_AXIS_Y], obj->offset[MC3XXX_AXIS_Z]);
-			
-		len += snprintf(buf+len, PAGE_SIZE-len, "[SW][%d] (%+3d, %+3d, %+3d)\n", 1, 
-			obj->cali_sw[MC3XXX_AXIS_X], obj->cali_sw[MC3XXX_AXIS_Y], obj->cali_sw[MC3XXX_AXIS_Z]);
-
-		len += snprintf(buf+len, PAGE_SIZE-len, "[ALL]  (%+3d, %+3d, %+3d) : (%+3d, %+3d, %+3d)\n", 
-			obj->offset[MC3XXX_AXIS_X]*mul + obj->cali_sw[MC3XXX_AXIS_X],
-			obj->offset[MC3XXX_AXIS_Y]*mul + obj->cali_sw[MC3XXX_AXIS_Y],
-			obj->offset[MC3XXX_AXIS_Z]*mul + obj->cali_sw[MC3XXX_AXIS_Z],
-			tmp[MC3XXX_AXIS_X], tmp[MC3XXX_AXIS_Y], tmp[MC3XXX_AXIS_Z]);
-		
-		return len;
-    }
-}
-
-/*****************************************
- *** store_cali_value
- *****************************************/
-static ssize_t store_cali_value(struct device_driver *ddri, const char *buf, size_t count)
-{
-	struct i2c_client *client = mc3xxx_i2c_client;  
-	int err=0;
-	int x=0;
-	int y=0;
-	int z=0;
-	int dat[MC3XXX_AXES_NUM]={0};
-
-	if(!strncmp(buf, "rst", 3))
-	{
-        MC3XXX_MUTEX_LOCK();
-		err = MC3XXX_ResetCalibration(client);
-        MC3XXX_MUTEX_UNLOCK();
-
-		if (err)
-			GSE_ERR("reset offset err = %d\n", err);
-	}
-	else if(3 == sscanf(buf, "0x%02X 0x%02X 0x%02X", &x, &y, &z))
-	{
-		dat[MC3XXX_AXIS_X] = x;
-		dat[MC3XXX_AXIS_Y] = y;
-		dat[MC3XXX_AXIS_Z] = z;
-
-        MC3XXX_MUTEX_LOCK();
-		err = MC3XXX_WriteCalibration(client, dat);
-        MC3XXX_MUTEX_UNLOCK();
-
-		if (err)
-			GSE_ERR("write calibration err = %d\n", err);
-	}
-	else
-	{
-		GSE_ERR("invalid format\n");
-	}
-	
-	return count;
-}
-
-/*****************************************
- *** show_selftest_value
- *****************************************/
-static ssize_t show_selftest_value(struct device_driver *ddri, char *buf)
-{
-    struct i2c_client *client = mc3xxx_i2c_client;
-
-    if (NULL == client)
-    {
-        GSE_ERR("i2c client is null!!\n");
-        return 0;
-    }
-
-    return snprintf(buf, 8, "%s\n", selftestRes);
-}
-
-/*****************************************
- *** store_selftest_value
- *****************************************/
-static ssize_t store_selftest_value(struct device_driver *ddri, const char *buf, size_t count)
-{   /*write anything to this register will trigger the process*/
-    struct i2c_client *client = mc3xxx_i2c_client;  
-    int num = 0;
-    
-    if (1 != sscanf(buf, "%d", &num))
-    {
-        GSE_ERR("parse number fail\n");
-        return count;
-    }
-    else if(0 == num)
-    {
-        GSE_ERR("invalid data count\n");
-        return count;
-    }
-       
-    GSE_LOG("NORMAL:\n");
-    MC3XXX_MUTEX_LOCK();
-    MC3XXX_SetPowerMode(client, true); 
-    MC3XXX_MUTEX_UNLOCK();
-    GSE_LOG("SELFTEST:\n");    
-    
-    if (!MC3XXX_JudgeTestResult(client))
-    {
-        GSE_LOG("SELFTEST : PASS\n");
-        strcpy(selftestRes,"y");
-    }	
-    else
-    {
-        GSE_LOG("SELFTEST : FAIL\n");		
-        strcpy(selftestRes,"n");
-    }
-    
-    return count;
-}
-
-/*****************************************
- *** show_firlen_value
- *****************************************/
-static ssize_t show_firlen_value(struct device_driver *ddri, char *buf)
-{
-    #ifdef _MC3XXX_SUPPORT_LPF_
-        struct i2c_client *client = mc3xxx_i2c_client;
-        struct mc3xxx_i2c_data *obj = i2c_get_clientdata(client);
-        GSE_LOG("fwq show_firlen_value \n");
-        if(atomic_read(&obj->firlen))
-        {
-            int idx = 0, len = atomic_read(&obj->firlen);
-            GSE_LOG("len = %2d, idx = %2d\n", obj->fir.num, obj->fir.idx);
-            
-            for(idx = 0; idx < len; idx++)
-            {
-                GSE_LOG("[%5d %5d %5d]\n", obj->fir.raw[idx][MC3XXX_AXIS_X], obj->fir.raw[idx][MC3XXX_AXIS_Y], obj->fir.raw[idx][MC3XXX_AXIS_Z]);
-            }
-            
-            GSE_LOG("sum = [%5d %5d %5d]\n", obj->fir.sum[MC3XXX_AXIS_X], obj->fir.sum[MC3XXX_AXIS_Y], obj->fir.sum[MC3XXX_AXIS_Z]);
-            GSE_LOG("avg = [%5d %5d %5d]\n", obj->fir.sum[MC3XXX_AXIS_X]/len, obj->fir.sum[MC3XXX_AXIS_Y]/len, obj->fir.sum[MC3XXX_AXIS_Z]/len);
-        }
-        return snprintf(buf, PAGE_SIZE, "%d\n", atomic_read(&obj->firlen));
-    #else
-        GSE_LOG("fwq show_firlen_value \n");
-        return snprintf(buf, PAGE_SIZE, "not support\n");
-    #endif
-}
-
-/*****************************************
- *** store_firlen_value
- *****************************************/
-static ssize_t store_firlen_value(struct device_driver *ddri, const char *buf, size_t count)
-{
-    #ifdef _MC3XXX_SUPPORT_LPF_
-    struct i2c_client *client = mc3xxx_i2c_client;  
-    struct mc3xxx_i2c_data *obj = i2c_get_clientdata(client);
-    int firlen = 0;
-
-    GSE_LOG("fwq store_firlen_value \n");
-    
-    if(1 != sscanf(buf, "%d", &firlen))
-    {
-	GSE_ERR("invallid format\n");
-    }
-    else if(firlen > C_MAX_FIR_LENGTH)
-    {
-	GSE_ERR("exceeds maximum filter length\n");
-    }
-    else
-    { 
-        atomic_set(&obj->firlen, firlen);
-	if(0 == firlen)
-	{
-		atomic_set(&obj->fir_en, 0);
-	}
-	else
-	{
-		memset(&obj->fir, 0x00, sizeof(obj->fir));
-		atomic_set(&obj->fir_en, 1);
-	}
-    }
-    #endif    
-    return count;
-}
-
-/*****************************************
- *** show_trace_value
- *****************************************/
-static ssize_t show_trace_value(struct device_driver *ddri, char *buf)
-{
-	ssize_t res = 0;
-	struct mc3xxx_i2c_data *obj = mc3xxx_obj_i2c_data;
-
-    GSE_LOG("fwq show_trace_value \n");
-
-	if (obj == NULL)
-	{
-		GSE_ERR("i2c_data obj is null!!\n");
-		return 0;
-	}
-	
-	res = snprintf(buf, PAGE_SIZE, "0x%04X\n", atomic_read(&obj->trace));     
-	return res;    
-}
-
-/*****************************************
- *** store_trace_value
- *****************************************/
-static ssize_t store_trace_value(struct device_driver *ddri, const char *buf, size_t count)
-{
-	struct mc3xxx_i2c_data *obj = mc3xxx_obj_i2c_data;
-	int trace = 0;
-
-    GSE_LOG("fwq store_trace_value \n");
-
-	if (obj == NULL)
-	{
-		GSE_ERR("i2c_data obj is null!!\n");
-		return 0;
-	}
-	
-	if(1 == sscanf(buf, "0x%x", &trace))
-	{
-		atomic_set(&obj->trace, trace);
-	}	
-	else
-	{
-		GSE_ERR("invalid content: '%s', length = %d\n", buf, count);
-	}
-	
-	return count;    
-}
-
-/*****************************************
- *** show_status_value
- *****************************************/
-static ssize_t show_status_value(struct device_driver *ddri, char *buf)
-{
-	ssize_t len = 0;    
-	struct mc3xxx_i2c_data *obj = mc3xxx_obj_i2c_data;
-
-    GSE_LOG("fwq show_status_value \n");
-
-	if (obj == NULL)
-	{
-		GSE_ERR("i2c_data obj is null!!\n");
-		return 0;
-	}	
-	
-	if(obj->hw)
-	{
-		len += snprintf(buf+len, PAGE_SIZE-len, "CUST: %d %d (%d %d)\n", 
-	            obj->hw->i2c_num, obj->hw->direction, obj->hw->power_id, obj->hw->power_vol);   
-	}
-	else
-	{
-		len += snprintf(buf+len, PAGE_SIZE-len, "CUST: NULL\n");
-	}
-	return len;    
-}
-
-/*****************************************
- *** show_power_status
- *****************************************/
-static ssize_t show_power_status(struct device_driver *ddri, char *buf)
-{
-	ssize_t res = 0;
-	u8 uData = 0;
-	struct mc3xxx_i2c_data *obj = mc3xxx_obj_i2c_data;
-
-	if (obj == NULL)
-	{
-		GSE_ERR("i2c_data obj is null!!\n");
-		return 0;
-	}
-	hwmsen_read_byte(obj->client, MC3XXX_REG_MODE_FEATURE, &uData);
-	
-	res = snprintf(buf, PAGE_SIZE, "0x%04X\n", uData);     
-	return res;   
-}
-
-/*****************************************
- *** show_version_value
- *****************************************/
-static ssize_t show_version_value(struct device_driver *ddri, char *buf)
-{
-	if ( 1 == VIRTUAL_Z)	
-		return snprintf(buf, PAGE_SIZE, "%s\n", MC3XXX_DEV_DRIVER_VERSION_VIRTUAL_Z);
-	else
-		return snprintf(buf, PAGE_SIZE, "%s\n", MC3XXX_DEV_DRIVER_VERSION);	
-}
-
-/*****************************************
- *** show_chip_id
- *****************************************/
-static ssize_t show_chip_id(struct device_driver *ddri, char *buf)
-{
-	struct mc3xxx_i2c_data   *_pt_i2c_data = mc3xxx_obj_i2c_data;
-
-	return MC3XXX_Read_Chip_ID(_pt_i2c_data->client, buf);
-}
-
-/*****************************************
- *** show_virtual_z
- *****************************************/
-static ssize_t show_virtual_z(struct device_driver *ddri, char *buf)
-{
-	return snprintf(buf, PAGE_SIZE, "%s\n", VIRTUAL_Z == 1 ? "Virtual Z Support": "No Virtual Z Support");     
-}
-
-/*****************************************
- *** show_regiter_map
- *****************************************/
-static ssize_t show_regiter_map(struct device_driver *ddri, char *buf)
-{
-    u8         _bIndex       = 0;
-    u8         _baRegMap[64] = { 0 };
-    ssize_t    _tLength      = 0;
-
-    struct i2c_client *client = mc3xxx_i2c_client;
-
-    if ((0xA5 == buf[0]) && (0x7B == buf[1]) && (0x40 == buf[2]))
-    {
-        MC3XXX_MUTEX_LOCK();
-        MC3XXX_Read_Reg_Map(client, buf);
-        MC3XXX_MUTEX_UNLOCK();
-
-        buf[0x21] = s_baOTP_OffsetData[0];
-        buf[0x22] = s_baOTP_OffsetData[1];
-        buf[0x23] = s_baOTP_OffsetData[2];
-        buf[0x24] = s_baOTP_OffsetData[3];
-        buf[0x25] = s_baOTP_OffsetData[4];
-        buf[0x26] = s_baOTP_OffsetData[5];
-
-        _tLength = 64;
-    }
-    else
-    {
-        MC3XXX_MUTEX_LOCK();
-        MC3XXX_Read_Reg_Map(client, _baRegMap);
-        MC3XXX_MUTEX_UNLOCK();
-    
-        for (_bIndex = 0; _bIndex < 64; _bIndex++)
-            _tLength += snprintf((buf + _tLength), (PAGE_SIZE - _tLength), "Reg[0x%02X]: 0x%02X\n", _bIndex, _baRegMap[_bIndex]); 
-    }
-
-    return (_tLength);
-}
-
-/*****************************************
- *** store_regiter_map
- *****************************************/
-static ssize_t store_regiter_map(struct device_driver *ddri, const char *buf, size_t count)
-{
-    // reserved
-    //GSE_LOG("[%s] buf[0]: 0x%02X\n", __FUNCTION__, buf[0]);
-
-    return count;
-}
-
-/*****************************************
- *** show_chip_orientation
- *****************************************/
-static ssize_t show_chip_orientation(struct device_driver *ptDevDrv, char *pbBuf)
-{
-    ssize_t          _tLength = 0;
-    struct acc_hw   *_ptAccelHw = mc3xxx_get_cust_acc_hw();
-    
-    GSE_LOG("[%s] default direction: %d\n", __FUNCTION__, _ptAccelHw->direction);
-    
-    _tLength = snprintf(pbBuf, PAGE_SIZE, "default direction = %d\n", _ptAccelHw->direction);     
-    
-    return (_tLength);    
-}
-
-/*****************************************
- *** store_chip_orientation
- *****************************************/
-static ssize_t store_chip_orientation(struct device_driver *ptDevDrv, const char *pbBuf, size_t tCount)
-{
-    int                       _nDirection = 0;
-    struct mc3xxx_i2c_data   *_pt_i2c_obj = mc3xxx_obj_i2c_data;
-
-    if (NULL == _pt_i2c_obj)
-        return (0);
-
-    if (1 == sscanf(pbBuf, "%d", &_nDirection))
-    {
-        if (hwmsen_get_convert(_nDirection, &_pt_i2c_obj->cvt))
-            GSE_ERR("ERR: fail to set direction\n");
-    }
-
-    GSE_LOG("[%s] set direction: %d\n", __FUNCTION__, _nDirection);
-
-    return (tCount);
-}
-
-/*****************************************
- *** show_accuracy_status
- *****************************************/
-static ssize_t show_accuracy_status(struct device_driver *ddri, char *buf)
-{
-	return snprintf(buf, PAGE_SIZE, "%d\n", s_bAccuracyStatus);     
-}
-
-/*****************************************
- *** store_accuracy_status
- *****************************************/
-static ssize_t store_accuracy_status(struct device_driver *ddri, const char *buf, size_t count)
-{
-    int    _nAccuracyStatus = 0;
-    
-    if (1 != sscanf(buf, "%d", &_nAccuracyStatus))
-    {
-        GSE_ERR("incorrect argument\n");
-        return count;
-    }
-
-    if (SENSOR_STATUS_ACCURACY_HIGH < _nAccuracyStatus)
-    {
-        GSE_ERR("illegal accuracy status\n");
-        return count;
-    }
-
-    s_bAccuracyStatus = ((int8_t) _nAccuracyStatus);
-
-    return count;
-}
-
-/*****************************************
- *** show_selfcheck_value
- *****************************************/
-static ssize_t show_selfcheck_value(struct device_driver *ptDevDriver, char *pbBuf)
-{
-    struct i2c_client   *_pt_i2c_client = mc3xxx_i2c_client;
-
-    //GSE_LOG("[%s] 0x%02X\n", __FUNCTION__, pbBuf[0]);
-
-    MC3XXX_MUTEX_LOCK();
-    MC3XXX_SelfCheck(_pt_i2c_client, pbBuf);
-    MC3XXX_Init(_pt_i2c_client, 0);
-    MC3XXX_MUTEX_UNLOCK();
-
-	return (64);
-}
-
-/*****************************************
- *** store_selfcheck_value
- *****************************************/
-static ssize_t store_selfcheck_value(struct device_driver *ddri, const char *buf, size_t count)
-{
-    // reserved
-    //GSE_LOG("[%s] buf[0]: 0x%02X\n", __FUNCTION__, buf[0]);
-
-    return count;
-}
-
-/*****************************************
- *** show_chip_validate_value
- *****************************************/
-static ssize_t show_chip_validate_value(struct device_driver *ptDevDriver, char *pbBuf)
-{
-    unsigned char    _bChipValidation = 0;
-
-    _bChipValidation = MC3XXX_ValidateSensorIC(&s_bPCODE, &s_bHWID);
-
-    return snprintf(pbBuf, PAGE_SIZE, "%d\n", _bChipValidation);        
-}
-
-/*****************************************
- *** show_pdoc_enable_value
- *****************************************/
-static ssize_t show_pdoc_enable_value(struct device_driver *ptDevDriver, char *pbBuf)
-{
-    #ifdef _MC3XXX_SUPPORT_PERIODIC_DOC_
-        return snprintf(pbBuf, PAGE_SIZE, "%d\n", s_bIsPDOC_Enabled);        
-    #else
-        unsigned char    _bIsPDOC_Enabled = false;
-        
-        return snprintf(pbBuf, PAGE_SIZE, "%d\n", _bIsPDOC_Enabled);		 
-    #endif
-}
-
-/*****************************************
- *** DRIVER ATTRIBUTE LIST TABLE
- *****************************************/
-static DRIVER_ATTR(chipinfo   ,           S_IRUGO, show_chipinfo_value,   NULL                  );
-static DRIVER_ATTR(sensordata ,           S_IRUGO, show_sensordata_value, NULL                  );
-static DRIVER_ATTR(cali       , S_IWUSR | S_IRUGO, show_cali_value,       store_cali_value      );
-static DRIVER_ATTR(selftest   , S_IWUSR | S_IRUGO, show_selftest_value,   store_selftest_value  );
-static DRIVER_ATTR(firlen     , S_IWUSR | S_IRUGO, show_firlen_value,     store_firlen_value    );
-static DRIVER_ATTR(trace      , S_IWUSR | S_IRUGO, show_trace_value,      store_trace_value     );
-static DRIVER_ATTR(status     ,           S_IRUGO, show_status_value,     NULL                  );
-static DRIVER_ATTR(power      ,           S_IRUGO, show_power_status,     NULL                  );
-static DRIVER_ATTR(version    ,           S_IRUGO, show_version_value,    NULL                  );
-static DRIVER_ATTR(chipid     ,           S_IRUGO, show_chip_id,          NULL                  );
-static DRIVER_ATTR(virtualz   ,           S_IRUGO, show_virtual_z,        NULL                  );
-static DRIVER_ATTR(regmap     , S_IWUSR | S_IRUGO, show_regiter_map,      store_regiter_map     );
-static DRIVER_ATTR(orientation, S_IWUSR | S_IRUGO, show_chip_orientation, store_chip_orientation);
-static DRIVER_ATTR(accuracy   , S_IWUSR | S_IRUGO, show_accuracy_status , store_accuracy_status );
-static DRIVER_ATTR(selfcheck  , S_IWUSR | S_IRUGO, show_selfcheck_value , store_selfcheck_value );
-static DRIVER_ATTR(validate   ,           S_IRUGO, show_chip_validate_value, NULL                  );
-static DRIVER_ATTR(pdoc       ,           S_IRUGO, show_pdoc_enable_value  , NULL                  );
-
-static struct driver_attribute   *mc3xxx_attr_list[] = {
-                                                           &driver_attr_chipinfo,
-                                                           &driver_attr_sensordata,
-                                                           &driver_attr_cali,
-                                                           &driver_attr_selftest,
-                                                           &driver_attr_firlen,
-                                                           &driver_attr_trace,
-                                                           &driver_attr_status,
-                                                           &driver_attr_power, 
-                                                           &driver_attr_version, 
-                                                           &driver_attr_chipid,
-                                                           &driver_attr_virtualz,
-                                                           &driver_attr_regmap,
-                                                           &driver_attr_orientation,
-                                                           &driver_attr_accuracy,
-                                                           &driver_attr_selfcheck,
-                                                           &driver_attr_validate,
-                                                           &driver_attr_pdoc,
-                                                       };
-
-/*****************************************
- *** mc3xxx_create_attr
- *****************************************/
-static int mc3xxx_create_attr(struct device_driver *driver) 
-{
-	int idx, err = 0;
-	int num = (int)(sizeof(mc3xxx_attr_list)/sizeof(mc3xxx_attr_list[0]));
-	if (driver == NULL)
-	{
-		return -EINVAL;
-	}
-
-	for(idx = 0; idx < num; idx++)
-	{
-		if((err = driver_create_file(driver, mc3xxx_attr_list[idx])))
-		{            
-			GSE_ERR("driver_create_file (%s) = %d\n", mc3xxx_attr_list[idx]->attr.name, err);
-			break;
-		}
-	}    
-	return err;
-}
-
-/*****************************************
- *** mc3xxx_delete_attr
- *****************************************/
-static int mc3xxx_delete_attr(struct device_driver *driver)
-{
-	int idx ,err = 0;
-	int num = (int)(sizeof(mc3xxx_attr_list)/sizeof(mc3xxx_attr_list[0]));
-
-	if(driver == NULL)
-	{
-		return -EINVAL;
-	}
-	
-
-	for(idx = 0; idx < num; idx++)
-	{
-		driver_remove_file(driver, mc3xxx_attr_list[idx]);
-	}
-	
-
-	return err;
-}
-
-/*****************************************
- *** gsensor_operate
- *****************************************/
-static int gsensor_operate(void* self, uint32_t command, void* buff_in, int size_in,
-		void* buff_out, int size_out, int* actualout)
-{
-	int err = 0;
-	int value = 0;	
-	struct mc3xxx_i2c_data *priv = (struct mc3xxx_i2c_data*)self;
-	hwm_sensor_data* gsensor_data = NULL;
-	char buff[MC3XXX_BUF_SIZE] = { 0 };
-	
-	GSE_FUN(f);
-	switch (command)
-	{
-		case SENSOR_DELAY:
-			GSE_LOG("fwq set delay\n");
-			if((buff_in == NULL) || (size_in < sizeof(int)))
-			{
-				GSE_ERR("Set delay parameter error!\n");
-				err = -EINVAL;
-			}
-			else
-			{
-				value = *(int *)buff_in;
-				if(value >= 50)
-				{
-				    atomic_set(&priv->filter, 0);
-				}
-				else
-				{			
-	    			    #if defined(_MC3XXX_SUPPORT_LPF_)  
-	 				priv->fir.num = 0;
-					priv->fir.idx = 0;
-					priv->fir.sum[MC3XXX_AXIS_X] = 0;
-					priv->fir.sum[MC3XXX_AXIS_Y] = 0;
-					priv->fir.sum[MC3XXX_AXIS_Z] = 0;
-					atomic_set(&priv->filter, 1);
-                                    #endif					
-				}
-			}
-			break;
-
-		case SENSOR_ENABLE:
-			if((buff_in == NULL) || (size_in < sizeof(int)))
-			{
-				GSE_ERR("Enable sensor parameter error!\n");
-				err = -EINVAL;
-			}
-			else
-			{
-				value = *(int *)buff_in;
-
-                GSE_LOG("fwq sensor enable gsensor: %d\n", value);
-
-				if(((value == 0) && (mc3xxx_sensor_power == false)) ||((value == 1) && (mc3xxx_sensor_power == true)))
-				{
-					GSE_LOG("Gsensor device have updated!\n");
-				}
-				else
-				{
-                    MC3XXX_MUTEX_LOCK();
-					err = MC3XXX_SetPowerMode( priv->client, !mc3xxx_sensor_power);
-                    MC3XXX_MUTEX_UNLOCK();
-				}
-            
-                #ifdef _MC3XXX_SUPPORT_PERIODIC_DOC_
-                    if (0 == value)
-                        atomic_set(&s_t_mc3xxx_open_status, 0);
-                    else
-                        atomic_set(&s_t_mc3xxx_open_status, 1);
-                    
-                    wake_up(&wq_mc3xxx_open_status);
-                #endif
-			}
-			break;
-
-		case SENSOR_GET_DATA:
-			GSE_LOG("fwq sensor operate get data\n");
-			if((buff_out == NULL) || (size_out< sizeof(hwm_sensor_data)))
-			{
-				GSE_ERR("get sensor data parameter error!\n");
-				err = -EINVAL;
-			}
-			else
-			{
-				gsensor_data = (hwm_sensor_data *)buff_out;
-                MC3XXX_MUTEX_LOCK();
-				MC3XXX_ReadSensorData(priv->client, buff, MC3XXX_BUF_SIZE);
-                MC3XXX_MUTEX_UNLOCK();
-				sscanf(buff, "%x %x %x", &gsensor_data->values[0], 
-					&gsensor_data->values[1], &gsensor_data->values[2]);				
-                gsensor_data->status = s_bAccuracyStatus;
-				gsensor_data->value_divide = 1000;
-				GSE_LOG("MC3XXX_ReadSensorData: X :%d,Y: %d, Z: %d\n",gsensor_data->values[0],gsensor_data->values[1],gsensor_data->values[2]);
-			}
-			break;
-		default:
-			GSE_ERR("gsensor operate function no this parameter %d!\n", command);
-			err = -1;
-			break;
-	}
-	
-	return err;
-}
-
-/*****************************************
- *** mc3xxx_open
- *****************************************/
-static int mc3xxx_open(struct inode *inode, struct file *file)
-{
-	file->private_data = mc3xxx_i2c_client;
-
-	if(file->private_data == NULL)
-	{
-		GSE_ERR("null pointer!!\n");
-		return -EINVAL;
-	}
-	return nonseekable_open(inode, file);
-}
-
-/*****************************************
- *** mc3xxx_release
- *****************************************/
-static int mc3xxx_release(struct inode *inode, struct file *file)
-{
-	file->private_data = NULL;
-	return 0;
-}
-
-/*****************************************
- *** mc3xxx_ioctl
- *****************************************/
-static long mc3xxx_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
-{
-	struct i2c_client *client = (struct i2c_client*)file->private_data;
-	struct mc3xxx_i2c_data *obj = (struct mc3xxx_i2c_data*)i2c_get_clientdata(client);	
-	char strbuf[MC3XXX_BUF_SIZE] = {0};
-	void __user *data = NULL;
-	SENSOR_DATA sensor_data = {0};
-	long err = 0;
-	int cali[3] = {0};
-
-        #ifdef _MC3XXX_SUPPORT_DOT_CALIBRATION_
-            int prod = -1;
-            int tempZ = 0;
-            unsigned char _bTempPCode = 0x00;
-        #endif
-
-	//GSE_FUN(f);
-	if(_IOC_DIR(cmd) & _IOC_READ)
-	{
-		err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
-	}
-	else if(_IOC_DIR(cmd) & _IOC_WRITE)
-	{
-		err = !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
-	}
-
-	if(err)
-	{
-		GSE_ERR("access error: %08X, (%2d, %2d)\n", cmd, _IOC_DIR(cmd), _IOC_SIZE(cmd));
-		return -EFAULT;
-	}
-
-	switch(cmd)
-	{
-		case GSENSOR_IOCTL_INIT:
-			GSE_LOG("fwq GSENSOR_IOCTL_INIT\n");
-            MC3XXX_MUTEX_LOCK();
-			MC3XXX_Init(client, 0);			
-            MC3XXX_MUTEX_UNLOCK();
-			break;
-
-		case GSENSOR_IOCTL_READ_CHIPINFO:
-			GSE_LOG("fwq GSENSOR_IOCTL_READ_CHIPINFO\n");
-			data = (void __user *) arg;
-			if(data == NULL)
-			{
-				err = -EINVAL;
-				break;	  
-			}
-			
-			MC3XXX_ReadChipInfo(client, strbuf, MC3XXX_BUF_SIZE);
-			if(copy_to_user(data, strbuf, strlen(strbuf)+1))
-			{
-				err = -EFAULT;
-				break;
-			}				 
-			break;	  
-
-		case GSENSOR_IOCTL_READ_SENSORDATA:
-			data = (void __user *) arg;
-			if(data == NULL)
-			{
-				err = -EINVAL;
-				break;	  
-			}
-            MC3XXX_MUTEX_LOCK();
-            #ifdef _MC3XXX_SUPPORT_APPLY_AVERAGE_AGORITHM_
-                MC3XXX_ReadRawData(client, strbuf);
-            #else
-                MC3XXX_ReadSensorData(client, strbuf, MC3XXX_BUF_SIZE);
-            #endif
-            MC3XXX_MUTEX_UNLOCK();
-			if(copy_to_user(data, strbuf, strlen(strbuf)+1))
-			{
-				err = -EFAULT;
-				break;	  
-			}				 
-			break;
-
-		case GSENSOR_IOCTL_READ_GAIN:
-			GSE_LOG("fwq GSENSOR_IOCTL_READ_GAIN\n");
-			data = (void __user *) arg;
-			if(data == NULL)
-			{
-				err = -EINVAL;
-				break;	  
-			}			
-			
-			if(copy_to_user(data, &gsensor_gain, sizeof(GSENSOR_VECTOR3D)))
-			{
-				err = -EFAULT;
-				break;
-			}				 
-			break;
-
-		case GSENSOR_IOCTL_READ_OFFSET:
-			GSE_LOG("fwq GSENSOR_IOCTL_READ_OFFSET\n");
-			data = (void __user *) arg;
-			if(data == NULL)
-			{
-				err = -EINVAL;
-				break;	  
-			}
-			
-			if(copy_to_user(data, &gsensor_offset, sizeof(GSENSOR_VECTOR3D)))
-			{
-				err = -EFAULT;
-				break;
-			}				 
-			break;
-
-		case GSENSOR_IOCTL_READ_RAW_DATA:
-			GSE_LOG("fwq GSENSOR_IOCTL_READ_RAW_DATA\n");
-			data = (void __user *) arg;
-			if(data == NULL)
-			{
-				err = -EINVAL;
-				break;	  
-			}
-            MC3XXX_MUTEX_LOCK();
-			MC3XXX_ReadRawData(client, strbuf);
-            MC3XXX_MUTEX_UNLOCK();
-			if(copy_to_user(data, strbuf, strlen(strbuf)+1))
-			{
-				err = -EFAULT;
-				break;	  
-			}
-			break;	  
-
-		case GSENSOR_IOCTL_SET_CALI:
-			GSE_LOG("fwq GSENSOR_IOCTL_SET_CALI!!\n");
-			data = (void __user*)arg;
-			if(data == NULL)
-			{
-				err = -EINVAL;
-				break;	  
-			}
-			if(copy_from_user(&sensor_data, data, sizeof(sensor_data)))
-			{
-				err = -EFAULT;
-				break;	  
-			}
-			if(atomic_read(&obj->suspend))
-			{
-				GSE_ERR("Perform calibration in suspend state!!\n");
-				err = -EINVAL;
-			}
-			else
-			{
-				obj->cali_sw[MC3XXX_AXIS_X] += sensor_data.x;
-				obj->cali_sw[MC3XXX_AXIS_Y] += sensor_data.y;
-				obj->cali_sw[MC3XXX_AXIS_Z] += sensor_data.z;
-				
-				cali[MC3XXX_AXIS_X] = sensor_data.x * gsensor_gain.x / GRAVITY_EARTH_1000;
-				cali[MC3XXX_AXIS_Y] = sensor_data.y * gsensor_gain.y / GRAVITY_EARTH_1000;
-				cali[MC3XXX_AXIS_Z] = sensor_data.z * gsensor_gain.z / GRAVITY_EARTH_1000;	
-			  
-                MC3XXX_MUTEX_LOCK();
-				err = MC3XXX_WriteCalibration(client, cali);			 
-                MC3XXX_MUTEX_UNLOCK();
-			}
-			break;
-
-		case GSENSOR_IOCTL_CLR_CALI:
-			GSE_LOG("fwq GSENSOR_IOCTL_CLR_CALI!!\n");
-            MC3XXX_MUTEX_LOCK();
-			err = MC3XXX_ResetCalibration(client);
-            MC3XXX_MUTEX_UNLOCK();
-			break;
-
-		case GSENSOR_IOCTL_GET_CALI:
-			GSE_LOG("fwq mc3xxx GSENSOR_IOCTL_GET_CALI\n");
-			data = (void __user*)arg;
-			if(data == NULL)
-			{
-				err = -EINVAL;
-				break;	  
-			}
-//			if((err = MC3XXX_ReadCalibration(client, cali)))
-//			{
-//				break;
-//			}
-
-			sensor_data.x = obj->cali_sw[MC3XXX_AXIS_X];
-			sensor_data.y = obj->cali_sw[MC3XXX_AXIS_Y];
-			sensor_data.z = obj->cali_sw[MC3XXX_AXIS_Z];
-			if(copy_to_user(data, &sensor_data, sizeof(sensor_data)))
-			{
-				err = -EFAULT;
-				break;
-			}		
-			break;
-
-        //add in Sensors_io.h
-        // ==============================================================================
-        #ifdef _MC3XXX_SUPPORT_DOT_CALIBRATION_
-        
-		case GSENSOR_MCUBE_IOCTL_SET_CALI:
-			GSE_LOG("fwq GSENSOR_MCUBE_IOCTL_SET_CALI!!\n");
-			data = (void __user*)arg;
-			if(data == NULL)
-			{
-				err = -EINVAL;
-				break;	  
-			}
-			if(copy_from_user(&sensor_data, data, sizeof(sensor_data)))
-			{
-				err = -EFAULT;
-				break;	  
-			}
-			if(atomic_read(&obj->suspend))
-			{
-				GSE_ERR("Perform calibration in suspend state!!\n");
-				err = -EINVAL;
-			}
-			else
-			{
-				cali[MC3XXX_AXIS_X] = sensor_data.x * gsensor_gain.x / GRAVITY_EARTH_1000;
-				cali[MC3XXX_AXIS_Y] = sensor_data.y * gsensor_gain.y / GRAVITY_EARTH_1000;
-				cali[MC3XXX_AXIS_Z] = sensor_data.z * gsensor_gain.z / GRAVITY_EARTH_1000;	
-			  
-                MC3XXX_MUTEX_LOCK();
-				err = MC3XXX_WriteCalibration(client, cali);			 
-                MC3XXX_MUTEX_UNLOCK();
-			}
-			break;
-
-		case GSENSOR_IOCTL_SET_CALI_MODE:
-			GSE_LOG("fwq mc3xxx GSENSOR_IOCTL_SET_CALI_MODE\n");
-			break;
-
-		case GSENSOR_MCUBE_IOCTL_READ_RBM_DATA:
-			GSE_LOG("fwq GSENSOR_MCUBE_IOCTL_READ_RBM_DATA\n");
-			data = (void __user *) arg;
-			if(data == NULL)
-			{
-				err = -EINVAL;
-				break;	  
-			}
-            MC3XXX_MUTEX_LOCK();
-			MC3XXX_ReadRBMData(client, strbuf);
-            MC3XXX_MUTEX_UNLOCK();
-			if(copy_to_user(data, strbuf, strlen(strbuf)+1))
-			{
-				err = -EFAULT;
-				break;	  
-			}
-			break;
-
-		case GSENSOR_MCUBE_IOCTL_SET_RBM_MODE:
-			GSE_LOG("fwq GSENSOR_MCUBE_IOCTL_SET_RBM_MODE\n");
-            MC3XXX_MUTEX_LOCK();
-			MC3XXX_rbm(client,1);
-            MC3XXX_MUTEX_UNLOCK();
-			break;
-
-		case GSENSOR_MCUBE_IOCTL_CLEAR_RBM_MODE:
-			GSE_LOG("fwq GSENSOR_MCUBE_IOCTL_CLEAR_RBM_MODE\n");
-            MC3XXX_MUTEX_LOCK();
-			MC3XXX_rbm(client,0);
-            MC3XXX_MUTEX_UNLOCK();
-			break;
-
-		case GSENSOR_MCUBE_IOCTL_REGISTER_MAP:
-			GSE_LOG("fwq GSENSOR_MCUBE_IOCTL_REGISTER_MAP\n");
-
-			MC3XXX_Read_Reg_Map(client, NULL);
-
-			break;
-
-		case GSENSOR_MCUBE_IOCTL_READ_PRODUCT_ID:
-			GSE_LOG("fwq GSENSOR_MCUBE_IOCTL_READ_PRODUCT_ID\n");
-			data = (void __user *) arg;
-			if(data == NULL)
-			{
-				err = -EINVAL;
-				break;	  
-			}
-
-            if (MC3XXX_RETCODE_SUCCESS != (prod = MC3XXX_ValidateSensorIC(&s_bPCODE, &s_bHWID)))
-				GSE_LOG("Not mCube accelerometers!\n");
-
-			if(copy_to_user(data, &prod, sizeof(prod)))
-			{
-				err = -EFAULT;
-				break;
-			}				 
-			break;
-
-		case GSENSOR_MCUBE_IOCTL_READ_FILEPATH:
-			GSE_LOG("fwq GSENSOR_MCUBE_IOCTL_READ_FILEPATH\n");
-			data = (void __user *) arg;
-			if(data == NULL)
-			{
-				err = -EINVAL;
-				break;	  
-			}
-			
-			if(copy_to_user(data, file_path, (strlen(file_path)+1)))
-			{
-				err = -EFAULT;
-				break;
-			}				 
-			break;		
-
-		case GSENSOR_MCUBE_IOCTL_VIRTUAL_Z:
-			GSE_LOG("fwq GSENSOR_MCUBE_IOCTL_VIRTUAL_Z\n");
-			data = (void __user *) arg;
-			tempZ = VIRTUAL_Z;
-			if(data == NULL)
-			{
-				err = -EINVAL;
-				break;	  
-			}
-			if(copy_to_user(data, &tempZ, sizeof(tempZ)))
-			{
-				err = -EFAULT;
-				break;
-			}				 
-			break;
-
-		case GSENSOR_MCUBE_IOCTL_READ_PCODE:
-			GSE_LOG("fwq GSENSOR_MCUBE_IOCTL_READ_PCODE\n");
-			data = (void __user *) arg;
-			if(data == NULL)
-			{
-				err = -EINVAL;
-				break;	  
-			}
-
-			_bTempPCode = s_bPCODE;
-			GSE_LOG("mCube PCode = %2x!\n", _bTempPCode);
-			if(copy_to_user(data, &_bTempPCode, sizeof(_bTempPCode)))
-			{
-				err = -EFAULT;
-				break;
-			}				 
-			break;
-
-        #endif    // END of _MC3XXX_SUPPORT_DOT_CALIBRATION_
-
-        // ==============================================================================
-        #ifdef _MC3XXX_SUPPORT_PERIODIC_DOC_
-        
-        case GSENSOR_MCUBE_IOCTL_GET_OFLAG:
-            {
-                int            _nSensorsOpenStatus = 0;
-                void __user   *_pArg = ((void __user *) arg);
-                
-                GSE_LOG("[%s] GSENSOR_MCUBE_IOCTL_GET_OFLAG\n", __func__);
-                
-                _nSensorsOpenStatus = MC3XXX_GetOpenStatus();			
-                
-                if(copy_to_user(_pArg, &_nSensorsOpenStatus, sizeof(_nSensorsOpenStatus)))
-                    return (-EFAULT);
-            }
-            break; 	   
-
-        #endif    // END of _MC3XXX_SUPPORT_PERIODIC_DOC_
-			
-		default:
-			GSE_ERR("unknown IOCTL: 0x%08x\n", cmd);
-			err = -ENOIOCTLCMD;
-			break;
-			
-	}
-
-	return err;
-}
-
-/*****************************************
- *** MC3XXX_reset
- *****************************************/
-static void MC3XXX_reset(struct i2c_client *client)
-{
-    unsigned char    _baBuf[2] = { 0 };
-    
-    _baBuf[1] = 0x43;
-    _baBuf[0] = MC3XXX_REG_MODE_FEATURE;
-    i2c_master_send(client, _baBuf, 0x2);
-    
-    hwmsen_read_block(client, 0x04, _baBuf, 0x01);
-    
-    if (0x00 == (_baBuf[0] & 0x40))
-    {
-        _baBuf[0] = 0x6D; 
-        hwmsen_write_block(client, 0x1B, _baBuf, 0x01);
-        
-        _baBuf[0] = 0x43; 
-        hwmsen_write_block(client, 0x1B, _baBuf, 0x01);
-    }
-    
-    _baBuf[0] = 0x43;
-    hwmsen_write_block(client, 0x07, _baBuf, 1);	
-    
-    _baBuf[0] = 0x80;
-    hwmsen_write_block(client, 0x1C, _baBuf, 1);	
-
-    _baBuf[0] = 0x80;
-    hwmsen_write_block(client, 0x17, _baBuf, 1);	
-
-    msleep(5);
-    
-    _baBuf[0] = 0x00;
-    hwmsen_write_block(client, 0x1C, _baBuf, 1);	
-
-    _baBuf[0] = 0x00;
-    hwmsen_write_block(client, 0x17, _baBuf, 1);	
-
-    msleep(5);
-    
-    hwmsen_read_block(client, 0x21, offset_buf, 6);
-    
-    hwmsen_read_block(client, 0x04, _baBuf, 0x01);
-    
-    if (_baBuf[0] & 0x40)
-    {
-        _baBuf[0] = 0x6D; 
-        hwmsen_write_block(client, 0x1B, _baBuf, 0x01);
-        
-        _baBuf[0] = 0x43; 
-        hwmsen_write_block(client, 0x1B, _baBuf, 0x01);
-    }
-    
-    _baBuf[1] = 0x41;
-    _baBuf[0] = MC3XXX_REG_MODE_FEATURE;
-    i2c_master_send(client, _baBuf, 0x2);
-}
-
-/*****************************************
- *** STRUCT:: mc3xxx_fops
- *****************************************/
-static struct file_operations    mc3xxx_fops = {
-                                                   .owner          = THIS_MODULE,
-                                                   .open           = mc3xxx_open,
-                                                   .release        = mc3xxx_release,
-                                                   .unlocked_ioctl = mc3xxx_ioctl,
-                                               };
-
-/*****************************************
- *** STRUCT:: mc3xxx_device
- *****************************************/
-static struct miscdevice    mc3xxx_device = {
-                                                .minor = MISC_DYNAMIC_MINOR,
-                                                .name  = "gsensor",
-                                                .fops  = &mc3xxx_fops,
-                                            };
-
-#ifndef CONFIG_HAS_EARLYSUSPEND
-/*****************************************
- *** mc3xxx_suspend
- *****************************************/
-static int mc3xxx_suspend(struct i2c_client *client, pm_message_t msg) 
-{
-	struct mc3xxx_i2c_data *obj = i2c_get_clientdata(client);    
-	int err = 0;
-	GSE_FUN();    
-
-	if(msg.event == PM_EVENT_SUSPEND)
-	{   
-		if(obj == NULL)
-		{
-			GSE_ERR("null pointer!!\n");
-			return -EINVAL;
-		}
-		
-		atomic_set(&obj->suspend, 1);
-
-        MC3XXX_MUTEX_LOCK();
-        err = MC3XXX_SetPowerMode(client, false);
-        MC3XXX_MUTEX_UNLOCK();
-
-        if (err)
-        {
-            GSE_ERR("write power control fail!!\n");
-            return err;
-        }     
-
-		MC3XXX_power(obj->hw, 0);
-	}
-	return err;
-}
-
-/*****************************************
- *** mc3xxx_resume
- *****************************************/
-static int mc3xxx_resume(struct i2c_client *client)
-{
-	struct mc3xxx_i2c_data *obj = i2c_get_clientdata(client);        
-	int err;
-	GSE_FUN();
-
-	if(obj == NULL)
-	{
-		GSE_ERR("null pointer!!\n");
-		return -EINVAL;
-	}
-
-	MC3XXX_power(obj->hw, 1);
-
-    MC3XXX_MUTEX_LOCK();
-    err = MC3XXX_Init(client, 0);
-
-    if(err)
-    {
-        MC3XXX_MUTEX_UNLOCK();
-        GSE_ERR("initialize client fail!!\n");
-        return err;        
-    }
-
-    err = MC3XXX_SetPowerMode(client, true);
-    MC3XXX_MUTEX_UNLOCK();
-
-    if (err)
-    {
-        GSE_ERR("write power control fail!!\n");
-        return err;
-    }     
-
-	atomic_set(&obj->suspend, 0);
-
-	return 0;
-}
-#else
-/*****************************************
- *** mc3xxx_early_suspend
- *****************************************/
-static void mc3xxx_early_suspend(struct early_suspend *h) 
-{
-	struct mc3xxx_i2c_data *obj = container_of(h, struct mc3xxx_i2c_data, early_drv);   
-	int err;
-	GSE_FUN();    
-
-	if(obj == NULL)
-	{
-		GSE_ERR("null pointer!!\n");
-		return;
-	}
-	atomic_set(&obj->suspend, 1); 
-	/*
-	if(err = hwmsen_write_byte(obj->client, MC3XXX_REG_POWER_CTL, 0x00))
-	{
-		GSE_ERR("write power control fail!!\n");
-		return;
-	}  
-	*/
-    MC3XXX_MUTEX_LOCK_RETURN_VOID();
-    err = MC3XXX_SetPowerMode(obj->client, false);
-    MC3XXX_MUTEX_UNLOCK();
-
-    if (err)
-    {
-        GSE_ERR("write power control fail!!\n");
-        return;
-    }     
-
-	MC3XXX_power(obj->hw, 0);
-}
-
-/*****************************************
- *** mc3xxx_late_resume
- *****************************************/
-static void mc3xxx_late_resume(struct early_suspend *h)
-{
-	struct mc3xxx_i2c_data *obj = container_of(h, struct mc3xxx_i2c_data, early_drv);         
-	int err;
-	GSE_FUN();
-
-	if(obj == NULL)
-	{
-		GSE_ERR("null pointer!!\n");
-		return;
-	}
-
-	MC3XXX_power(obj->hw, 1);
-
-    MC3XXX_MUTEX_LOCK_RETURN_VOID();
-    err = MC3XXX_Init(obj->client, 0);
-
-    if(err)
-    {
-        MC3XXX_MUTEX_UNLOCK();
-        GSE_ERR("initialize client fail!!\n");
-        return;
-    }
-
-    err = MC3XXX_SetPowerMode(obj->client, true);
-    MC3XXX_MUTEX_UNLOCK();
-
-    if (err)
-    {
-        GSE_ERR("write power control fail!!\n");
-        return;
-    }     
-
-
-	atomic_set(&obj->suspend, 0);    
-}
-#endif
-
-/*****************************************
- *** _mc3xxx_i2c_auto_probe
- *****************************************/
-static int _mc3xxx_i2c_auto_probe(struct i2c_client *client)
-{
-    #define _MC3XXX_I2C_PROBE_ADDR_COUNT_    (sizeof(mc3xxx_i2c_auto_probe_addr) / sizeof(mc3xxx_i2c_auto_probe_addr[0]))
-
-    unsigned char    _baData1Buf[2] = { 0 };
-    unsigned char    _baData2Buf[2] = { 0 };
-
-    int              _nCount = 0;
-    int              _naCheckCount[_MC3XXX_I2C_PROBE_ADDR_COUNT_] = { 0 };
-
-    //GSE_FUN();
-
-    memset(_naCheckCount, 0, sizeof(_naCheckCount));
-
-_I2C_AUTO_PROBE_RECHECK_:
-    s_bPCODE  = 0x00;
-    s_bPCODER = 0x00;
-    s_bHWID   = 0x00;
-
-    for (_nCount = 0; _nCount < _MC3XXX_I2C_PROBE_ADDR_COUNT_; _nCount++)
-    {
-        client->addr = mc3xxx_i2c_auto_probe_addr[_nCount];
-
-        //GSE_LOG("[%s][%d] probing addr: 0x%X\n", __FUNCTION__, _nCount, client->addr);
-
-        _baData1Buf[0] = 0x3B;
-        if (0 > i2c_master_send(client, &(_baData1Buf[0]), 1))
-        {
-            //GSE_ERR("ERR: addr: 0x%X fail to communicate-2!\n", client->addr);
-            continue;
-        }
-    
-        if (0 > i2c_master_recv(client, &(_baData1Buf[0]), 1))
-        {
-            //GSE_ERR("ERR: addr: 0x%X fail to communicate-3!\n", client->addr);
-            continue;
-        }
-
-        _naCheckCount[_nCount]++;
-
-        //GSE_LOG("[%s][%d] addr: 0x%X ok to read REG(0x3B): 0x%X\n", __FUNCTION__, _nCount, client->addr, _baData1Buf[0]);
-
-        if (0x00 == _baData1Buf[0])
-        {
-            if (1 == _naCheckCount[_nCount])
-            {
-                MC3XXX_reset(client);
-                msleep(3);
-                goto _I2C_AUTO_PROBE_RECHECK_;
-            }
-            else
-            {
-                continue;
-            }
-        }
-
-        _baData2Buf[0] = 0x18;
-        i2c_master_send(client, &(_baData2Buf[0]), 1);
-        i2c_master_recv(client, &(_baData2Buf[0]), 1);
-
-        s_bPCODER = _baData1Buf[0];
-
-        if (MC3XXX_RETCODE_SUCCESS == MC3XXX_ValidateSensorIC(&_baData1Buf[0], &_baData2Buf[0]))
-        {
-            s_bPCODE = _baData1Buf[0];
-            s_bHWID  = _baData2Buf[0];
-
-            MC3XXX_SaveDefaultOffset(client);
-
-            //GSE_LOG("[%s] addr: 0x%X confirmed ok to use. s_bPCODE: 0x%02X, s_bHWID: 0x%02X\n", __FUNCTION__, client->addr, s_bPCODE, s_bHWID);
-
-            return (MC3XXX_RETCODE_SUCCESS);
-        }
-    }
-
-    return (MC3XXX_RETCODE_ERROR_I2C);
-
-    #undef _MC3XXX_I2C_PROBE_ADDR_COUNT_
-}
-
-/*****************************************
- *** mc3xxx_i2c_probe
- *****************************************/
-static int mc3xxx_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
-{
-	struct i2c_client *new_client;
-	struct mc3xxx_i2c_data *obj;
-	struct hwmsen_object sobj;
-	int err = 0;
-	GSE_FUN();
-
-    if (MC3XXX_RETCODE_SUCCESS != _mc3xxx_i2c_auto_probe(client))
-    {
-        //GSE_ERR("ERR: fail to probe mCube sensor!\n");
-        goto exit;
-    }
-
-    //GSE_LOG("[%s] confirmed i2c addr: 0x%X\n", __FUNCTION__, client->addr);
-
-	if(!(obj = kzalloc(sizeof(*obj), GFP_KERNEL)))
-	{
-		err = -ENOMEM;
-		goto exit;
-	}
-	
-	memset(obj, 0, sizeof(struct mc3xxx_i2c_data));
-
-	obj->hw = mc3xxx_get_cust_acc_hw();
-	
-	if((err = hwmsen_get_convert(obj->hw->direction, &obj->cvt)))
-	{
-		GSE_ERR("invalid direction: %d\n", obj->hw->direction);
-		goto exit_kfree;
-	}
-
-	mc3xxx_obj_i2c_data = obj;
-	obj->client = client;
-	new_client = obj->client;
-	i2c_set_clientdata(new_client,obj);
-	
-	atomic_set(&obj->trace, 0);
-	atomic_set(&obj->suspend, 0);
-	
-    #ifdef _MC3XXX_SUPPORT_LPF_
-        if(obj->hw->firlen > C_MAX_FIR_LENGTH)
-        {
-            atomic_set(&obj->firlen, C_MAX_FIR_LENGTH);
-        }	
-        else
-        {
-            atomic_set(&obj->firlen, obj->hw->firlen);
-        }
-        
-        if(atomic_read(&obj->firlen) > 0)
-        {
-            atomic_set(&obj->fir_en, 1);
-        }
-    #endif
-
-	mc3xxx_i2c_client = new_client;	
-	
-	MC3XXX_reset(new_client);
-
-    if (MC3XXX_RETCODE_SUCCESS != _mc3xxx_i2c_auto_probe(client))
-    {
-        //GSE_ERR("ERR: fail to probe mCube sensor!\n");
-        goto exit_init_failed;
-    }
-
-    //GSE_LOG("[%s] 2nd confirmed i2c addr: 0x%X\n", __FUNCTION__, client->addr);
-
-    hwmsen_read_block(client, 0x21, offset_buf, 6);
-
-	if((err = MC3XXX_Init(new_client, 1)))
-	{
-		goto exit_init_failed;
-	}
-	
-    MC3XXX_MUTEX_INIT();
-
-	if((err = misc_register(&mc3xxx_device)))
-	{
-		GSE_ERR("mc3xxx_device register failed\n");
-		goto exit_misc_device_register_failed;
-	}
-
-    #ifdef _MC3XXX_SUPPORT_AUTO_DETECT_
-        if((err = mc3xxx_create_attr(&mc3xxx_init_info.platform_diver_addr->driver)))
-    #else
-        if((err = mc3xxx_create_attr(&mc3xxx_gsensor_driver.driver)))
-    #endif
-        {
-            GSE_ERR("create attribute err = %d\n", err);
-            goto exit_create_attr_failed;
-        }
-
-	sobj.self = obj;
-    sobj.polling = 1;
-    sobj.sensor_operate = gsensor_operate;
-
-	if((err = hwmsen_attach(ID_ACCELEROMETER, &sobj)))
-	{
-		GSE_ERR("attach fail = %d\n", err);
-		goto exit_hwmsen_attach_failed;
-	}
-
-    #ifdef _MC3XXX_SUPPORT_VPROXIMITY_SENSOR_
-    // p-sensor
-    {
-        struct hwmsen_object obj_ps;
-        
-        if((err = misc_register(&mcube_psensor_device)))
-        {
-            PS_ERR("mcube_psensor_device register failed\n");
-            goto exit_misc_device_psensor_register_failed;
-        }
-        
-        obj_ps.polling = 1;
-        obj_ps.sensor_operate = psensor_ps_operate;
-        
-        if((err = hwmsen_attach(ID_PROXIMITY, &obj_ps)))
-        {
-            PS_ERR("Proximity sensor attach fail = %d\n", err);
-            goto exit_hwmsen_attach_psensor_failed;
-        }
-    }
-    #endif
-
-    #ifdef CONFIG_HAS_EARLYSUSPEND
-        obj->early_drv.level    = EARLY_SUSPEND_LEVEL_DISABLE_FB - 1,
-        obj->early_drv.suspend  = mc3xxx_early_suspend,
-        obj->early_drv.resume   = mc3xxx_late_resume,    
-        register_early_suspend(&obj->early_drv);
-    #endif 
-
-	GSE_LOG("%s: OK\n", __func__);    
-    s_nInitFlag = MC3XXX_INIT_SUCC;
-	return 0;
-
-#ifdef _MC3XXX_SUPPORT_VPROXIMITY_SENSOR_
-exit_hwmsen_attach_psensor_failed:
-    misc_deregister(&mcube_psensor_device);
-exit_misc_device_psensor_register_failed:
-#endif    // END of _MC3XXX_SUPPORT_VPROXIMITY_SENSOR_
-
-exit_hwmsen_attach_failed:
-#ifndef _MC3XXX_SUPPORT_AUTO_DETECT_
-    mc3xxx_delete_attr(&mc3xxx_gsensor_driver.driver);
-#endif    // END of not _MC3XXX_SUPPORT_AUTO_DETECT_
-
-exit_create_attr_failed:
-	misc_deregister(&mc3xxx_device);
-
-exit_misc_device_register_failed:
-exit_init_failed:
-	//i2c_detach_client(new_client);
-
-exit_kfree:
-	kfree(obj);
-
-exit:
-	GSE_ERR("%s: err = %d\n", __func__, err);        
-	s_nInitFlag = MC3XXX_INIT_FAIL;
-
-	return err;
-}
-
-/*****************************************
- *** mc3xxx_i2c_remove
- *****************************************/
-static int mc3xxx_i2c_remove(struct i2c_client *client)
-{
-	int err = 0;	
-	
-    #ifdef _MC3XXX_SUPPORT_AUTO_DETECT_
-        if((err = mc3xxx_delete_attr(&mc3xxx_init_info.platform_diver_addr->driver)))
-    #else
-        if((err = mc3xxx_delete_attr(&mc3xxx_gsensor_driver.driver)))
-    #endif
-        {
-            GSE_ERR("mc3xxx_delete_attr fail: %d\n", err);
-        }
-	
-	if((err = misc_deregister(&mc3xxx_device)))
-	{
-		GSE_ERR("misc_deregister fail: %d\n", err);
-	}
-
-	if((err = hwmsen_detach(ID_ACCELEROMETER)))
-	{
-		GSE_ERR("hwmsen_detach fail: %d\n", err);
-	}
-
-    #ifdef _MC3XXX_SUPPORT_VPROXIMITY_SENSOR_
-        misc_deregister(&mcube_psensor_device);
-    #endif
-
-	mc3xxx_i2c_client = NULL;
-	i2c_unregister_device(client);
-	kfree(i2c_get_clientdata(client));
-
-	return 0;
-}
-
-/*****************************************
- *** mc3xxx_probe
- *****************************************/
-#ifndef _MC3XXX_SUPPORT_AUTO_DETECT_
-static int mc3xxx_probe(struct platform_device *pdev) 
-{
-	struct acc_hw *hw = mc3xxx_get_cust_acc_hw();
-	GSE_FUN();
-
-	MC3XXX_power(hw, 1);
-
-	if(i2c_add_driver(&mc3xxx_i2c_driver))
-	{
-		GSE_ERR("add driver error\n");
-
-		return -1;
-	}
-
-	return 0;
-}
-
-/*****************************************
- *** mc3xxx_remove
- *****************************************/
-static int mc3xxx_remove(struct platform_device *pdev)
-{
-    struct acc_hw *hw = mc3xxx_get_cust_acc_hw();
-
-    GSE_FUN();    
-    MC3XXX_power(hw, 0);    
-    i2c_del_driver(&mc3xxx_i2c_driver);
-
-    return 0;
-}
-
-/*****************************************
- *** PLATFORM_DRIVER:: mc3xxx_gsensor_driver
- *****************************************/
-static struct platform_driver    mc3xxx_gsensor_driver = {
-                                                             .probe  = mc3xxx_probe,
-                                                             .remove = mc3xxx_remove,    
-                                                             .driver = {
-                                                                           .name  = "gsensor",
-                                                                           .owner = THIS_MODULE,
-                                                                       }
-                                                         };
-#else    // else from _MC3XXX_SUPPORT_AUTO_DETECT_
-/*****************************************
- *** mc3xxx_remove
- *****************************************/
-static int mc3xxx_remove(void)
-{
-    struct acc_hw *hw = mc3xxx_get_cust_acc_hw();
-    
-    GSE_FUN();    
-
-    MC3XXX_power(hw, 0);    
-    i2c_del_driver(&mc3xxx_i2c_driver);
-
-    return 0;
-}
-
-/*****************************************
- *** mc3xxx_local_init
- *****************************************/
-static int  mc3xxx_local_init(void)
-{
-    struct acc_hw *hw = mc3xxx_get_cust_acc_hw();
-    
-    GSE_FUN();    
-    MC3XXX_power(hw, 1);    
-    
-    if(i2c_add_driver(&mc3xxx_i2c_driver))
-    {
-        GSE_ERR("add driver error\n");
-        return -1;
-    }
-
-    if(MC3XXX_INIT_FAIL == s_nInitFlag)
-    {
-        return -1;
-    }
-    
-    return 0;
-}
-#endif
-
-/*****************************************
- *** mc3xxx_init
- *****************************************/
-static int __init mc3xxx_init(void)
-{
-	struct acc_hw *hw = mc3xxx_get_cust_acc_hw();
-	i2c_register_board_info(hw->i2c_num, &mc3xxx_i2c_board_info, 1);
-	
-    #ifdef _MC3XXX_SUPPORT_AUTO_DETECT_
-        hwmsen_gsensor_add(&mc3xxx_init_info);
-    #else
-        if(platform_driver_register(&mc3xxx_gsensor_driver))
-        {
-            GSE_ERR("failed to register driver");
-            return -ENODEV;
-        }
-    #endif
-
-	return 0;    
-}
-
-/*****************************************
- *** mc3xxx_exit
- *****************************************/
-static void __exit mc3xxx_exit(void)
-{
-	GSE_FUN();
-
-    #ifndef _MC3XXX_SUPPORT_AUTO_DETECT_
-        platform_driver_unregister(&mc3xxx_gsensor_driver);
-    #endif
-}
-
-/*----------------------------------------------------------------------------*/
-module_init(mc3xxx_init);
-module_exit(mc3xxx_exit);
-/*----------------------------------------------------------------------------*/
-MODULE_DESCRIPTION("mc3XXX G-Sensor Driver");
-MODULE_AUTHOR("mCube-inc");
-MODULE_LICENSE("GPL");
-MODULE_VERSION(MC3XXX_DEV_DRIVER_VERSION);
-
diff --git a/drivers/misc/mediatek/fingerprint/Makefile~ b/drivers/misc/mediatek/fingerprint/Makefile~
deleted file mode 100755
index 327d3d3..0000000
--- a/drivers/misc/mediatek/fingerprint/Makefile~
+++ /dev/null
@@ -1,12 +0,0 @@
-#
-# Makefile for the input core drivers.
-#
-
-# Each configuration option enables a list of files.
-include $(srctree)/drivers/misc/mediatek/Makefile.custom
-obj-y  := eh570.o
-
-eh570-y := \
-	eh570-spi.o \
-	eh570-spi_data_transfer.o \
-	fps_trigger.o
diff --git a/drivers/misc/mediatek/fingerprint/eh570-spi.c~ b/drivers/misc/mediatek/fingerprint/eh570-spi.c~
deleted file mode 100755
index 435c5e2..0000000
--- a/drivers/misc/mediatek/fingerprint/eh570-spi.c~
+++ /dev/null
@@ -1,527 +0,0 @@
-/*
- * Simple synchronous userspace interface to SPI devices
- *
- * Copyright (C) 2006 SWAPP
- *	Andrea Paterniani <a.paterniani@swapp-eng.it>
- * Copyright (C) 2007 David Brownell (simplification, cleanup)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-#include "eh570_data_transfer.h"
-#include "eh570.h"
-#include "eh570_define_jadeOpc.h"
-#include "fps_trigger.h"
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/fs.h>
-#include <linux/init.h>
-#include <linux/delay.h>
-#include <linux/poll.h>
-#include <linux/sched.h>
-#include <linux/irq.h>
-#include <asm/irq.h>
-#include <linux/io.h>
-#include <linux/interrupt.h>
-#include <linux/uaccess.h>
-#include <mach/hardware.h>
-#include <linux/platform_device.h>
-#include <linux/cdev.h>
-#include <linux/miscdevice.h>
-#include <mach/mt_gpio.h>
-#include <mach/mt_pm_ldo.h>
-#include <mach/mt_spi.h>
-
-/* reset pin for CK MKT 92XX */
-//#define GPIO_FPS_RESET_PIN	GPIO55
-#define GPIO_FPS_RESET_PIN	GPIO1//GPIO17
-
-#ifdef EH570_SPI_DEBUG
-#define DEBUG_PRINT(fmt, args...)	printk(fmt, ## args)
-#else
-/* Don't do anything in release builds */
-#define DEBUG_PRINT(fmt, args...)
-#endif
-
-static DECLARE_BITMAP(minors, N_SPI_MINORS);
-static LIST_HEAD(device_list);
-static DEFINE_MUTEX(device_list_lock);
-static unsigned bufsiz = 4096;
-module_param(bufsiz, uint, S_IRUGO);
-MODULE_PARM_DESC(bufsiz, "data bytes in biggest supported SPI message");
-
-static struct mt_chip_conf spi_conf = {
-	.setuptime = 1,
-	.holdtime = 1,
-	.high_time = 4,
-	.low_time = 4,
-//	.high_time = 10,//6,//4,  //jeff 20150408
-//	.low_time = 10,//6,//4,
-
-	.cs_idletime = 2,
-	.ulthgh_thrsh = 0,
-	.cpol = 1,
-	.cpha = 1,
-	.rx_mlsb = SPI_MSB,
-	.tx_mlsb = SPI_MSB,
-	.tx_endian = 0,
-	.rx_endian = 0,
-	.com_mod = DMA_TRANSFER,
-	.pause = 0,
-	.finish_intr = 1,
-	.deassert = 0,
-	.ulthigh = 0,
-	.tckdly = 0,
-};
-
-/*-------------------------------------------------------------------------*/
-
-static void eh570_reset(void)
-{
-	mt_set_gpio_mode(GPIO_FPS_RESET_PIN, GPIO_MODE_00);
-	mt_set_gpio_dir(GPIO_FPS_RESET_PIN, GPIO_DIR_OUT);
-	mt_set_gpio_out(GPIO_FPS_RESET_PIN, GPIO_OUT_ZERO);
-	msleep(20);
-	mt_set_gpio_out(GPIO_FPS_RESET_PIN, GPIO_OUT_ONE);
-}
-
-static ssize_t eh570_read(struct file *filp,
-						char __user *buf,
-						size_t count,
-						loff_t *f_pos)
-{
-	/*Implement by vendor if needed*/
-	return 0;
-}
-
-static ssize_t eh570_write(struct file *filp,
-						const char __user *buf,
-						size_t count,
-						loff_t *f_pos)
-{
-/*Implement by vendor if needed*/
-	return 0;
-}
-
-static long eh570_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
-{
-	int			err = 0;
-	int			retval = 0;
-	struct eh570_data	*eh570;
-	struct spi_device	*spi;
-	u32			tmp;
-	struct egis_ioc_transfer	*ioc = NULL;
-
-	/* Check type and command number */
-	if (_IOC_TYPE(cmd) != EGIS_IOC_MAGIC) {
-		pr_err("%s _IOC_TYPE(cmd) != EGIS_IOC_MAGIC", __func__);
-		return -ENOTTY;
-	}
-
-	/* Check access direction once here; don't repeat below.
-	 * IOC_DIR is from the user perspective, while access_ok is
-	 * from the kernel perspective; so they look reversed.
-	 */
-	if (_IOC_DIR(cmd) & _IOC_READ)
-		err = !access_ok(VERIFY_WRITE,
-						(void __user *)arg,
-						_IOC_SIZE(cmd));
-	if (err == 0 && _IOC_DIR(cmd) & _IOC_WRITE)
-		err = !access_ok(VERIFY_READ,
-						(void __user *)arg,
-						_IOC_SIZE(cmd));
-	if (err) {
-		pr_err("%s err", __func__);
-		return -EFAULT;
-	}
-
-	/* guard against device removal before, or while,
-	 * we issue this ioctl.
-	 */
-	eh570 = filp->private_data;
-	spin_lock_irq(&eh570->spi_lock);
-	spi = spi_dev_get(eh570->spi);
-	spin_unlock_irq(&eh570->spi_lock);
-
-	if (spi == NULL) {
-		pr_err("%s spi == NULL", __func__);
-		return -ESHUTDOWN;
-	}
-
-	mutex_lock(&eh570->buf_lock);
-
-	/* segmented and/or full-duplex I/O request */
-	if (_IOC_NR(cmd) != _IOC_NR(EGIS_IOC_MESSAGE(0))
-					|| _IOC_DIR(cmd) != _IOC_WRITE) {
-		retval = -ENOTTY;
-		goto out;
-	}
-
-	tmp = _IOC_SIZE(cmd);
-	if ((tmp == 0) || (tmp % sizeof(struct egis_ioc_transfer)) != 0) {
-		retval = -EINVAL;
-		goto out;
-	}
-
-	/* copy into scratch area */
-	ioc = kmalloc(tmp, GFP_KERNEL);
-	if (ioc == NULL) {
-		retval = -ENOMEM;
-		goto out;
-	}
-	if (__copy_from_user(ioc, (void __user *)arg, tmp)) {
-		retval = -EFAULT;
-		goto out;
-	}
-
-	/*
-	 * Read register
-	 * tx_buf include register address will be read
-	 */
-	if (ioc->opcode == JADE_REGISTER_READ) {
-		u8 *address = ioc->tx_buf;
-		u8 *result = ioc->rx_buf;
-		DEBUG_PRINT("eh570 JADE_REGISTER_READ");
-
-		retval = eh570_io_read_register(eh570, address, result);
-		if (retval < 0)	{
-			pr_err("%s JADE_REGISTER_READ error retval = %d"
-			, __func__, retval);
-			goto out;
-		}
-	}
-
-	/*
-	 * Write data to register
-	 * tx_buf includes address and value will be wrote
-	 */
-	if (ioc->opcode == JADE_REGISTER_WRITE) {
-		u8 *buf = ioc->tx_buf;
-		retval = eh570_io_write_register(eh570, buf);
-		if (retval < 0) {
-			pr_err("%s JADE_REGISTER_WRITE error retval = %d"
-			, __func__, retval);
-			goto out;
-		}
-	}
-
-	/*
-	 * Get one frame data from sensor
-	 */
-	if (ioc->opcode == JADE_GET_ONE_IMG) {
-		u8 *buf = ioc->tx_buf;
-		u8 *image_buf = ioc->rx_buf;
-		DEBUG_PRINT("eh570 JADE_GET_ONE_IMG");
-		retval = eh570_io_get_one_image(eh570, buf, image_buf);
-		if (retval < 0) {
-			pr_err("%s JADE_GET_ONE_IMG error retval = %d"
-			, __func__, retval);
-			goto out;
-		}
-	}
-
-	if (ioc->opcode == JADE_SENSOR_RESET)
-		eh570_reset();
-
-	/*
-	 * Trigger inital routine
-	 */
-	if (ioc->opcode == INT_TRIGGER_INIT) {
-		pr_err(">>> eh570 Trigger function init\n");
-		retval = Interrupt_Init();
-		pr_err("trigger init = %d\n", retval);
-	}
-
-	/*
-	 * trigger
-	 */
-	if (ioc->opcode == INT_TRIGGER_CLOSE) {
-		pr_err("<<< eh570 Trigger function close\n");
-		retval = Interrupt_Free();
-		pr_err("trigger close = %d\n", retval);
-	}
-
-/*
- * read interrupt status
- */
-	if (ioc->opcode == INT_TRIGGER_ABORT)
-		fps_interrupt_abort();
-
-out:
-	if (ioc != NULL)
-		kfree(ioc);
-
-	mutex_unlock(&eh570->buf_lock);
-	spi_dev_put(spi);
-	if (retval < 0)
-		pr_err("%s retval = %d", __func__, retval);
-	return retval;
-}
-
-#ifdef CONFIG_COMPAT
-static long eh570_compat_ioctl(struct file *filp,
-	unsigned int cmd,
-	unsigned long arg)
-{
-	return eh570_ioctl(filp, cmd, (unsigned long)compat_ptr(arg));
-}
-#else
-#define eh570_compat_ioctl NULL
-#endif /* CONFIG_COMPAT */
-
-static int eh570_open(struct inode *inode, struct file *filp)
-{
-	struct eh570_data	*eh570;
-	int			status = -ENXIO;
-
-	DEBUG_PRINT("%s", __func__);
-	mutex_lock(&device_list_lock);
-
-	list_for_each_entry(eh570, &device_list, device_entry)
-	{
-		if (eh570->devt == inode->i_rdev) {
-			status = 0;
-			break;
-		}
-	}
-	if (status == 0) {
-		if (eh570->buffer == NULL) {
-			eh570->buffer = kmalloc(bufsiz, GFP_KERNEL);
-			if (eh570->buffer == NULL) {
-				dev_dbg(&eh570->spi->dev, "open/ENOMEM\n");
-				status = -ENOMEM;
-			}
-		}
-		if (status == 0) {
-			eh570->users++;
-			filp->private_data = eh570;
-			nonseekable_open(inode, filp);
-		}
-	} else
-		pr_debug("eh570: nothing for minor %d\n", iminor(inode));
-
-	mutex_unlock(&device_list_lock);
-	return status;
-}
-
-static int eh570_release(struct inode *inode, struct file *filp)
-{
-	struct eh570_data	*eh570;
-
-	DEBUG_PRINT("%s", __func__);
-	mutex_lock(&device_list_lock);
-	eh570 = filp->private_data;
-	filp->private_data = NULL;
-
-	/* last close? */
-	eh570->users--;
-	if (eh570->users == 0) {
-		int	dofree;
-
-		kfree(eh570->buffer);
-		eh570->buffer = NULL;
-
-		/* ... after we unbound from the underlying device? */
-		spin_lock_irq(&eh570->spi_lock);
-		dofree = (eh570->spi == NULL);
-		spin_unlock_irq(&eh570->spi_lock);
-
-		if (dofree)
-			kfree(eh570);
-	}
-	mutex_unlock(&device_list_lock);
-
-	return 0;
-}
-
-static const struct file_operations eh570_fops = {
-	.owner =	THIS_MODULE,
-	.write =	eh570_write,
-	.read =		eh570_read,
-	.unlocked_ioctl = eh570_ioctl,
-	.compat_ioctl = eh570_compat_ioctl,
-	.open =		eh570_open,
-	.release =	eh570_release,
-	.llseek =	no_llseek,
-	.poll	=	fps_interrupt_poll
-};
-
-/*-------------------------------------------------------------------------*/
-
-static struct class *eh570_class;
-
-/*-------------------------------------------------------------------------*/
-
-static int eh570_probe(struct spi_device *spi)
-{
-	struct eh570_data	*eh570;
-	int			status;
-	unsigned long		minor;
-
-	DEBUG_PRINT("%s", __func__);
-
-	/* Allocate driver data */
-	eh570 = kzalloc(sizeof(*eh570), GFP_KERNEL);
-	if (eh570 == NULL)
-		return -ENOMEM;
-///
-#if 0
-    mt_set_gpio_mode(GPIO65,1);
-    mt_set_gpio_dir(GPIO65,GPIO_DIR_OUT);
-    mt_set_gpio_pull_enable(GPIO65,GPIO_PULL_ENABLE);
-
-    mt_set_gpio_mode(GPIO66,1);
-    mt_set_gpio_dir(GPIO66,GPIO_DIR_OUT);
-    mt_set_gpio_pull_enable(GPIO66,GPIO_PULL_ENABLE);
-
-    mt_set_gpio_mode(GPIO67,1);
-    mt_set_gpio_dir(GPIO67,GPIO_DIR_IN);
-    mt_set_gpio_pull_enable(GPIO67,GPIO_PULL_ENABLE);
-
-    mt_set_gpio_mode(GPIO68,1);
-    mt_set_gpio_dir(GPIO68,GPIO_DIR_OUT);
-    mt_set_gpio_pull_enable(GPIO68,GPIO_PULL_ENABLE);
-
-    mt_set_gpio_mode(GPIO65,1);
-    mt_set_gpio_mode(GPIO66,1);
-    mt_set_gpio_mode(GPIO67,1);
-    mt_set_gpio_mode(GPIO68,1);
-#endif
-///
-//jeff add 20141128 begin
-	hwPowerOn(MT6328_POWER_LDO_VGP1,VOL_3300,"eh570"); 
-//jeff add 20141128 end
-
-	/* Initialize the driver data */
-	eh570->spi = spi;
-	spi->controller_data = (void *) &spi_conf;
-	spi->max_speed_hz = 12 * 1000 * 1000;
-	spi_setup(spi);
-	spin_lock_init(&eh570->spi_lock);
-	mutex_init(&eh570->buf_lock);
-
-	INIT_LIST_HEAD(&eh570->device_entry);
-
-	/* If we can allocate a minor number, hook up this device.
-	 * Reusing minors is fine so long as udev or mdev is working.
-	 */
-	mutex_lock(&device_list_lock);
-	minor = find_first_zero_bit(minors, N_SPI_MINORS);
-	if (minor < N_SPI_MINORS) {
-		struct device *dev;
-		eh570->devt = MKDEV(EH570_MAJOR, minor);
-		dev = device_create(eh570_class, &spi->dev, eh570->devt,
-				    eh570, "esfp0");
-		status = IS_ERR(dev) ? PTR_ERR(dev) : 0;
-	} else{
-		dev_dbg(&spi->dev, "no minor number available!\n");
-		status = -ENODEV;
-	}
-	if (status == 0) {
-		set_bit(minor, minors);
-		list_add(&eh570->device_entry, &device_list);
-	}
-	mutex_unlock(&device_list_lock);
-
-	if (gpio_request(GPIO_FPS_RESET_PIN, "fpsreset"))
-		pr_err("request GPIO for fpsreset failed\n");
-
-	eh570_reset();
-	if (status == 0)
-		spi_set_drvdata(spi, eh570);
-	else
-		kfree(eh570);
-
-	return status;
-}
-
-static int eh570_remove(struct spi_device *spi)
-{
-	struct eh570_data	*eh570 = spi_get_drvdata(spi);
-	DEBUG_PRINT("%s", __func__);
-
-	/* make sure ops on existing fds can abort cleanly */
-	spin_lock_irq(&eh570->spi_lock);
-	eh570->spi = NULL;
-	spi_set_drvdata(spi, NULL);
-	spin_unlock_irq(&eh570->spi_lock);
-
-	/* prevent new opens */
-	mutex_lock(&device_list_lock);
-	list_del(&eh570->device_entry);
-	device_destroy(eh570_class, eh570->devt);
-	clear_bit(MINOR(eh570->devt), minors);
-	if (eh570->users == 0)
-		kfree(eh570);
-	mutex_unlock(&device_list_lock);
-
-	return 0;
-}
-
-static struct spi_driver eh570_spi_driver = {
-	.driver = {
-		.name =		"eh570",
-		.owner =	THIS_MODULE,
-	},
-	.probe =	eh570_probe,
-	.remove =	eh570_remove,
-
-};
-
-/*-------------------------------------------------------------------------*/
-
-static int __init eh570_init(void)
-{
-	int status;
-	DEBUG_PRINT("%s", __func__);
-
-	/* Claim our 256 reserved device numbers.  Then register a class
-	 * that will key udev/mdev to add/remove /dev nodes.  Last, register
-	 * the driver which manages those device numbers.
-	 */
-	BUILD_BUG_ON(N_SPI_MINORS > 256);
-	status = register_chrdev(EH570_MAJOR, "spi", &eh570_fops);
-	if (status < 0)
-		return status;
-	eh570_class = class_create(THIS_MODULE, "eh570");
-	if (IS_ERR(eh570_class)) {
-		unregister_chrdev(EH570_MAJOR, eh570_spi_driver.driver.name);
-		return PTR_ERR(eh570_class);
-	}
-
-	status = spi_register_driver(&eh570_spi_driver);
-	if (status < 0) {
-		class_destroy(eh570_class);
-		unregister_chrdev(EH570_MAJOR, eh570_spi_driver.driver.name);
-	}
-	return status;
-}
-module_init(eh570_init);
-
-static void __exit eh570_exit(void)
-{
-	DEBUG_PRINT("%s", __func__);
-	gpio_free(GPIO_FPS_RESET_PIN);
-	spi_unregister_driver(&eh570_spi_driver);
-	class_destroy(eh570_class);
-	unregister_chrdev(EH570_MAJOR, eh570_spi_driver.driver.name);
-}
-module_exit(eh570_exit);
-
-MODULE_AUTHOR("Wang YuWei, <robert.wang@egistec.com>");
-MODULE_DESCRIPTION("SPI Interface for EH570");
-MODULE_LICENSE("GPL");
-MODULE_ALIAS("spi:eh570");
diff --git a/drivers/misc/mediatek/fingerprint/eh570-spi_data_transfer.c~ b/drivers/misc/mediatek/fingerprint/eh570-spi_data_transfer.c~
deleted file mode 100755
index 6e6599a..0000000
--- a/drivers/misc/mediatek/fingerprint/eh570-spi_data_transfer.c~
+++ /dev/null
@@ -1,316 +0,0 @@
-#include <linux/kernel.h>
-#include <linux/uaccess.h>
-#include <mach/mt_spi.h>
-#include "eh570_data_transfer.h"
-#include "eh570_define_jadeOpc.h"
-#include "eh570_register_define.h"
-
-int eh570_mass_read(struct eh570_data *eh570, u8 addr, u8 *buf, int read_len)
-{
-	ssize_t status;
-	struct spi_device *spi;
-	struct spi_message m;
-	u8 *write_addr;
-	/* Set start address */
-	u8 *read_data = kzalloc(read_len + 1024, GFP_KERNEL);
-	if (read_data == NULL)
-		return -ENOMEM;
-
-	write_addr = kzalloc(2, GFP_KERNEL);
-	write_addr[0] = EH570_WRITE_ADDRESS;
-	write_addr[1] = addr;
-
-	/* Write and read data in one data query section */
-	struct spi_transfer t_set_addr = {
-		.tx_buf = write_addr,
-		.len = 2,
-	};
-	struct spi_transfer t_read_data = {
-		.tx_buf = read_data,
-		.rx_buf = read_data,
-		.len = read_len + 1024,
-	};
-
-	DEBUG_PRINT("%s read_len = %d\n", __func__, read_len);
-	read_data[0] = EH570_READ_DATA;
-	spi = eh570->spi;
-	spi_message_init(&m);
-	spi_message_add_tail(&t_set_addr, &m);
-	spi_message_add_tail(&t_read_data, &m);
-	status = spi_sync(spi, &m);
-
-	kfree(write_addr);
-
-	if (status == 0) {
-		memcpy(buf, read_data + 3, read_len);
-	} else {
-	//	pr_err(KERN_ERR "%s read data error status = %d\n"
-		//		, __func__, status);
-	}
-	kfree(read_data);
-
-	return status;
-}
-
-/*
- * Read io register
- */
-int eh570_io_read_register(struct eh570_data *eh570, u8 *addr, u8 *buf)
-{
-	ssize_t status = 0;
-	struct spi_device *spi;
-	struct spi_message m;
-	int read_len = 1;
-	u8 *result;
-	u8 val, addrval;
-
-	if (copy_from_user(&addrval, (const u8 __user *) (uintptr_t) addr
-		, read_len)) {
-		pr_err(KERN_ERR "%s buffer copy_from_user fail", __func__);
-		status = -EFAULT;
-		goto out;
-	}
-
-	u8 *write_addr = kzalloc(2, GFP_KERNEL);
-	write_addr[0] = EH570_WRITE_ADDRESS;
-	write_addr[1] = addrval;
-	u8 *read_value = kzalloc(2, GFP_KERNEL);
-	read_value[0] = EH570_READ_DATA;
-	read_value[1] = 0x00;
-
-	result = kzalloc(2, GFP_KERNEL);
-	result[0] = 0xFF;
-	result[1] = 0xFF;
-	struct spi_transfer t_set_addr = {
-		.tx_buf = write_addr,
-		.len = 2,
-	};
-	struct spi_transfer t = {
-		.tx_buf = read_value,
-		.rx_buf = result,
-		.len = 2,
-	};
-
-	DEBUG_PRINT("%s read_len = %d", __func__, read_len);
-
-	spi = eh570->spi;
-
-	/*Set address*/
-	write_addr[1] = addrval;
-	/*Start to read*/
-	spi_message_init(&m);
-	spi_message_add_tail(&t_set_addr, &m);
-	spi_message_add_tail(&t, &m);
-	status = spi_sync(spi, &m);
-	if (status < 0) {
-		//pr_err(KERN_ERR "%s read data error status = %d\n"
-		//		, __func__, status);
-		goto out;
-	}
-
-	val = result[1];
-
-
-#ifdef EH570_SPI_DEBUG
-	//printk("%s address = %d buf = %d", __func__, addr, val);
-#endif
-	if (copy_to_user((u8 __user *) (uintptr_t) buf, &val, read_len)) {
-		pr_err(KERN_ERR "%s buffer copy_to_user fail status", __func__);
-		status = -EFAULT;
-		goto out;
-	}
-out:
-	if (write_addr != NULL)
-		kfree(write_addr);
-	if (read_value != NULL)
-		kfree(read_value);
-	if (result != NULL)
-		kfree(result);
-
-	return status;
-}
-
-/*
- * Write data to register
- */
-int eh570_io_write_register(struct eh570_data *eh570, u8 *buf)
-{
-	ssize_t status = 0;
-	struct spi_device *spi;
-	int write_len = 2;
-	struct spi_message m;
-
-	u8 *write_addr = kzalloc(2, GFP_KERNEL);
-	write_addr[0] = EH570_WRITE_ADDRESS;
-	write_addr[1] = 0x00;
-	u8 *write_value = kzalloc(2, GFP_KERNEL);
-	write_value[0] = EH570_WRITE_DATA;
-	write_value[1] = 0x00;
-	u8 *val = kzalloc(write_len, GFP_KERNEL);
-
-	if (copy_from_user(val, (const u8 __user *) (uintptr_t) buf
-		, write_len)) {
-		pr_err(KERN_ERR "%s buffer copy_from_user fail", __func__);
-		status = -EFAULT;
-		goto out;
-	}
-
-	struct spi_transfer t1 = {
-		.tx_buf = write_addr,
-		.len = 2,
-	};
-	struct spi_transfer t2 = {
-		.tx_buf = write_value,
-		.len = 2,
-	};
-
-	DEBUG_PRINT("%s write_len = %d", __func__, write_len);
-
-#ifdef EH570_SPI_DEBUG
-	//DEBUG_PRINT("%s address = %x data = %x", __func__, val[0], val[1]);
-#endif
-
-	spi = eh570->spi;
-
-	/*Set address*/
-	write_addr[1] = val[0];
-	/*Set value*/
-	write_value[1] = val[1];
-	spi_message_init(&m);
-	spi_message_add_tail(&t1, &m);
-	spi_message_add_tail(&t2, &m);
-	status = spi_sync(spi, &m);
-	if (status < 0) {
-	//	pr_err(KERN_ERR "%s read data error status = %d",
-		//		__func__, status);
-		goto out;
-	}
-
-out:
-	if (write_addr != NULL)
-		kfree(write_addr);
-	if (write_value != NULL)
-		kfree(write_value);
-	if (val != NULL)
-		kfree(val);
-	return status;
-}
-
-int eh570_read_register(struct eh570_data *eh570, u8 addr, u8 *buf)
-{
-	ssize_t	status;
-	struct spi_device *spi;
-	struct spi_message m;
-
-	/*Set address*/
-	u8 *write_addr = kzalloc(2, GFP_KERNEL);
-	write_addr[0] = EH570_WRITE_ADDRESS;
-	write_addr[1] = addr;
-	u8 *read_value = kzalloc(2, GFP_KERNEL);
-	read_value[0] = EH570_READ_DATA;
-	read_value[1] = 0x00;
-	u8 *result = kzalloc(2, GFP_KERNEL);
-	result[0] = 0xFF;
-	result[1] = 0xFF;
-
-	struct spi_transfer t1 = {
-		.tx_buf = write_addr,
-		.len = 2,
-	};
-	struct spi_transfer t2 = {
-		.tx_buf = read_value,
-		.rx_buf	= result,
-		.len = 2,
-	};
-
-	spi = eh570->spi;
-	spi_message_init(&m);
-	spi_message_add_tail(&t1, &m);
-	spi_message_add_tail(&t2, &m);
-	status = spi_sync(spi, &m);
-
-	if (status == 0) {
-		*buf = result[1];
-		printk("eh570_read_register address = %x result = %x %x\n"
-					, addr, result[0], result[1]);
-	} else
-		printk("read data error status =\n");
-
-out:
-	if (write_addr != NULL)
-		kfree(write_addr);
-	if (read_value != NULL)
-		kfree(read_value);
-	if (result != NULL)
-		kfree(result);
-	return status;
-}
-
-int eh570_io_get_one_image(
-	struct eh570_data *eh570,
-	u8 *buf,
-	u8 *image_buf
-	)
-{
-	uint8_t read_val;
-	int32_t status;
-	uint32_t fail_count = 0;
-	uint8_t *tx_buf = (uint8_t *)buf;
-	uint32_t read_count;
-	uint8_t *work_buf = NULL;
-	DEBUG_PRINT("%s", __func__);
-
-	uint8_t *val = kzalloc(6, GFP_KERNEL);
-	if (val == NULL)
-		return -ENOMEM;
-
-	if (copy_from_user(val, (const u8 __user *) (uintptr_t) tx_buf, 6)) {
-		//pr_err(KERN_ERR "%s buffer copy_from_user fail", __func__);
-		status = -EFAULT;
-		goto end;
-	}
-	read_count = val[0] * val[1];          /* total pixel , width * hight */
-
-	while (1) {
-		status = eh570_read_register
-				(eh570, FSTATUS_EH570_ADDR, &read_val);
-		if (status < 0)
-			goto end;
-
-		if (read_val & FRAME_READY_MASK)
-			break;
-
-		if (fail_count >= 250) {
-		//	pr_err(KERN_ERR "fail_count = %d", fail_count);
-			status = -ETIME;
-			goto end;
-		}
-		fail_count++;
-	}
-
-	work_buf = kzalloc(read_count, GFP_KERNEL);
-	if (work_buf == NULL) {
-		status = -ENOMEM;
-		goto end;
-	}
-
-	status = eh570_mass_read(eh570, FDATA_EH570_ADDR, work_buf, read_count);
-	if (status < 0) {
-		//pr_err(KERN_ERR "%s call eh570_mass_read error status = %d\n "
-				, __func__, status);
-		goto end;
-	}
-
-	if (copy_to_user((u8 __user *) (uintptr_t) image_buf,
-		work_buf, read_count)) {
-		//pr_err(KERN_ERR "buffer copy_to_user fail status = %d", status);
-		status = -EFAULT;
-	}
-end:
-	kfree(val);
-	kfree(work_buf);
-	return status;
-}
-
-
-
diff --git a/drivers/misc/mediatek/fingerprint/eh570.h~ b/drivers/misc/mediatek/fingerprint/eh570.h~
deleted file mode 100755
index 2942790..0000000
--- a/drivers/misc/mediatek/fingerprint/eh570.h~
+++ /dev/null
@@ -1,57 +0,0 @@
-#ifndef _EH570_LINUX_DIRVER_H_
-#define _EH570_LINUX_DIRVER_H_
-
-#include <linux/module.h>
-#include <linux/spi/spi.h>
-
-//#define EH570_SPI_DEBUG
-
-#ifdef EH570_SPI_DEBUG
-//#define DEBUG_PRINT(fmt, args...) pr_err(fmt, ## args)
-#define DEBUG_PRINT(fmt, args...) printk(fmt, ## args)
-#else
-#define DEBUG_PRINT(fmt, args...)
-#endif
-
-#define EH570_MAJOR         101 /* assigned */
-#define N_SPI_MINORS            32  /* ... up to 256 */
-
-#define EH570_ADDRESS_0 0x00
-#define EH570_WRITE_ADDRESS 0xAC
-#define EH570_READ_DATA 0xAF
-#define EH570_WRITE_DATA 0xAE
-
-struct egis_ioc_transfer {
-	__u8			*tx_buf;
-	__u8			*rx_buf;
-
-	__u32		len;
-	__u32		speed_hz;
-
-	__u16		delay_usecs;
-	__u8		bits_per_word;
-	__u8		cs_change;
-	__u8		opcode;
-	__u8		pad[3];
-
-};
-
-#define EGIS_IOC_MAGIC			'k'
-#define EGIS_MSGSIZE(N) \
-	((((N)*(sizeof(struct egis_ioc_transfer))) < (1 << _IOC_SIZEBITS)) \
-		? ((N)*(sizeof(struct egis_ioc_transfer))) : 0)
-#define EGIS_IOC_MESSAGE(N) _IOW(EGIS_IOC_MAGIC, 0, char[EGIS_MSGSIZE(N)])
-
-struct eh570_data {
-	dev_t           devt;
-	spinlock_t      spi_lock;
-	struct spi_device   *spi;
-	struct list_head    device_entry;
-
-	/* buffer is NULL unless this device is open (users > 0) */
-	struct mutex        buf_lock;
-	unsigned        users;
-	u8          *buffer;
-};
-
-#endif
diff --git a/drivers/misc/mediatek/fingerprint/fps_trigger.c~ b/drivers/misc/mediatek/fingerprint/fps_trigger.c~
deleted file mode 100755
index 8e7d537..0000000
--- a/drivers/misc/mediatek/fingerprint/fps_trigger.c~
+++ /dev/null
@@ -1,267 +0,0 @@
-/*
- FILENAME.
-      fps_trigger.c - FringerPrint Sensor signal trigger routine
-
-      $PATH:
-
- FUNCTIONAL DESCRIPTION.
-      FingerPrint Sensor trigger routine
-
- MODIFICATION HISTORY.
-
- NOTICE.
-      Copyright (C) 2000-2014 EgisTec All Rights Reserved.
-*/
-
-#include "fps_trigger.h"
-#include <linux/delay.h>
-/*
-	Interrupt description
-*/
-
-#define EH570_INT_DETECTION_PERIOD	 1
-#define EH570_DETECTION_THRESHOLD	4
-struct interrupt_desc {
-	int gpio;
-	int number;
-	char *name;
-	volatile int int_count;
-	struct timer_list timer;
-};
-
-/*
-	FPS interrupt table
-*/
-
-/*
-static struct interrupt_desc fps_ints[] = {
-	{EXYNOS4_GPX1(4) , 0, "BUT0" , 0}
-};
-*/
-
-static struct interrupt_desc fps_ints[] = {
-//	{1234 , 0, "BUT0" , 0} /* TINY4412CON15 XEINT12 pin */ //jeff 0408
-	{0 , 0, "BUT0" , 0}//{16 , 0, "BUT0" , 0}
-};
-
-static volatile char interrupt_values[] = {
-	'1', '1', '1', '1', '1', '1', '1', '1'
-};
-
-static DECLARE_WAIT_QUEUE_HEAD(interrupt_waitq);
-
-static volatile int ev_press = 1;  /*  it should be init to 0  */
-
-/*
-   FUNCTION NAME.
-      interrupt_timer_routine
-
-   FUNCTIONAL DESCRIPTION.
-      basic interrupt timer inital routine
-
-
- ENTRY PARAMETERS.
-      gpio             - gpio address
-
- EXIT PARAMETERS.
-      Function Return
-*/
-
-static void interrupt_timer_routine(
-	unsigned long _data
-)
-{
-	struct interrupt_desc *bdata = (struct interrupt_desc *)_data;
-	pr_err("FPS interrupt count = %d" , bdata->int_count);
-	if (bdata->int_count >= EH570_DETECTION_THRESHOLD) {
-		ev_press = 1;
-		pr_err("FPS triggered !!!!!!!\n");
-	}
-	bdata->int_count = 0;
-	wake_up_interruptible(&interrupt_waitq);
-}
-
-/*
- FUNCTION NAME.
-      fingerprint_interrupt
-
- FUNCTIONAL DESCRIPTION.
-      finger print interrupt callback routine
-
-
- ENTRY PARAMETERS.
-      irq
-      dev_id
-
- EXIT PARAMETERS.
-      Function Return
-*/
-
-static irqreturn_t fingerprint_interrupt(
-	int irq,
-	void *dev_id
-)
-{
-	/*
-	struct interrupt_desc *bdata = (struct interrupt_desc *)dev_id;
-	mod_timer(&bdata->timer, jiffies + msecs_to_jiffies(5000));
-	printk(KERN_ERR "enter to modify the finger interrupt routine\n");
-	return IRQ_HANDLED;
-	*/
-	struct interrupt_desc *bdata = (struct interrupt_desc *)dev_id;
-	if (!bdata->int_count)
-		mod_timer(&bdata->timer,
-			jiffies + msecs_to_jiffies(EH570_INT_DETECTION_PERIOD));
-	bdata->int_count++;
-	return IRQ_HANDLED;
-}
-
-/*
- FUNCTION NAME.
-      Interrupt_Init
-
- FUNCTIONAL DESCRIPTION.
-      button initial routine
-
-
- ENTRY PARAMETERS.
-      gpio             - gpio address
-
- EXIT PARAMETERS.
-      Function Return int
-*/
-
-int Interrupt_Init(void)
-{
-	int i;
-	int irq;
-	int err = 0;
-
-	for (i = 0; i < ARRAY_SIZE(fps_ints); i++) {
-		if (!fps_ints[i].gpio)
-			continue;
-/*
-set timer function to handle the interrupt
-*/
-	setup_timer(&fps_ints[i].timer, interrupt_timer_routine,
-				(unsigned long)&fps_ints[i]);
-
-/*
-set the IRQ function and GPIO. then setting the interrupt trigger type
-*/
-	irq = gpio_to_irq(fps_ints[i].gpio);
-	err = request_irq(irq, fingerprint_interrupt, IRQ_TYPE_EDGE_RISING,
-					fps_ints[i].name, (void *)&fps_ints[i]);
-		if (err)
-			break;
-	}
-
-	if (err) {
-		i--;
-		for (; i >= 0; i--) {
-			if (!fps_ints[i].gpio)
-				continue;
-			irq = gpio_to_irq(fps_ints[i].gpio);
-			disable_irq(irq);
-			free_irq(irq, (void *)&fps_ints[i]);
-			del_timer_sync(&fps_ints[i].timer);
-		}
-		return -EBUSY;
-	}
-	ev_press = 0;
-	return 0;
-}
-
-/*
- FUNCTION NAME.
-      Interrupt_Free
-
- FUNCTIONAL DESCRIPTION.
-      free all interrupt resource
-
-
- ENTRY PARAMETERS.
-      gpio             - gpio address
-
- EXIT PARAMETERS.
-      Function Return int
-*/
-
-int Interrupt_Free(void)
-{
-	int irq, i;
-
-	for (i = 0; i < ARRAY_SIZE(fps_ints); i++) {
-		if (!fps_ints[i].gpio)
-			continue;
-		irq = gpio_to_irq(fps_ints[i].gpio);
-		free_irq(irq, (void *)&fps_ints[i]);
-
-		del_timer_sync(&fps_ints[i].timer);
-	}
-
-	return 0;
-}
-
-/*
- FUNCTION NAME.
-      fps_interrupt_read
-
- FUNCTIONAL DESCRIPTION.
-      FPS interrupt read status
-
-
- ENTRY PARAMETERS.
-
-
- EXIT PARAMETERS.
-      Function Return int
-*/
-
-int fps_interrupt_read(
-	struct file *filp,
-	char __user *buff,
-	size_t count,
-	loff_t *offp
-)
-{
-	return 0;
-}
-
-/*
- FUNCTION NAME.
-      fps_interrupt_read
-
- FUNCTIONAL DESCRIPTION.
-      FPS interrupt read status
-
-
- ENTRY PARAMETERS.
-
-      wait      poll table structure
-
- EXIT PARAMETERS.
-      Function Return int
-*/
-
-unsigned int fps_interrupt_poll(
-	struct file *file,
-	struct poll_table_struct *wait
-)
-{
-	unsigned int mask = 0;
-	fps_ints[0].int_count = 0;
-	poll_wait(file, &interrupt_waitq, wait);
-	if (ev_press) {
-		mask |= POLLIN | POLLRDNORM;
-		ev_press = 0;
-	}
-	return mask;
-}
-
-void fps_interrupt_abort(void)
-{
-	ev_press = 0;
-	wake_up_interruptible(&interrupt_waitq);
-}
-
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/ov2680_mipi_raw/ov2680mipi_Sensor.c~ b/drivers/misc/mediatek/imgsensor/src/mt6735/ov2680_mipi_raw/ov2680mipi_Sensor.c~
deleted file mode 100755
index ed36bcb..0000000
--- a/drivers/misc/mediatek/imgsensor/src/mt6735/ov2680_mipi_raw/ov2680mipi_Sensor.c~
+++ /dev/null
@@ -1,1412 +0,0 @@
-/*****************************************************************************
- *
- * Filename:
- * ---------
- *	 OV2680mipi_Sensor.c
- *
- * Project:
- * --------
- *	 ALPS
- *
- * Description:
- * ------------
- *	 Source code of Sensor driver
- *
- *
- *------------------------------------------------------------------------------
- * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
- *============================================================================
- ****************************************************************************/
-
-#include <linux/videodev2.h>
-#include <linux/i2c.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/cdev.h>
-#include <linux/uaccess.h>
-#include <linux/fs.h>
-#include <asm/atomic.h>
-//#include <asm/system.h>
-#include <linux/xlog.h>
-
-#include "kd_camera_hw.h"
-#include "kd_imgsensor.h"
-#include "kd_imgsensor_define.h"
-#include "kd_imgsensor_errcode.h"
-
-#include "ov2680mipi_Sensor.h"
-
-/****************************Modify Following Strings for Debug****************************/
-#define PFX "OV2680_camera_sensor"
-#define LOG_1 LOG_INF("OV2680,MIPI 1LANE\n")
-#define LOG_2 LOG_INF("preview 1600*1200@30fps,600Mbps/lane; video 1600*1200@30fps,600Mbps/lane; 1600*1200@30fps,600Mbps/lane\n")
-/****************************   Modify end    *******************************************/
-#define LOG_INF(format, args...)	pr_debug(PFX "[%s] " format, __FUNCTION__, ##args)
-
-static DEFINE_SPINLOCK(imgsensor_drv_lock);
-
-
-static imgsensor_info_struct imgsensor_info = { 
-	.sensor_id = 0x2680, //OV2680MIPI_SENSOR_ID,  /*sensor_id = 0x2680*/ //record sensor id defined in Kd_imgsensor.h
-	
-	.checksum_value = 0x64d5ee2e, //checksum value for Camera Auto Test
-	
-	.pre = {
-		.pclk = 66000000,				//record different mode's pclk
-		.linelength = 1700,				//record different mode's linelength
-		.framelength = 1294,			//record different mode's framelength
-		.startx = 0,					//record different mode's startx of grabwindow
-		.starty = 0,					//record different mode's starty of grabwindow
-		.grabwindow_width = 1600,		//record different mode's width of grabwindow
-		.grabwindow_height = 1200,		//record different mode's height of grabwindow
-		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
-		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
-		/*	 following for GetDefaultFramerateByScenario()	*/
-		.max_framerate = 300,	
-	},
-	.cap = {/*normal capture*/
-		.pclk = 66000000,
-		.linelength = 1700, 
-		.framelength = 1294,
-		.startx = 0,
-		.starty = 0,
-		.grabwindow_width = 1600,
-		.grabwindow_height = 1200,
-		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
-		.max_framerate = 300,
-	},
-	.cap1 = {/*PIP capture*/ //capture for PIP 24fps relative information, capture1 mode must use same framelength, linelength with Capture mode for shutter calculate
-		.pclk = 66000000,
-		.linelength = 1700, 
-		.framelength = 1294,
-		.startx = 0,
-		.starty = 0,
-		.grabwindow_width = 1600,
-		.grabwindow_height = 1200,
-		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
-		.max_framerate = 240, //less than 13M(include 13M),cap1 max framerate is 24fps,16M max framerate is 20fps, 20M max framerate is 15fps  
-	},
-	.normal_video = {
-		.pclk = 66000000,
-		.linelength = 1700, 
-		.framelength = 1294,
-		.startx = 0,
-		.starty = 0,
-		.grabwindow_width = 1600,
-		.grabwindow_height = 1200,
-		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
-		.max_framerate = 300,
-	},
-	.hs_video = {/*slow motion*/
-		.pclk = 66000000,
-		.linelength = 1446,
-		.framelength = 760,
-		.startx = 0,
-		.starty = 0,
-		.grabwindow_width = 1280,
-		.grabwindow_height = 720,
-		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
-		.max_framerate = 600,
-	},
-	.slim_video = {/*VT Call*/
-		.pclk = 66000000,
-		.linelength = 1700,
-		.framelength = 1294,
-		.startx = 0,
-		.starty = 0,
-		.grabwindow_width = 1600,
-		.grabwindow_height = 1200,
-		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
-		.max_framerate = 300,
-	},
-	
-	.margin = 4,			//sensor framelength & shutter margin
-	.min_shutter = 1,		//min shutter
-	.max_frame_length = 0x7fff,//max framelength by sensor register's limitation
-	.ae_shut_delay_frame = 0,	//shutter delay frame for AE cycle, 2 frame with ispGain_delay-shut_delay=2-0=2
-	.ae_sensor_gain_delay_frame = 0,//sensor gain delay frame for AE cycle,2 frame with ispGain_delay-sensor_gain_delay=2-0=2
-	.ae_ispGain_delay_frame = 2,//isp gain delay frame for AE cycle
-	.ihdr_support = 0,	  //1, support; 0,not support
-	.ihdr_le_firstline = 0,  //1,le first ; 0, se first
-	.sensor_mode_num = 5,	  //support sensor mode num
-	
-	.cap_delay_frame = 1,		//enter capture delay frame num
-	.pre_delay_frame = 2,		//enter preview delay frame num
-	.video_delay_frame = 1, 	//enter video delay frame num
-	.hs_video_delay_frame = 2,	//enter high speed video  delay frame num
-	.slim_video_delay_frame = 2,//enter slim video delay frame num
-	
-	.isp_driving_current = ISP_DRIVING_4MA, //mclk driving current
-	.sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,//sensor_interface_type
-    .mipi_sensor_type = MIPI_OPHY_NCSI2, //0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2
-    .mipi_settle_delay_mode = MIPI_SETTLEDELAY_AUTO,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
-	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_B,//sensor output first pixel color
-	.mclk = 24,//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
-	.mipi_lane_num = SENSOR_MIPI_1_LANE,//mipi lane num
-	.i2c_addr_table = {0x6c,0x20, 0xff},//record sensor support all write id addr, only supprt 4must end with 0xff
-};
-
-
-static imgsensor_struct imgsensor = {
-	.mirror = IMAGE_HV_MIRROR,				//mirrorflip information
-	.sensor_mode = IMGSENSOR_MODE_INIT, //IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
-	.shutter = 0x3D0,					//current shutter
-	.gain = 0x100,						//current gain
-	.dummy_pixel = 0,					//current dummypixel
-	.dummy_line = 0,					//current dummyline
-    .current_fps = 300,  //full size current fps : 24fps for PIP, 30fps for Normal or ZSD
-	.autoflicker_en = KAL_FALSE,  //auto flicker enable: KAL_FALSE for disable auto flicker, KAL_TRUE for enable auto flicker
-	.test_pattern = KAL_FALSE,		//test pattern mode or not. KAL_FALSE for in test pattern mode, KAL_TRUE for normal output
-	.current_scenario_id = MSDK_SCENARIO_ID_CAMERA_PREVIEW,//current scenario id
-	.ihdr_en = 0, //sensor need support LE, SE with HDR feature
-	.i2c_write_id = 0x6c,//record current sensor's i2c write id
-};
-
-
-/* Sensor output window information */
-/*according toov2680 datasheet p53 image cropping*/
-static SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[10] =
-{{ 1616, 1216,	  0,  0, 1615, 1215, 1615, 1215, 8, 8, 1600, 1200,	  0,	0, 1600, 1200}, // Preview 
- { 1616, 1216,	  0,  0, 1615, 1215, 1615, 1215, 8, 8, 1600, 1200,	  0,	0, 1600, 1200}, // capture 
- { 1616, 1216,	  0,  0, 1615, 1215, 1615, 1215, 8, 8, 1600, 1200,	  0,	0, 1600, 1200}, // video 
- { 1616, 1216,	160,242, 1295,  731, 1295,  731, 8, 6, 1280,  720,	  0,	0, 1280,  720}, //hight speed video 
- { 1616, 1216,	  0,  0, 1615, 1215, 1615, 1215, 8, 8, 1600, 1200,	  0,	0, 1600, 1200}, // slim video 
- { 1616, 1216,	  0,  0, 1615, 1215, 1615, 1215, 8, 8, 1600, 1200,	  0,	0, 1600, 1200}, //custom 1
- { 1616, 1216,	  0,  0, 1615, 1215, 1615, 1215, 8, 8, 1600, 1200,	  0,	0, 1600, 1200},
- { 1616, 1216,	  0,  0, 1615, 1215, 1615, 1215, 8, 8, 1600, 1200,	  0,	0, 1600, 1200},
- { 1616, 1216,	  0,  0, 1615, 1215, 1615, 1215, 8, 8, 1600, 1200,	  0,	0, 1600, 1200},
- { 1616, 1216,	  0,  0, 1615, 1215, 1615, 1215, 8, 8, 1600, 1200,	  0,	0, 1600, 1200},
-};
-
-
-static kal_uint16 read_cmos_sensor(kal_uint32 addr)
-{
-	kal_uint16 get_byte=0;
-
-	char pu_send_cmd[2] = {(char)(addr >> 8), (char)(addr & 0xFF) };
-	iReadRegI2C(pu_send_cmd, 2, (u8*)&get_byte, 1, imgsensor.i2c_write_id);
-
-	return get_byte;
-}
-
-static void write_cmos_sensor(kal_uint32 addr, kal_uint32 para)
-{
-	char pu_send_cmd[3] = {(char)(addr >> 8), (char)(addr & 0xFF), (char)(para & 0xFF)};
-	iWriteRegI2C(pu_send_cmd, 3, imgsensor.i2c_write_id);
-}
-
-static void set_dummy()
-{
-	LOG_INF("dummyline = %d, dummypixels = %d \n", imgsensor.dummy_line, imgsensor.dummy_pixel);
-	/* you can set dummy by imgsensor.dummy_line and imgsensor.dummy_pixel, or you can set dummy by imgsensor.frame_length and imgsensor.line_length */
-
-	/*  Add dummy pixels: */
-    /* 0x380c [0:4], 0x380d defines the PCLKs in one line of OV2680  */  
-    /* Add dummy lines:*/
-    /* 0x380e [0:1], 0x380f defines total lines in one frame of OV2680 */
-
-	write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
-	write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);	  
-    write_cmos_sensor(0x380c, imgsensor.line_length >> 8);
-    write_cmos_sensor(0x380d, imgsensor.line_length & 0xFF);
-  
-}	/*	set_dummy  */
-
-static kal_uint32 return_sensor_id()
-{
-    return ((read_cmos_sensor(0x300A) << 8) | read_cmos_sensor(0x300B));
-}
-static void set_max_framerate(UINT16 framerate,kal_bool min_framelength_en)
-{
-	kal_int16 dummy_line;
-	kal_uint32 frame_length = imgsensor.frame_length;
-	//unsigned long flags;
-
-	LOG_INF("framerate = %d, min framelength should enable = %d\n", framerate,min_framelength_en);
-   
-	frame_length = imgsensor.pclk / framerate * 10 / imgsensor.line_length;
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.frame_length = (frame_length > imgsensor.min_frame_length) ? frame_length : imgsensor.min_frame_length; 
-	imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
-    //dummy_line = frame_length - imgsensor.min_frame_length;
-	//if (dummy_line < 0)
-	//	imgsensor.dummy_line = 0;
-	//else
-	//	imgsensor.dummy_line = dummy_line;
-	//imgsensor.frame_length = frame_length + imgsensor.dummy_line;
-	if (imgsensor.frame_length > imgsensor_info.max_frame_length)
-	{
-		imgsensor.frame_length = imgsensor_info.max_frame_length;
-		imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
-	}
-	if (min_framelength_en)
-		imgsensor.min_frame_length = imgsensor.frame_length;
-	spin_unlock(&imgsensor_drv_lock);
-	set_dummy();
-}	/*	set_max_framerate  */
-
-
-static void set_shutter(kal_uint16 shutter)
-{
-    unsigned long flags;
-	kal_uint16 realtime_fps = 0;
-	kal_uint32 frame_length = 0;
-    spin_lock_irqsave(&imgsensor_drv_lock, flags);
-    imgsensor.shutter = shutter;
-    spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
-	   
-	/* 0x3500, 0x3501, 0x3502 will increase VBLANK to get exposure larger than frame exposure */
-	/* AE doesn't update sensor gain at capture mode, thus extra exposure lines must be updated here. */
-	
-	/* OV Recommend Solution
-	*  if shutter bigger than frame_length, should extend frame length first
-	*/
-	
-	if(!shutter) shutter = 1; /*avoid 0*/
-	
-	spin_lock(&imgsensor_drv_lock);
-	if (shutter > imgsensor.min_frame_length - imgsensor_info.margin)		
-		imgsensor.frame_length = shutter + imgsensor_info.margin;
-	else
-		imgsensor.frame_length = imgsensor.min_frame_length;
-	if (imgsensor.frame_length > imgsensor_info.max_frame_length)
-		imgsensor.frame_length = imgsensor_info.max_frame_length;
-	spin_unlock(&imgsensor_drv_lock);
-	//if (shutter < imgsensor_info.min_shutter) shutter = imgsensor_info.min_shutter;
-	shutter = (shutter < imgsensor_info.min_shutter) ? imgsensor_info.min_shutter : shutter;
-	shutter = (shutter > (imgsensor_info.max_frame_length - imgsensor_info.margin)) ? (imgsensor_info.max_frame_length - imgsensor_info.margin) : shutter;
-	if (imgsensor.autoflicker_en) { 
-		realtime_fps = imgsensor.pclk / imgsensor.line_length * 10 / imgsensor.frame_length;
-		if(realtime_fps >= 297 && realtime_fps <= 305)
-			set_max_framerate(296,0);
-		else if(realtime_fps >= 147 && realtime_fps <= 150)
-			set_max_framerate(146,0);	
-        else {
-        // Extend frame length
-        write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
-        write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
-        }
-	} else {
-		// Extend frame length
-		write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
-		write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
-	}
-
-	// Update Shutter
-	write_cmos_sensor(0x3502, (shutter << 4) & 0xFF);
-	write_cmos_sensor(0x3501, (shutter >> 4) & 0xFF);	  
-	write_cmos_sensor(0x3500, (shutter >> 12) & 0x0F);	
-	LOG_INF("Exit! shutter =%d, framelength =%d\n", shutter,imgsensor.frame_length);
-
-	//LOG_INF("frame_length = %d ", frame_length);
-	
-}	/*	set_shutter */
-
-
-
-static kal_uint16 gain2reg(const kal_uint16 gain)
-{
-	
-	kal_uint16 reg_gain = 0x0000;
-	/*
-	reg_gain = ((gain / BASEGAIN) << 4) + ((gain % BASEGAIN) * 16 / BASEGAIN);
-	reg_gain = reg_gain & 0xFFFF;
-	*/
-	return (kal_uint16)reg_gain;
-}
-
-/*************************************************************************
-* FUNCTION
-*	set_gain
-*
-* DESCRIPTION
-*	This function is to set global gain to sensor.
-*
-* PARAMETERS
-*	iGain : sensor global gain(base: 0x40)
-*
-* RETURNS
-*	the actually gain set to sensor.
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint16 set_gain(kal_uint16 gain)
-{
-	kal_uint16 reg_gain;
-
-	/*
-	* sensor gain 1x = 128
-	* max gain = 0x7ff = 15.992x <16x
-	* here we just use 0x3508 analog gain 1 bit[3:2].
-	* 16x~32x should use 0x3508 analog gain 0 bit[1:0]
-	*/
-
-	if (gain < BASEGAIN || gain >= 16 * BASEGAIN) {
-		LOG_INF("Error gain setting");
-
-		if (gain < BASEGAIN)
-			gain = BASEGAIN;
-		else if (gain >= 16 * BASEGAIN)
-			gain = 15.9 * BASEGAIN;		 
-	}
- 
-	/*reg_gain = gain2reg(gain);*/
-	
-	reg_gain = gain/4; //sensor gain base 1x= 16, reg_gain = gain/(64*16);
-	reg_gain &= 0x3ff;
-		
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.gain = reg_gain; 
-	spin_unlock(&imgsensor_drv_lock);
-	LOG_INF("gain = %d , reg_gain = 0x%x\n ", gain, reg_gain);
-
-	write_cmos_sensor(0x350b, reg_gain&0xff);
-	write_cmos_sensor(0x3508, reg_gain>>8);    
-	
-	return gain;
-}	/*	set_gain  */
-
-static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gain)
-{
-	LOG_INF("Warining:Do not supportIHDR, Return. le:0x%x, se:0x%x, gain:0x%x\n",le,se,gain);
-	//return;
-	
-	if (imgsensor.ihdr_en) {
-		
-		spin_lock(&imgsensor_drv_lock);
-			if (le > imgsensor.min_frame_length - imgsensor_info.margin)		
-				imgsensor.frame_length = le + imgsensor_info.margin;
-			else
-				imgsensor.frame_length = imgsensor.min_frame_length;
-			if (imgsensor.frame_length > imgsensor_info.max_frame_length)
-				imgsensor.frame_length = imgsensor_info.max_frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			if (le < imgsensor_info.min_shutter) le = imgsensor_info.min_shutter;
-			if (se < imgsensor_info.min_shutter) se = imgsensor_info.min_shutter;
-			
-			
-				// Extend frame length first
-				write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
-				write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
-
-		write_cmos_sensor(0x3502, (le << 4) & 0xFF);
-		write_cmos_sensor(0x3501, (le >> 4) & 0xFF);	 
-		write_cmos_sensor(0x3500, (le >> 12) & 0x0F);
-		
-		write_cmos_sensor(0x3508, (se << 4) & 0xFF); 
-		write_cmos_sensor(0x3507, (se >> 4) & 0xFF);
-		write_cmos_sensor(0x3506, (se >> 12) & 0x0F); 
-
-		set_gain(gain);
-	}
-
-}
-
-static void set_mirror_flip(kal_uint8 image_mirror)
-{
-	LOG_INF("image_mirror = %d\n", image_mirror);
-
-	/********************************************************
-	   *
-	   *   0x3820[2] ISP Vertical flip
-	   *   0x3820[1] Sensor Vertical flip
-	   *
-	   *   0x3821[2] ISP Horizontal mirror
-	   *   0x3821[1] Sensor Horizontal mirror
-	   *
-	   *   ISP and Sensor flip or mirror register bit should be the same!!
-	   *
-	   ********************************************************/
-	
-	switch (image_mirror) {
-		case IMAGE_NORMAL:
-			write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x00));
-			write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x06));
-			break;
-		case IMAGE_H_MIRROR:
-			write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x00));
-			write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x00));
-			break;
-		case IMAGE_V_MIRROR:
-			write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x06));
-			write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x06));		
-			break;
-		case IMAGE_HV_MIRROR:
-			write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x06));
-			write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x00));
-			break;
-		default:
-			LOG_INF("Error image_mirror setting\n");
-	}
-
-}
-
-/*************************************************************************
-* FUNCTION
-*	night_mode
-*
-* DESCRIPTION
-*	This function night mode of sensor.
-*
-* PARAMETERS
-*	bEnable: KAL_TRUE -> enable night mode, otherwise, disable night mode
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static void night_mode(kal_bool enable)
-{
-/*No Need to implement this function*/ 
-}	/*	night_mode	*/
-static void preview_setting(void)
-{
-	LOG_INF("E\n");
-	
-	/*
-	 * @@Initial - MIPI 1-Lane 1600x1200 10-bit 30fps
-	* 100 99 1600 1200
-	*/
-	write_cmos_sensor(0x0100, 0x00);
-	write_cmos_sensor(0x3086, 0x00);
-	write_cmos_sensor(0x3501, 0x4e);
-	write_cmos_sensor(0x3502, 0xe0);
-	write_cmos_sensor(0x3620, 0x24);
-	write_cmos_sensor(0x3621, 0x37);
-	write_cmos_sensor(0x3622, 0x03);
-	write_cmos_sensor(0x370a, 0x21);
-	write_cmos_sensor(0x370d, 0xc0);
-	write_cmos_sensor(0x3718, 0x80);
-	write_cmos_sensor(0x3721, 0x09);
-	write_cmos_sensor(0x3722, 0x06);
-	write_cmos_sensor(0x3723, 0x59);
-	write_cmos_sensor(0x3738, 0x99);
-	write_cmos_sensor(0x3801, 0x00);
-	write_cmos_sensor(0x3803, 0x00);
-	write_cmos_sensor(0x3804, 0x06);
-	write_cmos_sensor(0x3805, 0x4f);
-	write_cmos_sensor(0x3806, 0x04);
-	write_cmos_sensor(0x3807, 0xbf);
-	write_cmos_sensor(0x3808, 0x06);
-	write_cmos_sensor(0x3809, 0x40);
-	write_cmos_sensor(0x380a, 0x04);
-	write_cmos_sensor(0x380b, 0xb0);
-	write_cmos_sensor(0x380c, 0x06);
-	write_cmos_sensor(0x380d, 0xa4);
-	write_cmos_sensor(0x380e, 0x05);
-	write_cmos_sensor(0x380f, 0x0e);
-	write_cmos_sensor(0x3811, 0x08);
-	write_cmos_sensor(0x3813, 0x08);
-	write_cmos_sensor(0x3814, 0x11);
-	write_cmos_sensor(0x3815, 0x11);
-	write_cmos_sensor(0x3820, 0xc4);
-	write_cmos_sensor(0x3821, 0x04);
-	write_cmos_sensor(0x4008, 0x02);
-	write_cmos_sensor(0x4009, 0x09);
-	write_cmos_sensor(0x4837, 0x18);
-	write_cmos_sensor(0x0100, 0x01);
-	mdelay(60);
-}
-	/*	preview_setting  */
-
-static void sensor_init(void)
-{
-	LOG_INF("E\n");
-
-   /*
-    * @@Initial - MIPI 1-Lane 1600x1200 10-bit 30fps
-   * 100 99 1600 1200
-   */
-   
-	/* Reset */
-	write_cmos_sensor(0x0103, 0x01);
-	mdelay(50);
-	write_cmos_sensor(0x3002, 0x00);
-	write_cmos_sensor(0x3016, 0x1c);
-	write_cmos_sensor(0x3018, 0x44);
-	write_cmos_sensor(0x3020, 0x00);
-	write_cmos_sensor(0x3080, 0x02);
-	write_cmos_sensor(0x3082, 0x37);
-	write_cmos_sensor(0x3084, 0x09);
-	write_cmos_sensor(0x3085, 0x04);
-	write_cmos_sensor(0x3086, 0x01);
-	write_cmos_sensor(0x3501, 0x26);
-	write_cmos_sensor(0x3502, 0x40);
-	write_cmos_sensor(0x3503, 0x03);
-	write_cmos_sensor(0x350b, 0x36);
-	write_cmos_sensor(0x3600, 0xb4);
-	write_cmos_sensor(0x3603, 0x35);
-	write_cmos_sensor(0x3604, 0x24);
-	write_cmos_sensor(0x3605, 0x00);
-	write_cmos_sensor(0x3620, 0x26);
-	write_cmos_sensor(0x3621, 0x37);
-	write_cmos_sensor(0x3622, 0x04);
-	write_cmos_sensor(0x3628, 0x00);
-	write_cmos_sensor(0x3701, 0x64);
-	write_cmos_sensor(0x3705, 0x3c);
-	write_cmos_sensor(0x370c, 0x50);
-	write_cmos_sensor(0x370d, 0xc0);
-	write_cmos_sensor(0x3718, 0x88);
-	write_cmos_sensor(0x3720, 0x00);
-	write_cmos_sensor(0x3721, 0x00);
-	write_cmos_sensor(0x3722, 0x00);
-	write_cmos_sensor(0x3723, 0x00);
-	write_cmos_sensor(0x3738, 0x00);
-	write_cmos_sensor(0x370a, 0x23);
-	write_cmos_sensor(0x3717, 0x58);
-	write_cmos_sensor(0x3781, 0x80);
-	write_cmos_sensor(0x3784, 0x0c); //
-	write_cmos_sensor(0x3789, 0x60);
-	write_cmos_sensor(0x3800, 0x00);
-	write_cmos_sensor(0x3801, 0x00);
-	write_cmos_sensor(0x3802, 0x00);
-	write_cmos_sensor(0x3803, 0x00);
-	write_cmos_sensor(0x3804, 0x06);
-	write_cmos_sensor(0x3805, 0x4f);
-	write_cmos_sensor(0x3806, 0x04);
-	write_cmos_sensor(0x3807, 0xbf);
-	write_cmos_sensor(0x3808, 0x03);
-	write_cmos_sensor(0x3809, 0x20);
-	write_cmos_sensor(0x380a, 0x02);
-	write_cmos_sensor(0x380b, 0x58);
-	write_cmos_sensor(0x380c, 0x06);
-	write_cmos_sensor(0x380d, 0xac);
-	write_cmos_sensor(0x380e, 0x02);
-	write_cmos_sensor(0x380f, 0x84);
-	write_cmos_sensor(0x3810, 0x00);
-	write_cmos_sensor(0x3811, 0x04);
-	write_cmos_sensor(0x3812, 0x00);
-	write_cmos_sensor(0x3813, 0x04);
-	write_cmos_sensor(0x3814, 0x31);
-	write_cmos_sensor(0x3815, 0x31);
-	write_cmos_sensor(0x3819, 0x04);
-	write_cmos_sensor(0x3820, 0xc4);
-	write_cmos_sensor(0x3821, 0x04);
-	write_cmos_sensor(0x4000, 0x81);
-	write_cmos_sensor(0x4001, 0x40);
-	write_cmos_sensor(0x4008, 0x00);
-	write_cmos_sensor(0x4009, 0x03);
-	write_cmos_sensor(0x4602, 0x02);
-	write_cmos_sensor(0x481f, 0x36);
-	write_cmos_sensor(0x4825, 0x36);
-	write_cmos_sensor(0x4837, 0x30);
-	write_cmos_sensor(0x5002, 0x30);
-	write_cmos_sensor(0x5080, 0x00);
-	write_cmos_sensor(0x5081, 0x41);
-
-	write_cmos_sensor(0x4800, 0x24); // disable LS/LE
-	
-	write_cmos_sensor(0x0100, 0x01);
-
-	mdelay(40);
-	//preview_setting();
-	
-}	/*	sensor_init  */
-
-
-
-
-static void capture_setting(kal_uint16 curretfps)
-{
-	LOG_INF("E! currefps:%d\n",curretfps);
-	preview_setting();
-}
-
-static void normal_video_setting(kal_uint16 currefps)
-{
-	LOG_INF("E! currefps:%d\n",currefps);
-	preview_setting();
-}
-static void hs_video_setting()
-{
-	LOG_INF("E\n");
-		
-	/*
-	 * @@Initial - MIPI 1-Lane 1280x720 10-bit 60fps
-	* 100 99 1280 720
-	*/
-	write_cmos_sensor(0x0100, 0x00);
-	write_cmos_sensor(0x3086, 0x00);
-	write_cmos_sensor(0x3501, 0x2d);
-	write_cmos_sensor(0x3502, 0x80);
-	write_cmos_sensor(0x3620, 0x26);
-	write_cmos_sensor(0x3621, 0x37);
-	write_cmos_sensor(0x3622, 0x04);
-	write_cmos_sensor(0x370a, 0x21);
-	write_cmos_sensor(0x370d, 0xc0);
-	write_cmos_sensor(0x3718, 0x88);
-	write_cmos_sensor(0x3721, 0x00);
-	write_cmos_sensor(0x3722, 0x00);
-	write_cmos_sensor(0x3723, 0x00);
-	write_cmos_sensor(0x3738, 0x00);
-	write_cmos_sensor(0x3801, 0xa0);
-	write_cmos_sensor(0x3803, 0xf2);
-	write_cmos_sensor(0x3804, 0x05);
-	write_cmos_sensor(0x3805, 0xaf);
-	write_cmos_sensor(0x3806, 0x03);
-	write_cmos_sensor(0x3807, 0xcd);
-	write_cmos_sensor(0x3808, 0x05);
-	write_cmos_sensor(0x3809, 0x00);
-	write_cmos_sensor(0x380a, 0x02);
-	write_cmos_sensor(0x380b, 0xd0);
-	write_cmos_sensor(0x380c, 0x05);
-	write_cmos_sensor(0x380d, 0xa6);
-	write_cmos_sensor(0x380e, 0x02);
-	write_cmos_sensor(0x380f, 0xf8);
-	write_cmos_sensor(0x3811, 0x08);
-	write_cmos_sensor(0x3813, 0x06);
-	write_cmos_sensor(0x3814, 0x11);
-	write_cmos_sensor(0x3815, 0x11);
-	write_cmos_sensor(0x3820, 0xc4);
-	write_cmos_sensor(0x3821, 0x04);
-	write_cmos_sensor(0x4008, 0x02);
-	write_cmos_sensor(0x4009, 0x09);
-	write_cmos_sensor(0x4837, 0x18);
-	write_cmos_sensor(0x0100, 0x01);
-	mdelay(60);
-}
-
-static void slim_video_setting()
-{
-	LOG_INF("E\n");
-	preview_setting();
-}
-
-
-/*************************************************************************
-* FUNCTION
-*	get_imgsensor_id
-*
-* DESCRIPTION
-*	This function get the sensor ID 
-*
-* PARAMETERS
-*	*sensorID : return the sensor ID 
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 get_imgsensor_id(UINT32 *sensor_id) 
-{
-	kal_uint8 i = 0;
-	kal_uint8 retry_total = 1;
-	kal_uint8 retry_cnt = retry_total;
-	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
-	while (imgsensor_info.i2c_addr_table[i] != 0xff) {
-		spin_lock(&imgsensor_drv_lock);
-		imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
-		spin_unlock(&imgsensor_drv_lock);
-		do {
-            *sensor_id = return_sensor_id();
-			if (*sensor_id == imgsensor_info.sensor_id) {				
-				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);	  
-				return ERROR_NONE;
-			}	
-            LOG_INF("Read sensor id fail, write id: 0x%x, id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
-			retry_cnt--;
-		} while(retry_cnt > 0);
-		i++;
-		retry_cnt = retry_total;
-	}
-	if (*sensor_id != imgsensor_info.sensor_id) {
-		// if Sensor ID is not correct, Must set *sensor_id to 0xFFFFFFFF 
-		*sensor_id = 0xFFFFFFFF;
-		return ERROR_SENSOR_CONNECT_FAIL;
-	}
-	return ERROR_NONE;
-}
-
-
-/*************************************************************************
-* FUNCTION
-*	open
-*
-* DESCRIPTION
-*	This function initialize the registers of CMOS sensor
-*
-* PARAMETERS
-*	None
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 open(void)
-{
-	//const kal_uint8 i2c_addr[] = {IMGSENSOR_WRITE_ID_1, IMGSENSOR_WRITE_ID_2};
-	kal_uint8 i = 0;
-	kal_uint8 retry = 2;
-    kal_uint32 sensor_id = 0;
-    LOG_1;
-    LOG_2;
-	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
-	while (imgsensor_info.i2c_addr_table[i] != 0xff) {
-		spin_lock(&imgsensor_drv_lock);
-		imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
-		spin_unlock(&imgsensor_drv_lock);
-		do {
-            sensor_id = return_sensor_id();
-			if (sensor_id == imgsensor_info.sensor_id) {				
-				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);	  
-				break;
-			}	
-            LOG_INF("Read sensor id fail, write id: 0x%x, id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
-			retry--;
-		} while(retry > 0);
-		i++;
-		if (sensor_id == imgsensor_info.sensor_id)
-			break;
-		retry = 2;
-	}		 
-	if (imgsensor_info.sensor_id != sensor_id)
-		return ERROR_SENSOR_CONNECT_FAIL;
-	
-	/* initail sequence write in  */
-	sensor_init();
-
-	spin_lock(&imgsensor_drv_lock);
-
-	imgsensor.autoflicker_en= KAL_FALSE;
-	imgsensor.sensor_mode = IMGSENSOR_MODE_INIT;
-	imgsensor.shutter = 0x3D0;
-	imgsensor.gain = 0x100;
-	imgsensor.pclk = imgsensor_info.pre.pclk;
-	imgsensor.frame_length = imgsensor_info.pre.framelength;
-	imgsensor.line_length = imgsensor_info.pre.linelength;
-	imgsensor.min_frame_length = imgsensor_info.pre.framelength;
-	imgsensor.dummy_pixel = 0;
-	imgsensor.dummy_line = 0;
-	imgsensor.ihdr_en = 0;
-	imgsensor.test_pattern = KAL_FALSE;
-	imgsensor.current_fps = imgsensor_info.pre.max_framerate;
-	spin_unlock(&imgsensor_drv_lock);
-
-	return ERROR_NONE;
-}	/*	open  */
-
-
-
-/*************************************************************************
-* FUNCTION
-*	close
-*
-* DESCRIPTION
-*	
-*
-* PARAMETERS
-*	None
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 close(void)
-{
-	LOG_INF("E\n");
-
-	/*No Need to implement this function*/ 
-	
-	return ERROR_NONE;
-}	/*	close  */
-
-
-/*************************************************************************
-* FUNCTION
-* preview
-*
-* DESCRIPTION
-*	This function start the sensor preview.
-*
-* PARAMETERS
-*	*image_window : address pointer of pixel numbers in one period of HSYNC
-*  *sensor_config_data : address pointer of line numbers in one period of VSYNC
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("E\n");
-
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.sensor_mode = IMGSENSOR_MODE_PREVIEW;
-	imgsensor.pclk = imgsensor_info.pre.pclk;
-	//imgsensor.video_mode = KAL_FALSE;
-	imgsensor.line_length = imgsensor_info.pre.linelength;
-	imgsensor.frame_length = imgsensor_info.pre.framelength; 
-	imgsensor.min_frame_length = imgsensor_info.pre.framelength;
-	imgsensor.autoflicker_en = KAL_FALSE;
-	spin_unlock(&imgsensor_drv_lock);
-	preview_setting();
-	return ERROR_NONE;
-}	/*	preview   */
-
-/*************************************************************************
-* FUNCTION
-*	capture
-*
-* DESCRIPTION
-*	This function setup the CMOS sensor in capture MY_OUTPUT mode
-*
-* PARAMETERS
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-						  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("E\n");
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.sensor_mode = IMGSENSOR_MODE_CAPTURE;
-    if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {//PIP capture: 24fps for less than 13M, 20fps for 16M,15fps for 20M
-        imgsensor.pclk = imgsensor_info.cap1.pclk;
-        imgsensor.line_length = imgsensor_info.cap1.linelength;
-        imgsensor.frame_length = imgsensor_info.cap1.framelength;
-        imgsensor.min_frame_length = imgsensor_info.cap1.framelength;
-        imgsensor.autoflicker_en = KAL_FALSE;
-    } else {
-        if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
-            LOG_INF("Warning: current_fps %d fps is not support, so use cap's setting: %d fps!\n",imgsensor.current_fps,imgsensor_info.cap.max_framerate/10);
-	imgsensor.pclk = imgsensor_info.cap.pclk;
-	imgsensor.line_length = imgsensor_info.cap.linelength;
-	imgsensor.frame_length = imgsensor_info.cap.framelength;  
-	imgsensor.min_frame_length = imgsensor_info.cap.framelength;
-	imgsensor.autoflicker_en = KAL_FALSE;
-    }
-	spin_unlock(&imgsensor_drv_lock);
-	capture_setting(imgsensor.current_fps);
-	mdelay(100);
-	return ERROR_NONE;
-}	/* capture() */
-static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("E\n");
-	
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.sensor_mode = IMGSENSOR_MODE_VIDEO;
-	imgsensor.pclk = imgsensor_info.normal_video.pclk;
-	imgsensor.line_length = imgsensor_info.normal_video.linelength;
-	imgsensor.frame_length = imgsensor_info.normal_video.framelength;  
-	imgsensor.min_frame_length = imgsensor_info.normal_video.framelength;
-	//imgsensor.current_fps = 300;
-	imgsensor.autoflicker_en = KAL_FALSE;
-	spin_unlock(&imgsensor_drv_lock);
-	normal_video_setting(imgsensor.current_fps);
-	return ERROR_NONE;
-}	/*	normal_video   */
-
-static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("E\n");
-	
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.sensor_mode = IMGSENSOR_MODE_HIGH_SPEED_VIDEO;
-	imgsensor.pclk = imgsensor_info.hs_video.pclk;
-	//imgsensor.video_mode = KAL_TRUE;
-	imgsensor.line_length = imgsensor_info.hs_video.linelength;
-	imgsensor.frame_length = imgsensor_info.hs_video.framelength; 
-	imgsensor.min_frame_length = imgsensor_info.hs_video.framelength;
-	imgsensor.dummy_line = 0;
-	imgsensor.dummy_pixel = 0;
-	//imgsensor.current_fps = 600;
-	imgsensor.autoflicker_en = KAL_FALSE;
-	spin_unlock(&imgsensor_drv_lock);
-	hs_video_setting();
-	
-	return ERROR_NONE;
-}	/*	hs_video   */
-
-static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("E\n");
-	
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.sensor_mode = IMGSENSOR_MODE_SLIM_VIDEO;
-	imgsensor.pclk = imgsensor_info.slim_video.pclk;
-	//imgsensor.video_mode = KAL_TRUE;
-	imgsensor.line_length = imgsensor_info.slim_video.linelength;
-	imgsensor.frame_length = imgsensor_info.slim_video.framelength; 
-	imgsensor.min_frame_length = imgsensor_info.slim_video.framelength;
-	imgsensor.dummy_line = 0;
-	imgsensor.dummy_pixel = 0;
-	//imgsensor.current_fps = 1200;
-	imgsensor.autoflicker_en = KAL_FALSE;
-	spin_unlock(&imgsensor_drv_lock);
-	slim_video_setting();
-	
-	return ERROR_NONE;
-}	/*	slim_video	 */
-
-
-
-static kal_uint32 get_resolution(MSDK_SENSOR_RESOLUTION_INFO_STRUCT *sensor_resolution)
-{
-	LOG_INF("E\n");
-	sensor_resolution->SensorFullWidth = imgsensor_info.cap.grabwindow_width;
-	sensor_resolution->SensorFullHeight = imgsensor_info.cap.grabwindow_height;
-	
-	sensor_resolution->SensorPreviewWidth = imgsensor_info.pre.grabwindow_width;
-	sensor_resolution->SensorPreviewHeight = imgsensor_info.pre.grabwindow_height;
-
-	sensor_resolution->SensorVideoWidth = imgsensor_info.normal_video.grabwindow_width;
-	sensor_resolution->SensorVideoHeight = imgsensor_info.normal_video.grabwindow_height;		
-
-	
-	sensor_resolution->SensorHighSpeedVideoWidth	 = imgsensor_info.hs_video.grabwindow_width;
-	sensor_resolution->SensorHighSpeedVideoHeight	 = imgsensor_info.hs_video.grabwindow_height;
-	
-	sensor_resolution->SensorSlimVideoWidth	 = imgsensor_info.slim_video.grabwindow_width;
-	sensor_resolution->SensorSlimVideoHeight	 = imgsensor_info.slim_video.grabwindow_height;
-	return ERROR_NONE;
-}	/*	get_resolution	*/
-
-static kal_uint32 get_info(MSDK_SCENARIO_ID_ENUM scenario_id,
-					  MSDK_SENSOR_INFO_STRUCT *sensor_info,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("scenario_id = %d\n", scenario_id);
-
-	
-	//sensor_info->SensorVideoFrameRate = imgsensor_info.normal_video.max_framerate/10; /* not use */
-	//sensor_info->SensorStillCaptureFrameRate= imgsensor_info.cap.max_framerate/10; /* not use */
-	//imgsensor_info->SensorWebCamCaptureFrameRate= imgsensor_info.v.max_framerate; /* not use */
-
-	sensor_info->SensorClockPolarity = SENSOR_CLOCK_POLARITY_LOW;
-	sensor_info->SensorClockFallingPolarity = SENSOR_CLOCK_POLARITY_LOW; /* not use */
-	sensor_info->SensorHsyncPolarity = SENSOR_CLOCK_POLARITY_LOW; // inverse with datasheet
-	sensor_info->SensorVsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
-	sensor_info->SensorInterruptDelayLines = 4; /* not use */
-	sensor_info->SensorResetActiveHigh = FALSE; /* not use */
-	sensor_info->SensorResetDelayCount = 5; /* not use */
-
-	sensor_info->SensroInterfaceType = imgsensor_info.sensor_interface_type;
-    sensor_info->MIPIsensorType = imgsensor_info.mipi_sensor_type;
-    sensor_info->SettleDelayMode = imgsensor_info.mipi_settle_delay_mode;
-
-	sensor_info->SensorOutputDataFormat = imgsensor_info.sensor_output_dataformat;
-
-	sensor_info->CaptureDelayFrame = imgsensor_info.cap_delay_frame; 
-	sensor_info->PreviewDelayFrame = imgsensor_info.pre_delay_frame; 
-	sensor_info->VideoDelayFrame = imgsensor_info.video_delay_frame;
-	sensor_info->HighSpeedVideoDelayFrame = imgsensor_info.hs_video_delay_frame;
-	sensor_info->SlimVideoDelayFrame = imgsensor_info.slim_video_delay_frame;
-
-	sensor_info->SensorMasterClockSwitch = 0; /* not use */
-	sensor_info->SensorDrivingCurrent = imgsensor_info.isp_driving_current;
-	
-	sensor_info->AEShutDelayFrame = imgsensor_info.ae_shut_delay_frame; 		 /* The frame of setting shutter default 0 for TG int */
-	sensor_info->AESensorGainDelayFrame = imgsensor_info.ae_sensor_gain_delay_frame;	/* The frame of setting sensor gain */
-	sensor_info->AEISPGainDelayFrame = imgsensor_info.ae_ispGain_delay_frame;	
-	sensor_info->IHDR_Support = imgsensor_info.ihdr_support;
-	sensor_info->IHDR_LE_FirstLine = imgsensor_info.ihdr_le_firstline;
-	sensor_info->SensorModeNum = imgsensor_info.sensor_mode_num;
-	
-	sensor_info->SensorMIPILaneNumber = imgsensor_info.mipi_lane_num; 
-	sensor_info->SensorClockFreq = imgsensor_info.mclk;
-	sensor_info->SensorClockDividCount = 3; /* not use */
-	sensor_info->SensorClockRisingCount = 0;
-	sensor_info->SensorClockFallingCount = 2; /* not use */
-	sensor_info->SensorPixelClockCount = 3; /* not use */
-	sensor_info->SensorDataLatchCount = 2; /* not use */
-	
-	sensor_info->MIPIDataLowPwr2HighSpeedTermDelayCount = 0; 
-	sensor_info->MIPICLKLowPwr2HighSpeedTermDelayCount = 0;
-	sensor_info->SensorWidthSampling = 0;  // 0 is default 1x
-	sensor_info->SensorHightSampling = 0;	// 0 is default 1x 
-	sensor_info->SensorPacketECCOrder = 1;
-
-	switch (scenario_id) {
-		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-			sensor_info->SensorGrabStartX = imgsensor_info.pre.startx; 
-			sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;		
-			
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
-			
-			break;
-		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
-			sensor_info->SensorGrabStartX = imgsensor_info.cap.startx; 
-			sensor_info->SensorGrabStartY = imgsensor_info.cap.starty;
-				  
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.cap.mipi_data_lp2hs_settle_dc; 
-
-			break;	 
-		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-			
-			sensor_info->SensorGrabStartX = imgsensor_info.normal_video.startx; 
-			sensor_info->SensorGrabStartY = imgsensor_info.normal_video.starty;
-	   
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.normal_video.mipi_data_lp2hs_settle_dc; 
-
-			break;	  
-		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:			
-			sensor_info->SensorGrabStartX = imgsensor_info.hs_video.startx; 
-			sensor_info->SensorGrabStartY = imgsensor_info.hs_video.starty;
-				  
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.hs_video.mipi_data_lp2hs_settle_dc; 
-
-			break;
-		case MSDK_SCENARIO_ID_SLIM_VIDEO:
-			sensor_info->SensorGrabStartX = imgsensor_info.slim_video.startx; 
-			sensor_info->SensorGrabStartY = imgsensor_info.slim_video.starty;
-				  
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.slim_video.mipi_data_lp2hs_settle_dc; 
-
-			break;
-		default:			
-			sensor_info->SensorGrabStartX = imgsensor_info.pre.startx; 
-			sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;		
-			
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
-			break;
-	}
-	
-	return ERROR_NONE;
-}	/*	get_info  */
-
-
-static kal_uint32 control(MSDK_SCENARIO_ID_ENUM scenario_id, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("scenario_id = %d\n", scenario_id);
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.current_scenario_id = scenario_id;
-	spin_unlock(&imgsensor_drv_lock);
-	switch (scenario_id) {
-		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-			preview(image_window, sensor_config_data);
-			break;
-		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
-			capture(image_window, sensor_config_data);
-			break;	
-		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-			normal_video(image_window, sensor_config_data);
-			break;	  
-		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
-			hs_video(image_window, sensor_config_data);
-			break;
-		case MSDK_SCENARIO_ID_SLIM_VIDEO:
-			slim_video(image_window, sensor_config_data);
-			break;	  
-		default:
-			LOG_INF("Error ScenarioId setting");
-			preview(image_window, sensor_config_data);
-			return ERROR_INVALID_SCENARIO_ID;
-	}
-	return ERROR_NONE;
-}	/* control() */
-
-
-
-static kal_uint32 set_video_mode(UINT16 framerate)
-{
-	LOG_INF("framerate = %d\n ", framerate);
-	// SetVideoMode Function should fix framerate
-	if (framerate == 0)
-		// Dynamic frame rate
-		return ERROR_NONE;
-	spin_lock(&imgsensor_drv_lock);
-	if ((framerate == 300) && (imgsensor.autoflicker_en == KAL_TRUE))
-		imgsensor.current_fps = 296;
-	else if ((framerate == 150) && (imgsensor.autoflicker_en == KAL_TRUE))
-		imgsensor.current_fps = 146;
-	else
-		imgsensor.current_fps = framerate;
-	spin_unlock(&imgsensor_drv_lock);
-	set_max_framerate(imgsensor.current_fps,1);
-
-	return ERROR_NONE;
-}
-
-static kal_uint32 set_auto_flicker_mode(kal_bool enable, UINT16 framerate)
-{
-	LOG_INF("enable = %d, framerate = %d \n", enable, framerate);
-	spin_lock(&imgsensor_drv_lock);
-	if (enable) //enable auto flicker	  
-		imgsensor.autoflicker_en = KAL_TRUE;
-	else //Cancel Auto flick
-		imgsensor.autoflicker_en = KAL_FALSE;
-	spin_unlock(&imgsensor_drv_lock);
-	return ERROR_NONE;
-}
-
-static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 framerate) 
-{
-	kal_uint32 frame_length;
-  
-	LOG_INF("scenario_id = %d, framerate = %d\n", scenario_id, framerate);
-
-	switch (scenario_id) {
-		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-			frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
-			imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();			
-			break;			
-		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-			if(framerate == 0)
-				return ERROR_NONE;
-			frame_length = imgsensor_info.normal_video.pclk / framerate * 10 / imgsensor_info.normal_video.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.normal_video.framelength) ? (frame_length - imgsensor_info.normal_video.framelength) : 0;			
-			imgsensor.frame_length = imgsensor_info.normal_video.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();			
-			break;
-		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:		
-        	  if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {
-                frame_length = imgsensor_info.cap1.pclk / framerate * 10 / imgsensor_info.cap1.linelength;
-                spin_lock(&imgsensor_drv_lock);
-		            imgsensor.dummy_line = (frame_length > imgsensor_info.cap1.framelength) ? (frame_length - imgsensor_info.cap1.framelength) : 0;
-		            imgsensor.frame_length = imgsensor_info.cap1.framelength + imgsensor.dummy_line;
-		            imgsensor.min_frame_length = imgsensor.frame_length;
-		            spin_unlock(&imgsensor_drv_lock);
-            } else {
-        		    if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
-                    LOG_INF("Warning: current_fps %d fps is not support, so use cap's setting: %d fps!\n",framerate,imgsensor_info.cap.max_framerate/10);
-			frame_length = imgsensor_info.cap.pclk / framerate * 10 / imgsensor_info.cap.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.cap.framelength) ? (frame_length - imgsensor_info.cap.framelength) : 0;
-			imgsensor.frame_length = imgsensor_info.cap.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-            }
-			set_dummy();			
-			break;	
-		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
-			frame_length = imgsensor_info.hs_video.pclk / framerate * 10 / imgsensor_info.hs_video.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.hs_video.framelength) ? (frame_length - imgsensor_info.hs_video.framelength) : 0;
-			imgsensor.frame_length = imgsensor_info.hs_video.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();			
-			break;
-		case MSDK_SCENARIO_ID_SLIM_VIDEO:
-			frame_length = imgsensor_info.slim_video.pclk / framerate * 10 / imgsensor_info.slim_video.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.slim_video.framelength) ? (frame_length - imgsensor_info.slim_video.framelength): 0;	
-			imgsensor.frame_length = imgsensor_info.slim_video.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();	
-			break;		
-		default:  //coding with  preview scenario by default
-			frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
-			imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();	
-			LOG_INF("error scenario_id = %d, we use preview scenario \n", scenario_id);
-			break;
-	}	
-	return ERROR_NONE;
-}
-
-
-static kal_uint32 get_default_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 *framerate) 
-{
-	LOG_INF("scenario_id = %d\n", scenario_id);
-
-	switch (scenario_id) {
-		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-			*framerate = imgsensor_info.pre.max_framerate;
-			break;
-		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-			*framerate = imgsensor_info.normal_video.max_framerate;
-			break;
-		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
-			*framerate = imgsensor_info.cap.max_framerate;
-			break;		
-		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
-			*framerate = imgsensor_info.hs_video.max_framerate;
-			break;
-		case MSDK_SCENARIO_ID_SLIM_VIDEO: 
-			*framerate = imgsensor_info.slim_video.max_framerate;
-			break;
-		default:
-			break;
-	}
-
-	return ERROR_NONE;
-}
-
-static kal_uint32 set_test_pattern_mode(kal_bool enable)
-{
-	LOG_INF("enable: %d\n", enable);
-
-	if (enable) {
-		// 0x5080[8]: 1 enable,  0 disable
-		// 0x5080[1:0]; 00 Color bar, 01 Random Data, 10 Square, 11 BLACK
-		write_cmos_sensor(0x5080, 0x80);
-	} else {
-		// 0x5080[8]: 1 enable,  0 disable
-		// 0x5080[1:0]; 00 Color bar, 01 Random Data, 10 Square, 11 BLACK
-		write_cmos_sensor(0x5080, 0x00);
-	}	 
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.test_pattern = enable;
-	spin_unlock(&imgsensor_drv_lock);
-	return ERROR_NONE;
-}
-
-static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
-							 UINT8 *feature_para,UINT32 *feature_para_len)
-{
-	UINT16 *feature_return_para_16=(UINT16 *) feature_para;
-	UINT16 *feature_data_16=(UINT16 *) feature_para;
-	UINT32 *feature_return_para_32=(UINT32 *) feature_para;
-	UINT32 *feature_data_32=(UINT32 *) feature_para;
-	unsigned long long *feature_data=(unsigned long long *) feature_para;
-    unsigned long long *feature_return_para=(unsigned long long *) feature_para;
-
-	SENSOR_WINSIZE_INFO_STRUCT *wininfo;	
-	MSDK_SENSOR_REG_INFO_STRUCT *sensor_reg_data=(MSDK_SENSOR_REG_INFO_STRUCT *) feature_para;
- 
-	LOG_INF("feature_id = %d\n", feature_id);
-	switch (feature_id) {
-		case SENSOR_FEATURE_GET_PERIOD:
-			*feature_return_para_16++ = imgsensor.line_length;
-			*feature_return_para_16 = imgsensor.frame_length;
-			*feature_para_len=4;
-			break;
-		case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:	 
-			*feature_return_para_32 = imgsensor.pclk;
-			*feature_para_len=4;
-			break;		   
-		case SENSOR_FEATURE_SET_ESHUTTER:
-			set_shutter(*feature_data);
-			break;
-		case SENSOR_FEATURE_SET_NIGHTMODE:
-			night_mode((BOOL) *feature_data);
-			break;
-		case SENSOR_FEATURE_SET_GAIN:		
-			set_gain((UINT16) *feature_data);
-			break;
-		case SENSOR_FEATURE_SET_FLASHLIGHT:
-			break;
-		case SENSOR_FEATURE_SET_ISP_MASTER_CLOCK_FREQ:
-			break;
-		case SENSOR_FEATURE_SET_REGISTER:
-			write_cmos_sensor(sensor_reg_data->RegAddr, sensor_reg_data->RegData);
-			break;
-		case SENSOR_FEATURE_GET_REGISTER:
-			sensor_reg_data->RegData = read_cmos_sensor(sensor_reg_data->RegAddr);
-			break;
-		case SENSOR_FEATURE_GET_LENS_DRIVER_ID:
-			// get the lens driver ID from EEPROM or just return LENS_DRIVER_ID_DO_NOT_CARE
-			// if EEPROM does not exist in camera module.
-			*feature_return_para_32=LENS_DRIVER_ID_DO_NOT_CARE;
-			*feature_para_len=4;
-			break;
-		case SENSOR_FEATURE_SET_VIDEO_MODE:
-			set_video_mode(*feature_data);
-			break; 
-		case SENSOR_FEATURE_CHECK_SENSOR_ID:
-			get_imgsensor_id(feature_return_para_32); 
-			break; 
-		case SENSOR_FEATURE_SET_AUTO_FLICKER_MODE:
-			set_auto_flicker_mode((BOOL)*feature_data_16,*(feature_data_16+1));
-			break;
-		case SENSOR_FEATURE_SET_MAX_FRAME_RATE_BY_SCENARIO:
-			set_max_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data, *(feature_data+1));
-			break;
-		case SENSOR_FEATURE_GET_DEFAULT_FRAME_RATE_BY_SCENARIO:
-			get_default_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data, (MUINT32 *)(uintptr_t)(*(feature_data+1)));
-			break;
-		case SENSOR_FEATURE_SET_TEST_PATTERN:
-			set_test_pattern_mode((BOOL)*feature_data);
-			break;
-		case SENSOR_FEATURE_GET_TEST_PATTERN_CHECKSUM_VALUE: //for factory mode auto testing			 
-			*feature_return_para_32 = imgsensor_info.checksum_value;
-			*feature_para_len=4;							 
-			break;				
-		case SENSOR_FEATURE_SET_FRAMERATE:
-			LOG_INF("current fps :%d\n",  (UINT32)*feature_data);
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.current_fps = *feature_data;
-			spin_unlock(&imgsensor_drv_lock);		
-			break;
-		case SENSOR_FEATURE_SET_HDR:
-			LOG_INF("ihdr enable :%d\n", (BOOL)*feature_data);
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.ihdr_en = (bool)*feature_data;
-			spin_unlock(&imgsensor_drv_lock);		
-			break;
-		case SENSOR_FEATURE_GET_CROP_INFO:
-			LOG_INF("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n", (UINT32)*feature_data);
-			wininfo = (SENSOR_WINSIZE_INFO_STRUCT *)(uintptr_t)(*(feature_data+1));
-		
-			switch (*feature_data_32) {
-				case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
-					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[1],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-					break;	  
-				case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[2],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-					break;
-				case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
-					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[3],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-					break;
-				case MSDK_SCENARIO_ID_SLIM_VIDEO:
-					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[4],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-					break;
-				case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-				default:
-					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[0],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-					break;
-			}
-		case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
-			LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",(UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2)); 
-			ihdr_write_shutter_gain((UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));	
-			break;
-		default:
-			break;
-	}
-  
-	return ERROR_NONE;
-}	/*	feature_control()  */
-
-static SENSOR_FUNCTION_STRUCT sensor_func = {
-	open,
-	get_info,
-	get_resolution,
-	feature_control,
-	control,
-	close
-};
-
-/*UINT32 OV2680_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)*/
-UINT32 OV2680MIPISensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
-
-{
-	/* To Do : Check Sensor status here */
-	if (pfFunc!=NULL)
-		*pfFunc=&sensor_func;
-	return ERROR_NONE;
-}	/*	OV2680_MIPI_RAW_SensorInit	*/
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735/ov8858_mipi_raw/ov8858mipiraw_Sensor.c~ b/drivers/misc/mediatek/imgsensor/src/mt6735/ov8858_mipi_raw/ov8858mipiraw_Sensor.c~
deleted file mode 100755
index 729b6cb..0000000
--- a/drivers/misc/mediatek/imgsensor/src/mt6735/ov8858_mipi_raw/ov8858mipiraw_Sensor.c~
+++ /dev/null
@@ -1,2395 +0,0 @@
-/*****************************************************************************
- *
- * Filename:
- * ---------
- *	 OV8858mipiraw_sensor.c
- *
- * Project:
- * --------
- *	 ALPS MT6795
- *
- * Description:
- * ------------
- *	 Source code of Sensor driver
- *
- *	PengtaoFan
- *------------------------------------------------------------------------------
- * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
- *============================================================================
- ****************************************************************************/
-
-#include <linux/videodev2.h>
-#include <linux/i2c.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/cdev.h>
-#include <linux/uaccess.h>
-#include <linux/fs.h>
-#include <asm/atomic.h>
-//#include <asm/system.h>
-#include <linux/xlog.h>
-
-#include "kd_camera_hw.h"
-#include "kd_imgsensor.h"
-#include "kd_imgsensor_define.h"
-#include "kd_imgsensor_errcode.h"
-
-#include "ov8858mipiraw_Sensor.h"
-
-#define PFX "OV8858"
-
-//#define OV8858R2AOTP
-
-//#define LOG_WRN(format, args...) xlog_printk(ANDROID_LOG_WARN ,PFX, "[%S] " format, __FUNCTION__, ##args)
-//#defineLOG_INF(format, args...) xlog_printk(ANDROID_LOG_INFO ,PFX, "[%s] " format, __FUNCTION__, ##args)
-//#define LOG_DBG(format, args...) xlog_printk(ANDROID_LOG_DEBUG ,PFX, "[%S] " format, __FUNCTION__, ##args)
-#define LOG_INF(format, args...)	xlog_printk(ANDROID_LOG_INFO   , PFX, "[%s] " format, __FUNCTION__, ##args)
-typedef enum {
-	OV8858R2A,
-	OV8858R1A
-}OV8858_VERSION;
-
-OV8858_VERSION ov8858version = OV8858R2A;
-
-static DEFINE_SPINLOCK(imgsensor_drv_lock);
-
-static imgsensor_info_struct imgsensor_info = { 
-	.sensor_id = OV8858_SENSOR_ID,		//record sensor id defined in Kd_imgsensor.h
-	
-	.checksum_value = 0xd14be45,		//checksum value for Camera Auto Test
-	
-	.pre = {
-		.pclk = 74400000,				//record different mode's pclk
-		.linelength  = 1928,				//record different mode's linelength
-		.framelength = 1284,			//record different mode's framelength
-		.startx = 0,					//record different mode's startx of grabwindow
-		.starty = 0,					//record different mode's starty of grabwindow
-		.grabwindow_width  = 1632,		//record different mode's width of grabwindow
-		.grabwindow_height = 1224,		//record different mode's height of grabwindow
-		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
-		.mipi_data_lp2hs_settle_dc = 23,
-		/*	 following for GetDefaultFramerateByScenario()	*/
-		.max_framerate = 300,	
-	},
-	.cap = {
-		.pclk = 148800000,
-		.linelength  = 1940,
-		.framelength = 2556,
-		.startx = 0,
-		.starty = 0,
-		.grabwindow_width  = 3264,
-		.grabwindow_height = 2448,
-		.mipi_data_lp2hs_settle_dc = 23,
-		.max_framerate = 300,
-	},
-	.cap1 = {							//capture for PIP 24fps relative information, capture1 mode must use same framelength, linelength with Capture mode for shutter calculate
-		.pclk = 148800000,
-		.linelength  = 2425,
-		.framelength = 4090,//MODIFY FOR 15FPS FOR MT6735 //2556
-		.startx = 0,
-		.starty = 0,
-		.grabwindow_width  = 3264,
-		.grabwindow_height = 2448,
-		.mipi_data_lp2hs_settle_dc = 23,
-		.max_framerate = 150,
-	},
-	.normal_video = {
-		.pclk = 148800000,
-		.linelength  = 1940,
-		.framelength = 2556,
-		.startx = 0,
-		.starty = 0,
-		.grabwindow_width  = 3264,
-		.grabwindow_height = 2448,
-		.mipi_data_lp2hs_settle_dc = 23,
-		.max_framerate = 300,
-	},
-	.hs_video = {
-		.pclk = 148800000,				//record different mode's pclk
-		.linelength  = 2270,				//record different mode's linelength
-		.framelength = 546,			//record different mode's framelength
-		.startx = 0,					//record different mode's startx of grabwindow
-		.starty = 0,					//record different mode's starty of grabwindow
-		.grabwindow_width  = 640,		//record different mode's width of grabwindow
-		.grabwindow_height = 480,		//record different mode's height of grabwindow
-		/*	 following for  MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
-		.mipi_data_lp2hs_settle_dc = 30,
-		/*	 following for GetDefaultFramerateByScenario()	*/
-		.max_framerate = 1200,
-	},
-	.slim_video = {
-		.pclk = 74400000,				//record different mode's pclk
-		.linelength  = 1928,				//record different mode's linelength
-		.framelength = 1284,			//record different mode's framelength
-		.startx = 0,					//record different mode's startx of grabwindow
-		.starty = 0,					//record different mode's starty of grabwindow
-		.grabwindow_width  = 1632,		//record different mode's width of grabwindow
-		.grabwindow_height = 1224,		//record different mode's height of grabwindow
-		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
-		.mipi_data_lp2hs_settle_dc = 30,
-		/*	 following for GetDefaultFramerateByScenario()	*/
-		.max_framerate = 300,	
-
-	},
-	.margin = 4,			//sensor framelength & shutter margin
-	.min_shutter = 4,		//min shutter
-	.max_frame_length = 0x90f7,//max framelength by sensor register's limitation
-	.ae_shut_delay_frame = 0,	//shutter delay frame for AE cycle, 2 frame with ispGain_delay-shut_delay=2-0=2
-	.ae_sensor_gain_delay_frame = 0,//sensor gain delay frame for AE cycle,2 frame with ispGain_delay-sensor_gain_delay=2-0=2
-	.ae_ispGain_delay_frame = 2,//isp gain delay frame for AE cycle
-	.ihdr_support = 1,	  //1, support; 0,not support
-	.ihdr_le_firstline = 0,  //1,le first ; 0, se first
-	.sensor_mode_num = 5,	  //support sensor mode num ,don't support Slow motion
-	
-	.cap_delay_frame = 3,		//enter capture delay frame num
-	.pre_delay_frame = 3, 		//enter preview delay frame num
-	.video_delay_frame = 3,		//enter video delay frame num
-	.hs_video_delay_frame = 3,	//enter high speed video  delay frame num
-	.slim_video_delay_frame = 3,//enter slim video delay frame num
-	
-	.isp_driving_current = ISP_DRIVING_8MA, //mclk driving current
-	.sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,//sensor_interface_type
-	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_B,//sensor output first pixel color
-	.mclk = 24,//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
-	.mipi_lane_num = SENSOR_MIPI_4_LANE,//mipi lane num
-	.i2c_addr_table = {0x42, 0x20,0x6C,0xff},//record sensor support all write id addr, only supprt 4must end with 0xff
-};
-
-
-static imgsensor_struct imgsensor = {
-	.mirror = IMAGE_NORMAL,				//mirrorflip information
-	.sensor_mode = IMGSENSOR_MODE_INIT, //IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
-	.shutter = 0x4C00,					//current shutter
-	.gain = 0x200,						//current gain
-	.dummy_pixel = 0,					//current dummypixel
-	.dummy_line = 0,					//current dummyline
-	.current_fps = 0,  //full size current fps : 24fps for PIP, 30fps for Normal or ZSD
-	.autoflicker_en = KAL_FALSE,  //auto flicker enable: KAL_FALSE for disable auto flicker, KAL_TRUE for enable auto flicker
-	.test_pattern = KAL_FALSE,		//test pattern mode or not. KAL_FALSE for in test pattern mode, KAL_TRUE for normal output
-	.current_scenario_id = MSDK_SCENARIO_ID_CAMERA_PREVIEW,//current scenario id
-	.ihdr_en = 0, //sensor need support LE, SE with HDR feature
-	.i2c_write_id = 0x42,//record current sensor's i2c write id
-};
-
-
-/* Sensor output window information*/
-static SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[5] =	 
-{{ 3296, 2480,	  12,	12, 3272, 2456, 3264, 2452,   4,	2, 1632, 1224,	 0, 0, 1632, 1224}, // Preview 
- { 3296, 2480,	  12,	12, 3272, 2456, 3264, 2452,   4,	2, 3264, 2448,	 0, 0, 3264, 2448}, // capture 
- { 3296, 2480,	  12,	12, 3272, 2456, 3264, 2452,   4,	2, 3264, 2448,	 0, 0, 3264, 2448}, // video 
- { 3296, 2480,	  12,	12, 3272, 2456,  640,  480,   4,	2,  640,  480,	 0, 0,  640,  480}, //hight speed video 
- { 3296, 2480,	  12,	12, 3272, 2456, 3264, 2452,   4,	2, 1632, 1224,	 0, 0, 1632, 1224}};// slim video 
-
-static kal_uint16 read_cmos_sensor(kal_uint32 addr)
-{
-	kal_uint16 get_byte=0;
-
-	char pu_send_cmd[2] = {(char)(addr >> 8), (char)(addr & 0xFF) };
-	iReadRegI2C(pu_send_cmd, 2, (u8*)&get_byte, 1, imgsensor.i2c_write_id);
-
-	return get_byte;
-}
-
-static void write_cmos_sensor(kal_uint32 addr, kal_uint32 para)
-{
-	char pu_send_cmd[3] = {(char)(addr >> 8), (char)(addr & 0xFF), (char)(para & 0xFF)};
-	iWriteRegI2C(pu_send_cmd, 3, imgsensor.i2c_write_id);
-}
-
-static void set_dummy()
-{
-	LOG_INF("dummyline = %d, dummypixels = %d \n", imgsensor.dummy_line, imgsensor.dummy_pixel);
-	/* you can set dummy by imgsensor.dummy_line and imgsensor.dummy_pixel, or you can set dummy by imgsensor.frame_length and imgsensor.line_length */
-	write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
-	write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);	  
-	write_cmos_sensor(0x380c, imgsensor.line_length >> 8);
-	write_cmos_sensor(0x380d, imgsensor.line_length & 0xFF);
-  
-}	/*	set_dummy  */
-
-
-static void set_max_framerate(UINT16 framerate,kal_bool min_framelength_en)
-{
-	kal_int16 dummy_line;
-	kal_uint32 frame_length = imgsensor.frame_length;
-	//unsigned long flags;
-
-	LOG_INF("framerate = %d, min framelength should enable? \n", framerate,min_framelength_en);
-   
-	frame_length = imgsensor.pclk / framerate * 10 / imgsensor.line_length;
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.frame_length = (frame_length > imgsensor.min_frame_length) ? frame_length : imgsensor.min_frame_length; 
-	imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
-	//dummy_line = frame_length - imgsensor.min_frame_length;
-	//if (dummy_line < 0)
-		//imgsensor.dummy_line = 0;
-	//else
-		//imgsensor.dummy_line = dummy_line;
-	//imgsensor.frame_length = frame_length + imgsensor.dummy_line;
-	if (imgsensor.frame_length > imgsensor_info.max_frame_length)
-	{
-		imgsensor.frame_length = imgsensor_info.max_frame_length;
-		imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
-	}
-	if (min_framelength_en)
-		imgsensor.min_frame_length = imgsensor.frame_length;
-	spin_unlock(&imgsensor_drv_lock);
-	set_dummy();
-}	/*	set_max_framerate  */
-
-
-static void write_shutter(kal_uint16 shutter)
-{
-	kal_uint16 realtime_fps = 0;
-	kal_uint32 frame_length = 0;
-	   
-	/* 0x3500, 0x3501, 0x3502 will increase VBLANK to get exposure larger than frame exposure */
-	/* AE doesn't update sensor gain at capture mode, thus extra exposure lines must be updated here. */
-	
-	// OV Recommend Solution
-	// if shutter bigger than frame_length, should extend frame length first
-	spin_lock(&imgsensor_drv_lock);
-	if (shutter > imgsensor.min_frame_length - imgsensor_info.margin)		
-		imgsensor.frame_length = shutter + imgsensor_info.margin;
-	else
-		imgsensor.frame_length = imgsensor.min_frame_length;
-	if (imgsensor.frame_length > imgsensor_info.max_frame_length)
-		imgsensor.frame_length = imgsensor_info.max_frame_length;
-	spin_unlock(&imgsensor_drv_lock);
-	shutter = (shutter < imgsensor_info.min_shutter) ? imgsensor_info.min_shutter : shutter;
-	shutter = (shutter > (imgsensor_info.max_frame_length - imgsensor_info.margin)) ? (imgsensor_info.max_frame_length - imgsensor_info.margin) : shutter;
-	
-	if (imgsensor.autoflicker_en) { 
-		realtime_fps = imgsensor.pclk / imgsensor.line_length * 10 / imgsensor.frame_length;
-		if(realtime_fps >= 297 && realtime_fps <= 305)
-			set_max_framerate(296,0);
-		else if(realtime_fps >= 147 && realtime_fps <= 150)
-			set_max_framerate(146,0);	
-	} else {
-		// Extend frame length
-		write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
-		write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
-	}
-
-	// Update Shutter
-	write_cmos_sensor(0x3500, (shutter>>12) & 0x0F);
-	write_cmos_sensor(0x3501, (shutter>>4) & 0xFF);
-	write_cmos_sensor(0x3502, (shutter<<4) & 0xF0);	
-	LOG_INF("Exit! shutter =%d, framelength =%d\n", shutter,imgsensor.frame_length);
-
-	//LOG_INF("frame_length = %d ", frame_length);
-	
-}	/*	write_shutter  */
-
-
-
-/*************************************************************************
-* FUNCTION
-*	set_shutter
-*
-* DESCRIPTION
-*	This function set e-shutter of sensor to change exposure time.
-*
-* PARAMETERS
-*	iShutter : exposured lines
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static void set_shutter(kal_uint16 shutter)
-{
-	unsigned long flags;
-	kal_uint16 realtime_fps = 0;
-	kal_uint32 frame_length = 0;
-	spin_lock_irqsave(&imgsensor_drv_lock, flags);
-	imgsensor.shutter = shutter;
-	spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
-	
-	//write_shutter(shutter);
-	/* 0x3500, 0x3501, 0x3502 will increase VBLANK to get exposure larger than frame exposure */
-	/* AE doesn't update sensor gain at capture mode, thus extra exposure lines must be updated here. */
-	
-	// OV Recommend Solution
-	// if shutter bigger than frame_length, should extend frame length first
-	spin_lock(&imgsensor_drv_lock);
-	if (shutter > imgsensor.min_frame_length - imgsensor_info.margin)		
-		imgsensor.frame_length = shutter + imgsensor_info.margin;
-	else
-		imgsensor.frame_length = imgsensor.min_frame_length;
-	if (imgsensor.frame_length > imgsensor_info.max_frame_length)
-		imgsensor.frame_length = imgsensor_info.max_frame_length;
-	spin_unlock(&imgsensor_drv_lock);
-	shutter = (shutter < imgsensor_info.min_shutter) ? imgsensor_info.min_shutter : shutter;
-	shutter = (shutter > (imgsensor_info.max_frame_length - imgsensor_info.margin)) ? (imgsensor_info.max_frame_length - imgsensor_info.margin) : shutter;
-	
-	if (imgsensor.autoflicker_en) { 
-		realtime_fps = imgsensor.pclk / imgsensor.line_length * 10 / imgsensor.frame_length;
-		if(realtime_fps >= 297 && realtime_fps <= 305)
-			set_max_framerate(296,0);
-		else if(realtime_fps >= 147 && realtime_fps <= 150)
-			set_max_framerate(146,0);	
-		else {
-		// Extend frame length
-		write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
-		write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
-		}
-	} else {
-		// Extend frame length
-		write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
-		write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
-	}
-
-	// Update Shutter
-	write_cmos_sensor(0x3502, (shutter << 4) & 0xFF);
-	write_cmos_sensor(0x3501, (shutter >> 4) & 0xFF);	  
-	write_cmos_sensor(0x3500, (shutter >> 12) & 0x0F);	
-	LOG_INF("Exit! shutter =%d, framelength =%d\n", shutter,imgsensor.frame_length);
-
-}
-
-static kal_uint16 gain2reg(const kal_uint16 gain)
-{
-	kal_uint16 reg_gain = 0x0000;
-	
-	reg_gain = gain*2;
-	//reg_gain = reg_gain & 0xFFFF;
-	return (kal_uint16)reg_gain;
-}
-
-/*************************************************************************
-* FUNCTION
-*	set_gain
-*
-* DESCRIPTION
-*	This function is to set global gain to sensor.
-*
-* PARAMETERS
-*	iGain : sensor global gain(base: 0x40)
-*
-* RETURNS
-*	the actually gain set to sensor.
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint16 set_gain(kal_uint16 gain)
-{
-	LOG_INF("set_gain %d \n", gain);
-	kal_uint16 reg_gain;
-	if (gain < BASEGAIN || gain > 10 * BASEGAIN) {
-		LOG_INF("Error gain setting");
-
-		if (gain < BASEGAIN)
-			gain = BASEGAIN;
-		else if (gain > 10 * BASEGAIN)
-			gain = 10 * BASEGAIN;		 
-	}
-
-	//reg_gain = gain2reg(gain);
-	reg_gain = gain*2;
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.gain = reg_gain; 
-	spin_unlock(&imgsensor_drv_lock);
-	LOG_INF("gain = %d , reg_gain = 0x%x\n ", gain, reg_gain);
-
-	write_cmos_sensor(0x3508, (reg_gain>>8));
-	write_cmos_sensor(0x3509, (reg_gain&0xFF));    
-	return gain;
-}	/*	set_gain  */
-
-static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gain)
-{
-	LOG_INF("le:0x%x, se:0x%x, gain:0x%x\n",le,se,gain);
-	if (imgsensor.ihdr_en) {
-		
-		spin_lock(&imgsensor_drv_lock);
-			if (le > imgsensor.min_frame_length - imgsensor_info.margin)		
-				imgsensor.frame_length = le + imgsensor_info.margin;
-			else
-				imgsensor.frame_length = imgsensor.min_frame_length;
-			if (imgsensor.frame_length > imgsensor_info.max_frame_length)
-				imgsensor.frame_length = imgsensor_info.max_frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			if (le < imgsensor_info.min_shutter) le = imgsensor_info.min_shutter;
-			if (se < imgsensor_info.min_shutter) se = imgsensor_info.min_shutter;
-			
-			
-		// Extend frame length first
-		write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
-		write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
-
-		write_cmos_sensor(0x3502, (le << 4) & 0xFF);
-		write_cmos_sensor(0x3501, (le >> 4) & 0xFF);	 
-		write_cmos_sensor(0x3500, (le >> 12) & 0x0F);
-		
-		write_cmos_sensor(0x3512, (se << 4) & 0xFF); 
-		write_cmos_sensor(0x3511, (se >> 4) & 0xFF);
-		write_cmos_sensor(0x3510, (se >> 12) & 0x0F); 
-
-		set_gain(gain);
-	}
-
-}
-
-
-
-static void set_mirror_flip(kal_uint8 image_mirror)
-{
-	LOG_INF("image_mirror = %d\n", image_mirror);
-
-	/********************************************************
-	   *
-	   *   0x3820[2] ISP Vertical flip
-	   *   0x3820[1] Sensor Vertical flip
-	   *
-	   *   0x3821[2] ISP Horizontal mirror
-	   *   0x3821[1] Sensor Horizontal mirror
-	   *
-	   *   ISP and Sensor flip or mirror register bit should be the same!!
-	   *
-	   ********************************************************/
-	
-	switch (image_mirror) {
-		case IMAGE_NORMAL:
-			write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x00));
-			write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x06));
-			break;
-		case IMAGE_H_MIRROR:
-			write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x00));
-			write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x00));
-			break;
-		case IMAGE_V_MIRROR:
-			write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x06));
-			write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x06));		
-			break;
-		case IMAGE_HV_MIRROR:
-			write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x06));
-			write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x00));
-			break;
-		default:
-			LOG_INF("Error image_mirror setting\n");
-	}
-
-}
-
-/*************************************************************************
-* FUNCTION
-*	night_mode
-*
-* DESCRIPTION
-*	This function night mode of sensor.
-*
-* PARAMETERS
-*	bEnable: KAL_TRUE -> enable night mode, otherwise, disable night mode
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static void night_mode(kal_bool enable)
-{
-/*No Need to implement this function*/ 
-}	/*	night_mode	*/
-static void r1asensor_init(void)
-{
-	LOG_INF("E\n");
-//   ;-----------------------------------------
-//   @@ OV8858R1A Key 1632x1224_30FPS_MIPI_2LANE(Binning)
-//   100 99 1632 1224 ; Resolution
-//   102 80 1
-//   102 3601 bb8;30fps
-//   102 40 0 ; HDR Mode off
-//   ;FPGA set-up
-//   c8 01 f2 ;MIPI FPGA
-//   ;
-//   CL 100 100;delay
-//   ;;
-//   ;; MIPI=720Mbps, SysClk=144Mhz,Dac Clock=360Mhz.
-//   ;;
-//   ;;
-//   ;; v00_EM_AM14 (02/26/2014) : initial setting
-//   ;;
-//   ;; AM09 : Add 1080P,720P, HDR and 2 Lane Formats
-//   ;;      : Update the setting for R1A final Version(EK)
-//   ;; AM14 : fullwell 7K
-
-	write_cmos_sensor(0x3605, 0x30);
-	write_cmos_sensor(0x360b, 0x06);
-	write_cmos_sensor(0x360c, 0xdc);
-	write_cmos_sensor(0x3617, 0x90);
-	write_cmos_sensor(0x3618, 0x56);
-	write_cmos_sensor(0x361b, 0x00);
-	write_cmos_sensor(0x3633, 0x0c);
-	write_cmos_sensor(0x3634, 0x0c);
-	write_cmos_sensor(0x3635, 0x0c);
-	write_cmos_sensor(0x3636, 0x0c);
-	write_cmos_sensor(0x3501, 0x4b);
-	write_cmos_sensor(0x3502, 0xc0);
-	write_cmos_sensor(0x3503, 0x00);
-	write_cmos_sensor(0x3508, 0x01);
-	write_cmos_sensor(0x3706, 0x6a);
-	write_cmos_sensor(0x370b, 0x6a);
-	write_cmos_sensor(0x3750, 0x00);
-	write_cmos_sensor(0x3751, 0x00);
-	write_cmos_sensor(0x37b5, 0x33);
-	write_cmos_sensor(0x3d85, 0x14);
-	write_cmos_sensor(0x3d8c, 0x73);
-	write_cmos_sensor(0x3d8d, 0xde);
-	write_cmos_sensor(0x5780, 0xfc);
-	write_cmos_sensor(0x5781, 0xdf);
-	write_cmos_sensor(0x5782, 0x3f);
-	write_cmos_sensor(0x5783, 0x08);
-	write_cmos_sensor(0x5784, 0x0c);
-	write_cmos_sensor(0x5785, 0x10);
-	write_cmos_sensor(0x5786, 0x20);
-	write_cmos_sensor(0x5787, 0x40);
-	write_cmos_sensor(0x5788, 0x08);
-	write_cmos_sensor(0x5789, 0x08);
-	write_cmos_sensor(0x578a, 0x02);
-	write_cmos_sensor(0x578b, 0x01);
-	write_cmos_sensor(0x578c, 0x01);
-	write_cmos_sensor(0x578d, 0x0c);
-	write_cmos_sensor(0x578e, 0x02);
-	write_cmos_sensor(0x578f, 0x01);
-	write_cmos_sensor(0x5790, 0x01);
-	write_cmos_sensor(0x5791, 0xff);
-	write_cmos_sensor(0x5792, 0x07);
-	write_cmos_sensor(0x5793, 0x03);
-	write_cmos_sensor(0x5794, 0x03);
-	write_cmos_sensor(0x5871, 0x0d);
-	write_cmos_sensor(0x5870, 0x18);
-	write_cmos_sensor(0x586e, 0x40);
-	write_cmos_sensor(0x586f, 0x20);
-	write_cmos_sensor(0x58f8, 0x00);
-	write_cmos_sensor(0x3763, 0x00);
-	write_cmos_sensor(0x3768, 0x00);
-	write_cmos_sensor(0x470b, 0x00);
-	write_cmos_sensor(0x4202, 0x00);
-	write_cmos_sensor(0x400d, 0x20);
-	write_cmos_sensor(0x4040, 0x00);
-	write_cmos_sensor(0x403e, 0x00);
-	write_cmos_sensor(0x4041, 0x07);
-	write_cmos_sensor(0x3007, 0x00);
-	write_cmos_sensor(0x400a, 0x00);
-	write_cmos_sensor(0x4009, 0x81);
-	write_cmos_sensor(0x4011, 0x00);
-	write_cmos_sensor(0x4020, 0x00);
-	write_cmos_sensor(0x4021, 0x04);
-	write_cmos_sensor(0x4022, 0x04);
-	write_cmos_sensor(0x4023, 0xb9);
-	write_cmos_sensor(0x4024, 0x05);
-	write_cmos_sensor(0x4025, 0x2a);
-	write_cmos_sensor(0x4026, 0x05);
-	write_cmos_sensor(0x4027, 0x2b);
-	write_cmos_sensor(0x4028, 0x00);
-	write_cmos_sensor(0x4029, 0x02);
-	write_cmos_sensor(0x402a, 0x04);
-	write_cmos_sensor(0x402b, 0x04);
-	write_cmos_sensor(0x402c, 0x02);
-	write_cmos_sensor(0x402d, 0x02);
-	write_cmos_sensor(0x402e, 0x08);
-	write_cmos_sensor(0x402f, 0x02);
-}
-static void sensor_init(void)
-{
-	LOG_INF("E\n");
-//  @@ OV8858R2A Initial 1632x1224_30FPS_MIPI_2LANE(Binning)
-//  100 99 1632 1224 ; Resolution
-//  102 80 1
-//  102 3601 bb8;30fps
-//  102 40 0 ; HDR Mode off
-//  ;FPGA set-up
-//  c8 01 f2 ;MIPI FPGA
-//  ;
-//  CL 100 100;delay
-//  ;;
-//  ;; MIPI=720Mbps, SysClk=148.8Mhz,Dac Clock=360Mhz.
-//  ;;
-//  ;;
-//  ;; v00_01_00 (05/29/2014) : initial setting
-//  ;;
-//  ;; AM19 : 3617 <- 0xC0
-//  ;;
-//  ;; AM20 : change 0x3618=0x5a
-//  ;; AM22 :
-//  ;;   6c 3617 40 
-//  ::   6c 4011 20 
-//  ::   6c 403e 08
-//  ;;   6c 4040 07
-//  ;;   6c 58f8 3d
-//  ;;
-
-
-	write_cmos_sensor(0x103 , 0x01);
-	write_cmos_sensor(0x303f, 0x01);
-	write_cmos_sensor(0x3012, 0x6c);
-	write_cmos_sensor(0x100 , 0x00);
-	write_cmos_sensor(0x302 , 0x1e);
-	write_cmos_sensor(0x303 , 0x00);
-	write_cmos_sensor(0x304 , 0x03);
-	write_cmos_sensor(0x30d , 0x1f);
-	write_cmos_sensor(0x30e , 0x02);
-	write_cmos_sensor(0x30f , 0x04);
-	write_cmos_sensor(0x312 , 0x03);
-	write_cmos_sensor(0x31e , 0x0c);
-	write_cmos_sensor(0x3007, 0x80);
-	write_cmos_sensor(0x3600, 0x00);
-	write_cmos_sensor(0x3601, 0x00);
-	write_cmos_sensor(0x3602, 0x00);
-	write_cmos_sensor(0x3603, 0x00);
-	write_cmos_sensor(0x3604, 0x22);
-	write_cmos_sensor(0x3605, 0x20);
-	write_cmos_sensor(0x3606, 0x00);
-	write_cmos_sensor(0x3607, 0x20);
-	write_cmos_sensor(0x3608, 0x11);
-	write_cmos_sensor(0x3609, 0x28);
-	write_cmos_sensor(0x360a, 0x00);
-	write_cmos_sensor(0x360b, 0x05);
-	write_cmos_sensor(0x360c, 0xd4);
-	write_cmos_sensor(0x360d, 0x40);
-	write_cmos_sensor(0x360e, 0x0c);
-	write_cmos_sensor(0x360f, 0x20);
-	write_cmos_sensor(0x3610, 0x07);
-	write_cmos_sensor(0x3611, 0x20);
-	write_cmos_sensor(0x3612, 0x88);
-	write_cmos_sensor(0x3613, 0x80);
-	write_cmos_sensor(0x3614, 0x58);
-	write_cmos_sensor(0x3615, 0x00);
-	write_cmos_sensor(0x3616, 0x4a);
-	write_cmos_sensor(0x3617, 0x40);
-	write_cmos_sensor(0x3618, 0x5a);
-	write_cmos_sensor(0x3619, 0x70);
-	write_cmos_sensor(0x361a, 0x99);
-	write_cmos_sensor(0x361b, 0x0a);
-	write_cmos_sensor(0x361c, 0x07);
-	write_cmos_sensor(0x361d, 0x00);
-	write_cmos_sensor(0x361e, 0x00);
-	write_cmos_sensor(0x361f, 0x00);
-	write_cmos_sensor(0x3638, 0xff);
-	write_cmos_sensor(0x3633, 0x0f);
-	write_cmos_sensor(0x3634, 0x0f);
-	write_cmos_sensor(0x3635, 0x0f);
-	write_cmos_sensor(0x3636, 0x12);
-	write_cmos_sensor(0x3645, 0x13);
-	write_cmos_sensor(0x3646, 0x83);
-	write_cmos_sensor(0x364a, 0x07);
-	write_cmos_sensor(0x3015, 0x00);
-	write_cmos_sensor(0x3018, 0x72);
-	write_cmos_sensor(0x3020, 0x93);
-	write_cmos_sensor(0x3022, 0x01);
-	write_cmos_sensor(0x3031, 0x0a);
-	write_cmos_sensor(0x3034, 0x00);
-	write_cmos_sensor(0x3106, 0x01);
-	write_cmos_sensor(0x3305, 0xf1);
-	write_cmos_sensor(0x3308, 0x00);
-	write_cmos_sensor(0x3309, 0x28);
-	write_cmos_sensor(0x330a, 0x00);
-	write_cmos_sensor(0x330b, 0x20);
-	write_cmos_sensor(0x330c, 0x00);
-	write_cmos_sensor(0x330d, 0x00);
-	write_cmos_sensor(0x330e, 0x00);
-	write_cmos_sensor(0x330f, 0x40);
-	write_cmos_sensor(0x3307, 0x04);
-	write_cmos_sensor(0x3500, 0x00);
-	write_cmos_sensor(0x3501, 0x4d);
-	write_cmos_sensor(0x3502, 0x40);
-	write_cmos_sensor(0x3503, 0x80);
-	write_cmos_sensor(0x3505, 0x80);
-	write_cmos_sensor(0x3508, 0x02);
-	write_cmos_sensor(0x3509, 0x00);
-	write_cmos_sensor(0x350c, 0x00);
-	write_cmos_sensor(0x350d, 0x80);
-	write_cmos_sensor(0x3510, 0x00);
-	write_cmos_sensor(0x3511, 0x02);
-	write_cmos_sensor(0x3512, 0x00);
-	write_cmos_sensor(0x3700, 0x18);
-	write_cmos_sensor(0x3701, 0x0c);
-	write_cmos_sensor(0x3702, 0x28);
-	write_cmos_sensor(0x3703, 0x19);
-	write_cmos_sensor(0x3704, 0x14);
-	write_cmos_sensor(0x3705, 0x00);
-	write_cmos_sensor(0x3706, 0x82);
-	write_cmos_sensor(0x3707, 0x04);
-	write_cmos_sensor(0x3708, 0x24);
-	write_cmos_sensor(0x3709, 0x33);
-	write_cmos_sensor(0x370a, 0x01);
-	write_cmos_sensor(0x370b, 0x82);
-	write_cmos_sensor(0x370c, 0x04);
-	write_cmos_sensor(0x3718, 0x12);
-	write_cmos_sensor(0x3719, 0x31);
-	write_cmos_sensor(0x3712, 0x42);
-	write_cmos_sensor(0x3714, 0x24);
-	write_cmos_sensor(0x371e, 0x19);
-	write_cmos_sensor(0x371f, 0x40);
-	write_cmos_sensor(0x3720, 0x05);
-	write_cmos_sensor(0x3721, 0x05);
-	write_cmos_sensor(0x3724, 0x06);
-	write_cmos_sensor(0x3725, 0x01);
-	write_cmos_sensor(0x3726, 0x06);
-	write_cmos_sensor(0x3728, 0x05);
-	write_cmos_sensor(0x3729, 0x02);
-	write_cmos_sensor(0x372a, 0x03);
-	write_cmos_sensor(0x372b, 0x53);
-	write_cmos_sensor(0x372c, 0xa3);
-	write_cmos_sensor(0x372d, 0x53);
-	write_cmos_sensor(0x372e, 0x06);
-	write_cmos_sensor(0x372f, 0x10);
-	write_cmos_sensor(0x3730, 0x01);
-	write_cmos_sensor(0x3731, 0x06);
-	write_cmos_sensor(0x3732, 0x14);
-	write_cmos_sensor(0x3733, 0x10);
-	write_cmos_sensor(0x3734, 0x40);
-	write_cmos_sensor(0x3736, 0x20);
-	write_cmos_sensor(0x373a, 0x05);
-	write_cmos_sensor(0x373b, 0x06);
-	write_cmos_sensor(0x373c, 0x0a);
-	write_cmos_sensor(0x373e, 0x03);
-	write_cmos_sensor(0x3750, 0x0a);
-	write_cmos_sensor(0x3751, 0x0e);
-	write_cmos_sensor(0x3755, 0x10);
-	write_cmos_sensor(0x3758, 0x00);
-	write_cmos_sensor(0x3759, 0x4c);
-	write_cmos_sensor(0x375a, 0x06);
-	write_cmos_sensor(0x375b, 0x13);
-	write_cmos_sensor(0x375c, 0x20);
-	write_cmos_sensor(0x375d, 0x02);
-	write_cmos_sensor(0x375e, 0x00);
-	write_cmos_sensor(0x375f, 0x14);
-	write_cmos_sensor(0x3768, 0xcc);
-	write_cmos_sensor(0x3769, 0x44);
-	write_cmos_sensor(0x376a, 0x44);
-	write_cmos_sensor(0x3761, 0x00);
-	write_cmos_sensor(0x3762, 0x00);
-	write_cmos_sensor(0x3763, 0x18);
-	write_cmos_sensor(0x3766, 0xff);
-	write_cmos_sensor(0x376b, 0x00);
-	write_cmos_sensor(0x3772, 0x23);
-	write_cmos_sensor(0x3773, 0x02);
-	write_cmos_sensor(0x3774, 0x16);
-	write_cmos_sensor(0x3775, 0x12);
-	write_cmos_sensor(0x3776, 0x04);
-	write_cmos_sensor(0x3777, 0x00);
-	write_cmos_sensor(0x3778, 0x17);
-	write_cmos_sensor(0x37a0, 0x44);
-	write_cmos_sensor(0x37a1, 0x3d);
-	write_cmos_sensor(0x37a2, 0x3d);
-	write_cmos_sensor(0x37a3, 0x00);
-	write_cmos_sensor(0x37a4, 0x00);
-	write_cmos_sensor(0x37a5, 0x00);
-	write_cmos_sensor(0x37a6, 0x00);
-	write_cmos_sensor(0x37a7, 0x44);
-	write_cmos_sensor(0x37a8, 0x4c);
-	write_cmos_sensor(0x37a9, 0x4c);
-	write_cmos_sensor(0x3760, 0x00);
-	write_cmos_sensor(0x376f, 0x01);
-	write_cmos_sensor(0x37aa, 0x44);
-	write_cmos_sensor(0x37ab, 0x2e);
-	write_cmos_sensor(0x37ac, 0x2e);
-	write_cmos_sensor(0x37ad, 0x33);
-	write_cmos_sensor(0x37ae, 0x0d);
-	write_cmos_sensor(0x37af, 0x0d);
-	write_cmos_sensor(0x37b0, 0x00);
-	write_cmos_sensor(0x37b1, 0x00);
-	write_cmos_sensor(0x37b2, 0x00);
-	write_cmos_sensor(0x37b3, 0x42);
-	write_cmos_sensor(0x37b4, 0x42);
-	write_cmos_sensor(0x37b5, 0x31);
-	write_cmos_sensor(0x37b6, 0x00);
-	write_cmos_sensor(0x37b7, 0x00);
-	write_cmos_sensor(0x37b8, 0x00);
-	write_cmos_sensor(0x37b9, 0xff);
-	write_cmos_sensor(0x3800, 0x00);
-	write_cmos_sensor(0x3801, 0x0c);
-	write_cmos_sensor(0x3802, 0x00);
-	write_cmos_sensor(0x3803, 0x0c);
-	write_cmos_sensor(0x3804, 0x0c);
-	write_cmos_sensor(0x3805, 0xd3);
-	write_cmos_sensor(0x3806, 0x09);
-	write_cmos_sensor(0x3807, 0xa3);
-	write_cmos_sensor(0x3808, 0x06);
-	write_cmos_sensor(0x3809, 0x60);
-	write_cmos_sensor(0x380a, 0x04);
-	write_cmos_sensor(0x380b, 0xc8);
-	write_cmos_sensor(0x380c, 0x07);
-	write_cmos_sensor(0x380d, 0x88);
-	write_cmos_sensor(0x380e, 0x04);
-	write_cmos_sensor(0x380f, 0xdc);
-	write_cmos_sensor(0x3810, 0x00);
-	write_cmos_sensor(0x3811, 0x04);
-	write_cmos_sensor(0x3813, 0x02);
-	write_cmos_sensor(0x3814, 0x03);
-	write_cmos_sensor(0x3815, 0x01);
-	write_cmos_sensor(0x3820, 0x00);
-	write_cmos_sensor(0x3821, 0x67);
-	write_cmos_sensor(0x382a, 0x03);
-	write_cmos_sensor(0x382b, 0x01);
-	write_cmos_sensor(0x3830, 0x08);
-	write_cmos_sensor(0x3836, 0x02);
-	write_cmos_sensor(0x3837, 0x18);
-	
-	// modify for pre cap view diff 20150105
-	//write_cmos_sensor(0x3841, 0xff);
-	write_cmos_sensor(0x3841, 0xef);
-	
-	write_cmos_sensor(0x3846, 0x48);
-	write_cmos_sensor(0x3d85, 0x16);
-	write_cmos_sensor(0x3d8c, 0x73);
-	write_cmos_sensor(0x3d8d, 0xde);
-	write_cmos_sensor(0x3f08, 0x08);
-	write_cmos_sensor(0x3f0a, 0x00);
-	write_cmos_sensor(0x4000, 0xf1);
-	write_cmos_sensor(0x4001, 0x10);
-	write_cmos_sensor(0x4005, 0x10);
-	write_cmos_sensor(0x4002, 0x27);
-	write_cmos_sensor(0x4009, 0x83);
-	write_cmos_sensor(0x400a, 0x01);
-	write_cmos_sensor(0x400b, 0x0c);
-	write_cmos_sensor(0x400d, 0x10);
-	write_cmos_sensor(0x4011, 0x20);
-	write_cmos_sensor(0x401b, 0x00);
-	write_cmos_sensor(0x401d, 0x00);
-	write_cmos_sensor(0x4020, 0x00);
-	write_cmos_sensor(0x4021, 0x04);
-	write_cmos_sensor(0x4022, 0x04);
-	write_cmos_sensor(0x4023, 0xb9);
-	write_cmos_sensor(0x4024, 0x05);
-	write_cmos_sensor(0x4025, 0x2a);
-	write_cmos_sensor(0x4026, 0x05);
-	write_cmos_sensor(0x4027, 0x2b);
-	write_cmos_sensor(0x4028, 0x00);
-	write_cmos_sensor(0x4029, 0x02);
-	write_cmos_sensor(0x402a, 0x04);
-	write_cmos_sensor(0x402b, 0x04);
-	write_cmos_sensor(0x402c, 0x02);
-	write_cmos_sensor(0x402d, 0x02);
-	write_cmos_sensor(0x402e, 0x08);
-	write_cmos_sensor(0x402f, 0x02);
-	write_cmos_sensor(0x401f, 0x00);
-	write_cmos_sensor(0x4034, 0x3f);
-	write_cmos_sensor(0x403d, 0x04);
-	write_cmos_sensor(0x403e, 0x08);
-	write_cmos_sensor(0x4040, 0x07);
-	write_cmos_sensor(0x4041, 0xc6);
-	write_cmos_sensor(0x4300, 0xff);
-	write_cmos_sensor(0x4202, 0x00);
-	write_cmos_sensor(0x4301, 0x00);
-	write_cmos_sensor(0x4302, 0x0f);
-	write_cmos_sensor(0x4316, 0x00);
-	write_cmos_sensor(0x4500, 0x58);
-	write_cmos_sensor(0x4503, 0x18);
-	write_cmos_sensor(0x4600, 0x00);
-	write_cmos_sensor(0x4601, 0xcb);
-	write_cmos_sensor(0x470b, 0x28);
-	
-	//NO CONTIUS MODE ADD BY PENGTAO FAN 20140723
-	//write_cmos_sensor(0x4800, 0x6C);
-	//CONTIUS MODE ADD BY PENGTAO FAN 20140723
-	//write_cmos_sensor(0x4800, 0x4C);
-	write_cmos_sensor(0x4800, 0x4C);
-	
-	write_cmos_sensor(0x481f, 0x32);
-	write_cmos_sensor(0x4837, 0x16);
-	write_cmos_sensor(0x4850, 0x10);
-	write_cmos_sensor(0x4851, 0x32);
-	write_cmos_sensor(0x4b00, 0x2a);
-	write_cmos_sensor(0x4b0d, 0x00);
-	write_cmos_sensor(0x4d00, 0x04);
-	write_cmos_sensor(0x4d01, 0x18);
-	write_cmos_sensor(0x4d02, 0xc3);
-	write_cmos_sensor(0x4d03, 0xff);
-	write_cmos_sensor(0x4d04, 0xff);
-	write_cmos_sensor(0x4d05, 0xff);
-	//DPC off white test(0x5000, 0x78);
-	//DPC on  white test(0x5000, 0x7e);
-	write_cmos_sensor(0x5000, 0x7e);
-	write_cmos_sensor(0x5001, 0x01);
-	write_cmos_sensor(0x5002, 0x08);
-	write_cmos_sensor(0x5003, 0x20);
-	write_cmos_sensor(0x5046, 0x12);
-	write_cmos_sensor(0x5780, 0x3e);
-	write_cmos_sensor(0x5781, 0x0f);
-	write_cmos_sensor(0x5782, 0x44);
-	write_cmos_sensor(0x5783, 0x02);
-	write_cmos_sensor(0x5784, 0x01);
-	write_cmos_sensor(0x5785, 0x00);
-	write_cmos_sensor(0x5786, 0x00);
-	write_cmos_sensor(0x5787, 0x04);
-	write_cmos_sensor(0x5788, 0x02);
-	write_cmos_sensor(0x5789, 0x0f);
-	write_cmos_sensor(0x578a, 0xfd);
-	write_cmos_sensor(0x578b, 0xf5);
-	write_cmos_sensor(0x578c, 0xf5);
-	write_cmos_sensor(0x578d, 0x03);
-	write_cmos_sensor(0x578e, 0x08);
-	write_cmos_sensor(0x578f, 0x0c);
-	write_cmos_sensor(0x5790, 0x08);
-	write_cmos_sensor(0x5791, 0x04);
-	write_cmos_sensor(0x5792, 0x00);
-	write_cmos_sensor(0x5793, 0x52);
-	write_cmos_sensor(0x5794, 0xa3);
-	write_cmos_sensor(0x5871, 0x0d);
-	write_cmos_sensor(0x5870, 0x18);
-	write_cmos_sensor(0x586e, 0x10);
-	write_cmos_sensor(0x586f, 0x08);
-	write_cmos_sensor(0x58f8, 0x3d); //; LEN VSCALE FACTOR
-	write_cmos_sensor(0x5901, 0x00);
-	write_cmos_sensor(0x5b00, 0x02);
-	write_cmos_sensor(0x5b01, 0x10);
-	write_cmos_sensor(0x5b02, 0x03);
-	write_cmos_sensor(0x5b03, 0xcf);
-	write_cmos_sensor(0x5b05, 0x6c);
-	write_cmos_sensor(0x5e00, 0x00);
-	write_cmos_sensor(0x5e01, 0x41);
-	write_cmos_sensor(0x382d, 0x7f);
-	write_cmos_sensor(0x4825, 0x3a);
-	write_cmos_sensor(0x4826, 0x40);
-	write_cmos_sensor(0x4808, 0x25);
-	if (ov8858version == OV8858R1A){
-		LOG_INF("inter r1asensor_init() ov8858version = %d(0=r2a,1=r1a)\n",ov8858version); 
-		r1asensor_init();
-	}
-	write_cmos_sensor(0x0100, 0x01);
-}	/*	sensor_init  */
-
-
-static void preview_setting(void)
-{
-	LOG_INF("E\n");
-//   @@ Binning Size 1632x1224 30fps 4Lane_PCLK=74.4M
-//   100 99 1632 1224
-	write_cmos_sensor(0x100 , 0x00);      //	
-	write_cmos_sensor(0x30e , 0x02);     //
-	write_cmos_sensor(0x312 , 0x03);     //
-	write_cmos_sensor(0x3015, 0x00);     //
-	write_cmos_sensor(0x3700, 0x18);     //
-	write_cmos_sensor(0x3701, 0x0c);     //
-	write_cmos_sensor(0x3702, 0x28);     //
-	write_cmos_sensor(0x3703, 0x19);     //
-	write_cmos_sensor(0x3704, 0x14);     //
-	write_cmos_sensor(0x3707, 0x04);     //
-	write_cmos_sensor(0x3708, 0x24);     //
-	write_cmos_sensor(0x3709, 0x33);     //
-	write_cmos_sensor(0x370c, 0x04);     //
-	write_cmos_sensor(0x3718, 0x12);     //
-	write_cmos_sensor(0x3712, 0x42);     //
-	write_cmos_sensor(0x371e, 0x19);     //
-	write_cmos_sensor(0x371f, 0x40);     //
-	write_cmos_sensor(0x3720, 0x05);     //
-	write_cmos_sensor(0x3721, 0x05);     //
-	write_cmos_sensor(0x3724, 0x06);     //
-	write_cmos_sensor(0x3725, 0x01);     //
-	write_cmos_sensor(0x3726, 0x06);     //
-	write_cmos_sensor(0x3728, 0x05);     //
-	write_cmos_sensor(0x3729, 0x02);     //
-	write_cmos_sensor(0x372a, 0x03);     //
-	write_cmos_sensor(0x372b, 0x53);     //
-	write_cmos_sensor(0x372c, 0xa3);     //
-	write_cmos_sensor(0x372d, 0x53);     //
-	write_cmos_sensor(0x372e, 0x06);     //
-	write_cmos_sensor(0x372f, 0x10);     //
-	write_cmos_sensor(0x3730, 0x01);     //
-	write_cmos_sensor(0x3731, 0x06);     //
-	write_cmos_sensor(0x3732, 0x14);     //
-	write_cmos_sensor(0x3736, 0x20);     //
-	write_cmos_sensor(0x373a, 0x05);     //
-	write_cmos_sensor(0x373b, 0x06);     //
-	write_cmos_sensor(0x373c, 0x0a);     //
-	write_cmos_sensor(0x373e, 0x03);     //
-	write_cmos_sensor(0x375a, 0x06);     //
-	write_cmos_sensor(0x375b, 0x13);     //
-	write_cmos_sensor(0x375d, 0x02);     //
-	write_cmos_sensor(0x375f, 0x14);     //
-	write_cmos_sensor(0x3772, 0x23);     //
-	write_cmos_sensor(0x3773, 0x02);     //
-	write_cmos_sensor(0x3774, 0x16);     //
-	write_cmos_sensor(0x3775, 0x12);     //
-	write_cmos_sensor(0x3776, 0x04);     //
-	write_cmos_sensor(0x3778, 0x17);     //
-	write_cmos_sensor(0x37a0, 0x44);     //
-	write_cmos_sensor(0x37a1, 0x3d);     //
-	write_cmos_sensor(0x37a2, 0x3d);     //
-	write_cmos_sensor(0x37a7, 0x44);     //
-	write_cmos_sensor(0x37a8, 0x4c);     //
-	write_cmos_sensor(0x37a9, 0x4c);     //
-	write_cmos_sensor(0x37aa, 0x44);     //
-	write_cmos_sensor(0x37ab, 0x2e);     //
-	write_cmos_sensor(0x37ac, 0x2e);     //
-	write_cmos_sensor(0x37ad, 0x33);     //
-	write_cmos_sensor(0x37ae, 0x0d);     //
-	write_cmos_sensor(0x37af, 0x0d);     //
-	write_cmos_sensor(0x37b3, 0x42);     //
-	write_cmos_sensor(0x37b4, 0x42);     //
-	write_cmos_sensor(0x37b5, 0x31);     // ;;; 
-	write_cmos_sensor(0x3768, 0x22);     //
-	write_cmos_sensor(0x3769, 0x44);     //
-	write_cmos_sensor(0x376a, 0x44);     //
-	write_cmos_sensor(0x3808, 0x06);     //
-	write_cmos_sensor(0x3809, 0x60);     //
-	write_cmos_sensor(0x380a, 0x04);     //
-	write_cmos_sensor(0x380b, 0xc8);     //
-	write_cmos_sensor(0x380c, 0x07);     //
-	write_cmos_sensor(0x380d, 0x88);     //
-	write_cmos_sensor(0x380e, 0x05);     //;04
-	write_cmos_sensor(0x380f, 0x04);     //;dc
-	write_cmos_sensor(0x3814, 0x03);     //
-	write_cmos_sensor(0x3821, 0x67);     //
-	write_cmos_sensor(0x382a, 0x03);     //
-	write_cmos_sensor(0x382b, 0x01);     //
-	write_cmos_sensor(0x3830, 0x08);     //
-	write_cmos_sensor(0x3836, 0x02);     //
-
-	write_cmos_sensor(0x3843, 0x00);     //	
-	// modify for pre cap view diff 20150105
-	write_cmos_sensor(0x3811, 0x03);     //	
-	write_cmos_sensor(0x3845, 0x02);     //	
-
-	write_cmos_sensor(0x3f08, 0x08);     //
-	write_cmos_sensor(0x4001, 0x10);     //
-	write_cmos_sensor(0x4020, 0x00);     //
-	write_cmos_sensor(0x4021, 0x04);     //
-	write_cmos_sensor(0x4022, 0x04);     //
-	write_cmos_sensor(0x4023, 0xb9);     //
-	write_cmos_sensor(0x4024, 0x05);     //
-	write_cmos_sensor(0x4025, 0x2a);     //
-	write_cmos_sensor(0x4026, 0x05);     //
-	write_cmos_sensor(0x4027, 0x2b);     //
-	write_cmos_sensor(0x402a, 0x04);     //
-	write_cmos_sensor(0x402b, 0x04);     //
-	write_cmos_sensor(0x402e, 0x08);     //
-	write_cmos_sensor(0x402f, 0x02);     //
-	write_cmos_sensor(0x4600, 0x00);     //
-	write_cmos_sensor(0x4601, 0xcb);     //
-	write_cmos_sensor(0x5901, 0x00);     //
-	write_cmos_sensor(0x382d, 0x7f);     // ;;;
-	write_cmos_sensor(0x100 , 0x1);     //
-}	/*	preview_setting  */
-
-static void capture_setting(kal_uint16 currefps)
-{
-	LOG_INF("E! currefps:%d\n",currefps);
-	if (currefps == 150) {
-//  @@ Full size 3264x2448 30fps 4lane_PCLK=148.8M
-//  100 99 3264 2448);    //
-	write_cmos_sensor(0x100 , 0x0 );  //  
-	write_cmos_sensor(0x30e , 0x00);  //  
-	write_cmos_sensor(0x312 , 0x01);  //  
-	write_cmos_sensor(0x3015, 0x01);  //  
-	write_cmos_sensor(0x3700, 0x30);  //  
-	write_cmos_sensor(0x3701, 0x18);  //  
-	write_cmos_sensor(0x3702, 0x50);  //  
-	write_cmos_sensor(0x3703, 0x32);  //  
-	write_cmos_sensor(0x3704, 0x28);  //  
-	write_cmos_sensor(0x3707, 0x08);  //  
-	write_cmos_sensor(0x3708, 0x48);  //  
-	write_cmos_sensor(0x3709, 0x66);  //  
-	write_cmos_sensor(0x370c, 0x07);  //  
-	write_cmos_sensor(0x3718, 0x14);  //  
-	write_cmos_sensor(0x3712, 0x44);  //  
-	write_cmos_sensor(0x371e, 0x31);  //  
-	write_cmos_sensor(0x371f, 0x7f);  //  
-	write_cmos_sensor(0x3720, 0x0a);  //  
-	write_cmos_sensor(0x3721, 0x0a);  //  
-	write_cmos_sensor(0x3724, 0x0c);  //  
-	write_cmos_sensor(0x3725, 0x02);  //  
-	write_cmos_sensor(0x3726, 0x0c);  //  
-	write_cmos_sensor(0x3728, 0x0a);  //  
-	write_cmos_sensor(0x3729, 0x03);  //  
-	write_cmos_sensor(0x372a, 0x06);  //  
-	write_cmos_sensor(0x372b, 0xa6);  //  
-	write_cmos_sensor(0x372c, 0xa6);  //  
-	write_cmos_sensor(0x372d, 0xa6);  //  
-	write_cmos_sensor(0x372e, 0x0c);  //  
-	write_cmos_sensor(0x372f, 0x20);  //  
-	write_cmos_sensor(0x3730, 0x02);  //  
-	write_cmos_sensor(0x3731, 0x0c);  //  
-	write_cmos_sensor(0x3732, 0x28);  //  
-	write_cmos_sensor(0x3736, 0x30);  //  
-	write_cmos_sensor(0x373a, 0x0a);  //  
-	write_cmos_sensor(0x373b, 0x0b);  //  
-	write_cmos_sensor(0x373c, 0x14);  //  
-	write_cmos_sensor(0x373e, 0x06);  //  
-	write_cmos_sensor(0x375a, 0x0c);  //  
-	write_cmos_sensor(0x375b, 0x26);  //  
-	write_cmos_sensor(0x375d, 0x04);  //  
-	write_cmos_sensor(0x375f, 0x28);  //  
-	write_cmos_sensor(0x3772, 0x46);  //  
-	write_cmos_sensor(0x3773, 0x04);  //  
-	write_cmos_sensor(0x3774, 0x2c);  //  
-	write_cmos_sensor(0x3775, 0x13);  //  
-	write_cmos_sensor(0x3776, 0x08);  //  
-	write_cmos_sensor(0x3778, 0x17);  //  
-	write_cmos_sensor(0x37a0, 0x88);  //  
-	write_cmos_sensor(0x37a1, 0x7a);  //  
-	write_cmos_sensor(0x37a2, 0x7a);  //  
-	write_cmos_sensor(0x37a7, 0x88);  //  
-	write_cmos_sensor(0x37a8, 0x98);  //  
-	write_cmos_sensor(0x37a9, 0x98);  //  
-	write_cmos_sensor(0x37aa, 0x88);  //  
-	write_cmos_sensor(0x37ab, 0x5c);  //  
-	write_cmos_sensor(0x37ac, 0x5c);  //  
-	write_cmos_sensor(0x37ad, 0x55);  //  
-	write_cmos_sensor(0x37ae, 0x19);  //  
-	write_cmos_sensor(0x37af, 0x19);  //  
-	write_cmos_sensor(0x37b3, 0x84);  //  
-	write_cmos_sensor(0x37b4, 0x84);  //  
-	write_cmos_sensor(0x37b5, 0x60);  //   ; 66
-	write_cmos_sensor(0x3768, 0x22);  //  
-	write_cmos_sensor(0x3769, 0x44);  //  
-	write_cmos_sensor(0x376a, 0x44);  //  
-	write_cmos_sensor(0x3808, 0x0c);  //  
-	write_cmos_sensor(0x3809, 0xc0);  //  
-	write_cmos_sensor(0x380a, 0x09);  //  
-	write_cmos_sensor(0x380b, 0x90);  //  
-	write_cmos_sensor(0x380c, 0x09);  //  
-	write_cmos_sensor(0x380d, 0x79);  //  
-	write_cmos_sensor(0x380e, 0x0f);  //  
-	write_cmos_sensor(0x380f, 0xfa);  //   ;aa
-	write_cmos_sensor(0x3814, 0x01);  //  
-	write_cmos_sensor(0x3821, 0x46);  //  
-	write_cmos_sensor(0x382a, 0x01);  //  
-	write_cmos_sensor(0x382b, 0x01);  //  
-	write_cmos_sensor(0x3830, 0x06);  //  
-	write_cmos_sensor(0x3836, 0x01);  //  
-	write_cmos_sensor(0x3f08, 0x10);  //  
-
-	write_cmos_sensor(0x3843, 0x00);     //	
-	// modify for pre cap view diff 20150105
-	write_cmos_sensor(0x3811, 0x05);     //	
-	write_cmos_sensor(0x3845, 0x00);     //	
-
-	
-	write_cmos_sensor(0x4001, 0x00);  //  
-	write_cmos_sensor(0x4020, 0x00);  //  
-	write_cmos_sensor(0x4021, 0x04);  //  
-	write_cmos_sensor(0x4022, 0x0b);  //  
-	write_cmos_sensor(0x4023, 0xc3);  //  
-	write_cmos_sensor(0x4024, 0x0c);  //  
-	write_cmos_sensor(0x4025, 0x36);  //  
-	write_cmos_sensor(0x4026, 0x0c);  //  
-	write_cmos_sensor(0x4027, 0x37);  //  
-	write_cmos_sensor(0x402a, 0x04);  //  
-	write_cmos_sensor(0x402b, 0x08);  //  
-	write_cmos_sensor(0x402e, 0x0c);  //  
-	write_cmos_sensor(0x402f, 0x02);  //  
-	write_cmos_sensor(0x4600, 0x01);  //  
-	write_cmos_sensor(0x4601, 0x97);  //  
-	write_cmos_sensor(0x5901, 0x00);  //  
-	write_cmos_sensor(0x382d, 0xff);  //   ;;;
-	write_cmos_sensor(0x100 , 0x1);   // 
-	}
-	else 
-	{   
-//  @@ Full size 3264x2448 30fps 4lane_PCLK=148.8M
-//  100 99 3264 2448);    //
-	write_cmos_sensor(0x100 , 0x0 );  //  
-	write_cmos_sensor(0x30e , 0x00);  //  
-	write_cmos_sensor(0x312 , 0x01);  //  
-	write_cmos_sensor(0x3015, 0x01);  //  
-	write_cmos_sensor(0x3700, 0x30);  //  
-	write_cmos_sensor(0x3701, 0x18);  //  
-	write_cmos_sensor(0x3702, 0x50);  //  
-	write_cmos_sensor(0x3703, 0x32);  //  
-	write_cmos_sensor(0x3704, 0x28);  //  
-	write_cmos_sensor(0x3707, 0x08);  //  
-	write_cmos_sensor(0x3708, 0x48);  //  
-	write_cmos_sensor(0x3709, 0x66);  //  
-	write_cmos_sensor(0x370c, 0x07);  //  
-	write_cmos_sensor(0x3718, 0x14);  //  
-	write_cmos_sensor(0x3712, 0x44);  //  
-	write_cmos_sensor(0x371e, 0x31);  //  
-	write_cmos_sensor(0x371f, 0x7f);  //  
-	write_cmos_sensor(0x3720, 0x0a);  //  
-	write_cmos_sensor(0x3721, 0x0a);  //  
-	write_cmos_sensor(0x3724, 0x0c);  //  
-	write_cmos_sensor(0x3725, 0x02);  //  
-	write_cmos_sensor(0x3726, 0x0c);  //  
-	write_cmos_sensor(0x3728, 0x0a);  //  
-	write_cmos_sensor(0x3729, 0x03);  //  
-	write_cmos_sensor(0x372a, 0x06);  //  
-	write_cmos_sensor(0x372b, 0xa6);  //  
-	write_cmos_sensor(0x372c, 0xa6);  //  
-	write_cmos_sensor(0x372d, 0xa6);  //  
-	write_cmos_sensor(0x372e, 0x0c);  //  
-	write_cmos_sensor(0x372f, 0x20);  //  
-	write_cmos_sensor(0x3730, 0x02);  //  
-	write_cmos_sensor(0x3731, 0x0c);  //  
-	write_cmos_sensor(0x3732, 0x28);  //  
-	write_cmos_sensor(0x3736, 0x30);  //  
-	write_cmos_sensor(0x373a, 0x0a);  //  
-	write_cmos_sensor(0x373b, 0x0b);  //  
-	write_cmos_sensor(0x373c, 0x14);  //  
-	write_cmos_sensor(0x373e, 0x06);  //  
-	write_cmos_sensor(0x375a, 0x0c);  //  
-	write_cmos_sensor(0x375b, 0x26);  //  
-	write_cmos_sensor(0x375d, 0x04);  //  
-	write_cmos_sensor(0x375f, 0x28);  //  
-	write_cmos_sensor(0x3772, 0x46);  //  
-	write_cmos_sensor(0x3773, 0x04);  //  
-	write_cmos_sensor(0x3774, 0x2c);  //  
-	write_cmos_sensor(0x3775, 0x13);  //  
-	write_cmos_sensor(0x3776, 0x08);  //  
-	write_cmos_sensor(0x3778, 0x17);  //  
-	write_cmos_sensor(0x37a0, 0x88);  //  
-	write_cmos_sensor(0x37a1, 0x7a);  //  
-	write_cmos_sensor(0x37a2, 0x7a);  //  
-	write_cmos_sensor(0x37a7, 0x88);  //  
-	write_cmos_sensor(0x37a8, 0x98);  //  
-	write_cmos_sensor(0x37a9, 0x98);  //  
-	write_cmos_sensor(0x37aa, 0x88);  //  
-	write_cmos_sensor(0x37ab, 0x5c);  //  
-	write_cmos_sensor(0x37ac, 0x5c);  //  
-	write_cmos_sensor(0x37ad, 0x55);  //  
-	write_cmos_sensor(0x37ae, 0x19);  //  
-	write_cmos_sensor(0x37af, 0x19);  //  
-	write_cmos_sensor(0x37b3, 0x84);  //  
-	write_cmos_sensor(0x37b4, 0x84);  //  
-	write_cmos_sensor(0x37b5, 0x60);  //   ; 66
-	write_cmos_sensor(0x3768, 0x22);  //  
-	write_cmos_sensor(0x3769, 0x44);  //  
-	write_cmos_sensor(0x376a, 0x44);  //  
-	write_cmos_sensor(0x3808, 0x0c);  //  
-	write_cmos_sensor(0x3809, 0xc0);  //  
-	write_cmos_sensor(0x380a, 0x09);  //  
-	write_cmos_sensor(0x380b, 0x90);  //  
-	write_cmos_sensor(0x380c, 0x07);  //  
-	write_cmos_sensor(0x380d, 0x94);  //  
-	write_cmos_sensor(0x380e, 0x09);  //  
-	write_cmos_sensor(0x380f, 0xfc);  //   ;aa
-	write_cmos_sensor(0x3814, 0x01);  //  
-	write_cmos_sensor(0x3821, 0x46);  //  
-	write_cmos_sensor(0x382a, 0x01);  //  
-	write_cmos_sensor(0x382b, 0x01);  //  
-	write_cmos_sensor(0x3830, 0x06);  //  
-	write_cmos_sensor(0x3836, 0x01);  //  
-	// modify for pre cap view diff 20150105
-	write_cmos_sensor(0x3811, 0x05);     //	
-	write_cmos_sensor(0x3845, 0x00);     //	
-	
-	write_cmos_sensor(0x3f08, 0x10);  //  
-	write_cmos_sensor(0x4001, 0x00);  //  
-	write_cmos_sensor(0x4020, 0x00);  //  
-	write_cmos_sensor(0x4021, 0x04);  //  
-	write_cmos_sensor(0x4022, 0x0b);  //  
-	write_cmos_sensor(0x4023, 0xc3);  //  
-	write_cmos_sensor(0x4024, 0x0c);  //  
-	write_cmos_sensor(0x4025, 0x36);  //  
-	write_cmos_sensor(0x4026, 0x0c);  //  
-	write_cmos_sensor(0x4027, 0x37);  //  
-	write_cmos_sensor(0x402a, 0x04);  //  
-	write_cmos_sensor(0x402b, 0x08);  //  
-	write_cmos_sensor(0x402e, 0x0c);  //  
-	write_cmos_sensor(0x402f, 0x02);  //  
-	write_cmos_sensor(0x4600, 0x01);  //  
-	write_cmos_sensor(0x4601, 0x97);  //  
-	write_cmos_sensor(0x5901, 0x00);  //  
-	write_cmos_sensor(0x382d, 0xff);  //   ;;;
-	write_cmos_sensor(0x100 , 0x1);   // 
-	}
-		
-}
-
-static void normal_video_setting(kal_uint16 currefps)
-{
-	LOG_INF("E! currefps:%d\n",currefps);
-    capture_setting(currefps);
-}
-static void hs_video_setting()
-{
-	LOG_INF("E\n");
-//  @@ OV8858R2A VGA 120fps_PCLK=148.8M
-//  100 99 640 480
-	write_cmos_sensor(0x0100, 0x00);  //
-	write_cmos_sensor(0x30e , 0x00);  //
-	write_cmos_sensor(0x312 , 0x01);  //
-	write_cmos_sensor(0x3015, 0x01);  //
-	write_cmos_sensor(0x3700, 0x30);  //
-	write_cmos_sensor(0x3701, 0x18);  //
-	write_cmos_sensor(0x3702, 0x50);  //
-	write_cmos_sensor(0x3703, 0x32);  //
-	write_cmos_sensor(0x3704, 0x28);  //
-	write_cmos_sensor(0x3707, 0x08);  //
-	write_cmos_sensor(0x3708, 0x48);  //
-	write_cmos_sensor(0x3709, 0x66);  //
-	write_cmos_sensor(0x370c, 0x07);  //
-	write_cmos_sensor(0x3718, 0x14);  //
-	write_cmos_sensor(0x3712, 0x44);  //
-	write_cmos_sensor(0x371e, 0x31);  //
-	write_cmos_sensor(0x371f, 0x7f);  //
-	write_cmos_sensor(0x3720, 0x0a);  //
-	write_cmos_sensor(0x3721, 0x0a);  //
-	write_cmos_sensor(0x3724, 0x0c);  //
-	write_cmos_sensor(0x3725, 0x02);  //
-	write_cmos_sensor(0x3726, 0x0c);  //
-	write_cmos_sensor(0x3728, 0x0a);  //
-	write_cmos_sensor(0x3729, 0x03);  //
-	write_cmos_sensor(0x372a, 0x06);  //
-	write_cmos_sensor(0x372b, 0xa6);  //
-	write_cmos_sensor(0x372c, 0xa6);  //
-	write_cmos_sensor(0x372d, 0xa6);  //
-	write_cmos_sensor(0x372e, 0x0c);  //
-	write_cmos_sensor(0x372f, 0x20);  //
-	write_cmos_sensor(0x3730, 0x02);  //
-	write_cmos_sensor(0x3731, 0x0c);  //
-	write_cmos_sensor(0x3732, 0x28);  //
-	write_cmos_sensor(0x3736, 0x30);  //
-	write_cmos_sensor(0x373a, 0x0a);  //
-	write_cmos_sensor(0x373b, 0x0b);  //
-	write_cmos_sensor(0x373c, 0x14);  //
-	write_cmos_sensor(0x373e, 0x06);  //
-	write_cmos_sensor(0x375a, 0x0c);  //
-	write_cmos_sensor(0x375b, 0x26);  //
-	write_cmos_sensor(0x375d, 0x04);  //
-	write_cmos_sensor(0x375f, 0x28);  //
-	write_cmos_sensor(0x3772, 0x46);  //
-	write_cmos_sensor(0x3773, 0x04);  //
-	write_cmos_sensor(0x3774, 0x2c);  //
-	write_cmos_sensor(0x3775, 0x13);  //
-	write_cmos_sensor(0x3776, 0x08);  //
-	write_cmos_sensor(0x3778, 0x17);  //
-	write_cmos_sensor(0x37a0, 0x88);  //
-	write_cmos_sensor(0x37a1, 0x7a);  //
-	write_cmos_sensor(0x37a2, 0x7a);  //
-	write_cmos_sensor(0x37a7, 0x88);  //
-	write_cmos_sensor(0x37a8, 0x98);  //
-	write_cmos_sensor(0x37a9, 0x98);  //
-	write_cmos_sensor(0x37aa, 0x88);  //
-	write_cmos_sensor(0x37ab, 0x5c);  //
-	write_cmos_sensor(0x37ac, 0x5c);  //
-	write_cmos_sensor(0x37ad, 0x55);  //
-	write_cmos_sensor(0x37ae, 0x19);  //
-	write_cmos_sensor(0x37af, 0x19);  //
-	write_cmos_sensor(0x37b3, 0x84);  //
-	write_cmos_sensor(0x37b4, 0x84);  //
-	write_cmos_sensor(0x37b5, 0x60);  //
-	write_cmos_sensor(0x3768, 0x00);  //
-	write_cmos_sensor(0x3769, 0xc0);  //
-	write_cmos_sensor(0x376a, 0x42);  //
-	write_cmos_sensor(0x3808, 0x02);  //
-	write_cmos_sensor(0x3809, 0x80);  //
-	write_cmos_sensor(0x380a, 0x01);  //
-	write_cmos_sensor(0x380b, 0xe0);  //
-	write_cmos_sensor(0x380c, 0x08);  //;09
-	write_cmos_sensor(0x380d, 0xDe);  //;02
-	write_cmos_sensor(0x380e, 0x02);  //
-	write_cmos_sensor(0x380f, 0x22);  //;08
-	write_cmos_sensor(0x3814, 0x03);  //
-	write_cmos_sensor(0x3821, 0x6f);  //
-	write_cmos_sensor(0x382a, 0x05);  //
-	write_cmos_sensor(0x382b, 0x03);  //
-	write_cmos_sensor(0x3830, 0x0c);  //
-	write_cmos_sensor(0x3836, 0x02);  //
-	write_cmos_sensor(0x3f08, 0x10);  //
-	write_cmos_sensor(0x4001, 0x10);  //
-	write_cmos_sensor(0x4020, 0x01);  //
-	write_cmos_sensor(0x4021, 0x20);  //
-	write_cmos_sensor(0x4022, 0x01);  //
-	write_cmos_sensor(0x4023, 0x9f);  //
-	write_cmos_sensor(0x4024, 0x03);  //
-	write_cmos_sensor(0x4025, 0xe0);  //
-	write_cmos_sensor(0x4026, 0x04);  //
-	write_cmos_sensor(0x4027, 0x5f);  //
-	write_cmos_sensor(0x402a, 0x02);  //
-	write_cmos_sensor(0x402b, 0x04);  //
-	write_cmos_sensor(0x402e, 0x02);  //
-	write_cmos_sensor(0x402f, 0x04);  //
-	write_cmos_sensor(0x4600, 0x00);  //
-	write_cmos_sensor(0x4601, 0x4f);  //
-	write_cmos_sensor(0x5901, 0x04);  //
-	
-	// modify for pre cap view diff 20150105
-	write_cmos_sensor(0x3811, 0x03);     //	
-	write_cmos_sensor(0x3845, 0x02);     //	
-
-	write_cmos_sensor(0x382d, 0x7f);  //
-	write_cmos_sensor(0x0100, 0x01);  //
-}
-
-static void slim_video_setting()
-{
-	LOG_INF("E\n");
-	preview_setting();
-}
-
-
-/*************************************************************************
-* FUNCTION
-*	get_imgsensor_id
-*
-* DESCRIPTION
-*	This function get the sensor ID 
-*
-* PARAMETERS
-*	*sensorID : return the sensor ID 
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 get_imgsensor_id(UINT32 *sensor_id) 
-{
-	kal_uint8 i = 0;
-	kal_uint8 retry = 2;
-	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
-	while (imgsensor_info.i2c_addr_table[i] != 0xff) {
-		spin_lock(&imgsensor_drv_lock);
-		imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
-		spin_unlock(&imgsensor_drv_lock);
-		do {
-			*sensor_id = ((read_cmos_sensor(0x300B) << 8) | read_cmos_sensor(0x300C));
-			if (*sensor_id == imgsensor_info.sensor_id) {
-				if((read_cmos_sensor(0x302A)) == 0XB2){
- 				ov8858version = OV8858R2A;
-				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x, ov8858version = %d(0=r2a,1=r1a)\n", imgsensor.i2c_write_id,*sensor_id,ov8858version);	
-				return ERROR_NONE;
-				}
-				else if((read_cmos_sensor(0x302A)) == 0XB1){
- 				ov8858version = OV8858R1A;
-				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x, ov8858version = %d(0=r2a,1=r1a)\n", imgsensor.i2c_write_id,*sensor_id,ov8858version);	
-				return ERROR_NONE;
-				}
-				else{
-				LOG_INF("read ov8858 R1A R2A bate fail\n");	  
-				return ERROR_SENSOR_CONNECT_FAIL;
-				}
-			}	
-			LOG_INF("Read sensor id fail, id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
-			retry--;
-		} while(retry > 0);
-		i++;
-		retry = 2;
-	}
-	if (*sensor_id != imgsensor_info.sensor_id) {
-		// if Sensor ID is not correct, Must set *sensor_id to 0xFFFFFFFF 
-		*sensor_id = 0xFFFFFFFF;
-		return ERROR_SENSOR_CONNECT_FAIL;
-	}
-	return ERROR_NONE;
-}
-
-#ifdef OV8858R2AOTP
-
-struct otp_struct {
-int flag; // bit[7]: info, bit[6]:wb, bit[5]:vcm, bit[4]:lenc
-int module_integrator_id;
-int lens_id;
-int production_year;
-int production_month;
-int production_day;
-int rg_ratio;
-int bg_ratio;
-int lenc[240];
-int checksum;
-int VCM_start;
-int VCM_end;
-int VCM_dir;
-};
-
-//static struct otp_struct *otp_ptr = (struct otp_struct *)kzalloc(sizeof(struct otp_struct), GFP_KERNEL);
-
-#if 0
-struct otp_struct otp_struct_obj = {
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-{0},
-0,
-0,
-0,
-0,
-};
-
-
-otp_ptr = &otp_struct_obj;
-#endif
-
-// return value:
-// bit[7]: 0 no otp info, 1 valid otp info
-// bit[6]: 0 no otp wb, 1 valib otp wb
-// bit[5]: 0 no otp vcm, 1 valid otp vcm
-// bit[4]: 0 no otp lenc/invalid otp lenc, 1 valid otp lenc
-int read_otp(struct otp_struct *otp_ptr)
-{
-	int otp_flag, addr, temp, i;
-	//set 0x5002[3] to \A1\B00\A1\B1
-	int temp1;
-	temp1 = read_cmos_sensor(0x5002);
-	write_cmos_sensor(0x5002, (0x00 & 0x08) | (temp1 & (~0x08)));
-	// read OTP into buffer
-	write_cmos_sensor(0x3d84, 0xC0);
-	write_cmos_sensor(0x3d88, 0x70); // OTP start address
-	write_cmos_sensor(0x3d89, 0x10);
-	write_cmos_sensor(0x3d8A, 0x72); // OTP end address
-	write_cmos_sensor(0x3d8B, 0x0a);
-	write_cmos_sensor(0x3d81, 0x01); // load otp into buffer
-	mdelay(10);
-	// OTP base information and WB calibration data
-	otp_flag = read_cmos_sensor(0x7010);
-	addr = 0;
-	if((otp_flag & 0xc0) == 0x40) {
-		addr = 0x7011; // base address of info group 1
-	}
-	else if((otp_flag & 0x30) == 0x10) {
-		addr = 0x7019; // base address of info group 2
-	}
-	if(addr != 0) {
-		(*otp_ptr).flag = 0xC0; // valid info and AWB in OTP
-		(*otp_ptr).module_integrator_id = read_cmos_sensor(addr);
-		(*otp_ptr).lens_id = read_cmos_sensor( addr + 1);
-		(*otp_ptr).production_year = read_cmos_sensor( addr + 2);
-		(*otp_ptr).production_month = read_cmos_sensor( addr + 3);
-		(*otp_ptr).production_day = read_cmos_sensor(addr + 4);
-		temp = read_cmos_sensor(addr + 7);
-		(*otp_ptr).rg_ratio = (read_cmos_sensor(addr + 5)<<2) + ((temp>>6) & 0x03);
-		(*otp_ptr).bg_ratio = (read_cmos_sensor(addr + 6)<<2) + ((temp>>4) & 0x03);
-	}
-	else {
-		(*otp_ptr).flag = 0x00; // not info and AWB in OTP
-		(*otp_ptr).module_integrator_id = 0;
-		(*otp_ptr).lens_id = 0;
-		(*otp_ptr).production_year = 0;
-		(*otp_ptr).production_month = 0;
-		(*otp_ptr).production_day = 0;
-		(*otp_ptr).rg_ratio = 0;
-		(*otp_ptr).bg_ratio = 0;
-	}
-	// OTP VCM Calibration
-	otp_flag = read_cmos_sensor(0x7021);
-	addr = 0;
-	if((otp_flag & 0xc0) == 0x40) {
-		addr = 0x7022; // base address of VCM Calibration group 1
-	}
-	else if((otp_flag & 0x30) == 0x10) {
-		addr = 0x7025; // base address of VCM Calibration group 2
-	}
-	if(addr != 0) {
-		(*otp_ptr).flag |= 0x20;
-		temp = read_cmos_sensor(addr + 2);
-		(* otp_ptr).VCM_start = (read_cmos_sensor(addr)<<2) | ((temp>>6) & 0x03);
-		(* otp_ptr).VCM_end = (read_cmos_sensor(addr + 1) << 2) | ((temp>>4) & 0x03);
-		(* otp_ptr).VCM_dir = (temp>>2) & 0x03;
-	}
-	else {
-		(* otp_ptr).VCM_start = 0;
-		(* otp_ptr).VCM_end = 0;
-		(* otp_ptr).VCM_dir = 0;
-	}
-	// OTP Lenc Calibration
-	otp_flag = read_cmos_sensor(0x7028);
-	addr = 0;
-	int checksum2=0;
-	if((otp_flag & 0xc0) == 0x40) {
-		addr = 0x7029; // base address of Lenc Calibration group 1
-	}
-	else if((otp_flag & 0x30) == 0x10) {
-		addr = 0x711a; // base address of Lenc Calibration group 2
-	}
-	if(addr != 0) {
-		for(i=0;i<240;i++) {
-			(* otp_ptr).lenc[i]=read_cmos_sensor(addr + i);
-			checksum2 += (* otp_ptr).lenc[i];
-		}
-		checksum2 = (checksum2)%255 +1;
-		(*otp_ptr).checksum = read_cmos_sensor(addr + 240);
-		if((*otp_ptr).checksum == checksum2){
-			(*otp_ptr).flag |= 0x10;	
-		}
-	}
-	else {
-		for(i=0;i<240;i++) {
-			(* otp_ptr).lenc[i]=0;
-		}
-	}
-	for(i=0x7010;i<=0x720a;i++) {
-		write_cmos_sensor(i,0); // clear OTP buffer, recommended use continuous write to accelarate
-	}
-	//set 0x5002[3] to \A1\B01\A1\B1
-	temp1 = read_cmos_sensor(0x5002);
-	write_cmos_sensor(0x5002, (0x08 & 0x08) | (temp1 & (~0x08)));
-	return (*otp_ptr).flag;
-}
-// return value:
-// bit[7]: 0 no otp info, 1 valid otp info
-// bit[6]: 0 no otp wb, 1 valib otp wb
-// bit[5]: 0 no otp vcm, 1 valid otp vcm
-// bit[4]: 0 no otp lenc, 1 valid otp lenc
-
-int apply_otp(struct otp_struct *otp_ptr)
-{
-	int RG_Ratio_Typical = 0x148, BG_Ratio_Typical = 0x12A;
-	int rg, bg, R_gain, G_gain, B_gain, Base_gain, temp, i;
-	// apply OTP WB Calibration
-	if ((*otp_ptr).flag & 0x40) {
-		rg = (*otp_ptr).rg_ratio;
-		bg = (*otp_ptr).bg_ratio;
-		//calculate G gain
-		R_gain = (RG_Ratio_Typical*1000) / rg;
-		B_gain = (BG_Ratio_Typical*1000) / bg;
-		G_gain = 1000;
-		if (R_gain < 1000 || B_gain < 1000)
-		{
-			if (R_gain < B_gain)
-				Base_gain = R_gain;
-			else
-				Base_gain = B_gain;
-		}
-		else
-		{
-			Base_gain = G_gain;
-		}
-		R_gain = 0x400 * R_gain / (Base_gain);
-		B_gain = 0x400 * B_gain / (Base_gain);
-		G_gain = 0x400 * G_gain / (Base_gain);
-		// update sensor WB gain
-		if (R_gain>0x400) {
-			write_cmos_sensor(0x5032, R_gain>>8);
-			write_cmos_sensor(0x5033, R_gain & 0x00ff);
-		}
-		if (G_gain>0x400) {
-			write_cmos_sensor(0x5034, G_gain>>8);
-			write_cmos_sensor(0x5035, G_gain & 0x00ff);
-		}
-		if (B_gain>0x400) {
-			write_cmos_sensor(0x5036, B_gain>>8);
-			write_cmos_sensor(0x5037, B_gain & 0x00ff);
-		}
-	}
-	// apply OTP Lenc Calibration
-	if ((*otp_ptr).flag & 0x10) {
-		temp = read_cmos_sensor(0x5000);
-		temp = 0x80 | temp;
-		write_cmos_sensor(0x5000, temp);
-		for(i=0;i<240;i++) {
-			write_cmos_sensor(0x5800 + i, (*otp_ptr).lenc[i]);
-		}
-	}
-	return (*otp_ptr).flag;
-}
-
-#endif
-/*************************************************************************
-* FUNCTION
-*	open
-*
-* DESCRIPTION
-*	This function initialize the registers of CMOS sensor
-*
-* PARAMETERS
-*	None
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 open(void)
-{
-	//const kal_uint8 i2c_addr[] = {IMGSENSOR_WRITE_ID_1, IMGSENSOR_WRITE_ID_2};
-	kal_uint8 i = 0;
-	kal_uint8 retry = 2;
-	kal_uint16 sensor_id = 0; 
-	LOG_INF("PLATFORM:MT6595,MIPI 4LANE\n");
-	//LOG_INF("preview 1280*960@30fps,864Mbps/lane; video 1280*960@30fps,864Mbps/lane; capture 5M@30fps,864Mbps/lane\n");
-	
-	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
-	while (imgsensor_info.i2c_addr_table[i] != 0xff) {
-		spin_lock(&imgsensor_drv_lock);
-		imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
-		spin_unlock(&imgsensor_drv_lock);
-		do {
-			sensor_id = ((read_cmos_sensor(0x300B) << 8) | read_cmos_sensor(0x300C));
-			if (sensor_id == imgsensor_info.sensor_id) {				
-				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);	  
-				break;
-			}	
-			LOG_INF("Read sensor id fail, id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
-			retry--;
-		} while(retry > 0);
-		i++;
-		if (sensor_id == imgsensor_info.sensor_id)
-			break;
-		retry = 2;
-	}		 
-	if (imgsensor_info.sensor_id != sensor_id)
-		return ERROR_SENSOR_CONNECT_FAIL;
-	
-	/* initail sequence write in  */
-	sensor_init();
-	
-	mdelay(10);
-	#ifdef OV8858R2AOTP
-		LOG_INF("Apply the sensor OTP\n");
-		struct otp_struct *otp_ptr = (struct otp_struct *)kzalloc(sizeof(struct otp_struct), GFP_KERNEL);
-		read_otp(otp_ptr);
-		apply_otp(otp_ptr);
-		kfree(otp_ptr);
-	#endif
-	spin_lock(&imgsensor_drv_lock);
-
-	imgsensor.autoflicker_en= KAL_FALSE;
-	imgsensor.sensor_mode = IMGSENSOR_MODE_INIT;
-	imgsensor.shutter = 0x2D00;
-	imgsensor.gain = 0x100;
-	imgsensor.pclk = imgsensor_info.pre.pclk;
-	imgsensor.frame_length = imgsensor_info.pre.framelength;
-	imgsensor.line_length = imgsensor_info.pre.linelength;
-	imgsensor.min_frame_length = imgsensor_info.pre.framelength;
-	imgsensor.dummy_pixel = 0;
-	imgsensor.dummy_line = 0;
-	imgsensor.ihdr_en = 0;
-	imgsensor.test_pattern = KAL_FALSE;
-	imgsensor.current_fps = imgsensor_info.pre.max_framerate;
-	spin_unlock(&imgsensor_drv_lock);
-
-	return ERROR_NONE;
-}	/*	open  */
-
-
-
-/*************************************************************************
-* FUNCTION
-*	close
-*
-* DESCRIPTION
-*	
-*
-* PARAMETERS
-*	None
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 close(void)
-{
-	LOG_INF("E\n");
-
-	/*No Need to implement this function*/ 
-	
-	return ERROR_NONE;
-}	/*	close  */
-
-
-/*************************************************************************
-* FUNCTION
-* preview
-*
-* DESCRIPTION
-*	This function start the sensor preview.
-*
-* PARAMETERS
-*	*image_window : address pointer of pixel numbers in one period of HSYNC
-*  *sensor_config_data : address pointer of line numbers in one period of VSYNC
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("E\n");
-
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.sensor_mode = IMGSENSOR_MODE_PREVIEW;
-	imgsensor.pclk = imgsensor_info.pre.pclk;
-	//imgsensor.video_mode = KAL_FALSE;
-	imgsensor.line_length = imgsensor_info.pre.linelength;
-	imgsensor.frame_length = imgsensor_info.pre.framelength; 
-	imgsensor.min_frame_length = imgsensor_info.pre.framelength;
-	imgsensor.autoflicker_en = KAL_FALSE;
-	spin_unlock(&imgsensor_drv_lock);
-	preview_setting();
-	mdelay(10);
-	return ERROR_NONE;
-}	/*	preview   */
-
-/*************************************************************************
-* FUNCTION
-*	capture
-*
-* DESCRIPTION
-*	This function setup the CMOS sensor in capture MY_OUTPUT mode
-*
-* PARAMETERS
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-						  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("E\n");
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.sensor_mode = IMGSENSOR_MODE_CAPTURE;
-	if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {//PIP capture: 24fps for less than 13M, 20fps for 16M,15fps for 20M
-		imgsensor.pclk = imgsensor_info.cap1.pclk;
-		imgsensor.line_length = imgsensor_info.cap1.linelength;
-		imgsensor.frame_length = imgsensor_info.cap1.framelength;  
-		imgsensor.min_frame_length = imgsensor_info.cap1.framelength;
-		imgsensor.autoflicker_en = KAL_FALSE;
-	} else {
-		if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
-			LOG_INF("Warning: current_fps %d fps is not support, so use cap1's setting: %d fps!\n",imgsensor_info.cap1.max_framerate/10);
-		imgsensor.pclk = imgsensor_info.cap.pclk;
-		imgsensor.line_length = imgsensor_info.cap.linelength;
-		imgsensor.frame_length = imgsensor_info.cap.framelength;  
-		imgsensor.min_frame_length = imgsensor_info.cap.framelength;
-		imgsensor.autoflicker_en = KAL_FALSE;
-	}
-	spin_unlock(&imgsensor_drv_lock);
-
-	capture_setting(imgsensor.current_fps); 
-	mdelay(10);
-
-	#if 0
-	if(imgsensor.test_pattern == KAL_TRUE)
-	{
-		write_cmos_sensor(0x3282,0x01);//DPU OFF
-		
-		write_cmos_sensor(0x0600,0x00);
-		write_cmos_sensor(0x0601,0x02);
-		
-	}
-#endif
-	return ERROR_NONE;
-}	/* capture() */
-static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("E\n");
-	
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.sensor_mode = IMGSENSOR_MODE_VIDEO;
-	imgsensor.pclk = imgsensor_info.normal_video.pclk;
-	imgsensor.line_length = imgsensor_info.normal_video.linelength;
-	imgsensor.frame_length = imgsensor_info.normal_video.framelength;  
-	imgsensor.min_frame_length = imgsensor_info.normal_video.framelength;
-	//imgsensor.current_fps = 300;
-	imgsensor.autoflicker_en = KAL_FALSE;
-	spin_unlock(&imgsensor_drv_lock);
-	capture_setting(imgsensor.current_fps);
-	mdelay(10);
-	
-	
-	return ERROR_NONE;
-}	/*	normal_video   */
-
-static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("E\n");
-	
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.sensor_mode = IMGSENSOR_MODE_HIGH_SPEED_VIDEO;
-	imgsensor.pclk = imgsensor_info.hs_video.pclk;
-	//imgsensor.video_mode = KAL_TRUE;
-	imgsensor.line_length = imgsensor_info.hs_video.linelength;
-	imgsensor.frame_length = imgsensor_info.hs_video.framelength; 
-	imgsensor.min_frame_length = imgsensor_info.hs_video.framelength;
-	imgsensor.dummy_line = 0;
-	imgsensor.dummy_pixel = 0;
-	//imgsensor.current_fps = 300;
-	imgsensor.autoflicker_en = KAL_FALSE;
-	spin_unlock(&imgsensor_drv_lock);
-	hs_video_setting();
-	mdelay(10);
-	
-	return ERROR_NONE;
-}	/*	hs_video   */
-
-static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("E\n");
-	
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.sensor_mode = IMGSENSOR_MODE_SLIM_VIDEO;
-	imgsensor.pclk = imgsensor_info.slim_video.pclk;
-	//imgsensor.video_mode = KAL_TRUE;
-	imgsensor.line_length = imgsensor_info.slim_video.linelength;
-	imgsensor.frame_length = imgsensor_info.slim_video.framelength; 
-	imgsensor.min_frame_length = imgsensor_info.slim_video.framelength;
-	imgsensor.dummy_line = 0;
-	imgsensor.dummy_pixel = 0;
-	//imgsensor.current_fps = 300;
-	imgsensor.autoflicker_en = KAL_FALSE;
-	spin_unlock(&imgsensor_drv_lock);
-	slim_video_setting();
-	mdelay(10);
-	
-	return ERROR_NONE;
-}	/*	slim_video	 */
-
-
-
-static kal_uint32 get_resolution(MSDK_SENSOR_RESOLUTION_INFO_STRUCT *sensor_resolution)
-{
-	LOG_INF("E\n");
-	sensor_resolution->SensorFullWidth = imgsensor_info.cap.grabwindow_width;
-	sensor_resolution->SensorFullHeight = imgsensor_info.cap.grabwindow_height;
-	
-	sensor_resolution->SensorPreviewWidth = imgsensor_info.pre.grabwindow_width;
-	sensor_resolution->SensorPreviewHeight = imgsensor_info.pre.grabwindow_height;
-
-	sensor_resolution->SensorVideoWidth = imgsensor_info.normal_video.grabwindow_width;
-	sensor_resolution->SensorVideoHeight = imgsensor_info.normal_video.grabwindow_height;		
-
-	
-	sensor_resolution->SensorHighSpeedVideoWidth	 = imgsensor_info.hs_video.grabwindow_width;
-	sensor_resolution->SensorHighSpeedVideoHeight	 = imgsensor_info.hs_video.grabwindow_height;
-	
-	sensor_resolution->SensorSlimVideoWidth	 = imgsensor_info.slim_video.grabwindow_width;
-	sensor_resolution->SensorSlimVideoHeight	 = imgsensor_info.slim_video.grabwindow_height;
-	return ERROR_NONE;
-}	/*	get_resolution	*/
-
-static kal_uint32 get_info(MSDK_SCENARIO_ID_ENUM scenario_id,
-					  MSDK_SENSOR_INFO_STRUCT *sensor_info,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("scenario_id = %d\n", scenario_id);
-
-	
-	//sensor_info->SensorVideoFrameRate = imgsensor_info.normal_video.max_framerate/10; /* not use */
-	//sensor_info->SensorStillCaptureFrameRate= imgsensor_info.cap.max_framerate/10; /* not use */
-	//imgsensor_info->SensorWebCamCaptureFrameRate= imgsensor_info.v.max_framerate; /* not use */
-
-	sensor_info->SensorClockPolarity = SENSOR_CLOCK_POLARITY_LOW;
-	sensor_info->SensorClockFallingPolarity = SENSOR_CLOCK_POLARITY_LOW; /* not use */
-	sensor_info->SensorHsyncPolarity = SENSOR_CLOCK_POLARITY_LOW; // inverse with datasheet
-	sensor_info->SensorVsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
-	sensor_info->SensorInterruptDelayLines = 4; /* not use */
-	sensor_info->SensorResetActiveHigh = FALSE; /* not use */
-	sensor_info->SensorResetDelayCount = 5; /* not use */
-
-	sensor_info->SensroInterfaceType = imgsensor_info.sensor_interface_type;
-	//sensor_info->MIPIsensorType = imgsensor_info.mipi_sensor_type;
-	//sensor_info->SettleDelayMode = imgsensor_info.mipi_settle_delay_mode;
-	sensor_info->SensorOutputDataFormat = imgsensor_info.sensor_output_dataformat;
-
-	sensor_info->CaptureDelayFrame = imgsensor_info.cap_delay_frame; 
-	sensor_info->PreviewDelayFrame = imgsensor_info.pre_delay_frame; 
-	sensor_info->VideoDelayFrame = imgsensor_info.video_delay_frame;
-	sensor_info->HighSpeedVideoDelayFrame = imgsensor_info.hs_video_delay_frame;
-	sensor_info->SlimVideoDelayFrame = imgsensor_info.slim_video_delay_frame;
-
-	sensor_info->SensorMasterClockSwitch = 0; /* not use */
-	sensor_info->SensorDrivingCurrent = imgsensor_info.isp_driving_current;
-	
-	sensor_info->AEShutDelayFrame = imgsensor_info.ae_shut_delay_frame; 		 /* The frame of setting shutter default 0 for TG int */
-	sensor_info->AESensorGainDelayFrame = imgsensor_info.ae_sensor_gain_delay_frame;	/* The frame of setting sensor gain */
-	sensor_info->AEISPGainDelayFrame = imgsensor_info.ae_ispGain_delay_frame;	
-	sensor_info->IHDR_Support = imgsensor_info.ihdr_support;
-	sensor_info->IHDR_LE_FirstLine = imgsensor_info.ihdr_le_firstline;
-	sensor_info->SensorModeNum = imgsensor_info.sensor_mode_num;
-	
-	sensor_info->SensorMIPILaneNumber = imgsensor_info.mipi_lane_num; 
-	sensor_info->SensorClockFreq = imgsensor_info.mclk;
-	sensor_info->SensorClockDividCount = 3; /* not use */
-	sensor_info->SensorClockRisingCount = 0;
-	sensor_info->SensorClockFallingCount = 2; /* not use */
-	sensor_info->SensorPixelClockCount = 3; /* not use */
-	sensor_info->SensorDataLatchCount = 2; /* not use */
-	
-	sensor_info->MIPIDataLowPwr2HighSpeedTermDelayCount = 0; 
-	sensor_info->MIPICLKLowPwr2HighSpeedTermDelayCount = 0;
-	sensor_info->SensorWidthSampling = 0;  // 0 is default 1x
-	sensor_info->SensorHightSampling = 0;	// 0 is default 1x 
-	sensor_info->SensorPacketECCOrder = 1;
-
-	switch (scenario_id) {
-		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-			sensor_info->SensorGrabStartX = imgsensor_info.pre.startx; 
-			sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;		
-			
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
-			
-			break;
-		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
-			sensor_info->SensorGrabStartX = imgsensor_info.cap.startx; 
-			sensor_info->SensorGrabStartY = imgsensor_info.cap.starty;
-				  
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.cap.mipi_data_lp2hs_settle_dc; 
-
-			break;	 
-		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-			
-			sensor_info->SensorGrabStartX = imgsensor_info.normal_video.startx; 
-			sensor_info->SensorGrabStartY = imgsensor_info.normal_video.starty;
-	   
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.normal_video.mipi_data_lp2hs_settle_dc; 
-
-			break;	  
-		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:			
-			sensor_info->SensorGrabStartX = imgsensor_info.hs_video.startx; 
-			sensor_info->SensorGrabStartY = imgsensor_info.hs_video.starty;
-				  
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.hs_video.mipi_data_lp2hs_settle_dc; 
-
-			break;
-		case MSDK_SCENARIO_ID_SLIM_VIDEO:
-			sensor_info->SensorGrabStartX = imgsensor_info.slim_video.startx; 
-			sensor_info->SensorGrabStartY = imgsensor_info.slim_video.starty;
-				  
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.slim_video.mipi_data_lp2hs_settle_dc; 
-
-			break;
-		default:			
-			sensor_info->SensorGrabStartX = imgsensor_info.pre.startx; 
-			sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;		
-			
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
-			break;
-	}
-	
-	return ERROR_NONE;
-}	/*	get_info  */
-
-
-static kal_uint32 control(MSDK_SCENARIO_ID_ENUM scenario_id, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("scenario_id = %d\n", scenario_id);
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.current_scenario_id = scenario_id;
-	spin_unlock(&imgsensor_drv_lock);
-	switch (scenario_id) {
-		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-			preview(image_window, sensor_config_data);
-			break;
-		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
-			capture(image_window, sensor_config_data);
-			break;	
-		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-			normal_video(image_window, sensor_config_data);
-			break;	  
-		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
-			hs_video(image_window, sensor_config_data);
-			break;
-		case MSDK_SCENARIO_ID_SLIM_VIDEO:
-			slim_video(image_window, sensor_config_data);
-			break;	  
-		default:
-			LOG_INF("Error ScenarioId setting");
-			preview(image_window, sensor_config_data);
-			return ERROR_INVALID_SCENARIO_ID;
-	}
-	return ERROR_NONE;
-}	/* control() */
-
-
-
-static kal_uint32 set_video_mode(UINT16 framerate)
-{
-	LOG_INF("framerate = %d\n ", framerate);
-	// SetVideoMode Function should fix framerate
-	if (framerate == 0)
-		// Dynamic frame rate
-		return ERROR_NONE;
-	spin_lock(&imgsensor_drv_lock);
-	if ((framerate == 300) && (imgsensor.autoflicker_en == KAL_TRUE))
-		imgsensor.current_fps = 296;
-	else if ((framerate == 150) && (imgsensor.autoflicker_en == KAL_TRUE))
-		imgsensor.current_fps = 146;
-	else
-		imgsensor.current_fps = framerate;
-	spin_unlock(&imgsensor_drv_lock);
-	set_max_framerate(imgsensor.current_fps,1);
-
-	return ERROR_NONE;
-}
-
-static kal_uint32 set_auto_flicker_mode(kal_bool enable, UINT16 framerate)
-{
-	LOG_INF("enable = %d, framerate = %d \n", enable, framerate);
-	spin_lock(&imgsensor_drv_lock);
-	if (enable) //enable auto flicker	  
-		imgsensor.autoflicker_en = KAL_TRUE;
-	else //Cancel Auto flick
-		imgsensor.autoflicker_en = KAL_FALSE;
-	spin_unlock(&imgsensor_drv_lock);
-	return ERROR_NONE;
-}
-
-
-static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 framerate) 
-{
-	kal_uint32 frame_length;
-  
-	LOG_INF("scenario_id = %d, framerate = %d\n", scenario_id, framerate);
-
-	switch (scenario_id) {
-		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-			frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
-			imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();			
-			break;			
-		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-			if(framerate == 0)
-				return ERROR_NONE;
-			frame_length = imgsensor_info.normal_video.pclk / framerate * 10 / imgsensor_info.normal_video.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.normal_video.framelength) ? (frame_length - imgsensor_info.normal_video.framelength) : 0;			
-			imgsensor.frame_length = imgsensor_info.normal_video.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();			
-			break;
-		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
-		//case MSDK_SCENARIO_ID_CAMERA_ZSD:			
-			frame_length = imgsensor_info.cap.pclk / framerate * 10 / imgsensor_info.cap.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.cap.framelength) ? (frame_length - imgsensor_info.cap.framelength) : 0;
-			imgsensor.frame_length = imgsensor_info.cap.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();			
-			break;	
-		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
-			frame_length = imgsensor_info.hs_video.pclk / framerate * 10 / imgsensor_info.hs_video.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.hs_video.framelength) ? (frame_length - imgsensor_info.hs_video.framelength) : 0;
-			imgsensor.frame_length = imgsensor_info.hs_video.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();			
-			break;
-		case MSDK_SCENARIO_ID_SLIM_VIDEO:
-			frame_length = imgsensor_info.slim_video.pclk / framerate * 10 / imgsensor_info.slim_video.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.slim_video.framelength) ? (frame_length - imgsensor_info.slim_video.framelength): 0;	
-			imgsensor.frame_length = imgsensor_info.slim_video.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();			
-			break;		
-		default:  //coding with  preview scenario by default
-			frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
-			imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();	
-			LOG_INF("error scenario_id = %d, we use preview scenario \n", scenario_id);
-			break;
-	}	
-	return ERROR_NONE;
-}
-
-
-static kal_uint32 get_default_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 *framerate) 
-{
-	LOG_INF("scenario_id = %d\n", scenario_id);
-
-	switch (scenario_id) {
-		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-			*framerate = imgsensor_info.pre.max_framerate;
-			break;
-		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-			*framerate = imgsensor_info.normal_video.max_framerate;
-			break;
-		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
-			*framerate = imgsensor_info.cap.max_framerate;
-			break;		
-		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
-			*framerate = imgsensor_info.hs_video.max_framerate;
-			break;
-		case MSDK_SCENARIO_ID_SLIM_VIDEO: 
-			*framerate = imgsensor_info.slim_video.max_framerate;
-			break;
-		default:
-			break;
-	}
-
-	return ERROR_NONE;
-}
-
-static kal_uint32 set_test_pattern_mode(kal_bool enable)
-{
-	LOG_INF("enable: %d\n", enable);
-
-	if (enable) {
-		// 0x5E00[8]: 1 enable,  0 disable
-		// 0x5E00[1:0]; 00 Color bar, 01 Random Data, 10 Square, 11 BLACK
-		write_cmos_sensor(0x5E00, 0x80);
-	} else {
-		// 0x5E00[8]: 1 enable,  0 disable
-		// 0x5E00[1:0]; 00 Color bar, 01 Random Data, 10 Square, 11 BLACK
-		write_cmos_sensor(0x5E00, 0x00);
-	}	 
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.test_pattern = enable;
-	spin_unlock(&imgsensor_drv_lock);
-	return ERROR_NONE;
-}
-
-static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
-                             UINT8 *feature_para,UINT32 *feature_para_len)
-{
-    UINT16 *feature_return_para_16=(UINT16 *) feature_para;
-    UINT16 *feature_data_16=(UINT16 *) feature_para;
-    UINT32 *feature_return_para_32=(UINT32 *) feature_para;
-    UINT32 *feature_data_32=(UINT32 *) feature_para;
-    unsigned long long *feature_data=(unsigned long long *) feature_para;
-    unsigned long long *feature_return_para=(unsigned long long *) feature_para;
-
-    SENSOR_WINSIZE_INFO_STRUCT *wininfo;
-    MSDK_SENSOR_REG_INFO_STRUCT *sensor_reg_data=(MSDK_SENSOR_REG_INFO_STRUCT *) feature_para;
-
-    LOG_INF("feature_id = %d\n", feature_id);
-    switch (feature_id) {
-        case SENSOR_FEATURE_GET_PERIOD:
-            *feature_return_para_16++ = imgsensor.line_length;
-            *feature_return_para_16 = imgsensor.frame_length;
-            *feature_para_len=4;
-            break;
-        case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:
-            *feature_return_para_32 = imgsensor.pclk;
-            *feature_para_len=4;
-            break;
-        case SENSOR_FEATURE_SET_ESHUTTER:
-            set_shutter(*feature_data);
-            break;
-        case SENSOR_FEATURE_SET_NIGHTMODE:
-            night_mode((BOOL) *feature_data);
-            break;
-        case SENSOR_FEATURE_SET_GAIN:
-            set_gain((UINT16) *feature_data);
-            break;
-        case SENSOR_FEATURE_SET_FLASHLIGHT:
-            break;
-        case SENSOR_FEATURE_SET_ISP_MASTER_CLOCK_FREQ:
-            break;
-        case SENSOR_FEATURE_SET_REGISTER:
-            write_cmos_sensor(sensor_reg_data->RegAddr, sensor_reg_data->RegData);
-            break;
-        case SENSOR_FEATURE_GET_REGISTER:
-            sensor_reg_data->RegData = read_cmos_sensor(sensor_reg_data->RegAddr);
-            break;
-        case SENSOR_FEATURE_GET_LENS_DRIVER_ID:
-            // get the lens driver ID from EEPROM or just return LENS_DRIVER_ID_DO_NOT_CARE
-            // if EEPROM does not exist in camera module.
-            *feature_return_para_32=LENS_DRIVER_ID_DO_NOT_CARE;
-            *feature_para_len=4;
-            break;
-        case SENSOR_FEATURE_SET_VIDEO_MODE:
-            set_video_mode(*feature_data);
-            break;
-        case SENSOR_FEATURE_CHECK_SENSOR_ID:
-            get_imgsensor_id(feature_return_para_32);
-            break;
-        case SENSOR_FEATURE_SET_AUTO_FLICKER_MODE:
-            set_auto_flicker_mode((BOOL)*feature_data_16,*(feature_data_16+1));
-            break;
-        case SENSOR_FEATURE_SET_MAX_FRAME_RATE_BY_SCENARIO:
-            set_max_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data, *(feature_data+1));
-            break;
-        case SENSOR_FEATURE_GET_DEFAULT_FRAME_RATE_BY_SCENARIO:
-            get_default_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*(feature_data), (MUINT32 *)(uintptr_t)(*(feature_data+1)));
-            break;
-        case SENSOR_FEATURE_SET_TEST_PATTERN:
-            set_test_pattern_mode((BOOL)*feature_data);
-            break;
-        case SENSOR_FEATURE_GET_TEST_PATTERN_CHECKSUM_VALUE: //for factory mode auto testing
-            *feature_return_para_32 = imgsensor_info.checksum_value;
-            *feature_para_len=4;
-            break;
-        case SENSOR_FEATURE_SET_FRAMERATE:
-            LOG_INF("current fps :%d\n", (UINT32)*feature_data);
-            spin_lock(&imgsensor_drv_lock);
-            imgsensor.current_fps = *feature_data;
-            spin_unlock(&imgsensor_drv_lock);
-            break;
-        case SENSOR_FEATURE_SET_HDR:
-            LOG_INF("ihdr enable :%d\n", (BOOL)*feature_data);
-            spin_lock(&imgsensor_drv_lock);
-            imgsensor.ihdr_en = (BOOL)*feature_data;
-            spin_unlock(&imgsensor_drv_lock);
-            break;
-        case SENSOR_FEATURE_GET_CROP_INFO:
-            LOG_INF("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n", (UINT32)*feature_data);
-
-            wininfo = (SENSOR_WINSIZE_INFO_STRUCT *)(uintptr_t)(*(feature_data+1));
-
-            switch (*feature_data_32) {
-                case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
-                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[1],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-                    break;
-                case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[2],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-                    break;
-                case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
-                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[3],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-                    break;
-                case MSDK_SCENARIO_ID_SLIM_VIDEO:
-                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[4],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-                    break;
-                case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-                default:
-                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[0],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-                    break;
-            }
-        case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
-            LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",(UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
-            ihdr_write_shutter_gain((UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
-            break;
-        default:
-            break;
-    }
-
-    return ERROR_NONE;
-}    /*    feature_control()  */
-
-
-static SENSOR_FUNCTION_STRUCT sensor_func = {
-	open,
-	get_info,
-	get_resolution,
-	feature_control,
-	control,
-	close
-};
-
-
-UINT32 OV8858_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
-{
-	/* To Do : Check Sensor status here */
-	if (pfFunc!=NULL)
-		*pfFunc=&sensor_func;
-	return ERROR_NONE;
-}	/*	OV5693_MIPI_RAW_SensorInit	*/
-
-UINT32 OV8858R2A_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
-{
-	/* To Do : Check Sensor status here */
-	if (pfFunc!=NULL)
-		*pfFunc=&sensor_func;
-	return ERROR_NONE;
-}	/*	OV5693_MIPI_RAW_SensorInit	*/
-
-
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/imx219_mipi_raw/imx219mipiraw_Sensor.c~ b/drivers/misc/mediatek/imgsensor/src/mt6735m/imx219_mipi_raw/imx219mipiraw_Sensor.c~
deleted file mode 100755
index a00eb64..0000000
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/imx219_mipi_raw/imx219mipiraw_Sensor.c~
+++ /dev/null
@@ -1,2150 +0,0 @@
-/*****************************************************************************
- *
- * Filename:
- * ---------
- *	 imx219mipi_Sensor.c
- *
- * Project:
- * --------
- *	 ALPS
- *
- * Description:
- * ------------
- *	 Source code of Sensor driver
- *
- *
- *------------------------------------------------------------------------------
- * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
- *============================================================================
- ****************************************************************************/
-
-#include <linux/videodev2.h>
-#include <linux/i2c.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/cdev.h>
-#include <linux/uaccess.h>
-#include <linux/fs.h>
-#include <asm/atomic.h>
-//#include <asm/system.h>
-#include <linux/xlog.h>
-
-#include "kd_camera_hw.h"
-#include "kd_imgsensor.h"
-#include "kd_imgsensor_define.h"
-#include "kd_imgsensor_errcode.h"
-
-#include "imx219mipiraw_Sensor.h"
-
-#ifdef CONFIG_MTK_CAM_CAL
-extern int read_imx219_eeprom_mtk_fmt(void);
-#endif
-
-
-/****************************Modify following Strings for debug****************************/
-#define PFX "imx219_camera_sensor"
-#define LOG_1 LOG_INF("imx219,MIPI 2LANE\n")
-#define LOG_2 LOG_INF("preview 1280*960@30fps,864Mbps/lane; video 1280*960@30fps,864Mbps/lane; capture 5M@30fps,864Mbps/lane\n")
-/****************************   Modify end    *******************************************/
-
-#define LOG_INF(format, args...)	pr_debug(PFX "[%s] " format, __FUNCTION__, ##args)
-
-static DEFINE_SPINLOCK(imgsensor_drv_lock);
-
-
-static imgsensor_info_struct imgsensor_info = {
-	.sensor_id = IMX219_SENSOR_ID,		//record sensor id defined in Kd_imgsensor.h
-
-	.checksum_value = 0x9e08861c,		//checksum value for Camera Auto Test
-
-	.pre = {
-		.pclk = 137600000,				//record different mode's pclk
-		.linelength = 0xD78,				//record different mode's linelength
-		.framelength = 0x534,			//record different mode's framelength
-		.startx = 2,					//record different mode's startx of grabwindow
-		.starty = 2,					//record different mode's starty of grabwindow
-		.grabwindow_width = 1632,		//record different mode's width of grabwindow
-		.grabwindow_height = 1224,		//record different mode's height of grabwindow
-		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
-		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
-		/*	 following for GetDefaultFramerateByScenario()	*/
-		.max_framerate = 300,
-	},
-	.cap = {
-		.pclk = 265600000,
-		.linelength = 0xD78,
-		.framelength = 0x9F0,
-		.startx = 4,
-		.starty = 4,
-		.grabwindow_width = 3264,
-		.grabwindow_height = 2448,
-		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
-		.max_framerate = 300,
-	},
-	.cap1 = {							//capture for PIP 24fps relative information, capture1 mode must use same framelength, linelength with Capture mode for shutter calculate
-		.pclk = 265600000,
-		.linelength = 0xD78,
-		.framelength = 0x9F0,
-		.startx = 4,
-		.starty = 4,
-		.grabwindow_width = 3264,
-		.grabwindow_height = 2448,
-		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
-		.max_framerate = 240,	//less than 13M(include 13M),cap1 max framerate is 24fps,16M max framerate is 20fps, 20M max framerate is 15fps
-	},
-	.normal_video = {
-		.pclk = 265600000,
-		.linelength = 0xD78,
-		.framelength = 0x9F0,
-		.startx = 4,
-		.starty = 4,
-		.grabwindow_width = 3264,
-		.grabwindow_height = 2448,
-		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
-		.max_framerate = 300,
-	},
-	.hs_video = {
-		.pclk = 265600000,
-		.linelength = 0xD78,
-		.framelength = 0x9F0,
-		.startx = 4,
-		.starty = 4,
-		.grabwindow_width = 3264,
-		.grabwindow_height = 2448,
-		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
-		.max_framerate = 300,
-	},
-	.slim_video = {
-		.pclk = 265600000,
-		.linelength = 0xD78,
-		.framelength = 0x9F0,
-		.startx = 4,
-		.starty = 4,
-		.grabwindow_width = 1280,
-		.grabwindow_height = 720,
-		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
-		.max_framerate = 300,
-
-	},
-	.custom1 = {
-		.pclk = 137600000,				//record different mode's pclk
-		.linelength = 0xD78,				//record different mode's linelength
-		.framelength = 0x534,			//record different mode's framelength
-		.startx = 2,					//record different mode's startx of grabwindow
-		.starty = 2,					//record different mode's starty of grabwindow
-		.grabwindow_width = 1632,		//record different mode's width of grabwindow
-		.grabwindow_height = 1224,		//record different mode's height of grabwindow
-		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
-		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
-		/*	 following for GetDefaultFramerateByScenario()	*/
-		.max_framerate = 300,
-	},
-	.custom2 = {
-		.pclk = 137600000,				//record different mode's pclk
-		.linelength = 0xD78,				//record different mode's linelength
-		.framelength = 0x534,			//record different mode's framelength
-		.startx = 2,					//record different mode's startx of grabwindow
-		.starty = 2,					//record different mode's starty of grabwindow
-		.grabwindow_width = 1632,		//record different mode's width of grabwindow
-		.grabwindow_height = 1224,		//record different mode's height of grabwindow
-		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
-		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
-		/*	 following for GetDefaultFramerateByScenario()	*/
-		.max_framerate = 300,
-	},
-	.custom3 = {
-		.pclk = 137600000,				//record different mode's pclk
-		.linelength = 0xD78,				//record different mode's linelength
-		.framelength = 0x534,			//record different mode's framelength
-		.startx = 2,					//record different mode's startx of grabwindow
-		.starty = 2,					//record different mode's starty of grabwindow
-		.grabwindow_width = 1632,		//record different mode's width of grabwindow
-		.grabwindow_height = 1224,		//record different mode's height of grabwindow
-		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
-		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
-		/*	 following for GetDefaultFramerateByScenario()	*/
-		.max_framerate = 300,
-	},
-	.custom4 = {
-		.pclk = 137600000,				//record different mode's pclk
-		.linelength = 0xD78,				//record different mode's linelength
-		.framelength = 0x534,			//record different mode's framelength
-		.startx = 2,					//record different mode's startx of grabwindow
-		.starty = 2,					//record different mode's starty of grabwindow
-		.grabwindow_width = 1632,		//record different mode's width of grabwindow
-		.grabwindow_height = 1224,		//record different mode's height of grabwindow
-		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
-		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
-		/*	 following for GetDefaultFramerateByScenario()	*/
-		.max_framerate = 300,
-	},
-	.custom5 = {
-		.pclk = 137600000,				//record different mode's pclk
-		.linelength = 0xD78,				//record different mode's linelength
-		.framelength = 0x534,			//record different mode's framelength
-		.startx = 2,					//record different mode's startx of grabwindow
-		.starty = 2,					//record different mode's starty of grabwindow
-		.grabwindow_width = 1632,		//record different mode's width of grabwindow
-		.grabwindow_height = 1224,		//record different mode's height of grabwindow
-		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
-		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
-		/*	 following for GetDefaultFramerateByScenario()	*/
-		.max_framerate = 300,
-	},
-	.margin = 5,			//sensor framelength & shutter margin
-	.min_shutter = 2,		//min shutter
-	.max_frame_length = 0xffff,//max framelength by sensor register's limitation
-	.ae_shut_delay_frame = 0,	//shutter delay frame for AE cycle, 2 frame with ispGain_delay-shut_delay=2-0=2
-	.ae_sensor_gain_delay_frame = 1,//sensor gain delay frame for AE cycle,2 frame with ispGain_delay-sensor_gain_delay=2-0=2
-	.ae_ispGain_delay_frame = 2,//isp gain delay frame for AE cycle
-	.ihdr_support = 0,	  //1, support; 0,not support
-	.ihdr_le_firstline = 0,  //1,le first ; 0, se first
-	.sensor_mode_num = 10,	  //support sensor mode num
-
-	.cap_delay_frame = 2,		//enter capture delay frame num
-	.pre_delay_frame = 2, 		//enter preview delay frame num
-	.video_delay_frame = 2,		//enter video delay frame num
-	.hs_video_delay_frame = 2,	//enter high speed video  delay frame num
-	.slim_video_delay_frame = 2,//enter slim video delay frame num
-	.custom1_delay_frame = 2,
-	.custom2_delay_frame = 2,
-	.custom3_delay_frame = 2,
-	.custom4_delay_frame = 2,
-	.custom5_delay_frame = 2,
-
-	.isp_driving_current = ISP_DRIVING_8MA, //mclk driving current
-	.sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,//sensor_interface_type
-	.mipi_sensor_type = MIPI_OPHY_NCSI2, //0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2
-	.mipi_settle_delay_mode = 1,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
-	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_B,//sensor output first pixel color
-	.mclk = 24,//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
-	.mipi_lane_num = SENSOR_MIPI_4_LANE,//mipi lane num
-	.i2c_addr_table = {0x21, 0x20, 0xff},//record sensor support all write id addr, only supprt 4must end with 0xff
-        .i2c_speed = 300, // i2c read/write speed
-};
-
-
-static imgsensor_struct imgsensor = {
-	.mirror = IMAGE_NORMAL,				//mirrorflip information
-	.sensor_mode = IMGSENSOR_MODE_INIT, //IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
-	.shutter = 0x3D0,					//current shutter
-	.gain = 0x100,						//current gain
-	.dummy_pixel = 0,					//current dummypixel
-	.dummy_line = 0,					//current dummyline
-	.current_fps = 300,  //full size current fps : 24fps for PIP, 30fps for Normal or ZSD
-	.autoflicker_en = KAL_FALSE,  //auto flicker enable: KAL_FALSE for disable auto flicker, KAL_TRUE for enable auto flicker
-	.test_pattern = KAL_FALSE,		//test pattern mode or not. KAL_FALSE for in test pattern mode, KAL_TRUE for normal output
-	.current_scenario_id = MSDK_SCENARIO_ID_CAMERA_PREVIEW,//current scenario id
-	.ihdr_en = 0, //sensor need support LE, SE with HDR feature
-	.i2c_write_id = 0x20,//record current sensor's i2c write id
-};
-
-
-/* Sensor output window information */
-static SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[10] =
-{{ 3280, 2464,	0, 	0, 3280, 2464, 1640, 1232, 0, 0, 1640, 1232,		2,	2, 1632,  1224}, // Preview
- { 3280, 2464,	0,	0, 3280, 2464, 3280, 2464, 0, 0, 3280, 2464,	4,	4, 3264, 2448}, // capture
- { 3280, 2464,	0,	0, 3280, 2464, 3280, 2464, 0, 0, 3280, 2464,	4,	4, 3264, 2448},  // video
- { 3280, 2464,	0,	0, 3280, 2464, 3280, 2464, 0, 0, 3280, 2464,	4,	4, 3264, 2448}, //hight speed video
- { 3280, 2464,	0,  0, 3280, 2464, 1640,  926, 0, 0, 1640,  926,	0,	0, 1280,  720},// slim video
- { 3280, 2464,	0, 	0, 3280, 2464, 1640, 1232, 0, 0, 1640, 1232,		2,	2, 1632,  1224},
- { 3280, 2464,	0, 	0, 3280, 2464, 1640, 1232, 0, 0, 1640, 1232,		2,	2, 1632,  1224},
- { 3280, 2464,	0, 	0, 3280, 2464, 1640, 1232, 0, 0, 1640, 1232,		2,	2, 1632,  1224},
- { 3280, 2464,	0, 	0, 3280, 2464, 1640, 1232, 0, 0, 1640, 1232,		2,	2, 1632,  1224},
- { 3280, 2464,	0, 	0, 3280, 2464, 1640, 1232, 0, 0, 1640, 1232,		2,	2, 1632,  1224}};
-
-
-#define IMX219MIPI_MaxGainIndex (97)
-kal_uint16 IMX219MIPI_sensorGainMapping[IMX219MIPI_MaxGainIndex][2] ={
-{ 64 ,0  },
-{ 68 ,12 },
-{ 71 ,23 },
-{ 74 ,33 },
-{ 77 ,42 },
-{ 81 ,52 },
-{ 84 ,59 },
-{ 87 ,66 },
-{ 90 ,73 },
-{ 93 ,79 },
-{ 96 ,85 },
-{ 100,91 },
-{ 103,96 },
-{ 106,101},
-{ 109,105},
-{ 113,110},
-{ 116,114},
-{ 120,118},
-{ 122,121},
-{ 125,125},
-{ 128,128},
-{ 132,131},
-{ 135,134},
-{ 138,137},
-{ 141,139},
-{ 144,142},
-{ 148,145},
-{ 151,147},
-{ 153,149},
-{ 157,151},
-{ 160,153},
-{ 164,156},
-{ 168,158},
-{ 169,159},
-{ 173,161},
-{ 176,163},
-{ 180,165},
-{ 182,166},
-{ 187,168},
-{ 189,169},
-{ 193,171},
-{ 196,172},
-{ 200,174},
-{ 203,175},
-{ 205,176},
-{ 208,177},
-{ 213,179},
-{ 216,180},
-{ 219,181},
-{ 222,182},
-{ 225,183},
-{ 228,184},
-{ 232,185},
-{ 235,186},
-{ 238,187},
-{ 241,188},
-{ 245,189},
-{ 249,190},
-{ 253,191},
-{ 256,192},
-{ 260,193},
-{ 265,194},
-{ 269,195},
-{ 274,196},
-{ 278,197},
-{ 283,198},
-{ 288,199},
-{ 293,200},
-{ 298,201},
-{ 304,202},
-{ 310,203},
-{ 315,204},
-{ 322,205},
-{ 328,206},
-{ 335,207},
-{ 342,208},
-{ 349,209},
-{ 357,210},
-{ 365,211},
-{ 373,212},
-{ 381,213},
-{ 400,215},
-{ 420,217},
-{ 432,218},
-{ 443,219},
-{ 468,221},
-{ 482,222},
-{ 497,223},
-{ 512,224},
-{ 529,225},
-{ 546,226},
-{ 566,227},
-{ 585,228},
-{ 607,229},
-{ 631,230},
-{ 656,231},
-{ 683,232}
-};
-
-
-static kal_uint16 read_cmos_sensor(kal_uint32 addr)
-{
-	kal_uint16 get_byte=0;
-
-	char pu_send_cmd[2] = {(char)(addr >> 8), (char)(addr & 0xFF) };
-        kdSetI2CSpeed(imgsensor_info.i2c_speed);
-	iReadRegI2C(pu_send_cmd, 2, (u8*)&get_byte, 1, imgsensor.i2c_write_id);
-
-	return get_byte;
-}
-
-static void write_cmos_sensor(kal_uint32 addr, kal_uint32 para)
-{
-	char pu_send_cmd[3] = {(char)(addr >> 8), (char)(addr & 0xFF), (char)(para & 0xFF)};
-        kdSetI2CSpeed(imgsensor_info.i2c_speed);
-	iWriteRegI2C(pu_send_cmd, 3, imgsensor.i2c_write_id);
-}
-
-static void set_dummy(void)
-{
-	LOG_INF("dummyline = %d, dummypixels = %d \n", imgsensor.dummy_line, imgsensor.dummy_pixel);
-	/* you can set dummy by imgsensor.dummy_line and imgsensor.dummy_pixel, or you can set dummy by imgsensor.frame_length and imgsensor.line_length */
-	write_cmos_sensor(0x0160, (imgsensor.frame_length >>8) & 0xFF);
-    write_cmos_sensor(0x0161, imgsensor.frame_length & 0xFF);
-    write_cmos_sensor(0x0162, (imgsensor.line_length >>8) & 0xFF);
-    write_cmos_sensor(0x0163, imgsensor.line_length & 0xFF);
-
-}	/*	set_dummy  */
-
-static kal_uint32 return_sensor_id(void)
-{
-	return ((read_cmos_sensor(0x0000) << 8) | read_cmos_sensor(0x0001));
-	//int sensorid;
-	//sensorid =  ((read_cmos_sensor(0x0000) << 8) | read_cmos_sensor(0x0001));
-	//LOG_INF("read sensor id:%x", sensorid);
-	//return 0x0219;
-}
-static void set_max_framerate(UINT16 framerate,kal_bool min_framelength_en)
-{
-	kal_uint32 frame_length = imgsensor.frame_length;
-	//unsigned long flags;
-
-	LOG_INF("framerate = %d, min framelength should enable = %d\n", framerate,min_framelength_en);
-
-	frame_length = imgsensor.pclk / framerate * 10 / imgsensor.line_length;
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.frame_length = (frame_length > imgsensor.min_frame_length) ? frame_length : imgsensor.min_frame_length;
-	imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
-	//dummy_line = frame_length - imgsensor.min_frame_length;
-	//if (dummy_line < 0)
-		//imgsensor.dummy_line = 0;
-	//else
-		//imgsensor.dummy_line = dummy_line;
-	//imgsensor.frame_length = frame_length + imgsensor.dummy_line;
-	if (imgsensor.frame_length > imgsensor_info.max_frame_length)
-	{
-		imgsensor.frame_length = imgsensor_info.max_frame_length;
-		imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
-	}
-	if (min_framelength_en)
-		imgsensor.min_frame_length = imgsensor.frame_length;
-	spin_unlock(&imgsensor_drv_lock);
-	set_dummy();
-}	/*	set_max_framerate  */
-
-#if 0
-static void write_shutter(kal_uint16 shutter)
-{
-	kal_uint16 realtime_fps = 0;
-	kal_uint32 frame_length = 0;
-
-	/* 0x3500, 0x3501, 0x3502 will increase VBLANK to get exposure larger than frame exposure */
-	/* AE doesn't update sensor gain at capture mode, thus extra exposure lines must be updated here. */
-
-	// OV Recommend Solution
-	// if shutter bigger than frame_length, should extend frame length first
-	spin_lock(&imgsensor_drv_lock);
-	if (shutter > imgsensor.min_frame_length - imgsensor_info.margin)
-		imgsensor.frame_length = shutter + imgsensor_info.margin;
-	else
-		imgsensor.frame_length = imgsensor.min_frame_length;
-	if (imgsensor.frame_length > imgsensor_info.max_frame_length)
-		imgsensor.frame_length = imgsensor_info.max_frame_length;
-	spin_unlock(&imgsensor_drv_lock);
-	shutter = (shutter < imgsensor_info.min_shutter) ? imgsensor_info.min_shutter : shutter;
-	shutter = (shutter > (imgsensor_info.max_frame_length - imgsensor_info.margin)) ? (imgsensor_info.max_frame_length - imgsensor_info.margin) : shutter;
-
-    // Framelength should be an even number
-    shutter = (shutter >> 1) << 1;
-    imgsensor.frame_length = (imgsensor.frame_length >> 1) << 1;
-
-	if (imgsensor.autoflicker_en) {
-		realtime_fps = imgsensor.pclk / imgsensor.line_length * 10 / imgsensor.frame_length;
-		if(realtime_fps >= 297 && realtime_fps <= 305)
-			set_max_framerate(296,0);
-		else if(realtime_fps >= 147 && realtime_fps <= 150)
-			set_max_framerate(146,0);
-		else {
-		// Extend frame length
-		write_cmos_sensor(0x0160, imgsensor.frame_length >> 8);
-		write_cmos_sensor(0x0161, imgsensor.frame_length & 0xFF);
-		}
-	} else {
-		// Extend frame length
-		write_cmos_sensor(0x0160, imgsensor.frame_length >> 8);
-		write_cmos_sensor(0x0161, imgsensor.frame_length & 0xFF);
-	}
-
-	// Update Shutter
-	write_cmos_sensor(0x015a, (shutter >> 8) & 0xFF);
-	write_cmos_sensor(0x015b, (shutter ) & 0xFF);
-	LOG_INF("Exit! shutter =%d, framelength =%d\n", shutter,imgsensor.frame_length);
-
-	//LOG_INF("frame_length = %d ", frame_length);
-
-}	/*	write_shutter  */
-#endif
-
-/*************************************************************************
-* FUNCTION
-*	set_shutter
-*
-* DESCRIPTION
-*	This function set e-shutter of sensor to change exposure time.
-*
-* PARAMETERS
-*	iShutter : exposured lines
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static void set_shutter(kal_uint16 shutter)
-{
-	unsigned long flags;
-	kal_uint16 realtime_fps = 0;
-	spin_lock_irqsave(&imgsensor_drv_lock, flags);
-	imgsensor.shutter = shutter;
-	spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
-
-	//write_shutter(shutter);
-	/* 0x3500, 0x3501, 0x3502 will increase VBLANK to get exposure larger than frame exposure */
-	/* AE doesn't update sensor gain at capture mode, thus extra exposure lines must be updated here. */
-
-	// OV Recommend Solution
-	// if shutter bigger than frame_length, should extend frame length first
-	spin_lock(&imgsensor_drv_lock);
-	if (shutter > imgsensor.min_frame_length - imgsensor_info.margin)
-		imgsensor.frame_length = shutter + imgsensor_info.margin;
-	else
-		imgsensor.frame_length = imgsensor.min_frame_length;
-	if (imgsensor.frame_length > imgsensor_info.max_frame_length)
-		imgsensor.frame_length = imgsensor_info.max_frame_length;
-	spin_unlock(&imgsensor_drv_lock);
-	shutter = (shutter < imgsensor_info.min_shutter) ? imgsensor_info.min_shutter : shutter;
-	shutter = (shutter > (imgsensor_info.max_frame_length - imgsensor_info.margin)) ? (imgsensor_info.max_frame_length - imgsensor_info.margin) : shutter;
-
-	if (imgsensor.autoflicker_en) {
-		realtime_fps = imgsensor.pclk / imgsensor.line_length * 10 / imgsensor.frame_length;
-		if(realtime_fps >= 297 && realtime_fps <= 305)
-			set_max_framerate(296,0);
-		else if(realtime_fps >= 147 && realtime_fps <= 150)
-			set_max_framerate(146,0);
-		else {
-		// Extend frame length
-		write_cmos_sensor(0x0160, imgsensor.frame_length >> 8);
-		write_cmos_sensor(0x0161, imgsensor.frame_length & 0xFF);
-		}
-	} else {
-		// Extend frame length
-		write_cmos_sensor(0x0160, imgsensor.frame_length >> 8);
-		write_cmos_sensor(0x0161, imgsensor.frame_length & 0xFF);
-	}
-
-	// Update Shutter
-	write_cmos_sensor(0x015a, (shutter >> 8) & 0xFF);
-	write_cmos_sensor(0x015b, (shutter ) & 0xFF);
-	LOG_INF("Exit! shutter =%d, framelength =%d\n", shutter,imgsensor.frame_length);
-
-}	/*	set_shutter */
-
-
-
-static kal_uint16 gain2reg(const kal_uint16 gain)
-{
-	kal_uint8 iI;
-    LOG_INF("[IMX219MIPI]enter IMX219MIPIGain2Reg function\n");
-    for (iI = 0; iI < (IMX219MIPI_MaxGainIndex-1); iI++)
-	{
-
-        if(gain <IMX219MIPI_sensorGainMapping[iI][0])
-		{
-            break;
-        }
-		if(gain < IMX219MIPI_sensorGainMapping[iI][0])
-		{
-			return IMX219MIPI_sensorGainMapping[iI][1];
-		}
-
-
-    }
-    if(gain != IMX219MIPI_sensorGainMapping[iI][0])
-    {
-         LOG_INF("Gain mapping don't correctly:%d %d \n", gain, IMX219MIPI_sensorGainMapping[iI][0]);
-    }
-	LOG_INF("exit IMX219MIPIGain2Reg function\n");
-    return IMX219MIPI_sensorGainMapping[iI-1][1];
-	//return NONE;
-
-}
-
-/*************************************************************************
-* FUNCTION
-*	set_gain
-*
-* DESCRIPTION
-*	This function is to set global gain to sensor.
-*
-* PARAMETERS
-*	iGain : sensor global gain(base: 0x40)
-*
-* RETURNS
-*	the actually gain set to sensor.
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-UINT16 iPreGain = 0;
-static kal_uint16 set_gain(kal_uint16 gain)
-{
-	kal_uint16 reg_gain;
-
- 	if (iPreGain != gain)
-	{
-		reg_gain = gain2reg(gain);
-		spin_lock(&imgsensor_drv_lock);
-		imgsensor.gain = reg_gain;
-		spin_unlock(&imgsensor_drv_lock);
-		write_cmos_sensor(0x0157, (kal_uint8)reg_gain);
-		LOG_INF("gain = %d , reg_gain = 0x%x\n ", gain, reg_gain);
- 	}
-
-	return gain;
-}	/*	set_gain  */
-
-static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gain)
-{
-	LOG_INF("le:0x%x, se:0x%x, gain:0x%x\n",le,se,gain);
-	if (imgsensor.ihdr_en) {
-
-		spin_lock(&imgsensor_drv_lock);
-			if (le > imgsensor.min_frame_length - imgsensor_info.margin)
-				imgsensor.frame_length = le + imgsensor_info.margin;
-			else
-				imgsensor.frame_length = imgsensor.min_frame_length;
-			if (imgsensor.frame_length > imgsensor_info.max_frame_length)
-				imgsensor.frame_length = imgsensor_info.max_frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			if (le < imgsensor_info.min_shutter) le = imgsensor_info.min_shutter;
-			if (se < imgsensor_info.min_shutter) se = imgsensor_info.min_shutter;
-
-
-				// Extend frame length first
-				write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
-				write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
-
-		write_cmos_sensor(0x3502, (le << 4) & 0xFF);
-		write_cmos_sensor(0x3501, (le >> 4) & 0xFF);
-		write_cmos_sensor(0x3500, (le >> 12) & 0x0F);
-
-		write_cmos_sensor(0x3508, (se << 4) & 0xFF);
-		write_cmos_sensor(0x3507, (se >> 4) & 0xFF);
-		write_cmos_sensor(0x3506, (se >> 12) & 0x0F);
-
-		set_gain(gain);
-	}
-
-}
-
-
-#if 1
-static void set_mirror_flip(kal_uint8 image_mirror)
-{
-	LOG_INF("image_mirror = %d\n", image_mirror);
-
-	/********************************************************
-	   *
-	   *   0x3820[2] ISP Vertical flip
-	   *   0x3820[1] Sensor Vertical flip
-	   *
-	   *   0x3821[2] ISP Horizontal mirror
-	   *   0x3821[1] Sensor Horizontal mirror
-	   *
-	   *   ISP and Sensor flip or mirror register bit should be the same!!
-	   *
-	   ********************************************************/
-	kal_uint8  iTemp;
-	LOG_INF("set_mirror_flip function\n");
-    iTemp = read_cmos_sensor(0x0172) & 0x03;	//Clear the mirror and flip bits.
-    switch (image_mirror)
-    {
-        case IMAGE_NORMAL:
-            write_cmos_sensor(0x0172, 0x03);	//Set normal
-            break;
-        case IMAGE_V_MIRROR:
-            write_cmos_sensor(0x0172, iTemp | 0x01);	//Set flip
-            break;
-        case IMAGE_H_MIRROR:
-            write_cmos_sensor(0x0172, iTemp | 0x02);	//Set mirror
-            break;
-        case IMAGE_HV_MIRROR:
-            write_cmos_sensor(0x0172, 0x00);	//Set mirror and flip
-            break;
-    }
-	LOG_INF("Error image_mirror setting\n");
-
-}
-#endif
-/*************************************************************************
-* FUNCTION
-*	night_mode
-*
-* DESCRIPTION
-*	This function night mode of sensor.
-*
-* PARAMETERS
-*	bEnable: KAL_TRUE -> enable night mode, otherwise, disable night mode
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static void night_mode(kal_bool enable)
-{
-/*No Need to implement this function*/
-}	/*	night_mode	*/
-
-static void sensor_init(void)
-{
-	LOG_INF("E\n");
-	//write_cmos_sensor(0x0100,0x01);  //wake up
-}	/*	sensor_init  */
-
-
-static void preview_setting(void)
-{
-
-	write_cmos_sensor(0x0100,   0x00);
-	write_cmos_sensor(0x30EB,  0x05);
-	write_cmos_sensor(0x30EB,  0x0C);
-	write_cmos_sensor(0x300A,  0xFF);
-	write_cmos_sensor(0x300B,  0xFF);
-	write_cmos_sensor(0x30EB,  0x05);
-	write_cmos_sensor(0x30EB,  0x09);
-	write_cmos_sensor(0x0114,  0x03);
-	write_cmos_sensor(0x0128,  0x00);
-	write_cmos_sensor(0x012A,  0x18);
-	write_cmos_sensor(0x012B,  0x00);
-	write_cmos_sensor(0x0160,  ((imgsensor_info.pre.framelength >> 8) & 0xFF));
-	write_cmos_sensor(0x0161,  (imgsensor_info.pre.framelength & 0xFF));
-	write_cmos_sensor(0x0162,  ((imgsensor_info.pre.linelength >> 8) & 0xFF));
-	write_cmos_sensor(0x0163,  (imgsensor_info.pre.linelength & 0xFF));
-	write_cmos_sensor(0x0164,  0x00);
-	write_cmos_sensor(0x0165,  0x00);
-	write_cmos_sensor(0x0166,  0x0C);
-	write_cmos_sensor(0x0167,  0xCF);
-	write_cmos_sensor(0x0168,  0x00);
-	write_cmos_sensor(0x0169,  0x00);
-	write_cmos_sensor(0x016A,  0x09);
-	write_cmos_sensor(0x016B,  0x9F);
-	write_cmos_sensor(0x016C,  0x06);
-	write_cmos_sensor(0x016D,  0x68);
-	write_cmos_sensor(0x016E,  0x04);
-	write_cmos_sensor(0x016F,  0xD0);
-	write_cmos_sensor(0x0170,  0x01);
-	write_cmos_sensor(0x0171,  0x01);
-	write_cmos_sensor(0x0174,  0x01);
-	write_cmos_sensor(0x0175,  0x01);
-	write_cmos_sensor(0x018C,  0x0A);
-	write_cmos_sensor(0x018D,  0x0A);
-	write_cmos_sensor(0x0301,  0x05);
-	write_cmos_sensor(0x0303,  0x01);
-	write_cmos_sensor(0x0304,  0x03);
-	write_cmos_sensor(0x0305,  0x03);
-	write_cmos_sensor(0x0306,  0x00);
-	write_cmos_sensor(0x0307,  0x2B);
-	write_cmos_sensor(0x0309,  0x0A);
-	write_cmos_sensor(0x030B,  0x01);
-	write_cmos_sensor(0x030C,  0x00);
-	write_cmos_sensor(0x030D,  0x2E);
-	write_cmos_sensor(0x455E,  0x00);
-	write_cmos_sensor(0x471E,  0x4B);
-	write_cmos_sensor(0x4767,  0x0F);
-	write_cmos_sensor(0x4750,  0x14);
-	write_cmos_sensor(0x4540,  0x00);
-	write_cmos_sensor(0x47B4,  0x14);
-	write_cmos_sensor(0x4713,  0x30);
-	write_cmos_sensor(0x478B,  0x10);
-	write_cmos_sensor(0x478F,  0x10);
-	write_cmos_sensor(0x4793,  0x10);
-	write_cmos_sensor(0x4797,  0x0E);
-	write_cmos_sensor(0x479B,  0x0E);
-	write_cmos_sensor(0x0100,  0x01);
-
-}	/*	preview_setting  */
-
-static void capture_setting(kal_uint16 currefps)
-{
-	LOG_INF("E! currefps:%d\n",currefps);
-	if (currefps == 240) { //24fps for PIP
-		//@@full_132PCLK_24.75
-		  write_cmos_sensor(0x0100,	0x00);
-		  write_cmos_sensor(0x30EB,   0x05);
-		  write_cmos_sensor(0x30EB,   0x0C);
-		  write_cmos_sensor(0x300A,   0xFF);
-		  write_cmos_sensor(0x300B,   0xFF);
-		  write_cmos_sensor(0x30EB,   0x05);
-		  write_cmos_sensor(0x30EB,   0x09);
-		  write_cmos_sensor(0x0114,   0x03);
-		  write_cmos_sensor(0x0128,   0x00);
-		  write_cmos_sensor(0x012A,   0x18);
-		  write_cmos_sensor(0x012B,   0x00);
-		  write_cmos_sensor(0x0160,   ((imgsensor_info.cap1.framelength >> 8) & 0xFF));
-		  write_cmos_sensor(0x0161,   (imgsensor_info.cap1.framelength & 0xFF));
-		  write_cmos_sensor(0x0162,   ((imgsensor_info.cap1.linelength >> 8) & 0xFF));
-		  write_cmos_sensor(0x0163,   (imgsensor_info.cap1.linelength & 0xFF));
-		  write_cmos_sensor(0x0164,   0x00);
-		  write_cmos_sensor(0x0165,   0x00);
-		  write_cmos_sensor(0x0166,   0x0C);
-		  write_cmos_sensor(0x0167,   0xCF);
-		  write_cmos_sensor(0x0168,   0x00);
-		  write_cmos_sensor(0x0169,   0x00);
-		  write_cmos_sensor(0x016A,   0x09);
-		  write_cmos_sensor(0x016B,   0x9F);
-		  write_cmos_sensor(0x016C,   0x0C);
-		  write_cmos_sensor(0x016D,   0xD0);
-		  write_cmos_sensor(0x016E,   0x09);
-		  write_cmos_sensor(0x016F,   0xA0);
-		  write_cmos_sensor(0x0170,   0x01);
-		  write_cmos_sensor(0x0171,   0x01);
-		  write_cmos_sensor(0x0174,   0x00);
-		  write_cmos_sensor(0x0175,   0x00);
-		  write_cmos_sensor(0x018C,   0x0A);
-		  write_cmos_sensor(0x018D,   0x0A);
-		  write_cmos_sensor(0x0301,   0x05);
-		  write_cmos_sensor(0x0303,   0x01);
-		  write_cmos_sensor(0x0304,   0x03);
-		  write_cmos_sensor(0x0305,   0x03);
-		  write_cmos_sensor(0x0306,   0x00);
-		  write_cmos_sensor(0x0307,   0x53); //0x51
-		  write_cmos_sensor(0x0309,   0x0A);
-		  write_cmos_sensor(0x030B,   0x01);
-		  write_cmos_sensor(0x030C,   0x00);
-		  write_cmos_sensor(0x030D,   0x56);//0x54
-		  write_cmos_sensor(0x455E,   0x00);
-		  write_cmos_sensor(0x471E,   0x4B);
-		  write_cmos_sensor(0x4767,   0x0F);
-		  write_cmos_sensor(0x4750,   0x14);
-		  write_cmos_sensor(0x4540,   0x00);
-		  write_cmos_sensor(0x47B4,   0x14);
-		  write_cmos_sensor(0x4713,   0x30);
-		  write_cmos_sensor(0x478B,   0x10);
-		  write_cmos_sensor(0x478F,   0x10);
-		  write_cmos_sensor(0x4793,   0x10);
-		  write_cmos_sensor(0x4797,   0x0E);
-		  write_cmos_sensor(0x479B,   0x0E);
-		  write_cmos_sensor(0x0100,   0x01);
-
-	} else {   //30fps			//30fps for Normal capture & ZSD
-		write_cmos_sensor(0x0100,	0x00);
-		  write_cmos_sensor(0x30EB,   0x05);
-		  write_cmos_sensor(0x30EB,   0x0C);
-		  write_cmos_sensor(0x300A,   0xFF);
-		  write_cmos_sensor(0x300B,   0xFF);
-		  write_cmos_sensor(0x30EB,   0x05);
-		  write_cmos_sensor(0x30EB,   0x09);
-		  write_cmos_sensor(0x0114,   0x03);
-		  write_cmos_sensor(0x0128,   0x00);
-		  write_cmos_sensor(0x012A,   0x18);
-		  write_cmos_sensor(0x012B,   0x00);
-		  write_cmos_sensor(0x0160,   ((imgsensor_info.cap.framelength >> 8) & 0xFF));
-		  write_cmos_sensor(0x0161,   (imgsensor_info.cap.framelength & 0xFF));
-		  write_cmos_sensor(0x0162,   ((imgsensor_info.cap.linelength >> 8) & 0xFF));
-		  write_cmos_sensor(0x0163,   (imgsensor_info.cap.linelength & 0xFF));
-		  write_cmos_sensor(0x0164,   0x00);
-		  write_cmos_sensor(0x0165,   0x00);
-		  write_cmos_sensor(0x0166,   0x0C);
-		  write_cmos_sensor(0x0167,   0xCF);
-		  write_cmos_sensor(0x0168,   0x00);
-		  write_cmos_sensor(0x0169,   0x00);
-		  write_cmos_sensor(0x016A,   0x09);
-		  write_cmos_sensor(0x016B,   0x9F);
-		  write_cmos_sensor(0x016C,   0x0C);
-		  write_cmos_sensor(0x016D,   0xD0);
-		  write_cmos_sensor(0x016E,   0x09);
-		  write_cmos_sensor(0x016F,   0xA0);
-		  write_cmos_sensor(0x0170,   0x01);
-		  write_cmos_sensor(0x0171,   0x01);
-		  write_cmos_sensor(0x0174,   0x00);
-		  write_cmos_sensor(0x0175,   0x00);
-		  write_cmos_sensor(0x018C,   0x0A);
-		  write_cmos_sensor(0x018D,   0x0A);
-		  write_cmos_sensor(0x0301,   0x05);
-		  write_cmos_sensor(0x0303,   0x01);
-		  write_cmos_sensor(0x0304,   0x03);
-		  write_cmos_sensor(0x0305,   0x03);
-		  write_cmos_sensor(0x0306,   0x00);
-		  write_cmos_sensor(0x0307,   0x53); //0x51
-		  write_cmos_sensor(0x0309,   0x0A);
-		  write_cmos_sensor(0x030B,   0x01);
-		  write_cmos_sensor(0x030C,   0x00);
-		  write_cmos_sensor(0x030D,   0x56);//0x54
-		  write_cmos_sensor(0x455E,   0x00);
-		  write_cmos_sensor(0x471E,   0x4B);
-		  write_cmos_sensor(0x4767,   0x0F);
-		  write_cmos_sensor(0x4750,   0x14);
-		  write_cmos_sensor(0x4540,   0x00);
-		  write_cmos_sensor(0x47B4,   0x14);
-		  write_cmos_sensor(0x4713,   0x30);
-		  write_cmos_sensor(0x478B,   0x10);
-		  write_cmos_sensor(0x478F,   0x10);
-		  write_cmos_sensor(0x4793,   0x10);
-		  write_cmos_sensor(0x4797,   0x0E);
-		  write_cmos_sensor(0x479B,   0x0E);
-		  write_cmos_sensor(0x0100,   0x01);
-		if (imgsensor.ihdr_en) {
-
-	} else {
-
-	}
-
-	}
-
-}
-
-static void normal_video_setting(kal_uint16 currefps)
-{
-	LOG_INF("E! currefps:%d\n",currefps);
-	write_cmos_sensor(0x0100,	0x00);
-		  write_cmos_sensor(0x30EB,   0x05);
-		  write_cmos_sensor(0x30EB,   0x0C);
-		  write_cmos_sensor(0x300A,   0xFF);
-		  write_cmos_sensor(0x300B,   0xFF);
-		  write_cmos_sensor(0x30EB,   0x05);
-		  write_cmos_sensor(0x30EB,   0x09);
-		  write_cmos_sensor(0x0114,   0x03);
-		  write_cmos_sensor(0x0128,   0x00);
-		  write_cmos_sensor(0x012A,   0x18);
-		  write_cmos_sensor(0x012B,   0x00);
-		  write_cmos_sensor(0x0160,   ((imgsensor_info.normal_video.framelength >> 8) & 0xFF));
-		  write_cmos_sensor(0x0161,   (imgsensor_info.normal_video.framelength & 0xFF));
-		  write_cmos_sensor(0x0162,   ((imgsensor_info.normal_video.linelength >> 8) & 0xFF));
-		  write_cmos_sensor(0x0163,   (imgsensor_info.normal_video.linelength & 0xFF));
-		  write_cmos_sensor(0x0164,   0x00);
-		  write_cmos_sensor(0x0165,   0x00);
-		  write_cmos_sensor(0x0166,   0x0C);
-		  write_cmos_sensor(0x0167,   0xCF);
-		  write_cmos_sensor(0x0168,   0x00);
-		  write_cmos_sensor(0x0169,   0x00);
-		  write_cmos_sensor(0x016A,   0x09);
-		  write_cmos_sensor(0x016B,   0x9F);
-		  write_cmos_sensor(0x016C,   0x0C);
-		  write_cmos_sensor(0x016D,   0xD0);
-		  write_cmos_sensor(0x016E,   0x09);
-		  write_cmos_sensor(0x016F,   0xA0);
-		  write_cmos_sensor(0x0170,   0x01);
-		  write_cmos_sensor(0x0171,   0x01);
-		  write_cmos_sensor(0x0174,   0x00);
-		  write_cmos_sensor(0x0175,   0x00);
-		  write_cmos_sensor(0x018C,   0x0A);
-		  write_cmos_sensor(0x018D,   0x0A);
-		  write_cmos_sensor(0x0301,   0x05);
-		  write_cmos_sensor(0x0303,   0x01);
-		  write_cmos_sensor(0x0304,   0x03);
-		  write_cmos_sensor(0x0305,   0x03);
-		  write_cmos_sensor(0x0306,   0x00);
-		  write_cmos_sensor(0x0307,   0x53); //0x51
-		  write_cmos_sensor(0x0309,   0x0A);
-		  write_cmos_sensor(0x030B,   0x01);
-		  write_cmos_sensor(0x030C,   0x00);
-		  write_cmos_sensor(0x030D,   0x56);//0x54
-		  write_cmos_sensor(0x455E,   0x00);
-		  write_cmos_sensor(0x471E,   0x4B);
-		  write_cmos_sensor(0x4767,   0x0F);
-		  write_cmos_sensor(0x4750,   0x14);
-		  write_cmos_sensor(0x4540,   0x00);
-		  write_cmos_sensor(0x47B4,   0x14);
-		  write_cmos_sensor(0x4713,   0x30);
-		  write_cmos_sensor(0x478B,   0x10);
-		  write_cmos_sensor(0x478F,   0x10);
-		  write_cmos_sensor(0x4793,   0x10);
-		  write_cmos_sensor(0x4797,   0x0E);
-		  write_cmos_sensor(0x479B,   0x0E);
-		  write_cmos_sensor(0x0100,   0x01);
-	if (imgsensor.ihdr_en) {
-	} else {
-	}
-
-}
-static void hs_video_setting(kal_uint16 currefps)
-{
-	LOG_INF("E! currefps:%d\n",currefps);
-	write_cmos_sensor(0x0100,	0x00);
-		  write_cmos_sensor(0x30EB,   0x05);
-		  write_cmos_sensor(0x30EB,   0x0C);
-		  write_cmos_sensor(0x300A,   0xFF);
-		  write_cmos_sensor(0x300B,   0xFF);
-		  write_cmos_sensor(0x30EB,   0x05);
-		  write_cmos_sensor(0x30EB,   0x09);
-		  write_cmos_sensor(0x0114,   0x03);
-		  write_cmos_sensor(0x0128,   0x00);
-		  write_cmos_sensor(0x012A,   0x18);
-		  write_cmos_sensor(0x012B,   0x00);
-		  write_cmos_sensor(0x0160,   ((imgsensor_info.hs_video.framelength >> 8) & 0xFF));
-		  write_cmos_sensor(0x0161,   (imgsensor_info.hs_video.framelength & 0xFF));
-		  write_cmos_sensor(0x0162,   ((imgsensor_info.hs_video.linelength >> 8) & 0xFF));
-		  write_cmos_sensor(0x0163,   (imgsensor_info.hs_video.linelength & 0xFF));
-		  write_cmos_sensor(0x0164,   0x00);
-		  write_cmos_sensor(0x0165,   0x00);
-		  write_cmos_sensor(0x0166,   0x0C);
-		  write_cmos_sensor(0x0167,   0xCF);
-		  write_cmos_sensor(0x0168,   0x00);
-		  write_cmos_sensor(0x0169,   0x00);
-		  write_cmos_sensor(0x016A,   0x09);
-		  write_cmos_sensor(0x016B,   0x9F);
-		  write_cmos_sensor(0x016C,   0x0C);
-		  write_cmos_sensor(0x016D,   0xD0);
-		  write_cmos_sensor(0x016E,   0x09);
-		  write_cmos_sensor(0x016F,   0xA0);
-		  write_cmos_sensor(0x0170,   0x01);
-		  write_cmos_sensor(0x0171,   0x01);
-		  write_cmos_sensor(0x0174,   0x00);
-		  write_cmos_sensor(0x0175,   0x00);
-		  write_cmos_sensor(0x018C,   0x0A);
-		  write_cmos_sensor(0x018D,   0x0A);
-		  write_cmos_sensor(0x0301,   0x05);
-		  write_cmos_sensor(0x0303,   0x01);
-		  write_cmos_sensor(0x0304,   0x03);
-		  write_cmos_sensor(0x0305,   0x03);
-		  write_cmos_sensor(0x0306,   0x00);
-		  write_cmos_sensor(0x0307,   0x53); //0x51
-		  write_cmos_sensor(0x0309,   0x0A);
-		  write_cmos_sensor(0x030B,   0x01);
-		  write_cmos_sensor(0x030C,   0x00);
-		  write_cmos_sensor(0x030D,   0x56);//0x54
-		  write_cmos_sensor(0x455E,   0x00);
-		  write_cmos_sensor(0x471E,   0x4B);
-		  write_cmos_sensor(0x4767,   0x0F);
-		  write_cmos_sensor(0x4750,   0x14);
-		  write_cmos_sensor(0x4540,   0x00);
-		  write_cmos_sensor(0x47B4,   0x14);
-		  write_cmos_sensor(0x4713,   0x30);
-		  write_cmos_sensor(0x478B,   0x10);
-		  write_cmos_sensor(0x478F,   0x10);
-		  write_cmos_sensor(0x4793,   0x10);
-		  write_cmos_sensor(0x4797,   0x0E);
-		  write_cmos_sensor(0x479B,   0x0E);
-		  write_cmos_sensor(0x0100,   0x01);
-	if (imgsensor.ihdr_en) {
-	} else {
-	}
-}
-
-static void slim_video_setting(void)
-{
-	LOG_INF("E\n");
-	write_cmos_sensor(0x0100,   0x00);
-	write_cmos_sensor(0x30EB,   0x05);
-	write_cmos_sensor(0x30EB,   0x0C);
-	write_cmos_sensor(0x300A,   0xFF);
-	write_cmos_sensor(0x300B,   0xFF);
-	write_cmos_sensor(0x30EB,   0x05);
-	write_cmos_sensor(0x30EB,   0x09);
-	write_cmos_sensor(0x0114,   0x03);
-	write_cmos_sensor(0x0128,   0x00);
-	write_cmos_sensor(0x012A,   0x18);
-	write_cmos_sensor(0x012B,   0x00);
-	write_cmos_sensor(0x0160,     ((imgsensor_info.slim_video.framelength >> 8) & 0xFF));
-	write_cmos_sensor(0x0161,     (imgsensor_info.slim_video.framelength & 0xFF));
-	write_cmos_sensor(0x0162,     ((imgsensor_info.slim_video.linelength >> 8) & 0xFF));
-	write_cmos_sensor(0x0163,     (imgsensor_info.slim_video.linelength & 0xFF));
-	write_cmos_sensor(0x0164,   0x00);
-	write_cmos_sensor(0x0165,   0x00);
-	write_cmos_sensor(0x0166,   0x0C);
-	write_cmos_sensor(0x0167,   0xCF);
-	write_cmos_sensor(0x0168,   0x01);
-	write_cmos_sensor(0x0169,   0x32);
-	write_cmos_sensor(0x016A,   0x08);
-	write_cmos_sensor(0x016B,   0x6D);
-	write_cmos_sensor(0x016C,   0x06);
-	write_cmos_sensor(0x016D,   0x68);
-	write_cmos_sensor(0x016E,   0x03);
-	write_cmos_sensor(0x016F,   0x9E);
-	write_cmos_sensor(0x0170,   0x01);
-	write_cmos_sensor(0x0171,   0x01);
-	write_cmos_sensor(0x0174,   0x01);
-	write_cmos_sensor(0x0175,   0x01);
-	write_cmos_sensor(0x018C,   0x0A);
-	write_cmos_sensor(0x018D,   0x0A);
-	write_cmos_sensor(0x0301,   0x05);
-	write_cmos_sensor(0x0303,   0x01);
-	write_cmos_sensor(0x0304,   0x03);
-	write_cmos_sensor(0x0305,   0x03);
-	write_cmos_sensor(0x0306,   0x00);
-	write_cmos_sensor(0x0307,   0x2B); //0x51
-	write_cmos_sensor(0x0309,   0x0A);
-	write_cmos_sensor(0x030B,   0x01);
-	write_cmos_sensor(0x030C,   0x00);
-	write_cmos_sensor(0x030D,   0x2E);//0x54
-	write_cmos_sensor(0x455E,   0x00);
-	write_cmos_sensor(0x471E,   0x4B);
-	write_cmos_sensor(0x4767,   0x0F);
-	write_cmos_sensor(0x4750,   0x14);
-	write_cmos_sensor(0x4540,   0x00);
-	write_cmos_sensor(0x47B4,   0x14);
-	write_cmos_sensor(0x4713,   0x30);
-	write_cmos_sensor(0x478B,   0x10);
-	write_cmos_sensor(0x478F,   0x10);
-	write_cmos_sensor(0x4793,   0x10);
-	write_cmos_sensor(0x4797,   0x0E);
-	write_cmos_sensor(0x479B,   0x0E);
-	write_cmos_sensor(0x0100,   0x01);
-	//@@video_720p_30fps_800Mbps
-
-	if (imgsensor.ihdr_en) {
-	} else {
-	}
-}
-//
-kal_uint8  test_pattern_flag=0;
-
-static kal_uint32 set_test_pattern_mode(kal_bool enable)
-{
-	LOG_INF("enable: %d\n", enable);
-	if(imgsensor.current_scenario_id != MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG)
-	   {
-		   if(enable)
-		   {
-			   //1640 x 1232
-			   // enable color bar
-			   test_pattern_flag=TRUE;
-			   write_cmos_sensor(0x0600, 0x00);
-			   write_cmos_sensor(0x0601, 0x02);
-			   write_cmos_sensor(0x0624, 0x06); //W:3280---h
-			   write_cmos_sensor(0x0625, 0x68); //		  l
-			   write_cmos_sensor(0x0626, 0x04); //H:2464   h
-			   write_cmos_sensor(0x0627, 0xd0); //		  l
-			   write_cmos_sensor(0x6128, 0x00);
-			   write_cmos_sensor(0x6129, 0x02);
-			   write_cmos_sensor(0x613C, 0x06); //W 		h
-			   write_cmos_sensor(0x613D, 0x68); //		   l
-			   write_cmos_sensor(0x613E, 0x04); //H 		h
-			   write_cmos_sensor(0x613F, 0xd0); //			   l
-			   write_cmos_sensor(0x6506, 0x00);
-			   write_cmos_sensor(0x6507, 0x00);
-
-		   }
-		   else
-		   {
-			   //1640 x 1232
-			   test_pattern_flag=FALSE;
-			   write_cmos_sensor(0x0600, 0x00);
-			   write_cmos_sensor(0x0601, 0x00);
-			   write_cmos_sensor(0x0624, 0x06); //W:3280---h
-			   write_cmos_sensor(0x0625, 0x68); //		  l
-			   write_cmos_sensor(0x0626, 0x04); //H:2464   h
-			   write_cmos_sensor(0x0627, 0xd0); //		  l
-			   write_cmos_sensor(0x6128, 0x00);
-			   write_cmos_sensor(0x6129, 0x02);
-			   write_cmos_sensor(0x613C, 0x06); //W 		h
-			   write_cmos_sensor(0x613D, 0x68); //		   l
-			   write_cmos_sensor(0x613E, 0x04); //H 		h
-			   write_cmos_sensor(0x613F, 0xd0); //			   l
-			   write_cmos_sensor(0x6506, 0x00);
-			   write_cmos_sensor(0x6507, 0x00);
-
-		   }
-	   }
-	   else
-	   {
-		   if(enable)
-		   {
-			   //3280 x 2464
-			   // enable color bar
-			   test_pattern_flag=TRUE;
-			   write_cmos_sensor(0x0600, 0x00);
-			   write_cmos_sensor(0x0601, 0x02);
-			   write_cmos_sensor(0x0624, 0x0C); //W:3280---h
-			   write_cmos_sensor(0x0625, 0xD0); //		  l
-			   write_cmos_sensor(0x0626, 0x09); //H:2464   h
-			   write_cmos_sensor(0x0627, 0xA0); //		  l
-			   write_cmos_sensor(0x6128, 0x00);
-			   write_cmos_sensor(0x6129, 0x02);
-			   write_cmos_sensor(0x613C, 0x0C); //W 		h
-			   write_cmos_sensor(0x613D, 0xD0); //		   l
-			   write_cmos_sensor(0x613E, 0x09); //H 		h
-			   write_cmos_sensor(0x613F, 0xA0); //			   l
-			   write_cmos_sensor(0x6506, 0x00);
-			   write_cmos_sensor(0x6507, 0x00);
-
-		   }
-		   else
-		   {
-			   test_pattern_flag=FALSE;
-			   write_cmos_sensor(0x0600, 0x00);
-			   write_cmos_sensor(0x0601, 0x02);
-			   write_cmos_sensor(0x0624, 0x0C); //W:3280---h
-			   write_cmos_sensor(0x0625, 0xD0); //		  l
-			   write_cmos_sensor(0x0626, 0x09); //H:2464   h
-			   write_cmos_sensor(0x0627, 0xA0); //		  l
-			   write_cmos_sensor(0x6128, 0x00);
-			   write_cmos_sensor(0x6129, 0x02);
-			   write_cmos_sensor(0x613C, 0x0C); //W 		h
-			   write_cmos_sensor(0x613D, 0xD0); //		   l
-			   write_cmos_sensor(0x613E, 0x09); //H 		h
-			   write_cmos_sensor(0x613F, 0xA0); //			   l
-			   write_cmos_sensor(0x6506, 0x00);
-			   write_cmos_sensor(0x6507, 0x00);
-
-
-		   }
-	   }
-
-	   return ERROR_NONE;
-
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.test_pattern = enable;
-	spin_unlock(&imgsensor_drv_lock);
-	return ERROR_NONE;
-}
-
-/*************************************************************************
-* FUNCTION
-*	get_imgsensor_id
-*
-* DESCRIPTION
-*	This function get the sensor ID
-*
-* PARAMETERS
-*	*sensorID : return the sensor ID
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 get_imgsensor_id(UINT32 *sensor_id)
-{
-	kal_uint8 i = 0;
-	kal_uint8 retry = 2;
-	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
-	while (imgsensor_info.i2c_addr_table[i] != 0xff) {
-		spin_lock(&imgsensor_drv_lock);
-		imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
-		spin_unlock(&imgsensor_drv_lock);
-		do {
-			*sensor_id = return_sensor_id();
-			if (*sensor_id == imgsensor_info.sensor_id) {
-
-#ifdef CONFIG_MTK_CAM_CAL
-				read_imx219_eeprom_mtk_fmt();
-#endif
-				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
-				return ERROR_NONE;
-			}
-			LOG_INF("Read sensor id fail, i2c write id: 0x%x id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
-			retry--;
-		} while(retry > 0);
-		i++;
-		retry = 2;
-	}
-	if (*sensor_id != imgsensor_info.sensor_id) {
-		// if Sensor ID is not correct, Must set *sensor_id to 0xFFFFFFFF
-		*sensor_id = 0xFFFFFFFF;
-		return ERROR_SENSOR_CONNECT_FAIL;
-	}
-	return ERROR_NONE;
-}
-
-
-/*************************************************************************
-* FUNCTION
-*	open
-*
-* DESCRIPTION
-*	This function initialize the registers of CMOS sensor
-*
-* PARAMETERS
-*	None
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 open(void)
-{
-	kal_uint8 i = 0;
-	kal_uint8 retry = 2;
-	kal_uint32 sensor_id = 0;
-	LOG_1;
-	LOG_2;
-	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
-	while (imgsensor_info.i2c_addr_table[i] != 0xff) {
-		spin_lock(&imgsensor_drv_lock);
-		imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
-		spin_unlock(&imgsensor_drv_lock);
-		do {
-			sensor_id = return_sensor_id();
-			if (sensor_id == imgsensor_info.sensor_id) {
-				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
-				break;
-			}
-			LOG_INF("Read sensor id fail, write id:0x%x id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
-			retry--;
-		} while(retry > 0);
-		i++;
-		if (sensor_id == imgsensor_info.sensor_id)
-			break;
-		retry = 2;
-	}
-	if (imgsensor_info.sensor_id != sensor_id)
-		return ERROR_SENSOR_CONNECT_FAIL;
-
-	/* initail sequence write in  */
-	sensor_init();
-
-	iPreGain = 0;
-
-	spin_lock(&imgsensor_drv_lock);
-
-	imgsensor.autoflicker_en= KAL_FALSE;
-	imgsensor.sensor_mode = IMGSENSOR_MODE_INIT;
-	imgsensor.pclk = imgsensor_info.pre.pclk;
-	imgsensor.frame_length = imgsensor_info.pre.framelength;
-	imgsensor.line_length = imgsensor_info.pre.linelength;
-	imgsensor.min_frame_length = imgsensor_info.pre.framelength;
-	imgsensor.dummy_pixel = 0;
-	imgsensor.dummy_line = 0;
-	imgsensor.ihdr_en = 0;
-	imgsensor.test_pattern = KAL_FALSE;
-	imgsensor.current_fps = imgsensor_info.pre.max_framerate;
-	spin_unlock(&imgsensor_drv_lock);
-
-	return ERROR_NONE;
-}	/*	open  */
-
-
-
-/*************************************************************************
-* FUNCTION
-*	close
-*
-* DESCRIPTION
-*
-*
-* PARAMETERS
-*	None
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 close(void)
-{
-	LOG_INF("E\n");
-
-	/*No Need to implement this function*/
-
-	return ERROR_NONE;
-}	/*	close  */
-
-
-/*************************************************************************
-* FUNCTION
-* preview
-*
-* DESCRIPTION
-*	This function start the sensor preview.
-*
-* PARAMETERS
-*	*image_window : address pointer of pixel numbers in one period of HSYNC
-*  *sensor_config_data : address pointer of line numbers in one period of VSYNC
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("E\n");
-
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.sensor_mode = IMGSENSOR_MODE_PREVIEW;
-	imgsensor.pclk = imgsensor_info.pre.pclk;
-	//imgsensor.video_mode = KAL_FALSE;
-	imgsensor.line_length = imgsensor_info.pre.linelength;
-	imgsensor.frame_length = imgsensor_info.pre.framelength;
-	imgsensor.min_frame_length = imgsensor_info.pre.framelength;
-	imgsensor.autoflicker_en = KAL_FALSE;
-	spin_unlock(&imgsensor_drv_lock);
-	preview_setting();
-	set_mirror_flip(IMAGE_NORMAL);
-	return ERROR_NONE;
-}	/*	preview   */
-
-/*************************************************************************
-* FUNCTION
-*	capture
-*
-* DESCRIPTION
-*	This function setup the CMOS sensor in capture MY_OUTPUT mode
-*
-* PARAMETERS
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-						  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("E\n");
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.sensor_mode = IMGSENSOR_MODE_CAPTURE;
-	if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {//PIP capture: 24fps for less than 13M, 20fps for 16M,15fps for 20M
-		imgsensor.pclk = imgsensor_info.cap1.pclk;
-		imgsensor.line_length = imgsensor_info.cap1.linelength;
-		imgsensor.frame_length = imgsensor_info.cap1.framelength;
-		imgsensor.min_frame_length = imgsensor_info.cap1.framelength;
-		imgsensor.autoflicker_en = KAL_FALSE;
-	} else {
-		if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
-			LOG_INF("Warning: current_fps %d fps is not support, so use cap1's setting: %d fps!\n",imgsensor.current_fps,imgsensor_info.cap1.max_framerate/10);
-		imgsensor.pclk = imgsensor_info.cap.pclk;
-		imgsensor.line_length = imgsensor_info.cap.linelength;
-		imgsensor.frame_length = imgsensor_info.cap.framelength;
-		imgsensor.min_frame_length = imgsensor_info.cap.framelength;
-		imgsensor.autoflicker_en = KAL_FALSE;
-	}
-
-	spin_unlock(&imgsensor_drv_lock);
-
-	capture_setting(imgsensor.current_fps);
-	set_mirror_flip(IMAGE_NORMAL);
-	if(test_pattern_flag)
-	{
-		set_test_pattern_mode(TRUE);
-		test_pattern_flag=FALSE;
-	}
-	return ERROR_NONE;
-}	/* capture() */
-static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("E\n");
-
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.sensor_mode = IMGSENSOR_MODE_VIDEO;
-	imgsensor.pclk = imgsensor_info.normal_video.pclk;
-	imgsensor.line_length = imgsensor_info.normal_video.linelength;
-	imgsensor.frame_length = imgsensor_info.normal_video.framelength;
-	imgsensor.min_frame_length = imgsensor_info.normal_video.framelength;
-	//imgsensor.current_fps = 300;
-	imgsensor.autoflicker_en = KAL_FALSE;
-	spin_unlock(&imgsensor_drv_lock);
-	normal_video_setting(imgsensor.current_fps);
-	set_mirror_flip(IMAGE_NORMAL);
-
-	return ERROR_NONE;
-}	/*	normal_video   */
-
-static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("E\n");
-
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.sensor_mode = IMGSENSOR_MODE_HIGH_SPEED_VIDEO;
-	imgsensor.pclk = imgsensor_info.hs_video.pclk;
-	//imgsensor.video_mode = KAL_TRUE;
-	imgsensor.line_length = imgsensor_info.hs_video.linelength;
-	imgsensor.frame_length = imgsensor_info.hs_video.framelength;
-	imgsensor.min_frame_length = imgsensor_info.hs_video.framelength;
-	imgsensor.dummy_line = 0;
-	imgsensor.dummy_pixel = 0;
-	imgsensor.autoflicker_en = KAL_FALSE;
-	spin_unlock(&imgsensor_drv_lock);
-	hs_video_setting(imgsensor.current_fps);
-	set_mirror_flip(IMAGE_NORMAL);
-	return ERROR_NONE;
-}	/*	hs_video   */
-
-static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("E\n");
-
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.sensor_mode = IMGSENSOR_MODE_SLIM_VIDEO;
-	imgsensor.pclk = imgsensor_info.slim_video.pclk;
-	imgsensor.line_length = imgsensor_info.slim_video.linelength;
-	imgsensor.frame_length = imgsensor_info.slim_video.framelength;
-	imgsensor.min_frame_length = imgsensor_info.slim_video.framelength;
-	imgsensor.dummy_line = 0;
-	imgsensor.dummy_pixel = 0;
-	imgsensor.autoflicker_en = KAL_FALSE;
-	spin_unlock(&imgsensor_drv_lock);
-	slim_video_setting();
-	set_mirror_flip(IMAGE_NORMAL);
-    return ERROR_NONE;
-}  /* slim_video */
-
-/*************************************************************************
-* FUNCTION
-* Custom1
-*
-* DESCRIPTION
-*   This function start the sensor Custom1.
-*
-* PARAMETERS
-*   *image_window : address pointer of pixel numbers in one period of HSYNC
-*  *sensor_config_data : address pointer of line numbers in one period of VSYNC
-*
-* RETURNS
-*   None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 Custom1(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-    LOG_INF("E\n");
-
-    spin_lock(&imgsensor_drv_lock);
-    imgsensor.sensor_mode = IMGSENSOR_MODE_CUSTOM1;
-    imgsensor.pclk = imgsensor_info.custom1.pclk;
-    //imgsensor.video_mode = KAL_FALSE;
-    imgsensor.line_length = imgsensor_info.custom1.linelength;
-    imgsensor.frame_length = imgsensor_info.custom1.framelength;
-    imgsensor.min_frame_length = imgsensor_info.custom1.framelength;
-    imgsensor.autoflicker_en = KAL_FALSE;
-    spin_unlock(&imgsensor_drv_lock);
-    preview_setting();
-	set_mirror_flip(IMAGE_NORMAL);
-    return ERROR_NONE;
-}   /*  Custom1   */
-
-static kal_uint32 Custom2(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-    LOG_INF("E\n");
-
-    spin_lock(&imgsensor_drv_lock);
-    imgsensor.sensor_mode = IMGSENSOR_MODE_CUSTOM2;
-    imgsensor.pclk = imgsensor_info.custom2.pclk;
-    //imgsensor.video_mode = KAL_FALSE;
-    imgsensor.line_length = imgsensor_info.custom2.linelength;
-    imgsensor.frame_length = imgsensor_info.custom2.framelength;
-    imgsensor.min_frame_length = imgsensor_info.custom2.framelength;
-    imgsensor.autoflicker_en = KAL_FALSE;
-    spin_unlock(&imgsensor_drv_lock);
-    preview_setting();
-    set_mirror_flip(IMAGE_NORMAL);
-    return ERROR_NONE;
-}   /*  Custom2   */
-
-static kal_uint32 Custom3(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-    LOG_INF("E\n");
-
-    spin_lock(&imgsensor_drv_lock);
-    imgsensor.sensor_mode = IMGSENSOR_MODE_CUSTOM3;
-    imgsensor.pclk = imgsensor_info.custom3.pclk;
-    //imgsensor.video_mode = KAL_FALSE;
-    imgsensor.line_length = imgsensor_info.custom3.linelength;
-    imgsensor.frame_length = imgsensor_info.custom3.framelength;
-    imgsensor.min_frame_length = imgsensor_info.custom3.framelength;
-    imgsensor.autoflicker_en = KAL_FALSE;
-    spin_unlock(&imgsensor_drv_lock);
-    preview_setting();
-    set_mirror_flip(IMAGE_NORMAL);
-    return ERROR_NONE;
-}   /*  Custom3   */
-
-static kal_uint32 Custom4(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-    LOG_INF("E\n");
-
-    spin_lock(&imgsensor_drv_lock);
-    imgsensor.sensor_mode = IMGSENSOR_MODE_CUSTOM4;
-    imgsensor.pclk = imgsensor_info.custom4.pclk;
-    //imgsensor.video_mode = KAL_FALSE;
-    imgsensor.line_length = imgsensor_info.custom4.linelength;
-    imgsensor.frame_length = imgsensor_info.custom4.framelength;
-    imgsensor.min_frame_length = imgsensor_info.custom4.framelength;
-    imgsensor.autoflicker_en = KAL_FALSE;
-    spin_unlock(&imgsensor_drv_lock);
-    preview_setting();
-    set_mirror_flip(IMAGE_NORMAL);
-    return ERROR_NONE;
-}   /*  Custom4   */
-
-
-static kal_uint32 Custom5(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-    LOG_INF("E\n");
-
-    spin_lock(&imgsensor_drv_lock);
-    imgsensor.sensor_mode = IMGSENSOR_MODE_CUSTOM5;
-    imgsensor.pclk = imgsensor_info.custom5.pclk;
-    //imgsensor.video_mode = KAL_FALSE;
-    imgsensor.line_length = imgsensor_info.custom5.linelength;
-    imgsensor.frame_length = imgsensor_info.custom5.framelength;
-    imgsensor.min_frame_length = imgsensor_info.custom5.framelength;
-    imgsensor.autoflicker_en = KAL_FALSE;
-    spin_unlock(&imgsensor_drv_lock);
-    preview_setting();
-    set_mirror_flip(IMAGE_NORMAL);
-    return ERROR_NONE;
-}   /*  Custom5   */
-static kal_uint32 get_resolution(MSDK_SENSOR_RESOLUTION_INFO_STRUCT *sensor_resolution)
-{
-	LOG_INF("E\n");
-	sensor_resolution->SensorFullWidth = imgsensor_info.cap.grabwindow_width;
-	sensor_resolution->SensorFullHeight = imgsensor_info.cap.grabwindow_height;
-
-	sensor_resolution->SensorPreviewWidth = imgsensor_info.pre.grabwindow_width;
-	sensor_resolution->SensorPreviewHeight = imgsensor_info.pre.grabwindow_height;
-
-	sensor_resolution->SensorVideoWidth = imgsensor_info.normal_video.grabwindow_width;
-	sensor_resolution->SensorVideoHeight = imgsensor_info.normal_video.grabwindow_height;
-
-
-	sensor_resolution->SensorHighSpeedVideoWidth	 = imgsensor_info.hs_video.grabwindow_width;
-	sensor_resolution->SensorHighSpeedVideoHeight	 = imgsensor_info.hs_video.grabwindow_height;
-
-	sensor_resolution->SensorSlimVideoWidth	 = imgsensor_info.slim_video.grabwindow_width;
-	sensor_resolution->SensorSlimVideoHeight	 = imgsensor_info.slim_video.grabwindow_height;
-
-    sensor_resolution->SensorHighSpeedVideoWidth     = imgsensor_info.hs_video.grabwindow_width;
-    sensor_resolution->SensorHighSpeedVideoHeight    = imgsensor_info.hs_video.grabwindow_height;
-
-    sensor_resolution->SensorSlimVideoWidth  = imgsensor_info.slim_video.grabwindow_width;
-    sensor_resolution->SensorSlimVideoHeight     = imgsensor_info.slim_video.grabwindow_height;
-
-    sensor_resolution->SensorCustom1Width  = imgsensor_info.custom1.grabwindow_width;
-    sensor_resolution->SensorCustom1Height     = imgsensor_info.custom1.grabwindow_height;
-
-    sensor_resolution->SensorCustom2Width  = imgsensor_info.custom2.grabwindow_width;
-    sensor_resolution->SensorCustom2Height     = imgsensor_info.custom2.grabwindow_height;
-
-    sensor_resolution->SensorCustom3Width  = imgsensor_info.custom3.grabwindow_width;
-    sensor_resolution->SensorCustom3Height     = imgsensor_info.custom3.grabwindow_height;
-
-    sensor_resolution->SensorCustom4Width  = imgsensor_info.custom4.grabwindow_width;
-    sensor_resolution->SensorCustom4Height     = imgsensor_info.custom4.grabwindow_height;
-
-    sensor_resolution->SensorCustom5Width  = imgsensor_info.custom5.grabwindow_width;
-    sensor_resolution->SensorCustom5Height     = imgsensor_info.custom5.grabwindow_height;
-	return ERROR_NONE;
-}	/*	get_resolution	*/
-
-static kal_uint32 get_info(MSDK_SCENARIO_ID_ENUM scenario_id,
-					  MSDK_SENSOR_INFO_STRUCT *sensor_info,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("scenario_id = %d\n", scenario_id);
-
-
-	//sensor_info->SensorVideoFrameRate = imgsensor_info.normal_video.max_framerate/10; /* not use */
-	//sensor_info->SensorStillCaptureFrameRate= imgsensor_info.cap.max_framerate/10; /* not use */
-	//imgsensor_info->SensorWebCamCaptureFrameRate= imgsensor_info.v.max_framerate; /* not use */
-
-	sensor_info->SensorClockPolarity = SENSOR_CLOCK_POLARITY_LOW;
-	sensor_info->SensorClockFallingPolarity = SENSOR_CLOCK_POLARITY_LOW; /* not use */
-	sensor_info->SensorHsyncPolarity = SENSOR_CLOCK_POLARITY_LOW; // inverse with datasheet
-	sensor_info->SensorVsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
-	sensor_info->SensorInterruptDelayLines = 4; /* not use */
-	sensor_info->SensorResetActiveHigh = FALSE; /* not use */
-	sensor_info->SensorResetDelayCount = 5; /* not use */
-
-	sensor_info->SensroInterfaceType = imgsensor_info.sensor_interface_type;
-	sensor_info->MIPIsensorType = imgsensor_info.mipi_sensor_type;
-	sensor_info->SettleDelayMode = imgsensor_info.mipi_settle_delay_mode;
-	sensor_info->SensorOutputDataFormat = imgsensor_info.sensor_output_dataformat;
-
-	sensor_info->CaptureDelayFrame = imgsensor_info.cap_delay_frame;
-	sensor_info->PreviewDelayFrame = imgsensor_info.pre_delay_frame;
-	sensor_info->VideoDelayFrame = imgsensor_info.video_delay_frame;
-	sensor_info->HighSpeedVideoDelayFrame = imgsensor_info.hs_video_delay_frame;
-	sensor_info->SlimVideoDelayFrame = imgsensor_info.slim_video_delay_frame;
-    sensor_info->Custom1DelayFrame = imgsensor_info.custom1_delay_frame;
-    sensor_info->Custom2DelayFrame = imgsensor_info.custom2_delay_frame;
-    sensor_info->Custom3DelayFrame = imgsensor_info.custom3_delay_frame;
-    sensor_info->Custom4DelayFrame = imgsensor_info.custom4_delay_frame;
-    sensor_info->Custom5DelayFrame = imgsensor_info.custom5_delay_frame;
-
-	sensor_info->SensorMasterClockSwitch = 0; /* not use */
-	sensor_info->SensorDrivingCurrent = imgsensor_info.isp_driving_current;
-
-	sensor_info->AEShutDelayFrame = imgsensor_info.ae_shut_delay_frame; 		 /* The frame of setting shutter default 0 for TG int */
-	sensor_info->AESensorGainDelayFrame = imgsensor_info.ae_sensor_gain_delay_frame;	/* The frame of setting sensor gain */
-	sensor_info->AEISPGainDelayFrame = imgsensor_info.ae_ispGain_delay_frame;
-	sensor_info->IHDR_Support = imgsensor_info.ihdr_support;
-	sensor_info->IHDR_LE_FirstLine = imgsensor_info.ihdr_le_firstline;
-	sensor_info->SensorModeNum = imgsensor_info.sensor_mode_num;
-
-	sensor_info->SensorMIPILaneNumber = imgsensor_info.mipi_lane_num;
-	sensor_info->SensorClockFreq = imgsensor_info.mclk;
-	sensor_info->SensorClockDividCount = 3; /* not use */
-	sensor_info->SensorClockRisingCount = 0;
-	sensor_info->SensorClockFallingCount = 2; /* not use */
-	sensor_info->SensorPixelClockCount = 3; /* not use */
-	sensor_info->SensorDataLatchCount = 2; /* not use */
-
-	sensor_info->MIPIDataLowPwr2HighSpeedTermDelayCount = 0;
-	sensor_info->MIPICLKLowPwr2HighSpeedTermDelayCount = 0;
-	sensor_info->SensorWidthSampling = 0;  // 0 is default 1x
-	sensor_info->SensorHightSampling = 0;	// 0 is default 1x
-	sensor_info->SensorPacketECCOrder = 1;
-
-	switch (scenario_id) {
-		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-			sensor_info->SensorGrabStartX = imgsensor_info.pre.startx;
-			sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;
-
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
-
-			break;
-		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
-			sensor_info->SensorGrabStartX = imgsensor_info.cap.startx;
-			sensor_info->SensorGrabStartY = imgsensor_info.cap.starty;
-
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.cap.mipi_data_lp2hs_settle_dc;
-
-			break;
-		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-
-			sensor_info->SensorGrabStartX = imgsensor_info.normal_video.startx;
-			sensor_info->SensorGrabStartY = imgsensor_info.normal_video.starty;
-
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.normal_video.mipi_data_lp2hs_settle_dc;
-
-			break;
-		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
-			sensor_info->SensorGrabStartX = imgsensor_info.hs_video.startx;
-			sensor_info->SensorGrabStartY = imgsensor_info.hs_video.starty;
-
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.hs_video.mipi_data_lp2hs_settle_dc;
-
-			break;
-		case MSDK_SCENARIO_ID_SLIM_VIDEO:
-			sensor_info->SensorGrabStartX = imgsensor_info.slim_video.startx;
-			sensor_info->SensorGrabStartY = imgsensor_info.slim_video.starty;
-
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.slim_video.mipi_data_lp2hs_settle_dc;
-
-			break;
-        case MSDK_SCENARIO_ID_CUSTOM1:
-            sensor_info->SensorGrabStartX = imgsensor_info.custom1.startx;
-            sensor_info->SensorGrabStartY = imgsensor_info.custom1.starty;
-            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.custom1.mipi_data_lp2hs_settle_dc;
-            break;
-        case MSDK_SCENARIO_ID_CUSTOM2:
-            sensor_info->SensorGrabStartX = imgsensor_info.custom2.startx;
-            sensor_info->SensorGrabStartY = imgsensor_info.custom2.starty;
-            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.custom1.mipi_data_lp2hs_settle_dc;
-            break;
-        case MSDK_SCENARIO_ID_CUSTOM3:
-            sensor_info->SensorGrabStartX = imgsensor_info.custom3.startx;
-            sensor_info->SensorGrabStartY = imgsensor_info.custom3.starty;
-            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.custom1.mipi_data_lp2hs_settle_dc;
-            break;
-        case MSDK_SCENARIO_ID_CUSTOM4:
-            sensor_info->SensorGrabStartX = imgsensor_info.custom4.startx;
-            sensor_info->SensorGrabStartY = imgsensor_info.custom4.starty;
-            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.custom1.mipi_data_lp2hs_settle_dc;
-            break;
-        case MSDK_SCENARIO_ID_CUSTOM5:
-            sensor_info->SensorGrabStartX = imgsensor_info.custom5.startx;
-            sensor_info->SensorGrabStartY = imgsensor_info.custom5.starty;
-            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.custom1.mipi_data_lp2hs_settle_dc;
-            break;
-        default:
-            sensor_info->SensorGrabStartX = imgsensor_info.pre.startx;
-            sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;
-            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
-            break;
-	}
-
-	return ERROR_NONE;
-}	/*	get_info  */
-
-
-static kal_uint32 control(MSDK_SCENARIO_ID_ENUM scenario_id, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("scenario_id = %d\n", scenario_id);
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.current_scenario_id = scenario_id;
-	spin_unlock(&imgsensor_drv_lock);
-	switch (scenario_id) {
-		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-			preview(image_window, sensor_config_data);
-			break;
-		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
-			capture(image_window, sensor_config_data);
-			break;
-		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-			normal_video(image_window, sensor_config_data);
-			break;
-		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
-			hs_video(image_window, sensor_config_data);
-			break;
-		case MSDK_SCENARIO_ID_SLIM_VIDEO:
-			slim_video(image_window, sensor_config_data);
-			break;
-        case MSDK_SCENARIO_ID_CUSTOM1:
-            Custom1(image_window, sensor_config_data); // Custom1
-            break;
-        case MSDK_SCENARIO_ID_CUSTOM2:
-            Custom2(image_window, sensor_config_data); // Custom1
-            break;
-        case MSDK_SCENARIO_ID_CUSTOM3:
-            Custom3(image_window, sensor_config_data); // Custom1
-            break;
-        case MSDK_SCENARIO_ID_CUSTOM4:
-            Custom4(image_window, sensor_config_data); // Custom1
-            break;
-        case MSDK_SCENARIO_ID_CUSTOM5:
-            Custom5(image_window, sensor_config_data); // Custom1
-            break;
-		default:
-			LOG_INF("Error ScenarioId setting");
-			preview(image_window, sensor_config_data);
-			return ERROR_INVALID_SCENARIO_ID;
-	}
-	return ERROR_NONE;
-}	/* control() */
-
-
-
-static kal_uint32 set_video_mode(UINT16 framerate)
-{
-	LOG_INF("framerate = %d\n ", framerate);
-	// SetVideoMode Function should fix framerate
-	if (framerate == 0)
-		// Dynamic frame rate
-		return ERROR_NONE;
-	spin_lock(&imgsensor_drv_lock);
-	if ((framerate == 300) && (imgsensor.autoflicker_en == KAL_TRUE))
-		imgsensor.current_fps = 296;
-	else if ((framerate == 150) && (imgsensor.autoflicker_en == KAL_TRUE))
-		imgsensor.current_fps = 146;
-	else
-		imgsensor.current_fps = framerate;
-	spin_unlock(&imgsensor_drv_lock);
-	set_max_framerate(imgsensor.current_fps,1);
-
-	return ERROR_NONE;
-}
-
-static kal_uint32 set_auto_flicker_mode(kal_bool enable, UINT16 framerate)
-{
-	LOG_INF("enable = %d, framerate = %d \n", enable, framerate);
-	spin_lock(&imgsensor_drv_lock);
-	if (enable) //enable auto flicker
-		imgsensor.autoflicker_en = KAL_TRUE;
-	else //Cancel Auto flick
-		imgsensor.autoflicker_en = KAL_FALSE;
-	spin_unlock(&imgsensor_drv_lock);
-	return ERROR_NONE;
-}
-
-
-static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 framerate)
-{
-	kal_uint32 frame_length;
-
-	LOG_INF("scenario_id = %d, framerate = %d\n", scenario_id, framerate);
-
-	switch (scenario_id) {
-		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-			frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
-			imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();
-			break;
-		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-			if(framerate == 0)
-				return ERROR_NONE;
-			frame_length = imgsensor_info.normal_video.pclk / framerate * 10 / imgsensor_info.normal_video.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.normal_video.framelength) ? (frame_length - imgsensor_info.normal_video.framelength) : 0;
-			imgsensor.frame_length = imgsensor_info.normal_video.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();
-			break;
-		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
-			frame_length = imgsensor_info.cap.pclk / framerate * 10 / imgsensor_info.cap.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.cap.framelength) ? (frame_length - imgsensor_info.cap.framelength) : 0;
-			imgsensor.frame_length = imgsensor_info.cap.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();
-			break;
-		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
-			frame_length = imgsensor_info.hs_video.pclk / framerate * 10 / imgsensor_info.hs_video.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.hs_video.framelength) ? (frame_length - imgsensor_info.hs_video.framelength) : 0;
-			imgsensor.frame_length = imgsensor_info.hs_video.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();
-			break;
-		case MSDK_SCENARIO_ID_SLIM_VIDEO:
-			frame_length = imgsensor_info.slim_video.pclk / framerate * 10 / imgsensor_info.slim_video.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.slim_video.framelength) ? (frame_length - imgsensor_info.slim_video.framelength): 0;
-			imgsensor.frame_length = imgsensor_info.slim_video.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();
-        case MSDK_SCENARIO_ID_CUSTOM1:
-            frame_length = imgsensor_info.custom1.pclk / framerate * 10 / imgsensor_info.custom1.linelength;
-            spin_lock(&imgsensor_drv_lock);
-            imgsensor.dummy_line = (frame_length > imgsensor_info.custom1.framelength) ? (frame_length - imgsensor_info.custom1.framelength) : 0;
-            if (imgsensor.dummy_line < 0)
-                imgsensor.dummy_line = 0;
-            imgsensor.frame_length = imgsensor_info.custom1.framelength + imgsensor.dummy_line;
-            imgsensor.min_frame_length = imgsensor.frame_length;
-            spin_unlock(&imgsensor_drv_lock);
-            set_dummy();
-            break;
-        case MSDK_SCENARIO_ID_CUSTOM2:
-            frame_length = imgsensor_info.custom2.pclk / framerate * 10 / imgsensor_info.custom2.linelength;
-            spin_lock(&imgsensor_drv_lock);
-            imgsensor.dummy_line = (frame_length > imgsensor_info.custom2.framelength) ? (frame_length - imgsensor_info.custom2.framelength) : 0;
-            if (imgsensor.dummy_line < 0)
-                imgsensor.dummy_line = 0;
-            imgsensor.frame_length = imgsensor_info.custom2.framelength + imgsensor.dummy_line;
-            imgsensor.min_frame_length = imgsensor.frame_length;
-            spin_unlock(&imgsensor_drv_lock);
-            set_dummy();
-            break;
-        case MSDK_SCENARIO_ID_CUSTOM3:
-            frame_length = imgsensor_info.custom3.pclk / framerate * 10 / imgsensor_info.custom3.linelength;
-            spin_lock(&imgsensor_drv_lock);
-            imgsensor.dummy_line = (frame_length > imgsensor_info.custom3.framelength) ? (frame_length - imgsensor_info.custom3.framelength) : 0;
-            if (imgsensor.dummy_line < 0)
-                imgsensor.dummy_line = 0;
-            imgsensor.frame_length = imgsensor_info.custom3.framelength + imgsensor.dummy_line;
-            imgsensor.min_frame_length = imgsensor.frame_length;
-            spin_unlock(&imgsensor_drv_lock);
-            set_dummy();
-            break;
-        case MSDK_SCENARIO_ID_CUSTOM4:
-            frame_length = imgsensor_info.custom4.pclk / framerate * 10 / imgsensor_info.custom4.linelength;
-            spin_lock(&imgsensor_drv_lock);
-            imgsensor.dummy_line = (frame_length > imgsensor_info.custom4.framelength) ? (frame_length - imgsensor_info.custom4.framelength) : 0;
-            if (imgsensor.dummy_line < 0)
-                imgsensor.dummy_line = 0;
-            imgsensor.frame_length = imgsensor_info.custom4.framelength + imgsensor.dummy_line;
-            imgsensor.min_frame_length = imgsensor.frame_length;
-            spin_unlock(&imgsensor_drv_lock);
-            set_dummy();
-            break;
-        case MSDK_SCENARIO_ID_CUSTOM5:
-            frame_length = imgsensor_info.custom5.pclk / framerate * 10 / imgsensor_info.custom5.linelength;
-            spin_lock(&imgsensor_drv_lock);
-            imgsensor.dummy_line = (frame_length > imgsensor_info.custom5.framelength) ? (frame_length - imgsensor_info.custom5.framelength) : 0;
-            if (imgsensor.dummy_line < 0)
-                imgsensor.dummy_line = 0;
-            imgsensor.frame_length = imgsensor_info.custom1.framelength + imgsensor.dummy_line;
-            imgsensor.min_frame_length = imgsensor.frame_length;
-            spin_unlock(&imgsensor_drv_lock);
-            set_dummy();
-			break;
-		default:  //coding with  preview scenario by default
-			frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
-			imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();
-			LOG_INF("error scenario_id = %d, we use preview scenario \n", scenario_id);
-			break;
-	}
-	return ERROR_NONE;
-}
-
-
-static kal_uint32 get_default_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 *framerate)
-{
-	LOG_INF("scenario_id = %d\n", scenario_id);
-
-	switch (scenario_id) {
-		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-			*framerate = imgsensor_info.pre.max_framerate;
-			break;
-		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-			*framerate = imgsensor_info.normal_video.max_framerate;
-			break;
-		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
-			*framerate = imgsensor_info.cap.max_framerate;
-			break;
-		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
-			*framerate = imgsensor_info.hs_video.max_framerate;
-			break;
-		case MSDK_SCENARIO_ID_SLIM_VIDEO:
-			*framerate = imgsensor_info.slim_video.max_framerate;
-			break;
-        case MSDK_SCENARIO_ID_CUSTOM1:
-            *framerate = imgsensor_info.custom1.max_framerate;
-            break;
-        case MSDK_SCENARIO_ID_CUSTOM2:
-            *framerate = imgsensor_info.custom2.max_framerate;
-            break;
-        case MSDK_SCENARIO_ID_CUSTOM3:
-            *framerate = imgsensor_info.custom3.max_framerate;
-            break;
-        case MSDK_SCENARIO_ID_CUSTOM4:
-            *framerate = imgsensor_info.custom4.max_framerate;
-            break;
-        case MSDK_SCENARIO_ID_CUSTOM5:
-            *framerate = imgsensor_info.custom5.max_framerate;
-            break;
-		default:
-			break;
-	}
-
-	return ERROR_NONE;
-}
-
-
-
-static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
-							 UINT8 *feature_para,UINT32 *feature_para_len)
-{
-	UINT16 *feature_return_para_16=(UINT16 *) feature_para;
-	UINT16 *feature_data_16=(UINT16 *) feature_para;
-	UINT32 *feature_return_para_32=(UINT32 *) feature_para;
-	UINT32 *feature_data_32=(UINT32 *) feature_para;
-    unsigned long long *feature_data=(unsigned long long *) feature_para;
-
-	SENSOR_WINSIZE_INFO_STRUCT *wininfo;
-	MSDK_SENSOR_REG_INFO_STRUCT *sensor_reg_data=(MSDK_SENSOR_REG_INFO_STRUCT *) feature_para;
-
-	LOG_INF("feature_id = %d\n", feature_id);
-	switch (feature_id) {
-		case SENSOR_FEATURE_GET_PERIOD:
-			*feature_return_para_16++ = imgsensor.line_length;
-			*feature_return_para_16 = imgsensor.frame_length;
-			*feature_para_len=4;
-			break;
-		case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:
-            LOG_INF("feature_Control imgsensor.pclk = %d,imgsensor.current_fps = %d\n", imgsensor.pclk,imgsensor.current_fps);
-			*feature_return_para_32 = imgsensor.pclk;
-			*feature_para_len=4;
-			break;
-		case SENSOR_FEATURE_SET_ESHUTTER:
-            set_shutter(*feature_data);
-			break;
-		case SENSOR_FEATURE_SET_NIGHTMODE:
-            night_mode((BOOL) *feature_data);
-			break;
-		case SENSOR_FEATURE_SET_GAIN:
-            set_gain((UINT16) *feature_data);
-			break;
-		case SENSOR_FEATURE_SET_FLASHLIGHT:
-			break;
-		case SENSOR_FEATURE_SET_ISP_MASTER_CLOCK_FREQ:
-			break;
-		case SENSOR_FEATURE_SET_REGISTER:
-			write_cmos_sensor(sensor_reg_data->RegAddr, sensor_reg_data->RegData);
-			break;
-		case SENSOR_FEATURE_GET_REGISTER:
-			sensor_reg_data->RegData = read_cmos_sensor(sensor_reg_data->RegAddr);
-			break;
-		case SENSOR_FEATURE_GET_LENS_DRIVER_ID:
-			// get the lens driver ID from EEPROM or just return LENS_DRIVER_ID_DO_NOT_CARE
-			// if EEPROM does not exist in camera module.
-			*feature_return_para_32=LENS_DRIVER_ID_DO_NOT_CARE;
-			*feature_para_len=4;
-			break;
-		case SENSOR_FEATURE_SET_VIDEO_MODE:
-            set_video_mode(*feature_data);
-			break;
-		case SENSOR_FEATURE_CHECK_SENSOR_ID:
-			get_imgsensor_id(feature_return_para_32);
-			break;
-		case SENSOR_FEATURE_SET_AUTO_FLICKER_MODE:
-			set_auto_flicker_mode((BOOL)*feature_data_16,*(feature_data_16+1));
-			break;
-		case SENSOR_FEATURE_SET_MAX_FRAME_RATE_BY_SCENARIO:
-            set_max_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data, *(feature_data+1));
-			break;
-		case SENSOR_FEATURE_GET_DEFAULT_FRAME_RATE_BY_SCENARIO:
-            get_default_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*(feature_data), (MUINT32 *)(uintptr_t)(*(feature_data+1)));
-			break;
-		case SENSOR_FEATURE_SET_TEST_PATTERN:
-            set_test_pattern_mode((BOOL)*feature_data);
-			break;
-		case SENSOR_FEATURE_GET_TEST_PATTERN_CHECKSUM_VALUE: //for factory mode auto testing
-			*feature_return_para_32 = imgsensor_info.checksum_value;
-			*feature_para_len=4;
-			break;
-		case SENSOR_FEATURE_SET_FRAMERATE:
-            LOG_INF("current fps :%d\n", (UINT32)*feature_data);
-			spin_lock(&imgsensor_drv_lock);
-            imgsensor.current_fps = *feature_data;
-			spin_unlock(&imgsensor_drv_lock);
-			break;
-		case SENSOR_FEATURE_SET_HDR:
-            LOG_INF("ihdr enable :%d\n", (BOOL)*feature_data);
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.ihdr_en = *feature_data;
-			spin_unlock(&imgsensor_drv_lock);
-			break;
-		case SENSOR_FEATURE_GET_CROP_INFO:
-            LOG_INF("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n", (UINT32)*feature_data);
-            wininfo = (SENSOR_WINSIZE_INFO_STRUCT *)(uintptr_t)(*(feature_data+1));
-
-			switch (*feature_data_32) {
-				case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
-					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[1],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-					break;
-				case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[2],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-					break;
-				case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
-					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[3],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-					break;
-				case MSDK_SCENARIO_ID_SLIM_VIDEO:
-					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[4],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-					break;
-				case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-				default:
-					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[0],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-					break;
-			}
-		case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
-            LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",(UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
-            ihdr_write_shutter_gain((UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
-			break;
-		default:
-			break;
-	}
-
-	return ERROR_NONE;
-}	/*	feature_control()  */
-
-static SENSOR_FUNCTION_STRUCT sensor_func = {
-	open,
-	get_info,
-	get_resolution,
-	feature_control,
-	control,
-	close
-};
-
-UINT32 IMX219_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
-{
-	/* To Do : Check Sensor status here */
-	if (pfFunc!=NULL)
-		*pfFunc=&sensor_func;
-	return ERROR_NONE;
-}	/*	OV5693_MIPI_RAW_SensorInit	*/
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/kd_sensorlist.h~ b/drivers/misc/mediatek/imgsensor/src/mt6735m/kd_sensorlist.h~
deleted file mode 100755
index 36dbe39..0000000
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/kd_sensorlist.h~
+++ /dev/null
@@ -1,441 +0,0 @@
-//s_add new sensor driver here
-//export funtions
-/*IMX*/
-UINT32 IMX220_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 IMX219_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 IMX214_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 IMX179_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 IMX132_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 IMX135_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 IMX105_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 IMX073_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-/*OV*/
-UINT32 OV16825MIPISensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 OV13850_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 OV12830_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 OV9760MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 OV9740_MIPI_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 OV9726_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT * pfFunc);
-UINT32 OV9726MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT * pfFunc);
-UINT32 OV8865_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 OV8858_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 OV8830SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 OV8825_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 OV7675_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 OV5693_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 OV5670_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 OV5650SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 OV5650MIPISensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 OV5648MIPISensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 OV5647MIPISensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 OV5647SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 OV5645_MIPI_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 OV5642_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 OV5642_MIPI_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 OV5642_MIPI_RGB_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 OV5642_MIPI_JPG_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 OV5642_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 OV5642_YUV_SWI2C_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 OV4688_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 OV3640SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 OV3640_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 OV2722MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 OV2680MIPISensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 OV2659_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 OV2655_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 OV2650SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-/*S5K*/
-UINT32 S5K2P8_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 S5K3H2YX_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 S5K3H7Y_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 S5K4H5YC_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 S5K4H5YX_2LANE_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 S5K5E2YA_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 S5K5CAGX_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 S5K4E1GA_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 S5K4ECGX_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 S5K4ECGX_MIPI_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 S5K4ECGX_MIPI_JPG_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 S5K8AAYX_MIPI_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 S5K8AAYX_PVI_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-/*HI*/
-UINT32 HI841_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 HI707_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 HI704_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 HI551_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 HI545_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 HI544_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 HI542_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 HI542_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 HI253_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 HI191MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-/*MT*/
-UINT32 MT9P012SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 MT9P015SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 MT9P017SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 MT9P017MIPISensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 MT9T113_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 MT9V113_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 MT9T113MIPI_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 MT9V114_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 MT9D115MIPISensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 MT9V115_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-/*GC*/
-UINT32 GC2355_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 GC2235_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 GC2145MIPI_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 GC2035_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 GC0330_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 GC0329_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 GC0313MIPI_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 GC0310_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-/*SP*/
-UINT32 SP0A19_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-/*A*/
-UINT32 A5141_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 A5142_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-/*HM*/
-UINT32 HM3451SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-/*AR*/
-UINT32 AR0833_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-/*SIV*/
-UINT32 SIV120B_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 SIV121D_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-/*PAS (PixArt Image)*/
-UINT32 PAS6180_SERIAL_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-/*Panasoic*/
-UINT32 MN34152_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-/*Toshiba*/
-UINT32 T4K28_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 T4KA7_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-/*Others*/
-UINT32 ISX012_MIPI_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-UINT32 T8EV5_YUV_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc);
-
-//! Add Sensor Init function here
-//! Note:
-//! 1. Add by the resolution from ""large to small"", due to large sensor
-//!    will be possible to be main sensor.
-//!    This can avoid I2C error during searching sensor.
-//! 2. This file should be the same as mediatek\custom\common\hal\imgsensor\src\sensorlist.cpp
-ACDK_KD_SENSOR_INIT_FUNCTION_STRUCT kdSensorList[MAX_NUM_OF_SUPPORT_SENSOR+1] =
-{
-/*IMX*/
-#if defined(IMX220_MIPI_RAW)
-    {IMX220_SENSOR_ID, SENSOR_DRVNAME_IMX220_MIPI_RAW, IMX220_MIPI_RAW_SensorInit},
-#endif
-#if defined(IMX219_MIPI_RAW)
-    {IMX219_SENSOR_ID, SENSOR_DRVNAME_IMX219_MIPI_RAW, IMX219_MIPI_RAW_SensorInit},
-#endif
-#if defined(IMX214_MIPI_RAW)
-    {IMX214_SENSOR_ID, SENSOR_DRVNAME_IMX214_MIPI_RAW, IMX214_MIPI_RAW_SensorInit},
-#endif
-#if defined(IMX179_MIPI_RAW)
-    {IMX179_SENSOR_ID, SENSOR_DRVNAME_IMX179_MIPI_RAW,IMX179_MIPI_RAW_SensorInit},
-#endif
-#if defined(IMX132_MIPI_RAW)
-    {IMX132MIPI_SENSOR_ID, SENSOR_DRVNAME_IMX132_MIPI_RAW, IMX132_MIPI_RAW_SensorInit},
-#endif
-#if defined(IMX135_MIPI_RAW)
-    {IMX135_SENSOR_ID, SENSOR_DRVNAME_IMX135_MIPI_RAW, IMX135_MIPI_RAW_SensorInit},
-#endif
-#if defined(IMX105_MIPI_RAW)
-    {IMX105_SENSOR_ID, SENSOR_DRVNAME_IMX105_MIPI_RAW, IMX105_MIPI_RAW_SensorInit},
-#endif
-#if defined(IMX073_MIPI_RAW)
-    {IMX073_SENSOR_ID, SENSOR_DRVNAME_IMX073_MIPI_RAW, IMX073_MIPI_RAW_SensorInit},
-#endif
-/*OV (OmniVision)*/
-#if defined(OV16825_MIPI_RAW)
-    {OV16825MIPI_SENSOR_ID, SENSOR_DRVNAME_OV16825_MIPI_RAW, OV16825MIPISensorInit},
-#endif
-#if defined(OV13850_MIPI_RAW)
-    {OV13850_SENSOR_ID, SENSOR_DRVNAME_OV13850_MIPI_RAW,OV13850_MIPI_RAW_SensorInit},
-#endif
-#if defined(OV12830_MIPI_RAW)
-    {OV12830_SENSOR_ID, SENSOR_DRVNAME_OV12830_MIPI_RAW, OV12830_MIPI_RAW_SensorInit},
-#endif
-#if defined(OV9760_MIPI_RAW)
-    {OV9760MIPI_SENSOR_ID,SENSOR_DRVNAME_OV9760_MIPI_RAW,OV9760MIPI_RAW_SensorInit},
-#endif
-#if defined(OV9740_MIPI_YUV)
-    {OV9740MIPI_SENSOR_ID, SENSOR_DRVNAME_OV9740_MIPI_YUV, OV9740_MIPI_YUV_SensorInit},
-#endif
-#if defined(OV9726_RAW)
-    {OV9726_SENSOR_ID,SENSOR_DRVNAME_0V9726_RAW,OV9726_RAW_SensorInit},
-#endif
-#if defined(OV9726_MIPI_RAW)
-    {OV9726MIPI_SENSOR_ID,SENSOR_DRVNAME_OV9726_MIPI_RAW,OV9726MIPI_RAW_SensorInit},
-#endif
-#if defined(OV8865_MIPI_RAW)
-    {OV8865_SENSOR_ID, SENSOR_DRVNAME_OV8865_MIPI_RAW,OV8865_MIPI_RAW_SensorInit},
-#endif
-#if defined(OV8858_MIPI_RAW)
-    {OV8858_SENSOR_ID, SENSOR_DRVNAME_OV8858_MIPI_RAW,OV8858_MIPI_RAW_SensorInit},
-#endif
-
-#if defined(OV8830_RAW)
-    {OV8830_SENSOR_ID, SENSOR_DRVNAME_OV8830_RAW, OV8830SensorInit},
-#endif
-
-#if defined(OV8825_MIPI_RAW)
-    {OV8825_SENSOR_ID, SENSOR_DRVNAME_OV8825_MIPI_RAW, OV8825_MIPI_RAW_SensorInit},
-#endif
-#if defined(OV7675_YUV)
-    {OV7675_SENSOR_ID, SENSOR_DRVNAME_OV7675_YUV, OV7675_YUV_SensorInit},
-#endif
-#if defined(OV5693_MIPI_RAW)
-    {OV5693_SENSOR_ID, SENSOR_DRVNAME_OV5693_MIPI_RAW, OV5693_MIPI_RAW_SensorInit},
-#endif
-#if defined(OV5670_MIPI_RAW)
-    {OV5670MIPI_SENSOR_ID, SENSOR_DRVNAME_OV5670_MIPI_RAW, OV5670_MIPI_RAW_SensorInit},
-#endif
-#if defined(OV5650_RAW)
-    {OV5650_SENSOR_ID, SENSOR_DRVNAME_OV5650_RAW,OV5650SensorInit},
-#endif
-#if defined(OV5650MIPI_RAW)
-    {OV5650MIPI_SENSOR_ID, SENSOR_DRVNAME_OV5650MIPI_RAW,OV5650MIPISensorInit},
-#endif
-#if defined(OV5648_MIPI_RAW)
-
-    {OV5648MIPI_SENSOR_ID, SENSOR_DRVNAME_OV5648_MIPI_RAW, OV5648MIPISensorInit},
-#endif
-#if defined(OV5647_MIPI_RAW)
-    {OV5647MIPI_SENSOR_ID, SENSOR_DRVNAME_OV5647MIPI_RAW, OV5647MIPISensorInit},
-#endif
-#if defined(OV5647_RAW)
-    {OV5647_SENSOR_ID, SENSOR_DRVNAME_OV5647_RAW, OV5647SensorInit},
-#endif
-#if defined(OV5645_MIPI_YUV)
-	{OV5645MIPI_SENSOR_ID,SENSOR_DRVNAME_OV5645_MIPI_YUV, OV5645_MIPI_YUV_SensorInit},
-#endif
-#if defined(OV5642_RAW)
-    {OV5642_SENSOR_ID, SENSOR_DRVNAME_OV5642_RAW, OV5642_RAW_SensorInit},
-#endif
-#if defined(OV5642_MIPI_YUV)
-    {OV5642_SENSOR_ID, SENSOR_DRVNAME_OV5642_MIPI_YUV, OV5642_MIPI_YUV_SensorInit},
-#endif
-#if defined(OV5642_MIPI_RGB)
-    {OV5642_SENSOR_ID, SENSOR_DRVNAME_OV5642_MIPI_RGB, OV5642_MIPI_RGB_SensorInit},
-#endif
-#if defined(OV5642_MIPI_JPG)
-    {OV5642_SENSOR_ID, SENSOR_DRVNAME_OV5642_MIPI_JPG, OV5642_MIPI_JPG_SensorInit},
-#endif
-#if defined(OV5642_YUV)
-    {OV5642_SENSOR_ID, SENSOR_DRVNAME_OV5642_YUV, OV5642_YUV_SensorInit},
-#endif
-#if defined(OV4688_MIPI_RAW)
-	{OV4688MIPI_SENSOR_ID, SENSOR_DRVNAME_OV4688_MIPI_RAW, OV4688_MIPI_RAW_SensorInit},
-#endif
-#if defined(OV3640_RAW)
-    {OV3640_SENSOR_ID, SENSOR_DRVNAME_OV3640_RAW,OV3640SensorInit},
-#endif
-#if defined(OV3640_YUV)
-    {OV3640_SENSOR_ID, SENSOR_DRVNAME_OV3640_YUV, OV3640_YUV_SensorInit},
-#endif
-#if defined(OV3640_YUV_AF)
-    {OV3640_SENSOR_ID, SENSOR_DRVNAME_OV3640_YUV, OV3640_YUV_SensorInit},
-#endif
-#if defined(OV2680_MIPI_RAW)
-    {OV2680MIPI_SENSOR_ID, SENSOR_DRVNAME_OV2680_MIPI_RAW,OV2680MIPISensorInit},
-#endif
-#if defined(OV2722_MIPI_RAW)
-    {OV2722MIPI_SENSOR_ID, SENSOR_DRVNAME_OV2722_MIPI_RAW, OV2722MIPI_RAW_SensorInit},
-#endif
-#if defined(OV2659_YUV)
-    {OV2659_SENSOR_ID, SENSOR_DRVNAME_OV2659_YUV,OV2659_YUV_SensorInit},
-#endif
-#if defined(OV2655_YUV)
-    {OV2650_SENSOR_ID, SENSOR_DRVNAME_OV2655_YUV,OV2655_YUV_SensorInit},
-#endif
-#if defined(OV2650_RAW)
-    {OV2650_SENSOR_ID, SENSOR_DRVNAME_OV2650_RAW,OV2650SensorInit},
-#endif
-/*S5K*/
-#if defined(S5K2P8_MIPI_RAW)
-    {S5K2P8_SENSOR_ID, SENSOR_DRVNAME_S5K2P8_MIPI_RAW, S5K2P8_MIPI_RAW_SensorInit},
-#endif
-#if defined(S5K3H2YX_MIPI_RAW)
-    {S5K3H2YX_SENSOR_ID, SENSOR_DRVNAME_S5K3H2YX_MIPI_RAW, S5K3H2YX_MIPI_RAW_SensorInit},
-#endif
-#if defined(S5K3H7Y_MIPI_RAW)
-    {S5K3H7Y_SENSOR_ID, SENSOR_DRVNAME_S5K3H7Y_MIPI_RAW, S5K3H7Y_MIPI_RAW_SensorInit},
-#endif
-#if defined(S5K4H5YC_MIPI_RAW)
-    {S5K4H5YC_SENSOR_ID, SENSOR_DRVNAME_S5K4H5YC_MIPI_RAW, S5K4H5YC_MIPI_RAW_SensorInit},
-#endif
-#if defined(S5K4H5YX_2LANE_MIPI_RAW)
-    {S5K4H5YX_2LANE_SENSOR_ID, SENSOR_DRVNAME_S5K4H5YX_2LANE_MIPI_RAW, S5K4H5YX_2LANE_MIPI_RAW_SensorInit},
-#endif
-#if defined(S5K5E2YA_MIPI_RAW)
-    {S5K5E2YA_SENSOR_ID, SENSOR_DRVNAME_S5K5E2YA_MIPI_RAW, S5K5E2YA_MIPI_RAW_SensorInit},
-#endif
-#if defined(S5K5CAGX_YUV)
-    {S5K5CAGX_SENSOR_ID, SENSOR_DRVNAME_S5K5CAGX_YUV, S5K5CAGX_YUV_SensorInit},
-#endif
-#if defined(S5K4E1GA_MIPI_RAW)
-    {S5K4E1GA_SENSOR_ID, SENSOR_DRVNAME_S5K4E1GA_MIPI_RAW, S5K4E1GA_MIPI_RAW_SensorInit},
-#endif
-#if defined(S5K4ECGX_YUV)
-    {S5K4ECGX_SENSOR_ID, SENSOR_DRVNAME_S5K4ECGX_YUV, S5K4ECGX_YUV_SensorInit},
-#endif
-#if defined(S5K4ECGX_MIPI_YUV)
-    {S5K4ECGX_SENSOR_ID, SENSOR_DRVNAME_S5K4ECGX_MIPI_YUV, S5K4ECGX_MIPI_YUV_SensorInit},
-#endif
-#if defined(S5K4ECGX_MIPI_JPG)
-    {S5K4ECGX_SENSOR_ID, SENSOR_DRVNAME_S5K4ECGX_MIPI_JPG, S5K4ECGX_MIPI_JPG_SensorInit},
-#endif
-#if defined(S5K8AAYX_MIPI_YUV)
-    {S5K8AAYX_MIPI_SENSOR_ID, SENSOR_DRVNAME_S5K8AAYX_MIPI_YUV, S5K8AAYX_MIPI_YUV_SensorInit},
-#endif
-#if defined(S5K8AAYX_YUV)
-    {S5K8AAYX_MIPI_SENSOR_ID, SENSOR_DRVNAME_S5K8AAYX_YUV, S5K8AAYX_PVI_YUV_SensorInit},
-#endif
-/*HI*/
-#if defined(HI841_MIPI_RAW)
-    {HI841_SENSOR_ID, SENSOR_DRVNAME_HI841_MIPI_RAW,HI841_MIPI_RAW_SensorInit},
-#endif
-#if defined(HI707_YUV)
-    {HI707_SENSOR_ID, SENSOR_DRVNAME_HI707_YUV, HI707_YUV_SensorInit},
-#endif
-#if defined(HI704_YUV)
-    {HI704_SENSOR_ID, SENSOR_DRVNAME_HI704_YUV, HI704_YUV_SensorInit},
-#endif
-#if defined(HI551_MIPI_RAW)
-    {HI551_SENSOR_ID, SENSOR_DRVNAME_HI551_MIPI_RAW,HI551_MIPI_RAW_SensorInit},
-#endif
-#if defined(HI545_MIPI_RAW)
-    {HI545MIPI_SENSOR_ID, SENSOR_DRVNAME_HI545_MIPI_RAW, HI545_MIPI_RAW_SensorInit},
-#endif
-#if defined(HI544_MIPI_RAW)
-    {HI544MIPI_SENSOR_ID, SENSOR_DRVNAME_HI544_MIPI_RAW, HI544_MIPI_RAW_SensorInit},
-#endif
-#if defined(HI542_RAW)
-    {HI542_SENSOR_ID, SENSOR_DRVNAME_HI542_RAW, HI542_RAW_SensorInit},
-#endif
-#if defined(HI542_MIPI_RAW)
-    {HI542MIPI_SENSOR_ID, SENSOR_DRVNAME_HI542MIPI_RAW, HI542_MIPI_RAW_SensorInit},
-#endif
-#if defined(HI253_YUV)
-    {HI253_SENSOR_ID, SENSOR_DRVNAME_HI253_YUV, HI253_YUV_SensorInit},
-#endif
-#if defined(HI191_MIPI_RAW)
-    {HI191MIPI_SENSOR_ID, SENSOR_DRVNAME_HI191_MIPI_RAW, HI191MIPI_RAW_SensorInit},
-#endif
-/*MT*/
-#if defined(MT9P012_RAW)
-  {MT9P012_SENSOR_ID, SENSOR_DRVNAME_MT9P012_RAW,MT9P012SensorInit},
-#endif
-#if defined(MT9P015_RAW)
-  {MT9P015_SENSOR_ID, SENSOR_DRVNAME_MT9P015_RAW,MT9P015SensorInit},
-#endif
-#if defined(MT9P017_RAW)
-  {MT9P017_SENSOR_ID, SENSOR_DRVNAME_MT9P017_RAW,MT9P017SensorInit},
-#endif
-#if defined(MT9P017_MIPI_RAW)
-  {MT9P017MIPI_SENSOR_ID, SENSOR_DRVNAME_MT9P017_MIPI_RAW,MT9P017MIPISensorInit},
-#endif
-#if defined(MT9T113_YUV)
-    {MT9T113_SENSOR_ID, SENSOR_DRVNAME_MT9T113_YUV, MT9T113_YUV_SensorInit},
-#endif
-#if defined(MT9T113_MIPI_YUV)
-    {MT9T113MIPI_SENSOR_ID, SENSOR_DRVNAME_MT9T113_MIPI_YUV,MT9T113MIPI_YUV_SensorInit},
-#endif
-#if defined(MT9V113_YUV)
-    {MT9V113_SENSOR_ID, SENSOR_DRVNAME_MT9V113_YUV, MT9V113_YUV_SensorInit},
-#endif
-#if defined(MT9V114_YUV)
-    {MT9V114_SENSOR_ID, SENSOR_DRVNAME_MT9V114_YUV, MT9V114_YUV_SensorInit},
-#endif
-#if defined(MT9D115_MIPI_RAW)
-  {MT9D115_SENSOR_ID, SENSOR_DRVNAME_MT9D115_MIPI_RAW,MT9D115MIPISensorInit},
-#endif
-#if defined(MT9V115_YUV)
-  {MT9V115_SENSOR_ID,SENSOR_DRVNAME_MT9V115_YUV,MT9V115_YUV_SensorInit},
-#endif
-/*GC*/
-#if defined(GC2355_MIPI_RAW)
-    {GC2355_SENSOR_ID, SENSOR_DRVNAME_GC2355_MIPI_RAW,GC2355_MIPI_RAW_SensorInit},
-#endif
-#if defined(GC2235_RAW)
-    {GC2235_SENSOR_ID, SENSOR_DRVNAME_GC2235_RAW, GC2235_RAW_SensorInit},
-#endif
-#if defined(GC2145_MIPI_YUV)
-    {GC2145_SENSOR_ID, SENSOR_DRVNAME_GC2145_MIPI_YUV, GC2145MIPI_YUV_SensorInit},
-#endif
-#if defined(GC2035_YUV)
-    {GC2035_SENSOR_ID, SENSOR_DRVNAME_GC2035_YUV, GC2035_YUV_SensorInit},
-#endif
-#if defined(GC0330_YUV)
-    {GC0330_SENSOR_ID, SENSOR_DRVNAME_GC0330_YUV, GC0330_YUV_SensorInit},
-#endif
-#if defined(GC0329_YUV)
-    {GC0329_SENSOR_ID, SENSOR_DRVNAME_GC0329_YUV, GC0329_YUV_SensorInit},
-#endif
-#if defined(GC0313_MIPI_YUV)
-    {GC0313MIPI_YUV_SENSOR_ID, SENSOR_DRVNAME_GC0313MIPI_YUV, GC0313MIPI_YUV_SensorInit},
-#endif
-#if defined(GC0310_MIPI_YUV)
-    {GC0310_SENSOR_ID, SENSOR_DRVNAME_GC0310_MIPI_YUV,GC0310_YUV_SensorInit},
-#endif
-#if defined(GC0310_YUV)
-    {GC0310_SENSOR_ID, SENSOR_DRVNAME_GC0310_YUV,GC0310_YUV_SensorInit},
-#endif
-/*SP*/
-#if defined(SP0A19_YUV)
-    {SP0A19_YUV_SENSOR_ID, SENSOR_DRVNAME_SP0A19_YUV, SP0A19_YUV_SensorInit},
-#endif
-/*A*/
-#if defined(A5141_MIPI_RAW)
-  {A5141MIPI_SENSOR_ID, SENSOR_DRVNAME_A5141_MIPI_RAW,A5141_MIPI_RAW_SensorInit},
-#endif
-#if defined(A5142_MIPI_RAW)
-  {A5142MIPI_SENSOR_ID, SENSOR_DRVNAME_A5142_MIPI_RAW,A5142_MIPI_RAW_SensorInit},
-#endif
-/*HM*/
-#if defined(HM3451_RAW)
-    {HM3451_SENSOR_ID, SENSOR_DRVNAME_HM3451_RAW, HM3451SensorInit},
-#endif
-/*AR*/
-#if defined(AR0833_MIPI_RAW)
-  {AR0833_SENSOR_ID, SENSOR_DRVNAME_AR0833_MIPI_RAW,AR0833_MIPI_RAW_SensorInit},
-#endif
-/*SIV*/
-#if defined(SIV120B_YUV)
-    {SIV120B_SENSOR_ID, SENSOR_DRVNAME_SIV120B_YUV, SIV120B_YUV_SensorInit},
-#endif
-#if defined(SIV121D_YUV)
-    {SIV121D_SENSOR_ID, SENSOR_DRVNAME_SIV121D_YUV, SIV121D_YUV_SensorInit},
-#endif
-/*PAS (PixArt Image)*/
-#if defined(PAS6180_SERIAL_YUV)
-    {PAS6180_SENSOR_ID, SENSOR_DRVNAME_PAS6180_SERIAL_YUV, PAS6180_SERIAL_YUV_SensorInit},
-#endif
-/*Panasoic*/
-#if defined(MN34152_MIPI_RAW)
-    {MN34152_SENSOR_ID, SENSOR_DRVNAME_MN34152_MIPI_RAW, MN34152_MIPI_RAW_SensorInit},
-#endif
-/*Toshiba*/
-#if defined(T4K28_YUV)
-		{T4K28_SENSOR_ID, SENSOR_DRVNAME_T4K28_YUV, T4K28_YUV_SensorInit},
-#endif
-#if defined(T4KA7_MIPI_RAW)
-    {T4KA7_SENSOR_ID, SENSOR_DRVNAME_T4KA7_MIPI_RAW, T4KA7_MIPI_RAW_SensorInit},
-#endif
-/*Others*/
-#if defined(ISX012_MIPI_YUV)
-    {ISX012MIPI_SENSOR_ID, SENSOR_DRVNAME_ISX012_MIPI_YUV, ISX012_MIPI_YUV_SensorInit},
-#endif
-#if defined(T8EV5_YUV)
-    {T8EV5_SENSOR_ID, SENSOR_DRVNAME_T8EV5_YUV, T8EV5_YUV_SensorInit},
-#endif
-/*LCA Test*/
-#if defined(IMX135_MIPI_RAW_5MP)
-    {IMX135_SENSOR_ID, SENSOR_DRVNAME_IMX135_MIPI_RAW_5MP, IMX135_MIPI_RAW_SensorInit},
-#endif
-
-/*  ADD sensor driver before this line */
-    {0,{0},NULL}, //end of list
-};
-//e_add new sensor driver here
-
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/ov2680_mipi_raw/ov2680mipi_Sensor.c~ b/drivers/misc/mediatek/imgsensor/src/mt6735m/ov2680_mipi_raw/ov2680mipi_Sensor.c~
deleted file mode 100755
index ed36bcb..0000000
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/ov2680_mipi_raw/ov2680mipi_Sensor.c~
+++ /dev/null
@@ -1,1412 +0,0 @@
-/*****************************************************************************
- *
- * Filename:
- * ---------
- *	 OV2680mipi_Sensor.c
- *
- * Project:
- * --------
- *	 ALPS
- *
- * Description:
- * ------------
- *	 Source code of Sensor driver
- *
- *
- *------------------------------------------------------------------------------
- * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
- *============================================================================
- ****************************************************************************/
-
-#include <linux/videodev2.h>
-#include <linux/i2c.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/cdev.h>
-#include <linux/uaccess.h>
-#include <linux/fs.h>
-#include <asm/atomic.h>
-//#include <asm/system.h>
-#include <linux/xlog.h>
-
-#include "kd_camera_hw.h"
-#include "kd_imgsensor.h"
-#include "kd_imgsensor_define.h"
-#include "kd_imgsensor_errcode.h"
-
-#include "ov2680mipi_Sensor.h"
-
-/****************************Modify Following Strings for Debug****************************/
-#define PFX "OV2680_camera_sensor"
-#define LOG_1 LOG_INF("OV2680,MIPI 1LANE\n")
-#define LOG_2 LOG_INF("preview 1600*1200@30fps,600Mbps/lane; video 1600*1200@30fps,600Mbps/lane; 1600*1200@30fps,600Mbps/lane\n")
-/****************************   Modify end    *******************************************/
-#define LOG_INF(format, args...)	pr_debug(PFX "[%s] " format, __FUNCTION__, ##args)
-
-static DEFINE_SPINLOCK(imgsensor_drv_lock);
-
-
-static imgsensor_info_struct imgsensor_info = { 
-	.sensor_id = 0x2680, //OV2680MIPI_SENSOR_ID,  /*sensor_id = 0x2680*/ //record sensor id defined in Kd_imgsensor.h
-	
-	.checksum_value = 0x64d5ee2e, //checksum value for Camera Auto Test
-	
-	.pre = {
-		.pclk = 66000000,				//record different mode's pclk
-		.linelength = 1700,				//record different mode's linelength
-		.framelength = 1294,			//record different mode's framelength
-		.startx = 0,					//record different mode's startx of grabwindow
-		.starty = 0,					//record different mode's starty of grabwindow
-		.grabwindow_width = 1600,		//record different mode's width of grabwindow
-		.grabwindow_height = 1200,		//record different mode's height of grabwindow
-		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
-		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
-		/*	 following for GetDefaultFramerateByScenario()	*/
-		.max_framerate = 300,	
-	},
-	.cap = {/*normal capture*/
-		.pclk = 66000000,
-		.linelength = 1700, 
-		.framelength = 1294,
-		.startx = 0,
-		.starty = 0,
-		.grabwindow_width = 1600,
-		.grabwindow_height = 1200,
-		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
-		.max_framerate = 300,
-	},
-	.cap1 = {/*PIP capture*/ //capture for PIP 24fps relative information, capture1 mode must use same framelength, linelength with Capture mode for shutter calculate
-		.pclk = 66000000,
-		.linelength = 1700, 
-		.framelength = 1294,
-		.startx = 0,
-		.starty = 0,
-		.grabwindow_width = 1600,
-		.grabwindow_height = 1200,
-		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
-		.max_framerate = 240, //less than 13M(include 13M),cap1 max framerate is 24fps,16M max framerate is 20fps, 20M max framerate is 15fps  
-	},
-	.normal_video = {
-		.pclk = 66000000,
-		.linelength = 1700, 
-		.framelength = 1294,
-		.startx = 0,
-		.starty = 0,
-		.grabwindow_width = 1600,
-		.grabwindow_height = 1200,
-		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
-		.max_framerate = 300,
-	},
-	.hs_video = {/*slow motion*/
-		.pclk = 66000000,
-		.linelength = 1446,
-		.framelength = 760,
-		.startx = 0,
-		.starty = 0,
-		.grabwindow_width = 1280,
-		.grabwindow_height = 720,
-		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
-		.max_framerate = 600,
-	},
-	.slim_video = {/*VT Call*/
-		.pclk = 66000000,
-		.linelength = 1700,
-		.framelength = 1294,
-		.startx = 0,
-		.starty = 0,
-		.grabwindow_width = 1600,
-		.grabwindow_height = 1200,
-		.mipi_data_lp2hs_settle_dc = 85,//unit , ns
-		.max_framerate = 300,
-	},
-	
-	.margin = 4,			//sensor framelength & shutter margin
-	.min_shutter = 1,		//min shutter
-	.max_frame_length = 0x7fff,//max framelength by sensor register's limitation
-	.ae_shut_delay_frame = 0,	//shutter delay frame for AE cycle, 2 frame with ispGain_delay-shut_delay=2-0=2
-	.ae_sensor_gain_delay_frame = 0,//sensor gain delay frame for AE cycle,2 frame with ispGain_delay-sensor_gain_delay=2-0=2
-	.ae_ispGain_delay_frame = 2,//isp gain delay frame for AE cycle
-	.ihdr_support = 0,	  //1, support; 0,not support
-	.ihdr_le_firstline = 0,  //1,le first ; 0, se first
-	.sensor_mode_num = 5,	  //support sensor mode num
-	
-	.cap_delay_frame = 1,		//enter capture delay frame num
-	.pre_delay_frame = 2,		//enter preview delay frame num
-	.video_delay_frame = 1, 	//enter video delay frame num
-	.hs_video_delay_frame = 2,	//enter high speed video  delay frame num
-	.slim_video_delay_frame = 2,//enter slim video delay frame num
-	
-	.isp_driving_current = ISP_DRIVING_4MA, //mclk driving current
-	.sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,//sensor_interface_type
-    .mipi_sensor_type = MIPI_OPHY_NCSI2, //0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2
-    .mipi_settle_delay_mode = MIPI_SETTLEDELAY_AUTO,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
-	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_B,//sensor output first pixel color
-	.mclk = 24,//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
-	.mipi_lane_num = SENSOR_MIPI_1_LANE,//mipi lane num
-	.i2c_addr_table = {0x6c,0x20, 0xff},//record sensor support all write id addr, only supprt 4must end with 0xff
-};
-
-
-static imgsensor_struct imgsensor = {
-	.mirror = IMAGE_HV_MIRROR,				//mirrorflip information
-	.sensor_mode = IMGSENSOR_MODE_INIT, //IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
-	.shutter = 0x3D0,					//current shutter
-	.gain = 0x100,						//current gain
-	.dummy_pixel = 0,					//current dummypixel
-	.dummy_line = 0,					//current dummyline
-    .current_fps = 300,  //full size current fps : 24fps for PIP, 30fps for Normal or ZSD
-	.autoflicker_en = KAL_FALSE,  //auto flicker enable: KAL_FALSE for disable auto flicker, KAL_TRUE for enable auto flicker
-	.test_pattern = KAL_FALSE,		//test pattern mode or not. KAL_FALSE for in test pattern mode, KAL_TRUE for normal output
-	.current_scenario_id = MSDK_SCENARIO_ID_CAMERA_PREVIEW,//current scenario id
-	.ihdr_en = 0, //sensor need support LE, SE with HDR feature
-	.i2c_write_id = 0x6c,//record current sensor's i2c write id
-};
-
-
-/* Sensor output window information */
-/*according toov2680 datasheet p53 image cropping*/
-static SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[10] =
-{{ 1616, 1216,	  0,  0, 1615, 1215, 1615, 1215, 8, 8, 1600, 1200,	  0,	0, 1600, 1200}, // Preview 
- { 1616, 1216,	  0,  0, 1615, 1215, 1615, 1215, 8, 8, 1600, 1200,	  0,	0, 1600, 1200}, // capture 
- { 1616, 1216,	  0,  0, 1615, 1215, 1615, 1215, 8, 8, 1600, 1200,	  0,	0, 1600, 1200}, // video 
- { 1616, 1216,	160,242, 1295,  731, 1295,  731, 8, 6, 1280,  720,	  0,	0, 1280,  720}, //hight speed video 
- { 1616, 1216,	  0,  0, 1615, 1215, 1615, 1215, 8, 8, 1600, 1200,	  0,	0, 1600, 1200}, // slim video 
- { 1616, 1216,	  0,  0, 1615, 1215, 1615, 1215, 8, 8, 1600, 1200,	  0,	0, 1600, 1200}, //custom 1
- { 1616, 1216,	  0,  0, 1615, 1215, 1615, 1215, 8, 8, 1600, 1200,	  0,	0, 1600, 1200},
- { 1616, 1216,	  0,  0, 1615, 1215, 1615, 1215, 8, 8, 1600, 1200,	  0,	0, 1600, 1200},
- { 1616, 1216,	  0,  0, 1615, 1215, 1615, 1215, 8, 8, 1600, 1200,	  0,	0, 1600, 1200},
- { 1616, 1216,	  0,  0, 1615, 1215, 1615, 1215, 8, 8, 1600, 1200,	  0,	0, 1600, 1200},
-};
-
-
-static kal_uint16 read_cmos_sensor(kal_uint32 addr)
-{
-	kal_uint16 get_byte=0;
-
-	char pu_send_cmd[2] = {(char)(addr >> 8), (char)(addr & 0xFF) };
-	iReadRegI2C(pu_send_cmd, 2, (u8*)&get_byte, 1, imgsensor.i2c_write_id);
-
-	return get_byte;
-}
-
-static void write_cmos_sensor(kal_uint32 addr, kal_uint32 para)
-{
-	char pu_send_cmd[3] = {(char)(addr >> 8), (char)(addr & 0xFF), (char)(para & 0xFF)};
-	iWriteRegI2C(pu_send_cmd, 3, imgsensor.i2c_write_id);
-}
-
-static void set_dummy()
-{
-	LOG_INF("dummyline = %d, dummypixels = %d \n", imgsensor.dummy_line, imgsensor.dummy_pixel);
-	/* you can set dummy by imgsensor.dummy_line and imgsensor.dummy_pixel, or you can set dummy by imgsensor.frame_length and imgsensor.line_length */
-
-	/*  Add dummy pixels: */
-    /* 0x380c [0:4], 0x380d defines the PCLKs in one line of OV2680  */  
-    /* Add dummy lines:*/
-    /* 0x380e [0:1], 0x380f defines total lines in one frame of OV2680 */
-
-	write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
-	write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);	  
-    write_cmos_sensor(0x380c, imgsensor.line_length >> 8);
-    write_cmos_sensor(0x380d, imgsensor.line_length & 0xFF);
-  
-}	/*	set_dummy  */
-
-static kal_uint32 return_sensor_id()
-{
-    return ((read_cmos_sensor(0x300A) << 8) | read_cmos_sensor(0x300B));
-}
-static void set_max_framerate(UINT16 framerate,kal_bool min_framelength_en)
-{
-	kal_int16 dummy_line;
-	kal_uint32 frame_length = imgsensor.frame_length;
-	//unsigned long flags;
-
-	LOG_INF("framerate = %d, min framelength should enable = %d\n", framerate,min_framelength_en);
-   
-	frame_length = imgsensor.pclk / framerate * 10 / imgsensor.line_length;
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.frame_length = (frame_length > imgsensor.min_frame_length) ? frame_length : imgsensor.min_frame_length; 
-	imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
-    //dummy_line = frame_length - imgsensor.min_frame_length;
-	//if (dummy_line < 0)
-	//	imgsensor.dummy_line = 0;
-	//else
-	//	imgsensor.dummy_line = dummy_line;
-	//imgsensor.frame_length = frame_length + imgsensor.dummy_line;
-	if (imgsensor.frame_length > imgsensor_info.max_frame_length)
-	{
-		imgsensor.frame_length = imgsensor_info.max_frame_length;
-		imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
-	}
-	if (min_framelength_en)
-		imgsensor.min_frame_length = imgsensor.frame_length;
-	spin_unlock(&imgsensor_drv_lock);
-	set_dummy();
-}	/*	set_max_framerate  */
-
-
-static void set_shutter(kal_uint16 shutter)
-{
-    unsigned long flags;
-	kal_uint16 realtime_fps = 0;
-	kal_uint32 frame_length = 0;
-    spin_lock_irqsave(&imgsensor_drv_lock, flags);
-    imgsensor.shutter = shutter;
-    spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
-	   
-	/* 0x3500, 0x3501, 0x3502 will increase VBLANK to get exposure larger than frame exposure */
-	/* AE doesn't update sensor gain at capture mode, thus extra exposure lines must be updated here. */
-	
-	/* OV Recommend Solution
-	*  if shutter bigger than frame_length, should extend frame length first
-	*/
-	
-	if(!shutter) shutter = 1; /*avoid 0*/
-	
-	spin_lock(&imgsensor_drv_lock);
-	if (shutter > imgsensor.min_frame_length - imgsensor_info.margin)		
-		imgsensor.frame_length = shutter + imgsensor_info.margin;
-	else
-		imgsensor.frame_length = imgsensor.min_frame_length;
-	if (imgsensor.frame_length > imgsensor_info.max_frame_length)
-		imgsensor.frame_length = imgsensor_info.max_frame_length;
-	spin_unlock(&imgsensor_drv_lock);
-	//if (shutter < imgsensor_info.min_shutter) shutter = imgsensor_info.min_shutter;
-	shutter = (shutter < imgsensor_info.min_shutter) ? imgsensor_info.min_shutter : shutter;
-	shutter = (shutter > (imgsensor_info.max_frame_length - imgsensor_info.margin)) ? (imgsensor_info.max_frame_length - imgsensor_info.margin) : shutter;
-	if (imgsensor.autoflicker_en) { 
-		realtime_fps = imgsensor.pclk / imgsensor.line_length * 10 / imgsensor.frame_length;
-		if(realtime_fps >= 297 && realtime_fps <= 305)
-			set_max_framerate(296,0);
-		else if(realtime_fps >= 147 && realtime_fps <= 150)
-			set_max_framerate(146,0);	
-        else {
-        // Extend frame length
-        write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
-        write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
-        }
-	} else {
-		// Extend frame length
-		write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
-		write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
-	}
-
-	// Update Shutter
-	write_cmos_sensor(0x3502, (shutter << 4) & 0xFF);
-	write_cmos_sensor(0x3501, (shutter >> 4) & 0xFF);	  
-	write_cmos_sensor(0x3500, (shutter >> 12) & 0x0F);	
-	LOG_INF("Exit! shutter =%d, framelength =%d\n", shutter,imgsensor.frame_length);
-
-	//LOG_INF("frame_length = %d ", frame_length);
-	
-}	/*	set_shutter */
-
-
-
-static kal_uint16 gain2reg(const kal_uint16 gain)
-{
-	
-	kal_uint16 reg_gain = 0x0000;
-	/*
-	reg_gain = ((gain / BASEGAIN) << 4) + ((gain % BASEGAIN) * 16 / BASEGAIN);
-	reg_gain = reg_gain & 0xFFFF;
-	*/
-	return (kal_uint16)reg_gain;
-}
-
-/*************************************************************************
-* FUNCTION
-*	set_gain
-*
-* DESCRIPTION
-*	This function is to set global gain to sensor.
-*
-* PARAMETERS
-*	iGain : sensor global gain(base: 0x40)
-*
-* RETURNS
-*	the actually gain set to sensor.
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint16 set_gain(kal_uint16 gain)
-{
-	kal_uint16 reg_gain;
-
-	/*
-	* sensor gain 1x = 128
-	* max gain = 0x7ff = 15.992x <16x
-	* here we just use 0x3508 analog gain 1 bit[3:2].
-	* 16x~32x should use 0x3508 analog gain 0 bit[1:0]
-	*/
-
-	if (gain < BASEGAIN || gain >= 16 * BASEGAIN) {
-		LOG_INF("Error gain setting");
-
-		if (gain < BASEGAIN)
-			gain = BASEGAIN;
-		else if (gain >= 16 * BASEGAIN)
-			gain = 15.9 * BASEGAIN;		 
-	}
- 
-	/*reg_gain = gain2reg(gain);*/
-	
-	reg_gain = gain/4; //sensor gain base 1x= 16, reg_gain = gain/(64*16);
-	reg_gain &= 0x3ff;
-		
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.gain = reg_gain; 
-	spin_unlock(&imgsensor_drv_lock);
-	LOG_INF("gain = %d , reg_gain = 0x%x\n ", gain, reg_gain);
-
-	write_cmos_sensor(0x350b, reg_gain&0xff);
-	write_cmos_sensor(0x3508, reg_gain>>8);    
-	
-	return gain;
-}	/*	set_gain  */
-
-static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gain)
-{
-	LOG_INF("Warining:Do not supportIHDR, Return. le:0x%x, se:0x%x, gain:0x%x\n",le,se,gain);
-	//return;
-	
-	if (imgsensor.ihdr_en) {
-		
-		spin_lock(&imgsensor_drv_lock);
-			if (le > imgsensor.min_frame_length - imgsensor_info.margin)		
-				imgsensor.frame_length = le + imgsensor_info.margin;
-			else
-				imgsensor.frame_length = imgsensor.min_frame_length;
-			if (imgsensor.frame_length > imgsensor_info.max_frame_length)
-				imgsensor.frame_length = imgsensor_info.max_frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			if (le < imgsensor_info.min_shutter) le = imgsensor_info.min_shutter;
-			if (se < imgsensor_info.min_shutter) se = imgsensor_info.min_shutter;
-			
-			
-				// Extend frame length first
-				write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
-				write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
-
-		write_cmos_sensor(0x3502, (le << 4) & 0xFF);
-		write_cmos_sensor(0x3501, (le >> 4) & 0xFF);	 
-		write_cmos_sensor(0x3500, (le >> 12) & 0x0F);
-		
-		write_cmos_sensor(0x3508, (se << 4) & 0xFF); 
-		write_cmos_sensor(0x3507, (se >> 4) & 0xFF);
-		write_cmos_sensor(0x3506, (se >> 12) & 0x0F); 
-
-		set_gain(gain);
-	}
-
-}
-
-static void set_mirror_flip(kal_uint8 image_mirror)
-{
-	LOG_INF("image_mirror = %d\n", image_mirror);
-
-	/********************************************************
-	   *
-	   *   0x3820[2] ISP Vertical flip
-	   *   0x3820[1] Sensor Vertical flip
-	   *
-	   *   0x3821[2] ISP Horizontal mirror
-	   *   0x3821[1] Sensor Horizontal mirror
-	   *
-	   *   ISP and Sensor flip or mirror register bit should be the same!!
-	   *
-	   ********************************************************/
-	
-	switch (image_mirror) {
-		case IMAGE_NORMAL:
-			write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x00));
-			write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x06));
-			break;
-		case IMAGE_H_MIRROR:
-			write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x00));
-			write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x00));
-			break;
-		case IMAGE_V_MIRROR:
-			write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x06));
-			write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x06));		
-			break;
-		case IMAGE_HV_MIRROR:
-			write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x06));
-			write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x00));
-			break;
-		default:
-			LOG_INF("Error image_mirror setting\n");
-	}
-
-}
-
-/*************************************************************************
-* FUNCTION
-*	night_mode
-*
-* DESCRIPTION
-*	This function night mode of sensor.
-*
-* PARAMETERS
-*	bEnable: KAL_TRUE -> enable night mode, otherwise, disable night mode
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static void night_mode(kal_bool enable)
-{
-/*No Need to implement this function*/ 
-}	/*	night_mode	*/
-static void preview_setting(void)
-{
-	LOG_INF("E\n");
-	
-	/*
-	 * @@Initial - MIPI 1-Lane 1600x1200 10-bit 30fps
-	* 100 99 1600 1200
-	*/
-	write_cmos_sensor(0x0100, 0x00);
-	write_cmos_sensor(0x3086, 0x00);
-	write_cmos_sensor(0x3501, 0x4e);
-	write_cmos_sensor(0x3502, 0xe0);
-	write_cmos_sensor(0x3620, 0x24);
-	write_cmos_sensor(0x3621, 0x37);
-	write_cmos_sensor(0x3622, 0x03);
-	write_cmos_sensor(0x370a, 0x21);
-	write_cmos_sensor(0x370d, 0xc0);
-	write_cmos_sensor(0x3718, 0x80);
-	write_cmos_sensor(0x3721, 0x09);
-	write_cmos_sensor(0x3722, 0x06);
-	write_cmos_sensor(0x3723, 0x59);
-	write_cmos_sensor(0x3738, 0x99);
-	write_cmos_sensor(0x3801, 0x00);
-	write_cmos_sensor(0x3803, 0x00);
-	write_cmos_sensor(0x3804, 0x06);
-	write_cmos_sensor(0x3805, 0x4f);
-	write_cmos_sensor(0x3806, 0x04);
-	write_cmos_sensor(0x3807, 0xbf);
-	write_cmos_sensor(0x3808, 0x06);
-	write_cmos_sensor(0x3809, 0x40);
-	write_cmos_sensor(0x380a, 0x04);
-	write_cmos_sensor(0x380b, 0xb0);
-	write_cmos_sensor(0x380c, 0x06);
-	write_cmos_sensor(0x380d, 0xa4);
-	write_cmos_sensor(0x380e, 0x05);
-	write_cmos_sensor(0x380f, 0x0e);
-	write_cmos_sensor(0x3811, 0x08);
-	write_cmos_sensor(0x3813, 0x08);
-	write_cmos_sensor(0x3814, 0x11);
-	write_cmos_sensor(0x3815, 0x11);
-	write_cmos_sensor(0x3820, 0xc4);
-	write_cmos_sensor(0x3821, 0x04);
-	write_cmos_sensor(0x4008, 0x02);
-	write_cmos_sensor(0x4009, 0x09);
-	write_cmos_sensor(0x4837, 0x18);
-	write_cmos_sensor(0x0100, 0x01);
-	mdelay(60);
-}
-	/*	preview_setting  */
-
-static void sensor_init(void)
-{
-	LOG_INF("E\n");
-
-   /*
-    * @@Initial - MIPI 1-Lane 1600x1200 10-bit 30fps
-   * 100 99 1600 1200
-   */
-   
-	/* Reset */
-	write_cmos_sensor(0x0103, 0x01);
-	mdelay(50);
-	write_cmos_sensor(0x3002, 0x00);
-	write_cmos_sensor(0x3016, 0x1c);
-	write_cmos_sensor(0x3018, 0x44);
-	write_cmos_sensor(0x3020, 0x00);
-	write_cmos_sensor(0x3080, 0x02);
-	write_cmos_sensor(0x3082, 0x37);
-	write_cmos_sensor(0x3084, 0x09);
-	write_cmos_sensor(0x3085, 0x04);
-	write_cmos_sensor(0x3086, 0x01);
-	write_cmos_sensor(0x3501, 0x26);
-	write_cmos_sensor(0x3502, 0x40);
-	write_cmos_sensor(0x3503, 0x03);
-	write_cmos_sensor(0x350b, 0x36);
-	write_cmos_sensor(0x3600, 0xb4);
-	write_cmos_sensor(0x3603, 0x35);
-	write_cmos_sensor(0x3604, 0x24);
-	write_cmos_sensor(0x3605, 0x00);
-	write_cmos_sensor(0x3620, 0x26);
-	write_cmos_sensor(0x3621, 0x37);
-	write_cmos_sensor(0x3622, 0x04);
-	write_cmos_sensor(0x3628, 0x00);
-	write_cmos_sensor(0x3701, 0x64);
-	write_cmos_sensor(0x3705, 0x3c);
-	write_cmos_sensor(0x370c, 0x50);
-	write_cmos_sensor(0x370d, 0xc0);
-	write_cmos_sensor(0x3718, 0x88);
-	write_cmos_sensor(0x3720, 0x00);
-	write_cmos_sensor(0x3721, 0x00);
-	write_cmos_sensor(0x3722, 0x00);
-	write_cmos_sensor(0x3723, 0x00);
-	write_cmos_sensor(0x3738, 0x00);
-	write_cmos_sensor(0x370a, 0x23);
-	write_cmos_sensor(0x3717, 0x58);
-	write_cmos_sensor(0x3781, 0x80);
-	write_cmos_sensor(0x3784, 0x0c); //
-	write_cmos_sensor(0x3789, 0x60);
-	write_cmos_sensor(0x3800, 0x00);
-	write_cmos_sensor(0x3801, 0x00);
-	write_cmos_sensor(0x3802, 0x00);
-	write_cmos_sensor(0x3803, 0x00);
-	write_cmos_sensor(0x3804, 0x06);
-	write_cmos_sensor(0x3805, 0x4f);
-	write_cmos_sensor(0x3806, 0x04);
-	write_cmos_sensor(0x3807, 0xbf);
-	write_cmos_sensor(0x3808, 0x03);
-	write_cmos_sensor(0x3809, 0x20);
-	write_cmos_sensor(0x380a, 0x02);
-	write_cmos_sensor(0x380b, 0x58);
-	write_cmos_sensor(0x380c, 0x06);
-	write_cmos_sensor(0x380d, 0xac);
-	write_cmos_sensor(0x380e, 0x02);
-	write_cmos_sensor(0x380f, 0x84);
-	write_cmos_sensor(0x3810, 0x00);
-	write_cmos_sensor(0x3811, 0x04);
-	write_cmos_sensor(0x3812, 0x00);
-	write_cmos_sensor(0x3813, 0x04);
-	write_cmos_sensor(0x3814, 0x31);
-	write_cmos_sensor(0x3815, 0x31);
-	write_cmos_sensor(0x3819, 0x04);
-	write_cmos_sensor(0x3820, 0xc4);
-	write_cmos_sensor(0x3821, 0x04);
-	write_cmos_sensor(0x4000, 0x81);
-	write_cmos_sensor(0x4001, 0x40);
-	write_cmos_sensor(0x4008, 0x00);
-	write_cmos_sensor(0x4009, 0x03);
-	write_cmos_sensor(0x4602, 0x02);
-	write_cmos_sensor(0x481f, 0x36);
-	write_cmos_sensor(0x4825, 0x36);
-	write_cmos_sensor(0x4837, 0x30);
-	write_cmos_sensor(0x5002, 0x30);
-	write_cmos_sensor(0x5080, 0x00);
-	write_cmos_sensor(0x5081, 0x41);
-
-	write_cmos_sensor(0x4800, 0x24); // disable LS/LE
-	
-	write_cmos_sensor(0x0100, 0x01);
-
-	mdelay(40);
-	//preview_setting();
-	
-}	/*	sensor_init  */
-
-
-
-
-static void capture_setting(kal_uint16 curretfps)
-{
-	LOG_INF("E! currefps:%d\n",curretfps);
-	preview_setting();
-}
-
-static void normal_video_setting(kal_uint16 currefps)
-{
-	LOG_INF("E! currefps:%d\n",currefps);
-	preview_setting();
-}
-static void hs_video_setting()
-{
-	LOG_INF("E\n");
-		
-	/*
-	 * @@Initial - MIPI 1-Lane 1280x720 10-bit 60fps
-	* 100 99 1280 720
-	*/
-	write_cmos_sensor(0x0100, 0x00);
-	write_cmos_sensor(0x3086, 0x00);
-	write_cmos_sensor(0x3501, 0x2d);
-	write_cmos_sensor(0x3502, 0x80);
-	write_cmos_sensor(0x3620, 0x26);
-	write_cmos_sensor(0x3621, 0x37);
-	write_cmos_sensor(0x3622, 0x04);
-	write_cmos_sensor(0x370a, 0x21);
-	write_cmos_sensor(0x370d, 0xc0);
-	write_cmos_sensor(0x3718, 0x88);
-	write_cmos_sensor(0x3721, 0x00);
-	write_cmos_sensor(0x3722, 0x00);
-	write_cmos_sensor(0x3723, 0x00);
-	write_cmos_sensor(0x3738, 0x00);
-	write_cmos_sensor(0x3801, 0xa0);
-	write_cmos_sensor(0x3803, 0xf2);
-	write_cmos_sensor(0x3804, 0x05);
-	write_cmos_sensor(0x3805, 0xaf);
-	write_cmos_sensor(0x3806, 0x03);
-	write_cmos_sensor(0x3807, 0xcd);
-	write_cmos_sensor(0x3808, 0x05);
-	write_cmos_sensor(0x3809, 0x00);
-	write_cmos_sensor(0x380a, 0x02);
-	write_cmos_sensor(0x380b, 0xd0);
-	write_cmos_sensor(0x380c, 0x05);
-	write_cmos_sensor(0x380d, 0xa6);
-	write_cmos_sensor(0x380e, 0x02);
-	write_cmos_sensor(0x380f, 0xf8);
-	write_cmos_sensor(0x3811, 0x08);
-	write_cmos_sensor(0x3813, 0x06);
-	write_cmos_sensor(0x3814, 0x11);
-	write_cmos_sensor(0x3815, 0x11);
-	write_cmos_sensor(0x3820, 0xc4);
-	write_cmos_sensor(0x3821, 0x04);
-	write_cmos_sensor(0x4008, 0x02);
-	write_cmos_sensor(0x4009, 0x09);
-	write_cmos_sensor(0x4837, 0x18);
-	write_cmos_sensor(0x0100, 0x01);
-	mdelay(60);
-}
-
-static void slim_video_setting()
-{
-	LOG_INF("E\n");
-	preview_setting();
-}
-
-
-/*************************************************************************
-* FUNCTION
-*	get_imgsensor_id
-*
-* DESCRIPTION
-*	This function get the sensor ID 
-*
-* PARAMETERS
-*	*sensorID : return the sensor ID 
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 get_imgsensor_id(UINT32 *sensor_id) 
-{
-	kal_uint8 i = 0;
-	kal_uint8 retry_total = 1;
-	kal_uint8 retry_cnt = retry_total;
-	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
-	while (imgsensor_info.i2c_addr_table[i] != 0xff) {
-		spin_lock(&imgsensor_drv_lock);
-		imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
-		spin_unlock(&imgsensor_drv_lock);
-		do {
-            *sensor_id = return_sensor_id();
-			if (*sensor_id == imgsensor_info.sensor_id) {				
-				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);	  
-				return ERROR_NONE;
-			}	
-            LOG_INF("Read sensor id fail, write id: 0x%x, id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
-			retry_cnt--;
-		} while(retry_cnt > 0);
-		i++;
-		retry_cnt = retry_total;
-	}
-	if (*sensor_id != imgsensor_info.sensor_id) {
-		// if Sensor ID is not correct, Must set *sensor_id to 0xFFFFFFFF 
-		*sensor_id = 0xFFFFFFFF;
-		return ERROR_SENSOR_CONNECT_FAIL;
-	}
-	return ERROR_NONE;
-}
-
-
-/*************************************************************************
-* FUNCTION
-*	open
-*
-* DESCRIPTION
-*	This function initialize the registers of CMOS sensor
-*
-* PARAMETERS
-*	None
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 open(void)
-{
-	//const kal_uint8 i2c_addr[] = {IMGSENSOR_WRITE_ID_1, IMGSENSOR_WRITE_ID_2};
-	kal_uint8 i = 0;
-	kal_uint8 retry = 2;
-    kal_uint32 sensor_id = 0;
-    LOG_1;
-    LOG_2;
-	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
-	while (imgsensor_info.i2c_addr_table[i] != 0xff) {
-		spin_lock(&imgsensor_drv_lock);
-		imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
-		spin_unlock(&imgsensor_drv_lock);
-		do {
-            sensor_id = return_sensor_id();
-			if (sensor_id == imgsensor_info.sensor_id) {				
-				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);	  
-				break;
-			}	
-            LOG_INF("Read sensor id fail, write id: 0x%x, id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
-			retry--;
-		} while(retry > 0);
-		i++;
-		if (sensor_id == imgsensor_info.sensor_id)
-			break;
-		retry = 2;
-	}		 
-	if (imgsensor_info.sensor_id != sensor_id)
-		return ERROR_SENSOR_CONNECT_FAIL;
-	
-	/* initail sequence write in  */
-	sensor_init();
-
-	spin_lock(&imgsensor_drv_lock);
-
-	imgsensor.autoflicker_en= KAL_FALSE;
-	imgsensor.sensor_mode = IMGSENSOR_MODE_INIT;
-	imgsensor.shutter = 0x3D0;
-	imgsensor.gain = 0x100;
-	imgsensor.pclk = imgsensor_info.pre.pclk;
-	imgsensor.frame_length = imgsensor_info.pre.framelength;
-	imgsensor.line_length = imgsensor_info.pre.linelength;
-	imgsensor.min_frame_length = imgsensor_info.pre.framelength;
-	imgsensor.dummy_pixel = 0;
-	imgsensor.dummy_line = 0;
-	imgsensor.ihdr_en = 0;
-	imgsensor.test_pattern = KAL_FALSE;
-	imgsensor.current_fps = imgsensor_info.pre.max_framerate;
-	spin_unlock(&imgsensor_drv_lock);
-
-	return ERROR_NONE;
-}	/*	open  */
-
-
-
-/*************************************************************************
-* FUNCTION
-*	close
-*
-* DESCRIPTION
-*	
-*
-* PARAMETERS
-*	None
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 close(void)
-{
-	LOG_INF("E\n");
-
-	/*No Need to implement this function*/ 
-	
-	return ERROR_NONE;
-}	/*	close  */
-
-
-/*************************************************************************
-* FUNCTION
-* preview
-*
-* DESCRIPTION
-*	This function start the sensor preview.
-*
-* PARAMETERS
-*	*image_window : address pointer of pixel numbers in one period of HSYNC
-*  *sensor_config_data : address pointer of line numbers in one period of VSYNC
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("E\n");
-
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.sensor_mode = IMGSENSOR_MODE_PREVIEW;
-	imgsensor.pclk = imgsensor_info.pre.pclk;
-	//imgsensor.video_mode = KAL_FALSE;
-	imgsensor.line_length = imgsensor_info.pre.linelength;
-	imgsensor.frame_length = imgsensor_info.pre.framelength; 
-	imgsensor.min_frame_length = imgsensor_info.pre.framelength;
-	imgsensor.autoflicker_en = KAL_FALSE;
-	spin_unlock(&imgsensor_drv_lock);
-	preview_setting();
-	return ERROR_NONE;
-}	/*	preview   */
-
-/*************************************************************************
-* FUNCTION
-*	capture
-*
-* DESCRIPTION
-*	This function setup the CMOS sensor in capture MY_OUTPUT mode
-*
-* PARAMETERS
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-						  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("E\n");
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.sensor_mode = IMGSENSOR_MODE_CAPTURE;
-    if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {//PIP capture: 24fps for less than 13M, 20fps for 16M,15fps for 20M
-        imgsensor.pclk = imgsensor_info.cap1.pclk;
-        imgsensor.line_length = imgsensor_info.cap1.linelength;
-        imgsensor.frame_length = imgsensor_info.cap1.framelength;
-        imgsensor.min_frame_length = imgsensor_info.cap1.framelength;
-        imgsensor.autoflicker_en = KAL_FALSE;
-    } else {
-        if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
-            LOG_INF("Warning: current_fps %d fps is not support, so use cap's setting: %d fps!\n",imgsensor.current_fps,imgsensor_info.cap.max_framerate/10);
-	imgsensor.pclk = imgsensor_info.cap.pclk;
-	imgsensor.line_length = imgsensor_info.cap.linelength;
-	imgsensor.frame_length = imgsensor_info.cap.framelength;  
-	imgsensor.min_frame_length = imgsensor_info.cap.framelength;
-	imgsensor.autoflicker_en = KAL_FALSE;
-    }
-	spin_unlock(&imgsensor_drv_lock);
-	capture_setting(imgsensor.current_fps);
-	mdelay(100);
-	return ERROR_NONE;
-}	/* capture() */
-static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("E\n");
-	
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.sensor_mode = IMGSENSOR_MODE_VIDEO;
-	imgsensor.pclk = imgsensor_info.normal_video.pclk;
-	imgsensor.line_length = imgsensor_info.normal_video.linelength;
-	imgsensor.frame_length = imgsensor_info.normal_video.framelength;  
-	imgsensor.min_frame_length = imgsensor_info.normal_video.framelength;
-	//imgsensor.current_fps = 300;
-	imgsensor.autoflicker_en = KAL_FALSE;
-	spin_unlock(&imgsensor_drv_lock);
-	normal_video_setting(imgsensor.current_fps);
-	return ERROR_NONE;
-}	/*	normal_video   */
-
-static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("E\n");
-	
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.sensor_mode = IMGSENSOR_MODE_HIGH_SPEED_VIDEO;
-	imgsensor.pclk = imgsensor_info.hs_video.pclk;
-	//imgsensor.video_mode = KAL_TRUE;
-	imgsensor.line_length = imgsensor_info.hs_video.linelength;
-	imgsensor.frame_length = imgsensor_info.hs_video.framelength; 
-	imgsensor.min_frame_length = imgsensor_info.hs_video.framelength;
-	imgsensor.dummy_line = 0;
-	imgsensor.dummy_pixel = 0;
-	//imgsensor.current_fps = 600;
-	imgsensor.autoflicker_en = KAL_FALSE;
-	spin_unlock(&imgsensor_drv_lock);
-	hs_video_setting();
-	
-	return ERROR_NONE;
-}	/*	hs_video   */
-
-static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("E\n");
-	
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.sensor_mode = IMGSENSOR_MODE_SLIM_VIDEO;
-	imgsensor.pclk = imgsensor_info.slim_video.pclk;
-	//imgsensor.video_mode = KAL_TRUE;
-	imgsensor.line_length = imgsensor_info.slim_video.linelength;
-	imgsensor.frame_length = imgsensor_info.slim_video.framelength; 
-	imgsensor.min_frame_length = imgsensor_info.slim_video.framelength;
-	imgsensor.dummy_line = 0;
-	imgsensor.dummy_pixel = 0;
-	//imgsensor.current_fps = 1200;
-	imgsensor.autoflicker_en = KAL_FALSE;
-	spin_unlock(&imgsensor_drv_lock);
-	slim_video_setting();
-	
-	return ERROR_NONE;
-}	/*	slim_video	 */
-
-
-
-static kal_uint32 get_resolution(MSDK_SENSOR_RESOLUTION_INFO_STRUCT *sensor_resolution)
-{
-	LOG_INF("E\n");
-	sensor_resolution->SensorFullWidth = imgsensor_info.cap.grabwindow_width;
-	sensor_resolution->SensorFullHeight = imgsensor_info.cap.grabwindow_height;
-	
-	sensor_resolution->SensorPreviewWidth = imgsensor_info.pre.grabwindow_width;
-	sensor_resolution->SensorPreviewHeight = imgsensor_info.pre.grabwindow_height;
-
-	sensor_resolution->SensorVideoWidth = imgsensor_info.normal_video.grabwindow_width;
-	sensor_resolution->SensorVideoHeight = imgsensor_info.normal_video.grabwindow_height;		
-
-	
-	sensor_resolution->SensorHighSpeedVideoWidth	 = imgsensor_info.hs_video.grabwindow_width;
-	sensor_resolution->SensorHighSpeedVideoHeight	 = imgsensor_info.hs_video.grabwindow_height;
-	
-	sensor_resolution->SensorSlimVideoWidth	 = imgsensor_info.slim_video.grabwindow_width;
-	sensor_resolution->SensorSlimVideoHeight	 = imgsensor_info.slim_video.grabwindow_height;
-	return ERROR_NONE;
-}	/*	get_resolution	*/
-
-static kal_uint32 get_info(MSDK_SCENARIO_ID_ENUM scenario_id,
-					  MSDK_SENSOR_INFO_STRUCT *sensor_info,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("scenario_id = %d\n", scenario_id);
-
-	
-	//sensor_info->SensorVideoFrameRate = imgsensor_info.normal_video.max_framerate/10; /* not use */
-	//sensor_info->SensorStillCaptureFrameRate= imgsensor_info.cap.max_framerate/10; /* not use */
-	//imgsensor_info->SensorWebCamCaptureFrameRate= imgsensor_info.v.max_framerate; /* not use */
-
-	sensor_info->SensorClockPolarity = SENSOR_CLOCK_POLARITY_LOW;
-	sensor_info->SensorClockFallingPolarity = SENSOR_CLOCK_POLARITY_LOW; /* not use */
-	sensor_info->SensorHsyncPolarity = SENSOR_CLOCK_POLARITY_LOW; // inverse with datasheet
-	sensor_info->SensorVsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
-	sensor_info->SensorInterruptDelayLines = 4; /* not use */
-	sensor_info->SensorResetActiveHigh = FALSE; /* not use */
-	sensor_info->SensorResetDelayCount = 5; /* not use */
-
-	sensor_info->SensroInterfaceType = imgsensor_info.sensor_interface_type;
-    sensor_info->MIPIsensorType = imgsensor_info.mipi_sensor_type;
-    sensor_info->SettleDelayMode = imgsensor_info.mipi_settle_delay_mode;
-
-	sensor_info->SensorOutputDataFormat = imgsensor_info.sensor_output_dataformat;
-
-	sensor_info->CaptureDelayFrame = imgsensor_info.cap_delay_frame; 
-	sensor_info->PreviewDelayFrame = imgsensor_info.pre_delay_frame; 
-	sensor_info->VideoDelayFrame = imgsensor_info.video_delay_frame;
-	sensor_info->HighSpeedVideoDelayFrame = imgsensor_info.hs_video_delay_frame;
-	sensor_info->SlimVideoDelayFrame = imgsensor_info.slim_video_delay_frame;
-
-	sensor_info->SensorMasterClockSwitch = 0; /* not use */
-	sensor_info->SensorDrivingCurrent = imgsensor_info.isp_driving_current;
-	
-	sensor_info->AEShutDelayFrame = imgsensor_info.ae_shut_delay_frame; 		 /* The frame of setting shutter default 0 for TG int */
-	sensor_info->AESensorGainDelayFrame = imgsensor_info.ae_sensor_gain_delay_frame;	/* The frame of setting sensor gain */
-	sensor_info->AEISPGainDelayFrame = imgsensor_info.ae_ispGain_delay_frame;	
-	sensor_info->IHDR_Support = imgsensor_info.ihdr_support;
-	sensor_info->IHDR_LE_FirstLine = imgsensor_info.ihdr_le_firstline;
-	sensor_info->SensorModeNum = imgsensor_info.sensor_mode_num;
-	
-	sensor_info->SensorMIPILaneNumber = imgsensor_info.mipi_lane_num; 
-	sensor_info->SensorClockFreq = imgsensor_info.mclk;
-	sensor_info->SensorClockDividCount = 3; /* not use */
-	sensor_info->SensorClockRisingCount = 0;
-	sensor_info->SensorClockFallingCount = 2; /* not use */
-	sensor_info->SensorPixelClockCount = 3; /* not use */
-	sensor_info->SensorDataLatchCount = 2; /* not use */
-	
-	sensor_info->MIPIDataLowPwr2HighSpeedTermDelayCount = 0; 
-	sensor_info->MIPICLKLowPwr2HighSpeedTermDelayCount = 0;
-	sensor_info->SensorWidthSampling = 0;  // 0 is default 1x
-	sensor_info->SensorHightSampling = 0;	// 0 is default 1x 
-	sensor_info->SensorPacketECCOrder = 1;
-
-	switch (scenario_id) {
-		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-			sensor_info->SensorGrabStartX = imgsensor_info.pre.startx; 
-			sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;		
-			
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
-			
-			break;
-		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
-			sensor_info->SensorGrabStartX = imgsensor_info.cap.startx; 
-			sensor_info->SensorGrabStartY = imgsensor_info.cap.starty;
-				  
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.cap.mipi_data_lp2hs_settle_dc; 
-
-			break;	 
-		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-			
-			sensor_info->SensorGrabStartX = imgsensor_info.normal_video.startx; 
-			sensor_info->SensorGrabStartY = imgsensor_info.normal_video.starty;
-	   
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.normal_video.mipi_data_lp2hs_settle_dc; 
-
-			break;	  
-		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:			
-			sensor_info->SensorGrabStartX = imgsensor_info.hs_video.startx; 
-			sensor_info->SensorGrabStartY = imgsensor_info.hs_video.starty;
-				  
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.hs_video.mipi_data_lp2hs_settle_dc; 
-
-			break;
-		case MSDK_SCENARIO_ID_SLIM_VIDEO:
-			sensor_info->SensorGrabStartX = imgsensor_info.slim_video.startx; 
-			sensor_info->SensorGrabStartY = imgsensor_info.slim_video.starty;
-				  
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.slim_video.mipi_data_lp2hs_settle_dc; 
-
-			break;
-		default:			
-			sensor_info->SensorGrabStartX = imgsensor_info.pre.startx; 
-			sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;		
-			
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
-			break;
-	}
-	
-	return ERROR_NONE;
-}	/*	get_info  */
-
-
-static kal_uint32 control(MSDK_SCENARIO_ID_ENUM scenario_id, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("scenario_id = %d\n", scenario_id);
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.current_scenario_id = scenario_id;
-	spin_unlock(&imgsensor_drv_lock);
-	switch (scenario_id) {
-		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-			preview(image_window, sensor_config_data);
-			break;
-		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
-			capture(image_window, sensor_config_data);
-			break;	
-		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-			normal_video(image_window, sensor_config_data);
-			break;	  
-		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
-			hs_video(image_window, sensor_config_data);
-			break;
-		case MSDK_SCENARIO_ID_SLIM_VIDEO:
-			slim_video(image_window, sensor_config_data);
-			break;	  
-		default:
-			LOG_INF("Error ScenarioId setting");
-			preview(image_window, sensor_config_data);
-			return ERROR_INVALID_SCENARIO_ID;
-	}
-	return ERROR_NONE;
-}	/* control() */
-
-
-
-static kal_uint32 set_video_mode(UINT16 framerate)
-{
-	LOG_INF("framerate = %d\n ", framerate);
-	// SetVideoMode Function should fix framerate
-	if (framerate == 0)
-		// Dynamic frame rate
-		return ERROR_NONE;
-	spin_lock(&imgsensor_drv_lock);
-	if ((framerate == 300) && (imgsensor.autoflicker_en == KAL_TRUE))
-		imgsensor.current_fps = 296;
-	else if ((framerate == 150) && (imgsensor.autoflicker_en == KAL_TRUE))
-		imgsensor.current_fps = 146;
-	else
-		imgsensor.current_fps = framerate;
-	spin_unlock(&imgsensor_drv_lock);
-	set_max_framerate(imgsensor.current_fps,1);
-
-	return ERROR_NONE;
-}
-
-static kal_uint32 set_auto_flicker_mode(kal_bool enable, UINT16 framerate)
-{
-	LOG_INF("enable = %d, framerate = %d \n", enable, framerate);
-	spin_lock(&imgsensor_drv_lock);
-	if (enable) //enable auto flicker	  
-		imgsensor.autoflicker_en = KAL_TRUE;
-	else //Cancel Auto flick
-		imgsensor.autoflicker_en = KAL_FALSE;
-	spin_unlock(&imgsensor_drv_lock);
-	return ERROR_NONE;
-}
-
-static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 framerate) 
-{
-	kal_uint32 frame_length;
-  
-	LOG_INF("scenario_id = %d, framerate = %d\n", scenario_id, framerate);
-
-	switch (scenario_id) {
-		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-			frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
-			imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();			
-			break;			
-		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-			if(framerate == 0)
-				return ERROR_NONE;
-			frame_length = imgsensor_info.normal_video.pclk / framerate * 10 / imgsensor_info.normal_video.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.normal_video.framelength) ? (frame_length - imgsensor_info.normal_video.framelength) : 0;			
-			imgsensor.frame_length = imgsensor_info.normal_video.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();			
-			break;
-		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:		
-        	  if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {
-                frame_length = imgsensor_info.cap1.pclk / framerate * 10 / imgsensor_info.cap1.linelength;
-                spin_lock(&imgsensor_drv_lock);
-		            imgsensor.dummy_line = (frame_length > imgsensor_info.cap1.framelength) ? (frame_length - imgsensor_info.cap1.framelength) : 0;
-		            imgsensor.frame_length = imgsensor_info.cap1.framelength + imgsensor.dummy_line;
-		            imgsensor.min_frame_length = imgsensor.frame_length;
-		            spin_unlock(&imgsensor_drv_lock);
-            } else {
-        		    if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
-                    LOG_INF("Warning: current_fps %d fps is not support, so use cap's setting: %d fps!\n",framerate,imgsensor_info.cap.max_framerate/10);
-			frame_length = imgsensor_info.cap.pclk / framerate * 10 / imgsensor_info.cap.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.cap.framelength) ? (frame_length - imgsensor_info.cap.framelength) : 0;
-			imgsensor.frame_length = imgsensor_info.cap.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-            }
-			set_dummy();			
-			break;	
-		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
-			frame_length = imgsensor_info.hs_video.pclk / framerate * 10 / imgsensor_info.hs_video.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.hs_video.framelength) ? (frame_length - imgsensor_info.hs_video.framelength) : 0;
-			imgsensor.frame_length = imgsensor_info.hs_video.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();			
-			break;
-		case MSDK_SCENARIO_ID_SLIM_VIDEO:
-			frame_length = imgsensor_info.slim_video.pclk / framerate * 10 / imgsensor_info.slim_video.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.slim_video.framelength) ? (frame_length - imgsensor_info.slim_video.framelength): 0;	
-			imgsensor.frame_length = imgsensor_info.slim_video.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();	
-			break;		
-		default:  //coding with  preview scenario by default
-			frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
-			imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();	
-			LOG_INF("error scenario_id = %d, we use preview scenario \n", scenario_id);
-			break;
-	}	
-	return ERROR_NONE;
-}
-
-
-static kal_uint32 get_default_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 *framerate) 
-{
-	LOG_INF("scenario_id = %d\n", scenario_id);
-
-	switch (scenario_id) {
-		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-			*framerate = imgsensor_info.pre.max_framerate;
-			break;
-		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-			*framerate = imgsensor_info.normal_video.max_framerate;
-			break;
-		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
-			*framerate = imgsensor_info.cap.max_framerate;
-			break;		
-		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
-			*framerate = imgsensor_info.hs_video.max_framerate;
-			break;
-		case MSDK_SCENARIO_ID_SLIM_VIDEO: 
-			*framerate = imgsensor_info.slim_video.max_framerate;
-			break;
-		default:
-			break;
-	}
-
-	return ERROR_NONE;
-}
-
-static kal_uint32 set_test_pattern_mode(kal_bool enable)
-{
-	LOG_INF("enable: %d\n", enable);
-
-	if (enable) {
-		// 0x5080[8]: 1 enable,  0 disable
-		// 0x5080[1:0]; 00 Color bar, 01 Random Data, 10 Square, 11 BLACK
-		write_cmos_sensor(0x5080, 0x80);
-	} else {
-		// 0x5080[8]: 1 enable,  0 disable
-		// 0x5080[1:0]; 00 Color bar, 01 Random Data, 10 Square, 11 BLACK
-		write_cmos_sensor(0x5080, 0x00);
-	}	 
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.test_pattern = enable;
-	spin_unlock(&imgsensor_drv_lock);
-	return ERROR_NONE;
-}
-
-static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
-							 UINT8 *feature_para,UINT32 *feature_para_len)
-{
-	UINT16 *feature_return_para_16=(UINT16 *) feature_para;
-	UINT16 *feature_data_16=(UINT16 *) feature_para;
-	UINT32 *feature_return_para_32=(UINT32 *) feature_para;
-	UINT32 *feature_data_32=(UINT32 *) feature_para;
-	unsigned long long *feature_data=(unsigned long long *) feature_para;
-    unsigned long long *feature_return_para=(unsigned long long *) feature_para;
-
-	SENSOR_WINSIZE_INFO_STRUCT *wininfo;	
-	MSDK_SENSOR_REG_INFO_STRUCT *sensor_reg_data=(MSDK_SENSOR_REG_INFO_STRUCT *) feature_para;
- 
-	LOG_INF("feature_id = %d\n", feature_id);
-	switch (feature_id) {
-		case SENSOR_FEATURE_GET_PERIOD:
-			*feature_return_para_16++ = imgsensor.line_length;
-			*feature_return_para_16 = imgsensor.frame_length;
-			*feature_para_len=4;
-			break;
-		case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:	 
-			*feature_return_para_32 = imgsensor.pclk;
-			*feature_para_len=4;
-			break;		   
-		case SENSOR_FEATURE_SET_ESHUTTER:
-			set_shutter(*feature_data);
-			break;
-		case SENSOR_FEATURE_SET_NIGHTMODE:
-			night_mode((BOOL) *feature_data);
-			break;
-		case SENSOR_FEATURE_SET_GAIN:		
-			set_gain((UINT16) *feature_data);
-			break;
-		case SENSOR_FEATURE_SET_FLASHLIGHT:
-			break;
-		case SENSOR_FEATURE_SET_ISP_MASTER_CLOCK_FREQ:
-			break;
-		case SENSOR_FEATURE_SET_REGISTER:
-			write_cmos_sensor(sensor_reg_data->RegAddr, sensor_reg_data->RegData);
-			break;
-		case SENSOR_FEATURE_GET_REGISTER:
-			sensor_reg_data->RegData = read_cmos_sensor(sensor_reg_data->RegAddr);
-			break;
-		case SENSOR_FEATURE_GET_LENS_DRIVER_ID:
-			// get the lens driver ID from EEPROM or just return LENS_DRIVER_ID_DO_NOT_CARE
-			// if EEPROM does not exist in camera module.
-			*feature_return_para_32=LENS_DRIVER_ID_DO_NOT_CARE;
-			*feature_para_len=4;
-			break;
-		case SENSOR_FEATURE_SET_VIDEO_MODE:
-			set_video_mode(*feature_data);
-			break; 
-		case SENSOR_FEATURE_CHECK_SENSOR_ID:
-			get_imgsensor_id(feature_return_para_32); 
-			break; 
-		case SENSOR_FEATURE_SET_AUTO_FLICKER_MODE:
-			set_auto_flicker_mode((BOOL)*feature_data_16,*(feature_data_16+1));
-			break;
-		case SENSOR_FEATURE_SET_MAX_FRAME_RATE_BY_SCENARIO:
-			set_max_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data, *(feature_data+1));
-			break;
-		case SENSOR_FEATURE_GET_DEFAULT_FRAME_RATE_BY_SCENARIO:
-			get_default_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data, (MUINT32 *)(uintptr_t)(*(feature_data+1)));
-			break;
-		case SENSOR_FEATURE_SET_TEST_PATTERN:
-			set_test_pattern_mode((BOOL)*feature_data);
-			break;
-		case SENSOR_FEATURE_GET_TEST_PATTERN_CHECKSUM_VALUE: //for factory mode auto testing			 
-			*feature_return_para_32 = imgsensor_info.checksum_value;
-			*feature_para_len=4;							 
-			break;				
-		case SENSOR_FEATURE_SET_FRAMERATE:
-			LOG_INF("current fps :%d\n",  (UINT32)*feature_data);
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.current_fps = *feature_data;
-			spin_unlock(&imgsensor_drv_lock);		
-			break;
-		case SENSOR_FEATURE_SET_HDR:
-			LOG_INF("ihdr enable :%d\n", (BOOL)*feature_data);
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.ihdr_en = (bool)*feature_data;
-			spin_unlock(&imgsensor_drv_lock);		
-			break;
-		case SENSOR_FEATURE_GET_CROP_INFO:
-			LOG_INF("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n", (UINT32)*feature_data);
-			wininfo = (SENSOR_WINSIZE_INFO_STRUCT *)(uintptr_t)(*(feature_data+1));
-		
-			switch (*feature_data_32) {
-				case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
-					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[1],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-					break;	  
-				case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[2],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-					break;
-				case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
-					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[3],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-					break;
-				case MSDK_SCENARIO_ID_SLIM_VIDEO:
-					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[4],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-					break;
-				case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-				default:
-					memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[0],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-					break;
-			}
-		case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
-			LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",(UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2)); 
-			ihdr_write_shutter_gain((UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));	
-			break;
-		default:
-			break;
-	}
-  
-	return ERROR_NONE;
-}	/*	feature_control()  */
-
-static SENSOR_FUNCTION_STRUCT sensor_func = {
-	open,
-	get_info,
-	get_resolution,
-	feature_control,
-	control,
-	close
-};
-
-/*UINT32 OV2680_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)*/
-UINT32 OV2680MIPISensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
-
-{
-	/* To Do : Check Sensor status here */
-	if (pfFunc!=NULL)
-		*pfFunc=&sensor_func;
-	return ERROR_NONE;
-}	/*	OV2680_MIPI_RAW_SensorInit	*/
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/ov5648_mipi_raw/ov5648mipi_Sensor.c~ b/drivers/misc/mediatek/imgsensor/src/mt6735m/ov5648_mipi_raw/ov5648mipi_Sensor.c~
deleted file mode 100755
index 0738f98..0000000
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/ov5648_mipi_raw/ov5648mipi_Sensor.c~
+++ /dev/null
@@ -1,1818 +0,0 @@
-/*****************************************************************************
- *
- * Filename:
- * ---------
- *     OV5648mipi_Sensor.c
- *
- * Project:
- * --------
- *     ALPS
- *
- * Description:
- * ------------
- *     Source code of Sensor driver
- *
- *
- *------------------------------------------------------------------------------
- * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
- *============================================================================
- ****************************************************************************/
-
-#include <linux/videodev2.h>
-#include <linux/i2c.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/cdev.h>
-#include <linux/uaccess.h>
-#include <linux/fs.h>
-#include <asm/atomic.h>
-//#include <asm/system.h>
-#include <linux/xlog.h>
-
-#include "kd_camera_hw.h"
-#include "kd_imgsensor.h"
-#include "kd_imgsensor_define.h"
-#include "kd_imgsensor_errcode.h"
-
-#include "ov5648mipi_Sensor.h"
-
-/****************************Modify Following Strings for Debug****************************/
-#define PFX "OV5648_camera_sensor"
-#define LOG_1 LOG_INF("OV5648,MIPI 2LANE\n")
-#define LOG_2 LOG_INF("preview 1280*960@30fps,420Mbps/lane; video 1280*960@30fps,420Mbps/lane; capture 5M@15fps,420Mbps/lane\n")
-/****************************   Modify end    *******************************************/
-
-#define LOG_INF(format, args...)    pr_debug(PFX "[%s] " format, __FUNCTION__, ##args)
-
-static DEFINE_SPINLOCK(imgsensor_drv_lock);
-
-
-static imgsensor_info_struct imgsensor_info = {
-    .sensor_id = OV5648MIPI_SENSOR_ID,
-
-    .checksum_value = 0xf7375923,        //checksum value for Camera Auto Test
-
-    .pre = {
-        .pclk = 84000000,            //record different mode's pclk
-        .linelength = 2816,            //record different mode's linelength
-        .framelength = 992,            //record different mode's framelength
-        .startx = 2,                    //record different mode's startx of grabwindow
-        .starty = 2,                    //record different mode's starty of grabwindow
-        .grabwindow_width = 1280,        //record different mode's width of grabwindow
-        .grabwindow_height = 960,        //record different mode's height of grabwindow
-        /*     following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario    */
-        .mipi_data_lp2hs_settle_dc = 85,//unit , ns
-        /*     following for GetDefaultFramerateByScenario()    */
-        .max_framerate = 300,
-    },
-    .cap = {
-        .pclk = 84000000,
-        .linelength = 2816,
-        .framelength = 1984,
-        .startx = 2,
-        .starty = 6,
-        .grabwindow_width = 2560,
-        .grabwindow_height = 1920,
-        .mipi_data_lp2hs_settle_dc = 85,//unit , ns
-        .max_framerate = 150,
-    },
-    .cap1 = {
-        .pclk = 84000000,
-        .linelength = 2816,
-        .framelength = 1984,
-        .startx = 2,
-        .starty = 2,
-        .grabwindow_width = 2560,
-        .grabwindow_height = 1920,
-        .mipi_data_lp2hs_settle_dc = 85,//unit , ns
-        .max_framerate = 150,
-    },
-    .normal_video = {
-        .pclk = 84000000,
-        .linelength = 2816,
-        .framelength = 992,
-        .startx = 2,
-        .starty = 2,
-        .grabwindow_width = 1280,
-        .grabwindow_height = 960,
-        .mipi_data_lp2hs_settle_dc = 85,//unit , ns
-        .max_framerate = 300,
-    },
-    .hs_video = {
-        .pclk = 84000000,
-        .linelength = 2500,
-        .framelength = 1120,
-        .startx = 0,
-        .starty = 0,
-        .grabwindow_width = 1920,
-        .grabwindow_height = 1080,
-        .mipi_data_lp2hs_settle_dc = 85,//unit , ns
-        .max_framerate = 300,
-    },
-    .slim_video = {
-        .pclk = 84000000,
-        .linelength = 3728,
-        .framelength = 748,
-        .startx = 0,
-        .starty = 0,
-        .grabwindow_width = 1280,
-        .grabwindow_height = 720,
-        .mipi_data_lp2hs_settle_dc = 85,//unit , ns
-        .max_framerate = 300,
-    },
-    .margin = 4,            //sensor framelength & shutter margin
-    .min_shutter = 1,        //min shutter
-    .max_frame_length = 0x7fff,//max framelength by sensor register's limitation
-    .ae_shut_delay_frame = 0,    //shutter delay frame for AE cycle, 2 frame with ispGain_delay-shut_delay=2-0=2
-    .ae_sensor_gain_delay_frame = 0,//sensor gain delay frame for AE cycle,2 frame with ispGain_delay-sensor_gain_delay=2-0=2
-    .ae_ispGain_delay_frame = 2,//isp gain delay frame for AE cycle
-    .ihdr_support = 0,      //1, support; 0,not support
-    .ihdr_le_firstline = 0,  //1,le first ; 0, se first
-    .sensor_mode_num = 5,      //support sensor mode num
-
-    .cap_delay_frame = 2,
-    .pre_delay_frame = 2,
-    .video_delay_frame = 2,
-    .hs_video_delay_frame = 2,
-    .slim_video_delay_frame = 2,
-
-    .isp_driving_current = ISP_DRIVING_2MA, //mclk driving current
-    .sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,//sensor_interface_type
-    .mipi_sensor_type = MIPI_OPHY_NCSI2, //0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2
-    .mipi_settle_delay_mode = MIPI_SETTLEDELAY_AUTO,//0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANNUAL
-    .sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_B,//sensor output first pixel color
-    .mclk = 24,//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
-    .mipi_lane_num = SENSOR_MIPI_2_LANE,//mipi lane num
-    .i2c_addr_table = {0x6c, 0xff},
-    .i2c_speed = 200,
-};
-
-
-static imgsensor_struct imgsensor = {
-    .mirror = IMAGE_HV_MIRROR,//IMAGE_NORMAL,                //mirrorflip information
-    .sensor_mode = IMGSENSOR_MODE_INIT, //IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
-    .shutter = 0x3D0,                    //current shutter
-    .gain = 0x100,                        //current gain
-    .dummy_pixel = 0,                    //current dummypixel
-    .dummy_line = 0,                    //current dummyline
-    .current_fps = 300,  //full size current fps : 24fps for PIP, 30fps for Normal or ZSD
-    .autoflicker_en = KAL_FALSE,  //auto flicker enable: KAL_FALSE for disable auto flicker, KAL_TRUE for enable auto flicker
-    .test_pattern = KAL_FALSE,        //test pattern mode or not. KAL_FALSE for in test pattern mode, KAL_TRUE for normal output
-    .current_scenario_id = MSDK_SCENARIO_ID_CAMERA_PREVIEW,//current scenario id
-    .ihdr_en = 0, //sensor need support LE, SE with HDR feature
-    .i2c_write_id = 0x6c,//record current sensor's i2c write id
-};
-
-
-/* Sensor output window information */
-static SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[5]=
-{{ 2624, 1956,      0,    0, 2624, 1956, 1312,  978,      8,   4, 1296,  972,  4,    8, 1280,  960},  // Preview
- { 2624, 1956,      0,    0, 2624, 1956, 2624, 1956,     16,   6, 2592, 1944,  2,    2, 2560,  1920}, // capture
- { 2624, 1956,      0,    0, 2624, 1956, 2592, 1944,      0,   0, 1296,  972,  4,    8, 1280,  960},  // video
- { 2624, 1956,    336,  434, 1952, 1088, 1952, 1088,     16,   4, 1920, 1080,  0,    0, 1920,  1080}, //hight speed video
- { 2624, 1956,     16,  254, 2592, 1448, 1296,  724,      8,   2, 1280,  720,  0,    0, 1280,  720}}; // slim video
-
-
-static kal_uint16 read_cmos_sensor(kal_uint32 addr)
-{
-    kal_uint16 get_byte=0;
-	char pu_send_cmd[2] = {(char)(addr >> 8), (char)(addr & 0xFF) };
-
-	kdSetI2CSpeed(imgsensor_info.i2c_speed); // Add this func to set i2c speed by each sensor
-
-    iReadRegI2C(pu_send_cmd, 2, (u8*)&get_byte, 1, imgsensor.i2c_write_id);
-
-    return get_byte;
-}
-
-static void write_cmos_sensor(kal_uint32 addr, kal_uint32 para)
-{
-    char pu_send_cmd[3] = {(char)(addr >> 8), (char)(addr & 0xFF), (char)(para & 0xFF)};
-
-	kdSetI2CSpeed(imgsensor_info.i2c_speed); // Add this func to set i2c speed by each sensor
-
-    iWriteRegI2C(pu_send_cmd, 3, imgsensor.i2c_write_id);
-}
-
-static void set_dummy(void)
-{
-    LOG_INF("dummyline = %d, dummypixels = %d \n", imgsensor.dummy_line, imgsensor.dummy_pixel);
-    /* you can set dummy by imgsensor.dummy_line and imgsensor.dummy_pixel, or you can set dummy by imgsensor.frame_length and imgsensor.line_length */
-    write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
-    write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
-    write_cmos_sensor(0x380c, imgsensor.line_length >> 8);
-    write_cmos_sensor(0x380d, imgsensor.line_length & 0xFF);
-
-}    /*    set_dummy  */
-
-static kal_uint32 return_sensor_id(void)
-{
-    return ((read_cmos_sensor(0x300A) << 8) | read_cmos_sensor(0x300B));
-}
-static void set_max_framerate(UINT16 framerate,kal_bool min_framelength_en)
-{
-    kal_uint32 frame_length = imgsensor.frame_length;
-
-    LOG_INF("framerate = %d, min framelength should enable = %d\n", framerate,min_framelength_en);
-
-    frame_length = imgsensor.pclk / framerate * 10 / imgsensor.line_length;
-
-    spin_lock(&imgsensor_drv_lock);
-    imgsensor.frame_length = (frame_length > imgsensor.min_frame_length) ? frame_length : imgsensor.min_frame_length;
-    imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
-    //dummy_line = frame_length - imgsensor.min_frame_length;
-    //if (dummy_line < 0)
-        //imgsensor.dummy_line = 0;
-    //else
-        //imgsensor.dummy_line = dummy_line;
-    //imgsensor.frame_length = frame_length + imgsensor.dummy_line;
-    if (imgsensor.frame_length > imgsensor_info.max_frame_length)
-    {
-        imgsensor.frame_length = imgsensor_info.max_frame_length;
-        imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
-    }
-    if (min_framelength_en)
-        imgsensor.min_frame_length = imgsensor.frame_length;
-    spin_unlock(&imgsensor_drv_lock);
-
-    set_dummy();
-}    /*    set_max_framerate  */
-
-static void write_shutter(kal_uint16 shutter)
-{
-    kal_uint16 realtime_fps = 0;
-
-    /* 0x3500, 0x3501, 0x3502 will increase VBLANK to get exposure larger than frame exposure */
-    /* AE doesn't update sensor gain at capture mode, thus extra exposure lines must be updated here. */
-
-    // OV Recommend Solution
-    // if shutter bigger than frame_length, should extend frame length first
-    spin_lock(&imgsensor_drv_lock);
-    if (shutter > imgsensor.min_frame_length - imgsensor_info.margin)
-        imgsensor.frame_length = shutter + imgsensor_info.margin;
-    else
-        imgsensor.frame_length = imgsensor.min_frame_length;
-    if (imgsensor.frame_length > imgsensor_info.max_frame_length)
-        imgsensor.frame_length = imgsensor_info.max_frame_length;
-    spin_unlock(&imgsensor_drv_lock);
-    shutter = (shutter < imgsensor_info.min_shutter) ? imgsensor_info.min_shutter : shutter;
-    shutter = (shutter > (imgsensor_info.max_frame_length - imgsensor_info.margin)) ? (imgsensor_info.max_frame_length - imgsensor_info.margin) : shutter;
-
-    // Framelength should be an even number
-    shutter = (shutter >> 1) << 1;
-    imgsensor.frame_length = (imgsensor.frame_length >> 1) << 1;
-
-    if (imgsensor.autoflicker_en) {
-        realtime_fps = imgsensor.pclk / imgsensor.line_length * 10 / imgsensor.frame_length;
-
-        if(realtime_fps >= 297 && realtime_fps <= 305)
-            set_max_framerate(296,0);
-        else if(realtime_fps >= 147 && realtime_fps <= 150)
-            set_max_framerate(146,0);
-        else {
-            // Extend frame length
-            write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
-            write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
-        }
-    } else {
-        // Extend frame length
-        write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
-        write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
-    }
-
-    // Update Shutter
-    write_cmos_sensor(0x3502, (shutter << 4) & 0xFF);
-    write_cmos_sensor(0x3501, (shutter >> 4) & 0xFF);
-    write_cmos_sensor(0x3500, (shutter >> 12) & 0x0F);
-
-    LOG_INF("shutter =%d, framelength =%d\n", shutter, imgsensor.frame_length);
-}
-
-
-/*************************************************************************
-* FUNCTION
-*    set_shutter
-*
-* DESCRIPTION
-*    This function set e-shutter of sensor to change exposure time.
-*
-* PARAMETERS
-*    iShutter : exposured lines
-*
-* RETURNS
-*    None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static void set_shutter(kal_uint16 shutter)
-{
-    unsigned long flags;
-    spin_lock_irqsave(&imgsensor_drv_lock, flags);
-    imgsensor.shutter = shutter;
-    spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
-
-    write_shutter(shutter);
-}
-
-static kal_uint16 gain2reg(const kal_uint16 gain)
-{
-    kal_uint16 reg_gain = 0x0000;
-
-    reg_gain = ((gain / BASEGAIN) << 4) + ((gain % BASEGAIN) * 16 / BASEGAIN);
-    reg_gain = reg_gain & 0xFFFF;
-
-    return (kal_uint16)reg_gain;
-}
-
-/*************************************************************************
-* FUNCTION
-*    set_gain
-*
-* DESCRIPTION
-*    This function is to set global gain to sensor.
-*
-* PARAMETERS
-*    iGain : sensor global gain(base: 0x40)
-*
-* RETURNS
-*    the actually gain set to sensor.
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint16 set_gain(kal_uint16 gain)
-{
-    kal_uint16 reg_gain;
-
-    /* 0x350A[0:1], 0x350B[0:7] AGC real gain */
-    /* [0:3] = N meams N /16 X    */
-    /* [4:9] = M meams M X         */
-    /* Total gain = M + N /16 X   */
-
-    //
-    if (gain < BASEGAIN || gain > 32 * BASEGAIN) {
-        LOG_INF("Error gain setting");
-
-        if (gain < BASEGAIN)
-            gain = BASEGAIN;
-        else if (gain > 32 * BASEGAIN)
-            gain = 32 * BASEGAIN;
-    }
-
-    reg_gain = gain2reg(gain);
-    spin_lock(&imgsensor_drv_lock);
-    imgsensor.gain = reg_gain;
-    spin_unlock(&imgsensor_drv_lock);
-    LOG_INF("gain = %d , reg_gain = 0x%x\n ", gain, reg_gain);
-
-    write_cmos_sensor(0x350a, reg_gain >> 8);
-    write_cmos_sensor(0x350b, reg_gain & 0xFF);
-
-    return gain;
-}    /*    set_gain  */
-
-static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gain)
-{
-    //not support HDR
-    //LOG_INF("le:0x%x, se:0x%x, gain:0x%x\n",le,se,gain);
-}
-
-#if 1
-static void set_mirror_flip(kal_uint8 image_mirror)
-{
-    LOG_INF("image_mirror = %d\n", image_mirror);
-
-    /********************************************************
-       *
-       *   0x3820[2] ISP Vertical flip
-       *   0x3820[1] Sensor Vertical flip
-       *
-       *   0x3821[2] ISP Horizontal mirror
-       *   0x3821[1] Sensor Horizontal mirror
-       *
-       *   ISP and Sensor flip or mirror register bit should be the same!!
-       *
-       ********************************************************/
-
-    switch (image_mirror) {
-        case IMAGE_NORMAL:
-            write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x00));
-            write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x06));
-            break;
-        case IMAGE_H_MIRROR:
-            write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x00));
-            write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x00));
-            break;
-        case IMAGE_V_MIRROR:
-            write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x06));
-            write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x06));
-            break;
-        case IMAGE_HV_MIRROR:
-            write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x06));
-            write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x00));
-            break;
-        default:
-            LOG_INF("Error image_mirror setting\n");
-    }
-
-}
-#endif
-
-/*************************************************************************
-* FUNCTION
-*    night_mode
-*
-* DESCRIPTION
-*    This function night mode of sensor.
-*
-* PARAMETERS
-*    bEnable: KAL_TRUE -> enable night mode, otherwise, disable night mode
-*
-* RETURNS
-*    None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static void night_mode(kal_bool enable)
-{
-/*No Need to implement this function*/
-}    /*    night_mode    */
-
-static void sensor_init(void)
-{
-    LOG_INF("E\n");
-    /*****************************************************************************
-    0x3037    SC_CMMN_PLL_CTR13
-        SC_CMMN_PLL_CTR13[4] pll_root_div 0: bypass 1: /2
-        SC_CMMN_PLL_CTR13[3:0] pll_prediv 1, 2, 3, 4, 6, 8
-
-    0x3036    SC_CMMN_PLL_MULTIPLIER
-        SC_CMMN_PLL_MULTIPLIER[7:0] PLL_multiplier(4~252) This can be any integer during 4~127 and only even integer during 128 ~ 252
-
-    0x3035    SC_CMMN_PLL_CTR1
-        SC_CMMN_PLL_CTR1[7:4] system_pll_div
-        SC_CMMN_PLL_CTR1[3:0] scale_divider_mipi
-
-    0x3034    SC_CMMN_PLL_CTR0
-        SC_CMMN_PLL_CTR0[6:4] pll_charge_pump
-        SC_CMMN_PLL_CTR0[3:0] mipi_bit_mode
-
-    0x3106    SRB CTRL
-        SRB CTRL[3:2] PLL_clock_divider
-        SRB CTRL[1] rst_arb
-        SRB CTRL[0] sclk_arb
-
-    pll_prediv_map[] = {2, 2, 4, 6, 8, 3, 12, 5, 16, 2, 2, 2, 2, 2, 2, 2};
-    system_pll_div_map[] = {16, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
-    pll_root_div_map[] = {1, 2};
-    mipi_bit_mode_map[] = {2, 2, 2, 2, 2, 2, 2, 2, 4, 2, 5, 2, 2, 2, 2, 2};
-    PLL_clock_divider_map[] = {1, 2, 4, 1};
-
-    VCO = XVCLK * 2 / pll_prediv_map[pll_prediv] * PLL_multiplier;
-    sysclk = VCO * 2 / system_pll_div_map[system_pll_div] / pll_root_div_map[pll_root_div] / mipi_bit_mode_map[mipi_bit_mode] / PLL_clock_divider_map[PLL_clock_divider]
-
-    Change Register
-
-    VCO = XVCLK * 2 / pll_prediv_map[0x3037[3:0]] * 0x3036[7:0];
-    sysclk = VCO * 2 / system_pll_div_map[0x3035[7:4]] / pll_root_div_map[0x3037[4]] / mipi_bit_mode_map[0x3034[3:0]] / PLL_clock_divider_map[0x3106[3:2]]
-
-    XVCLK = 24 MHZ
-    0x3106 0x05
-    0x3037 0x03
-    0x3036 0x69
-    0x3035 0x21
-    0x3034 0x1A
-
-    VCO = 24 * 2 / 6 * 105
-    sysclk = VCO * 2 / 2 / 1 / 5 / 2
-    sysclk = 84 MHZ
-    */
-
-    //@@ global setting
-    write_cmos_sensor(0x0100, 0x00); // Software Standy
-    write_cmos_sensor(0x0103, 0x01); // Software Reset
-
-    mDELAY(5);
-
-    write_cmos_sensor(0x3001, 0x00); // D[7:0] set to input
-    write_cmos_sensor(0x3002, 0x00); // D[11:8] set to input
-    write_cmos_sensor(0x3011, 0x02); // Drive strength 2x
-
-    write_cmos_sensor(0x3018, 0x4c); // MIPI 2 lane
-    write_cmos_sensor(0x3022, 0x00);
-
-    write_cmos_sensor(0x3034, 0x1a); // 10-bit mode
-    write_cmos_sensor(0x3035, 0x21); // PLL
-    write_cmos_sensor(0x3036, 0x69); // PLL
-
-    write_cmos_sensor(0x3037, 0x03); // PLL
-
-    write_cmos_sensor(0x3038, 0x00); // PLL
-    write_cmos_sensor(0x3039, 0x00); // PLL
-    write_cmos_sensor(0x303a, 0x00); // PLLS
-    write_cmos_sensor(0x303b, 0x19); // PLLS
-    write_cmos_sensor(0x303c, 0x11); // PLLS
-    write_cmos_sensor(0x303d, 0x30); // PLLS
-    write_cmos_sensor(0x3105, 0x11);
-    write_cmos_sensor(0x3106, 0x05); // PLL
-    write_cmos_sensor(0x3304, 0x28);
-    write_cmos_sensor(0x3305, 0x41);
-    write_cmos_sensor(0x3306, 0x30);
-    write_cmos_sensor(0x3308, 0x00);
-    write_cmos_sensor(0x3309, 0xc8);
-    write_cmos_sensor(0x330a, 0x01);
-    write_cmos_sensor(0x330b, 0x90);
-    write_cmos_sensor(0x330c, 0x02);
-    write_cmos_sensor(0x330d, 0x58);
-    write_cmos_sensor(0x330e, 0x03);
-    write_cmos_sensor(0x330f, 0x20);
-    write_cmos_sensor(0x3300, 0x00);
-
-    // exposure time
-    //write_cmos_sensor(0x3500, 0x00); // exposure [19:16]
-    //write_cmos_sensor(0x3501, 0x3d); // exposure [15:8]
-    //write_cmos_sensor(0x3502, 0x00); // exposure [7:0], exposure = 0x3d0 = 976
-
-    write_cmos_sensor(0x3503, 0x07); // gain has no delay, manual agc/aec
-
-    // gain
-    write_cmos_sensor(0x350a, 0x00); // gain[9:8]
-    write_cmos_sensor(0x350b, 0x40); // gain[7:0], gain = 4x
-
-    write_cmos_sensor(0x3601, 0x33); // analog control
-    write_cmos_sensor(0x3602, 0x00); // analog control
-    write_cmos_sensor(0x3611, 0x0e); // analog control
-    write_cmos_sensor(0x3612, 0x2b); // analog control
-    write_cmos_sensor(0x3614, 0x50); // analog control
-    write_cmos_sensor(0x3620, 0x33); // analog control
-    write_cmos_sensor(0x3622, 0x00); // analog control
-    write_cmos_sensor(0x3630, 0xad); // analog control
-    write_cmos_sensor(0x3631, 0x00); // analog control
-    write_cmos_sensor(0x3632, 0x94); // analog control
-    write_cmos_sensor(0x3633, 0x17); // analog control
-    write_cmos_sensor(0x3634, 0x14); // analog control
-
-    // fix EV3 issue
-    write_cmos_sensor(0x3704, 0xc0); // analog control
-
-    write_cmos_sensor(0x3705, 0x2a); // analog control
-    write_cmos_sensor(0x3708, 0x66); // analog control
-    write_cmos_sensor(0x3709, 0x52); // analog control
-    write_cmos_sensor(0x370b, 0x23); // analog control
-    write_cmos_sensor(0x370c, 0xc3); // analog control
-    write_cmos_sensor(0x370d, 0x00); // analog control
-    write_cmos_sensor(0x370e, 0x00); // analog control
-    write_cmos_sensor(0x371c, 0x07); // analog control
-    write_cmos_sensor(0x3739, 0xd2); // analog control
-    write_cmos_sensor(0x373c, 0x00);
-
-    write_cmos_sensor(0x3800, 0x00); // xstart = 0
-    write_cmos_sensor(0x3801, 0x00); // xstart
-    write_cmos_sensor(0x3802, 0x00); // ystart = 0
-    write_cmos_sensor(0x3803, 0x00); // ystart
-    write_cmos_sensor(0x3804, 0x0a); // xend = 2623
-    write_cmos_sensor(0x3805, 0x3f); // yend
-    write_cmos_sensor(0x3806, 0x07); // yend = 1955
-    write_cmos_sensor(0x3807, 0xa3); // yend
-    write_cmos_sensor(0x3808, 0x05); // x output size = 1296
-    write_cmos_sensor(0x3809, 0x10); // x output size
-    write_cmos_sensor(0x380a, 0x03); // y output size = 972
-    write_cmos_sensor(0x380b, 0xcc); // y output size
-    write_cmos_sensor(0x380c, 0x0b); // hts = 2816
-    write_cmos_sensor(0x380d, 0x00); // hts
-    write_cmos_sensor(0x380e, 0x03); // vts = 992
-    write_cmos_sensor(0x380f, 0xe0); // vts
-
-    write_cmos_sensor(0x3810, 0x00); // isp x win = 8
-    write_cmos_sensor(0x3811, 0x08); // isp x win
-    write_cmos_sensor(0x3812, 0x00); // isp y win = 4
-    write_cmos_sensor(0x3813, 0x04); // isp y win
-    write_cmos_sensor(0x3814, 0x31); // x inc
-    write_cmos_sensor(0x3815, 0x31); // y inc
-    write_cmos_sensor(0x3817, 0x00); // hsync start
-
-    // Horizontal binning
-    write_cmos_sensor(0x3820, 0x08); // flip off, v bin off
-    write_cmos_sensor(0x3821, 0x07); // mirror on, h bin on
-
-    write_cmos_sensor(0x3826, 0x03);
-    write_cmos_sensor(0x3829, 0x00);
-    write_cmos_sensor(0x382b, 0x0b);
-    write_cmos_sensor(0x3830, 0x00);
-    write_cmos_sensor(0x3836, 0x00);
-    write_cmos_sensor(0x3837, 0x00);
-    write_cmos_sensor(0x3838, 0x00);
-    write_cmos_sensor(0x3839, 0x04);
-    write_cmos_sensor(0x383a, 0x00);
-    write_cmos_sensor(0x383b, 0x01);
-
-    write_cmos_sensor(0x3b00, 0x00); // strobe off
-    write_cmos_sensor(0x3b02, 0x08); // shutter delay
-    write_cmos_sensor(0x3b03, 0x00); // shutter delay
-    write_cmos_sensor(0x3b04, 0x04); // frex_exp
-    write_cmos_sensor(0x3b05, 0x00); // frex_exp
-    write_cmos_sensor(0x3b06, 0x04);
-    write_cmos_sensor(0x3b07, 0x08); // frex inv
-    write_cmos_sensor(0x3b08, 0x00); // frex exp req
-    write_cmos_sensor(0x3b09, 0x02); // frex end option
-    write_cmos_sensor(0x3b0a, 0x04); // frex rst length
-    write_cmos_sensor(0x3b0b, 0x00); // frex strobe width
-    write_cmos_sensor(0x3b0c, 0x3d); // frex strobe width
-    write_cmos_sensor(0x3f01, 0x0d);
-    write_cmos_sensor(0x3f0f, 0xf5);
-
-    write_cmos_sensor(0x4000, 0x89); // blc enable
-    write_cmos_sensor(0x4001, 0x02); // blc start line
-    write_cmos_sensor(0x4002, 0x45); // blc auto, reset frame number = 5
-    write_cmos_sensor(0x4004, 0x02); // black line number
-    write_cmos_sensor(0x4005, 0x18); // blc normal freeze
-    write_cmos_sensor(0x4006, 0x08);
-    write_cmos_sensor(0x4007, 0x10);
-    write_cmos_sensor(0x4008, 0x00);
-    write_cmos_sensor(0x4300, 0xf8);
-    write_cmos_sensor(0x4303, 0xff);
-    write_cmos_sensor(0x4304, 0x00);
-    write_cmos_sensor(0x4307, 0xff);
-    write_cmos_sensor(0x4520, 0x00);
-    write_cmos_sensor(0x4521, 0x00);
-    write_cmos_sensor(0x4511, 0x22);
-
-    //update DPC settings
-    write_cmos_sensor(0x5780, 0xfc);
-    write_cmos_sensor(0x5781, 0x1f);
-    write_cmos_sensor(0x5782, 0x03);
-    write_cmos_sensor(0x5786, 0x20);
-    write_cmos_sensor(0x5787, 0x40);
-    write_cmos_sensor(0x5788, 0x08);
-    write_cmos_sensor(0x5789, 0x08);
-    write_cmos_sensor(0x578a, 0x02);
-    write_cmos_sensor(0x578b, 0x01);
-    write_cmos_sensor(0x578c, 0x01);
-    write_cmos_sensor(0x578d, 0x0c);
-    write_cmos_sensor(0x578e, 0x02);
-    write_cmos_sensor(0x578f, 0x01);
-    write_cmos_sensor(0x5790, 0x01);
-
-    write_cmos_sensor(0x4800, 0x24); // MIPI line sync enable
-
-    write_cmos_sensor(0x481f, 0x3c); // MIPI clk prepare min
-    write_cmos_sensor(0x4826, 0x00); // MIPI hs prepare min
-    write_cmos_sensor(0x4837, 0x18); // MIPI global timing
-    write_cmos_sensor(0x4b00, 0x06);
-    write_cmos_sensor(0x4b01, 0x0a);
-    write_cmos_sensor(0x5000, 0xff); // bpc on, wpc on
-    write_cmos_sensor(0x5001, 0x00); // awb disable
-    write_cmos_sensor(0x5002, 0x41); // win enable, awb gain enable
-    write_cmos_sensor(0x5003, 0x0a); // buf en, bin auto en
-    write_cmos_sensor(0x5004, 0x00); // size man off
-    write_cmos_sensor(0x5043, 0x00);
-    write_cmos_sensor(0x5013, 0x00);
-    write_cmos_sensor(0x501f, 0x03); // ISP output data
-    write_cmos_sensor(0x503d, 0x00); // test pattern off
-    write_cmos_sensor(0x5180, 0x08); // manual wb gain on
-    write_cmos_sensor(0x5a00, 0x08);
-    write_cmos_sensor(0x5b00, 0x01);
-    write_cmos_sensor(0x5b01, 0x40);
-    write_cmos_sensor(0x5b02, 0x00);
-    write_cmos_sensor(0x5b03, 0xf0);
-
-    //write_cmos_sensor(0x350b, 0x80); // gain = 8x
-    write_cmos_sensor(0x4837, 0x17); // MIPI global timing
-
-    write_cmos_sensor(0x0100, 0x01); // wake up from software sleep
-}    /*    MIPI_sensor_Init  */
-
-
-static void preview_setting(void)
-{
-    /********************************************************
-       *
-       *   1296x972 30fps 2 lane MIPI 420Mbps/lane
-       *
-       ********************************************************/
-
-    write_cmos_sensor(0x0100, 0x00); //Stream Off
-    mDELAY(10);
-
-    write_cmos_sensor(0x3500, 0x00); // exposure [19:16]
-    write_cmos_sensor(0x3501, 0x3d); // exposure
-    write_cmos_sensor(0x3502, 0x00); // exposure
-
-    write_cmos_sensor(0x3708, 0x66);
-
-    write_cmos_sensor(0x3709, 0x52);
-    write_cmos_sensor(0x370c, 0xc3);
-    write_cmos_sensor(0x3800, 0x00); // x start = 0
-    write_cmos_sensor(0x3801, 0x00); // x start
-    write_cmos_sensor(0x3802, 0x00); // y start = 0
-    write_cmos_sensor(0x3803, 0x00); // y start
-    write_cmos_sensor(0x3804, 0x0a); // xend = 2623
-    write_cmos_sensor(0x3805, 0x3f); // xend
-    write_cmos_sensor(0x3806, 0x07); // yend = 1955
-    write_cmos_sensor(0x3807, 0xa3); // yend
-    write_cmos_sensor(0x3808, 0x05); // x output size = 1296
-    write_cmos_sensor(0x3809, 0x10); // x output size
-    write_cmos_sensor(0x380a, 0x03); // y output size = 972
-    write_cmos_sensor(0x380b, 0xcc); // y output size
-
-
-    //write_cmos_sensor(0x380c, 0x0b); // hts = 2816
-    //write_cmos_sensor(0x380d, 0x00); // hts
-    //write_cmos_sensor(0x380e, 0x03); // vts = 992
-    //write_cmos_sensor(0x380f, 0xE0); // vts
-    write_cmos_sensor(0x380c, ((imgsensor_info.pre.linelength >> 8) & 0xFF)); // hts = 2688
-    write_cmos_sensor(0x380d, (imgsensor_info.pre.linelength & 0xFF));       // hts
-    write_cmos_sensor(0x380e, ((imgsensor_info.pre.framelength >> 8) & 0xFF));    // vts = 1984
-    write_cmos_sensor(0x380f, (imgsensor_info.pre.framelength & 0xFF));         // vts
-
-    write_cmos_sensor(0x3810, 0x00); // isp x win = 8
-    write_cmos_sensor(0x3811, 0x08); // isp x win
-    write_cmos_sensor(0x3812, 0x00); // isp y win = 4
-    write_cmos_sensor(0x3813, 0x04); // isp y win
-    write_cmos_sensor(0x3814, 0x31); // x inc
-    write_cmos_sensor(0x3815, 0x31); // y inc
-    write_cmos_sensor(0x3817, 0x00); // hsync start
-
-
-    /********************************************************
-       *
-       *   0x3820[2] ISP Vertical flip
-       *   0x3820[1] Sensor Vertical flip
-       *
-       *   0x3821[2] ISP Horizontal mirror
-       *   0x3821[1] Sensor Horizontal mirror
-       *
-       *   ISP and Sensor flip or mirror register bit should be the same!!
-       *
-       ********************************************************/
-    write_cmos_sensor(0x3820, 0x08); // flip off, v bin off
-    write_cmos_sensor(0x3821, 0x07); // mirror on, h bin on
-
-
-    write_cmos_sensor(0x4004, 0x02); // black line number
-    //write_cmos_sensor(0x4005, 0x1a); // blc normal freeze
-    write_cmos_sensor(0x4005, 0x18); // blc normal freeze
-    //write_cmos_sensor(0x4050, 0x37); // blc normal freeze
-    write_cmos_sensor(0x4050, 0x6e); // blc normal freeze
-    write_cmos_sensor(0x4051, 0x8f); // blc normal freeze
-
-    //write_cmos_sensor(0x350b, 0x80); // gain = 8x
-    write_cmos_sensor(0x4837, 0x17); // MIPI global timing
-
-    write_cmos_sensor(0x0100, 0x01); //Stream On
-}    /*    preview_setting  */
-
-
-static void capture_setting(kal_uint16 currefps)
-{
-    LOG_INF("E! currefps:%d\n", currefps);
-
-    /********************************************************
-       *
-       *   2592x1944 15fps 2 lane MIPI 420Mbps/lane
-       *
-       ********************************************************/
-
-    write_cmos_sensor(0x0100, 0x00); //Stream Off
-
-    write_cmos_sensor(0x3500, 0x00); // exposure [19:16]
-    write_cmos_sensor(0x3501, 0x7b); // exposure
-    write_cmos_sensor(0x3502, 0x00); // exposure
-    write_cmos_sensor(0x3708, 0x63);
-
-    write_cmos_sensor(0x3709, 0x12);
-    write_cmos_sensor(0x370c, 0xc0);
-    write_cmos_sensor(0x3800, 0x00); // xstart = 0
-    write_cmos_sensor(0x3801, 0x00); // xstart
-    write_cmos_sensor(0x3802, 0x00); // ystart = 0
-    write_cmos_sensor(0x3803, 0x00); // ystart
-    write_cmos_sensor(0x3804, 0x0a); // xend = 2623
-    write_cmos_sensor(0x3805, 0x3f); // xend
-    write_cmos_sensor(0x3806, 0x07); // yend = 1955
-    write_cmos_sensor(0x3807, 0xa3); // yend
-    write_cmos_sensor(0x3808, 0x0a); // x output size = 2592
-    write_cmos_sensor(0x3809, 0x20); // x output size
-    write_cmos_sensor(0x380a, 0x07); // y output size = 1944
-    write_cmos_sensor(0x380b, 0x98); // y output size
-
-    //write_cmos_sensor(0x380c, 0x0b); // hts = 2816
-    //write_cmos_sensor(0x380d, 0x00); // hts
-    //write_cmos_sensor(0x380e, 0x07); // vts = 1984
-    //write_cmos_sensor(0x380f, 0xc0); // vts
-    write_cmos_sensor(0x380c, ((imgsensor_info.cap.linelength >> 8) & 0xFF)); // hts = 2688
-    write_cmos_sensor(0x380d, (imgsensor_info.cap.linelength & 0xFF));       // hts
-    write_cmos_sensor(0x380e, ((imgsensor_info.cap.framelength >> 8) & 0xFF));    // vts = 1984
-    write_cmos_sensor(0x380f, (imgsensor_info.cap.framelength & 0xFF));         // vts
-
-
-    write_cmos_sensor(0x3810, 0x00); // isp x win = 16
-    write_cmos_sensor(0x3811, 0x10); // isp x win
-    write_cmos_sensor(0x3812, 0x00); // isp y win = 6
-    write_cmos_sensor(0x3813, 0x06); // isp y win
-    write_cmos_sensor(0x3814, 0x11); // x inc
-    write_cmos_sensor(0x3815, 0x11); // y inc
-    write_cmos_sensor(0x3817, 0x00); // hsync start
-
-
-    /********************************************************
-       *
-       *   0x3820[2] ISP Vertical flip
-       *   0x3820[1] Sensor Vertical flip
-       *
-       *   0x3821[2] ISP Horizontal mirror
-       *   0x3821[1] Sensor Horizontal mirror
-       *
-       *   ISP and Sensor flip or mirror register bit should be the same!!
-       *
-       ********************************************************/
-    write_cmos_sensor(0x3820, 0x40); // flip off, v bin off
-    write_cmos_sensor(0x3821, 0x06); // mirror on, v bin off
-
-
-    write_cmos_sensor(0x4004, 0x04); // black line number
-    //0x4005[1]: 0 normal freeze 1 blc always update
-    write_cmos_sensor(0x4005, 0x18); // blc normal freeze
-
-    write_cmos_sensor(0x350b, 0x40); // gain = 4x
-    write_cmos_sensor(0x4837, 0x17); // MIPI global timing
-
-    write_cmos_sensor(0x0100, 0x01); //Stream On
-}    /*    capture_setting  */
-
-static void normal_video_setting(kal_uint16 currefps)
-{
-    LOG_INF("E! currefps:%d\n", currefps);
-
-    /********************************************************
-       *
-       *   1296x972 30fps 2 lane MIPI 420Mbps/lane
-       *
-       ********************************************************/
-
-    write_cmos_sensor(0x0100, 0x00); //Stream Off
-
-    write_cmos_sensor(0x3500, 0x00); // exposure [19:16]
-    write_cmos_sensor(0x3501, 0x3d); // exposure
-    write_cmos_sensor(0x3502, 0x00); // exposure
-
-    write_cmos_sensor(0x3708, 0x66);
-
-    write_cmos_sensor(0x3709, 0x52);
-    write_cmos_sensor(0x370c, 0xc3);
-    write_cmos_sensor(0x3800, 0x00); // x start = 0
-    write_cmos_sensor(0x3801, 0x00); // x start
-    write_cmos_sensor(0x3802, 0x00); // y start = 0
-    write_cmos_sensor(0x3803, 0x00); // y start
-    write_cmos_sensor(0x3804, 0x0a); // xend = 2623
-    write_cmos_sensor(0x3805, 0x3f); // xend
-    write_cmos_sensor(0x3806, 0x07); // yend = 1955
-    write_cmos_sensor(0x3807, 0xa3); // yend
-    write_cmos_sensor(0x3808, 0x05); // x output size = 1296
-    write_cmos_sensor(0x3809, 0x10); // x output size
-    write_cmos_sensor(0x380a, 0x03); // y output size = 972
-    write_cmos_sensor(0x380b, 0xcc); // y output size
-
-
-    //write_cmos_sensor(0x380c, 0x0b); // hts = 2816
-    //write_cmos_sensor(0x380d, 0x00); // hts
-    //write_cmos_sensor(0x380e, 0x03); // vts = 992
-    //write_cmos_sensor(0x380f, 0xE0); // vts
-    write_cmos_sensor(0x380c, ((imgsensor_info.normal_video.linelength >> 8) & 0xFF)); // hts = 2688
-    write_cmos_sensor(0x380d, (imgsensor_info.normal_video.linelength & 0xFF));         // hts
-    write_cmos_sensor(0x380e, ((imgsensor_info.normal_video.framelength >> 8) & 0xFF));  // vts = 1984
-    write_cmos_sensor(0x380f, (imgsensor_info.normal_video.framelength & 0xFF));           // vts
-
-    write_cmos_sensor(0x3810, 0x00); // isp x win = 8
-    write_cmos_sensor(0x3811, 0x08); // isp x win
-    write_cmos_sensor(0x3812, 0x00); // isp y win = 4
-    write_cmos_sensor(0x3813, 0x04); // isp y win
-    write_cmos_sensor(0x3814, 0x31); // x inc
-    write_cmos_sensor(0x3815, 0x31); // y inc
-    write_cmos_sensor(0x3817, 0x00); // hsync start
-
-
-    /********************************************************
-       *
-       *   0x3820[2] ISP Vertical flip
-       *   0x3820[1] Sensor Vertical flip
-       *
-       *   0x3821[2] ISP Horizontal mirror
-       *   0x3821[1] Sensor Horizontal mirror
-       *
-       *   ISP and Sensor flip or mirror register bit should be the same!!
-       *
-       ********************************************************/
-    write_cmos_sensor(0x3820, 0x08); // flip off, v bin off
-    write_cmos_sensor(0x3821, 0x07); // mirror on, h bin on
-
-
-    write_cmos_sensor(0x4004, 0x02); // black line number
-    //write_cmos_sensor(0x4005, 0x1a); // blc normal freeze
-    write_cmos_sensor(0x4005, 0x18); // blc normal freeze
-    //write_cmos_sensor(0x4050, 0x37); // blc normal freeze
-    write_cmos_sensor(0x4050, 0x6e); // blc normal freeze
-    write_cmos_sensor(0x4051, 0x8f); // blc normal freeze
-
-    //write_cmos_sensor(0x350b, 0x80); // gain = 8x
-    write_cmos_sensor(0x4837, 0x17); // MIPI global timing
-
-    write_cmos_sensor(0x0100, 0x01); //Stream On
-}    /*    preview_setting  */
-
-
-static void video_1080p_setting(void)
-{
-
-    /********************************************************
-       *
-       *   1080p 30fps 2 lane MIPI 420Mbps/lane
-       *    @@1080p
-       *    ;;pclk=84M,HTS=2500,VTS=1120
-       ********************************************************/
-
-    write_cmos_sensor(0x0100, 0x00); //Stream Off
-
-    write_cmos_sensor(0x3500, 0x00); // exposure [19:16]
-    write_cmos_sensor(0x3501, 0x45); // exposure
-    write_cmos_sensor(0x3502, 0xc0); // exposure
-
-    write_cmos_sensor(0x3708, 0x63);
-
-    write_cmos_sensor(0x3709, 0x12);
-    write_cmos_sensor(0x370c, 0xcc);
-    write_cmos_sensor(0x3800, 0x01); // x start = 336
-    write_cmos_sensor(0x3801, 0x50); // x start
-    write_cmos_sensor(0x3802, 0x01); // y start = 434
-    write_cmos_sensor(0x3803, 0xb2); // y start
-    write_cmos_sensor(0x3804, 0x08); // xend = 2287
-    write_cmos_sensor(0x3805, 0xef); // xend
-    write_cmos_sensor(0x3806, 0x05); // yend = 1521
-    write_cmos_sensor(0x3807, 0xf1); // yend
-    write_cmos_sensor(0x3808, 0x07); // x output size = 1920
-    write_cmos_sensor(0x3809, 0x80); // x output size
-    write_cmos_sensor(0x380a, 0x04); // y output size = 1080
-    write_cmos_sensor(0x380b, 0x38); // y output size
-
-
-    //write_cmos_sensor(0x380c, 0x09); // hts = 2500
-    //write_cmos_sensor(0x380d, 0xc4); // hts
-    //write_cmos_sensor(0x380e, 0x04); // vts = 1120
-    //write_cmos_sensor(0x380f, 0x60); // vts
-    write_cmos_sensor(0x380c, ((imgsensor_info.hs_video.linelength >> 8) & 0xFF)); // hts = 2688
-    write_cmos_sensor(0x380d, (imgsensor_info.hs_video.linelength & 0xFF));          // hts
-    write_cmos_sensor(0x380e, ((imgsensor_info.hs_video.framelength >> 8) & 0xFF));    // vts = 1984
-    write_cmos_sensor(0x380f, (imgsensor_info.hs_video.framelength & 0xFF));        // vts
-
-    write_cmos_sensor(0x3810, 0x00); // isp x win = 16
-    write_cmos_sensor(0x3811, 0x10); // isp x win
-    write_cmos_sensor(0x3812, 0x00); // isp y win = 4
-    write_cmos_sensor(0x3813, 0x04); // isp y win
-    write_cmos_sensor(0x3814, 0x11); // x inc
-    write_cmos_sensor(0x3815, 0x11); // y inc
-    write_cmos_sensor(0x3817, 0x00); // hsync start
-
-
-    /********************************************************
-       *
-       *   0x3820[2] ISP Vertical flip
-       *   0x3820[1] Sensor Vertical flip
-       *
-       *   0x3821[2] ISP Horizontal mirror
-       *   0x3821[1] Sensor Horizontal mirror
-       *
-       *   ISP and Sensor flip or mirror register bit should be the same!!
-       *
-       ********************************************************/
-    write_cmos_sensor(0x3820, 0x40); // flip off, v bin off
-    write_cmos_sensor(0x3821, 0x06); // mirror on, h bin on
-
-
-    write_cmos_sensor(0x4004, 0x04); // black line number
-    write_cmos_sensor(0x4005, 0x18); // blc normal freeze
-
-
-    //write_cmos_sensor(0x350b, 0xf0); // gain = 8x
-    write_cmos_sensor(0x4837, 0x18); // MIPI global timing
-
-    write_cmos_sensor(0x0100, 0x01); //Stream On
-
-}    /*    preview_setting  */
-
-static void video_720p_setting(void)
-{
-    /********************************************************
-       *
-       *   720p 30fps 2 lane MIPI 420Mbps/lane
-       *    @@720p_30fps
-       *     ;;pclk=84M,HTS=3728,VTS=748
-       ********************************************************/
-
-    write_cmos_sensor(0x0100, 0x00); //Stream Off
-
-    mDELAY(10);
-    write_cmos_sensor(0x3500, 0x00); // exposure [19:16]
-    write_cmos_sensor(0x3501, 0x2d); // exposure
-    write_cmos_sensor(0x3502, 0xc0); // exposure
-
-    write_cmos_sensor(0x3708, 0x66);
-
-    write_cmos_sensor(0x3709, 0x52);
-    write_cmos_sensor(0x370c, 0xcf);
-    write_cmos_sensor(0x3800, 0x00); // x start = 16
-    write_cmos_sensor(0x3801, 0x10); // x start
-    write_cmos_sensor(0x3802, 0x00); // y start = 254
-    write_cmos_sensor(0x3803, 0xfe); // y start
-    write_cmos_sensor(0x3804, 0x0a); // xend = 2607
-    write_cmos_sensor(0x3805, 0x2f); // xend
-    write_cmos_sensor(0x3806, 0x06); // yend = 1701
-    write_cmos_sensor(0x3807, 0xa5); // yend
-    write_cmos_sensor(0x3808, 0x05); // x output size = 1280
-    write_cmos_sensor(0x3809, 0x00); // x output size
-    write_cmos_sensor(0x380a, 0x02); // y output size = 720
-    write_cmos_sensor(0x380b, 0xd0); // y output size
-
-
-    //write_cmos_sensor(0x380c, 0x0e); // hts = 3728
-    //write_cmos_sensor(0x380d, 0x90); // hts
-    //write_cmos_sensor(0x380e, 0x02); // vts = 748
-    //write_cmos_sensor(0x380f, 0xec); // vts
-    write_cmos_sensor(0x380c, ((imgsensor_info.slim_video.linelength >> 8) & 0xFF)); // hts = 2688
-    write_cmos_sensor(0x380d, (imgsensor_info.slim_video.linelength & 0xFF));          // hts
-    write_cmos_sensor(0x380e, ((imgsensor_info.slim_video.framelength >> 8) & 0xFF));    // vts = 1984
-    write_cmos_sensor(0x380f, (imgsensor_info.slim_video.framelength & 0xFF));        // vts
-
-    write_cmos_sensor(0x3810, 0x00); // isp x win = 8
-    write_cmos_sensor(0x3811, 0x08); // isp x win
-    write_cmos_sensor(0x3812, 0x00); // isp y win = 2
-    write_cmos_sensor(0x3813, 0x02); // isp y win
-    write_cmos_sensor(0x3814, 0x31); // x inc
-    write_cmos_sensor(0x3815, 0x31); // y inc
-    write_cmos_sensor(0x3817, 0x00); // hsync start
-
-
-    /********************************************************
-       *
-       *   0x3820[2] ISP Vertical flip
-       *   0x3820[1] Sensor Vertical flip
-       *
-       *   0x3821[2] ISP Horizontal mirror
-       *   0x3821[1] Sensor Horizontal mirror
-       *
-       *   ISP and Sensor flip or mirror register bit should be the same!!
-       *
-       ********************************************************/
-    write_cmos_sensor(0x3820, 0x08); // flip off, v bin off
-    write_cmos_sensor(0x3821, 0x07); // mirror on, h bin on
-
-
-    write_cmos_sensor(0x4004, 0x02); // black line number
-    write_cmos_sensor(0x4005, 0x18); // blc normal freeze
-
-
-    //write_cmos_sensor(0x350b, 0x80); // gain = 8x
-    write_cmos_sensor(0x4837, 0x18); // MIPI global timing
-
-    write_cmos_sensor(0x0100, 0x01); //Stream On
-
-    LOG_INF("Exit!");
-}    /*    preview_setting  */
-
-
-static void hs_video_setting(void)
-{
-    LOG_INF("E\n");
-
-    video_1080p_setting();
-}
-
-static void slim_video_setting(void)
-{
-    LOG_INF("E\n");
-
-    video_720p_setting();
-}
-
-/*************************************************************************
-* FUNCTION
-*    get_imgsensor_id
-*
-* DESCRIPTION
-*    This function get the sensor ID
-*
-* PARAMETERS
-*    *sensorID : return the sensor ID
-*
-* RETURNS
-*    None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 get_imgsensor_id(UINT32 *sensor_id)
-{
-    kal_uint8 i = 0;
-    kal_uint8 retry = 2;
-    //sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
-    while (imgsensor_info.i2c_addr_table[i] != 0xff) {
-        spin_lock(&imgsensor_drv_lock);
-        imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
-        spin_unlock(&imgsensor_drv_lock);
-        do {
-            *sensor_id = return_sensor_id();
-            if (*sensor_id == imgsensor_info.sensor_id) {
-                LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
-                return ERROR_NONE;
-            }
-            LOG_INF("Read sensor id fail, write id:0x%x id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
-            retry--;
-        } while(retry > 0);
-        i++;
-        retry = 2;
-    }
-    if (*sensor_id != imgsensor_info.sensor_id) {
-        // if Sensor ID is not correct, Must set *sensor_id to 0xFFFFFFFF
-        *sensor_id = 0xFFFFFFFF;
-        return ERROR_SENSOR_CONNECT_FAIL;
-    }
-    return ERROR_NONE;
-}
-
-
-/*************************************************************************
-* FUNCTION
-*    open
-*
-* DESCRIPTION
-*    This function initialize the registers of CMOS sensor
-*
-* PARAMETERS
-*    None
-*
-* RETURNS
-*    None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 open(void)
-{
-    kal_uint8 i = 0;
-    kal_uint8 retry = 2;
-    kal_uint32 sensor_id = 0;
-    LOG_1;
-    LOG_2;
-
-    //sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
-    while (imgsensor_info.i2c_addr_table[i] != 0xff) {
-        spin_lock(&imgsensor_drv_lock);
-        imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
-        spin_unlock(&imgsensor_drv_lock);
-        do {
-            sensor_id = return_sensor_id();
-            if (sensor_id == imgsensor_info.sensor_id) {
-                LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
-                break;
-            }
-            LOG_INF("Read sensor id fail, write id:0x%x id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
-            retry--;
-        } while(retry > 0);
-        i++;
-        if (sensor_id == imgsensor_info.sensor_id)
-            break;
-        retry = 2;
-    }
-    if (imgsensor_info.sensor_id != sensor_id)
-        return ERROR_SENSOR_CONNECT_FAIL;
-
-    /* initail sequence write in  */
-    sensor_init();
-
-    spin_lock(&imgsensor_drv_lock);
-
-    imgsensor.autoflicker_en= KAL_FALSE;
-    imgsensor.sensor_mode = IMGSENSOR_MODE_INIT;
-    imgsensor.pclk = imgsensor_info.pre.pclk;
-    imgsensor.frame_length = imgsensor_info.pre.framelength;
-    imgsensor.line_length = imgsensor_info.pre.linelength;
-    imgsensor.min_frame_length = imgsensor_info.pre.framelength;
-    imgsensor.dummy_pixel = 0;
-    imgsensor.dummy_line = 0;
-    imgsensor.ihdr_en = 0;
-    imgsensor.test_pattern = KAL_FALSE;
-    imgsensor.current_fps = imgsensor_info.pre.max_framerate;
-    spin_unlock(&imgsensor_drv_lock);
-
-    return ERROR_NONE;
-}    /*    open  */
-
-
-
-/*************************************************************************
-* FUNCTION
-*    close
-*
-* DESCRIPTION
-*
-*
-* PARAMETERS
-*    None
-*
-* RETURNS
-*    None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 close(void)
-{
-    LOG_INF("E\n");
-
-    /*No Need to implement this function*/
-
-    return ERROR_NONE;
-}    /*    close  */
-
-
-/*************************************************************************
-* FUNCTION
-* preview
-*
-* DESCRIPTION
-*    This function start the sensor preview.
-*
-* PARAMETERS
-*    *image_window : address pointer of pixel numbers in one period of HSYNC
-*  *sensor_config_data : address pointer of line numbers in one period of VSYNC
-*
-* RETURNS
-*    None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-    LOG_INF("E\n");
-
-    spin_lock(&imgsensor_drv_lock);
-    imgsensor.sensor_mode = IMGSENSOR_MODE_PREVIEW;
-    imgsensor.pclk = imgsensor_info.pre.pclk;
-    //imgsensor.video_mode = KAL_FALSE;
-    imgsensor.line_length = imgsensor_info.pre.linelength;
-    imgsensor.frame_length = imgsensor_info.pre.framelength;
-    imgsensor.min_frame_length = imgsensor_info.pre.framelength;
-    imgsensor.autoflicker_en = KAL_FALSE;
-    spin_unlock(&imgsensor_drv_lock);
-    preview_setting();
-    set_mirror_flip(imgsensor.mirror);
-    return ERROR_NONE;
-}    /*    preview   */
-
-/*************************************************************************
-* FUNCTION
-*    capture
-*
-* DESCRIPTION
-*    This function setup the CMOS sensor in capture MY_OUTPUT mode
-*
-* PARAMETERS
-*
-* RETURNS
-*    None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-                          MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-    LOG_INF("E\n");
-
-    spin_lock(&imgsensor_drv_lock);
-    imgsensor.sensor_mode = IMGSENSOR_MODE_CAPTURE;
-    if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {//PIP capture: 24fps for less than 13M, 20fps for 16M,15fps for 20M
-        imgsensor.pclk = imgsensor_info.cap1.pclk;
-        imgsensor.line_length = imgsensor_info.cap1.linelength;
-        imgsensor.frame_length = imgsensor_info.cap1.framelength;
-        imgsensor.min_frame_length = imgsensor_info.cap1.framelength;
-        imgsensor.autoflicker_en = KAL_FALSE;
-    } else {
-        if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
-            LOG_INF("Warning: current_fps %d fps is not support, so use cap1's setting: %d fps!\n",imgsensor.current_fps,imgsensor_info.cap1.max_framerate/10);
-        imgsensor.pclk = imgsensor_info.cap.pclk;
-        imgsensor.line_length = imgsensor_info.cap.linelength;
-        imgsensor.frame_length = imgsensor_info.cap.framelength;
-        imgsensor.min_frame_length = imgsensor_info.cap.framelength;
-        imgsensor.autoflicker_en = KAL_FALSE;
-    }
-    spin_unlock(&imgsensor_drv_lock);
-    capture_setting(imgsensor.current_fps);
-    set_mirror_flip(imgsensor.mirror);
-    return ERROR_NONE;
-}    /* capture() */
-static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-    LOG_INF("E\n");
-
-    spin_lock(&imgsensor_drv_lock);
-    imgsensor.sensor_mode = IMGSENSOR_MODE_VIDEO;
-    imgsensor.pclk = imgsensor_info.normal_video.pclk;
-    imgsensor.line_length = imgsensor_info.normal_video.linelength;
-    imgsensor.frame_length = imgsensor_info.normal_video.framelength;
-    imgsensor.min_frame_length = imgsensor_info.normal_video.framelength;
-    //imgsensor.current_fps = 300;
-    imgsensor.autoflicker_en = KAL_FALSE;
-    spin_unlock(&imgsensor_drv_lock);
-    normal_video_setting(imgsensor.current_fps);
-    set_mirror_flip(imgsensor.mirror);
-    return ERROR_NONE;
-}    /*    normal_video   */
-
-static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-    LOG_INF("E\n");
-
-    spin_lock(&imgsensor_drv_lock);
-    imgsensor.sensor_mode = IMGSENSOR_MODE_HIGH_SPEED_VIDEO;
-    imgsensor.pclk = imgsensor_info.hs_video.pclk;
-    //imgsensor.video_mode = KAL_TRUE;
-    imgsensor.line_length = imgsensor_info.hs_video.linelength;
-    imgsensor.frame_length = imgsensor_info.hs_video.framelength;
-    imgsensor.min_frame_length = imgsensor_info.hs_video.framelength;
-    imgsensor.dummy_line = 0;
-    imgsensor.dummy_pixel = 0;
-    imgsensor.autoflicker_en = KAL_FALSE;
-    spin_unlock(&imgsensor_drv_lock);
-    hs_video_setting();
-    set_mirror_flip(imgsensor.mirror);
-    return ERROR_NONE;
-}    /*    hs_video   */
-
-static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-    LOG_INF("E\n");
-
-    spin_lock(&imgsensor_drv_lock);
-    imgsensor.sensor_mode = IMGSENSOR_MODE_SLIM_VIDEO;
-    imgsensor.pclk = imgsensor_info.slim_video.pclk;
-    imgsensor.line_length = imgsensor_info.slim_video.linelength;
-    imgsensor.frame_length = imgsensor_info.slim_video.framelength;
-    imgsensor.min_frame_length = imgsensor_info.slim_video.framelength;
-    imgsensor.dummy_line = 0;
-    imgsensor.dummy_pixel = 0;
-    imgsensor.autoflicker_en = KAL_FALSE;
-    spin_unlock(&imgsensor_drv_lock);
-    slim_video_setting();
-    set_mirror_flip(imgsensor.mirror);
-
-    return ERROR_NONE;
-}    /*    slim_video     */
-
-
-
-static kal_uint32 get_resolution(MSDK_SENSOR_RESOLUTION_INFO_STRUCT *sensor_resolution)
-{
-    LOG_INF("E\n");
-    sensor_resolution->SensorFullWidth = imgsensor_info.cap.grabwindow_width;
-    sensor_resolution->SensorFullHeight = imgsensor_info.cap.grabwindow_height;
-
-    sensor_resolution->SensorPreviewWidth = imgsensor_info.pre.grabwindow_width;
-    sensor_resolution->SensorPreviewHeight = imgsensor_info.pre.grabwindow_height;
-
-    sensor_resolution->SensorVideoWidth = imgsensor_info.normal_video.grabwindow_width;
-    sensor_resolution->SensorVideoHeight = imgsensor_info.normal_video.grabwindow_height;
-
-
-    sensor_resolution->SensorHighSpeedVideoWidth     = imgsensor_info.hs_video.grabwindow_width;
-    sensor_resolution->SensorHighSpeedVideoHeight     = imgsensor_info.hs_video.grabwindow_height;
-
-    sensor_resolution->SensorSlimVideoWidth     = imgsensor_info.slim_video.grabwindow_width;
-    sensor_resolution->SensorSlimVideoHeight     = imgsensor_info.slim_video.grabwindow_height;
-    return ERROR_NONE;
-}    /*    get_resolution    */
-
-static kal_uint32 get_info(MSDK_SCENARIO_ID_ENUM scenario_id,
-                      MSDK_SENSOR_INFO_STRUCT *sensor_info,
-                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-    LOG_INF("scenario_id = %d\n", scenario_id);
-
-
-    //sensor_info->SensorVideoFrameRate = imgsensor_info.normal_video.max_framerate/10; /* not use */
-    //sensor_info->SensorStillCaptureFrameRate= imgsensor_info.cap.max_framerate/10; /* not use */
-    //imgsensor_info->SensorWebCamCaptureFrameRate= imgsensor_info.v.max_framerate; /* not use */
-
-    sensor_info->SensorClockPolarity = SENSOR_CLOCK_POLARITY_LOW;
-    sensor_info->SensorClockFallingPolarity = SENSOR_CLOCK_POLARITY_LOW; /* not use */
-    sensor_info->SensorHsyncPolarity = SENSOR_CLOCK_POLARITY_LOW; // inverse with datasheet
-    sensor_info->SensorVsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
-    sensor_info->SensorInterruptDelayLines = 4; /* not use */
-    sensor_info->SensorResetActiveHigh = FALSE; /* not use */
-    sensor_info->SensorResetDelayCount = 5; /* not use */
-
-    sensor_info->SensroInterfaceType = imgsensor_info.sensor_interface_type;
-    sensor_info->MIPIsensorType = imgsensor_info.mipi_sensor_type;
-    sensor_info->SettleDelayMode = imgsensor_info.mipi_settle_delay_mode;
-    sensor_info->SensorOutputDataFormat = imgsensor_info.sensor_output_dataformat;
-
-    sensor_info->CaptureDelayFrame = imgsensor_info.cap_delay_frame;
-    sensor_info->PreviewDelayFrame = imgsensor_info.pre_delay_frame;
-    sensor_info->VideoDelayFrame = imgsensor_info.video_delay_frame;
-    sensor_info->HighSpeedVideoDelayFrame = imgsensor_info.hs_video_delay_frame;
-    sensor_info->SlimVideoDelayFrame = imgsensor_info.slim_video_delay_frame;
-
-    sensor_info->SensorMasterClockSwitch = 0; /* not use */
-    sensor_info->SensorDrivingCurrent = imgsensor_info.isp_driving_current;
-
-    sensor_info->AEShutDelayFrame = imgsensor_info.ae_shut_delay_frame;          /* The frame of setting shutter default 0 for TG int */
-    sensor_info->AESensorGainDelayFrame = imgsensor_info.ae_sensor_gain_delay_frame;    /* The frame of setting sensor gain */
-    sensor_info->AEISPGainDelayFrame = imgsensor_info.ae_ispGain_delay_frame;
-    sensor_info->IHDR_Support = imgsensor_info.ihdr_support;
-    sensor_info->IHDR_LE_FirstLine = imgsensor_info.ihdr_le_firstline;
-    sensor_info->SensorModeNum = imgsensor_info.sensor_mode_num;
-
-    sensor_info->SensorMIPILaneNumber = imgsensor_info.mipi_lane_num;
-    sensor_info->SensorClockFreq = imgsensor_info.mclk;
-    sensor_info->SensorClockDividCount = 3; /* not use */
-    sensor_info->SensorClockRisingCount = 0;
-    sensor_info->SensorClockFallingCount = 2; /* not use */
-    sensor_info->SensorPixelClockCount = 3; /* not use */
-    sensor_info->SensorDataLatchCount = 2; /* not use */
-
-    sensor_info->MIPIDataLowPwr2HighSpeedTermDelayCount = 0;
-    sensor_info->MIPICLKLowPwr2HighSpeedTermDelayCount = 0;
-    sensor_info->SensorWidthSampling = 0;  // 0 is default 1x
-    sensor_info->SensorHightSampling = 0;    // 0 is default 1x
-    sensor_info->SensorPacketECCOrder = 1;
-
-    switch (scenario_id) {
-        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-            sensor_info->SensorGrabStartX = imgsensor_info.pre.startx;
-            sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;
-
-            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
-
-            break;
-        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
-            sensor_info->SensorGrabStartX = imgsensor_info.cap.startx;
-            sensor_info->SensorGrabStartY = imgsensor_info.cap.starty;
-
-            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.cap.mipi_data_lp2hs_settle_dc;
-
-            break;
-        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-
-            sensor_info->SensorGrabStartX = imgsensor_info.normal_video.startx;
-            sensor_info->SensorGrabStartY = imgsensor_info.normal_video.starty;
-
-            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.normal_video.mipi_data_lp2hs_settle_dc;
-
-            break;
-        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
-            sensor_info->SensorGrabStartX = imgsensor_info.hs_video.startx;
-            sensor_info->SensorGrabStartY = imgsensor_info.hs_video.starty;
-
-            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.hs_video.mipi_data_lp2hs_settle_dc;
-
-            break;
-        case MSDK_SCENARIO_ID_SLIM_VIDEO:
-            sensor_info->SensorGrabStartX = imgsensor_info.slim_video.startx;
-            sensor_info->SensorGrabStartY = imgsensor_info.slim_video.starty;
-
-            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.slim_video.mipi_data_lp2hs_settle_dc;
-
-            break;
-        default:
-            sensor_info->SensorGrabStartX = imgsensor_info.pre.startx;
-            sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;
-
-            sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
-            break;
-    }
-
-    return ERROR_NONE;
-}    /*    get_info  */
-
-
-static kal_uint32 control(MSDK_SCENARIO_ID_ENUM scenario_id, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-                      MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-    LOG_INF("scenario_id = %d\n", scenario_id);
-    spin_lock(&imgsensor_drv_lock);
-    imgsensor.current_scenario_id = scenario_id;
-    spin_unlock(&imgsensor_drv_lock);
-    switch (scenario_id) {
-        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-            preview(image_window, sensor_config_data);
-            break;
-        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
-            capture(image_window, sensor_config_data);
-            break;
-        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-            normal_video(image_window, sensor_config_data);
-            break;
-        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
-            hs_video(image_window, sensor_config_data);
-            break;
-        case MSDK_SCENARIO_ID_SLIM_VIDEO:
-            slim_video(image_window, sensor_config_data);
-            break;
-        default:
-            LOG_INF("Error ScenarioId setting");
-            preview(image_window, sensor_config_data);
-            return ERROR_INVALID_SCENARIO_ID;
-    }
-    return ERROR_NONE;
-}    /* control() */
-
-
-
-static kal_uint32 set_video_mode(UINT16 framerate)
-{
-    LOG_INF("framerate = %d\n ", framerate);
-    // SetVideoMode Function should fix framerate
-    if (framerate == 0)
-        // Dynamic frame rate
-        return ERROR_NONE;
-    spin_lock(&imgsensor_drv_lock);
-    if ((framerate == 300) && (imgsensor.autoflicker_en == KAL_TRUE))
-        imgsensor.current_fps = 296;
-    else if ((framerate == 150) && (imgsensor.autoflicker_en == KAL_TRUE))
-        imgsensor.current_fps = 146;
-    else
-        imgsensor.current_fps = framerate;
-    spin_unlock(&imgsensor_drv_lock);
-    set_max_framerate(imgsensor.current_fps,1);
-
-    return ERROR_NONE;
-}
-
-static kal_uint32 set_auto_flicker_mode(kal_bool enable, UINT16 framerate)
-{
-    LOG_INF("enable = %d, framerate = %d \n", enable, framerate);
-    spin_lock(&imgsensor_drv_lock);
-    if (enable) //enable auto flicker
-        imgsensor.autoflicker_en = KAL_TRUE;
-    else //Cancel Auto flick
-        imgsensor.autoflicker_en = KAL_FALSE;
-    spin_unlock(&imgsensor_drv_lock);
-    return ERROR_NONE;
-}
-
-
-static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 framerate)
-{
-    kal_uint32 frame_length;
-
-    LOG_INF("scenario_id = %d, framerate = %d\n", scenario_id, framerate);
-
-    switch (scenario_id) {
-        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-            frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
-            spin_lock(&imgsensor_drv_lock);
-            imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
-            imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
-            imgsensor.min_frame_length = imgsensor.frame_length;
-            spin_unlock(&imgsensor_drv_lock);
-            //set_dummy();
-            break;
-        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-            if(framerate == 0)
-                return ERROR_NONE;
-            frame_length = imgsensor_info.normal_video.pclk / framerate * 10 / imgsensor_info.normal_video.linelength;
-            spin_lock(&imgsensor_drv_lock);
-            imgsensor.dummy_line = (frame_length > imgsensor_info.normal_video.framelength) ? (frame_length - imgsensor_info.normal_video.framelength) : 0;
-            imgsensor.frame_length = imgsensor_info.normal_video.framelength + imgsensor.dummy_line;
-            imgsensor.min_frame_length = imgsensor.frame_length;
-            spin_unlock(&imgsensor_drv_lock);
-            //set_dummy();
-            break;
-        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
-            frame_length = imgsensor_info.cap.pclk / framerate * 10 / imgsensor_info.cap.linelength;
-            spin_lock(&imgsensor_drv_lock);
-            imgsensor.dummy_line = (frame_length > imgsensor_info.cap.framelength) ? (frame_length - imgsensor_info.cap.framelength) : 0;
-            imgsensor.frame_length = imgsensor_info.cap.framelength + imgsensor.dummy_line;
-            imgsensor.min_frame_length = imgsensor.frame_length;
-            spin_unlock(&imgsensor_drv_lock);
-            //set_dummy();
-            break;
-        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
-            frame_length = imgsensor_info.hs_video.pclk / framerate * 10 / imgsensor_info.hs_video.linelength;
-            spin_lock(&imgsensor_drv_lock);
-            imgsensor.dummy_line = (frame_length > imgsensor_info.hs_video.framelength) ? (frame_length - imgsensor_info.hs_video.framelength) : 0;
-            imgsensor.frame_length = imgsensor_info.hs_video.framelength + imgsensor.dummy_line;
-            imgsensor.min_frame_length = imgsensor.frame_length;
-            spin_unlock(&imgsensor_drv_lock);
-            //set_dummy();
-            break;
-        case MSDK_SCENARIO_ID_SLIM_VIDEO:
-            frame_length = imgsensor_info.slim_video.pclk / framerate * 10 / imgsensor_info.slim_video.linelength;
-            spin_lock(&imgsensor_drv_lock);
-            imgsensor.dummy_line = (frame_length > imgsensor_info.slim_video.framelength) ? (frame_length - imgsensor_info.slim_video.framelength): 0;
-            imgsensor.frame_length = imgsensor_info.slim_video.framelength + imgsensor.dummy_line;
-            imgsensor.min_frame_length = imgsensor.frame_length;
-            spin_unlock(&imgsensor_drv_lock);
-            //set_dummy();
-            break;
-        default:  //coding with  preview scenario by default
-            frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
-            spin_lock(&imgsensor_drv_lock);
-            imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
-            imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
-            imgsensor.min_frame_length = imgsensor.frame_length;
-            spin_unlock(&imgsensor_drv_lock);
-            //set_dummy();
-            LOG_INF("error scenario_id = %d, we use preview scenario \n", scenario_id);
-            break;
-    }
-    return ERROR_NONE;
-}
-
-
-static kal_uint32 get_default_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 *framerate)
-{
-    LOG_INF("scenario_id = %d\n", scenario_id);
-
-    switch (scenario_id) {
-        case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-            *framerate = imgsensor_info.pre.max_framerate;
-            break;
-        case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-            *framerate = imgsensor_info.normal_video.max_framerate;
-            break;
-        case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
-            *framerate = imgsensor_info.cap.max_framerate;
-            break;
-        case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
-            *framerate = imgsensor_info.hs_video.max_framerate;
-            break;
-        case MSDK_SCENARIO_ID_SLIM_VIDEO:
-            *framerate = imgsensor_info.slim_video.max_framerate;
-            break;
-        default:
-            break;
-    }
-
-    return ERROR_NONE;
-}
-
-
-
-static kal_uint32 set_test_pattern_mode(kal_bool enable)
-{
-    LOG_INF("enable: %d\n", enable);
-
-    // 0x503D[8]: 1 enable,  0 disable
-    // 0x503D[1:0]; 00 Color bar, 01 Random Data, 10 Square
-    if(enable)
-        write_cmos_sensor(0x503D, 0x80);
-    else
-        write_cmos_sensor(0x503D, 0x00);
-
-    spin_lock(&imgsensor_drv_lock);
-    imgsensor.test_pattern = enable;
-    spin_unlock(&imgsensor_drv_lock);
-    return ERROR_NONE;
-}
-
-
-static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
-                             UINT8 *feature_para,UINT32 *feature_para_len)
-{
-    UINT16 *feature_return_para_16=(UINT16 *) feature_para;
-    UINT16 *feature_data_16=(UINT16 *) feature_para;
-    UINT32 *feature_return_para_32=(UINT32 *) feature_para;
-    UINT32 *feature_data_32=(UINT32 *) feature_para;
-    unsigned long long *feature_data=(unsigned long long *) feature_para;
-    //unsigned long long *feature_return_para=(unsigned long long *) feature_para;
-
-    SENSOR_WINSIZE_INFO_STRUCT *wininfo;
-    MSDK_SENSOR_REG_INFO_STRUCT *sensor_reg_data=(MSDK_SENSOR_REG_INFO_STRUCT *) feature_para;
-
-    //printk("feature_id = %d\n", feature_id);
-    switch (feature_id) {
-        case SENSOR_FEATURE_GET_PERIOD:
-            *feature_return_para_16++ = imgsensor.line_length;
-            *feature_return_para_16 = imgsensor.frame_length;
-            *feature_para_len=4;
-            break;
-        case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:
-            LOG_INF("feature_Control imgsensor.pclk = %d,imgsensor.current_fps = %d\n", imgsensor.pclk,imgsensor.current_fps);
-            *feature_return_para_32 = imgsensor.pclk;
-            *feature_para_len=4;
-            break;
-        case SENSOR_FEATURE_SET_ESHUTTER:
-            set_shutter(*feature_data);
-            break;
-        case SENSOR_FEATURE_SET_NIGHTMODE:
-            night_mode((BOOL) *feature_data);
-            break;
-        case SENSOR_FEATURE_SET_GAIN:
-            set_gain((UINT16) *feature_data);
-            break;
-        case SENSOR_FEATURE_SET_FLASHLIGHT:
-            break;
-        case SENSOR_FEATURE_SET_ISP_MASTER_CLOCK_FREQ:
-            break;
-        case SENSOR_FEATURE_SET_REGISTER:
-            write_cmos_sensor(sensor_reg_data->RegAddr, sensor_reg_data->RegData);
-            break;
-        case SENSOR_FEATURE_GET_REGISTER:
-            sensor_reg_data->RegData = read_cmos_sensor(sensor_reg_data->RegAddr);
-            break;
-        case SENSOR_FEATURE_GET_LENS_DRIVER_ID:
-            // get the lens driver ID from EEPROM or just return LENS_DRIVER_ID_DO_NOT_CARE
-            // if EEPROM does not exist in camera module.
-            *feature_return_para_32=LENS_DRIVER_ID_DO_NOT_CARE;
-            *feature_para_len=4;
-            break;
-        case SENSOR_FEATURE_SET_VIDEO_MODE:
-            set_video_mode(*feature_data);
-            break;
-        case SENSOR_FEATURE_CHECK_SENSOR_ID:
-            get_imgsensor_id(feature_return_para_32);
-            break;
-        case SENSOR_FEATURE_SET_AUTO_FLICKER_MODE:
-            set_auto_flicker_mode((BOOL)*feature_data_16,*(feature_data_16+1));
-            break;
-        case SENSOR_FEATURE_SET_MAX_FRAME_RATE_BY_SCENARIO:
-            set_max_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data, *(feature_data+1));
-            break;
-        case SENSOR_FEATURE_GET_DEFAULT_FRAME_RATE_BY_SCENARIO:
-            get_default_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*(feature_data), (MUINT32 *)(uintptr_t)(*(feature_data+1)));
-            break;
-        case SENSOR_FEATURE_SET_TEST_PATTERN:
-            set_test_pattern_mode((BOOL)*feature_data);
-            break;
-        case SENSOR_FEATURE_GET_TEST_PATTERN_CHECKSUM_VALUE: //for factory mode auto testing
-            *feature_return_para_32 = imgsensor_info.checksum_value;
-            *feature_para_len=4;
-            break;
-        case SENSOR_FEATURE_SET_FRAMERATE:
-            LOG_INF("current fps :%d\n", (UINT32)*feature_data);
-            spin_lock(&imgsensor_drv_lock);
-            imgsensor.current_fps = *feature_data;
-            spin_unlock(&imgsensor_drv_lock);
-            break;
-        case SENSOR_FEATURE_SET_HDR:
-            LOG_INF("ihdr enable :%d\n", (BOOL)*feature_data);
-            spin_lock(&imgsensor_drv_lock);
-            imgsensor.ihdr_en = (BOOL)*feature_data;
-            spin_unlock(&imgsensor_drv_lock);
-            break;
-        case SENSOR_FEATURE_GET_CROP_INFO:
-            LOG_INF("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n", (UINT32)*feature_data);
-
-            wininfo = (SENSOR_WINSIZE_INFO_STRUCT *)(uintptr_t)(*(feature_data+1));
-
-            switch (*feature_data_32) {
-                case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
-                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[1],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-                    break;
-                case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[2],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-                    break;
-                case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
-                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[3],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-                    break;
-                case MSDK_SCENARIO_ID_SLIM_VIDEO:
-                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[4],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-                    break;
-                case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-                default:
-                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[0],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-                    break;
-            }
-        case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
-            LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",(UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
-            ihdr_write_shutter_gain((UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
-            break;
-        default:
-            break;
-    }
-
-    return ERROR_NONE;
-}    /*    feature_control()  */
-
-static SENSOR_FUNCTION_STRUCT sensor_func = {
-    open,
-    get_info,
-    get_resolution,
-    feature_control,
-    control,
-    close
-};
-
-UINT32 OV5648MIPISensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
-{
-    /* To Do : Check Sensor status here */
-    if (pfFunc!=NULL)
-        *pfFunc=&sensor_func;
-    return ERROR_NONE;
-}    /*    OV5648MIPISensorInit    */
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/ov8858_mipi_raw/ov8858mipiraw_Sensor.c~ b/drivers/misc/mediatek/imgsensor/src/mt6735m/ov8858_mipi_raw/ov8858mipiraw_Sensor.c~
deleted file mode 100755
index ca828e8..0000000
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/ov8858_mipi_raw/ov8858mipiraw_Sensor.c~
+++ /dev/null
@@ -1,2400 +0,0 @@
-/*****************************************************************************
- *
- * Filename:
- * ---------
- *	 OV8858mipiraw_sensor.c
- *
- * Project:
- * --------
- *	 ALPS MT6795
- *
- * Description:
- * ------------
- *	 Source code of Sensor driver
- *
- *	PengtaoFan
- *------------------------------------------------------------------------------
- * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
- *============================================================================
- ****************************************************************************/
-
-#include <linux/videodev2.h>
-#include <linux/i2c.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/cdev.h>
-#include <linux/uaccess.h>
-#include <linux/fs.h>
-#include <asm/atomic.h>
-//#include <asm/system.h>
-#include <linux/xlog.h>
-
-#include "kd_camera_hw.h"
-#include "kd_imgsensor.h"
-#include "kd_imgsensor_define.h"
-#include "kd_imgsensor_errcode.h"
-
-#include "ov8858mipiraw_Sensor.h"
-
-#define PFX "OV8858"
-
-//#define OV8858R2AOTP
-
-//#define LOG_WRN(format, args...) xlog_printk(ANDROID_LOG_WARN ,PFX, "[%S] " format, __FUNCTION__, ##args)
-//#defineLOG_INF(format, args...) xlog_printk(ANDROID_LOG_INFO ,PFX, "[%s] " format, __FUNCTION__, ##args)
-//#define LOG_DBG(format, args...) xlog_printk(ANDROID_LOG_DEBUG ,PFX, "[%S] " format, __FUNCTION__, ##args)
-#define LOG_INF(format, args...)	xlog_printk(ANDROID_LOG_INFO   , PFX, "[%s] " format, __FUNCTION__, ##args)
-typedef enum {
-	OV8858R2A,
-	OV8858R1A
-}OV8858_VERSION;
-
-OV8858_VERSION ov8858version = OV8858R2A;
-
-static DEFINE_SPINLOCK(imgsensor_drv_lock);
-
-static imgsensor_info_struct imgsensor_info = { 
-	.sensor_id = OV8858_SENSOR_ID,		//record sensor id defined in Kd_imgsensor.h
-	
-	.checksum_value = 0xd14be45,		//checksum value for Camera Auto Test
-	
-	.pre = {
-		.pclk = 74400000,				//record different mode's pclk
-		.linelength  = 1928,				//record different mode's linelength
-		.framelength = 1284,			//record different mode's framelength
-		.startx = 0,					//record different mode's startx of grabwindow
-		.starty = 0,					//record different mode's starty of grabwindow
-		.grabwindow_width  = 1632,		//record different mode's width of grabwindow
-		.grabwindow_height = 1224,		//record different mode's height of grabwindow
-		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
-		.mipi_data_lp2hs_settle_dc = 23,
-		/*	 following for GetDefaultFramerateByScenario()	*/
-		.max_framerate = 300,	
-	},
-	.cap = {
-		.pclk = 148800000,
-		.linelength  = 1940,
-		.framelength = 2556,
-		.startx = 0,
-		.starty = 0,
-		.grabwindow_width  = 3264,
-		.grabwindow_height = 2448,
-		.mipi_data_lp2hs_settle_dc = 23,
-		.max_framerate = 300,
-	},
-	.cap1 = {							//capture for PIP 24fps relative information, capture1 mode must use same framelength, linelength with Capture mode for shutter calculate
-		.pclk = 148800000,
-		.linelength  = 2425,
-		.framelength = 4090,//MODIFY FOR 15FPS FOR MT6735 //2556
-		.startx = 0,
-		.starty = 0,
-		.grabwindow_width  = 3264,
-		.grabwindow_height = 2448,
-		.mipi_data_lp2hs_settle_dc = 23,
-		.max_framerate = 150,
-	},
-	.normal_video = {
-		.pclk = 148800000,
-		.linelength  = 1940,
-		.framelength = 2556,
-		.startx = 0,
-		.starty = 0,
-		.grabwindow_width  = 3264,
-		.grabwindow_height = 2448,
-		.mipi_data_lp2hs_settle_dc = 23,
-		.max_framerate = 300,
-	},
-	.hs_video = {
-		.pclk = 148800000,				//record different mode's pclk
-		.linelength  = 2270,				//record different mode's linelength
-		.framelength = 546,			//record different mode's framelength
-		.startx = 0,					//record different mode's startx of grabwindow
-		.starty = 0,					//record different mode's starty of grabwindow
-		.grabwindow_width  = 640,		//record different mode's width of grabwindow
-		.grabwindow_height = 480,		//record different mode's height of grabwindow
-		/*	 following for  MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
-		.mipi_data_lp2hs_settle_dc = 30,
-		/*	 following for GetDefaultFramerateByScenario()	*/
-		.max_framerate = 1200,
-	},
-	.slim_video = {
-		.pclk = 74400000,				//record different mode's pclk
-		.linelength  = 1928,				//record different mode's linelength
-		.framelength = 1284,			//record different mode's framelength
-		.startx = 0,					//record different mode's startx of grabwindow
-		.starty = 0,					//record different mode's starty of grabwindow
-		.grabwindow_width  = 1632,		//record different mode's width of grabwindow
-		.grabwindow_height = 1224,		//record different mode's height of grabwindow
-		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
-		.mipi_data_lp2hs_settle_dc = 30,
-		/*	 following for GetDefaultFramerateByScenario()	*/
-		.max_framerate = 300,	
-
-	},
-	.margin = 4,			//sensor framelength & shutter margin
-	.min_shutter = 4,		//min shutter
-	.max_frame_length = 0x90f7,//max framelength by sensor register's limitation
-	.ae_shut_delay_frame = 0,	//shutter delay frame for AE cycle, 2 frame with ispGain_delay-shut_delay=2-0=2
-	.ae_sensor_gain_delay_frame = 0,//sensor gain delay frame for AE cycle,2 frame with ispGain_delay-sensor_gain_delay=2-0=2
-	.ae_ispGain_delay_frame = 2,//isp gain delay frame for AE cycle
-	.ihdr_support = 1,	  //1, support; 0,not support
-	.ihdr_le_firstline = 0,  //1,le first ; 0, se first
-	.sensor_mode_num = 5,	  //support sensor mode num ,don't support Slow motion
-	
-	.cap_delay_frame = 3,		//enter capture delay frame num
-	.pre_delay_frame = 3, 		//enter preview delay frame num
-	.video_delay_frame = 3,		//enter video delay frame num
-	.hs_video_delay_frame = 3,	//enter high speed video  delay frame num
-	.slim_video_delay_frame = 3,//enter slim video delay frame num
-	
-	.isp_driving_current = ISP_DRIVING_8MA, //mclk driving current
-	.sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,//sensor_interface_type
-	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_Gb,//sensor output first pixel color
-	.mclk = 24,//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
-	.mipi_lane_num = SENSOR_MIPI_4_LANE,//mipi lane num
-	.i2c_addr_table = {0x42, 0x20,0x6C,0xff},//record sensor support all write id addr, only supprt 4must end with 0xff
-};
-
-
-static imgsensor_struct imgsensor = {
-	.mirror = IMAGE_HV_MIRROR,//IMAGE_NORMAL,				//mirrorflip information
-	.sensor_mode = IMGSENSOR_MODE_INIT, //IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
-	.shutter = 0x4C00,					//current shutter
-	.gain = 0x200,						//current gain
-	.dummy_pixel = 0,					//current dummypixel
-	.dummy_line = 0,					//current dummyline
-	.current_fps = 0,  //full size current fps : 24fps for PIP, 30fps for Normal or ZSD
-	.autoflicker_en = KAL_FALSE,  //auto flicker enable: KAL_FALSE for disable auto flicker, KAL_TRUE for enable auto flicker
-	.test_pattern = KAL_FALSE,		//test pattern mode or not. KAL_FALSE for in test pattern mode, KAL_TRUE for normal output
-	.current_scenario_id = MSDK_SCENARIO_ID_CAMERA_PREVIEW,//current scenario id
-	.ihdr_en = 0, //sensor need support LE, SE with HDR feature
-	.i2c_write_id = 0x42,//record current sensor's i2c write id
-};
-
-
-/* Sensor output window information*/
-static SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[5] =	 
-{{ 3296, 2480,	  12,	12, 3272, 2456, 3264, 2452,   4,	2, 1632, 1224,	 0, 0, 1632, 1224}, // Preview 
- { 3296, 2480,	  12,	12, 3272, 2456, 3264, 2452,   4,	2, 3264, 2448,	 0, 0, 3264, 2448}, // capture 
- { 3296, 2480,	  12,	12, 3272, 2456, 3264, 2452,   4,	2, 3264, 2448,	 0, 0, 3264, 2448}, // video 
- { 3296, 2480,	  12,	12, 3272, 2456,  640,  480,   4,	2,  640,  480,	 0, 0,  640,  480}, //hight speed video 
- { 3296, 2480,	  12,	12, 3272, 2456, 3264, 2452,   4,	2, 1632, 1224,	 0, 0, 1632, 1224}};// slim video 
-
-static kal_uint16 read_cmos_sensor(kal_uint32 addr)
-{
-	kal_uint16 get_byte=0;
-
-	char pu_send_cmd[2] = {(char)(addr >> 8), (char)(addr & 0xFF) };
-	iReadRegI2C(pu_send_cmd, 2, (u8*)&get_byte, 1, imgsensor.i2c_write_id);
-
-	return get_byte;
-}
-
-static void write_cmos_sensor(kal_uint32 addr, kal_uint32 para)
-{
-	char pu_send_cmd[3] = {(char)(addr >> 8), (char)(addr & 0xFF), (char)(para & 0xFF)};
-	iWriteRegI2C(pu_send_cmd, 3, imgsensor.i2c_write_id);
-}
-
-static void set_dummy()
-{
-	LOG_INF("dummyline = %d, dummypixels = %d \n", imgsensor.dummy_line, imgsensor.dummy_pixel);
-	/* you can set dummy by imgsensor.dummy_line and imgsensor.dummy_pixel, or you can set dummy by imgsensor.frame_length and imgsensor.line_length */
-	write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
-	write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);	  
-	write_cmos_sensor(0x380c, imgsensor.line_length >> 8);
-	write_cmos_sensor(0x380d, imgsensor.line_length & 0xFF);
-  
-}	/*	set_dummy  */
-
-
-static void set_max_framerate(UINT16 framerate,kal_bool min_framelength_en)
-{
-	kal_int16 dummy_line;
-	kal_uint32 frame_length = imgsensor.frame_length;
-	//unsigned long flags;
-
-	LOG_INF("framerate = %d, min framelength should enable? \n", framerate,min_framelength_en);
-   
-	frame_length = imgsensor.pclk / framerate * 10 / imgsensor.line_length;
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.frame_length = (frame_length > imgsensor.min_frame_length) ? frame_length : imgsensor.min_frame_length; 
-	imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
-	//dummy_line = frame_length - imgsensor.min_frame_length;
-	//if (dummy_line < 0)
-		//imgsensor.dummy_line = 0;
-	//else
-		//imgsensor.dummy_line = dummy_line;
-	//imgsensor.frame_length = frame_length + imgsensor.dummy_line;
-	if (imgsensor.frame_length > imgsensor_info.max_frame_length)
-	{
-		imgsensor.frame_length = imgsensor_info.max_frame_length;
-		imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
-	}
-	if (min_framelength_en)
-		imgsensor.min_frame_length = imgsensor.frame_length;
-	spin_unlock(&imgsensor_drv_lock);
-	set_dummy();
-}	/*	set_max_framerate  */
-
-
-static void write_shutter(kal_uint16 shutter)
-{
-	kal_uint16 realtime_fps = 0;
-	kal_uint32 frame_length = 0;
-	   
-	/* 0x3500, 0x3501, 0x3502 will increase VBLANK to get exposure larger than frame exposure */
-	/* AE doesn't update sensor gain at capture mode, thus extra exposure lines must be updated here. */
-	
-	// OV Recommend Solution
-	// if shutter bigger than frame_length, should extend frame length first
-	spin_lock(&imgsensor_drv_lock);
-	if (shutter > imgsensor.min_frame_length - imgsensor_info.margin)		
-		imgsensor.frame_length = shutter + imgsensor_info.margin;
-	else
-		imgsensor.frame_length = imgsensor.min_frame_length;
-	if (imgsensor.frame_length > imgsensor_info.max_frame_length)
-		imgsensor.frame_length = imgsensor_info.max_frame_length;
-	spin_unlock(&imgsensor_drv_lock);
-	shutter = (shutter < imgsensor_info.min_shutter) ? imgsensor_info.min_shutter : shutter;
-	shutter = (shutter > (imgsensor_info.max_frame_length - imgsensor_info.margin)) ? (imgsensor_info.max_frame_length - imgsensor_info.margin) : shutter;
-	
-	if (imgsensor.autoflicker_en) { 
-		realtime_fps = imgsensor.pclk / imgsensor.line_length * 10 / imgsensor.frame_length;
-		if(realtime_fps >= 297 && realtime_fps <= 305)
-			set_max_framerate(296,0);
-		else if(realtime_fps >= 147 && realtime_fps <= 150)
-			set_max_framerate(146,0);	
-	} else {
-		// Extend frame length
-		write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
-		write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
-	}
-
-	// Update Shutter
-	write_cmos_sensor(0x3500, (shutter>>12) & 0x0F);
-	write_cmos_sensor(0x3501, (shutter>>4) & 0xFF);
-	write_cmos_sensor(0x3502, (shutter<<4) & 0xF0);	
-	LOG_INF("Exit! shutter =%d, framelength =%d\n", shutter,imgsensor.frame_length);
-
-	//LOG_INF("frame_length = %d ", frame_length);
-	
-}	/*	write_shutter  */
-
-
-
-/*************************************************************************
-* FUNCTION
-*	set_shutter
-*
-* DESCRIPTION
-*	This function set e-shutter of sensor to change exposure time.
-*
-* PARAMETERS
-*	iShutter : exposured lines
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static void set_shutter(kal_uint16 shutter)
-{
-	unsigned long flags;
-	kal_uint16 realtime_fps = 0;
-	kal_uint32 frame_length = 0;
-	spin_lock_irqsave(&imgsensor_drv_lock, flags);
-	imgsensor.shutter = shutter;
-	spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
-	
-	//write_shutter(shutter);
-	/* 0x3500, 0x3501, 0x3502 will increase VBLANK to get exposure larger than frame exposure */
-	/* AE doesn't update sensor gain at capture mode, thus extra exposure lines must be updated here. */
-	
-	// OV Recommend Solution
-	// if shutter bigger than frame_length, should extend frame length first
-	spin_lock(&imgsensor_drv_lock);
-	if (shutter > imgsensor.min_frame_length - imgsensor_info.margin)		
-		imgsensor.frame_length = shutter + imgsensor_info.margin;
-	else
-		imgsensor.frame_length = imgsensor.min_frame_length;
-	if (imgsensor.frame_length > imgsensor_info.max_frame_length)
-		imgsensor.frame_length = imgsensor_info.max_frame_length;
-	spin_unlock(&imgsensor_drv_lock);
-	shutter = (shutter < imgsensor_info.min_shutter) ? imgsensor_info.min_shutter : shutter;
-	shutter = (shutter > (imgsensor_info.max_frame_length - imgsensor_info.margin)) ? (imgsensor_info.max_frame_length - imgsensor_info.margin) : shutter;
-	
-	if (imgsensor.autoflicker_en) { 
-		realtime_fps = imgsensor.pclk / imgsensor.line_length * 10 / imgsensor.frame_length;
-		if(realtime_fps >= 297 && realtime_fps <= 305)
-			set_max_framerate(296,0);
-		else if(realtime_fps >= 147 && realtime_fps <= 150)
-			set_max_framerate(146,0);	
-		else {
-		// Extend frame length
-		write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
-		write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
-		}
-	} else {
-		// Extend frame length
-		write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
-		write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
-	}
-
-	// Update Shutter
-	write_cmos_sensor(0x3502, (shutter << 4) & 0xFF);
-	write_cmos_sensor(0x3501, (shutter >> 4) & 0xFF);	  
-	write_cmos_sensor(0x3500, (shutter >> 12) & 0x0F);	
-	LOG_INF("Exit! shutter =%d, framelength =%d\n", shutter,imgsensor.frame_length);
-
-}
-
-static kal_uint16 gain2reg(const kal_uint16 gain)
-{
-	kal_uint16 reg_gain = 0x0000;
-	
-	reg_gain = gain*2;
-	//reg_gain = reg_gain & 0xFFFF;
-	return (kal_uint16)reg_gain;
-}
-
-/*************************************************************************
-* FUNCTION
-*	set_gain
-*
-* DESCRIPTION
-*	This function is to set global gain to sensor.
-*
-* PARAMETERS
-*	iGain : sensor global gain(base: 0x40)
-*
-* RETURNS
-*	the actually gain set to sensor.
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint16 set_gain(kal_uint16 gain)
-{
-	LOG_INF("set_gain %d \n", gain);
-	kal_uint16 reg_gain;
-	if (gain < BASEGAIN || gain > 10 * BASEGAIN) {
-		LOG_INF("Error gain setting");
-
-		if (gain < BASEGAIN)
-			gain = BASEGAIN;
-		else if (gain > 10 * BASEGAIN)
-			gain = 10 * BASEGAIN;		 
-	}
-
-	//reg_gain = gain2reg(gain);
-	reg_gain = gain*2;
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.gain = reg_gain; 
-	spin_unlock(&imgsensor_drv_lock);
-	LOG_INF("gain = %d , reg_gain = 0x%x\n ", gain, reg_gain);
-
-	write_cmos_sensor(0x3508, (reg_gain>>8));
-	write_cmos_sensor(0x3509, (reg_gain&0xFF));    
-	return gain;
-}	/*	set_gain  */
-
-static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gain)
-{
-	LOG_INF("le:0x%x, se:0x%x, gain:0x%x\n",le,se,gain);
-	if (imgsensor.ihdr_en) {
-		
-		spin_lock(&imgsensor_drv_lock);
-			if (le > imgsensor.min_frame_length - imgsensor_info.margin)		
-				imgsensor.frame_length = le + imgsensor_info.margin;
-			else
-				imgsensor.frame_length = imgsensor.min_frame_length;
-			if (imgsensor.frame_length > imgsensor_info.max_frame_length)
-				imgsensor.frame_length = imgsensor_info.max_frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			if (le < imgsensor_info.min_shutter) le = imgsensor_info.min_shutter;
-			if (se < imgsensor_info.min_shutter) se = imgsensor_info.min_shutter;
-			
-			
-		// Extend frame length first
-		write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
-		write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
-
-		write_cmos_sensor(0x3502, (le << 4) & 0xFF);
-		write_cmos_sensor(0x3501, (le >> 4) & 0xFF);	 
-		write_cmos_sensor(0x3500, (le >> 12) & 0x0F);
-		
-		write_cmos_sensor(0x3512, (se << 4) & 0xFF); 
-		write_cmos_sensor(0x3511, (se >> 4) & 0xFF);
-		write_cmos_sensor(0x3510, (se >> 12) & 0x0F); 
-
-		set_gain(gain);
-	}
-
-}
-
-
-
-static void set_mirror_flip(kal_uint8 image_mirror)
-{
-	LOG_INF("image_mirror = %d\n", image_mirror);
-
-	/********************************************************
-	   *
-	   *   0x3820[2] ISP Vertical flip
-	   *   0x3820[1] Sensor Vertical flip
-	   *
-	   *   0x3821[2] ISP Horizontal mirror
-	   *   0x3821[1] Sensor Horizontal mirror
-	   *
-	   *   ISP and Sensor flip or mirror register bit should be the same!!
-	   *
-	   ********************************************************/
-	
-	switch (image_mirror) {
-		case IMAGE_NORMAL:
-			write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x00));
-			write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x06));
-			break;
-		case IMAGE_H_MIRROR:
-			write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x00));
-			write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x00));
-			break;
-		case IMAGE_V_MIRROR:
-			write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x06));
-			write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x06));		
-			break;
-		case IMAGE_HV_MIRROR:
-			write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x06));
-			write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x00));
-			break;
-		default:
-			LOG_INF("Error image_mirror setting\n");
-	}
-
-}
-
-/*************************************************************************
-* FUNCTION
-*	night_mode
-*
-* DESCRIPTION
-*	This function night mode of sensor.
-*
-* PARAMETERS
-*	bEnable: KAL_TRUE -> enable night mode, otherwise, disable night mode
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static void night_mode(kal_bool enable)
-{
-/*No Need to implement this function*/ 
-}	/*	night_mode	*/
-static void r1asensor_init(void)
-{
-	LOG_INF("E\n");
-//   ;-----------------------------------------
-//   @@ OV8858R1A Key 1632x1224_30FPS_MIPI_2LANE(Binning)
-//   100 99 1632 1224 ; Resolution
-//   102 80 1
-//   102 3601 bb8;30fps
-//   102 40 0 ; HDR Mode off
-//   ;FPGA set-up
-//   c8 01 f2 ;MIPI FPGA
-//   ;
-//   CL 100 100;delay
-//   ;;
-//   ;; MIPI=720Mbps, SysClk=144Mhz,Dac Clock=360Mhz.
-//   ;;
-//   ;;
-//   ;; v00_EM_AM14 (02/26/2014) : initial setting
-//   ;;
-//   ;; AM09 : Add 1080P,720P, HDR and 2 Lane Formats
-//   ;;      : Update the setting for R1A final Version(EK)
-//   ;; AM14 : fullwell 7K
-
-	write_cmos_sensor(0x3605, 0x30);
-	write_cmos_sensor(0x360b, 0x06);
-	write_cmos_sensor(0x360c, 0xdc);
-	write_cmos_sensor(0x3617, 0x90);
-	write_cmos_sensor(0x3618, 0x56);
-	write_cmos_sensor(0x361b, 0x00);
-	write_cmos_sensor(0x3633, 0x0c);
-	write_cmos_sensor(0x3634, 0x0c);
-	write_cmos_sensor(0x3635, 0x0c);
-	write_cmos_sensor(0x3636, 0x0c);
-	write_cmos_sensor(0x3501, 0x4b);
-	write_cmos_sensor(0x3502, 0xc0);
-	write_cmos_sensor(0x3503, 0x00);
-	write_cmos_sensor(0x3508, 0x01);
-	write_cmos_sensor(0x3706, 0x6a);
-	write_cmos_sensor(0x370b, 0x6a);
-	write_cmos_sensor(0x3750, 0x00);
-	write_cmos_sensor(0x3751, 0x00);
-	write_cmos_sensor(0x37b5, 0x33);
-	write_cmos_sensor(0x3d85, 0x14);
-	write_cmos_sensor(0x3d8c, 0x73);
-	write_cmos_sensor(0x3d8d, 0xde);
-	write_cmos_sensor(0x5780, 0xfc);
-	write_cmos_sensor(0x5781, 0xdf);
-	write_cmos_sensor(0x5782, 0x3f);
-	write_cmos_sensor(0x5783, 0x08);
-	write_cmos_sensor(0x5784, 0x0c);
-	write_cmos_sensor(0x5785, 0x10);
-	write_cmos_sensor(0x5786, 0x20);
-	write_cmos_sensor(0x5787, 0x40);
-	write_cmos_sensor(0x5788, 0x08);
-	write_cmos_sensor(0x5789, 0x08);
-	write_cmos_sensor(0x578a, 0x02);
-	write_cmos_sensor(0x578b, 0x01);
-	write_cmos_sensor(0x578c, 0x01);
-	write_cmos_sensor(0x578d, 0x0c);
-	write_cmos_sensor(0x578e, 0x02);
-	write_cmos_sensor(0x578f, 0x01);
-	write_cmos_sensor(0x5790, 0x01);
-	write_cmos_sensor(0x5791, 0xff);
-	write_cmos_sensor(0x5792, 0x07);
-	write_cmos_sensor(0x5793, 0x03);
-	write_cmos_sensor(0x5794, 0x03);
-	write_cmos_sensor(0x5871, 0x0d);
-	write_cmos_sensor(0x5870, 0x18);
-	write_cmos_sensor(0x586e, 0x40);
-	write_cmos_sensor(0x586f, 0x20);
-	write_cmos_sensor(0x58f8, 0x00);
-	write_cmos_sensor(0x3763, 0x00);
-	write_cmos_sensor(0x3768, 0x00);
-	write_cmos_sensor(0x470b, 0x00);
-	write_cmos_sensor(0x4202, 0x00);
-	write_cmos_sensor(0x400d, 0x20);
-	write_cmos_sensor(0x4040, 0x00);
-	write_cmos_sensor(0x403e, 0x00);
-	write_cmos_sensor(0x4041, 0x07);
-	write_cmos_sensor(0x3007, 0x00);
-	write_cmos_sensor(0x400a, 0x00);
-	write_cmos_sensor(0x4009, 0x81);
-	write_cmos_sensor(0x4011, 0x00);
-	write_cmos_sensor(0x4020, 0x00);
-	write_cmos_sensor(0x4021, 0x04);
-	write_cmos_sensor(0x4022, 0x04);
-	write_cmos_sensor(0x4023, 0xb9);
-	write_cmos_sensor(0x4024, 0x05);
-	write_cmos_sensor(0x4025, 0x2a);
-	write_cmos_sensor(0x4026, 0x05);
-	write_cmos_sensor(0x4027, 0x2b);
-	write_cmos_sensor(0x4028, 0x00);
-	write_cmos_sensor(0x4029, 0x02);
-	write_cmos_sensor(0x402a, 0x04);
-	write_cmos_sensor(0x402b, 0x04);
-	write_cmos_sensor(0x402c, 0x02);
-	write_cmos_sensor(0x402d, 0x02);
-	write_cmos_sensor(0x402e, 0x08);
-	write_cmos_sensor(0x402f, 0x02);
-}
-static void sensor_init(void)
-{
-	LOG_INF("E\n");
-//  @@ OV8858R2A Initial 1632x1224_30FPS_MIPI_2LANE(Binning)
-//  100 99 1632 1224 ; Resolution
-//  102 80 1
-//  102 3601 bb8;30fps
-//  102 40 0 ; HDR Mode off
-//  ;FPGA set-up
-//  c8 01 f2 ;MIPI FPGA
-//  ;
-//  CL 100 100;delay
-//  ;;
-//  ;; MIPI=720Mbps, SysClk=148.8Mhz,Dac Clock=360Mhz.
-//  ;;
-//  ;;
-//  ;; v00_01_00 (05/29/2014) : initial setting
-//  ;;
-//  ;; AM19 : 3617 <- 0xC0
-//  ;;
-//  ;; AM20 : change 0x3618=0x5a
-//  ;; AM22 :
-//  ;;   6c 3617 40 
-//  ::   6c 4011 20 
-//  ::   6c 403e 08
-//  ;;   6c 4040 07
-//  ;;   6c 58f8 3d
-//  ;;
-
-
-	write_cmos_sensor(0x103 , 0x01);
-	write_cmos_sensor(0x303f, 0x01);
-	write_cmos_sensor(0x3012, 0x6c);
-	write_cmos_sensor(0x100 , 0x00);
-	write_cmos_sensor(0x302 , 0x1e);
-	write_cmos_sensor(0x303 , 0x00);
-	write_cmos_sensor(0x304 , 0x03);
-	write_cmos_sensor(0x30d , 0x1f);
-	write_cmos_sensor(0x30e , 0x02);
-	write_cmos_sensor(0x30f , 0x04);
-	write_cmos_sensor(0x312 , 0x03);
-	write_cmos_sensor(0x31e , 0x0c);
-	write_cmos_sensor(0x3007, 0x80);
-	write_cmos_sensor(0x3600, 0x00);
-	write_cmos_sensor(0x3601, 0x00);
-	write_cmos_sensor(0x3602, 0x00);
-	write_cmos_sensor(0x3603, 0x00);
-	write_cmos_sensor(0x3604, 0x22);
-	write_cmos_sensor(0x3605, 0x20);
-	write_cmos_sensor(0x3606, 0x00);
-	write_cmos_sensor(0x3607, 0x20);
-	write_cmos_sensor(0x3608, 0x11);
-	write_cmos_sensor(0x3609, 0x28);
-	write_cmos_sensor(0x360a, 0x00);
-	write_cmos_sensor(0x360b, 0x05);
-	write_cmos_sensor(0x360c, 0xd4);
-	write_cmos_sensor(0x360d, 0x40);
-	write_cmos_sensor(0x360e, 0x0c);
-	write_cmos_sensor(0x360f, 0x20);
-	write_cmos_sensor(0x3610, 0x07);
-	write_cmos_sensor(0x3611, 0x20);
-	write_cmos_sensor(0x3612, 0x88);
-	write_cmos_sensor(0x3613, 0x80);
-	write_cmos_sensor(0x3614, 0x58);
-	write_cmos_sensor(0x3615, 0x00);
-	write_cmos_sensor(0x3616, 0x4a);
-	write_cmos_sensor(0x3617, 0x40);
-	write_cmos_sensor(0x3618, 0x5a);
-	write_cmos_sensor(0x3619, 0x70);
-	write_cmos_sensor(0x361a, 0x99);
-	write_cmos_sensor(0x361b, 0x0a);
-	write_cmos_sensor(0x361c, 0x07);
-	write_cmos_sensor(0x361d, 0x00);
-	write_cmos_sensor(0x361e, 0x00);
-	write_cmos_sensor(0x361f, 0x00);
-	write_cmos_sensor(0x3638, 0xff);
-	write_cmos_sensor(0x3633, 0x0f);
-	write_cmos_sensor(0x3634, 0x0f);
-	write_cmos_sensor(0x3635, 0x0f);
-	write_cmos_sensor(0x3636, 0x12);
-	write_cmos_sensor(0x3645, 0x13);
-	write_cmos_sensor(0x3646, 0x83);
-	write_cmos_sensor(0x364a, 0x07);
-	write_cmos_sensor(0x3015, 0x00);
-	write_cmos_sensor(0x3018, 0x72);
-	write_cmos_sensor(0x3020, 0x93);
-	write_cmos_sensor(0x3022, 0x01);
-	write_cmos_sensor(0x3031, 0x0a);
-	write_cmos_sensor(0x3034, 0x00);
-	write_cmos_sensor(0x3106, 0x01);
-	write_cmos_sensor(0x3305, 0xf1);
-	write_cmos_sensor(0x3308, 0x00);
-	write_cmos_sensor(0x3309, 0x28);
-	write_cmos_sensor(0x330a, 0x00);
-	write_cmos_sensor(0x330b, 0x20);
-	write_cmos_sensor(0x330c, 0x00);
-	write_cmos_sensor(0x330d, 0x00);
-	write_cmos_sensor(0x330e, 0x00);
-	write_cmos_sensor(0x330f, 0x40);
-	write_cmos_sensor(0x3307, 0x04);
-	write_cmos_sensor(0x3500, 0x00);
-	write_cmos_sensor(0x3501, 0x4d);
-	write_cmos_sensor(0x3502, 0x40);
-	write_cmos_sensor(0x3503, 0x80);
-	write_cmos_sensor(0x3505, 0x80);
-	write_cmos_sensor(0x3508, 0x02);
-	write_cmos_sensor(0x3509, 0x00);
-	write_cmos_sensor(0x350c, 0x00);
-	write_cmos_sensor(0x350d, 0x80);
-	write_cmos_sensor(0x3510, 0x00);
-	write_cmos_sensor(0x3511, 0x02);
-	write_cmos_sensor(0x3512, 0x00);
-	write_cmos_sensor(0x3700, 0x18);
-	write_cmos_sensor(0x3701, 0x0c);
-	write_cmos_sensor(0x3702, 0x28);
-	write_cmos_sensor(0x3703, 0x19);
-	write_cmos_sensor(0x3704, 0x14);
-	write_cmos_sensor(0x3705, 0x00);
-	write_cmos_sensor(0x3706, 0x82);
-	write_cmos_sensor(0x3707, 0x04);
-	write_cmos_sensor(0x3708, 0x24);
-	write_cmos_sensor(0x3709, 0x33);
-	write_cmos_sensor(0x370a, 0x01);
-	write_cmos_sensor(0x370b, 0x82);
-	write_cmos_sensor(0x370c, 0x04);
-	write_cmos_sensor(0x3718, 0x12);
-	write_cmos_sensor(0x3719, 0x31);
-	write_cmos_sensor(0x3712, 0x42);
-	write_cmos_sensor(0x3714, 0x24);
-	write_cmos_sensor(0x371e, 0x19);
-	write_cmos_sensor(0x371f, 0x40);
-	write_cmos_sensor(0x3720, 0x05);
-	write_cmos_sensor(0x3721, 0x05);
-	write_cmos_sensor(0x3724, 0x06);
-	write_cmos_sensor(0x3725, 0x01);
-	write_cmos_sensor(0x3726, 0x06);
-	write_cmos_sensor(0x3728, 0x05);
-	write_cmos_sensor(0x3729, 0x02);
-	write_cmos_sensor(0x372a, 0x03);
-	write_cmos_sensor(0x372b, 0x53);
-	write_cmos_sensor(0x372c, 0xa3);
-	write_cmos_sensor(0x372d, 0x53);
-	write_cmos_sensor(0x372e, 0x06);
-	write_cmos_sensor(0x372f, 0x10);
-	write_cmos_sensor(0x3730, 0x01);
-	write_cmos_sensor(0x3731, 0x06);
-	write_cmos_sensor(0x3732, 0x14);
-	write_cmos_sensor(0x3733, 0x10);
-	write_cmos_sensor(0x3734, 0x40);
-	write_cmos_sensor(0x3736, 0x20);
-	write_cmos_sensor(0x373a, 0x05);
-	write_cmos_sensor(0x373b, 0x06);
-	write_cmos_sensor(0x373c, 0x0a);
-	write_cmos_sensor(0x373e, 0x03);
-	write_cmos_sensor(0x3750, 0x0a);
-	write_cmos_sensor(0x3751, 0x0e);
-	write_cmos_sensor(0x3755, 0x10);
-	write_cmos_sensor(0x3758, 0x00);
-	write_cmos_sensor(0x3759, 0x4c);
-	write_cmos_sensor(0x375a, 0x06);
-	write_cmos_sensor(0x375b, 0x13);
-	write_cmos_sensor(0x375c, 0x20);
-	write_cmos_sensor(0x375d, 0x02);
-	write_cmos_sensor(0x375e, 0x00);
-	write_cmos_sensor(0x375f, 0x14);
-	write_cmos_sensor(0x3768, 0xcc);
-	write_cmos_sensor(0x3769, 0x44);
-	write_cmos_sensor(0x376a, 0x44);
-	write_cmos_sensor(0x3761, 0x00);
-	write_cmos_sensor(0x3762, 0x00);
-	write_cmos_sensor(0x3763, 0x18);
-	write_cmos_sensor(0x3766, 0xff);
-	write_cmos_sensor(0x376b, 0x00);
-	write_cmos_sensor(0x3772, 0x23);
-	write_cmos_sensor(0x3773, 0x02);
-	write_cmos_sensor(0x3774, 0x16);
-	write_cmos_sensor(0x3775, 0x12);
-	write_cmos_sensor(0x3776, 0x04);
-	write_cmos_sensor(0x3777, 0x00);
-	write_cmos_sensor(0x3778, 0x17);
-	write_cmos_sensor(0x37a0, 0x44);
-	write_cmos_sensor(0x37a1, 0x3d);
-	write_cmos_sensor(0x37a2, 0x3d);
-	write_cmos_sensor(0x37a3, 0x00);
-	write_cmos_sensor(0x37a4, 0x00);
-	write_cmos_sensor(0x37a5, 0x00);
-	write_cmos_sensor(0x37a6, 0x00);
-	write_cmos_sensor(0x37a7, 0x44);
-	write_cmos_sensor(0x37a8, 0x4c);
-	write_cmos_sensor(0x37a9, 0x4c);
-	write_cmos_sensor(0x3760, 0x00);
-	write_cmos_sensor(0x376f, 0x01);
-	write_cmos_sensor(0x37aa, 0x44);
-	write_cmos_sensor(0x37ab, 0x2e);
-	write_cmos_sensor(0x37ac, 0x2e);
-	write_cmos_sensor(0x37ad, 0x33);
-	write_cmos_sensor(0x37ae, 0x0d);
-	write_cmos_sensor(0x37af, 0x0d);
-	write_cmos_sensor(0x37b0, 0x00);
-	write_cmos_sensor(0x37b1, 0x00);
-	write_cmos_sensor(0x37b2, 0x00);
-	write_cmos_sensor(0x37b3, 0x42);
-	write_cmos_sensor(0x37b4, 0x42);
-	write_cmos_sensor(0x37b5, 0x31);
-	write_cmos_sensor(0x37b6, 0x00);
-	write_cmos_sensor(0x37b7, 0x00);
-	write_cmos_sensor(0x37b8, 0x00);
-	write_cmos_sensor(0x37b9, 0xff);
-	write_cmos_sensor(0x3800, 0x00);
-	write_cmos_sensor(0x3801, 0x0c);
-	write_cmos_sensor(0x3802, 0x00);
-	write_cmos_sensor(0x3803, 0x0c);
-	write_cmos_sensor(0x3804, 0x0c);
-	write_cmos_sensor(0x3805, 0xd3);
-	write_cmos_sensor(0x3806, 0x09);
-	write_cmos_sensor(0x3807, 0xa3);
-	write_cmos_sensor(0x3808, 0x06);
-	write_cmos_sensor(0x3809, 0x60);
-	write_cmos_sensor(0x380a, 0x04);
-	write_cmos_sensor(0x380b, 0xc8);
-	write_cmos_sensor(0x380c, 0x07);
-	write_cmos_sensor(0x380d, 0x88);
-	write_cmos_sensor(0x380e, 0x04);
-	write_cmos_sensor(0x380f, 0xdc);
-	write_cmos_sensor(0x3810, 0x00);
-	write_cmos_sensor(0x3811, 0x04);
-	write_cmos_sensor(0x3813, 0x02);
-	write_cmos_sensor(0x3814, 0x03);
-	write_cmos_sensor(0x3815, 0x01);
-	write_cmos_sensor(0x3820, 0x00);
-	write_cmos_sensor(0x3821, 0x67);
-	write_cmos_sensor(0x382a, 0x03);
-	write_cmos_sensor(0x382b, 0x01);
-	write_cmos_sensor(0x3830, 0x08);
-	write_cmos_sensor(0x3836, 0x02);
-	write_cmos_sensor(0x3837, 0x18);
-	
-	// modify for pre cap view diff 20150105
-	//write_cmos_sensor(0x3841, 0xff);
-	write_cmos_sensor(0x3841, 0xef);
-	
-	write_cmos_sensor(0x3846, 0x48);
-	write_cmos_sensor(0x3d85, 0x16);
-	write_cmos_sensor(0x3d8c, 0x73);
-	write_cmos_sensor(0x3d8d, 0xde);
-	write_cmos_sensor(0x3f08, 0x08);
-	write_cmos_sensor(0x3f0a, 0x00);
-	write_cmos_sensor(0x4000, 0xf1);
-	write_cmos_sensor(0x4001, 0x10);
-	write_cmos_sensor(0x4005, 0x10);
-	write_cmos_sensor(0x4002, 0x27);
-	write_cmos_sensor(0x4009, 0x83);
-	write_cmos_sensor(0x400a, 0x01);
-	write_cmos_sensor(0x400b, 0x0c);
-	write_cmos_sensor(0x400d, 0x10);
-	write_cmos_sensor(0x4011, 0x20);
-	write_cmos_sensor(0x401b, 0x00);
-	write_cmos_sensor(0x401d, 0x00);
-	write_cmos_sensor(0x4020, 0x00);
-	write_cmos_sensor(0x4021, 0x04);
-	write_cmos_sensor(0x4022, 0x04);
-	write_cmos_sensor(0x4023, 0xb9);
-	write_cmos_sensor(0x4024, 0x05);
-	write_cmos_sensor(0x4025, 0x2a);
-	write_cmos_sensor(0x4026, 0x05);
-	write_cmos_sensor(0x4027, 0x2b);
-	write_cmos_sensor(0x4028, 0x00);
-	write_cmos_sensor(0x4029, 0x02);
-	write_cmos_sensor(0x402a, 0x04);
-	write_cmos_sensor(0x402b, 0x04);
-	write_cmos_sensor(0x402c, 0x02);
-	write_cmos_sensor(0x402d, 0x02);
-	write_cmos_sensor(0x402e, 0x08);
-	write_cmos_sensor(0x402f, 0x02);
-	write_cmos_sensor(0x401f, 0x00);
-	write_cmos_sensor(0x4034, 0x3f);
-	write_cmos_sensor(0x403d, 0x04);
-	write_cmos_sensor(0x403e, 0x08);
-	write_cmos_sensor(0x4040, 0x07);
-	write_cmos_sensor(0x4041, 0xc6);
-	write_cmos_sensor(0x4300, 0xff);
-	write_cmos_sensor(0x4202, 0x00);
-	write_cmos_sensor(0x4301, 0x00);
-	write_cmos_sensor(0x4302, 0x0f);
-	write_cmos_sensor(0x4316, 0x00);
-	write_cmos_sensor(0x4500, 0x58);
-	write_cmos_sensor(0x4503, 0x18);
-	write_cmos_sensor(0x4600, 0x00);
-	write_cmos_sensor(0x4601, 0xcb);
-	write_cmos_sensor(0x470b, 0x28);
-	
-	//NO CONTIUS MODE ADD BY PENGTAO FAN 20140723
-	//write_cmos_sensor(0x4800, 0x6C);
-	//CONTIUS MODE ADD BY PENGTAO FAN 20140723
-	//write_cmos_sensor(0x4800, 0x4C);
-	write_cmos_sensor(0x4800, 0x4C);
-	
-	write_cmos_sensor(0x481f, 0x32);
-	write_cmos_sensor(0x4837, 0x16);
-	write_cmos_sensor(0x4850, 0x10);
-	write_cmos_sensor(0x4851, 0x32);
-	write_cmos_sensor(0x4b00, 0x2a);
-	write_cmos_sensor(0x4b0d, 0x00);
-	write_cmos_sensor(0x4d00, 0x04);
-	write_cmos_sensor(0x4d01, 0x18);
-	write_cmos_sensor(0x4d02, 0xc3);
-	write_cmos_sensor(0x4d03, 0xff);
-	write_cmos_sensor(0x4d04, 0xff);
-	write_cmos_sensor(0x4d05, 0xff);
-	//DPC off white test(0x5000, 0x78);
-	//DPC on  white test(0x5000, 0x7e);
-	write_cmos_sensor(0x5000, 0x7e);
-	write_cmos_sensor(0x5001, 0x01);
-	write_cmos_sensor(0x5002, 0x08);
-	write_cmos_sensor(0x5003, 0x20);
-	write_cmos_sensor(0x5046, 0x12);
-	write_cmos_sensor(0x5780, 0x3e);
-	write_cmos_sensor(0x5781, 0x0f);
-	write_cmos_sensor(0x5782, 0x44);
-	write_cmos_sensor(0x5783, 0x02);
-	write_cmos_sensor(0x5784, 0x01);
-	write_cmos_sensor(0x5785, 0x00);
-	write_cmos_sensor(0x5786, 0x00);
-	write_cmos_sensor(0x5787, 0x04);
-	write_cmos_sensor(0x5788, 0x02);
-	write_cmos_sensor(0x5789, 0x0f);
-	write_cmos_sensor(0x578a, 0xfd);
-	write_cmos_sensor(0x578b, 0xf5);
-	write_cmos_sensor(0x578c, 0xf5);
-	write_cmos_sensor(0x578d, 0x03);
-	write_cmos_sensor(0x578e, 0x08);
-	write_cmos_sensor(0x578f, 0x0c);
-	write_cmos_sensor(0x5790, 0x08);
-	write_cmos_sensor(0x5791, 0x04);
-	write_cmos_sensor(0x5792, 0x00);
-	write_cmos_sensor(0x5793, 0x52);
-	write_cmos_sensor(0x5794, 0xa3);
-	write_cmos_sensor(0x5871, 0x0d);
-	write_cmos_sensor(0x5870, 0x18);
-	write_cmos_sensor(0x586e, 0x10);
-	write_cmos_sensor(0x586f, 0x08);
-	write_cmos_sensor(0x58f8, 0x3d); //; LEN VSCALE FACTOR
-	write_cmos_sensor(0x5901, 0x00);
-	write_cmos_sensor(0x5b00, 0x02);
-	write_cmos_sensor(0x5b01, 0x10);
-	write_cmos_sensor(0x5b02, 0x03);
-	write_cmos_sensor(0x5b03, 0xcf);
-	write_cmos_sensor(0x5b05, 0x6c);
-	write_cmos_sensor(0x5e00, 0x00);
-	write_cmos_sensor(0x5e01, 0x41);
-	write_cmos_sensor(0x382d, 0x7f);
-	write_cmos_sensor(0x4825, 0x3a);
-	write_cmos_sensor(0x4826, 0x40);
-	write_cmos_sensor(0x4808, 0x25);
-	if (ov8858version == OV8858R1A){
-		LOG_INF("inter r1asensor_init() ov8858version = %d(0=r2a,1=r1a)\n",ov8858version); 
-		r1asensor_init();
-	}
-	write_cmos_sensor(0x0100, 0x01);
-}	/*	sensor_init  */
-
-
-static void preview_setting(void)
-{
-	LOG_INF("E\n");
-//   @@ Binning Size 1632x1224 30fps 4Lane_PCLK=74.4M
-//   100 99 1632 1224
-	write_cmos_sensor(0x100 , 0x00);      //	
-	write_cmos_sensor(0x30e , 0x02);     //
-	write_cmos_sensor(0x312 , 0x03);     //
-	write_cmos_sensor(0x3015, 0x00);     //
-	write_cmos_sensor(0x3700, 0x18);     //
-	write_cmos_sensor(0x3701, 0x0c);     //
-	write_cmos_sensor(0x3702, 0x28);     //
-	write_cmos_sensor(0x3703, 0x19);     //
-	write_cmos_sensor(0x3704, 0x14);     //
-	write_cmos_sensor(0x3707, 0x04);     //
-	write_cmos_sensor(0x3708, 0x24);     //
-	write_cmos_sensor(0x3709, 0x33);     //
-	write_cmos_sensor(0x370c, 0x04);     //
-	write_cmos_sensor(0x3718, 0x12);     //
-	write_cmos_sensor(0x3712, 0x42);     //
-	write_cmos_sensor(0x371e, 0x19);     //
-	write_cmos_sensor(0x371f, 0x40);     //
-	write_cmos_sensor(0x3720, 0x05);     //
-	write_cmos_sensor(0x3721, 0x05);     //
-	write_cmos_sensor(0x3724, 0x06);     //
-	write_cmos_sensor(0x3725, 0x01);     //
-	write_cmos_sensor(0x3726, 0x06);     //
-	write_cmos_sensor(0x3728, 0x05);     //
-	write_cmos_sensor(0x3729, 0x02);     //
-	write_cmos_sensor(0x372a, 0x03);     //
-	write_cmos_sensor(0x372b, 0x53);     //
-	write_cmos_sensor(0x372c, 0xa3);     //
-	write_cmos_sensor(0x372d, 0x53);     //
-	write_cmos_sensor(0x372e, 0x06);     //
-	write_cmos_sensor(0x372f, 0x10);     //
-	write_cmos_sensor(0x3730, 0x01);     //
-	write_cmos_sensor(0x3731, 0x06);     //
-	write_cmos_sensor(0x3732, 0x14);     //
-	write_cmos_sensor(0x3736, 0x20);     //
-	write_cmos_sensor(0x373a, 0x05);     //
-	write_cmos_sensor(0x373b, 0x06);     //
-	write_cmos_sensor(0x373c, 0x0a);     //
-	write_cmos_sensor(0x373e, 0x03);     //
-	write_cmos_sensor(0x375a, 0x06);     //
-	write_cmos_sensor(0x375b, 0x13);     //
-	write_cmos_sensor(0x375d, 0x02);     //
-	write_cmos_sensor(0x375f, 0x14);     //
-	write_cmos_sensor(0x3772, 0x23);     //
-	write_cmos_sensor(0x3773, 0x02);     //
-	write_cmos_sensor(0x3774, 0x16);     //
-	write_cmos_sensor(0x3775, 0x12);     //
-	write_cmos_sensor(0x3776, 0x04);     //
-	write_cmos_sensor(0x3778, 0x17);     //
-	write_cmos_sensor(0x37a0, 0x44);     //
-	write_cmos_sensor(0x37a1, 0x3d);     //
-	write_cmos_sensor(0x37a2, 0x3d);     //
-	write_cmos_sensor(0x37a7, 0x44);     //
-	write_cmos_sensor(0x37a8, 0x4c);     //
-	write_cmos_sensor(0x37a9, 0x4c);     //
-	write_cmos_sensor(0x37aa, 0x44);     //
-	write_cmos_sensor(0x37ab, 0x2e);     //
-	write_cmos_sensor(0x37ac, 0x2e);     //
-	write_cmos_sensor(0x37ad, 0x33);     //
-	write_cmos_sensor(0x37ae, 0x0d);     //
-	write_cmos_sensor(0x37af, 0x0d);     //
-	write_cmos_sensor(0x37b3, 0x42);     //
-	write_cmos_sensor(0x37b4, 0x42);     //
-	write_cmos_sensor(0x37b5, 0x31);     // ;;; 
-	write_cmos_sensor(0x3768, 0x22);     //
-	write_cmos_sensor(0x3769, 0x44);     //
-	write_cmos_sensor(0x376a, 0x44);     //
-	write_cmos_sensor(0x3808, 0x06);     //
-	write_cmos_sensor(0x3809, 0x60);     //
-	write_cmos_sensor(0x380a, 0x04);     //
-	write_cmos_sensor(0x380b, 0xc8);     //
-	write_cmos_sensor(0x380c, 0x07);     //
-	write_cmos_sensor(0x380d, 0x88);     //
-	write_cmos_sensor(0x380e, 0x05);     //;04
-	write_cmos_sensor(0x380f, 0x04);     //;dc
-	write_cmos_sensor(0x3814, 0x03);     //
-	write_cmos_sensor(0x3821, 0x67);     //
-	write_cmos_sensor(0x382a, 0x03);     //
-	write_cmos_sensor(0x382b, 0x01);     //
-	write_cmos_sensor(0x3830, 0x08);     //
-	write_cmos_sensor(0x3836, 0x02);     //
-
-	write_cmos_sensor(0x3843, 0x00);     //	
-	// modify for pre cap view diff 20150105
-	write_cmos_sensor(0x3811, 0x03);     //	
-	write_cmos_sensor(0x3845, 0x02);     //	
-
-	write_cmos_sensor(0x3f08, 0x08);     //
-	write_cmos_sensor(0x4001, 0x10);     //
-	write_cmos_sensor(0x4020, 0x00);     //
-	write_cmos_sensor(0x4021, 0x04);     //
-	write_cmos_sensor(0x4022, 0x04);     //
-	write_cmos_sensor(0x4023, 0xb9);     //
-	write_cmos_sensor(0x4024, 0x05);     //
-	write_cmos_sensor(0x4025, 0x2a);     //
-	write_cmos_sensor(0x4026, 0x05);     //
-	write_cmos_sensor(0x4027, 0x2b);     //
-	write_cmos_sensor(0x402a, 0x04);     //
-	write_cmos_sensor(0x402b, 0x04);     //
-	write_cmos_sensor(0x402e, 0x08);     //
-	write_cmos_sensor(0x402f, 0x02);     //
-	write_cmos_sensor(0x4600, 0x00);     //
-	write_cmos_sensor(0x4601, 0xcb);     //
-	write_cmos_sensor(0x5901, 0x00);     //
-	write_cmos_sensor(0x382d, 0x7f);     // ;;;
-	write_cmos_sensor(0x100 , 0x1);     //
-}	/*	preview_setting  */
-
-static void capture_setting(kal_uint16 currefps)
-{
-	LOG_INF("E! currefps:%d\n",currefps);
-	if (currefps == 150) {
-//  @@ Full size 3264x2448 30fps 4lane_PCLK=148.8M
-//  100 99 3264 2448);    //
-	write_cmos_sensor(0x100 , 0x0 );  //  
-	write_cmos_sensor(0x30e , 0x00);  //  
-	write_cmos_sensor(0x312 , 0x01);  //  
-	write_cmos_sensor(0x3015, 0x01);  //  
-	write_cmos_sensor(0x3700, 0x30);  //  
-	write_cmos_sensor(0x3701, 0x18);  //  
-	write_cmos_sensor(0x3702, 0x50);  //  
-	write_cmos_sensor(0x3703, 0x32);  //  
-	write_cmos_sensor(0x3704, 0x28);  //  
-	write_cmos_sensor(0x3707, 0x08);  //  
-	write_cmos_sensor(0x3708, 0x48);  //  
-	write_cmos_sensor(0x3709, 0x66);  //  
-	write_cmos_sensor(0x370c, 0x07);  //  
-	write_cmos_sensor(0x3718, 0x14);  //  
-	write_cmos_sensor(0x3712, 0x44);  //  
-	write_cmos_sensor(0x371e, 0x31);  //  
-	write_cmos_sensor(0x371f, 0x7f);  //  
-	write_cmos_sensor(0x3720, 0x0a);  //  
-	write_cmos_sensor(0x3721, 0x0a);  //  
-	write_cmos_sensor(0x3724, 0x0c);  //  
-	write_cmos_sensor(0x3725, 0x02);  //  
-	write_cmos_sensor(0x3726, 0x0c);  //  
-	write_cmos_sensor(0x3728, 0x0a);  //  
-	write_cmos_sensor(0x3729, 0x03);  //  
-	write_cmos_sensor(0x372a, 0x06);  //  
-	write_cmos_sensor(0x372b, 0xa6);  //  
-	write_cmos_sensor(0x372c, 0xa6);  //  
-	write_cmos_sensor(0x372d, 0xa6);  //  
-	write_cmos_sensor(0x372e, 0x0c);  //  
-	write_cmos_sensor(0x372f, 0x20);  //  
-	write_cmos_sensor(0x3730, 0x02);  //  
-	write_cmos_sensor(0x3731, 0x0c);  //  
-	write_cmos_sensor(0x3732, 0x28);  //  
-	write_cmos_sensor(0x3736, 0x30);  //  
-	write_cmos_sensor(0x373a, 0x0a);  //  
-	write_cmos_sensor(0x373b, 0x0b);  //  
-	write_cmos_sensor(0x373c, 0x14);  //  
-	write_cmos_sensor(0x373e, 0x06);  //  
-	write_cmos_sensor(0x375a, 0x0c);  //  
-	write_cmos_sensor(0x375b, 0x26);  //  
-	write_cmos_sensor(0x375d, 0x04);  //  
-	write_cmos_sensor(0x375f, 0x28);  //  
-	write_cmos_sensor(0x3772, 0x46);  //  
-	write_cmos_sensor(0x3773, 0x04);  //  
-	write_cmos_sensor(0x3774, 0x2c);  //  
-	write_cmos_sensor(0x3775, 0x13);  //  
-	write_cmos_sensor(0x3776, 0x08);  //  
-	write_cmos_sensor(0x3778, 0x17);  //  
-	write_cmos_sensor(0x37a0, 0x88);  //  
-	write_cmos_sensor(0x37a1, 0x7a);  //  
-	write_cmos_sensor(0x37a2, 0x7a);  //  
-	write_cmos_sensor(0x37a7, 0x88);  //  
-	write_cmos_sensor(0x37a8, 0x98);  //  
-	write_cmos_sensor(0x37a9, 0x98);  //  
-	write_cmos_sensor(0x37aa, 0x88);  //  
-	write_cmos_sensor(0x37ab, 0x5c);  //  
-	write_cmos_sensor(0x37ac, 0x5c);  //  
-	write_cmos_sensor(0x37ad, 0x55);  //  
-	write_cmos_sensor(0x37ae, 0x19);  //  
-	write_cmos_sensor(0x37af, 0x19);  //  
-	write_cmos_sensor(0x37b3, 0x84);  //  
-	write_cmos_sensor(0x37b4, 0x84);  //  
-	write_cmos_sensor(0x37b5, 0x60);  //   ; 66
-	write_cmos_sensor(0x3768, 0x22);  //  
-	write_cmos_sensor(0x3769, 0x44);  //  
-	write_cmos_sensor(0x376a, 0x44);  //  
-	write_cmos_sensor(0x3808, 0x0c);  //  
-	write_cmos_sensor(0x3809, 0xc0);  //  
-	write_cmos_sensor(0x380a, 0x09);  //  
-	write_cmos_sensor(0x380b, 0x90);  //  
-	write_cmos_sensor(0x380c, 0x09);  //  
-	write_cmos_sensor(0x380d, 0x79);  //  
-	write_cmos_sensor(0x380e, 0x0f);  //  
-	write_cmos_sensor(0x380f, 0xfa);  //   ;aa
-	write_cmos_sensor(0x3814, 0x01);  //  
-	write_cmos_sensor(0x3821, 0x46);  //  
-	write_cmos_sensor(0x382a, 0x01);  //  
-	write_cmos_sensor(0x382b, 0x01);  //  
-	write_cmos_sensor(0x3830, 0x06);  //  
-	write_cmos_sensor(0x3836, 0x01);  //  
-	write_cmos_sensor(0x3f08, 0x10);  //  
-
-	write_cmos_sensor(0x3843, 0x00);     //	
-	// modify for pre cap view diff 20150105
-	write_cmos_sensor(0x3811, 0x05);     //	
-	write_cmos_sensor(0x3845, 0x00);     //	
-
-	
-	write_cmos_sensor(0x4001, 0x00);  //  
-	write_cmos_sensor(0x4020, 0x00);  //  
-	write_cmos_sensor(0x4021, 0x04);  //  
-	write_cmos_sensor(0x4022, 0x0b);  //  
-	write_cmos_sensor(0x4023, 0xc3);  //  
-	write_cmos_sensor(0x4024, 0x0c);  //  
-	write_cmos_sensor(0x4025, 0x36);  //  
-	write_cmos_sensor(0x4026, 0x0c);  //  
-	write_cmos_sensor(0x4027, 0x37);  //  
-	write_cmos_sensor(0x402a, 0x04);  //  
-	write_cmos_sensor(0x402b, 0x08);  //  
-	write_cmos_sensor(0x402e, 0x0c);  //  
-	write_cmos_sensor(0x402f, 0x02);  //  
-	write_cmos_sensor(0x4600, 0x01);  //  
-	write_cmos_sensor(0x4601, 0x97);  //  
-	write_cmos_sensor(0x5901, 0x00);  //  
-	write_cmos_sensor(0x382d, 0xff);  //   ;;;
-	write_cmos_sensor(0x100 , 0x1);   // 
-	}
-	else 
-	{   
-//  @@ Full size 3264x2448 30fps 4lane_PCLK=148.8M
-//  100 99 3264 2448);    //
-	write_cmos_sensor(0x100 , 0x0 );  //  
-	write_cmos_sensor(0x30e , 0x00);  //  
-	write_cmos_sensor(0x312 , 0x01);  //  
-	write_cmos_sensor(0x3015, 0x01);  //  
-	write_cmos_sensor(0x3700, 0x30);  //  
-	write_cmos_sensor(0x3701, 0x18);  //  
-	write_cmos_sensor(0x3702, 0x50);  //  
-	write_cmos_sensor(0x3703, 0x32);  //  
-	write_cmos_sensor(0x3704, 0x28);  //  
-	write_cmos_sensor(0x3707, 0x08);  //  
-	write_cmos_sensor(0x3708, 0x48);  //  
-	write_cmos_sensor(0x3709, 0x66);  //  
-	write_cmos_sensor(0x370c, 0x07);  //  
-	write_cmos_sensor(0x3718, 0x14);  //  
-	write_cmos_sensor(0x3712, 0x44);  //  
-	write_cmos_sensor(0x371e, 0x31);  //  
-	write_cmos_sensor(0x371f, 0x7f);  //  
-	write_cmos_sensor(0x3720, 0x0a);  //  
-	write_cmos_sensor(0x3721, 0x0a);  //  
-	write_cmos_sensor(0x3724, 0x0c);  //  
-	write_cmos_sensor(0x3725, 0x02);  //  
-	write_cmos_sensor(0x3726, 0x0c);  //  
-	write_cmos_sensor(0x3728, 0x0a);  //  
-	write_cmos_sensor(0x3729, 0x03);  //  
-	write_cmos_sensor(0x372a, 0x06);  //  
-	write_cmos_sensor(0x372b, 0xa6);  //  
-	write_cmos_sensor(0x372c, 0xa6);  //  
-	write_cmos_sensor(0x372d, 0xa6);  //  
-	write_cmos_sensor(0x372e, 0x0c);  //  
-	write_cmos_sensor(0x372f, 0x20);  //  
-	write_cmos_sensor(0x3730, 0x02);  //  
-	write_cmos_sensor(0x3731, 0x0c);  //  
-	write_cmos_sensor(0x3732, 0x28);  //  
-	write_cmos_sensor(0x3736, 0x30);  //  
-	write_cmos_sensor(0x373a, 0x0a);  //  
-	write_cmos_sensor(0x373b, 0x0b);  //  
-	write_cmos_sensor(0x373c, 0x14);  //  
-	write_cmos_sensor(0x373e, 0x06);  //  
-	write_cmos_sensor(0x375a, 0x0c);  //  
-	write_cmos_sensor(0x375b, 0x26);  //  
-	write_cmos_sensor(0x375d, 0x04);  //  
-	write_cmos_sensor(0x375f, 0x28);  //  
-	write_cmos_sensor(0x3772, 0x46);  //  
-	write_cmos_sensor(0x3773, 0x04);  //  
-	write_cmos_sensor(0x3774, 0x2c);  //  
-	write_cmos_sensor(0x3775, 0x13);  //  
-	write_cmos_sensor(0x3776, 0x08);  //  
-	write_cmos_sensor(0x3778, 0x17);  //  
-	write_cmos_sensor(0x37a0, 0x88);  //  
-	write_cmos_sensor(0x37a1, 0x7a);  //  
-	write_cmos_sensor(0x37a2, 0x7a);  //  
-	write_cmos_sensor(0x37a7, 0x88);  //  
-	write_cmos_sensor(0x37a8, 0x98);  //  
-	write_cmos_sensor(0x37a9, 0x98);  //  
-	write_cmos_sensor(0x37aa, 0x88);  //  
-	write_cmos_sensor(0x37ab, 0x5c);  //  
-	write_cmos_sensor(0x37ac, 0x5c);  //  
-	write_cmos_sensor(0x37ad, 0x55);  //  
-	write_cmos_sensor(0x37ae, 0x19);  //  
-	write_cmos_sensor(0x37af, 0x19);  //  
-	write_cmos_sensor(0x37b3, 0x84);  //  
-	write_cmos_sensor(0x37b4, 0x84);  //  
-	write_cmos_sensor(0x37b5, 0x60);  //   ; 66
-	write_cmos_sensor(0x3768, 0x22);  //  
-	write_cmos_sensor(0x3769, 0x44);  //  
-	write_cmos_sensor(0x376a, 0x44);  //  
-	write_cmos_sensor(0x3808, 0x0c);  //  
-	write_cmos_sensor(0x3809, 0xc0);  //  
-	write_cmos_sensor(0x380a, 0x09);  //  
-	write_cmos_sensor(0x380b, 0x90);  //  
-	write_cmos_sensor(0x380c, 0x07);  //  
-	write_cmos_sensor(0x380d, 0x94);  //  
-	write_cmos_sensor(0x380e, 0x09);  //  
-	write_cmos_sensor(0x380f, 0xfc);  //   ;aa
-	write_cmos_sensor(0x3814, 0x01);  //  
-	write_cmos_sensor(0x3821, 0x46);  //  
-	write_cmos_sensor(0x382a, 0x01);  //  
-	write_cmos_sensor(0x382b, 0x01);  //  
-	write_cmos_sensor(0x3830, 0x06);  //  
-	write_cmos_sensor(0x3836, 0x01);  //  
-	// modify for pre cap view diff 20150105
-	write_cmos_sensor(0x3811, 0x05);     //	
-	write_cmos_sensor(0x3845, 0x00);     //	
-	
-	write_cmos_sensor(0x3f08, 0x10);  //  
-	write_cmos_sensor(0x4001, 0x00);  //  
-	write_cmos_sensor(0x4020, 0x00);  //  
-	write_cmos_sensor(0x4021, 0x04);  //  
-	write_cmos_sensor(0x4022, 0x0b);  //  
-	write_cmos_sensor(0x4023, 0xc3);  //  
-	write_cmos_sensor(0x4024, 0x0c);  //  
-	write_cmos_sensor(0x4025, 0x36);  //  
-	write_cmos_sensor(0x4026, 0x0c);  //  
-	write_cmos_sensor(0x4027, 0x37);  //  
-	write_cmos_sensor(0x402a, 0x04);  //  
-	write_cmos_sensor(0x402b, 0x08);  //  
-	write_cmos_sensor(0x402e, 0x0c);  //  
-	write_cmos_sensor(0x402f, 0x02);  //  
-	write_cmos_sensor(0x4600, 0x01);  //  
-	write_cmos_sensor(0x4601, 0x97);  //  
-	write_cmos_sensor(0x5901, 0x00);  //  
-	write_cmos_sensor(0x382d, 0xff);  //   ;;;
-	write_cmos_sensor(0x100 , 0x1);   // 
-	}
-		
-}
-
-static void normal_video_setting(kal_uint16 currefps)
-{
-	LOG_INF("E! currefps:%d\n",currefps);
-    capture_setting(currefps);
-}
-static void hs_video_setting()
-{
-	LOG_INF("E\n");
-//  @@ OV8858R2A VGA 120fps_PCLK=148.8M
-//  100 99 640 480
-	write_cmos_sensor(0x0100, 0x00);  //
-	write_cmos_sensor(0x30e , 0x00);  //
-	write_cmos_sensor(0x312 , 0x01);  //
-	write_cmos_sensor(0x3015, 0x01);  //
-	write_cmos_sensor(0x3700, 0x30);  //
-	write_cmos_sensor(0x3701, 0x18);  //
-	write_cmos_sensor(0x3702, 0x50);  //
-	write_cmos_sensor(0x3703, 0x32);  //
-	write_cmos_sensor(0x3704, 0x28);  //
-	write_cmos_sensor(0x3707, 0x08);  //
-	write_cmos_sensor(0x3708, 0x48);  //
-	write_cmos_sensor(0x3709, 0x66);  //
-	write_cmos_sensor(0x370c, 0x07);  //
-	write_cmos_sensor(0x3718, 0x14);  //
-	write_cmos_sensor(0x3712, 0x44);  //
-	write_cmos_sensor(0x371e, 0x31);  //
-	write_cmos_sensor(0x371f, 0x7f);  //
-	write_cmos_sensor(0x3720, 0x0a);  //
-	write_cmos_sensor(0x3721, 0x0a);  //
-	write_cmos_sensor(0x3724, 0x0c);  //
-	write_cmos_sensor(0x3725, 0x02);  //
-	write_cmos_sensor(0x3726, 0x0c);  //
-	write_cmos_sensor(0x3728, 0x0a);  //
-	write_cmos_sensor(0x3729, 0x03);  //
-	write_cmos_sensor(0x372a, 0x06);  //
-	write_cmos_sensor(0x372b, 0xa6);  //
-	write_cmos_sensor(0x372c, 0xa6);  //
-	write_cmos_sensor(0x372d, 0xa6);  //
-	write_cmos_sensor(0x372e, 0x0c);  //
-	write_cmos_sensor(0x372f, 0x20);  //
-	write_cmos_sensor(0x3730, 0x02);  //
-	write_cmos_sensor(0x3731, 0x0c);  //
-	write_cmos_sensor(0x3732, 0x28);  //
-	write_cmos_sensor(0x3736, 0x30);  //
-	write_cmos_sensor(0x373a, 0x0a);  //
-	write_cmos_sensor(0x373b, 0x0b);  //
-	write_cmos_sensor(0x373c, 0x14);  //
-	write_cmos_sensor(0x373e, 0x06);  //
-	write_cmos_sensor(0x375a, 0x0c);  //
-	write_cmos_sensor(0x375b, 0x26);  //
-	write_cmos_sensor(0x375d, 0x04);  //
-	write_cmos_sensor(0x375f, 0x28);  //
-	write_cmos_sensor(0x3772, 0x46);  //
-	write_cmos_sensor(0x3773, 0x04);  //
-	write_cmos_sensor(0x3774, 0x2c);  //
-	write_cmos_sensor(0x3775, 0x13);  //
-	write_cmos_sensor(0x3776, 0x08);  //
-	write_cmos_sensor(0x3778, 0x17);  //
-	write_cmos_sensor(0x37a0, 0x88);  //
-	write_cmos_sensor(0x37a1, 0x7a);  //
-	write_cmos_sensor(0x37a2, 0x7a);  //
-	write_cmos_sensor(0x37a7, 0x88);  //
-	write_cmos_sensor(0x37a8, 0x98);  //
-	write_cmos_sensor(0x37a9, 0x98);  //
-	write_cmos_sensor(0x37aa, 0x88);  //
-	write_cmos_sensor(0x37ab, 0x5c);  //
-	write_cmos_sensor(0x37ac, 0x5c);  //
-	write_cmos_sensor(0x37ad, 0x55);  //
-	write_cmos_sensor(0x37ae, 0x19);  //
-	write_cmos_sensor(0x37af, 0x19);  //
-	write_cmos_sensor(0x37b3, 0x84);  //
-	write_cmos_sensor(0x37b4, 0x84);  //
-	write_cmos_sensor(0x37b5, 0x60);  //
-	write_cmos_sensor(0x3768, 0x00);  //
-	write_cmos_sensor(0x3769, 0xc0);  //
-	write_cmos_sensor(0x376a, 0x42);  //
-	write_cmos_sensor(0x3808, 0x02);  //
-	write_cmos_sensor(0x3809, 0x80);  //
-	write_cmos_sensor(0x380a, 0x01);  //
-	write_cmos_sensor(0x380b, 0xe0);  //
-	write_cmos_sensor(0x380c, 0x08);  //;09
-	write_cmos_sensor(0x380d, 0xDe);  //;02
-	write_cmos_sensor(0x380e, 0x02);  //
-	write_cmos_sensor(0x380f, 0x22);  //;08
-	write_cmos_sensor(0x3814, 0x03);  //
-	write_cmos_sensor(0x3821, 0x6f);  //
-	write_cmos_sensor(0x382a, 0x05);  //
-	write_cmos_sensor(0x382b, 0x03);  //
-	write_cmos_sensor(0x3830, 0x0c);  //
-	write_cmos_sensor(0x3836, 0x02);  //
-	write_cmos_sensor(0x3f08, 0x10);  //
-	write_cmos_sensor(0x4001, 0x10);  //
-	write_cmos_sensor(0x4020, 0x01);  //
-	write_cmos_sensor(0x4021, 0x20);  //
-	write_cmos_sensor(0x4022, 0x01);  //
-	write_cmos_sensor(0x4023, 0x9f);  //
-	write_cmos_sensor(0x4024, 0x03);  //
-	write_cmos_sensor(0x4025, 0xe0);  //
-	write_cmos_sensor(0x4026, 0x04);  //
-	write_cmos_sensor(0x4027, 0x5f);  //
-	write_cmos_sensor(0x402a, 0x02);  //
-	write_cmos_sensor(0x402b, 0x04);  //
-	write_cmos_sensor(0x402e, 0x02);  //
-	write_cmos_sensor(0x402f, 0x04);  //
-	write_cmos_sensor(0x4600, 0x00);  //
-	write_cmos_sensor(0x4601, 0x4f);  //
-	write_cmos_sensor(0x5901, 0x04);  //
-	
-	// modify for pre cap view diff 20150105
-	write_cmos_sensor(0x3811, 0x03);     //	
-	write_cmos_sensor(0x3845, 0x02);     //	
-
-	write_cmos_sensor(0x382d, 0x7f);  //
-	write_cmos_sensor(0x0100, 0x01);  //
-}
-
-static void slim_video_setting()
-{
-	LOG_INF("E\n");
-	preview_setting();
-}
-
-
-/*************************************************************************
-* FUNCTION
-*	get_imgsensor_id
-*
-* DESCRIPTION
-*	This function get the sensor ID 
-*
-* PARAMETERS
-*	*sensorID : return the sensor ID 
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 get_imgsensor_id(UINT32 *sensor_id) 
-{
-	kal_uint8 i = 0;
-	kal_uint8 retry = 2;
-	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
-	while (imgsensor_info.i2c_addr_table[i] != 0xff) {
-		spin_lock(&imgsensor_drv_lock);
-		imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
-		spin_unlock(&imgsensor_drv_lock);
-		do {
-			*sensor_id = ((read_cmos_sensor(0x300B) << 8) | read_cmos_sensor(0x300C));
-			if (*sensor_id == imgsensor_info.sensor_id) {
-				if((read_cmos_sensor(0x302A)) == 0XB2){
- 				ov8858version = OV8858R2A;
-				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x, ov8858version = %d(0=r2a,1=r1a)\n", imgsensor.i2c_write_id,*sensor_id,ov8858version);	
-				return ERROR_NONE;
-				}
-				else if((read_cmos_sensor(0x302A)) == 0XB1){
- 				ov8858version = OV8858R1A;
-				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x, ov8858version = %d(0=r2a,1=r1a)\n", imgsensor.i2c_write_id,*sensor_id,ov8858version);	
-				return ERROR_NONE;
-				}
-				else{
-				LOG_INF("read ov8858 R1A R2A bate fail\n");	  
-				return ERROR_SENSOR_CONNECT_FAIL;
-				}
-			}	
-			LOG_INF("Read sensor id fail, id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
-			retry--;
-		} while(retry > 0);
-		i++;
-		retry = 2;
-	}
-	if (*sensor_id != imgsensor_info.sensor_id) {
-		// if Sensor ID is not correct, Must set *sensor_id to 0xFFFFFFFF 
-		*sensor_id = 0xFFFFFFFF;
-		return ERROR_SENSOR_CONNECT_FAIL;
-	}
-	return ERROR_NONE;
-}
-
-#ifdef OV8858R2AOTP
-
-struct otp_struct {
-int flag; // bit[7]: info, bit[6]:wb, bit[5]:vcm, bit[4]:lenc
-int module_integrator_id;
-int lens_id;
-int production_year;
-int production_month;
-int production_day;
-int rg_ratio;
-int bg_ratio;
-int lenc[240];
-int checksum;
-int VCM_start;
-int VCM_end;
-int VCM_dir;
-};
-
-//static struct otp_struct *otp_ptr = (struct otp_struct *)kzalloc(sizeof(struct otp_struct), GFP_KERNEL);
-
-#if 0
-struct otp_struct otp_struct_obj = {
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-{0},
-0,
-0,
-0,
-0,
-};
-
-
-otp_ptr = &otp_struct_obj;
-#endif
-
-// return value:
-// bit[7]: 0 no otp info, 1 valid otp info
-// bit[6]: 0 no otp wb, 1 valib otp wb
-// bit[5]: 0 no otp vcm, 1 valid otp vcm
-// bit[4]: 0 no otp lenc/invalid otp lenc, 1 valid otp lenc
-int read_otp(struct otp_struct *otp_ptr)
-{
-	int otp_flag, addr, temp, i;
-	//set 0x5002[3] to \A1\B00\A1\B1
-	int temp1;
-	temp1 = read_cmos_sensor(0x5002);
-	write_cmos_sensor(0x5002, (0x00 & 0x08) | (temp1 & (~0x08)));
-	// read OTP into buffer
-	write_cmos_sensor(0x3d84, 0xC0);
-	write_cmos_sensor(0x3d88, 0x70); // OTP start address
-	write_cmos_sensor(0x3d89, 0x10);
-	write_cmos_sensor(0x3d8A, 0x72); // OTP end address
-	write_cmos_sensor(0x3d8B, 0x0a);
-	write_cmos_sensor(0x3d81, 0x01); // load otp into buffer
-	mdelay(10);
-	// OTP base information and WB calibration data
-	otp_flag = read_cmos_sensor(0x7010);
-	addr = 0;
-	if((otp_flag & 0xc0) == 0x40) {
-		addr = 0x7011; // base address of info group 1
-	}
-	else if((otp_flag & 0x30) == 0x10) {
-		addr = 0x7019; // base address of info group 2
-	}
-	if(addr != 0) {
-		(*otp_ptr).flag = 0xC0; // valid info and AWB in OTP
-		(*otp_ptr).module_integrator_id = read_cmos_sensor(addr);
-		(*otp_ptr).lens_id = read_cmos_sensor( addr + 1);
-		(*otp_ptr).production_year = read_cmos_sensor( addr + 2);
-		(*otp_ptr).production_month = read_cmos_sensor( addr + 3);
-		(*otp_ptr).production_day = read_cmos_sensor(addr + 4);
-		temp = read_cmos_sensor(addr + 7);
-		(*otp_ptr).rg_ratio = (read_cmos_sensor(addr + 5)<<2) + ((temp>>6) & 0x03);
-		(*otp_ptr).bg_ratio = (read_cmos_sensor(addr + 6)<<2) + ((temp>>4) & 0x03);
-	}
-	else {
-		(*otp_ptr).flag = 0x00; // not info and AWB in OTP
-		(*otp_ptr).module_integrator_id = 0;
-		(*otp_ptr).lens_id = 0;
-		(*otp_ptr).production_year = 0;
-		(*otp_ptr).production_month = 0;
-		(*otp_ptr).production_day = 0;
-		(*otp_ptr).rg_ratio = 0;
-		(*otp_ptr).bg_ratio = 0;
-	}
-	// OTP VCM Calibration
-	otp_flag = read_cmos_sensor(0x7021);
-	addr = 0;
-	if((otp_flag & 0xc0) == 0x40) {
-		addr = 0x7022; // base address of VCM Calibration group 1
-	}
-	else if((otp_flag & 0x30) == 0x10) {
-		addr = 0x7025; // base address of VCM Calibration group 2
-	}
-	if(addr != 0) {
-		(*otp_ptr).flag |= 0x20;
-		temp = read_cmos_sensor(addr + 2);
-		(* otp_ptr).VCM_start = (read_cmos_sensor(addr)<<2) | ((temp>>6) & 0x03);
-		(* otp_ptr).VCM_end = (read_cmos_sensor(addr + 1) << 2) | ((temp>>4) & 0x03);
-		(* otp_ptr).VCM_dir = (temp>>2) & 0x03;
-	}
-	else {
-		(* otp_ptr).VCM_start = 0;
-		(* otp_ptr).VCM_end = 0;
-		(* otp_ptr).VCM_dir = 0;
-	}
-	// OTP Lenc Calibration
-	otp_flag = read_cmos_sensor(0x7028);
-	addr = 0;
-	int checksum2=0;
-	if((otp_flag & 0xc0) == 0x40) {
-		addr = 0x7029; // base address of Lenc Calibration group 1
-	}
-	else if((otp_flag & 0x30) == 0x10) {
-		addr = 0x711a; // base address of Lenc Calibration group 2
-	}
-	if(addr != 0) {
-		for(i=0;i<240;i++) {
-			(* otp_ptr).lenc[i]=read_cmos_sensor(addr + i);
-			checksum2 += (* otp_ptr).lenc[i];
-		}
-		checksum2 = (checksum2)%255 +1;
-		(*otp_ptr).checksum = read_cmos_sensor(addr + 240);
-		if((*otp_ptr).checksum == checksum2){
-			(*otp_ptr).flag |= 0x10;	
-		}
-	}
-	else {
-		for(i=0;i<240;i++) {
-			(* otp_ptr).lenc[i]=0;
-		}
-	}
-	for(i=0x7010;i<=0x720a;i++) {
-		write_cmos_sensor(i,0); // clear OTP buffer, recommended use continuous write to accelarate
-	}
-	//set 0x5002[3] to \A1\B01\A1\B1
-	temp1 = read_cmos_sensor(0x5002);
-	write_cmos_sensor(0x5002, (0x08 & 0x08) | (temp1 & (~0x08)));
-	return (*otp_ptr).flag;
-}
-// return value:
-// bit[7]: 0 no otp info, 1 valid otp info
-// bit[6]: 0 no otp wb, 1 valib otp wb
-// bit[5]: 0 no otp vcm, 1 valid otp vcm
-// bit[4]: 0 no otp lenc, 1 valid otp lenc
-
-int apply_otp(struct otp_struct *otp_ptr)
-{
-	int RG_Ratio_Typical = 0x148, BG_Ratio_Typical = 0x12A;
-	int rg, bg, R_gain, G_gain, B_gain, Base_gain, temp, i;
-	// apply OTP WB Calibration
-	if ((*otp_ptr).flag & 0x40) {
-		rg = (*otp_ptr).rg_ratio;
-		bg = (*otp_ptr).bg_ratio;
-		//calculate G gain
-		R_gain = (RG_Ratio_Typical*1000) / rg;
-		B_gain = (BG_Ratio_Typical*1000) / bg;
-		G_gain = 1000;
-		if (R_gain < 1000 || B_gain < 1000)
-		{
-			if (R_gain < B_gain)
-				Base_gain = R_gain;
-			else
-				Base_gain = B_gain;
-		}
-		else
-		{
-			Base_gain = G_gain;
-		}
-		R_gain = 0x400 * R_gain / (Base_gain);
-		B_gain = 0x400 * B_gain / (Base_gain);
-		G_gain = 0x400 * G_gain / (Base_gain);
-		// update sensor WB gain
-		if (R_gain>0x400) {
-			write_cmos_sensor(0x5032, R_gain>>8);
-			write_cmos_sensor(0x5033, R_gain & 0x00ff);
-		}
-		if (G_gain>0x400) {
-			write_cmos_sensor(0x5034, G_gain>>8);
-			write_cmos_sensor(0x5035, G_gain & 0x00ff);
-		}
-		if (B_gain>0x400) {
-			write_cmos_sensor(0x5036, B_gain>>8);
-			write_cmos_sensor(0x5037, B_gain & 0x00ff);
-		}
-	}
-	// apply OTP Lenc Calibration
-	if ((*otp_ptr).flag & 0x10) {
-		temp = read_cmos_sensor(0x5000);
-		temp = 0x80 | temp;
-		write_cmos_sensor(0x5000, temp);
-		for(i=0;i<240;i++) {
-			write_cmos_sensor(0x5800 + i, (*otp_ptr).lenc[i]);
-		}
-	}
-	return (*otp_ptr).flag;
-}
-
-#endif
-/*************************************************************************
-* FUNCTION
-*	open
-*
-* DESCRIPTION
-*	This function initialize the registers of CMOS sensor
-*
-* PARAMETERS
-*	None
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 open(void)
-{
-	//const kal_uint8 i2c_addr[] = {IMGSENSOR_WRITE_ID_1, IMGSENSOR_WRITE_ID_2};
-	kal_uint8 i = 0;
-	kal_uint8 retry = 2;
-	kal_uint16 sensor_id = 0; 
-	LOG_INF("PLATFORM:MT6595,MIPI 4LANE\n");
-	//LOG_INF("preview 1280*960@30fps,864Mbps/lane; video 1280*960@30fps,864Mbps/lane; capture 5M@30fps,864Mbps/lane\n");
-	
-	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
-	while (imgsensor_info.i2c_addr_table[i] != 0xff) {
-		spin_lock(&imgsensor_drv_lock);
-		imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
-		spin_unlock(&imgsensor_drv_lock);
-		do {
-			sensor_id = ((read_cmos_sensor(0x300B) << 8) | read_cmos_sensor(0x300C));
-			if (sensor_id == imgsensor_info.sensor_id) {				
-				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);	  
-				break;
-			}	
-			LOG_INF("Read sensor id fail, id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
-			retry--;
-		} while(retry > 0);
-		i++;
-		if (sensor_id == imgsensor_info.sensor_id)
-			break;
-		retry = 2;
-	}		 
-	if (imgsensor_info.sensor_id != sensor_id)
-		return ERROR_SENSOR_CONNECT_FAIL;
-	
-	/* initail sequence write in  */
-	sensor_init();
-	
-	mdelay(10);
-	#ifdef OV8858R2AOTP
-		LOG_INF("Apply the sensor OTP\n");
-		struct otp_struct *otp_ptr = (struct otp_struct *)kzalloc(sizeof(struct otp_struct), GFP_KERNEL);
-		read_otp(otp_ptr);
-		apply_otp(otp_ptr);
-		kfree(otp_ptr);
-	#endif
-	spin_lock(&imgsensor_drv_lock);
-
-	imgsensor.autoflicker_en= KAL_FALSE;
-	imgsensor.sensor_mode = IMGSENSOR_MODE_INIT;
-	imgsensor.shutter = 0x2D00;
-	imgsensor.gain = 0x100;
-	imgsensor.pclk = imgsensor_info.pre.pclk;
-	imgsensor.frame_length = imgsensor_info.pre.framelength;
-	imgsensor.line_length = imgsensor_info.pre.linelength;
-	imgsensor.min_frame_length = imgsensor_info.pre.framelength;
-	imgsensor.dummy_pixel = 0;
-	imgsensor.dummy_line = 0;
-	imgsensor.ihdr_en = 0;
-	imgsensor.test_pattern = KAL_FALSE;
-	imgsensor.current_fps = imgsensor_info.pre.max_framerate;
-	spin_unlock(&imgsensor_drv_lock);
-
-	return ERROR_NONE;
-}	/*	open  */
-
-
-
-/*************************************************************************
-* FUNCTION
-*	close
-*
-* DESCRIPTION
-*	
-*
-* PARAMETERS
-*	None
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 close(void)
-{
-	LOG_INF("E\n");
-
-	/*No Need to implement this function*/ 
-	
-	return ERROR_NONE;
-}	/*	close  */
-
-
-/*************************************************************************
-* FUNCTION
-* preview
-*
-* DESCRIPTION
-*	This function start the sensor preview.
-*
-* PARAMETERS
-*	*image_window : address pointer of pixel numbers in one period of HSYNC
-*  *sensor_config_data : address pointer of line numbers in one period of VSYNC
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("E\n");
-
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.sensor_mode = IMGSENSOR_MODE_PREVIEW;
-	imgsensor.pclk = imgsensor_info.pre.pclk;
-	//imgsensor.video_mode = KAL_FALSE;
-	imgsensor.line_length = imgsensor_info.pre.linelength;
-	imgsensor.frame_length = imgsensor_info.pre.framelength; 
-	imgsensor.min_frame_length = imgsensor_info.pre.framelength;
-	imgsensor.autoflicker_en = KAL_FALSE;
-	spin_unlock(&imgsensor_drv_lock);
-	preview_setting();
-	set_mirror_flip(imgsensor.mirror);
-	mdelay(10);
-	return ERROR_NONE;
-}	/*	preview   */
-
-/*************************************************************************
-* FUNCTION
-*	capture
-*
-* DESCRIPTION
-*	This function setup the CMOS sensor in capture MY_OUTPUT mode
-*
-* PARAMETERS
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-						  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("E\n");
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.sensor_mode = IMGSENSOR_MODE_CAPTURE;
-	if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {//PIP capture: 24fps for less than 13M, 20fps for 16M,15fps for 20M
-		imgsensor.pclk = imgsensor_info.cap1.pclk;
-		imgsensor.line_length = imgsensor_info.cap1.linelength;
-		imgsensor.frame_length = imgsensor_info.cap1.framelength;  
-		imgsensor.min_frame_length = imgsensor_info.cap1.framelength;
-		imgsensor.autoflicker_en = KAL_FALSE;
-	} else {
-		if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
-			LOG_INF("Warning: current_fps %d fps is not support, so use cap1's setting: %d fps!\n",imgsensor_info.cap1.max_framerate/10);
-		imgsensor.pclk = imgsensor_info.cap.pclk;
-		imgsensor.line_length = imgsensor_info.cap.linelength;
-		imgsensor.frame_length = imgsensor_info.cap.framelength;  
-		imgsensor.min_frame_length = imgsensor_info.cap.framelength;
-		imgsensor.autoflicker_en = KAL_FALSE;
-	}
-	spin_unlock(&imgsensor_drv_lock);
-
-	capture_setting(imgsensor.current_fps); 
-	set_mirror_flip(imgsensor.mirror);
-	mdelay(10);
-
-	#if 0
-	if(imgsensor.test_pattern == KAL_TRUE)
-	{
-		write_cmos_sensor(0x3282,0x01);//DPU OFF
-		
-		write_cmos_sensor(0x0600,0x00);
-		write_cmos_sensor(0x0601,0x02);
-		
-	}
-#endif
-	return ERROR_NONE;
-}	/* capture() */
-static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("E\n");
-	
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.sensor_mode = IMGSENSOR_MODE_VIDEO;
-	imgsensor.pclk = imgsensor_info.normal_video.pclk;
-	imgsensor.line_length = imgsensor_info.normal_video.linelength;
-	imgsensor.frame_length = imgsensor_info.normal_video.framelength;  
-	imgsensor.min_frame_length = imgsensor_info.normal_video.framelength;
-	//imgsensor.current_fps = 300;
-	imgsensor.autoflicker_en = KAL_FALSE;
-	spin_unlock(&imgsensor_drv_lock);
-	capture_setting(imgsensor.current_fps);
-	set_mirror_flip(imgsensor.mirror);
-	mdelay(10);
-	
-	
-	return ERROR_NONE;
-}	/*	normal_video   */
-
-static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("E\n");
-	
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.sensor_mode = IMGSENSOR_MODE_HIGH_SPEED_VIDEO;
-	imgsensor.pclk = imgsensor_info.hs_video.pclk;
-	//imgsensor.video_mode = KAL_TRUE;
-	imgsensor.line_length = imgsensor_info.hs_video.linelength;
-	imgsensor.frame_length = imgsensor_info.hs_video.framelength; 
-	imgsensor.min_frame_length = imgsensor_info.hs_video.framelength;
-	imgsensor.dummy_line = 0;
-	imgsensor.dummy_pixel = 0;
-	//imgsensor.current_fps = 300;
-	imgsensor.autoflicker_en = KAL_FALSE;
-	spin_unlock(&imgsensor_drv_lock);
-	hs_video_setting();
-	set_mirror_flip(imgsensor.mirror);
-	mdelay(10);
-	
-	return ERROR_NONE;
-}	/*	hs_video   */
-
-static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("E\n");
-	
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.sensor_mode = IMGSENSOR_MODE_SLIM_VIDEO;
-	imgsensor.pclk = imgsensor_info.slim_video.pclk;
-	//imgsensor.video_mode = KAL_TRUE;
-	imgsensor.line_length = imgsensor_info.slim_video.linelength;
-	imgsensor.frame_length = imgsensor_info.slim_video.framelength; 
-	imgsensor.min_frame_length = imgsensor_info.slim_video.framelength;
-	imgsensor.dummy_line = 0;
-	imgsensor.dummy_pixel = 0;
-	//imgsensor.current_fps = 300;
-	imgsensor.autoflicker_en = KAL_FALSE;
-	spin_unlock(&imgsensor_drv_lock);
-	slim_video_setting();
-	set_mirror_flip(imgsensor.mirror);
-	mdelay(10);
-	
-	return ERROR_NONE;
-}	/*	slim_video	 */
-
-
-
-static kal_uint32 get_resolution(MSDK_SENSOR_RESOLUTION_INFO_STRUCT *sensor_resolution)
-{
-	LOG_INF("E\n");
-	sensor_resolution->SensorFullWidth = imgsensor_info.cap.grabwindow_width;
-	sensor_resolution->SensorFullHeight = imgsensor_info.cap.grabwindow_height;
-	
-	sensor_resolution->SensorPreviewWidth = imgsensor_info.pre.grabwindow_width;
-	sensor_resolution->SensorPreviewHeight = imgsensor_info.pre.grabwindow_height;
-
-	sensor_resolution->SensorVideoWidth = imgsensor_info.normal_video.grabwindow_width;
-	sensor_resolution->SensorVideoHeight = imgsensor_info.normal_video.grabwindow_height;		
-
-	
-	sensor_resolution->SensorHighSpeedVideoWidth	 = imgsensor_info.hs_video.grabwindow_width;
-	sensor_resolution->SensorHighSpeedVideoHeight	 = imgsensor_info.hs_video.grabwindow_height;
-	
-	sensor_resolution->SensorSlimVideoWidth	 = imgsensor_info.slim_video.grabwindow_width;
-	sensor_resolution->SensorSlimVideoHeight	 = imgsensor_info.slim_video.grabwindow_height;
-	return ERROR_NONE;
-}	/*	get_resolution	*/
-
-static kal_uint32 get_info(MSDK_SCENARIO_ID_ENUM scenario_id,
-					  MSDK_SENSOR_INFO_STRUCT *sensor_info,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("scenario_id = %d\n", scenario_id);
-
-	
-	//sensor_info->SensorVideoFrameRate = imgsensor_info.normal_video.max_framerate/10; /* not use */
-	//sensor_info->SensorStillCaptureFrameRate= imgsensor_info.cap.max_framerate/10; /* not use */
-	//imgsensor_info->SensorWebCamCaptureFrameRate= imgsensor_info.v.max_framerate; /* not use */
-
-	sensor_info->SensorClockPolarity = SENSOR_CLOCK_POLARITY_LOW;
-	sensor_info->SensorClockFallingPolarity = SENSOR_CLOCK_POLARITY_LOW; /* not use */
-	sensor_info->SensorHsyncPolarity = SENSOR_CLOCK_POLARITY_LOW; // inverse with datasheet
-	sensor_info->SensorVsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
-	sensor_info->SensorInterruptDelayLines = 4; /* not use */
-	sensor_info->SensorResetActiveHigh = FALSE; /* not use */
-	sensor_info->SensorResetDelayCount = 5; /* not use */
-
-	sensor_info->SensroInterfaceType = imgsensor_info.sensor_interface_type;
-	//sensor_info->MIPIsensorType = imgsensor_info.mipi_sensor_type;
-	//sensor_info->SettleDelayMode = imgsensor_info.mipi_settle_delay_mode;
-	sensor_info->SensorOutputDataFormat = imgsensor_info.sensor_output_dataformat;
-
-	sensor_info->CaptureDelayFrame = imgsensor_info.cap_delay_frame; 
-	sensor_info->PreviewDelayFrame = imgsensor_info.pre_delay_frame; 
-	sensor_info->VideoDelayFrame = imgsensor_info.video_delay_frame;
-	sensor_info->HighSpeedVideoDelayFrame = imgsensor_info.hs_video_delay_frame;
-	sensor_info->SlimVideoDelayFrame = imgsensor_info.slim_video_delay_frame;
-
-	sensor_info->SensorMasterClockSwitch = 0; /* not use */
-	sensor_info->SensorDrivingCurrent = imgsensor_info.isp_driving_current;
-	
-	sensor_info->AEShutDelayFrame = imgsensor_info.ae_shut_delay_frame; 		 /* The frame of setting shutter default 0 for TG int */
-	sensor_info->AESensorGainDelayFrame = imgsensor_info.ae_sensor_gain_delay_frame;	/* The frame of setting sensor gain */
-	sensor_info->AEISPGainDelayFrame = imgsensor_info.ae_ispGain_delay_frame;	
-	sensor_info->IHDR_Support = imgsensor_info.ihdr_support;
-	sensor_info->IHDR_LE_FirstLine = imgsensor_info.ihdr_le_firstline;
-	sensor_info->SensorModeNum = imgsensor_info.sensor_mode_num;
-	
-	sensor_info->SensorMIPILaneNumber = imgsensor_info.mipi_lane_num; 
-	sensor_info->SensorClockFreq = imgsensor_info.mclk;
-	sensor_info->SensorClockDividCount = 3; /* not use */
-	sensor_info->SensorClockRisingCount = 0;
-	sensor_info->SensorClockFallingCount = 2; /* not use */
-	sensor_info->SensorPixelClockCount = 3; /* not use */
-	sensor_info->SensorDataLatchCount = 2; /* not use */
-	
-	sensor_info->MIPIDataLowPwr2HighSpeedTermDelayCount = 0; 
-	sensor_info->MIPICLKLowPwr2HighSpeedTermDelayCount = 0;
-	sensor_info->SensorWidthSampling = 0;  // 0 is default 1x
-	sensor_info->SensorHightSampling = 0;	// 0 is default 1x 
-	sensor_info->SensorPacketECCOrder = 1;
-
-	switch (scenario_id) {
-		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-			sensor_info->SensorGrabStartX = imgsensor_info.pre.startx; 
-			sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;		
-			
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
-			
-			break;
-		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
-			sensor_info->SensorGrabStartX = imgsensor_info.cap.startx; 
-			sensor_info->SensorGrabStartY = imgsensor_info.cap.starty;
-				  
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.cap.mipi_data_lp2hs_settle_dc; 
-
-			break;	 
-		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-			
-			sensor_info->SensorGrabStartX = imgsensor_info.normal_video.startx; 
-			sensor_info->SensorGrabStartY = imgsensor_info.normal_video.starty;
-	   
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.normal_video.mipi_data_lp2hs_settle_dc; 
-
-			break;	  
-		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:			
-			sensor_info->SensorGrabStartX = imgsensor_info.hs_video.startx; 
-			sensor_info->SensorGrabStartY = imgsensor_info.hs_video.starty;
-				  
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.hs_video.mipi_data_lp2hs_settle_dc; 
-
-			break;
-		case MSDK_SCENARIO_ID_SLIM_VIDEO:
-			sensor_info->SensorGrabStartX = imgsensor_info.slim_video.startx; 
-			sensor_info->SensorGrabStartY = imgsensor_info.slim_video.starty;
-				  
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.slim_video.mipi_data_lp2hs_settle_dc; 
-
-			break;
-		default:			
-			sensor_info->SensorGrabStartX = imgsensor_info.pre.startx; 
-			sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;		
-			
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
-			break;
-	}
-	
-	return ERROR_NONE;
-}	/*	get_info  */
-
-
-static kal_uint32 control(MSDK_SCENARIO_ID_ENUM scenario_id, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("scenario_id = %d\n", scenario_id);
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.current_scenario_id = scenario_id;
-	spin_unlock(&imgsensor_drv_lock);
-	switch (scenario_id) {
-		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-			preview(image_window, sensor_config_data);
-			break;
-		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
-			capture(image_window, sensor_config_data);
-			break;	
-		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-			normal_video(image_window, sensor_config_data);
-			break;	  
-		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
-			hs_video(image_window, sensor_config_data);
-			break;
-		case MSDK_SCENARIO_ID_SLIM_VIDEO:
-			slim_video(image_window, sensor_config_data);
-			break;	  
-		default:
-			LOG_INF("Error ScenarioId setting");
-			preview(image_window, sensor_config_data);
-			return ERROR_INVALID_SCENARIO_ID;
-	}
-	return ERROR_NONE;
-}	/* control() */
-
-
-
-static kal_uint32 set_video_mode(UINT16 framerate)
-{
-	LOG_INF("framerate = %d\n ", framerate);
-	// SetVideoMode Function should fix framerate
-	if (framerate == 0)
-		// Dynamic frame rate
-		return ERROR_NONE;
-	spin_lock(&imgsensor_drv_lock);
-	if ((framerate == 300) && (imgsensor.autoflicker_en == KAL_TRUE))
-		imgsensor.current_fps = 296;
-	else if ((framerate == 150) && (imgsensor.autoflicker_en == KAL_TRUE))
-		imgsensor.current_fps = 146;
-	else
-		imgsensor.current_fps = framerate;
-	spin_unlock(&imgsensor_drv_lock);
-	set_max_framerate(imgsensor.current_fps,1);
-
-	return ERROR_NONE;
-}
-
-static kal_uint32 set_auto_flicker_mode(kal_bool enable, UINT16 framerate)
-{
-	LOG_INF("enable = %d, framerate = %d \n", enable, framerate);
-	spin_lock(&imgsensor_drv_lock);
-	if (enable) //enable auto flicker	  
-		imgsensor.autoflicker_en = KAL_TRUE;
-	else //Cancel Auto flick
-		imgsensor.autoflicker_en = KAL_FALSE;
-	spin_unlock(&imgsensor_drv_lock);
-	return ERROR_NONE;
-}
-
-
-static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 framerate) 
-{
-	kal_uint32 frame_length;
-  
-	LOG_INF("scenario_id = %d, framerate = %d\n", scenario_id, framerate);
-
-	switch (scenario_id) {
-		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-			frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
-			imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();			
-			break;			
-		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-			if(framerate == 0)
-				return ERROR_NONE;
-			frame_length = imgsensor_info.normal_video.pclk / framerate * 10 / imgsensor_info.normal_video.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.normal_video.framelength) ? (frame_length - imgsensor_info.normal_video.framelength) : 0;			
-			imgsensor.frame_length = imgsensor_info.normal_video.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();			
-			break;
-		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
-		//case MSDK_SCENARIO_ID_CAMERA_ZSD:			
-			frame_length = imgsensor_info.cap.pclk / framerate * 10 / imgsensor_info.cap.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.cap.framelength) ? (frame_length - imgsensor_info.cap.framelength) : 0;
-			imgsensor.frame_length = imgsensor_info.cap.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();			
-			break;	
-		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
-			frame_length = imgsensor_info.hs_video.pclk / framerate * 10 / imgsensor_info.hs_video.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.hs_video.framelength) ? (frame_length - imgsensor_info.hs_video.framelength) : 0;
-			imgsensor.frame_length = imgsensor_info.hs_video.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();			
-			break;
-		case MSDK_SCENARIO_ID_SLIM_VIDEO:
-			frame_length = imgsensor_info.slim_video.pclk / framerate * 10 / imgsensor_info.slim_video.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.slim_video.framelength) ? (frame_length - imgsensor_info.slim_video.framelength): 0;	
-			imgsensor.frame_length = imgsensor_info.slim_video.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();			
-			break;		
-		default:  //coding with  preview scenario by default
-			frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
-			imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();	
-			LOG_INF("error scenario_id = %d, we use preview scenario \n", scenario_id);
-			break;
-	}	
-	return ERROR_NONE;
-}
-
-
-static kal_uint32 get_default_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 *framerate) 
-{
-	LOG_INF("scenario_id = %d\n", scenario_id);
-
-	switch (scenario_id) {
-		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-			*framerate = imgsensor_info.pre.max_framerate;
-			break;
-		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-			*framerate = imgsensor_info.normal_video.max_framerate;
-			break;
-		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
-			*framerate = imgsensor_info.cap.max_framerate;
-			break;		
-		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
-			*framerate = imgsensor_info.hs_video.max_framerate;
-			break;
-		case MSDK_SCENARIO_ID_SLIM_VIDEO: 
-			*framerate = imgsensor_info.slim_video.max_framerate;
-			break;
-		default:
-			break;
-	}
-
-	return ERROR_NONE;
-}
-
-static kal_uint32 set_test_pattern_mode(kal_bool enable)
-{
-	LOG_INF("enable: %d\n", enable);
-
-	if (enable) {
-		// 0x5E00[8]: 1 enable,  0 disable
-		// 0x5E00[1:0]; 00 Color bar, 01 Random Data, 10 Square, 11 BLACK
-		write_cmos_sensor(0x5E00, 0x80);
-	} else {
-		// 0x5E00[8]: 1 enable,  0 disable
-		// 0x5E00[1:0]; 00 Color bar, 01 Random Data, 10 Square, 11 BLACK
-		write_cmos_sensor(0x5E00, 0x00);
-	}	 
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.test_pattern = enable;
-	spin_unlock(&imgsensor_drv_lock);
-	return ERROR_NONE;
-}
-
-static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
-                             UINT8 *feature_para,UINT32 *feature_para_len)
-{
-    UINT16 *feature_return_para_16=(UINT16 *) feature_para;
-    UINT16 *feature_data_16=(UINT16 *) feature_para;
-    UINT32 *feature_return_para_32=(UINT32 *) feature_para;
-    UINT32 *feature_data_32=(UINT32 *) feature_para;
-    unsigned long long *feature_data=(unsigned long long *) feature_para;
-    unsigned long long *feature_return_para=(unsigned long long *) feature_para;
-
-    SENSOR_WINSIZE_INFO_STRUCT *wininfo;
-    MSDK_SENSOR_REG_INFO_STRUCT *sensor_reg_data=(MSDK_SENSOR_REG_INFO_STRUCT *) feature_para;
-
-    LOG_INF("feature_id = %d\n", feature_id);
-    switch (feature_id) {
-        case SENSOR_FEATURE_GET_PERIOD:
-            *feature_return_para_16++ = imgsensor.line_length;
-            *feature_return_para_16 = imgsensor.frame_length;
-            *feature_para_len=4;
-            break;
-        case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:
-            *feature_return_para_32 = imgsensor.pclk;
-            *feature_para_len=4;
-            break;
-        case SENSOR_FEATURE_SET_ESHUTTER:
-            set_shutter(*feature_data);
-            break;
-        case SENSOR_FEATURE_SET_NIGHTMODE:
-            night_mode((BOOL) *feature_data);
-            break;
-        case SENSOR_FEATURE_SET_GAIN:
-            set_gain((UINT16) *feature_data);
-            break;
-        case SENSOR_FEATURE_SET_FLASHLIGHT:
-            break;
-        case SENSOR_FEATURE_SET_ISP_MASTER_CLOCK_FREQ:
-            break;
-        case SENSOR_FEATURE_SET_REGISTER:
-            write_cmos_sensor(sensor_reg_data->RegAddr, sensor_reg_data->RegData);
-            break;
-        case SENSOR_FEATURE_GET_REGISTER:
-            sensor_reg_data->RegData = read_cmos_sensor(sensor_reg_data->RegAddr);
-            break;
-        case SENSOR_FEATURE_GET_LENS_DRIVER_ID:
-            // get the lens driver ID from EEPROM or just return LENS_DRIVER_ID_DO_NOT_CARE
-            // if EEPROM does not exist in camera module.
-            *feature_return_para_32=LENS_DRIVER_ID_DO_NOT_CARE;
-            *feature_para_len=4;
-            break;
-        case SENSOR_FEATURE_SET_VIDEO_MODE:
-            set_video_mode(*feature_data);
-            break;
-        case SENSOR_FEATURE_CHECK_SENSOR_ID:
-            get_imgsensor_id(feature_return_para_32);
-            break;
-        case SENSOR_FEATURE_SET_AUTO_FLICKER_MODE:
-            set_auto_flicker_mode((BOOL)*feature_data_16,*(feature_data_16+1));
-            break;
-        case SENSOR_FEATURE_SET_MAX_FRAME_RATE_BY_SCENARIO:
-            set_max_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data, *(feature_data+1));
-            break;
-        case SENSOR_FEATURE_GET_DEFAULT_FRAME_RATE_BY_SCENARIO:
-            get_default_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*(feature_data), (MUINT32 *)(uintptr_t)(*(feature_data+1)));
-            break;
-        case SENSOR_FEATURE_SET_TEST_PATTERN:
-            set_test_pattern_mode((BOOL)*feature_data);
-            break;
-        case SENSOR_FEATURE_GET_TEST_PATTERN_CHECKSUM_VALUE: //for factory mode auto testing
-            *feature_return_para_32 = imgsensor_info.checksum_value;
-            *feature_para_len=4;
-            break;
-        case SENSOR_FEATURE_SET_FRAMERATE:
-            LOG_INF("current fps :%d\n", (UINT32)*feature_data);
-            spin_lock(&imgsensor_drv_lock);
-            imgsensor.current_fps = *feature_data;
-            spin_unlock(&imgsensor_drv_lock);
-            break;
-        case SENSOR_FEATURE_SET_HDR:
-            LOG_INF("ihdr enable :%d\n", (BOOL)*feature_data);
-            spin_lock(&imgsensor_drv_lock);
-            imgsensor.ihdr_en = (BOOL)*feature_data;
-            spin_unlock(&imgsensor_drv_lock);
-            break;
-        case SENSOR_FEATURE_GET_CROP_INFO:
-            LOG_INF("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n", (UINT32)*feature_data);
-
-            wininfo = (SENSOR_WINSIZE_INFO_STRUCT *)(uintptr_t)(*(feature_data+1));
-
-            switch (*feature_data_32) {
-                case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
-                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[1],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-                    break;
-                case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[2],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-                    break;
-                case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
-                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[3],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-                    break;
-                case MSDK_SCENARIO_ID_SLIM_VIDEO:
-                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[4],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-                    break;
-                case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-                default:
-                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[0],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-                    break;
-            }
-        case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
-            LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",(UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
-            ihdr_write_shutter_gain((UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
-            break;
-        default:
-            break;
-    }
-
-    return ERROR_NONE;
-}    /*    feature_control()  */
-
-
-static SENSOR_FUNCTION_STRUCT sensor_func = {
-	open,
-	get_info,
-	get_resolution,
-	feature_control,
-	control,
-	close
-};
-
-
-UINT32 OV8858_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
-{
-	/* To Do : Check Sensor status here */
-	if (pfFunc!=NULL)
-		*pfFunc=&sensor_func;
-	return ERROR_NONE;
-}	/*	OV5693_MIPI_RAW_SensorInit	*/
-
-UINT32 OV8858R2A_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
-{
-	/* To Do : Check Sensor status here */
-	if (pfFunc!=NULL)
-		*pfFunc=&sensor_func;
-	return ERROR_NONE;
-}	/*	OV5693_MIPI_RAW_SensorInit	*/
-
-
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6753/ov8858_mipi_raw/ov8858mipiraw_Sensor.c~ b/drivers/misc/mediatek/imgsensor/src/mt6753/ov8858_mipi_raw/ov8858mipiraw_Sensor.c~
deleted file mode 100755
index 729b6cb..0000000
--- a/drivers/misc/mediatek/imgsensor/src/mt6753/ov8858_mipi_raw/ov8858mipiraw_Sensor.c~
+++ /dev/null
@@ -1,2395 +0,0 @@
-/*****************************************************************************
- *
- * Filename:
- * ---------
- *	 OV8858mipiraw_sensor.c
- *
- * Project:
- * --------
- *	 ALPS MT6795
- *
- * Description:
- * ------------
- *	 Source code of Sensor driver
- *
- *	PengtaoFan
- *------------------------------------------------------------------------------
- * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
- *============================================================================
- ****************************************************************************/
-
-#include <linux/videodev2.h>
-#include <linux/i2c.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/cdev.h>
-#include <linux/uaccess.h>
-#include <linux/fs.h>
-#include <asm/atomic.h>
-//#include <asm/system.h>
-#include <linux/xlog.h>
-
-#include "kd_camera_hw.h"
-#include "kd_imgsensor.h"
-#include "kd_imgsensor_define.h"
-#include "kd_imgsensor_errcode.h"
-
-#include "ov8858mipiraw_Sensor.h"
-
-#define PFX "OV8858"
-
-//#define OV8858R2AOTP
-
-//#define LOG_WRN(format, args...) xlog_printk(ANDROID_LOG_WARN ,PFX, "[%S] " format, __FUNCTION__, ##args)
-//#defineLOG_INF(format, args...) xlog_printk(ANDROID_LOG_INFO ,PFX, "[%s] " format, __FUNCTION__, ##args)
-//#define LOG_DBG(format, args...) xlog_printk(ANDROID_LOG_DEBUG ,PFX, "[%S] " format, __FUNCTION__, ##args)
-#define LOG_INF(format, args...)	xlog_printk(ANDROID_LOG_INFO   , PFX, "[%s] " format, __FUNCTION__, ##args)
-typedef enum {
-	OV8858R2A,
-	OV8858R1A
-}OV8858_VERSION;
-
-OV8858_VERSION ov8858version = OV8858R2A;
-
-static DEFINE_SPINLOCK(imgsensor_drv_lock);
-
-static imgsensor_info_struct imgsensor_info = { 
-	.sensor_id = OV8858_SENSOR_ID,		//record sensor id defined in Kd_imgsensor.h
-	
-	.checksum_value = 0xd14be45,		//checksum value for Camera Auto Test
-	
-	.pre = {
-		.pclk = 74400000,				//record different mode's pclk
-		.linelength  = 1928,				//record different mode's linelength
-		.framelength = 1284,			//record different mode's framelength
-		.startx = 0,					//record different mode's startx of grabwindow
-		.starty = 0,					//record different mode's starty of grabwindow
-		.grabwindow_width  = 1632,		//record different mode's width of grabwindow
-		.grabwindow_height = 1224,		//record different mode's height of grabwindow
-		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
-		.mipi_data_lp2hs_settle_dc = 23,
-		/*	 following for GetDefaultFramerateByScenario()	*/
-		.max_framerate = 300,	
-	},
-	.cap = {
-		.pclk = 148800000,
-		.linelength  = 1940,
-		.framelength = 2556,
-		.startx = 0,
-		.starty = 0,
-		.grabwindow_width  = 3264,
-		.grabwindow_height = 2448,
-		.mipi_data_lp2hs_settle_dc = 23,
-		.max_framerate = 300,
-	},
-	.cap1 = {							//capture for PIP 24fps relative information, capture1 mode must use same framelength, linelength with Capture mode for shutter calculate
-		.pclk = 148800000,
-		.linelength  = 2425,
-		.framelength = 4090,//MODIFY FOR 15FPS FOR MT6735 //2556
-		.startx = 0,
-		.starty = 0,
-		.grabwindow_width  = 3264,
-		.grabwindow_height = 2448,
-		.mipi_data_lp2hs_settle_dc = 23,
-		.max_framerate = 150,
-	},
-	.normal_video = {
-		.pclk = 148800000,
-		.linelength  = 1940,
-		.framelength = 2556,
-		.startx = 0,
-		.starty = 0,
-		.grabwindow_width  = 3264,
-		.grabwindow_height = 2448,
-		.mipi_data_lp2hs_settle_dc = 23,
-		.max_framerate = 300,
-	},
-	.hs_video = {
-		.pclk = 148800000,				//record different mode's pclk
-		.linelength  = 2270,				//record different mode's linelength
-		.framelength = 546,			//record different mode's framelength
-		.startx = 0,					//record different mode's startx of grabwindow
-		.starty = 0,					//record different mode's starty of grabwindow
-		.grabwindow_width  = 640,		//record different mode's width of grabwindow
-		.grabwindow_height = 480,		//record different mode's height of grabwindow
-		/*	 following for  MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
-		.mipi_data_lp2hs_settle_dc = 30,
-		/*	 following for GetDefaultFramerateByScenario()	*/
-		.max_framerate = 1200,
-	},
-	.slim_video = {
-		.pclk = 74400000,				//record different mode's pclk
-		.linelength  = 1928,				//record different mode's linelength
-		.framelength = 1284,			//record different mode's framelength
-		.startx = 0,					//record different mode's startx of grabwindow
-		.starty = 0,					//record different mode's starty of grabwindow
-		.grabwindow_width  = 1632,		//record different mode's width of grabwindow
-		.grabwindow_height = 1224,		//record different mode's height of grabwindow
-		/*	 following for MIPIDataLowPwr2HighSpeedSettleDelayCount by different scenario	*/
-		.mipi_data_lp2hs_settle_dc = 30,
-		/*	 following for GetDefaultFramerateByScenario()	*/
-		.max_framerate = 300,	
-
-	},
-	.margin = 4,			//sensor framelength & shutter margin
-	.min_shutter = 4,		//min shutter
-	.max_frame_length = 0x90f7,//max framelength by sensor register's limitation
-	.ae_shut_delay_frame = 0,	//shutter delay frame for AE cycle, 2 frame with ispGain_delay-shut_delay=2-0=2
-	.ae_sensor_gain_delay_frame = 0,//sensor gain delay frame for AE cycle,2 frame with ispGain_delay-sensor_gain_delay=2-0=2
-	.ae_ispGain_delay_frame = 2,//isp gain delay frame for AE cycle
-	.ihdr_support = 1,	  //1, support; 0,not support
-	.ihdr_le_firstline = 0,  //1,le first ; 0, se first
-	.sensor_mode_num = 5,	  //support sensor mode num ,don't support Slow motion
-	
-	.cap_delay_frame = 3,		//enter capture delay frame num
-	.pre_delay_frame = 3, 		//enter preview delay frame num
-	.video_delay_frame = 3,		//enter video delay frame num
-	.hs_video_delay_frame = 3,	//enter high speed video  delay frame num
-	.slim_video_delay_frame = 3,//enter slim video delay frame num
-	
-	.isp_driving_current = ISP_DRIVING_8MA, //mclk driving current
-	.sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,//sensor_interface_type
-	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_RAW_B,//sensor output first pixel color
-	.mclk = 24,//mclk value, suggest 24 or 26 for 24Mhz or 26Mhz
-	.mipi_lane_num = SENSOR_MIPI_4_LANE,//mipi lane num
-	.i2c_addr_table = {0x42, 0x20,0x6C,0xff},//record sensor support all write id addr, only supprt 4must end with 0xff
-};
-
-
-static imgsensor_struct imgsensor = {
-	.mirror = IMAGE_NORMAL,				//mirrorflip information
-	.sensor_mode = IMGSENSOR_MODE_INIT, //IMGSENSOR_MODE enum value,record current sensor mode,such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video
-	.shutter = 0x4C00,					//current shutter
-	.gain = 0x200,						//current gain
-	.dummy_pixel = 0,					//current dummypixel
-	.dummy_line = 0,					//current dummyline
-	.current_fps = 0,  //full size current fps : 24fps for PIP, 30fps for Normal or ZSD
-	.autoflicker_en = KAL_FALSE,  //auto flicker enable: KAL_FALSE for disable auto flicker, KAL_TRUE for enable auto flicker
-	.test_pattern = KAL_FALSE,		//test pattern mode or not. KAL_FALSE for in test pattern mode, KAL_TRUE for normal output
-	.current_scenario_id = MSDK_SCENARIO_ID_CAMERA_PREVIEW,//current scenario id
-	.ihdr_en = 0, //sensor need support LE, SE with HDR feature
-	.i2c_write_id = 0x42,//record current sensor's i2c write id
-};
-
-
-/* Sensor output window information*/
-static SENSOR_WINSIZE_INFO_STRUCT imgsensor_winsize_info[5] =	 
-{{ 3296, 2480,	  12,	12, 3272, 2456, 3264, 2452,   4,	2, 1632, 1224,	 0, 0, 1632, 1224}, // Preview 
- { 3296, 2480,	  12,	12, 3272, 2456, 3264, 2452,   4,	2, 3264, 2448,	 0, 0, 3264, 2448}, // capture 
- { 3296, 2480,	  12,	12, 3272, 2456, 3264, 2452,   4,	2, 3264, 2448,	 0, 0, 3264, 2448}, // video 
- { 3296, 2480,	  12,	12, 3272, 2456,  640,  480,   4,	2,  640,  480,	 0, 0,  640,  480}, //hight speed video 
- { 3296, 2480,	  12,	12, 3272, 2456, 3264, 2452,   4,	2, 1632, 1224,	 0, 0, 1632, 1224}};// slim video 
-
-static kal_uint16 read_cmos_sensor(kal_uint32 addr)
-{
-	kal_uint16 get_byte=0;
-
-	char pu_send_cmd[2] = {(char)(addr >> 8), (char)(addr & 0xFF) };
-	iReadRegI2C(pu_send_cmd, 2, (u8*)&get_byte, 1, imgsensor.i2c_write_id);
-
-	return get_byte;
-}
-
-static void write_cmos_sensor(kal_uint32 addr, kal_uint32 para)
-{
-	char pu_send_cmd[3] = {(char)(addr >> 8), (char)(addr & 0xFF), (char)(para & 0xFF)};
-	iWriteRegI2C(pu_send_cmd, 3, imgsensor.i2c_write_id);
-}
-
-static void set_dummy()
-{
-	LOG_INF("dummyline = %d, dummypixels = %d \n", imgsensor.dummy_line, imgsensor.dummy_pixel);
-	/* you can set dummy by imgsensor.dummy_line and imgsensor.dummy_pixel, or you can set dummy by imgsensor.frame_length and imgsensor.line_length */
-	write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
-	write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);	  
-	write_cmos_sensor(0x380c, imgsensor.line_length >> 8);
-	write_cmos_sensor(0x380d, imgsensor.line_length & 0xFF);
-  
-}	/*	set_dummy  */
-
-
-static void set_max_framerate(UINT16 framerate,kal_bool min_framelength_en)
-{
-	kal_int16 dummy_line;
-	kal_uint32 frame_length = imgsensor.frame_length;
-	//unsigned long flags;
-
-	LOG_INF("framerate = %d, min framelength should enable? \n", framerate,min_framelength_en);
-   
-	frame_length = imgsensor.pclk / framerate * 10 / imgsensor.line_length;
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.frame_length = (frame_length > imgsensor.min_frame_length) ? frame_length : imgsensor.min_frame_length; 
-	imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
-	//dummy_line = frame_length - imgsensor.min_frame_length;
-	//if (dummy_line < 0)
-		//imgsensor.dummy_line = 0;
-	//else
-		//imgsensor.dummy_line = dummy_line;
-	//imgsensor.frame_length = frame_length + imgsensor.dummy_line;
-	if (imgsensor.frame_length > imgsensor_info.max_frame_length)
-	{
-		imgsensor.frame_length = imgsensor_info.max_frame_length;
-		imgsensor.dummy_line = imgsensor.frame_length - imgsensor.min_frame_length;
-	}
-	if (min_framelength_en)
-		imgsensor.min_frame_length = imgsensor.frame_length;
-	spin_unlock(&imgsensor_drv_lock);
-	set_dummy();
-}	/*	set_max_framerate  */
-
-
-static void write_shutter(kal_uint16 shutter)
-{
-	kal_uint16 realtime_fps = 0;
-	kal_uint32 frame_length = 0;
-	   
-	/* 0x3500, 0x3501, 0x3502 will increase VBLANK to get exposure larger than frame exposure */
-	/* AE doesn't update sensor gain at capture mode, thus extra exposure lines must be updated here. */
-	
-	// OV Recommend Solution
-	// if shutter bigger than frame_length, should extend frame length first
-	spin_lock(&imgsensor_drv_lock);
-	if (shutter > imgsensor.min_frame_length - imgsensor_info.margin)		
-		imgsensor.frame_length = shutter + imgsensor_info.margin;
-	else
-		imgsensor.frame_length = imgsensor.min_frame_length;
-	if (imgsensor.frame_length > imgsensor_info.max_frame_length)
-		imgsensor.frame_length = imgsensor_info.max_frame_length;
-	spin_unlock(&imgsensor_drv_lock);
-	shutter = (shutter < imgsensor_info.min_shutter) ? imgsensor_info.min_shutter : shutter;
-	shutter = (shutter > (imgsensor_info.max_frame_length - imgsensor_info.margin)) ? (imgsensor_info.max_frame_length - imgsensor_info.margin) : shutter;
-	
-	if (imgsensor.autoflicker_en) { 
-		realtime_fps = imgsensor.pclk / imgsensor.line_length * 10 / imgsensor.frame_length;
-		if(realtime_fps >= 297 && realtime_fps <= 305)
-			set_max_framerate(296,0);
-		else if(realtime_fps >= 147 && realtime_fps <= 150)
-			set_max_framerate(146,0);	
-	} else {
-		// Extend frame length
-		write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
-		write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
-	}
-
-	// Update Shutter
-	write_cmos_sensor(0x3500, (shutter>>12) & 0x0F);
-	write_cmos_sensor(0x3501, (shutter>>4) & 0xFF);
-	write_cmos_sensor(0x3502, (shutter<<4) & 0xF0);	
-	LOG_INF("Exit! shutter =%d, framelength =%d\n", shutter,imgsensor.frame_length);
-
-	//LOG_INF("frame_length = %d ", frame_length);
-	
-}	/*	write_shutter  */
-
-
-
-/*************************************************************************
-* FUNCTION
-*	set_shutter
-*
-* DESCRIPTION
-*	This function set e-shutter of sensor to change exposure time.
-*
-* PARAMETERS
-*	iShutter : exposured lines
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static void set_shutter(kal_uint16 shutter)
-{
-	unsigned long flags;
-	kal_uint16 realtime_fps = 0;
-	kal_uint32 frame_length = 0;
-	spin_lock_irqsave(&imgsensor_drv_lock, flags);
-	imgsensor.shutter = shutter;
-	spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
-	
-	//write_shutter(shutter);
-	/* 0x3500, 0x3501, 0x3502 will increase VBLANK to get exposure larger than frame exposure */
-	/* AE doesn't update sensor gain at capture mode, thus extra exposure lines must be updated here. */
-	
-	// OV Recommend Solution
-	// if shutter bigger than frame_length, should extend frame length first
-	spin_lock(&imgsensor_drv_lock);
-	if (shutter > imgsensor.min_frame_length - imgsensor_info.margin)		
-		imgsensor.frame_length = shutter + imgsensor_info.margin;
-	else
-		imgsensor.frame_length = imgsensor.min_frame_length;
-	if (imgsensor.frame_length > imgsensor_info.max_frame_length)
-		imgsensor.frame_length = imgsensor_info.max_frame_length;
-	spin_unlock(&imgsensor_drv_lock);
-	shutter = (shutter < imgsensor_info.min_shutter) ? imgsensor_info.min_shutter : shutter;
-	shutter = (shutter > (imgsensor_info.max_frame_length - imgsensor_info.margin)) ? (imgsensor_info.max_frame_length - imgsensor_info.margin) : shutter;
-	
-	if (imgsensor.autoflicker_en) { 
-		realtime_fps = imgsensor.pclk / imgsensor.line_length * 10 / imgsensor.frame_length;
-		if(realtime_fps >= 297 && realtime_fps <= 305)
-			set_max_framerate(296,0);
-		else if(realtime_fps >= 147 && realtime_fps <= 150)
-			set_max_framerate(146,0);	
-		else {
-		// Extend frame length
-		write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
-		write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
-		}
-	} else {
-		// Extend frame length
-		write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
-		write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
-	}
-
-	// Update Shutter
-	write_cmos_sensor(0x3502, (shutter << 4) & 0xFF);
-	write_cmos_sensor(0x3501, (shutter >> 4) & 0xFF);	  
-	write_cmos_sensor(0x3500, (shutter >> 12) & 0x0F);	
-	LOG_INF("Exit! shutter =%d, framelength =%d\n", shutter,imgsensor.frame_length);
-
-}
-
-static kal_uint16 gain2reg(const kal_uint16 gain)
-{
-	kal_uint16 reg_gain = 0x0000;
-	
-	reg_gain = gain*2;
-	//reg_gain = reg_gain & 0xFFFF;
-	return (kal_uint16)reg_gain;
-}
-
-/*************************************************************************
-* FUNCTION
-*	set_gain
-*
-* DESCRIPTION
-*	This function is to set global gain to sensor.
-*
-* PARAMETERS
-*	iGain : sensor global gain(base: 0x40)
-*
-* RETURNS
-*	the actually gain set to sensor.
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint16 set_gain(kal_uint16 gain)
-{
-	LOG_INF("set_gain %d \n", gain);
-	kal_uint16 reg_gain;
-	if (gain < BASEGAIN || gain > 10 * BASEGAIN) {
-		LOG_INF("Error gain setting");
-
-		if (gain < BASEGAIN)
-			gain = BASEGAIN;
-		else if (gain > 10 * BASEGAIN)
-			gain = 10 * BASEGAIN;		 
-	}
-
-	//reg_gain = gain2reg(gain);
-	reg_gain = gain*2;
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.gain = reg_gain; 
-	spin_unlock(&imgsensor_drv_lock);
-	LOG_INF("gain = %d , reg_gain = 0x%x\n ", gain, reg_gain);
-
-	write_cmos_sensor(0x3508, (reg_gain>>8));
-	write_cmos_sensor(0x3509, (reg_gain&0xFF));    
-	return gain;
-}	/*	set_gain  */
-
-static void ihdr_write_shutter_gain(kal_uint16 le, kal_uint16 se, kal_uint16 gain)
-{
-	LOG_INF("le:0x%x, se:0x%x, gain:0x%x\n",le,se,gain);
-	if (imgsensor.ihdr_en) {
-		
-		spin_lock(&imgsensor_drv_lock);
-			if (le > imgsensor.min_frame_length - imgsensor_info.margin)		
-				imgsensor.frame_length = le + imgsensor_info.margin;
-			else
-				imgsensor.frame_length = imgsensor.min_frame_length;
-			if (imgsensor.frame_length > imgsensor_info.max_frame_length)
-				imgsensor.frame_length = imgsensor_info.max_frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			if (le < imgsensor_info.min_shutter) le = imgsensor_info.min_shutter;
-			if (se < imgsensor_info.min_shutter) se = imgsensor_info.min_shutter;
-			
-			
-		// Extend frame length first
-		write_cmos_sensor(0x380e, imgsensor.frame_length >> 8);
-		write_cmos_sensor(0x380f, imgsensor.frame_length & 0xFF);
-
-		write_cmos_sensor(0x3502, (le << 4) & 0xFF);
-		write_cmos_sensor(0x3501, (le >> 4) & 0xFF);	 
-		write_cmos_sensor(0x3500, (le >> 12) & 0x0F);
-		
-		write_cmos_sensor(0x3512, (se << 4) & 0xFF); 
-		write_cmos_sensor(0x3511, (se >> 4) & 0xFF);
-		write_cmos_sensor(0x3510, (se >> 12) & 0x0F); 
-
-		set_gain(gain);
-	}
-
-}
-
-
-
-static void set_mirror_flip(kal_uint8 image_mirror)
-{
-	LOG_INF("image_mirror = %d\n", image_mirror);
-
-	/********************************************************
-	   *
-	   *   0x3820[2] ISP Vertical flip
-	   *   0x3820[1] Sensor Vertical flip
-	   *
-	   *   0x3821[2] ISP Horizontal mirror
-	   *   0x3821[1] Sensor Horizontal mirror
-	   *
-	   *   ISP and Sensor flip or mirror register bit should be the same!!
-	   *
-	   ********************************************************/
-	
-	switch (image_mirror) {
-		case IMAGE_NORMAL:
-			write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x00));
-			write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x06));
-			break;
-		case IMAGE_H_MIRROR:
-			write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x00));
-			write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x00));
-			break;
-		case IMAGE_V_MIRROR:
-			write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x06));
-			write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x06));		
-			break;
-		case IMAGE_HV_MIRROR:
-			write_cmos_sensor(0x3820,((read_cmos_sensor(0x3820) & 0xF9) | 0x06));
-			write_cmos_sensor(0x3821,((read_cmos_sensor(0x3821) & 0xF9) | 0x00));
-			break;
-		default:
-			LOG_INF("Error image_mirror setting\n");
-	}
-
-}
-
-/*************************************************************************
-* FUNCTION
-*	night_mode
-*
-* DESCRIPTION
-*	This function night mode of sensor.
-*
-* PARAMETERS
-*	bEnable: KAL_TRUE -> enable night mode, otherwise, disable night mode
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static void night_mode(kal_bool enable)
-{
-/*No Need to implement this function*/ 
-}	/*	night_mode	*/
-static void r1asensor_init(void)
-{
-	LOG_INF("E\n");
-//   ;-----------------------------------------
-//   @@ OV8858R1A Key 1632x1224_30FPS_MIPI_2LANE(Binning)
-//   100 99 1632 1224 ; Resolution
-//   102 80 1
-//   102 3601 bb8;30fps
-//   102 40 0 ; HDR Mode off
-//   ;FPGA set-up
-//   c8 01 f2 ;MIPI FPGA
-//   ;
-//   CL 100 100;delay
-//   ;;
-//   ;; MIPI=720Mbps, SysClk=144Mhz,Dac Clock=360Mhz.
-//   ;;
-//   ;;
-//   ;; v00_EM_AM14 (02/26/2014) : initial setting
-//   ;;
-//   ;; AM09 : Add 1080P,720P, HDR and 2 Lane Formats
-//   ;;      : Update the setting for R1A final Version(EK)
-//   ;; AM14 : fullwell 7K
-
-	write_cmos_sensor(0x3605, 0x30);
-	write_cmos_sensor(0x360b, 0x06);
-	write_cmos_sensor(0x360c, 0xdc);
-	write_cmos_sensor(0x3617, 0x90);
-	write_cmos_sensor(0x3618, 0x56);
-	write_cmos_sensor(0x361b, 0x00);
-	write_cmos_sensor(0x3633, 0x0c);
-	write_cmos_sensor(0x3634, 0x0c);
-	write_cmos_sensor(0x3635, 0x0c);
-	write_cmos_sensor(0x3636, 0x0c);
-	write_cmos_sensor(0x3501, 0x4b);
-	write_cmos_sensor(0x3502, 0xc0);
-	write_cmos_sensor(0x3503, 0x00);
-	write_cmos_sensor(0x3508, 0x01);
-	write_cmos_sensor(0x3706, 0x6a);
-	write_cmos_sensor(0x370b, 0x6a);
-	write_cmos_sensor(0x3750, 0x00);
-	write_cmos_sensor(0x3751, 0x00);
-	write_cmos_sensor(0x37b5, 0x33);
-	write_cmos_sensor(0x3d85, 0x14);
-	write_cmos_sensor(0x3d8c, 0x73);
-	write_cmos_sensor(0x3d8d, 0xde);
-	write_cmos_sensor(0x5780, 0xfc);
-	write_cmos_sensor(0x5781, 0xdf);
-	write_cmos_sensor(0x5782, 0x3f);
-	write_cmos_sensor(0x5783, 0x08);
-	write_cmos_sensor(0x5784, 0x0c);
-	write_cmos_sensor(0x5785, 0x10);
-	write_cmos_sensor(0x5786, 0x20);
-	write_cmos_sensor(0x5787, 0x40);
-	write_cmos_sensor(0x5788, 0x08);
-	write_cmos_sensor(0x5789, 0x08);
-	write_cmos_sensor(0x578a, 0x02);
-	write_cmos_sensor(0x578b, 0x01);
-	write_cmos_sensor(0x578c, 0x01);
-	write_cmos_sensor(0x578d, 0x0c);
-	write_cmos_sensor(0x578e, 0x02);
-	write_cmos_sensor(0x578f, 0x01);
-	write_cmos_sensor(0x5790, 0x01);
-	write_cmos_sensor(0x5791, 0xff);
-	write_cmos_sensor(0x5792, 0x07);
-	write_cmos_sensor(0x5793, 0x03);
-	write_cmos_sensor(0x5794, 0x03);
-	write_cmos_sensor(0x5871, 0x0d);
-	write_cmos_sensor(0x5870, 0x18);
-	write_cmos_sensor(0x586e, 0x40);
-	write_cmos_sensor(0x586f, 0x20);
-	write_cmos_sensor(0x58f8, 0x00);
-	write_cmos_sensor(0x3763, 0x00);
-	write_cmos_sensor(0x3768, 0x00);
-	write_cmos_sensor(0x470b, 0x00);
-	write_cmos_sensor(0x4202, 0x00);
-	write_cmos_sensor(0x400d, 0x20);
-	write_cmos_sensor(0x4040, 0x00);
-	write_cmos_sensor(0x403e, 0x00);
-	write_cmos_sensor(0x4041, 0x07);
-	write_cmos_sensor(0x3007, 0x00);
-	write_cmos_sensor(0x400a, 0x00);
-	write_cmos_sensor(0x4009, 0x81);
-	write_cmos_sensor(0x4011, 0x00);
-	write_cmos_sensor(0x4020, 0x00);
-	write_cmos_sensor(0x4021, 0x04);
-	write_cmos_sensor(0x4022, 0x04);
-	write_cmos_sensor(0x4023, 0xb9);
-	write_cmos_sensor(0x4024, 0x05);
-	write_cmos_sensor(0x4025, 0x2a);
-	write_cmos_sensor(0x4026, 0x05);
-	write_cmos_sensor(0x4027, 0x2b);
-	write_cmos_sensor(0x4028, 0x00);
-	write_cmos_sensor(0x4029, 0x02);
-	write_cmos_sensor(0x402a, 0x04);
-	write_cmos_sensor(0x402b, 0x04);
-	write_cmos_sensor(0x402c, 0x02);
-	write_cmos_sensor(0x402d, 0x02);
-	write_cmos_sensor(0x402e, 0x08);
-	write_cmos_sensor(0x402f, 0x02);
-}
-static void sensor_init(void)
-{
-	LOG_INF("E\n");
-//  @@ OV8858R2A Initial 1632x1224_30FPS_MIPI_2LANE(Binning)
-//  100 99 1632 1224 ; Resolution
-//  102 80 1
-//  102 3601 bb8;30fps
-//  102 40 0 ; HDR Mode off
-//  ;FPGA set-up
-//  c8 01 f2 ;MIPI FPGA
-//  ;
-//  CL 100 100;delay
-//  ;;
-//  ;; MIPI=720Mbps, SysClk=148.8Mhz,Dac Clock=360Mhz.
-//  ;;
-//  ;;
-//  ;; v00_01_00 (05/29/2014) : initial setting
-//  ;;
-//  ;; AM19 : 3617 <- 0xC0
-//  ;;
-//  ;; AM20 : change 0x3618=0x5a
-//  ;; AM22 :
-//  ;;   6c 3617 40 
-//  ::   6c 4011 20 
-//  ::   6c 403e 08
-//  ;;   6c 4040 07
-//  ;;   6c 58f8 3d
-//  ;;
-
-
-	write_cmos_sensor(0x103 , 0x01);
-	write_cmos_sensor(0x303f, 0x01);
-	write_cmos_sensor(0x3012, 0x6c);
-	write_cmos_sensor(0x100 , 0x00);
-	write_cmos_sensor(0x302 , 0x1e);
-	write_cmos_sensor(0x303 , 0x00);
-	write_cmos_sensor(0x304 , 0x03);
-	write_cmos_sensor(0x30d , 0x1f);
-	write_cmos_sensor(0x30e , 0x02);
-	write_cmos_sensor(0x30f , 0x04);
-	write_cmos_sensor(0x312 , 0x03);
-	write_cmos_sensor(0x31e , 0x0c);
-	write_cmos_sensor(0x3007, 0x80);
-	write_cmos_sensor(0x3600, 0x00);
-	write_cmos_sensor(0x3601, 0x00);
-	write_cmos_sensor(0x3602, 0x00);
-	write_cmos_sensor(0x3603, 0x00);
-	write_cmos_sensor(0x3604, 0x22);
-	write_cmos_sensor(0x3605, 0x20);
-	write_cmos_sensor(0x3606, 0x00);
-	write_cmos_sensor(0x3607, 0x20);
-	write_cmos_sensor(0x3608, 0x11);
-	write_cmos_sensor(0x3609, 0x28);
-	write_cmos_sensor(0x360a, 0x00);
-	write_cmos_sensor(0x360b, 0x05);
-	write_cmos_sensor(0x360c, 0xd4);
-	write_cmos_sensor(0x360d, 0x40);
-	write_cmos_sensor(0x360e, 0x0c);
-	write_cmos_sensor(0x360f, 0x20);
-	write_cmos_sensor(0x3610, 0x07);
-	write_cmos_sensor(0x3611, 0x20);
-	write_cmos_sensor(0x3612, 0x88);
-	write_cmos_sensor(0x3613, 0x80);
-	write_cmos_sensor(0x3614, 0x58);
-	write_cmos_sensor(0x3615, 0x00);
-	write_cmos_sensor(0x3616, 0x4a);
-	write_cmos_sensor(0x3617, 0x40);
-	write_cmos_sensor(0x3618, 0x5a);
-	write_cmos_sensor(0x3619, 0x70);
-	write_cmos_sensor(0x361a, 0x99);
-	write_cmos_sensor(0x361b, 0x0a);
-	write_cmos_sensor(0x361c, 0x07);
-	write_cmos_sensor(0x361d, 0x00);
-	write_cmos_sensor(0x361e, 0x00);
-	write_cmos_sensor(0x361f, 0x00);
-	write_cmos_sensor(0x3638, 0xff);
-	write_cmos_sensor(0x3633, 0x0f);
-	write_cmos_sensor(0x3634, 0x0f);
-	write_cmos_sensor(0x3635, 0x0f);
-	write_cmos_sensor(0x3636, 0x12);
-	write_cmos_sensor(0x3645, 0x13);
-	write_cmos_sensor(0x3646, 0x83);
-	write_cmos_sensor(0x364a, 0x07);
-	write_cmos_sensor(0x3015, 0x00);
-	write_cmos_sensor(0x3018, 0x72);
-	write_cmos_sensor(0x3020, 0x93);
-	write_cmos_sensor(0x3022, 0x01);
-	write_cmos_sensor(0x3031, 0x0a);
-	write_cmos_sensor(0x3034, 0x00);
-	write_cmos_sensor(0x3106, 0x01);
-	write_cmos_sensor(0x3305, 0xf1);
-	write_cmos_sensor(0x3308, 0x00);
-	write_cmos_sensor(0x3309, 0x28);
-	write_cmos_sensor(0x330a, 0x00);
-	write_cmos_sensor(0x330b, 0x20);
-	write_cmos_sensor(0x330c, 0x00);
-	write_cmos_sensor(0x330d, 0x00);
-	write_cmos_sensor(0x330e, 0x00);
-	write_cmos_sensor(0x330f, 0x40);
-	write_cmos_sensor(0x3307, 0x04);
-	write_cmos_sensor(0x3500, 0x00);
-	write_cmos_sensor(0x3501, 0x4d);
-	write_cmos_sensor(0x3502, 0x40);
-	write_cmos_sensor(0x3503, 0x80);
-	write_cmos_sensor(0x3505, 0x80);
-	write_cmos_sensor(0x3508, 0x02);
-	write_cmos_sensor(0x3509, 0x00);
-	write_cmos_sensor(0x350c, 0x00);
-	write_cmos_sensor(0x350d, 0x80);
-	write_cmos_sensor(0x3510, 0x00);
-	write_cmos_sensor(0x3511, 0x02);
-	write_cmos_sensor(0x3512, 0x00);
-	write_cmos_sensor(0x3700, 0x18);
-	write_cmos_sensor(0x3701, 0x0c);
-	write_cmos_sensor(0x3702, 0x28);
-	write_cmos_sensor(0x3703, 0x19);
-	write_cmos_sensor(0x3704, 0x14);
-	write_cmos_sensor(0x3705, 0x00);
-	write_cmos_sensor(0x3706, 0x82);
-	write_cmos_sensor(0x3707, 0x04);
-	write_cmos_sensor(0x3708, 0x24);
-	write_cmos_sensor(0x3709, 0x33);
-	write_cmos_sensor(0x370a, 0x01);
-	write_cmos_sensor(0x370b, 0x82);
-	write_cmos_sensor(0x370c, 0x04);
-	write_cmos_sensor(0x3718, 0x12);
-	write_cmos_sensor(0x3719, 0x31);
-	write_cmos_sensor(0x3712, 0x42);
-	write_cmos_sensor(0x3714, 0x24);
-	write_cmos_sensor(0x371e, 0x19);
-	write_cmos_sensor(0x371f, 0x40);
-	write_cmos_sensor(0x3720, 0x05);
-	write_cmos_sensor(0x3721, 0x05);
-	write_cmos_sensor(0x3724, 0x06);
-	write_cmos_sensor(0x3725, 0x01);
-	write_cmos_sensor(0x3726, 0x06);
-	write_cmos_sensor(0x3728, 0x05);
-	write_cmos_sensor(0x3729, 0x02);
-	write_cmos_sensor(0x372a, 0x03);
-	write_cmos_sensor(0x372b, 0x53);
-	write_cmos_sensor(0x372c, 0xa3);
-	write_cmos_sensor(0x372d, 0x53);
-	write_cmos_sensor(0x372e, 0x06);
-	write_cmos_sensor(0x372f, 0x10);
-	write_cmos_sensor(0x3730, 0x01);
-	write_cmos_sensor(0x3731, 0x06);
-	write_cmos_sensor(0x3732, 0x14);
-	write_cmos_sensor(0x3733, 0x10);
-	write_cmos_sensor(0x3734, 0x40);
-	write_cmos_sensor(0x3736, 0x20);
-	write_cmos_sensor(0x373a, 0x05);
-	write_cmos_sensor(0x373b, 0x06);
-	write_cmos_sensor(0x373c, 0x0a);
-	write_cmos_sensor(0x373e, 0x03);
-	write_cmos_sensor(0x3750, 0x0a);
-	write_cmos_sensor(0x3751, 0x0e);
-	write_cmos_sensor(0x3755, 0x10);
-	write_cmos_sensor(0x3758, 0x00);
-	write_cmos_sensor(0x3759, 0x4c);
-	write_cmos_sensor(0x375a, 0x06);
-	write_cmos_sensor(0x375b, 0x13);
-	write_cmos_sensor(0x375c, 0x20);
-	write_cmos_sensor(0x375d, 0x02);
-	write_cmos_sensor(0x375e, 0x00);
-	write_cmos_sensor(0x375f, 0x14);
-	write_cmos_sensor(0x3768, 0xcc);
-	write_cmos_sensor(0x3769, 0x44);
-	write_cmos_sensor(0x376a, 0x44);
-	write_cmos_sensor(0x3761, 0x00);
-	write_cmos_sensor(0x3762, 0x00);
-	write_cmos_sensor(0x3763, 0x18);
-	write_cmos_sensor(0x3766, 0xff);
-	write_cmos_sensor(0x376b, 0x00);
-	write_cmos_sensor(0x3772, 0x23);
-	write_cmos_sensor(0x3773, 0x02);
-	write_cmos_sensor(0x3774, 0x16);
-	write_cmos_sensor(0x3775, 0x12);
-	write_cmos_sensor(0x3776, 0x04);
-	write_cmos_sensor(0x3777, 0x00);
-	write_cmos_sensor(0x3778, 0x17);
-	write_cmos_sensor(0x37a0, 0x44);
-	write_cmos_sensor(0x37a1, 0x3d);
-	write_cmos_sensor(0x37a2, 0x3d);
-	write_cmos_sensor(0x37a3, 0x00);
-	write_cmos_sensor(0x37a4, 0x00);
-	write_cmos_sensor(0x37a5, 0x00);
-	write_cmos_sensor(0x37a6, 0x00);
-	write_cmos_sensor(0x37a7, 0x44);
-	write_cmos_sensor(0x37a8, 0x4c);
-	write_cmos_sensor(0x37a9, 0x4c);
-	write_cmos_sensor(0x3760, 0x00);
-	write_cmos_sensor(0x376f, 0x01);
-	write_cmos_sensor(0x37aa, 0x44);
-	write_cmos_sensor(0x37ab, 0x2e);
-	write_cmos_sensor(0x37ac, 0x2e);
-	write_cmos_sensor(0x37ad, 0x33);
-	write_cmos_sensor(0x37ae, 0x0d);
-	write_cmos_sensor(0x37af, 0x0d);
-	write_cmos_sensor(0x37b0, 0x00);
-	write_cmos_sensor(0x37b1, 0x00);
-	write_cmos_sensor(0x37b2, 0x00);
-	write_cmos_sensor(0x37b3, 0x42);
-	write_cmos_sensor(0x37b4, 0x42);
-	write_cmos_sensor(0x37b5, 0x31);
-	write_cmos_sensor(0x37b6, 0x00);
-	write_cmos_sensor(0x37b7, 0x00);
-	write_cmos_sensor(0x37b8, 0x00);
-	write_cmos_sensor(0x37b9, 0xff);
-	write_cmos_sensor(0x3800, 0x00);
-	write_cmos_sensor(0x3801, 0x0c);
-	write_cmos_sensor(0x3802, 0x00);
-	write_cmos_sensor(0x3803, 0x0c);
-	write_cmos_sensor(0x3804, 0x0c);
-	write_cmos_sensor(0x3805, 0xd3);
-	write_cmos_sensor(0x3806, 0x09);
-	write_cmos_sensor(0x3807, 0xa3);
-	write_cmos_sensor(0x3808, 0x06);
-	write_cmos_sensor(0x3809, 0x60);
-	write_cmos_sensor(0x380a, 0x04);
-	write_cmos_sensor(0x380b, 0xc8);
-	write_cmos_sensor(0x380c, 0x07);
-	write_cmos_sensor(0x380d, 0x88);
-	write_cmos_sensor(0x380e, 0x04);
-	write_cmos_sensor(0x380f, 0xdc);
-	write_cmos_sensor(0x3810, 0x00);
-	write_cmos_sensor(0x3811, 0x04);
-	write_cmos_sensor(0x3813, 0x02);
-	write_cmos_sensor(0x3814, 0x03);
-	write_cmos_sensor(0x3815, 0x01);
-	write_cmos_sensor(0x3820, 0x00);
-	write_cmos_sensor(0x3821, 0x67);
-	write_cmos_sensor(0x382a, 0x03);
-	write_cmos_sensor(0x382b, 0x01);
-	write_cmos_sensor(0x3830, 0x08);
-	write_cmos_sensor(0x3836, 0x02);
-	write_cmos_sensor(0x3837, 0x18);
-	
-	// modify for pre cap view diff 20150105
-	//write_cmos_sensor(0x3841, 0xff);
-	write_cmos_sensor(0x3841, 0xef);
-	
-	write_cmos_sensor(0x3846, 0x48);
-	write_cmos_sensor(0x3d85, 0x16);
-	write_cmos_sensor(0x3d8c, 0x73);
-	write_cmos_sensor(0x3d8d, 0xde);
-	write_cmos_sensor(0x3f08, 0x08);
-	write_cmos_sensor(0x3f0a, 0x00);
-	write_cmos_sensor(0x4000, 0xf1);
-	write_cmos_sensor(0x4001, 0x10);
-	write_cmos_sensor(0x4005, 0x10);
-	write_cmos_sensor(0x4002, 0x27);
-	write_cmos_sensor(0x4009, 0x83);
-	write_cmos_sensor(0x400a, 0x01);
-	write_cmos_sensor(0x400b, 0x0c);
-	write_cmos_sensor(0x400d, 0x10);
-	write_cmos_sensor(0x4011, 0x20);
-	write_cmos_sensor(0x401b, 0x00);
-	write_cmos_sensor(0x401d, 0x00);
-	write_cmos_sensor(0x4020, 0x00);
-	write_cmos_sensor(0x4021, 0x04);
-	write_cmos_sensor(0x4022, 0x04);
-	write_cmos_sensor(0x4023, 0xb9);
-	write_cmos_sensor(0x4024, 0x05);
-	write_cmos_sensor(0x4025, 0x2a);
-	write_cmos_sensor(0x4026, 0x05);
-	write_cmos_sensor(0x4027, 0x2b);
-	write_cmos_sensor(0x4028, 0x00);
-	write_cmos_sensor(0x4029, 0x02);
-	write_cmos_sensor(0x402a, 0x04);
-	write_cmos_sensor(0x402b, 0x04);
-	write_cmos_sensor(0x402c, 0x02);
-	write_cmos_sensor(0x402d, 0x02);
-	write_cmos_sensor(0x402e, 0x08);
-	write_cmos_sensor(0x402f, 0x02);
-	write_cmos_sensor(0x401f, 0x00);
-	write_cmos_sensor(0x4034, 0x3f);
-	write_cmos_sensor(0x403d, 0x04);
-	write_cmos_sensor(0x403e, 0x08);
-	write_cmos_sensor(0x4040, 0x07);
-	write_cmos_sensor(0x4041, 0xc6);
-	write_cmos_sensor(0x4300, 0xff);
-	write_cmos_sensor(0x4202, 0x00);
-	write_cmos_sensor(0x4301, 0x00);
-	write_cmos_sensor(0x4302, 0x0f);
-	write_cmos_sensor(0x4316, 0x00);
-	write_cmos_sensor(0x4500, 0x58);
-	write_cmos_sensor(0x4503, 0x18);
-	write_cmos_sensor(0x4600, 0x00);
-	write_cmos_sensor(0x4601, 0xcb);
-	write_cmos_sensor(0x470b, 0x28);
-	
-	//NO CONTIUS MODE ADD BY PENGTAO FAN 20140723
-	//write_cmos_sensor(0x4800, 0x6C);
-	//CONTIUS MODE ADD BY PENGTAO FAN 20140723
-	//write_cmos_sensor(0x4800, 0x4C);
-	write_cmos_sensor(0x4800, 0x4C);
-	
-	write_cmos_sensor(0x481f, 0x32);
-	write_cmos_sensor(0x4837, 0x16);
-	write_cmos_sensor(0x4850, 0x10);
-	write_cmos_sensor(0x4851, 0x32);
-	write_cmos_sensor(0x4b00, 0x2a);
-	write_cmos_sensor(0x4b0d, 0x00);
-	write_cmos_sensor(0x4d00, 0x04);
-	write_cmos_sensor(0x4d01, 0x18);
-	write_cmos_sensor(0x4d02, 0xc3);
-	write_cmos_sensor(0x4d03, 0xff);
-	write_cmos_sensor(0x4d04, 0xff);
-	write_cmos_sensor(0x4d05, 0xff);
-	//DPC off white test(0x5000, 0x78);
-	//DPC on  white test(0x5000, 0x7e);
-	write_cmos_sensor(0x5000, 0x7e);
-	write_cmos_sensor(0x5001, 0x01);
-	write_cmos_sensor(0x5002, 0x08);
-	write_cmos_sensor(0x5003, 0x20);
-	write_cmos_sensor(0x5046, 0x12);
-	write_cmos_sensor(0x5780, 0x3e);
-	write_cmos_sensor(0x5781, 0x0f);
-	write_cmos_sensor(0x5782, 0x44);
-	write_cmos_sensor(0x5783, 0x02);
-	write_cmos_sensor(0x5784, 0x01);
-	write_cmos_sensor(0x5785, 0x00);
-	write_cmos_sensor(0x5786, 0x00);
-	write_cmos_sensor(0x5787, 0x04);
-	write_cmos_sensor(0x5788, 0x02);
-	write_cmos_sensor(0x5789, 0x0f);
-	write_cmos_sensor(0x578a, 0xfd);
-	write_cmos_sensor(0x578b, 0xf5);
-	write_cmos_sensor(0x578c, 0xf5);
-	write_cmos_sensor(0x578d, 0x03);
-	write_cmos_sensor(0x578e, 0x08);
-	write_cmos_sensor(0x578f, 0x0c);
-	write_cmos_sensor(0x5790, 0x08);
-	write_cmos_sensor(0x5791, 0x04);
-	write_cmos_sensor(0x5792, 0x00);
-	write_cmos_sensor(0x5793, 0x52);
-	write_cmos_sensor(0x5794, 0xa3);
-	write_cmos_sensor(0x5871, 0x0d);
-	write_cmos_sensor(0x5870, 0x18);
-	write_cmos_sensor(0x586e, 0x10);
-	write_cmos_sensor(0x586f, 0x08);
-	write_cmos_sensor(0x58f8, 0x3d); //; LEN VSCALE FACTOR
-	write_cmos_sensor(0x5901, 0x00);
-	write_cmos_sensor(0x5b00, 0x02);
-	write_cmos_sensor(0x5b01, 0x10);
-	write_cmos_sensor(0x5b02, 0x03);
-	write_cmos_sensor(0x5b03, 0xcf);
-	write_cmos_sensor(0x5b05, 0x6c);
-	write_cmos_sensor(0x5e00, 0x00);
-	write_cmos_sensor(0x5e01, 0x41);
-	write_cmos_sensor(0x382d, 0x7f);
-	write_cmos_sensor(0x4825, 0x3a);
-	write_cmos_sensor(0x4826, 0x40);
-	write_cmos_sensor(0x4808, 0x25);
-	if (ov8858version == OV8858R1A){
-		LOG_INF("inter r1asensor_init() ov8858version = %d(0=r2a,1=r1a)\n",ov8858version); 
-		r1asensor_init();
-	}
-	write_cmos_sensor(0x0100, 0x01);
-}	/*	sensor_init  */
-
-
-static void preview_setting(void)
-{
-	LOG_INF("E\n");
-//   @@ Binning Size 1632x1224 30fps 4Lane_PCLK=74.4M
-//   100 99 1632 1224
-	write_cmos_sensor(0x100 , 0x00);      //	
-	write_cmos_sensor(0x30e , 0x02);     //
-	write_cmos_sensor(0x312 , 0x03);     //
-	write_cmos_sensor(0x3015, 0x00);     //
-	write_cmos_sensor(0x3700, 0x18);     //
-	write_cmos_sensor(0x3701, 0x0c);     //
-	write_cmos_sensor(0x3702, 0x28);     //
-	write_cmos_sensor(0x3703, 0x19);     //
-	write_cmos_sensor(0x3704, 0x14);     //
-	write_cmos_sensor(0x3707, 0x04);     //
-	write_cmos_sensor(0x3708, 0x24);     //
-	write_cmos_sensor(0x3709, 0x33);     //
-	write_cmos_sensor(0x370c, 0x04);     //
-	write_cmos_sensor(0x3718, 0x12);     //
-	write_cmos_sensor(0x3712, 0x42);     //
-	write_cmos_sensor(0x371e, 0x19);     //
-	write_cmos_sensor(0x371f, 0x40);     //
-	write_cmos_sensor(0x3720, 0x05);     //
-	write_cmos_sensor(0x3721, 0x05);     //
-	write_cmos_sensor(0x3724, 0x06);     //
-	write_cmos_sensor(0x3725, 0x01);     //
-	write_cmos_sensor(0x3726, 0x06);     //
-	write_cmos_sensor(0x3728, 0x05);     //
-	write_cmos_sensor(0x3729, 0x02);     //
-	write_cmos_sensor(0x372a, 0x03);     //
-	write_cmos_sensor(0x372b, 0x53);     //
-	write_cmos_sensor(0x372c, 0xa3);     //
-	write_cmos_sensor(0x372d, 0x53);     //
-	write_cmos_sensor(0x372e, 0x06);     //
-	write_cmos_sensor(0x372f, 0x10);     //
-	write_cmos_sensor(0x3730, 0x01);     //
-	write_cmos_sensor(0x3731, 0x06);     //
-	write_cmos_sensor(0x3732, 0x14);     //
-	write_cmos_sensor(0x3736, 0x20);     //
-	write_cmos_sensor(0x373a, 0x05);     //
-	write_cmos_sensor(0x373b, 0x06);     //
-	write_cmos_sensor(0x373c, 0x0a);     //
-	write_cmos_sensor(0x373e, 0x03);     //
-	write_cmos_sensor(0x375a, 0x06);     //
-	write_cmos_sensor(0x375b, 0x13);     //
-	write_cmos_sensor(0x375d, 0x02);     //
-	write_cmos_sensor(0x375f, 0x14);     //
-	write_cmos_sensor(0x3772, 0x23);     //
-	write_cmos_sensor(0x3773, 0x02);     //
-	write_cmos_sensor(0x3774, 0x16);     //
-	write_cmos_sensor(0x3775, 0x12);     //
-	write_cmos_sensor(0x3776, 0x04);     //
-	write_cmos_sensor(0x3778, 0x17);     //
-	write_cmos_sensor(0x37a0, 0x44);     //
-	write_cmos_sensor(0x37a1, 0x3d);     //
-	write_cmos_sensor(0x37a2, 0x3d);     //
-	write_cmos_sensor(0x37a7, 0x44);     //
-	write_cmos_sensor(0x37a8, 0x4c);     //
-	write_cmos_sensor(0x37a9, 0x4c);     //
-	write_cmos_sensor(0x37aa, 0x44);     //
-	write_cmos_sensor(0x37ab, 0x2e);     //
-	write_cmos_sensor(0x37ac, 0x2e);     //
-	write_cmos_sensor(0x37ad, 0x33);     //
-	write_cmos_sensor(0x37ae, 0x0d);     //
-	write_cmos_sensor(0x37af, 0x0d);     //
-	write_cmos_sensor(0x37b3, 0x42);     //
-	write_cmos_sensor(0x37b4, 0x42);     //
-	write_cmos_sensor(0x37b5, 0x31);     // ;;; 
-	write_cmos_sensor(0x3768, 0x22);     //
-	write_cmos_sensor(0x3769, 0x44);     //
-	write_cmos_sensor(0x376a, 0x44);     //
-	write_cmos_sensor(0x3808, 0x06);     //
-	write_cmos_sensor(0x3809, 0x60);     //
-	write_cmos_sensor(0x380a, 0x04);     //
-	write_cmos_sensor(0x380b, 0xc8);     //
-	write_cmos_sensor(0x380c, 0x07);     //
-	write_cmos_sensor(0x380d, 0x88);     //
-	write_cmos_sensor(0x380e, 0x05);     //;04
-	write_cmos_sensor(0x380f, 0x04);     //;dc
-	write_cmos_sensor(0x3814, 0x03);     //
-	write_cmos_sensor(0x3821, 0x67);     //
-	write_cmos_sensor(0x382a, 0x03);     //
-	write_cmos_sensor(0x382b, 0x01);     //
-	write_cmos_sensor(0x3830, 0x08);     //
-	write_cmos_sensor(0x3836, 0x02);     //
-
-	write_cmos_sensor(0x3843, 0x00);     //	
-	// modify for pre cap view diff 20150105
-	write_cmos_sensor(0x3811, 0x03);     //	
-	write_cmos_sensor(0x3845, 0x02);     //	
-
-	write_cmos_sensor(0x3f08, 0x08);     //
-	write_cmos_sensor(0x4001, 0x10);     //
-	write_cmos_sensor(0x4020, 0x00);     //
-	write_cmos_sensor(0x4021, 0x04);     //
-	write_cmos_sensor(0x4022, 0x04);     //
-	write_cmos_sensor(0x4023, 0xb9);     //
-	write_cmos_sensor(0x4024, 0x05);     //
-	write_cmos_sensor(0x4025, 0x2a);     //
-	write_cmos_sensor(0x4026, 0x05);     //
-	write_cmos_sensor(0x4027, 0x2b);     //
-	write_cmos_sensor(0x402a, 0x04);     //
-	write_cmos_sensor(0x402b, 0x04);     //
-	write_cmos_sensor(0x402e, 0x08);     //
-	write_cmos_sensor(0x402f, 0x02);     //
-	write_cmos_sensor(0x4600, 0x00);     //
-	write_cmos_sensor(0x4601, 0xcb);     //
-	write_cmos_sensor(0x5901, 0x00);     //
-	write_cmos_sensor(0x382d, 0x7f);     // ;;;
-	write_cmos_sensor(0x100 , 0x1);     //
-}	/*	preview_setting  */
-
-static void capture_setting(kal_uint16 currefps)
-{
-	LOG_INF("E! currefps:%d\n",currefps);
-	if (currefps == 150) {
-//  @@ Full size 3264x2448 30fps 4lane_PCLK=148.8M
-//  100 99 3264 2448);    //
-	write_cmos_sensor(0x100 , 0x0 );  //  
-	write_cmos_sensor(0x30e , 0x00);  //  
-	write_cmos_sensor(0x312 , 0x01);  //  
-	write_cmos_sensor(0x3015, 0x01);  //  
-	write_cmos_sensor(0x3700, 0x30);  //  
-	write_cmos_sensor(0x3701, 0x18);  //  
-	write_cmos_sensor(0x3702, 0x50);  //  
-	write_cmos_sensor(0x3703, 0x32);  //  
-	write_cmos_sensor(0x3704, 0x28);  //  
-	write_cmos_sensor(0x3707, 0x08);  //  
-	write_cmos_sensor(0x3708, 0x48);  //  
-	write_cmos_sensor(0x3709, 0x66);  //  
-	write_cmos_sensor(0x370c, 0x07);  //  
-	write_cmos_sensor(0x3718, 0x14);  //  
-	write_cmos_sensor(0x3712, 0x44);  //  
-	write_cmos_sensor(0x371e, 0x31);  //  
-	write_cmos_sensor(0x371f, 0x7f);  //  
-	write_cmos_sensor(0x3720, 0x0a);  //  
-	write_cmos_sensor(0x3721, 0x0a);  //  
-	write_cmos_sensor(0x3724, 0x0c);  //  
-	write_cmos_sensor(0x3725, 0x02);  //  
-	write_cmos_sensor(0x3726, 0x0c);  //  
-	write_cmos_sensor(0x3728, 0x0a);  //  
-	write_cmos_sensor(0x3729, 0x03);  //  
-	write_cmos_sensor(0x372a, 0x06);  //  
-	write_cmos_sensor(0x372b, 0xa6);  //  
-	write_cmos_sensor(0x372c, 0xa6);  //  
-	write_cmos_sensor(0x372d, 0xa6);  //  
-	write_cmos_sensor(0x372e, 0x0c);  //  
-	write_cmos_sensor(0x372f, 0x20);  //  
-	write_cmos_sensor(0x3730, 0x02);  //  
-	write_cmos_sensor(0x3731, 0x0c);  //  
-	write_cmos_sensor(0x3732, 0x28);  //  
-	write_cmos_sensor(0x3736, 0x30);  //  
-	write_cmos_sensor(0x373a, 0x0a);  //  
-	write_cmos_sensor(0x373b, 0x0b);  //  
-	write_cmos_sensor(0x373c, 0x14);  //  
-	write_cmos_sensor(0x373e, 0x06);  //  
-	write_cmos_sensor(0x375a, 0x0c);  //  
-	write_cmos_sensor(0x375b, 0x26);  //  
-	write_cmos_sensor(0x375d, 0x04);  //  
-	write_cmos_sensor(0x375f, 0x28);  //  
-	write_cmos_sensor(0x3772, 0x46);  //  
-	write_cmos_sensor(0x3773, 0x04);  //  
-	write_cmos_sensor(0x3774, 0x2c);  //  
-	write_cmos_sensor(0x3775, 0x13);  //  
-	write_cmos_sensor(0x3776, 0x08);  //  
-	write_cmos_sensor(0x3778, 0x17);  //  
-	write_cmos_sensor(0x37a0, 0x88);  //  
-	write_cmos_sensor(0x37a1, 0x7a);  //  
-	write_cmos_sensor(0x37a2, 0x7a);  //  
-	write_cmos_sensor(0x37a7, 0x88);  //  
-	write_cmos_sensor(0x37a8, 0x98);  //  
-	write_cmos_sensor(0x37a9, 0x98);  //  
-	write_cmos_sensor(0x37aa, 0x88);  //  
-	write_cmos_sensor(0x37ab, 0x5c);  //  
-	write_cmos_sensor(0x37ac, 0x5c);  //  
-	write_cmos_sensor(0x37ad, 0x55);  //  
-	write_cmos_sensor(0x37ae, 0x19);  //  
-	write_cmos_sensor(0x37af, 0x19);  //  
-	write_cmos_sensor(0x37b3, 0x84);  //  
-	write_cmos_sensor(0x37b4, 0x84);  //  
-	write_cmos_sensor(0x37b5, 0x60);  //   ; 66
-	write_cmos_sensor(0x3768, 0x22);  //  
-	write_cmos_sensor(0x3769, 0x44);  //  
-	write_cmos_sensor(0x376a, 0x44);  //  
-	write_cmos_sensor(0x3808, 0x0c);  //  
-	write_cmos_sensor(0x3809, 0xc0);  //  
-	write_cmos_sensor(0x380a, 0x09);  //  
-	write_cmos_sensor(0x380b, 0x90);  //  
-	write_cmos_sensor(0x380c, 0x09);  //  
-	write_cmos_sensor(0x380d, 0x79);  //  
-	write_cmos_sensor(0x380e, 0x0f);  //  
-	write_cmos_sensor(0x380f, 0xfa);  //   ;aa
-	write_cmos_sensor(0x3814, 0x01);  //  
-	write_cmos_sensor(0x3821, 0x46);  //  
-	write_cmos_sensor(0x382a, 0x01);  //  
-	write_cmos_sensor(0x382b, 0x01);  //  
-	write_cmos_sensor(0x3830, 0x06);  //  
-	write_cmos_sensor(0x3836, 0x01);  //  
-	write_cmos_sensor(0x3f08, 0x10);  //  
-
-	write_cmos_sensor(0x3843, 0x00);     //	
-	// modify for pre cap view diff 20150105
-	write_cmos_sensor(0x3811, 0x05);     //	
-	write_cmos_sensor(0x3845, 0x00);     //	
-
-	
-	write_cmos_sensor(0x4001, 0x00);  //  
-	write_cmos_sensor(0x4020, 0x00);  //  
-	write_cmos_sensor(0x4021, 0x04);  //  
-	write_cmos_sensor(0x4022, 0x0b);  //  
-	write_cmos_sensor(0x4023, 0xc3);  //  
-	write_cmos_sensor(0x4024, 0x0c);  //  
-	write_cmos_sensor(0x4025, 0x36);  //  
-	write_cmos_sensor(0x4026, 0x0c);  //  
-	write_cmos_sensor(0x4027, 0x37);  //  
-	write_cmos_sensor(0x402a, 0x04);  //  
-	write_cmos_sensor(0x402b, 0x08);  //  
-	write_cmos_sensor(0x402e, 0x0c);  //  
-	write_cmos_sensor(0x402f, 0x02);  //  
-	write_cmos_sensor(0x4600, 0x01);  //  
-	write_cmos_sensor(0x4601, 0x97);  //  
-	write_cmos_sensor(0x5901, 0x00);  //  
-	write_cmos_sensor(0x382d, 0xff);  //   ;;;
-	write_cmos_sensor(0x100 , 0x1);   // 
-	}
-	else 
-	{   
-//  @@ Full size 3264x2448 30fps 4lane_PCLK=148.8M
-//  100 99 3264 2448);    //
-	write_cmos_sensor(0x100 , 0x0 );  //  
-	write_cmos_sensor(0x30e , 0x00);  //  
-	write_cmos_sensor(0x312 , 0x01);  //  
-	write_cmos_sensor(0x3015, 0x01);  //  
-	write_cmos_sensor(0x3700, 0x30);  //  
-	write_cmos_sensor(0x3701, 0x18);  //  
-	write_cmos_sensor(0x3702, 0x50);  //  
-	write_cmos_sensor(0x3703, 0x32);  //  
-	write_cmos_sensor(0x3704, 0x28);  //  
-	write_cmos_sensor(0x3707, 0x08);  //  
-	write_cmos_sensor(0x3708, 0x48);  //  
-	write_cmos_sensor(0x3709, 0x66);  //  
-	write_cmos_sensor(0x370c, 0x07);  //  
-	write_cmos_sensor(0x3718, 0x14);  //  
-	write_cmos_sensor(0x3712, 0x44);  //  
-	write_cmos_sensor(0x371e, 0x31);  //  
-	write_cmos_sensor(0x371f, 0x7f);  //  
-	write_cmos_sensor(0x3720, 0x0a);  //  
-	write_cmos_sensor(0x3721, 0x0a);  //  
-	write_cmos_sensor(0x3724, 0x0c);  //  
-	write_cmos_sensor(0x3725, 0x02);  //  
-	write_cmos_sensor(0x3726, 0x0c);  //  
-	write_cmos_sensor(0x3728, 0x0a);  //  
-	write_cmos_sensor(0x3729, 0x03);  //  
-	write_cmos_sensor(0x372a, 0x06);  //  
-	write_cmos_sensor(0x372b, 0xa6);  //  
-	write_cmos_sensor(0x372c, 0xa6);  //  
-	write_cmos_sensor(0x372d, 0xa6);  //  
-	write_cmos_sensor(0x372e, 0x0c);  //  
-	write_cmos_sensor(0x372f, 0x20);  //  
-	write_cmos_sensor(0x3730, 0x02);  //  
-	write_cmos_sensor(0x3731, 0x0c);  //  
-	write_cmos_sensor(0x3732, 0x28);  //  
-	write_cmos_sensor(0x3736, 0x30);  //  
-	write_cmos_sensor(0x373a, 0x0a);  //  
-	write_cmos_sensor(0x373b, 0x0b);  //  
-	write_cmos_sensor(0x373c, 0x14);  //  
-	write_cmos_sensor(0x373e, 0x06);  //  
-	write_cmos_sensor(0x375a, 0x0c);  //  
-	write_cmos_sensor(0x375b, 0x26);  //  
-	write_cmos_sensor(0x375d, 0x04);  //  
-	write_cmos_sensor(0x375f, 0x28);  //  
-	write_cmos_sensor(0x3772, 0x46);  //  
-	write_cmos_sensor(0x3773, 0x04);  //  
-	write_cmos_sensor(0x3774, 0x2c);  //  
-	write_cmos_sensor(0x3775, 0x13);  //  
-	write_cmos_sensor(0x3776, 0x08);  //  
-	write_cmos_sensor(0x3778, 0x17);  //  
-	write_cmos_sensor(0x37a0, 0x88);  //  
-	write_cmos_sensor(0x37a1, 0x7a);  //  
-	write_cmos_sensor(0x37a2, 0x7a);  //  
-	write_cmos_sensor(0x37a7, 0x88);  //  
-	write_cmos_sensor(0x37a8, 0x98);  //  
-	write_cmos_sensor(0x37a9, 0x98);  //  
-	write_cmos_sensor(0x37aa, 0x88);  //  
-	write_cmos_sensor(0x37ab, 0x5c);  //  
-	write_cmos_sensor(0x37ac, 0x5c);  //  
-	write_cmos_sensor(0x37ad, 0x55);  //  
-	write_cmos_sensor(0x37ae, 0x19);  //  
-	write_cmos_sensor(0x37af, 0x19);  //  
-	write_cmos_sensor(0x37b3, 0x84);  //  
-	write_cmos_sensor(0x37b4, 0x84);  //  
-	write_cmos_sensor(0x37b5, 0x60);  //   ; 66
-	write_cmos_sensor(0x3768, 0x22);  //  
-	write_cmos_sensor(0x3769, 0x44);  //  
-	write_cmos_sensor(0x376a, 0x44);  //  
-	write_cmos_sensor(0x3808, 0x0c);  //  
-	write_cmos_sensor(0x3809, 0xc0);  //  
-	write_cmos_sensor(0x380a, 0x09);  //  
-	write_cmos_sensor(0x380b, 0x90);  //  
-	write_cmos_sensor(0x380c, 0x07);  //  
-	write_cmos_sensor(0x380d, 0x94);  //  
-	write_cmos_sensor(0x380e, 0x09);  //  
-	write_cmos_sensor(0x380f, 0xfc);  //   ;aa
-	write_cmos_sensor(0x3814, 0x01);  //  
-	write_cmos_sensor(0x3821, 0x46);  //  
-	write_cmos_sensor(0x382a, 0x01);  //  
-	write_cmos_sensor(0x382b, 0x01);  //  
-	write_cmos_sensor(0x3830, 0x06);  //  
-	write_cmos_sensor(0x3836, 0x01);  //  
-	// modify for pre cap view diff 20150105
-	write_cmos_sensor(0x3811, 0x05);     //	
-	write_cmos_sensor(0x3845, 0x00);     //	
-	
-	write_cmos_sensor(0x3f08, 0x10);  //  
-	write_cmos_sensor(0x4001, 0x00);  //  
-	write_cmos_sensor(0x4020, 0x00);  //  
-	write_cmos_sensor(0x4021, 0x04);  //  
-	write_cmos_sensor(0x4022, 0x0b);  //  
-	write_cmos_sensor(0x4023, 0xc3);  //  
-	write_cmos_sensor(0x4024, 0x0c);  //  
-	write_cmos_sensor(0x4025, 0x36);  //  
-	write_cmos_sensor(0x4026, 0x0c);  //  
-	write_cmos_sensor(0x4027, 0x37);  //  
-	write_cmos_sensor(0x402a, 0x04);  //  
-	write_cmos_sensor(0x402b, 0x08);  //  
-	write_cmos_sensor(0x402e, 0x0c);  //  
-	write_cmos_sensor(0x402f, 0x02);  //  
-	write_cmos_sensor(0x4600, 0x01);  //  
-	write_cmos_sensor(0x4601, 0x97);  //  
-	write_cmos_sensor(0x5901, 0x00);  //  
-	write_cmos_sensor(0x382d, 0xff);  //   ;;;
-	write_cmos_sensor(0x100 , 0x1);   // 
-	}
-		
-}
-
-static void normal_video_setting(kal_uint16 currefps)
-{
-	LOG_INF("E! currefps:%d\n",currefps);
-    capture_setting(currefps);
-}
-static void hs_video_setting()
-{
-	LOG_INF("E\n");
-//  @@ OV8858R2A VGA 120fps_PCLK=148.8M
-//  100 99 640 480
-	write_cmos_sensor(0x0100, 0x00);  //
-	write_cmos_sensor(0x30e , 0x00);  //
-	write_cmos_sensor(0x312 , 0x01);  //
-	write_cmos_sensor(0x3015, 0x01);  //
-	write_cmos_sensor(0x3700, 0x30);  //
-	write_cmos_sensor(0x3701, 0x18);  //
-	write_cmos_sensor(0x3702, 0x50);  //
-	write_cmos_sensor(0x3703, 0x32);  //
-	write_cmos_sensor(0x3704, 0x28);  //
-	write_cmos_sensor(0x3707, 0x08);  //
-	write_cmos_sensor(0x3708, 0x48);  //
-	write_cmos_sensor(0x3709, 0x66);  //
-	write_cmos_sensor(0x370c, 0x07);  //
-	write_cmos_sensor(0x3718, 0x14);  //
-	write_cmos_sensor(0x3712, 0x44);  //
-	write_cmos_sensor(0x371e, 0x31);  //
-	write_cmos_sensor(0x371f, 0x7f);  //
-	write_cmos_sensor(0x3720, 0x0a);  //
-	write_cmos_sensor(0x3721, 0x0a);  //
-	write_cmos_sensor(0x3724, 0x0c);  //
-	write_cmos_sensor(0x3725, 0x02);  //
-	write_cmos_sensor(0x3726, 0x0c);  //
-	write_cmos_sensor(0x3728, 0x0a);  //
-	write_cmos_sensor(0x3729, 0x03);  //
-	write_cmos_sensor(0x372a, 0x06);  //
-	write_cmos_sensor(0x372b, 0xa6);  //
-	write_cmos_sensor(0x372c, 0xa6);  //
-	write_cmos_sensor(0x372d, 0xa6);  //
-	write_cmos_sensor(0x372e, 0x0c);  //
-	write_cmos_sensor(0x372f, 0x20);  //
-	write_cmos_sensor(0x3730, 0x02);  //
-	write_cmos_sensor(0x3731, 0x0c);  //
-	write_cmos_sensor(0x3732, 0x28);  //
-	write_cmos_sensor(0x3736, 0x30);  //
-	write_cmos_sensor(0x373a, 0x0a);  //
-	write_cmos_sensor(0x373b, 0x0b);  //
-	write_cmos_sensor(0x373c, 0x14);  //
-	write_cmos_sensor(0x373e, 0x06);  //
-	write_cmos_sensor(0x375a, 0x0c);  //
-	write_cmos_sensor(0x375b, 0x26);  //
-	write_cmos_sensor(0x375d, 0x04);  //
-	write_cmos_sensor(0x375f, 0x28);  //
-	write_cmos_sensor(0x3772, 0x46);  //
-	write_cmos_sensor(0x3773, 0x04);  //
-	write_cmos_sensor(0x3774, 0x2c);  //
-	write_cmos_sensor(0x3775, 0x13);  //
-	write_cmos_sensor(0x3776, 0x08);  //
-	write_cmos_sensor(0x3778, 0x17);  //
-	write_cmos_sensor(0x37a0, 0x88);  //
-	write_cmos_sensor(0x37a1, 0x7a);  //
-	write_cmos_sensor(0x37a2, 0x7a);  //
-	write_cmos_sensor(0x37a7, 0x88);  //
-	write_cmos_sensor(0x37a8, 0x98);  //
-	write_cmos_sensor(0x37a9, 0x98);  //
-	write_cmos_sensor(0x37aa, 0x88);  //
-	write_cmos_sensor(0x37ab, 0x5c);  //
-	write_cmos_sensor(0x37ac, 0x5c);  //
-	write_cmos_sensor(0x37ad, 0x55);  //
-	write_cmos_sensor(0x37ae, 0x19);  //
-	write_cmos_sensor(0x37af, 0x19);  //
-	write_cmos_sensor(0x37b3, 0x84);  //
-	write_cmos_sensor(0x37b4, 0x84);  //
-	write_cmos_sensor(0x37b5, 0x60);  //
-	write_cmos_sensor(0x3768, 0x00);  //
-	write_cmos_sensor(0x3769, 0xc0);  //
-	write_cmos_sensor(0x376a, 0x42);  //
-	write_cmos_sensor(0x3808, 0x02);  //
-	write_cmos_sensor(0x3809, 0x80);  //
-	write_cmos_sensor(0x380a, 0x01);  //
-	write_cmos_sensor(0x380b, 0xe0);  //
-	write_cmos_sensor(0x380c, 0x08);  //;09
-	write_cmos_sensor(0x380d, 0xDe);  //;02
-	write_cmos_sensor(0x380e, 0x02);  //
-	write_cmos_sensor(0x380f, 0x22);  //;08
-	write_cmos_sensor(0x3814, 0x03);  //
-	write_cmos_sensor(0x3821, 0x6f);  //
-	write_cmos_sensor(0x382a, 0x05);  //
-	write_cmos_sensor(0x382b, 0x03);  //
-	write_cmos_sensor(0x3830, 0x0c);  //
-	write_cmos_sensor(0x3836, 0x02);  //
-	write_cmos_sensor(0x3f08, 0x10);  //
-	write_cmos_sensor(0x4001, 0x10);  //
-	write_cmos_sensor(0x4020, 0x01);  //
-	write_cmos_sensor(0x4021, 0x20);  //
-	write_cmos_sensor(0x4022, 0x01);  //
-	write_cmos_sensor(0x4023, 0x9f);  //
-	write_cmos_sensor(0x4024, 0x03);  //
-	write_cmos_sensor(0x4025, 0xe0);  //
-	write_cmos_sensor(0x4026, 0x04);  //
-	write_cmos_sensor(0x4027, 0x5f);  //
-	write_cmos_sensor(0x402a, 0x02);  //
-	write_cmos_sensor(0x402b, 0x04);  //
-	write_cmos_sensor(0x402e, 0x02);  //
-	write_cmos_sensor(0x402f, 0x04);  //
-	write_cmos_sensor(0x4600, 0x00);  //
-	write_cmos_sensor(0x4601, 0x4f);  //
-	write_cmos_sensor(0x5901, 0x04);  //
-	
-	// modify for pre cap view diff 20150105
-	write_cmos_sensor(0x3811, 0x03);     //	
-	write_cmos_sensor(0x3845, 0x02);     //	
-
-	write_cmos_sensor(0x382d, 0x7f);  //
-	write_cmos_sensor(0x0100, 0x01);  //
-}
-
-static void slim_video_setting()
-{
-	LOG_INF("E\n");
-	preview_setting();
-}
-
-
-/*************************************************************************
-* FUNCTION
-*	get_imgsensor_id
-*
-* DESCRIPTION
-*	This function get the sensor ID 
-*
-* PARAMETERS
-*	*sensorID : return the sensor ID 
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 get_imgsensor_id(UINT32 *sensor_id) 
-{
-	kal_uint8 i = 0;
-	kal_uint8 retry = 2;
-	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
-	while (imgsensor_info.i2c_addr_table[i] != 0xff) {
-		spin_lock(&imgsensor_drv_lock);
-		imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
-		spin_unlock(&imgsensor_drv_lock);
-		do {
-			*sensor_id = ((read_cmos_sensor(0x300B) << 8) | read_cmos_sensor(0x300C));
-			if (*sensor_id == imgsensor_info.sensor_id) {
-				if((read_cmos_sensor(0x302A)) == 0XB2){
- 				ov8858version = OV8858R2A;
-				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x, ov8858version = %d(0=r2a,1=r1a)\n", imgsensor.i2c_write_id,*sensor_id,ov8858version);	
-				return ERROR_NONE;
-				}
-				else if((read_cmos_sensor(0x302A)) == 0XB1){
- 				ov8858version = OV8858R1A;
-				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x, ov8858version = %d(0=r2a,1=r1a)\n", imgsensor.i2c_write_id,*sensor_id,ov8858version);	
-				return ERROR_NONE;
-				}
-				else{
-				LOG_INF("read ov8858 R1A R2A bate fail\n");	  
-				return ERROR_SENSOR_CONNECT_FAIL;
-				}
-			}	
-			LOG_INF("Read sensor id fail, id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
-			retry--;
-		} while(retry > 0);
-		i++;
-		retry = 2;
-	}
-	if (*sensor_id != imgsensor_info.sensor_id) {
-		// if Sensor ID is not correct, Must set *sensor_id to 0xFFFFFFFF 
-		*sensor_id = 0xFFFFFFFF;
-		return ERROR_SENSOR_CONNECT_FAIL;
-	}
-	return ERROR_NONE;
-}
-
-#ifdef OV8858R2AOTP
-
-struct otp_struct {
-int flag; // bit[7]: info, bit[6]:wb, bit[5]:vcm, bit[4]:lenc
-int module_integrator_id;
-int lens_id;
-int production_year;
-int production_month;
-int production_day;
-int rg_ratio;
-int bg_ratio;
-int lenc[240];
-int checksum;
-int VCM_start;
-int VCM_end;
-int VCM_dir;
-};
-
-//static struct otp_struct *otp_ptr = (struct otp_struct *)kzalloc(sizeof(struct otp_struct), GFP_KERNEL);
-
-#if 0
-struct otp_struct otp_struct_obj = {
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-0,
-{0},
-0,
-0,
-0,
-0,
-};
-
-
-otp_ptr = &otp_struct_obj;
-#endif
-
-// return value:
-// bit[7]: 0 no otp info, 1 valid otp info
-// bit[6]: 0 no otp wb, 1 valib otp wb
-// bit[5]: 0 no otp vcm, 1 valid otp vcm
-// bit[4]: 0 no otp lenc/invalid otp lenc, 1 valid otp lenc
-int read_otp(struct otp_struct *otp_ptr)
-{
-	int otp_flag, addr, temp, i;
-	//set 0x5002[3] to \A1\B00\A1\B1
-	int temp1;
-	temp1 = read_cmos_sensor(0x5002);
-	write_cmos_sensor(0x5002, (0x00 & 0x08) | (temp1 & (~0x08)));
-	// read OTP into buffer
-	write_cmos_sensor(0x3d84, 0xC0);
-	write_cmos_sensor(0x3d88, 0x70); // OTP start address
-	write_cmos_sensor(0x3d89, 0x10);
-	write_cmos_sensor(0x3d8A, 0x72); // OTP end address
-	write_cmos_sensor(0x3d8B, 0x0a);
-	write_cmos_sensor(0x3d81, 0x01); // load otp into buffer
-	mdelay(10);
-	// OTP base information and WB calibration data
-	otp_flag = read_cmos_sensor(0x7010);
-	addr = 0;
-	if((otp_flag & 0xc0) == 0x40) {
-		addr = 0x7011; // base address of info group 1
-	}
-	else if((otp_flag & 0x30) == 0x10) {
-		addr = 0x7019; // base address of info group 2
-	}
-	if(addr != 0) {
-		(*otp_ptr).flag = 0xC0; // valid info and AWB in OTP
-		(*otp_ptr).module_integrator_id = read_cmos_sensor(addr);
-		(*otp_ptr).lens_id = read_cmos_sensor( addr + 1);
-		(*otp_ptr).production_year = read_cmos_sensor( addr + 2);
-		(*otp_ptr).production_month = read_cmos_sensor( addr + 3);
-		(*otp_ptr).production_day = read_cmos_sensor(addr + 4);
-		temp = read_cmos_sensor(addr + 7);
-		(*otp_ptr).rg_ratio = (read_cmos_sensor(addr + 5)<<2) + ((temp>>6) & 0x03);
-		(*otp_ptr).bg_ratio = (read_cmos_sensor(addr + 6)<<2) + ((temp>>4) & 0x03);
-	}
-	else {
-		(*otp_ptr).flag = 0x00; // not info and AWB in OTP
-		(*otp_ptr).module_integrator_id = 0;
-		(*otp_ptr).lens_id = 0;
-		(*otp_ptr).production_year = 0;
-		(*otp_ptr).production_month = 0;
-		(*otp_ptr).production_day = 0;
-		(*otp_ptr).rg_ratio = 0;
-		(*otp_ptr).bg_ratio = 0;
-	}
-	// OTP VCM Calibration
-	otp_flag = read_cmos_sensor(0x7021);
-	addr = 0;
-	if((otp_flag & 0xc0) == 0x40) {
-		addr = 0x7022; // base address of VCM Calibration group 1
-	}
-	else if((otp_flag & 0x30) == 0x10) {
-		addr = 0x7025; // base address of VCM Calibration group 2
-	}
-	if(addr != 0) {
-		(*otp_ptr).flag |= 0x20;
-		temp = read_cmos_sensor(addr + 2);
-		(* otp_ptr).VCM_start = (read_cmos_sensor(addr)<<2) | ((temp>>6) & 0x03);
-		(* otp_ptr).VCM_end = (read_cmos_sensor(addr + 1) << 2) | ((temp>>4) & 0x03);
-		(* otp_ptr).VCM_dir = (temp>>2) & 0x03;
-	}
-	else {
-		(* otp_ptr).VCM_start = 0;
-		(* otp_ptr).VCM_end = 0;
-		(* otp_ptr).VCM_dir = 0;
-	}
-	// OTP Lenc Calibration
-	otp_flag = read_cmos_sensor(0x7028);
-	addr = 0;
-	int checksum2=0;
-	if((otp_flag & 0xc0) == 0x40) {
-		addr = 0x7029; // base address of Lenc Calibration group 1
-	}
-	else if((otp_flag & 0x30) == 0x10) {
-		addr = 0x711a; // base address of Lenc Calibration group 2
-	}
-	if(addr != 0) {
-		for(i=0;i<240;i++) {
-			(* otp_ptr).lenc[i]=read_cmos_sensor(addr + i);
-			checksum2 += (* otp_ptr).lenc[i];
-		}
-		checksum2 = (checksum2)%255 +1;
-		(*otp_ptr).checksum = read_cmos_sensor(addr + 240);
-		if((*otp_ptr).checksum == checksum2){
-			(*otp_ptr).flag |= 0x10;	
-		}
-	}
-	else {
-		for(i=0;i<240;i++) {
-			(* otp_ptr).lenc[i]=0;
-		}
-	}
-	for(i=0x7010;i<=0x720a;i++) {
-		write_cmos_sensor(i,0); // clear OTP buffer, recommended use continuous write to accelarate
-	}
-	//set 0x5002[3] to \A1\B01\A1\B1
-	temp1 = read_cmos_sensor(0x5002);
-	write_cmos_sensor(0x5002, (0x08 & 0x08) | (temp1 & (~0x08)));
-	return (*otp_ptr).flag;
-}
-// return value:
-// bit[7]: 0 no otp info, 1 valid otp info
-// bit[6]: 0 no otp wb, 1 valib otp wb
-// bit[5]: 0 no otp vcm, 1 valid otp vcm
-// bit[4]: 0 no otp lenc, 1 valid otp lenc
-
-int apply_otp(struct otp_struct *otp_ptr)
-{
-	int RG_Ratio_Typical = 0x148, BG_Ratio_Typical = 0x12A;
-	int rg, bg, R_gain, G_gain, B_gain, Base_gain, temp, i;
-	// apply OTP WB Calibration
-	if ((*otp_ptr).flag & 0x40) {
-		rg = (*otp_ptr).rg_ratio;
-		bg = (*otp_ptr).bg_ratio;
-		//calculate G gain
-		R_gain = (RG_Ratio_Typical*1000) / rg;
-		B_gain = (BG_Ratio_Typical*1000) / bg;
-		G_gain = 1000;
-		if (R_gain < 1000 || B_gain < 1000)
-		{
-			if (R_gain < B_gain)
-				Base_gain = R_gain;
-			else
-				Base_gain = B_gain;
-		}
-		else
-		{
-			Base_gain = G_gain;
-		}
-		R_gain = 0x400 * R_gain / (Base_gain);
-		B_gain = 0x400 * B_gain / (Base_gain);
-		G_gain = 0x400 * G_gain / (Base_gain);
-		// update sensor WB gain
-		if (R_gain>0x400) {
-			write_cmos_sensor(0x5032, R_gain>>8);
-			write_cmos_sensor(0x5033, R_gain & 0x00ff);
-		}
-		if (G_gain>0x400) {
-			write_cmos_sensor(0x5034, G_gain>>8);
-			write_cmos_sensor(0x5035, G_gain & 0x00ff);
-		}
-		if (B_gain>0x400) {
-			write_cmos_sensor(0x5036, B_gain>>8);
-			write_cmos_sensor(0x5037, B_gain & 0x00ff);
-		}
-	}
-	// apply OTP Lenc Calibration
-	if ((*otp_ptr).flag & 0x10) {
-		temp = read_cmos_sensor(0x5000);
-		temp = 0x80 | temp;
-		write_cmos_sensor(0x5000, temp);
-		for(i=0;i<240;i++) {
-			write_cmos_sensor(0x5800 + i, (*otp_ptr).lenc[i]);
-		}
-	}
-	return (*otp_ptr).flag;
-}
-
-#endif
-/*************************************************************************
-* FUNCTION
-*	open
-*
-* DESCRIPTION
-*	This function initialize the registers of CMOS sensor
-*
-* PARAMETERS
-*	None
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 open(void)
-{
-	//const kal_uint8 i2c_addr[] = {IMGSENSOR_WRITE_ID_1, IMGSENSOR_WRITE_ID_2};
-	kal_uint8 i = 0;
-	kal_uint8 retry = 2;
-	kal_uint16 sensor_id = 0; 
-	LOG_INF("PLATFORM:MT6595,MIPI 4LANE\n");
-	//LOG_INF("preview 1280*960@30fps,864Mbps/lane; video 1280*960@30fps,864Mbps/lane; capture 5M@30fps,864Mbps/lane\n");
-	
-	//sensor have two i2c address 0x6c 0x6d & 0x21 0x20, we should detect the module used i2c address
-	while (imgsensor_info.i2c_addr_table[i] != 0xff) {
-		spin_lock(&imgsensor_drv_lock);
-		imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
-		spin_unlock(&imgsensor_drv_lock);
-		do {
-			sensor_id = ((read_cmos_sensor(0x300B) << 8) | read_cmos_sensor(0x300C));
-			if (sensor_id == imgsensor_info.sensor_id) {				
-				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);	  
-				break;
-			}	
-			LOG_INF("Read sensor id fail, id: 0x%x\n", imgsensor.i2c_write_id,sensor_id);
-			retry--;
-		} while(retry > 0);
-		i++;
-		if (sensor_id == imgsensor_info.sensor_id)
-			break;
-		retry = 2;
-	}		 
-	if (imgsensor_info.sensor_id != sensor_id)
-		return ERROR_SENSOR_CONNECT_FAIL;
-	
-	/* initail sequence write in  */
-	sensor_init();
-	
-	mdelay(10);
-	#ifdef OV8858R2AOTP
-		LOG_INF("Apply the sensor OTP\n");
-		struct otp_struct *otp_ptr = (struct otp_struct *)kzalloc(sizeof(struct otp_struct), GFP_KERNEL);
-		read_otp(otp_ptr);
-		apply_otp(otp_ptr);
-		kfree(otp_ptr);
-	#endif
-	spin_lock(&imgsensor_drv_lock);
-
-	imgsensor.autoflicker_en= KAL_FALSE;
-	imgsensor.sensor_mode = IMGSENSOR_MODE_INIT;
-	imgsensor.shutter = 0x2D00;
-	imgsensor.gain = 0x100;
-	imgsensor.pclk = imgsensor_info.pre.pclk;
-	imgsensor.frame_length = imgsensor_info.pre.framelength;
-	imgsensor.line_length = imgsensor_info.pre.linelength;
-	imgsensor.min_frame_length = imgsensor_info.pre.framelength;
-	imgsensor.dummy_pixel = 0;
-	imgsensor.dummy_line = 0;
-	imgsensor.ihdr_en = 0;
-	imgsensor.test_pattern = KAL_FALSE;
-	imgsensor.current_fps = imgsensor_info.pre.max_framerate;
-	spin_unlock(&imgsensor_drv_lock);
-
-	return ERROR_NONE;
-}	/*	open  */
-
-
-
-/*************************************************************************
-* FUNCTION
-*	close
-*
-* DESCRIPTION
-*	
-*
-* PARAMETERS
-*	None
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 close(void)
-{
-	LOG_INF("E\n");
-
-	/*No Need to implement this function*/ 
-	
-	return ERROR_NONE;
-}	/*	close  */
-
-
-/*************************************************************************
-* FUNCTION
-* preview
-*
-* DESCRIPTION
-*	This function start the sensor preview.
-*
-* PARAMETERS
-*	*image_window : address pointer of pixel numbers in one period of HSYNC
-*  *sensor_config_data : address pointer of line numbers in one period of VSYNC
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("E\n");
-
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.sensor_mode = IMGSENSOR_MODE_PREVIEW;
-	imgsensor.pclk = imgsensor_info.pre.pclk;
-	//imgsensor.video_mode = KAL_FALSE;
-	imgsensor.line_length = imgsensor_info.pre.linelength;
-	imgsensor.frame_length = imgsensor_info.pre.framelength; 
-	imgsensor.min_frame_length = imgsensor_info.pre.framelength;
-	imgsensor.autoflicker_en = KAL_FALSE;
-	spin_unlock(&imgsensor_drv_lock);
-	preview_setting();
-	mdelay(10);
-	return ERROR_NONE;
-}	/*	preview   */
-
-/*************************************************************************
-* FUNCTION
-*	capture
-*
-* DESCRIPTION
-*	This function setup the CMOS sensor in capture MY_OUTPUT mode
-*
-* PARAMETERS
-*
-* RETURNS
-*	None
-*
-* GLOBALS AFFECTED
-*
-*************************************************************************/
-static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-						  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("E\n");
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.sensor_mode = IMGSENSOR_MODE_CAPTURE;
-	if (imgsensor.current_fps == imgsensor_info.cap1.max_framerate) {//PIP capture: 24fps for less than 13M, 20fps for 16M,15fps for 20M
-		imgsensor.pclk = imgsensor_info.cap1.pclk;
-		imgsensor.line_length = imgsensor_info.cap1.linelength;
-		imgsensor.frame_length = imgsensor_info.cap1.framelength;  
-		imgsensor.min_frame_length = imgsensor_info.cap1.framelength;
-		imgsensor.autoflicker_en = KAL_FALSE;
-	} else {
-		if (imgsensor.current_fps != imgsensor_info.cap.max_framerate)
-			LOG_INF("Warning: current_fps %d fps is not support, so use cap1's setting: %d fps!\n",imgsensor_info.cap1.max_framerate/10);
-		imgsensor.pclk = imgsensor_info.cap.pclk;
-		imgsensor.line_length = imgsensor_info.cap.linelength;
-		imgsensor.frame_length = imgsensor_info.cap.framelength;  
-		imgsensor.min_frame_length = imgsensor_info.cap.framelength;
-		imgsensor.autoflicker_en = KAL_FALSE;
-	}
-	spin_unlock(&imgsensor_drv_lock);
-
-	capture_setting(imgsensor.current_fps); 
-	mdelay(10);
-
-	#if 0
-	if(imgsensor.test_pattern == KAL_TRUE)
-	{
-		write_cmos_sensor(0x3282,0x01);//DPU OFF
-		
-		write_cmos_sensor(0x0600,0x00);
-		write_cmos_sensor(0x0601,0x02);
-		
-	}
-#endif
-	return ERROR_NONE;
-}	/* capture() */
-static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("E\n");
-	
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.sensor_mode = IMGSENSOR_MODE_VIDEO;
-	imgsensor.pclk = imgsensor_info.normal_video.pclk;
-	imgsensor.line_length = imgsensor_info.normal_video.linelength;
-	imgsensor.frame_length = imgsensor_info.normal_video.framelength;  
-	imgsensor.min_frame_length = imgsensor_info.normal_video.framelength;
-	//imgsensor.current_fps = 300;
-	imgsensor.autoflicker_en = KAL_FALSE;
-	spin_unlock(&imgsensor_drv_lock);
-	capture_setting(imgsensor.current_fps);
-	mdelay(10);
-	
-	
-	return ERROR_NONE;
-}	/*	normal_video   */
-
-static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("E\n");
-	
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.sensor_mode = IMGSENSOR_MODE_HIGH_SPEED_VIDEO;
-	imgsensor.pclk = imgsensor_info.hs_video.pclk;
-	//imgsensor.video_mode = KAL_TRUE;
-	imgsensor.line_length = imgsensor_info.hs_video.linelength;
-	imgsensor.frame_length = imgsensor_info.hs_video.framelength; 
-	imgsensor.min_frame_length = imgsensor_info.hs_video.framelength;
-	imgsensor.dummy_line = 0;
-	imgsensor.dummy_pixel = 0;
-	//imgsensor.current_fps = 300;
-	imgsensor.autoflicker_en = KAL_FALSE;
-	spin_unlock(&imgsensor_drv_lock);
-	hs_video_setting();
-	mdelay(10);
-	
-	return ERROR_NONE;
-}	/*	hs_video   */
-
-static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("E\n");
-	
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.sensor_mode = IMGSENSOR_MODE_SLIM_VIDEO;
-	imgsensor.pclk = imgsensor_info.slim_video.pclk;
-	//imgsensor.video_mode = KAL_TRUE;
-	imgsensor.line_length = imgsensor_info.slim_video.linelength;
-	imgsensor.frame_length = imgsensor_info.slim_video.framelength; 
-	imgsensor.min_frame_length = imgsensor_info.slim_video.framelength;
-	imgsensor.dummy_line = 0;
-	imgsensor.dummy_pixel = 0;
-	//imgsensor.current_fps = 300;
-	imgsensor.autoflicker_en = KAL_FALSE;
-	spin_unlock(&imgsensor_drv_lock);
-	slim_video_setting();
-	mdelay(10);
-	
-	return ERROR_NONE;
-}	/*	slim_video	 */
-
-
-
-static kal_uint32 get_resolution(MSDK_SENSOR_RESOLUTION_INFO_STRUCT *sensor_resolution)
-{
-	LOG_INF("E\n");
-	sensor_resolution->SensorFullWidth = imgsensor_info.cap.grabwindow_width;
-	sensor_resolution->SensorFullHeight = imgsensor_info.cap.grabwindow_height;
-	
-	sensor_resolution->SensorPreviewWidth = imgsensor_info.pre.grabwindow_width;
-	sensor_resolution->SensorPreviewHeight = imgsensor_info.pre.grabwindow_height;
-
-	sensor_resolution->SensorVideoWidth = imgsensor_info.normal_video.grabwindow_width;
-	sensor_resolution->SensorVideoHeight = imgsensor_info.normal_video.grabwindow_height;		
-
-	
-	sensor_resolution->SensorHighSpeedVideoWidth	 = imgsensor_info.hs_video.grabwindow_width;
-	sensor_resolution->SensorHighSpeedVideoHeight	 = imgsensor_info.hs_video.grabwindow_height;
-	
-	sensor_resolution->SensorSlimVideoWidth	 = imgsensor_info.slim_video.grabwindow_width;
-	sensor_resolution->SensorSlimVideoHeight	 = imgsensor_info.slim_video.grabwindow_height;
-	return ERROR_NONE;
-}	/*	get_resolution	*/
-
-static kal_uint32 get_info(MSDK_SCENARIO_ID_ENUM scenario_id,
-					  MSDK_SENSOR_INFO_STRUCT *sensor_info,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("scenario_id = %d\n", scenario_id);
-
-	
-	//sensor_info->SensorVideoFrameRate = imgsensor_info.normal_video.max_framerate/10; /* not use */
-	//sensor_info->SensorStillCaptureFrameRate= imgsensor_info.cap.max_framerate/10; /* not use */
-	//imgsensor_info->SensorWebCamCaptureFrameRate= imgsensor_info.v.max_framerate; /* not use */
-
-	sensor_info->SensorClockPolarity = SENSOR_CLOCK_POLARITY_LOW;
-	sensor_info->SensorClockFallingPolarity = SENSOR_CLOCK_POLARITY_LOW; /* not use */
-	sensor_info->SensorHsyncPolarity = SENSOR_CLOCK_POLARITY_LOW; // inverse with datasheet
-	sensor_info->SensorVsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
-	sensor_info->SensorInterruptDelayLines = 4; /* not use */
-	sensor_info->SensorResetActiveHigh = FALSE; /* not use */
-	sensor_info->SensorResetDelayCount = 5; /* not use */
-
-	sensor_info->SensroInterfaceType = imgsensor_info.sensor_interface_type;
-	//sensor_info->MIPIsensorType = imgsensor_info.mipi_sensor_type;
-	//sensor_info->SettleDelayMode = imgsensor_info.mipi_settle_delay_mode;
-	sensor_info->SensorOutputDataFormat = imgsensor_info.sensor_output_dataformat;
-
-	sensor_info->CaptureDelayFrame = imgsensor_info.cap_delay_frame; 
-	sensor_info->PreviewDelayFrame = imgsensor_info.pre_delay_frame; 
-	sensor_info->VideoDelayFrame = imgsensor_info.video_delay_frame;
-	sensor_info->HighSpeedVideoDelayFrame = imgsensor_info.hs_video_delay_frame;
-	sensor_info->SlimVideoDelayFrame = imgsensor_info.slim_video_delay_frame;
-
-	sensor_info->SensorMasterClockSwitch = 0; /* not use */
-	sensor_info->SensorDrivingCurrent = imgsensor_info.isp_driving_current;
-	
-	sensor_info->AEShutDelayFrame = imgsensor_info.ae_shut_delay_frame; 		 /* The frame of setting shutter default 0 for TG int */
-	sensor_info->AESensorGainDelayFrame = imgsensor_info.ae_sensor_gain_delay_frame;	/* The frame of setting sensor gain */
-	sensor_info->AEISPGainDelayFrame = imgsensor_info.ae_ispGain_delay_frame;	
-	sensor_info->IHDR_Support = imgsensor_info.ihdr_support;
-	sensor_info->IHDR_LE_FirstLine = imgsensor_info.ihdr_le_firstline;
-	sensor_info->SensorModeNum = imgsensor_info.sensor_mode_num;
-	
-	sensor_info->SensorMIPILaneNumber = imgsensor_info.mipi_lane_num; 
-	sensor_info->SensorClockFreq = imgsensor_info.mclk;
-	sensor_info->SensorClockDividCount = 3; /* not use */
-	sensor_info->SensorClockRisingCount = 0;
-	sensor_info->SensorClockFallingCount = 2; /* not use */
-	sensor_info->SensorPixelClockCount = 3; /* not use */
-	sensor_info->SensorDataLatchCount = 2; /* not use */
-	
-	sensor_info->MIPIDataLowPwr2HighSpeedTermDelayCount = 0; 
-	sensor_info->MIPICLKLowPwr2HighSpeedTermDelayCount = 0;
-	sensor_info->SensorWidthSampling = 0;  // 0 is default 1x
-	sensor_info->SensorHightSampling = 0;	// 0 is default 1x 
-	sensor_info->SensorPacketECCOrder = 1;
-
-	switch (scenario_id) {
-		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-			sensor_info->SensorGrabStartX = imgsensor_info.pre.startx; 
-			sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;		
-			
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
-			
-			break;
-		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
-			sensor_info->SensorGrabStartX = imgsensor_info.cap.startx; 
-			sensor_info->SensorGrabStartY = imgsensor_info.cap.starty;
-				  
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.cap.mipi_data_lp2hs_settle_dc; 
-
-			break;	 
-		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-			
-			sensor_info->SensorGrabStartX = imgsensor_info.normal_video.startx; 
-			sensor_info->SensorGrabStartY = imgsensor_info.normal_video.starty;
-	   
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.normal_video.mipi_data_lp2hs_settle_dc; 
-
-			break;	  
-		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:			
-			sensor_info->SensorGrabStartX = imgsensor_info.hs_video.startx; 
-			sensor_info->SensorGrabStartY = imgsensor_info.hs_video.starty;
-				  
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.hs_video.mipi_data_lp2hs_settle_dc; 
-
-			break;
-		case MSDK_SCENARIO_ID_SLIM_VIDEO:
-			sensor_info->SensorGrabStartX = imgsensor_info.slim_video.startx; 
-			sensor_info->SensorGrabStartY = imgsensor_info.slim_video.starty;
-				  
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.slim_video.mipi_data_lp2hs_settle_dc; 
-
-			break;
-		default:			
-			sensor_info->SensorGrabStartX = imgsensor_info.pre.startx; 
-			sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;		
-			
-			sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount = imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
-			break;
-	}
-	
-	return ERROR_NONE;
-}	/*	get_info  */
-
-
-static kal_uint32 control(MSDK_SCENARIO_ID_ENUM scenario_id, MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
-					  MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
-{
-	LOG_INF("scenario_id = %d\n", scenario_id);
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.current_scenario_id = scenario_id;
-	spin_unlock(&imgsensor_drv_lock);
-	switch (scenario_id) {
-		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-			preview(image_window, sensor_config_data);
-			break;
-		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
-			capture(image_window, sensor_config_data);
-			break;	
-		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-			normal_video(image_window, sensor_config_data);
-			break;	  
-		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
-			hs_video(image_window, sensor_config_data);
-			break;
-		case MSDK_SCENARIO_ID_SLIM_VIDEO:
-			slim_video(image_window, sensor_config_data);
-			break;	  
-		default:
-			LOG_INF("Error ScenarioId setting");
-			preview(image_window, sensor_config_data);
-			return ERROR_INVALID_SCENARIO_ID;
-	}
-	return ERROR_NONE;
-}	/* control() */
-
-
-
-static kal_uint32 set_video_mode(UINT16 framerate)
-{
-	LOG_INF("framerate = %d\n ", framerate);
-	// SetVideoMode Function should fix framerate
-	if (framerate == 0)
-		// Dynamic frame rate
-		return ERROR_NONE;
-	spin_lock(&imgsensor_drv_lock);
-	if ((framerate == 300) && (imgsensor.autoflicker_en == KAL_TRUE))
-		imgsensor.current_fps = 296;
-	else if ((framerate == 150) && (imgsensor.autoflicker_en == KAL_TRUE))
-		imgsensor.current_fps = 146;
-	else
-		imgsensor.current_fps = framerate;
-	spin_unlock(&imgsensor_drv_lock);
-	set_max_framerate(imgsensor.current_fps,1);
-
-	return ERROR_NONE;
-}
-
-static kal_uint32 set_auto_flicker_mode(kal_bool enable, UINT16 framerate)
-{
-	LOG_INF("enable = %d, framerate = %d \n", enable, framerate);
-	spin_lock(&imgsensor_drv_lock);
-	if (enable) //enable auto flicker	  
-		imgsensor.autoflicker_en = KAL_TRUE;
-	else //Cancel Auto flick
-		imgsensor.autoflicker_en = KAL_FALSE;
-	spin_unlock(&imgsensor_drv_lock);
-	return ERROR_NONE;
-}
-
-
-static kal_uint32 set_max_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 framerate) 
-{
-	kal_uint32 frame_length;
-  
-	LOG_INF("scenario_id = %d, framerate = %d\n", scenario_id, framerate);
-
-	switch (scenario_id) {
-		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-			frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
-			imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();			
-			break;			
-		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-			if(framerate == 0)
-				return ERROR_NONE;
-			frame_length = imgsensor_info.normal_video.pclk / framerate * 10 / imgsensor_info.normal_video.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.normal_video.framelength) ? (frame_length - imgsensor_info.normal_video.framelength) : 0;			
-			imgsensor.frame_length = imgsensor_info.normal_video.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();			
-			break;
-		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
-		//case MSDK_SCENARIO_ID_CAMERA_ZSD:			
-			frame_length = imgsensor_info.cap.pclk / framerate * 10 / imgsensor_info.cap.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.cap.framelength) ? (frame_length - imgsensor_info.cap.framelength) : 0;
-			imgsensor.frame_length = imgsensor_info.cap.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();			
-			break;	
-		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
-			frame_length = imgsensor_info.hs_video.pclk / framerate * 10 / imgsensor_info.hs_video.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.hs_video.framelength) ? (frame_length - imgsensor_info.hs_video.framelength) : 0;
-			imgsensor.frame_length = imgsensor_info.hs_video.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();			
-			break;
-		case MSDK_SCENARIO_ID_SLIM_VIDEO:
-			frame_length = imgsensor_info.slim_video.pclk / framerate * 10 / imgsensor_info.slim_video.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.slim_video.framelength) ? (frame_length - imgsensor_info.slim_video.framelength): 0;	
-			imgsensor.frame_length = imgsensor_info.slim_video.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();			
-			break;		
-		default:  //coding with  preview scenario by default
-			frame_length = imgsensor_info.pre.pclk / framerate * 10 / imgsensor_info.pre.linelength;
-			spin_lock(&imgsensor_drv_lock);
-			imgsensor.dummy_line = (frame_length > imgsensor_info.pre.framelength) ? (frame_length - imgsensor_info.pre.framelength) : 0;
-			imgsensor.frame_length = imgsensor_info.pre.framelength + imgsensor.dummy_line;
-			imgsensor.min_frame_length = imgsensor.frame_length;
-			spin_unlock(&imgsensor_drv_lock);
-			set_dummy();	
-			LOG_INF("error scenario_id = %d, we use preview scenario \n", scenario_id);
-			break;
-	}	
-	return ERROR_NONE;
-}
-
-
-static kal_uint32 get_default_framerate_by_scenario(MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 *framerate) 
-{
-	LOG_INF("scenario_id = %d\n", scenario_id);
-
-	switch (scenario_id) {
-		case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-			*framerate = imgsensor_info.pre.max_framerate;
-			break;
-		case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-			*framerate = imgsensor_info.normal_video.max_framerate;
-			break;
-		case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
-			*framerate = imgsensor_info.cap.max_framerate;
-			break;		
-		case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
-			*framerate = imgsensor_info.hs_video.max_framerate;
-			break;
-		case MSDK_SCENARIO_ID_SLIM_VIDEO: 
-			*framerate = imgsensor_info.slim_video.max_framerate;
-			break;
-		default:
-			break;
-	}
-
-	return ERROR_NONE;
-}
-
-static kal_uint32 set_test_pattern_mode(kal_bool enable)
-{
-	LOG_INF("enable: %d\n", enable);
-
-	if (enable) {
-		// 0x5E00[8]: 1 enable,  0 disable
-		// 0x5E00[1:0]; 00 Color bar, 01 Random Data, 10 Square, 11 BLACK
-		write_cmos_sensor(0x5E00, 0x80);
-	} else {
-		// 0x5E00[8]: 1 enable,  0 disable
-		// 0x5E00[1:0]; 00 Color bar, 01 Random Data, 10 Square, 11 BLACK
-		write_cmos_sensor(0x5E00, 0x00);
-	}	 
-	spin_lock(&imgsensor_drv_lock);
-	imgsensor.test_pattern = enable;
-	spin_unlock(&imgsensor_drv_lock);
-	return ERROR_NONE;
-}
-
-static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
-                             UINT8 *feature_para,UINT32 *feature_para_len)
-{
-    UINT16 *feature_return_para_16=(UINT16 *) feature_para;
-    UINT16 *feature_data_16=(UINT16 *) feature_para;
-    UINT32 *feature_return_para_32=(UINT32 *) feature_para;
-    UINT32 *feature_data_32=(UINT32 *) feature_para;
-    unsigned long long *feature_data=(unsigned long long *) feature_para;
-    unsigned long long *feature_return_para=(unsigned long long *) feature_para;
-
-    SENSOR_WINSIZE_INFO_STRUCT *wininfo;
-    MSDK_SENSOR_REG_INFO_STRUCT *sensor_reg_data=(MSDK_SENSOR_REG_INFO_STRUCT *) feature_para;
-
-    LOG_INF("feature_id = %d\n", feature_id);
-    switch (feature_id) {
-        case SENSOR_FEATURE_GET_PERIOD:
-            *feature_return_para_16++ = imgsensor.line_length;
-            *feature_return_para_16 = imgsensor.frame_length;
-            *feature_para_len=4;
-            break;
-        case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:
-            *feature_return_para_32 = imgsensor.pclk;
-            *feature_para_len=4;
-            break;
-        case SENSOR_FEATURE_SET_ESHUTTER:
-            set_shutter(*feature_data);
-            break;
-        case SENSOR_FEATURE_SET_NIGHTMODE:
-            night_mode((BOOL) *feature_data);
-            break;
-        case SENSOR_FEATURE_SET_GAIN:
-            set_gain((UINT16) *feature_data);
-            break;
-        case SENSOR_FEATURE_SET_FLASHLIGHT:
-            break;
-        case SENSOR_FEATURE_SET_ISP_MASTER_CLOCK_FREQ:
-            break;
-        case SENSOR_FEATURE_SET_REGISTER:
-            write_cmos_sensor(sensor_reg_data->RegAddr, sensor_reg_data->RegData);
-            break;
-        case SENSOR_FEATURE_GET_REGISTER:
-            sensor_reg_data->RegData = read_cmos_sensor(sensor_reg_data->RegAddr);
-            break;
-        case SENSOR_FEATURE_GET_LENS_DRIVER_ID:
-            // get the lens driver ID from EEPROM or just return LENS_DRIVER_ID_DO_NOT_CARE
-            // if EEPROM does not exist in camera module.
-            *feature_return_para_32=LENS_DRIVER_ID_DO_NOT_CARE;
-            *feature_para_len=4;
-            break;
-        case SENSOR_FEATURE_SET_VIDEO_MODE:
-            set_video_mode(*feature_data);
-            break;
-        case SENSOR_FEATURE_CHECK_SENSOR_ID:
-            get_imgsensor_id(feature_return_para_32);
-            break;
-        case SENSOR_FEATURE_SET_AUTO_FLICKER_MODE:
-            set_auto_flicker_mode((BOOL)*feature_data_16,*(feature_data_16+1));
-            break;
-        case SENSOR_FEATURE_SET_MAX_FRAME_RATE_BY_SCENARIO:
-            set_max_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*feature_data, *(feature_data+1));
-            break;
-        case SENSOR_FEATURE_GET_DEFAULT_FRAME_RATE_BY_SCENARIO:
-            get_default_framerate_by_scenario((MSDK_SCENARIO_ID_ENUM)*(feature_data), (MUINT32 *)(uintptr_t)(*(feature_data+1)));
-            break;
-        case SENSOR_FEATURE_SET_TEST_PATTERN:
-            set_test_pattern_mode((BOOL)*feature_data);
-            break;
-        case SENSOR_FEATURE_GET_TEST_PATTERN_CHECKSUM_VALUE: //for factory mode auto testing
-            *feature_return_para_32 = imgsensor_info.checksum_value;
-            *feature_para_len=4;
-            break;
-        case SENSOR_FEATURE_SET_FRAMERATE:
-            LOG_INF("current fps :%d\n", (UINT32)*feature_data);
-            spin_lock(&imgsensor_drv_lock);
-            imgsensor.current_fps = *feature_data;
-            spin_unlock(&imgsensor_drv_lock);
-            break;
-        case SENSOR_FEATURE_SET_HDR:
-            LOG_INF("ihdr enable :%d\n", (BOOL)*feature_data);
-            spin_lock(&imgsensor_drv_lock);
-            imgsensor.ihdr_en = (BOOL)*feature_data;
-            spin_unlock(&imgsensor_drv_lock);
-            break;
-        case SENSOR_FEATURE_GET_CROP_INFO:
-            LOG_INF("SENSOR_FEATURE_GET_CROP_INFO scenarioId:%d\n", (UINT32)*feature_data);
-
-            wininfo = (SENSOR_WINSIZE_INFO_STRUCT *)(uintptr_t)(*(feature_data+1));
-
-            switch (*feature_data_32) {
-                case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
-                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[1],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-                    break;
-                case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
-                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[2],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-                    break;
-                case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
-                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[3],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-                    break;
-                case MSDK_SCENARIO_ID_SLIM_VIDEO:
-                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[4],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-                    break;
-                case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
-                default:
-                    memcpy((void *)wininfo,(void *)&imgsensor_winsize_info[0],sizeof(SENSOR_WINSIZE_INFO_STRUCT));
-                    break;
-            }
-        case SENSOR_FEATURE_SET_IHDR_SHUTTER_GAIN:
-            LOG_INF("SENSOR_SET_SENSOR_IHDR LE=%d, SE=%d, Gain=%d\n",(UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
-            ihdr_write_shutter_gain((UINT16)*feature_data,(UINT16)*(feature_data+1),(UINT16)*(feature_data+2));
-            break;
-        default:
-            break;
-    }
-
-    return ERROR_NONE;
-}    /*    feature_control()  */
-
-
-static SENSOR_FUNCTION_STRUCT sensor_func = {
-	open,
-	get_info,
-	get_resolution,
-	feature_control,
-	control,
-	close
-};
-
-
-UINT32 OV8858_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
-{
-	/* To Do : Check Sensor status here */
-	if (pfFunc!=NULL)
-		*pfFunc=&sensor_func;
-	return ERROR_NONE;
-}	/*	OV5693_MIPI_RAW_SensorInit	*/
-
-UINT32 OV8858R2A_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc)
-{
-	/* To Do : Check Sensor status here */
-	if (pfFunc!=NULL)
-		*pfFunc=&sensor_func;
-	return ERROR_NONE;
-}	/*	OV5693_MIPI_RAW_SensorInit	*/
-
-
diff --git a/drivers/misc/mediatek/keypad/kpd.c~ b/drivers/misc/mediatek/keypad/kpd.c~
deleted file mode 100755
index b8d97ae..0000000
--- a/drivers/misc/mediatek/keypad/kpd.c~
+++ /dev/null
@@ -1,1025 +0,0 @@
-/*
- * Copyright (C) 2010 MediaTek, Inc.
- *
- * Author: Terry Chang <terry.chang@mediatek.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-
-/*kpd.h file path: ALPS/mediatek/kernel/include/linux */
-#include <linux/kpd.h>
-#ifdef CONFIG_MTK_TC1_FM_AT_SUSPEND
-#include <linux/wakelock.h>
-#endif
-#ifdef CONFIG_OF
-#include <linux/of.h>
-#include <linux/of_address.h>
-#include <linux/of_irq.h>
-#endif
-
-#define KPD_NAME	"mtk-kpd"
-#define MTK_KP_WAKESOURCE	/* this is for auto set wake up source */
-
-#ifdef CONFIG_OF
-void __iomem *kp_base;
-static unsigned int kp_irqnr;
-#endif	
-struct input_dev *kpd_input_dev;
-static bool kpd_suspend = false;
-static int kpd_show_hw_keycode = 1;
-static int kpd_show_register = 1;
-static volatile int call_status = 0;
-#ifdef CONFIG_MTK_TC1_FM_AT_SUSPEND
-struct wake_lock kpd_suspend_lock; /* For suspend usage */
-#endif
-
-/*for kpd_memory_setting() function*/
-static u16 kpd_keymap[KPD_NUM_KEYS];
-static u16 kpd_keymap_state[KPD_NUM_MEMS];
-/***********************************/
-
-/* for slide QWERTY */
-#if KPD_HAS_SLIDE_QWERTY
-static void kpd_slide_handler(unsigned long data);
-static DECLARE_TASKLET(kpd_slide_tasklet, kpd_slide_handler, 0);
-static u8 kpd_slide_state = !KPD_SLIDE_POLARITY;
-#endif
-
-/* for Power key using EINT */
-#if KPD_PWRKEY_USE_EINT
-static void kpd_pwrkey_handler(unsigned long data);
-static DECLARE_TASKLET(kpd_pwrkey_tasklet, kpd_pwrkey_handler, 0);
-#endif
-
-/* for keymap handling */
-static void kpd_keymap_handler(unsigned long data);
-static DECLARE_TASKLET(kpd_keymap_tasklet, kpd_keymap_handler, 0);
-
-/*********************************************************************/
-static void kpd_memory_setting(void);
-
-/*********************************************************************/
-static int kpd_pdrv_probe(struct platform_device *pdev);
-static int kpd_pdrv_remove(struct platform_device *pdev);
-#ifndef USE_EARLY_SUSPEND
-static int kpd_pdrv_suspend(struct platform_device *pdev, pm_message_t state);
-static int kpd_pdrv_resume(struct platform_device *pdev);
-#endif
-
-#ifdef CONFIG_OF
-static const struct of_device_id kpd_of_match[] = {
-	{ .compatible = "mediatek,KP", },
-	{},
-};
-#endif
-
-static struct platform_driver kpd_pdrv = {
-	.probe = kpd_pdrv_probe,
-	.remove = kpd_pdrv_remove,
-#ifndef USE_EARLY_SUSPEND
-	.suspend = kpd_pdrv_suspend,
-	.resume = kpd_pdrv_resume,
-#endif
-	.driver = {
-		.name = KPD_NAME,
-		.owner = THIS_MODULE,
-#ifdef CONFIG_OF
-		.of_match_table = kpd_of_match,
-#endif
-	},
-};
-
-/********************************************************************/
-static void kpd_memory_setting(void)
-{
-	kpd_init_keymap(kpd_keymap);
-	kpd_init_keymap_state(kpd_keymap_state);
-	return;
-}
-
-
-/*****************for kpd auto set wake up source*************************/
-
-static ssize_t kpd_store_call_state(struct device_driver *ddri, const char *buf, size_t count)
-{
-	if (sscanf(buf, "%u", &call_status) != 1) {
-		kpd_print("kpd call state: Invalid values\n");
-		return -EINVAL;
-	}
-
-	switch (call_status) {
-	case 1:
-		kpd_print("kpd call state: Idle state!\n");
-		break;
-	case 2:
-		kpd_print("kpd call state: ringing state!\n");
-		break;
-	case 3:
-		kpd_print("kpd call state: active or hold state!\n");
-		break;
-
-	default:
-		kpd_print("kpd call state: Invalid values\n");
-		break;
-	}
-	return count;
-}
-
-static ssize_t kpd_show_call_state(struct device_driver *ddri, char *buf)
-{
-	ssize_t res;
-	res = snprintf(buf, PAGE_SIZE, "%d\n", call_status);
-	return res;
-}
-
-static DRIVER_ATTR(kpd_call_state, S_IWUSR | S_IRUGO, kpd_show_call_state, kpd_store_call_state);
-
-static struct driver_attribute *kpd_attr_list[] = {
-	&driver_attr_kpd_call_state,
-};
-
-/*----------------------------------------------------------------------------*/
-static int kpd_create_attr(struct device_driver *driver)
-{
-	int idx, err = 0;
-	int num = (int)(sizeof(kpd_attr_list) / sizeof(kpd_attr_list[0]));
-	if (driver == NULL) {
-		return -EINVAL;
-	}
-
-	for (idx = 0; idx < num; idx++) {
-		if ((err = driver_create_file(driver, kpd_attr_list[idx]))) {
-			kpd_print("driver_create_file (%s) = %d\n", kpd_attr_list[idx]->attr.name,
-				  err);
-			break;
-		}
-	}
-	return err;
-}
-
-/*----------------------------------------------------------------------------*/
-static int kpd_delete_attr(struct device_driver *driver)
-{
-	int idx, err = 0;
-	int num = (int)(sizeof(kpd_attr_list) / sizeof(kpd_attr_list[0]));
-
-	if (!driver)
-		return -EINVAL;
-
-	for (idx = 0; idx < num; idx++) {
-		driver_remove_file(driver, kpd_attr_list[idx]);
-	}
-
-	return err;
-}
-
-/*----------------------------------------------------------------------------*/
-/********************************************************************************************/
-/************************************************************************************************************************************************/
-/* for autotest */
-#if KPD_AUTOTEST
-static const u16 kpd_auto_keymap[] = {
-	KEY_MENU,
-	KEY_HOME, KEY_BACK,
-	KEY_CALL, KEY_ENDCALL,
-	KEY_VOLUMEUP, KEY_VOLUMEDOWN,
-	KEY_FOCUS, KEY_CAMERA,
-};
-#endif
-/* for AEE manual dump */
-#define AEE_VOLUMEUP_BIT	0
-#define AEE_VOLUMEDOWN_BIT	1
-#define AEE_DELAY_TIME		15
-/* enable volup + voldown was pressed 5~15 s Trigger aee manual dump */
-#define AEE_ENABLE_5_15		1
-static struct hrtimer aee_timer;
-static unsigned long aee_pressed_keys;
-static bool aee_timer_started;
-
-#if AEE_ENABLE_5_15
-#define AEE_DELAY_TIME_5S	5
-static struct hrtimer aee_timer_5s;
-static bool aee_timer_5s_started;
-static bool flags_5s;
-#endif
-
-static inline void kpd_update_aee_state(void)
-{
-	if (aee_pressed_keys == ((1 << AEE_VOLUMEUP_BIT) | (1 << AEE_VOLUMEDOWN_BIT))) {
-		/* if volumeup and volumedown was pressed the same time then start the time of ten seconds */
-		aee_timer_started = true;
-
-#if AEE_ENABLE_5_15
-		aee_timer_5s_started = true;
-		hrtimer_start(&aee_timer_5s, ktime_set(AEE_DELAY_TIME_5S, 0), HRTIMER_MODE_REL);
-#endif
-		hrtimer_start(&aee_timer, ktime_set(AEE_DELAY_TIME, 0), HRTIMER_MODE_REL);
-		kpd_print("aee_timer started\n");
-	} else {
-		if (aee_timer_started) {
-/*
-  * hrtimer_cancel - cancel a timer and wait for the handler to finish.
-  * Returns:
-  *	0 when the timer was not active.
-  *	1 when the timer was active.
- */
-			if (hrtimer_cancel(&aee_timer)) {
-				kpd_print("try to cancel hrtimer\n");
-#if AEE_ENABLE_5_15
-				if (flags_5s) {
-					printk
-					    ("Pressed Volup + Voldown5s~15s then trigger aee manual dump.\n");
-					aee_kernel_reminding("manual dump",
-							     "Trigger Vol Up +Vol Down 5s");
-				}
-#endif
-
-			}
-#if AEE_ENABLE_5_15
-			flags_5s = false;
-#endif
-			aee_timer_started = false;
-			kpd_print("aee_timer canceled\n");
-		}
-#if AEE_ENABLE_5_15
-		if (aee_timer_5s_started) {
-/*
-  * hrtimer_cancel - cancel a timer and wait for the handler to finish.
-  * Returns:
-  *	0 when the timer was not active.
-  *	1 when the timer was active.
- */
-			if (hrtimer_cancel(&aee_timer_5s)) {
-				kpd_print("try to cancel hrtimer (5s)\n");
-			}
-			aee_timer_5s_started = false;
-			kpd_print("aee_timer canceled (5s)\n");
-		}
-#endif
-	}
-}
-
-static void kpd_aee_handler(u32 keycode, u16 pressed)
-{
-	if (pressed) {
-		if (keycode == KEY_VOLUMEUP) {
-			__set_bit(AEE_VOLUMEUP_BIT, &aee_pressed_keys);
-		} else if (keycode == KEY_VOLUMEDOWN) {
-			__set_bit(AEE_VOLUMEDOWN_BIT, &aee_pressed_keys);
-		} else {
-			return;
-		}
-		kpd_update_aee_state();
-	} else {
-		if (keycode == KEY_VOLUMEUP) {
-			__clear_bit(AEE_VOLUMEUP_BIT, &aee_pressed_keys);
-		} else if (keycode == KEY_VOLUMEDOWN) {
-			__clear_bit(AEE_VOLUMEDOWN_BIT, &aee_pressed_keys);
-		} else {
-			return;
-		}
-		kpd_update_aee_state();
-	}
-}
-
-static enum hrtimer_restart aee_timer_func(struct hrtimer *timer)
-{
-	/* printk("kpd: vol up+vol down AEE manual dump!\n"); */
-	/* aee_kernel_reminding("manual dump ", "Triggered by press KEY_VOLUMEUP+KEY_VOLUMEDOWN"); */
-	aee_trigger_kdb();
-	return HRTIMER_NORESTART;
-}
-
-#if AEE_ENABLE_5_15
-static enum hrtimer_restart aee_timer_5s_func(struct hrtimer *timer)
-{
-
-	/* printk("kpd: vol up+vol down AEE manual dump timer 5s !\n"); */
-	flags_5s = true;
-	return HRTIMER_NORESTART;
-}
-#endif
-
-/************************************************************************************************************************************************/
-
-#if KPD_HAS_SLIDE_QWERTY
-static void kpd_slide_handler(unsigned long data)
-{
-	bool slid;
-	u8 old_state = kpd_slide_state;
-
-	kpd_slide_state = !kpd_slide_state;
-	slid = (kpd_slide_state == !!KPD_SLIDE_POLARITY);
-	/* for SW_LID, 1: lid open => slid, 0: lid shut => closed */
-	input_report_switch(kpd_input_dev, SW_LID, slid);
-	input_sync(kpd_input_dev);
-	kpd_print("report QWERTY = %s\n", slid ? "slid" : "closed");
-
-	if (old_state) {
-		mt_set_gpio_pull_select(GPIO_QWERTYSLIDE_EINT_PIN, 0);
-	} else {
-		mt_set_gpio_pull_select(GPIO_QWERTYSLIDE_EINT_PIN, 1);
-	}
-	/* for detecting the return to old_state */
-	mt65xx_eint_set_polarity(KPD_SLIDE_EINT, old_state);
-	mt65xx_eint_unmask(KPD_SLIDE_EINT);
-}
-
-static void kpd_slide_eint_handler(void)
-{
-	tasklet_schedule(&kpd_slide_tasklet);
-}
-#endif
-
-#if KPD_PWRKEY_USE_EINT
-static void kpd_pwrkey_handler(unsigned long data)
-{
-	kpd_pwrkey_handler_hal(data);
-}
-
-static void kpd_pwrkey_eint_handler(void)
-{
-	tasklet_schedule(&kpd_pwrkey_tasklet);
-}
-#endif
-/*********************************************************************/
-
-/*********************************************************************/
-#if KPD_PWRKEY_USE_PMIC
-void kpd_pwrkey_pmic_handler(unsigned long pressed)
-{
-	printk(KPD_SAY "Power Key generate, pressed=%ld\n", pressed);
-	if (!kpd_input_dev) {
-		printk("KPD input device not ready\n");
-		return;
-	}
-	kpd_pmic_pwrkey_hal(pressed);
-}
-#endif
-
-
-void kpd_pmic_rstkey_handler(unsigned long pressed)
-{
-	printk(KPD_SAY "PMIC reset Key generate, pressed=%ld\n", pressed);
-	if (!kpd_input_dev) {
-		printk("KPD input device not ready\n");
-		return;
-	}
-	kpd_pmic_rstkey_hal(pressed);
-#ifdef KPD_PMIC_RSTKEY_MAP
-	kpd_aee_handler(KPD_PMIC_RSTKEY_MAP, pressed);
-#endif
-}
-
-/*********************************************************************/
-
-/*********************************************************************/
-static void kpd_keymap_handler(unsigned long data)
-{
-	int i, j;
-	bool pressed;
-	u16 new_state[KPD_NUM_MEMS], change, mask;
-	u16 hw_keycode, linux_keycode;
-	kpd_get_keymap_state(new_state);
-
-#ifdef CONFIG_MTK_TC1_FM_AT_SUSPEND
-	wake_lock_timeout(&kpd_suspend_lock, HZ / 2);
-#endif
-
-	for (i = 0; i < KPD_NUM_MEMS; i++) {
-		change = new_state[i] ^ kpd_keymap_state[i];
-		if (!change)
-			continue;
-
-		for (j = 0; j < 16; j++) {
-			mask = 1U << j;
-			if (!(change & mask))
-				continue;
-
-			hw_keycode = (i << 4) + j;
-			/* bit is 1: not pressed, 0: pressed */
-			pressed = !(new_state[i] & mask);
-			if (kpd_show_hw_keycode) {
-				printk(KPD_SAY "(%s) HW keycode = %u\n",
-				       pressed ? "pressed" : "released", hw_keycode);
-			}
-			BUG_ON(hw_keycode >= KPD_NUM_KEYS);
-			linux_keycode = kpd_keymap[hw_keycode];
-			if (unlikely(linux_keycode == 0)) {
-				kpd_print("Linux keycode = 0\n");
-				continue;
-			}
-			kpd_aee_handler(linux_keycode, pressed);
-
-			kpd_backlight_handler(pressed, linux_keycode);
-			input_report_key(kpd_input_dev, linux_keycode, pressed);
-			input_sync(kpd_input_dev);
-			kpd_print("report Linux keycode = %u\n", linux_keycode);
-		}
-	}
-
-	memcpy(kpd_keymap_state, new_state, sizeof(new_state));
-	kpd_print("save new keymap state\n");
-#ifdef CONFIG_OF
-	enable_irq(kp_irqnr);
-#else
-	enable_irq(MT_KP_IRQ_ID);
-#endif
-}
-
-static irqreturn_t kpd_irq_handler(int irq, void *dev_id)
-{
-	/* use _nosync to avoid deadlock */
-#ifdef CONFIG_OF
-	disable_irq_nosync(kp_irqnr);
-#else
-	disable_irq_nosync(MT_KP_IRQ_ID);
-#endif
-	tasklet_schedule(&kpd_keymap_tasklet);
-	return IRQ_HANDLED;
-}
-
-/*********************************************************************/
-
-/*****************************************************************************************/
-long kpd_dev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
-{
-	/* void __user *uarg = (void __user *)arg; */
-
-	switch (cmd) {
-#if KPD_AUTOTEST
-	case PRESS_OK_KEY:	/* KPD_AUTOTEST disable auto test setting to resolve CR ALPS00464496 */
-		if (test_bit(KEY_OK, kpd_input_dev->keybit)) {
-			printk("[AUTOTEST] PRESS OK KEY!!\n");
-			input_report_key(kpd_input_dev, KEY_OK, 1);
-			input_sync(kpd_input_dev);
-		} else {
-			printk("[AUTOTEST] Not Support OK KEY!!\n");
-		}
-		break;
-	case RELEASE_OK_KEY:
-		if (test_bit(KEY_OK, kpd_input_dev->keybit)) {
-			printk("[AUTOTEST] RELEASE OK KEY!!\n");
-			input_report_key(kpd_input_dev, KEY_OK, 0);
-			input_sync(kpd_input_dev);
-		} else {
-			printk("[AUTOTEST] Not Support OK KEY!!\n");
-		}
-		break;
-	case PRESS_MENU_KEY:
-		if (test_bit(KEY_MENU, kpd_input_dev->keybit)) {
-			printk("[AUTOTEST] PRESS MENU KEY!!\n");
-			input_report_key(kpd_input_dev, KEY_MENU, 1);
-			input_sync(kpd_input_dev);
-		} else {
-			printk("[AUTOTEST] Not Support MENU KEY!!\n");
-		}
-		break;
-	case RELEASE_MENU_KEY:
-		if (test_bit(KEY_MENU, kpd_input_dev->keybit)) {
-			printk("[AUTOTEST] RELEASE MENU KEY!!\n");
-			input_report_key(kpd_input_dev, KEY_MENU, 0);
-			input_sync(kpd_input_dev);
-		} else {
-			printk("[AUTOTEST] Not Support MENU KEY!!\n");
-		}
-
-		break;
-	case PRESS_UP_KEY:
-		if (test_bit(KEY_UP, kpd_input_dev->keybit)) {
-			printk("[AUTOTEST] PRESS UP KEY!!\n");
-			input_report_key(kpd_input_dev, KEY_UP, 1);
-			input_sync(kpd_input_dev);
-		} else {
-			printk("[AUTOTEST] Not Support UP KEY!!\n");
-		}
-		break;
-	case RELEASE_UP_KEY:
-		if (test_bit(KEY_UP, kpd_input_dev->keybit)) {
-			printk("[AUTOTEST] RELEASE UP KEY!!\n");
-			input_report_key(kpd_input_dev, KEY_UP, 0);
-			input_sync(kpd_input_dev);
-		} else {
-			printk("[AUTOTEST] Not Support UP KEY!!\n");
-		}
-		break;
-	case PRESS_DOWN_KEY:
-		if (test_bit(KEY_DOWN, kpd_input_dev->keybit)) {
-			printk("[AUTOTEST] PRESS DOWN KEY!!\n");
-			input_report_key(kpd_input_dev, KEY_DOWN, 1);
-			input_sync(kpd_input_dev);
-		} else {
-			printk("[AUTOTEST] Not Support DOWN KEY!!\n");
-		}
-		break;
-	case RELEASE_DOWN_KEY:
-		if (test_bit(KEY_DOWN, kpd_input_dev->keybit)) {
-			printk("[AUTOTEST] RELEASE DOWN KEY!!\n");
-			input_report_key(kpd_input_dev, KEY_DOWN, 0);
-			input_sync(kpd_input_dev);
-		} else {
-			printk("[AUTOTEST] Not Support DOWN KEY!!\n");
-		}
-		break;
-	case PRESS_LEFT_KEY:
-		if (test_bit(KEY_LEFT, kpd_input_dev->keybit)) {
-			printk("[AUTOTEST] PRESS LEFT KEY!!\n");
-			input_report_key(kpd_input_dev, KEY_LEFT, 1);
-			input_sync(kpd_input_dev);
-		} else {
-			printk("[AUTOTEST] Not Support LEFT KEY!!\n");
-		}
-		break;
-	case RELEASE_LEFT_KEY:
-		if (test_bit(KEY_LEFT, kpd_input_dev->keybit)) {
-			printk("[AUTOTEST] RELEASE LEFT KEY!!\n");
-			input_report_key(kpd_input_dev, KEY_LEFT, 0);
-			input_sync(kpd_input_dev);
-		} else {
-			printk("[AUTOTEST] Not Support LEFT KEY!!\n");
-		}
-		break;
-
-	case PRESS_RIGHT_KEY:
-		if (test_bit(KEY_RIGHT, kpd_input_dev->keybit)) {
-			printk("[AUTOTEST] PRESS RIGHT KEY!!\n");
-			input_report_key(kpd_input_dev, KEY_RIGHT, 1);
-			input_sync(kpd_input_dev);
-		} else {
-			printk("[AUTOTEST] Not Support RIGHT KEY!!\n");
-		}
-		break;
-	case RELEASE_RIGHT_KEY:
-		if (test_bit(KEY_RIGHT, kpd_input_dev->keybit)) {
-			printk("[AUTOTEST] RELEASE RIGHT KEY!!\n");
-			input_report_key(kpd_input_dev, KEY_RIGHT, 0);
-			input_sync(kpd_input_dev);
-		} else {
-			printk("[AUTOTEST] Not Support RIGHT KEY!!\n");
-		}
-		break;
-	case PRESS_HOME_KEY:
-		if (test_bit(KEY_HOME, kpd_input_dev->keybit)) {
-			printk("[AUTOTEST] PRESS HOME KEY!!\n");
-			input_report_key(kpd_input_dev, KEY_HOME, 1);
-			input_sync(kpd_input_dev);
-		} else {
-			printk("[AUTOTEST] Not Support HOME KEY!!\n");
-		}
-		break;
-	case RELEASE_HOME_KEY:
-		if (test_bit(KEY_HOME, kpd_input_dev->keybit)) {
-			printk("[AUTOTEST] RELEASE HOME KEY!!\n");
-			input_report_key(kpd_input_dev, KEY_HOME, 0);
-			input_sync(kpd_input_dev);
-		} else {
-			printk("[AUTOTEST] Not Support HOME KEY!!\n");
-		}
-		break;
-	case PRESS_BACK_KEY:
-		if (test_bit(KEY_BACK, kpd_input_dev->keybit)) {
-			printk("[AUTOTEST] PRESS BACK KEY!!\n");
-			input_report_key(kpd_input_dev, KEY_BACK, 1);
-			input_sync(kpd_input_dev);
-		} else {
-			printk("[AUTOTEST] Not Support BACK KEY!!\n");
-		}
-		break;
-	case RELEASE_BACK_KEY:
-		if (test_bit(KEY_BACK, kpd_input_dev->keybit)) {
-			printk("[AUTOTEST] RELEASE BACK KEY!!\n");
-			input_report_key(kpd_input_dev, KEY_BACK, 0);
-			input_sync(kpd_input_dev);
-		} else {
-			printk("[AUTOTEST] Not Support BACK KEY!!\n");
-		}
-		break;
-	case PRESS_CALL_KEY:
-		if (test_bit(KEY_CALL, kpd_input_dev->keybit)) {
-			printk("[AUTOTEST] PRESS CALL KEY!!\n");
-			input_report_key(kpd_input_dev, KEY_CALL, 1);
-			input_sync(kpd_input_dev);
-		} else {
-			printk("[AUTOTEST] Not Support CALL KEY!!\n");
-		}
-		break;
-	case RELEASE_CALL_KEY:
-		if (test_bit(KEY_CALL, kpd_input_dev->keybit)) {
-			printk("[AUTOTEST] RELEASE CALL KEY!!\n");
-			input_report_key(kpd_input_dev, KEY_CALL, 0);
-			input_sync(kpd_input_dev);
-		} else {
-			printk("[AUTOTEST] Not Support CALL KEY!!\n");
-		}
-		break;
-
-	case PRESS_ENDCALL_KEY:
-		if (test_bit(KEY_ENDCALL, kpd_input_dev->keybit)) {
-			printk("[AUTOTEST] PRESS ENDCALL KEY!!\n");
-			input_report_key(kpd_input_dev, KEY_ENDCALL, 1);
-			input_sync(kpd_input_dev);
-		} else {
-			printk("[AUTOTEST] Not Support ENDCALL KEY!!\n");
-		}
-		break;
-	case RELEASE_ENDCALL_KEY:
-		if (test_bit(KEY_ENDCALL, kpd_input_dev->keybit)) {
-			printk("[AUTOTEST] RELEASE ENDCALL KEY!!\n");
-			input_report_key(kpd_input_dev, KEY_ENDCALL, 0);
-			input_sync(kpd_input_dev);
-		} else {
-			printk("[AUTOTEST] Not Support ENDCALL KEY!!\n");
-		}
-		break;
-	case PRESS_VLUP_KEY:
-		if (test_bit(KEY_VOLUMEUP, kpd_input_dev->keybit)) {
-			printk("[AUTOTEST] PRESS VOLUMEUP KEY!!\n");
-			input_report_key(kpd_input_dev, KEY_VOLUMEUP, 1);
-			input_sync(kpd_input_dev);
-		} else {
-			printk("[AUTOTEST] Not Support VOLUMEUP KEY!!\n");
-		}
-		break;
-	case RELEASE_VLUP_KEY:
-		if (test_bit(KEY_VOLUMEUP, kpd_input_dev->keybit)) {
-			printk("[AUTOTEST] RELEASE VOLUMEUP KEY!!\n");
-			input_report_key(kpd_input_dev, KEY_VOLUMEUP, 0);
-			input_sync(kpd_input_dev);
-		} else {
-			printk("[AUTOTEST] Not Support VOLUMEUP KEY!!\n");
-		}
-		break;
-	case PRESS_VLDOWN_KEY:
-		if (test_bit(KEY_VOLUMEDOWN, kpd_input_dev->keybit)) {
-			printk("[AUTOTEST] PRESS VOLUMEDOWN KEY!!\n");
-			input_report_key(kpd_input_dev, KEY_VOLUMEDOWN, 1);
-			input_sync(kpd_input_dev);
-		} else {
-			printk("[AUTOTEST] Not Support VOLUMEDOWN KEY!!\n");
-		}
-		break;
-	case RELEASE_VLDOWN_KEY:
-		if (test_bit(KEY_VOLUMEDOWN, kpd_input_dev->keybit)) {
-			printk("[AUTOTEST] RELEASE VOLUMEDOWN KEY!!\n");
-			input_report_key(kpd_input_dev, KEY_VOLUMEDOWN, 0);
-			input_sync(kpd_input_dev);
-		} else {
-			printk("[AUTOTEST] Not Support VOLUMEDOWN KEY!!\n");
-		}
-		break;
-	case PRESS_FOCUS_KEY:
-		if (test_bit(KEY_FOCUS, kpd_input_dev->keybit)) {
-			printk("[AUTOTEST] PRESS FOCUS KEY!!\n");
-			input_report_key(kpd_input_dev, KEY_FOCUS, 1);
-			input_sync(kpd_input_dev);
-		} else {
-			printk("[AUTOTEST] Not Support FOCUS KEY!!\n");
-		}
-		break;
-	case RELEASE_FOCUS_KEY:
-		if (test_bit(KEY_FOCUS, kpd_input_dev->keybit)) {
-			printk("[AUTOTEST] RELEASE FOCUS KEY!!\n");
-			input_report_key(kpd_input_dev, KEY_FOCUS, 0);
-			input_sync(kpd_input_dev);
-		} else {
-			printk("[AUTOTEST] Not Support RELEASE KEY!!\n");
-		}
-		break;
-	case PRESS_CAMERA_KEY:
-		if (test_bit(KEY_CAMERA, kpd_input_dev->keybit)) {
-			printk("[AUTOTEST] PRESS CAMERA KEY!!\n");
-			input_report_key(kpd_input_dev, KEY_CAMERA, 1);
-			input_sync(kpd_input_dev);
-		} else {
-			printk("[AUTOTEST] Not Support CAMERA KEY!!\n");
-		}
-		break;
-	case RELEASE_CAMERA_KEY:
-		if (test_bit(KEY_CAMERA, kpd_input_dev->keybit)) {
-			printk("[AUTOTEST] RELEASE CAMERA KEY!!\n");
-			input_report_key(kpd_input_dev, KEY_CAMERA, 0);
-			input_sync(kpd_input_dev);
-		} else {
-			printk("[AUTOTEST] Not Support CAMERA KEY!!\n");
-		}
-		break;
-	case PRESS_POWER_KEY:
-		if (test_bit(KEY_POWER, kpd_input_dev->keybit)) {
-			printk("[AUTOTEST] PRESS POWER KEY!!\n");
-			input_report_key(kpd_input_dev, KEY_POWER, 1);
-			input_sync(kpd_input_dev);
-		} else {
-			printk("[AUTOTEST] Not Support POWER KEY!!\n");
-		}
-		break;
-	case RELEASE_POWER_KEY:
-		if (test_bit(KEY_POWER, kpd_input_dev->keybit)) {
-			printk("[AUTOTEST] RELEASE POWER KEY!!\n");
-			input_report_key(kpd_input_dev, KEY_POWER, 0);
-			input_sync(kpd_input_dev);
-		} else {
-			printk("[AUTOTEST] Not Support POWER KEY!!\n");
-		}
-		break;
-#endif
-
-	case SET_KPD_KCOL:
-		kpd_auto_test_for_factorymode();	/* API 3 for kpd factory mode auto-test */
-		printk("[kpd_auto_test_for_factorymode] test performed!!\n");
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-
-int kpd_dev_open(struct inode *inode, struct file *file)
-{
-	return 0;
-}
-
-static struct file_operations kpd_dev_fops = {
-	.owner = THIS_MODULE,
-	.unlocked_ioctl = kpd_dev_ioctl,
-	.open = kpd_dev_open,
-};
-
-/*********************************************************************/
-static struct miscdevice kpd_dev = {
-	.minor = MISC_DYNAMIC_MINOR,
-	.name = KPD_NAME,
-	.fops = &kpd_dev_fops,
-};
-
-static int kpd_open(struct input_dev *dev)
-{
-	kpd_slide_qwerty_init();	/* API 1 for kpd slide qwerty init settings */
-	return 0;
-}
-
-
-static int kpd_pdrv_probe(struct platform_device *pdev)
-{
-
-	int i, r;
-	int err = 0;
-
-#ifdef CONFIG_OF
-	kp_base = of_iomap(pdev->dev.of_node, 0);
-	if (!kp_base) {
-		pr_warn(KPD_SAY "KP iomap failed\n");
-		return -ENODEV;
-	};
-
-	kp_irqnr = irq_of_parse_and_map(pdev->dev.of_node, 0);
-	if (!kp_irqnr) {
-		pr_warn(KPD_SAY "KP get irqnr failed\n");
-		return -ENODEV;
-	}
-	pr_warn(KPD_SAY "kp base: 0x%p, addr:0x%p,  kp irq: %d\n", kp_base,&kp_base, kp_irqnr);
-#endif
-
-	kpd_ldvt_test_init();	/* API 2 for kpd LFVT test enviroment settings */
-
-	/* initialize and register input device (/dev/input/eventX) */
-	kpd_input_dev = input_allocate_device();
-	if (!kpd_input_dev)
-		return -ENOMEM;
-
-	kpd_input_dev->name = KPD_NAME;
-	kpd_input_dev->id.bustype = BUS_HOST;
-	kpd_input_dev->id.vendor = 0x2454;
-	kpd_input_dev->id.product = 0x6500;
-	kpd_input_dev->id.version = 0x0010;
-	kpd_input_dev->open = kpd_open;
-
-	/* fulfill custom settings */
-	kpd_memory_setting();
-
-	__set_bit(EV_KEY, kpd_input_dev->evbit);
-
-#if (KPD_PWRKEY_USE_EINT || KPD_PWRKEY_USE_PMIC)
-	__set_bit(KPD_PWRKEY_MAP, kpd_input_dev->keybit);
-	kpd_keymap[8] = 0;
-#endif
-
-#if !KPD_USE_EXTEND_TYPE
-	for (i = 17; i < KPD_NUM_KEYS; i += 9)	/* only [8] works for Power key */
-		kpd_keymap[i] = 0;
-#endif
-
-	for (i = 0; i < KPD_NUM_KEYS; i++) {
-		if (kpd_keymap[i] != 0)
-			__set_bit(kpd_keymap[i], kpd_input_dev->keybit);
-	}
-
-#if KPD_AUTOTEST
-	for (i = 0; i < ARRAY_SIZE(kpd_auto_keymap); i++)
-		__set_bit(kpd_auto_keymap[i], kpd_input_dev->keybit);
-#endif
-
-#if KPD_HAS_SLIDE_QWERTY
-	__set_bit(EV_SW, kpd_input_dev->evbit);
-	__set_bit(SW_LID, kpd_input_dev->swbit);
-#endif
-
-#ifdef KPD_PMIC_RSTKEY_MAP
-	__set_bit(KPD_PMIC_RSTKEY_MAP, kpd_input_dev->keybit);
-#endif
-
-#ifdef KPD_KEY_MAP
-		__set_bit(KPD_KEY_MAP, kpd_input_dev->keybit);
-#endif
-
-	kpd_input_dev->dev.parent = &pdev->dev;
-	r = input_register_device(kpd_input_dev);
-	if (r) {
-		printk(KPD_SAY "register input device failed (%d)\n", r);
-		input_free_device(kpd_input_dev);
-		return r;
-	}
-
-	/* register device (/dev/mt6575-kpd) */
-	kpd_dev.parent = &pdev->dev;
-	r = misc_register(&kpd_dev);
-	if (r) {
-		printk(KPD_SAY "register device failed (%d)\n", r);
-		input_unregister_device(kpd_input_dev);
-		return r;
-	}
-
-#ifdef CONFIG_MTK_TC1_FM_AT_SUSPEND
-	wake_lock_init(&kpd_suspend_lock, WAKE_LOCK_SUSPEND, "kpd wakelock");
-#endif
-
-	/* register IRQ and EINT */
-	kpd_set_debounce(KPD_KEY_DEBOUNCE);
-#ifdef CONFIG_OF
-	r = request_irq(kp_irqnr, kpd_irq_handler, IRQF_TRIGGER_NONE, KPD_NAME, NULL);
-#else
-	r = request_irq(MT_KP_IRQ_ID, kpd_irq_handler, IRQF_TRIGGER_FALLING, KPD_NAME, NULL);
-#endif
-	if (r) {
-		printk(KPD_SAY "register IRQ failed (%d)\n", r);
-		misc_deregister(&kpd_dev);
-		input_unregister_device(kpd_input_dev);
-		return r;
-	}
-	mt_eint_register();
-
-#ifndef KPD_EARLY_PORTING	/*add for avoid early porting build err the macro is defined in custom file */
-	long_press_reboot_function_setting();	/* /API 4 for kpd long press reboot function setting */
-#endif
-	hrtimer_init(&aee_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-	aee_timer.function = aee_timer_func;
-
-#if AEE_ENABLE_5_15
-	hrtimer_init(&aee_timer_5s, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-	aee_timer_5s.function = aee_timer_5s_func;
-#endif
-
-	if ((err = kpd_create_attr(&kpd_pdrv.driver))) {
-		kpd_print("create attr file fail\n");
-		kpd_delete_attr(&kpd_pdrv.driver);
-		return err;
-	}
-    pr_warn(KPD_SAY "%s Done\n", __FUNCTION__);
-	return 0;
-}
-
-/* should never be called */
-static int kpd_pdrv_remove(struct platform_device *pdev)
-{
-	return 0;
-}
-
-#ifndef USE_EARLY_SUSPEND
-static int kpd_pdrv_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	kpd_suspend = true;
-#if 1//def MTK_KP_WAKESOURCE//by zhu
-	if (call_status == 2) {
-		kpd_print("kpd_early_suspend wake up source enable!! (%d)\n", kpd_suspend);
-	} else {
-		kpd_wakeup_src_setting(1);//kpd_wakeup_src_setting(0);
-		kpd_print("kpd_early_suspend wake up source disable!! (%d)\n", kpd_suspend);
-	}
-#endif
-	kpd_disable_backlight();
-	kpd_print("suspend!! (%d)\n", kpd_suspend);
-	return 0;
-}
-
-static int kpd_pdrv_resume(struct platform_device *pdev)
-{
-	kpd_suspend = false;
-#ifdef MTK_KP_WAKESOURCE
-	if (call_status == 2) {
-		kpd_print("kpd_early_suspend wake up source enable!! (%d)\n", kpd_suspend);
-	} else {
-		kpd_print("kpd_early_suspend wake up source resume!! (%d)\n", kpd_suspend);
-		kpd_wakeup_src_setting(1);
-	}
-#endif
-	kpd_print("resume!! (%d)\n", kpd_suspend);
-	return 0;
-}
-#else
-#define kpd_pdrv_suspend	NULL
-#define kpd_pdrv_resume		NULL
-#endif
-
-
-#ifdef USE_EARLY_SUSPEND
-static void kpd_early_suspend(struct early_suspend *h)
-{
-	kpd_suspend = true;
-#ifdef MTK_KP_WAKESOURCE
-	if (call_status == 2) {
-		kpd_print("kpd_early_suspend wake up source enable!! (%d)\n", kpd_suspend);
-	} else {
-		/* kpd_wakeup_src_setting(0); */
-		kpd_print("kpd_early_suspend wake up source disable!! (%d)\n", kpd_suspend);
-	}
-#endif
-	kpd_disable_backlight();
-	kpd_print("early suspend!! (%d)\n", kpd_suspend);
-}
-
-static void kpd_early_resume(struct early_suspend *h)
-{
-	kpd_suspend = false;
-#ifdef MTK_KP_WAKESOURCE
-	if (call_status == 2) {
-		kpd_print("kpd_early_resume wake up source resume!! (%d)\n", kpd_suspend);
-	} else {
-		kpd_print("kpd_early_resume wake up source enable!! (%d)\n", kpd_suspend);
-		/* kpd_wakeup_src_setting(1); */
-	}
-#endif
-	kpd_print("early resume!! (%d)\n", kpd_suspend);
-}
-
-static struct early_suspend kpd_early_suspend_desc = {
-	.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1,
-	.suspend = kpd_early_suspend,
-	.resume = kpd_early_resume,
-};
-#endif
-
-#ifdef CONFIG_MTK_SMARTBOOK_SUPPORT
-#ifdef CONFIG_HAS_SBSUSPEND
-static struct sb_handler kpd_sb_handler_desc = {
-	.level = SB_LEVEL_DISABLE_KEYPAD,
-	.plug_in = sb_kpd_enable,
-	.plug_out = sb_kpd_disable,
-};
-#endif
-#endif
-
-static int __init kpd_mod_init(void)
-{
-	int r;
-
-	r = platform_driver_register(&kpd_pdrv);
-	if (r) {
-		printk(KPD_SAY "register driver failed (%d)\n", r);
-		return r;
-	}
-#ifdef USE_EARLY_SUSPEND
-	register_early_suspend(&kpd_early_suspend_desc);
-#endif
-
-#ifdef CONFIG_MTK_SMARTBOOK_SUPPORT
-#ifdef CONFIG_HAS_SBSUSPEND
-	register_sb_handler(&kpd_sb_handler_desc);
-#endif
-#endif
-
-	return 0;
-}
-
-/* should never be called */
-static void __exit kpd_mod_exit(void)
-{
-}
-module_init(kpd_mod_init);
-module_exit(kpd_mod_exit);
-
-module_param(kpd_show_hw_keycode, int, 0644);
-module_param(kpd_show_register, int, 0644);
-
-MODULE_AUTHOR("yucong.xiong <yucong.xiong@mediatek.com>");
-MODULE_DESCRIPTION("MTK Keypad (KPD) Driver v0.4");
-MODULE_LICENSE("GPL");
diff --git a/drivers/misc/mediatek/lcm/hct_otm1282a_dsi_vdo_hd_auo/Makefile~ b/drivers/misc/mediatek/lcm/hct_otm1282a_dsi_vdo_hd_auo/Makefile~
deleted file mode 100644
index 0cf5d6d..0000000
--- a/drivers/misc/mediatek/lcm/hct_otm1282a_dsi_vdo_hd_auo/Makefile~
+++ /dev/null
@@ -1,13 +0,0 @@
-#
-# Makefile for misc devices that really don't fit anywhere else.
-#
-ifdef MTK_LEGCY
-include $(srctree)/drivers/misc/mediatek/Makefile.custom
-endif
-
-CFLAGS += -Wno-unused-variable -g
-CFLAGS += -Wno-unused-function -g
-
-obj-y += hct_otm1282a_dsi_vdo_hd_auo.o
-
-
diff --git a/drivers/misc/mediatek/lcm/hct_otm1282a_dsi_vdo_hd_auo/hct_otm1282a_dsi_vdo_hd_auo.c~ b/drivers/misc/mediatek/lcm/hct_otm1282a_dsi_vdo_hd_auo/hct_otm1282a_dsi_vdo_hd_auo.c~
deleted file mode 100644
index 0ba31d5..0000000
--- a/drivers/misc/mediatek/lcm/hct_otm1282a_dsi_vdo_hd_auo/hct_otm1282a_dsi_vdo_hd_auo.c~
+++ /dev/null
@@ -1,902 +0,0 @@
-/* Copyright Statement:
- *
- * This software/firmware and related documentation ("MediaTek Software") are
- * protected under relevant copyright laws. The information contained herein
- * is confidential and proprietary to MediaTek Inc. and/or its licensors.
- * Without the prior written permission of MediaTek inc. and/or its licensors,
- * any reproduction, modification, use or disclosure of MediaTek Software,
- * and information contained herein, in whole or in part, shall be strictly prohibited.
- */
-/* MediaTek Inc. (C) 2010. All rights reserved.
- *
- * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
- * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
- * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
- * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
- * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
- * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
- * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
- * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
- * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
- * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
- * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
- * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
- * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
- * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
- * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
- * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
- *
- * The following software/firmware and/or related documentation ("MediaTek Software")
- * have been modified by MediaTek Inc. All revisions are subject to any receiver's
- * applicable license agreements with MediaTek Inc.
- */
-
-/*****************************************************************************
-*  Copyright Statement:
-*  --------------------
-*  This software is protected by Copyright and the information contained
-*  herein is confidential. The software may not be copied and the information
-*  contained herein may not be used or disclosed except with the written
-*  permission of MediaTek Inc. (C) 2008
-*
-*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
-*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
-*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
-*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
-*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
-*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
-*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
-*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
-*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
-*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
-*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
-*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
-*
-*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
-*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
-*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
-*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
-*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
-*
-*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
-*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
-*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
-*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
-*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
-*
-*****************************************************************************/
-#include "lcm_drv.h"
-
-#ifdef MTK_LEGACY
-
-#if defined(BUILD_LK)
-#include <platform/mt_gpio.h>
-#include <platform/mt_pmic.h>
-#else
-#include <mach/mt_gpio.h>
-#include <mach/mt_pm_ldo.h>
-#endif
-
-#if !defined(BUILD_LK)
-#include <linux/string.h>
-#endif
-
-
-#else /* MTK_LEGCAY*/
-
-#ifndef BUILD_LK
-#include <linux/string.h>
-#endif
-
-#ifdef BUILD_LK
-	#include <platform/mt_gpio.h>
-	#include <string.h>
-#elif defined(BUILD_UBOOT)
-	#include <asm/arch/mt_gpio.h>
-#else
-//	#include <mach/mt_gpio.h>
-#endif
-
-#endif /* MTK_LEGACY */
-
-
-#if defined(BUILD_LK)
-        #define LCM_DEBUG  printf
-        #define LCM_FUNC_TRACE() printf("huyl [uboot] %s\n",__func__)
-#else
-        #define LCM_DEBUG  printk
-        #define LCM_FUNC_TRACE() printk("huyl [kernel] %s\n",__func__)
-#endif
-// ---------------------------------------------------------------------------
-//  Local Constants
-// ---------------------------------------------------------------------------
-
-#define FRAME_WIDTH  (720)
-#define FRAME_HEIGHT (1280)
-
-#define LCM_ID_OTM1282 (0x1282)
-
-#ifndef TRUE
-    #define TRUE 1
-#endif
-
-#ifndef FALSE
-    #define FALSE 0
-#endif
-
-static unsigned int lcm_esd_test = FALSE;      ///only for ESD test
-
-// ---------------------------------------------------------------------------
-//  Local Variables
-// ---------------------------------------------------------------------------
-
-static LCM_UTIL_FUNCS lcm_util = {0};
-
-#define SET_RESET_PIN(v)    (lcm_util.set_reset_pin((v)))
-
-#define UDELAY(n) (lcm_util.udelay(n))
-#define MDELAY(n) (lcm_util.mdelay(n))
-
-#define REGFLAG_DELAY                                                                   0XFE
-#define REGFLAG_END_OF_TABLE                                                            0x100   // END OF REGISTERS MARKER
-
-// ---------------------------------------------------------------------------
-//  Local Functions
-// ---------------------------------------------------------------------------
-
-#define dsi_set_cmdq_V2(cmd, count, ppara, force_update)                lcm_util.dsi_set_cmdq_V2(cmd, count, ppara, force_update)
-#define dsi_set_cmdq(pdata, queue_size, force_update)           lcm_util.dsi_set_cmdq(pdata, queue_size, force_update)
-#define wrtie_cmd(cmd)                                                                          lcm_util.dsi_write_cmd(cmd)
-#define write_regs(addr, pdata, byte_nums)                                      lcm_util.dsi_write_regs(addr, pdata, byte_nums)
-#define read_reg(cmd)                                                                                   lcm_util.dsi_dcs_read_lcm_reg(cmd)
-#define read_reg_v2(cmd, buffer, buffer_size)                                   lcm_util.dsi_dcs_read_lcm_reg_v2(cmd, buffer, buffer_size)   
-
-#define   LCM_DSI_CMD_MODE                                                      0
-
-struct LCM_setting_table {
-    unsigned cmd;
-    unsigned char count;
-    unsigned char para_list[64];
-};
-
-static struct LCM_setting_table lcm_initialization_setting[] = {
-
-{0x00,1,{0x00}},
-{0xff,3,{0x12,0x82,0x01}},
-
-{0x00,1,{0x80}},
-{0xff,2,{0x12,0x82}},
-
-{0x00,1,{0x92}},
-{0xff,2,{0x30,0x02}},//fae
-
-
-{0x00,1,{0xb4}},
-{0xc0,1,{0x40}},
-
-{0x00,1,{0x91}},
-{0xb3,2,{0x0c,0x10}},
-
-{0x00,1,{0xb3}},
-{0xc0,1,{0x33}},
-
-{0x00,1,{0x00}},
-{0x1c,1,{0x32}},//32
-
-{0x00,1,{0x84}},
-{0xa4,1,{0x00}},
-{0x00,1,{0x80}},
-{0xc0,14,{0x00,0x85,0x00,0x2c,0x2c,0x00,0x7b,0x2c,0x2c,0x00,0x7b,0x00,0x2c,0x2c}},
-
-{0x00,1,{0xa0}},
-{0xc0,7,{0x00,0x00,0x00,0x07,0x00,0x19,0x09}},
-
-{0x00,1,{0xd0}},
-{0xc0,7,{0x00,0x00,0x00,0x07,0x00,0x19,0x09}},
-
-{0x00,1,{0x80}},
-{0xc1,2,{0x55,0x55}},
-
-{0x00,1,{0x90}},
-{0xc1,3,{0x66,0x00,0x00}},
-
-{0x00,1,{0x80}},
-{0xc2,4,{0x83,0x01,0x45,0x45}},
-
-{0x00,1,{0x90}},
-{0xc2,15,{0xa9,0x2c,0x01,0x00,0x00,0xab,0x2c,0x01,0x00,0x00,0xaa,0x2c,0x01,0x00,0x00}},
-
-{0x00,1,{0xa0}},
-{0xc2,5,{0xa8,0x2c,0x01,0x00,0x00}},
-
-{0x00,1,{0xec}},
-{0xc2,1,{0x00}},
-
-{0x00,1,{0xfa}},
-{0xc2,3,{0x00,0x80,0x01}},
-
-{0x00,1,{0x80}},
-{0xc3,4,{0x83,0x01,0x45,0x45}},
-
-{0x00,1,{0x90}},
-{0xc3,15,{0xa9,0x2c,0x01,0x00,0x00,0xab,0x2c,0x01,0x00,0x00,0xaa,0x2c,0x01,0x00,0x00}},
-
-{0x00,1,{0xa0}},
-{0xc3,5,{0xa8,0x2c,0x01,0x00,0x00}},
-
-{0x00,1,{0xec}},
-{0xc3,1,{0x00}},
-
-{0x00,1,{0x90}},
-{0xcb,15,{0xc0,0x00,0xc0,0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x00,0x00}},
-
-{0x00,1,{0xa0}},
-{0xcb,15,{0x00,0x00,0x00,0x00,0x00,0xc0,0x00,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
-
-{0x00,1,{0xb0}},
-{0xcb,15,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x50,0xc0,0x00,0x00,0x00,0x00}},
-
-{0x00,1,{0xc0}},
-{0xcb,15,{0xff,0x28,0xeb,0x28,0xeb,0x14,0x14,0x14,0x14,0x00,0x14,0x14,0xd7,0x28,0x28}},
-
-{0x00,1,{0xd0}},
-{0xcb,15,{0x28,0x28,0x14,0x14,0x14,0xd7,0x04,0xf7,0x04,0x14,0x14,0x14,0x14,0x04,0x04}},
-
-{0x00,1,{0xe0}},
-{0xcb,15,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x15,0x15,0x07,0x14,0x14,0x00,0x00}},
-
-{0x00,1,{0xf0}},
-{0xcb,12,{0x30,0x03,0xfc,0x03,0xf0,0x30,0x00,0x00,0x00,0x00,0x00,0x00}},
-
-{0x00,1,{0x80}},
-{0xcc,10,{0x0f,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x10}},
-
-{0x00,1,{0xb0}},
-{0xcc,10,{0x0f,0x06,0x05,0x04,0x03,0x07,0x08,0x09,0x0a,0x10}},
-
-{0x00,1,{0x8a}},
-{0xcd,1,{0x0b}},
-
-{0x00,1,{0xa0}},
-{0xcd,15,{0x12,0x14,0x15,0x04,0x05,0x01,0x0a,0x2d,0x2d,0x2d,0x2d,0x2d,0x26,0x25,0x24}},
-
-{0x00,1,{0xb0}},
-{0xcd,15,{0x23,0x22,0x21,0x20,0x1f,0x2d,0x2d,0x2d,0x2d,0x13,0x0b,0x0c,0x2d,0x2d,0x2d}},
-
-{0x00,1,{0xc0}},
-{0xcd,10,{0x2d,0x2d,0x2d,0x27,0x28,0x29,0x2a,0x2b,0x1d,0x2d}},
-
-{0x00,1,{0xd0}},
-{0xcd,15,{0x12,0x14,0x15,0x02,0x03,0x01,0x0a,0x2d,0x2d,0x2d,0x2d,0x2d,0x26,0x25,0x24}},
-
-{0x00,1,{0xe0}},
-{0xcd,15,{0x23,0x22,0x21,0x20,0x1f,0x2d,0x2d,0x2d,0x2d,0x13,0x0b,0x0c,0x2d,0x2d,0x2d}},
-
-{0x00,1,{0xf0}},
-{0xcd,10,{0x2d,0x2d,0x2d,0x27,0x28,0x29,0x2a,0x2b,0x1d,0x2d}},
-
-{0x00,1,{0x00}},
-{0xd9,1,{0x6e}},
-
-{0x00,1,{0x00}},
-{0xd8,2,{0x33,0x33}},
-
-{0x00,1,{0x90}},
-{0xc5,4,{0x92,0xd6,0xad,0xb0}},
-
-{0x00,1,{0xa0}},
-{0xc5,4,{0x92,0xd6,0xad,0xb0}},
-
-#if 1
-{0x00,1,{0x00}},
-{0xe1,24,{0x1b,0x21,0x31,0x3f,0x49,0x52,0x5e,0x71,0x7d,0x8f,0x99,0xa0,0x5b,0x57,0x54,0x48,0x39,0x2a,0x20,0x1a,0x15,0x10,0x0c,0x0a}},
-{0x00,1,{0x00}},
-{0xe2,24,{0x1b,0x21,0x31,0x3f,0x49,0x52,0x5e,0x71,0x7d,0x8f,0x9a,0xa1,0x5b,0x57,0x54,0x48,0x39,0x2a,0x20,0x1a,0x15,0x10,0x0c,0x0a}},
-{0x00,1,{0x00}},
-{0xe3,24,{0x1b,0x21,0x31,0x3f,0x49,0x52,0x5e,0x71,0x7d,0x8f,0x99,0xa0,0x5b,0x57,0x54,0x48,0x39,0x2a,0x20,0x1a,0x15,0x10,0x0c,0x0a}},
-{0x00,1,{0x00}},
-{0xe4,24,{0x1b,0x21,0x31,0x3f,0x49,0x52,0x5e,0x71,0x7d,0x8f,0x9a,0xa1,0x5b,0x57,0x54,0x48,0x39,0x2a,0x20,0x1a,0x15,0x10,0x0c,0x0a}},
-{0x00,1,{0x00}},
-{0xe5,24,{0x1b,0x21,0x31,0x3f,0x49,0x52,0x5e,0x71,0x7d,0x8f,0x99,0xa0,0x5b,0x57,0x54,0x48,0x39,0x2a,0x20,0x1a,0x15,0x10,0x0c,0x0a}},
-{0x00,1,{0x00}},
-{0xe6,24,{0x1b,0x21,0x31,0x3f,0x49,0x52,0x5e,0x71,0x7d,0x8f,0x9a,0xa1,0x5b,0x57,0x54,0x48,0x39,0x2a,0x20,0x1a,0x15,0x10,0x0c,0x0a}},
-
-#else
-{0x00,1,{0x00}},
-{0xe1,24,{0x1b,0x21,0x2f,0x3c,0x46,0x4e,0x5b,0x6d,0x79,0x89,0x94,0x9b,0x60,0x5d,0x5a,0x50,0x42,0x34,0x2a,0x24,0x1f,0x19,0x18,0x17}},
-{0x00,1,{0x00}},
-{0xe2,24,{0x1b,0x21,0x2f,0x3c,0x46,0x4e,0x5b,0x6d,0x79,0x89,0x94,0x9b,0x60,0x5d,0x5a,0x50,0x42,0x34,0x2a,0x24,0x1f,0x19,0x18,0x17}},
-{0x00,1,{0x00}},
-{0xe3,24,{0x1b,0x21,0x2f,0x3c,0x46,0x4e,0x5b,0x6d,0x79,0x89,0x94,0x9b,0x60,0x5d,0x5a,0x50,0x42,0x34,0x2a,0x24,0x1f,0x19,0x18,0x17}},
-{0x00,1,{0x00}},
-{0xe4,24,{0x1b,0x21,0x2f,0x3c,0x46,0x4e,0x5b,0x6d,0x79,0x89,0x94,0x9b,0x60,0x5d,0x5a,0x50,0x42,0x34,0x2a,0x24,0x1f,0x19,0x18,0x17}},
-{0x00,1,{0x00}},
-{0xe5,24,{0x1b,0x21,0x2f,0x3c,0x46,0x4e,0x5b,0x6d,0x79,0x89,0x94,0x9b,0x60,0x5d,0x5a,0x50,0x42,0x34,0x2a,0x24,0x1f,0x19,0x18,0x17}},
-{0x00,1,{0x00}},
-{0xe6,24,{0x1b,0x21,0x2f,0x3c,0x46,0x4e,0x5b,0x6d,0x79,0x89,0x94,0x9b,0x60,0x5d,0x5a,0x50,0x42,0x34,0x2a,0x24,0x1f,0x19,0x18,0x17}},
-#endif
-
-{0x00,1,{0x93}},
-{0xf5,1,{0x10}},
-
-{0x00,1,{0x97}},
-{0xc5,2,{0x33,0x30}},
-
-{0x00,1,{0xa7}},
-{0xc5,2,{0x33,0x30}},
-
-{0x00,1,{0x80}},
-{0xa5,1,{0x0c}},
-
-{0x00,1,{0xb3}},
-{0xc0,1,{0x33}},
-
-{0x00,1,{0x80}},
-{0xc4,2,{0x04,0x0f}},
-
-{0x00,1,{0xa0}},
-{0xc1,2,{0xE8,0xe0}},
-
-{0x00,1,{0x00}},
-{0xff,3,{0xff,0xff,0xff}},
-
-/*
-{0x00,1,{0x00}},
-{0xff,3,{0x12,0x82,0x01}},
-	
-{0x00, 1 , {0x80}},
-{0xFF, 2 ,{0x12,0x82}},
-
-{0x00,1,{0x92}},
-{0xff,2,{0x30,0x02}},
-
-{0x00, 1 , {0x80}},
-{0xC0, 14 ,{0x00,0x85,0x00,0x2C,0x2C,0x00,0x7B,0x2C,0x2C,0x00,0x7B,0x00,0x2C,0x2C}},
-
-{0x00, 1 , {0xA0}},
-{0xC0,  7 ,{0x00,0x00,0x00,0x07,0x00,0x19,0x09}},
-
-{0x00, 1 , {0xD0}},
-{0xC0,  7 ,{0x00,0x00,0x07,0x0C,0x00,0x19,0x09}},
-
-{0x00, 1 , {0x80}},
-{0xC1,  2 ,{0x55,0x55}},
-
-{0x00, 1 , {0x90}},
-{0xC1,  3 ,{0x66,0x00,0x00}},
-
-{0x00, 1 , {0x80}},
-{0xC2,  4 ,{0x82,0x00,0x45,0x45}},
-
-{0x00, 1 , {0x90}},
-{0xC2, 15 ,{0xAB,0x2D,0x00,0x02,0x00,0xAA,0x2C,0x00,0x02,0x00,0xAB,0x2C,0x01,0x00,0x00}},
-
-{0x00, 1 , {0xA0}},
-{0xC2,  5 ,{0xA9,0x2C,0x01,0x00,0x00}},
-
-{0x00, 1 , {0xEC}},
-{0xC2,  1 ,{0x00}},
-
-{0x02,  1 ,{0xFA}},
-{0xC2,  3 ,{0x00,0x80,0x01}},
-
-{0x00, 1 , {0x80}},
-{0xC3,  4 ,{0x82,0x00,0x45,0x45}},
-
-{0x00, 1 , {0x90}},
-{0xC3, 15 ,{0xAB,0x2D,0x00,0x02,0x00,0xAA,0x2C,0x00,0x02,0x00,0xAB,0x2C,0x01,0x00,0x00}},
-
-{0x00, 1 , {0xA0}},
-{0xC3,  5 ,{0xA9,0x2C,0x01,0x00,0x00}},
-
-{0x00, 1 , {0xEC}},
-{0xC3,  1 ,{0x00}},
-
-{0x00, 1 , {0x90}},
-{0xCB, 15 ,{0xC0,0x00,0xC0,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x00,0x00}},
-
-{0x00, 1 , {0xA0}},
-{0xCB, 15 ,{0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
-
-{0x00, 1 , {0xB0}},
-{0xCB, 15 ,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x50,0xC0,0x00,0x00,0x00,0x00}},
-
-{0x00, 1 , {0xC0}},
-{0xCB, 15 ,{0xFF,0x28,0xEB,0x28,0xEB,0x14,0x14,0x14,0x14,0x00,0x14,0x14,0xD7,0x28,0x28}},
-
-{0x00, 1 , {0xD0}},
-{0xCB, 15 ,{0x28,0x28,0x14,0x14,0x04,0xF7,0x04,0xF7,0x04,0x14,0x14,0x14,0x14,0x04,0x04}},
-
-{0x00, 1 , {0xE0}},
-{0xCB, 15 ,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x15,0x15,0x07,0x14,0x14,0x00,0x00}},
-
-{0x00, 1 , {0x80}},
-{0xF5,  1 ,{0x01}},
-
-{0x00, 1 , {0x81}},
-{0xF5,  1 ,{0x18}},
-
-{0x00, 1 , {0x91}},
-{0xB0,  1 ,{0x9E}},
-
-{0x00, 1 , {0x90}},
-{0xA5,  1 ,{0x00}},
-
-{0x00, 1 , {0xD2}},
-{0xF5,  1 ,{0x20}},
-
-{0x00, 1 , {0x81}},
-{0xF5,  1 ,{0x18}},
-
-{0x00, 1 , {0x83}},
-{0xF5,  1 ,{0x18}},
-
-{0x00, 1 , {0x87}},
-{0xF5,  1 ,{0x18}},
-
-{0x00, 1 , {0x89}},
-{0xF5,  1 ,{0x18}},
-
-{0x00, 1 , {0x91}},
-{0xF5,  1 ,{0x18}},
-
-{0x00, 1 , {0x93}},
-{0xF5,  1 ,{0x18}},
-
-{0x00, 1 , {0x95}},
-{0xF5,  1 ,{0x18}},
-
-{0x00, 1 , {0x97}},
-{0xF5,  1 ,{0x18}},
-
-{0x00, 1 , {0x99}},
-{0xF5,  1 ,{0x18}},
-
-{0x00, 1 , {0xA7}},
-{0xF5,  1 ,{0x18}},
-
-{0x00, 1 , {0xC1}},
-{0xF5,  1 ,{0x18}},
-
-{0x00, 1 , {0xC3}},
-{0xF5,  1 ,{0x18}},
-
-{0x00, 1 , {0xC5}},
-{0xF5,  1 ,{0x18}},
-
-{0x00, 1 , {0xC7}},
-{0xF5,  1 ,{0x18}},
-
-{0x00, 1 , {0xC9}},
-{0xF5,  1 ,{0x14}},
-
-{0x00, 1 , {0xF0}},
-{0xCB, 12 ,{0x30,0x03,0xFC,0x03,0xF0,0x30,0x00,0x00,0x00,0x00,0x00,0x00}},
-
-{0x00, 1 , {0x80}},
-{0xCC, 10 ,{0x0F,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x10}},
-
-{0x00, 1 , {0xB0}},
-{0xCC, 10 ,{0x0F,0x04,0x03,0x06,0x05,0x07,0x08,0x09,0x0A,0x10}},
-
-{0x00, 1 , {0x8A}},
-{0xCD,  1 ,{0x0B}},
-
-{0x00, 1 , {0xA0}},
-{0xCD, 15 ,{0x12,0x14,0x15,0x02,0x03,0x01,0x0A,0x2D,0x2D,0x2D,0x2D,0x2D,0x26,0x25,0x24}},
-
-{0x00, 1 , {0xB0}},
-{0xCD, 15 ,{0x23,0x22,0x21,0x20,0x1F,0x2D,0x2D,0x2D,0x2D,0x13,0x0B,0x0C,0x2D,0x2D,0x2D}},
-
-{0x00, 1 , {0xC0}},
-{0xCD, 10 ,{0x2D,0x2D,0x2D,0x27,0x28,0x29,0x2A,0x2B,0x1D,0x2D}},
-
-{0x00, 1 , {0xD0}},
-{0xCD, 15 ,{0x12,0x14,0x15,0x02,0x03,0x01,0x0A,0x2D,0x2D,0x2D,0x2D,0x2D,0x26,0x25,0x24}},
-
-{0x00, 1 , {0xE0}},
-{0xCD, 15 ,{0x23,0x22,0x21,0x20,0x1F,0x2D,0x2D,0x2D,0x2D,0x13,0x0B,0x0C,0x2D,0x2D,0x2D}},
-
-{0x00, 1 , {0xF0}},
-{0xCD, 10 ,{0x2D,0x2D,0x2D,0x27,0x28,0x29,0x2A,0x2B,0x1D,0x2D}},
-
-{0x00, 1 , {0x90}},
-{0xB4,  1 ,{0x11}},
-
-{0x00, 1 , {0x81}},
-{0xC4,  1 ,{0x04}},
-
-{0x00, 1 , {0xC0}},
-{0xF5,  4 ,{0x00,0x00,0x00,0x00}},
-
-{0x00, 1 , {0x80}},
-{0xA4,  1 ,{0x08}},
-
-{0x00, 1 , {0x00}},
-{0xD9,  1 ,{0x74}},
-
-{0x00, 1 , {0x90}},
-{0xC5,  4 ,{0x92,0xD6,0xB6,0xB4}},
-
-{0x00, 1 , {0xA0}},
-{0xC5,  4 ,{0x92,0xD6,0xB6,0xB4}},
-
-{0x00, 1 , {0x00}},
-{0xD9,  1 ,{0x74}},
-
-{0x00, 1 , {0x00}},
-{0xD8,  2 ,{0x72,0x72}},
-
-{0x00, 1 , {0x90}},
-{0xC5,  4 ,{0x92,0xD6,0xB6,0xB4}},
-
-{0x00, 1 , {0xA0}},
-{0xC5,  4 ,{0x92,0xD6,0xB6,0xB4}},
-
-{0x00, 1 , {0x00}},
-{0xE1, 24 ,{0x29,0x3B,0x45,0x4E,0x57,0x5D,0x68,0x78,0x7F,0x8F,0x97,0x9C,0x5D,0x5C,0x5A,0x51,0x45,0x2B,0x27,0x25,0x1A,0x18,0x17,0x15}},
-
-{0x00, 1 , {0x00}},
-{0xE2, 24 ,{0x30,0x3A,0x46,0x50,0x57,0x5F,0x6A,0x78,0x82,0x8F,0x97,0x9D,0x5F,0x5C,0x5A,0x52,0x45,0x2C,0x28,0x26,0x19,0x16,0x15,0x12}},
-
-{0x00, 1 , {0xCA}},
-{0xCB,  2 ,{0xD4,0xD4}},
-
-{0x00, 1 , {0xD3}},
-{0xCB,  1 ,{0xD4}},
-
-{0x00, 1 , {0x90}},
-{0xB4,  1 ,{0x11}},
-
-{0x00,1,{0x00}},
-{0xff,3,{0xff,0xff,0xff}},
-*/
-
-{0x00,	1,	{0xb8}}, 
-{0xb0, 1,	{0x05}},
-
-
-{0x35,1,{0x00}},
-
-{0x11,1,{0x00}},//SLEEP OUT
-{REGFLAG_DELAY,120,{}},
-                                                                                                                        
-{0x29,1,{0x00}},//Display ON 
-{REGFLAG_DELAY,20,{}},  
-{REGFLAG_END_OF_TABLE, 0x00, {}}
-};
-static struct LCM_setting_table lcm_sleep_out_setting[] = {
-    // Sleep Out
-        {0x11, 0, {0x00}},
-    {REGFLAG_DELAY, 120, {}},
-
-    // Display ON
-        {0x29, 0, {0x00}},
-        {REGFLAG_DELAY, 10, {}},
-        
-        {REGFLAG_END_OF_TABLE, 0x00, {}}
-};
-
-
-static struct LCM_setting_table lcm_sleep_mode_in_setting[] = {
-        // Display off sequence
-        {0x28, 0, {0x00}},
-        {REGFLAG_DELAY, 100, {}},
-
-    // Sleep Mode On
-        {0x10, 0, {0x00}},
-        {REGFLAG_DELAY, 200, {}},
-        {REGFLAG_END_OF_TABLE, 0x00, {}}
-};
-static struct LCM_setting_table lcm_compare_id_setting[] = {
-        // Display off sequence
-        {0xF0,  5,      {0x55, 0xaa, 0x52,0x08,0x00}},
-        {REGFLAG_DELAY, 10, {}},
-
-        {REGFLAG_END_OF_TABLE, 0x00, {}}
-};
-
-
-static void push_table(struct LCM_setting_table *table, unsigned int count, unsigned char force_update)
-{
-        unsigned int i;
-
-    for(i = 0; i < count; i++) {
-                
-        unsigned cmd;
-        cmd = table[i].cmd;
-                
-        switch (cmd) {
-                        
-            case REGFLAG_DELAY :
-                MDELAY(table[i].count);
-                break;
-                                
-            case REGFLAG_END_OF_TABLE :
-                break;
-                                
-            default:
-                                dsi_set_cmdq_V2(cmd, table[i].count, table[i].para_list, force_update);
-                                MDELAY(2);
-        }
-    }
-        
-}
-
-
-
-
-// ---------------------------------------------------------------------------
-//  LCM Driver Implementations
-// ---------------------------------------------------------------------------
-
-static void lcm_set_util_funcs(const LCM_UTIL_FUNCS *util)
-{
-    memcpy(&lcm_util, util, sizeof(LCM_UTIL_FUNCS));
-}
-
-
-static void lcm_get_params(LCM_PARAMS *params)
-{
-
-            memset(params, 0, sizeof(LCM_PARAMS));
-        
-                params->type   = LCM_TYPE_DSI;
-
-                params->width  = FRAME_WIDTH;
-                params->height = FRAME_HEIGHT;
-
-                // enable tearing-free
-                params->dbi.te_mode                             = LCM_DBI_TE_MODE_DISABLED;
-                //params->dbi.te_edge_polarity          = LCM_POLARITY_RISING;
-
-
-                params->dsi.mode   = SYNC_EVENT_VDO_MODE; //SYNC_PULSE_VDO_MODE;//BURST_VDO_MODE; 
-
-        
-                // DSI
-                /* Command mode setting */
-                 // 1 Three lane or Four lane
-                params->dsi.LANE_NUM                            = LCM_FOUR_LANE;
-                //The following defined the fomat for data coming from LCD engine.
-                params->dsi.data_format.color_order = LCM_COLOR_ORDER_RGB;
-                params->dsi.data_format.trans_seq   = LCM_DSI_TRANS_SEQ_MSB_FIRST;
-                params->dsi.data_format.padding     = LCM_DSI_PADDING_ON_LSB;
-                params->dsi.data_format.format      = LCM_DSI_FORMAT_RGB888;
-
-                // Highly depends on LCD driver capability.
-                // Not support in MT6573
-                params->dsi.packet_size=256;
-
-                // Video mode setting           
-                params->dsi.intermediat_buffer_num = 2;//because DSI/DPI HW design change, this parameters should be 0 when video mode in MT658X; or memory leakage
-
-                params->dsi.PS=LCM_PACKED_PS_24BIT_RGB888;
-          //      params->dsi.word_count=720*3;   
-
-                
-                params->dsi.vertical_sync_active                                = 4;//0x3;// 3    2
-                params->dsi.vertical_backporch                                  = 20;//0x10;// 20   1
-                params->dsi.vertical_frontporch                                 = 16;//0x10; // 1  12
-                params->dsi.vertical_active_line                                = FRAME_HEIGHT; 
-
-                params->dsi.horizontal_sync_active                              = 8;//0x0B;// 50  2
-                params->dsi.horizontal_backporch                                = 65;//0x40 ;
-                params->dsi.horizontal_frontporch                               = 75;//0x40 ;
-                params->dsi.horizontal_active_pixel                             = FRAME_WIDTH;
-
-    		params->dsi.cont_clock=0; //1;
-	
-		params->dsi.esd_check_enable = 1;
-		params->dsi.customization_esd_check_enable = 1;
-		params->dsi.lcm_esd_check_table[0].cmd = 0x0a;
-		params->dsi.lcm_esd_check_table[0].count = 1;
-		params->dsi.lcm_esd_check_table[0].para_list[0] = 0x9c;
-#if 0
-params->dsi.HS_PRPR=3;
-params->dsi.CLK_HS_POST=22;
-params->dsi.DA_HS_EXIT=20;
-#endif
-
-
-            //params->dsi.LPX=8; 
-
-                // Bit rate calculation
-                // 1 Every lane speed
-#if 0
-                params->dsi.pll_div1=0;         // div1=0,1,2,3;div1_real=1,2,4,4 ----0: 546Mbps  1:273Mbps
-                params->dsi.pll_div2=1;         // div2=0,1,2,3;div1_real=1,2,4,4       
-        params->dsi.fbk_sel=1;           // fbk_sel=0,1,2,3;fbk_sel_real=1,2,4,4
-                params->dsi.fbk_div =20;    // fref=26MHz, fvco=fref*(fbk_div+1)*2/(div1_real*div2_real)        
-#else
-        params->dsi.PLL_CLOCK=240;//227;//254;//254//247
-#endif
-}
-
-static void lcm_init(void)
-{
-        SET_RESET_PIN(1);
-        MDELAY(50); 
-        SET_RESET_PIN(0);
-        MDELAY(50); 
-        
-        SET_RESET_PIN(1);
-        MDELAY(120);      
-
-        push_table(lcm_initialization_setting, sizeof(lcm_initialization_setting) / sizeof(struct LCM_setting_table), 1);
-}
-
-
-
-static void lcm_suspend(void)
-{
-#ifndef BUILD_LK
-#if 0
-        SET_RESET_PIN(1);
-          MDELAY(20);
-          SET_RESET_PIN(0);
-          MDELAY(20);
-
-          SET_RESET_PIN(1);
-          MDELAY(120);
-
-          push_table(lcm_initialization_setting, sizeof(lcm_initialization_setting) / sizeof(struct LCM_setting_table), 1);
-#else
-        push_table(lcm_sleep_mode_in_setting, sizeof(lcm_sleep_mode_in_setting) / sizeof(struct LCM_setting_table), 1);
-#endif
-#endif
-
-}
-
-
-static void lcm_resume(void)
-{
-#ifndef BUILD_LK
-
-        //lcm_init();
-        push_table(lcm_sleep_out_setting, sizeof(lcm_sleep_out_setting) / sizeof(struct LCM_setting_table), 1);
-#endif
-}
-         
-#if (LCM_DSI_CMD_MODE)
-static void lcm_update(unsigned int x, unsigned int y,
-                       unsigned int width, unsigned int height)
-{
-        unsigned int x0 = x;
-        unsigned int y0 = y;
-        unsigned int x1 = x0 + width - 1;
-        unsigned int y1 = y0 + height - 1;
-
-        unsigned char x0_MSB = ((x0>>8)&0xFF);
-        unsigned char x0_LSB = (x0&0xFF);
-        unsigned char x1_MSB = ((x1>>8)&0xFF);
-        unsigned char x1_LSB = (x1&0xFF);
-        unsigned char y0_MSB = ((y0>>8)&0xFF);
-        unsigned char y0_LSB = (y0&0xFF);
-        unsigned char y1_MSB = ((y1>>8)&0xFF);
-        unsigned char y1_LSB = (y1&0xFF);
-
-        unsigned int data_array[16];
-
-        data_array[0]= 0x00053902;
-        data_array[1]= (x1_MSB<<24)|(x0_LSB<<16)|(x0_MSB<<8)|0x2a;
-        data_array[2]= (x1_LSB);
-        dsi_set_cmdq(data_array, 3, 1);
-        
-        data_array[0]= 0x00053902;
-        data_array[1]= (y1_MSB<<24)|(y0_LSB<<16)|(y0_MSB<<8)|0x2b;
-        data_array[2]= (y1_LSB);
-        dsi_set_cmdq(data_array, 3, 1);
-
-        data_array[0]= 0x00290508; //HW bug, so need send one HS packet
-        dsi_set_cmdq(data_array, 1, 1);
-        
-        data_array[0]= 0x002c3909;
-        dsi_set_cmdq(data_array, 1, 0);
-
-}
-#endif
-
-static unsigned int lcm_compare_id(void)
-{
-        unsigned int id0,id1,id=0;
-        unsigned char buffer[5];
-        unsigned int array[16];  
-
-//return 1;
-        SET_RESET_PIN(1);
-        SET_RESET_PIN(0);
-        MDELAY(1);
-        
-        SET_RESET_PIN(1);
-        MDELAY(20); 
-
-        array[0] = 0x00053700;// read id return two byte,version and id
-        dsi_set_cmdq(array, 1, 1);
-        
-        read_reg_v2(0xA1, buffer, 5);   //018B1283ff
-        id0 = buffer[2];
-        id1 = buffer[3];
-        id=(id0<<8)|id1;
-        
-    #ifdef BUILD_LK
-                printf("%s, LK otm1282a debug: otm1282a id = 0x%08x\n", __func__, id);
-    #else
-                printk("%s, kernel otm1282a horse debug: otm1282a id = 0x%08x\n", __func__, id);
-    #endif
-
-    if(id == LCM_ID_OTM1282)
-        return 1;
-    else
-        return 0;
-
-
-}
-
-//extern void hct_set_hs_read();
-//extern void hct_restore_HS_read();
-
-
-static unsigned int lcm_esd_check(void)
-{
-  #ifndef BUILD_LK
-        char  buffer[3];
-        int   array[4];
-
-        if(lcm_esd_test)
-        {
-                lcm_esd_test = FALSE;
-                return TRUE;
-        }
-
-
-	//hct_set_hs_read();
-	array[0] = 0x00013708;
-	dsi_set_cmdq(array, 1, 1);
-	 read_reg_v2(0x0a, buffer, 1);
-	// printk("otm1282 lcm_esd_check %x %x\n",buffer[0]);
-	//hct_restore_HS_read();
-
-
-      //  array[0] = 0x00013700;
-        //dsi_set_cmdq(array, 1, 1);
-
-     //   read_reg_v2(0x36, buffer, 1);
-        if(buffer[0]==0x9c)
-        {
-                return FALSE;
-        }
-        else
-        {                        
-                return TRUE;
-        }
- #endif
-
-}
-
-static unsigned int lcm_esd_recover(void)
-{
-        lcm_init();
-        lcm_resume();
-
-        return TRUE;
-}
-
-LCM_DRIVER hct_otm1282a_dsi_vdo_hd_auo = 
-{
-    .name                       = "hct_otm1282a_dsi_vdo_hd_auo",
-        .set_util_funcs = lcm_set_util_funcs,
-        .get_params     = lcm_get_params,
-        .init           = lcm_init,
-        .suspend        = lcm_suspend,
-        .resume         = lcm_resume,
-        .compare_id    = lcm_compare_id,        
-#if (LCM_DSI_CMD_MODE)
-        //.set_backlight        = lcm_setbacklight,
-    .update         = lcm_update,
-#endif
- //.esd_check = lcm_esd_check,
- //.esd_recover=lcm_esd_recover,
-};
diff --git a/drivers/misc/mediatek/lcm/hct_rm68200_dsi_vdo_hd_cpt/Makefile~ b/drivers/misc/mediatek/lcm/hct_rm68200_dsi_vdo_hd_cpt/Makefile~
deleted file mode 100644
index 89914fa..0000000
--- a/drivers/misc/mediatek/lcm/hct_rm68200_dsi_vdo_hd_cpt/Makefile~
+++ /dev/null
@@ -1,15 +0,0 @@
-#
-# Makefile for misc devices that really don't fit anywhere else.
-#
-ifdef MTK_LEGCY
-include $(srctree)/drivers/misc/mediatek/Makefile.custom
-endif
-
-ccflags-y += -Wno-unused-variable -g
-ccflags-y += -Wno-unused-function -g
-
-obj-y += hct_rm68200_dsi_vdo_hd_cpt.o
-
-
-
-
diff --git a/drivers/misc/mediatek/lcm/hct_rm68200_dsi_vdo_hd_cpt/hct_rm68200_dsi_vdo_hd_cpt.c~ b/drivers/misc/mediatek/lcm/hct_rm68200_dsi_vdo_hd_cpt/hct_rm68200_dsi_vdo_hd_cpt.c~
deleted file mode 100644
index 533aa10..0000000
--- a/drivers/misc/mediatek/lcm/hct_rm68200_dsi_vdo_hd_cpt/hct_rm68200_dsi_vdo_hd_cpt.c~
+++ /dev/null
@@ -1,1055 +0,0 @@
-/* Copyright Statement:
- *
- * This software/firmware and related documentation ("MediaTek Software") are
- * protected under relevant copyright laws. The information contained herein
- * is confidential and proprietary to MediaTek Inc. and/or its licensors.
- * Without the prior written permission of MediaTek inc. and/or its licensors,
- * any reproduction, modification, use or disclosure of MediaTek Software,
- * and information contained herein, in whole or in part, shall be strictly prohibited.
- */
-/* MediaTek Inc. (C) 2010. All rights reserved.
- *
- * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
- * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
- * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
- * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
- * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
- * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
- * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
- * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
- * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
- * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
- * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
- * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
- * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
- * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
- * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
- * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
- *
- * The following software/firmware and/or related documentation ("MediaTek Software")
- * have been modified by MediaTek Inc. All revisions are subject to any receiver's
- * applicable license agreements with MediaTek Inc.
- */
-
-/*****************************************************************************
-*  Copyright Statement:
-*  --------------------
-*  This software is protected by Copyright and the information contained
-*  herein is confidential. The software may not be copied and the information
-*  contained herein may not be used or disclosed except with the written
-*  permission of MediaTek Inc. (C) 2008
-*
-*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
-*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
-*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
-*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
-*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
-*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
-*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
-*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
-*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
-*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
-*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
-*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
-*
-*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
-*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
-*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
-*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
-*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
-*
-*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
-*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
-*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
-*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
-*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
-*
-*****************************************************************************/
-#ifndef BUILD_LK
-#include <linux/string.h>
-#endif
-
-#include "lcm_drv.h"
-
-#ifdef BUILD_LK
-	#include <platform/mt_gpio.h>
-	#include <string.h>
-#elif defined(BUILD_UBOOT)
-	#include <asm/arch/mt_gpio.h>
-#else
-//	#include <mach/mt_gpio.h>
-#endif
-
-// ---------------------------------------------------------------------------
-//  Local Constants
-// ---------------------------------------------------------------------------
-
-#define FRAME_WIDTH  										(720)
-#define FRAME_HEIGHT 										(1280)
-#define LCM_ID                       						(0x1284)
-
-#define REGFLAG_DELAY             							(0XFFFE)
-#define REGFLAG_END_OF_TABLE      							(0xFFFF)	// END OF REGISTERS MARKER
-
-
-#define LCM_DSI_CMD_MODE									0
-
-#ifndef TRUE
-    #define TRUE 1
-#endif
-
-#ifndef FALSE
-    #define FALSE 0
-#endif
-
-// ---------------------------------------------------------------------------
-//  Local Variables
-// ---------------------------------------------------------------------------
-
-static LCM_UTIL_FUNCS lcm_util = {0};
-
-#define SET_RESET_PIN(v)    								(lcm_util.set_reset_pin((v)))
-
-#define UDELAY(n) 											(lcm_util.udelay(n))
-#define MDELAY(n) 											(lcm_util.mdelay(n))
-
-#define LCM_RM68200_ID 		(0x6820)
-
-static unsigned int lcm_esd_test = FALSE;      ///only for ESD test
-
-// ---------------------------------------------------------------------------
-//  Local Functions
-// ---------------------------------------------------------------------------
-
-#define dsi_set_cmdq_V2(cmd, count, ppara, force_update)	lcm_util.dsi_set_cmdq_V2(cmd, count, ppara, force_update)
-#define dsi_set_cmdq(pdata, queue_size, force_update)		lcm_util.dsi_set_cmdq(pdata, queue_size, force_update)
-#define wrtie_cmd(cmd)										lcm_util.dsi_write_cmd(cmd)
-#define write_regs(addr, pdata, byte_nums)					lcm_util.dsi_write_regs(addr, pdata, byte_nums)
-#define read_reg(cmd)											lcm_util.dsi_dcs_read_lcm_reg(cmd)
-#define read_reg_v2(cmd, buffer, buffer_size)				lcm_util.dsi_dcs_read_lcm_reg_v2(cmd, buffer, buffer_size)
-
- struct LCM_setting_table {
-    unsigned cmd;
-    unsigned char count;
-    unsigned char para_list[64];
-};
-
-
-static struct LCM_setting_table lcm_initialization_setting[] = {
-
-	/*
-Note :
-
-Data ID will depends on the following rule.
-
-count of parameters > 1      => Data ID = 0x39
-count of parameters = 1      => Data ID = 0x15
-count of parameters = 0      => Data ID = 0x05
-
-Struclcm_deep_sleep_mode_in_settingture Format :
-
-{DCS command, count of parameters, {parameter list}}
-{REGFLAG_DELAY, milliseconds of time, {}},
-
-...
-
-Setting ending by predefined flag
-
-{REGFLAG_END_OF_TABLE, 0x00, {}}
-*/
-//RM38200+HSD5.94 YKL CODE
-{0xFE, 1,{0x01}},
-
-{0x24, 1,{0xC0}},
-
-{0x25, 1,{0x73}},
-
-{0x26, 1,{0x00}},
-
-{0x27, 1,{0x0A}},
-
-{0x29, 1,{0x0A}},
-
-{0x2B, 1,{0xE5}},
-
-{0x2F, 1,{0x44}},//44
-
-{0x34, 1,{0x45}},//45  4a
-
-//{0x17, 1,{0x10}},
-
-//{0x18, 1,{0x10}},
-
-//{0x19, 1,{0x10}},
-
-//{0x1A, 1,{0x0D}},
-
-{0x1B, 1,{0x00}},//00
-
-{0x12, 1,{0x08}},
-
-{0x46, 1,{0x5C}},//vcom 58
-
-{0x52, 1,{0xA8}},
-
-{0x53, 1,{0x00}},
-
-{0x54, 1,{0xA8}},
-
-{0x55, 1,{0x00}},
-
-
-{0xFE, 1,{0x03}},
-
-{0x00, 1,{0x05}},
-
-{0x01, 1,{0x14}},
-
-{0x02, 1,{0x01}},
-
-{0x03, 1,{0x00}},
-
-{0x04, 1,{0x00}},
-
-{0x05, 1,{0x00}},
-
-{0x06, 1,{0x00}},
-
-{0x07, 1,{0x00}},
-
-{0x08, 1,{0x00}},
-
-{0x09, 1,{0x00}},
-
-{0x0A, 1,{0x00}},
-
-{0x0B, 1,{0x00}},
-
-{0x0C, 1,{0x00}},
-
-{0x0D, 1,{0x00}},
-
-{0x0E, 1,{0x05}},
-
-{0x0F, 1,{0x06}},
-
-{0x10, 1,{0x07}},
-
-{0x11, 1,{0x08}},
-
-{0x12, 1,{0x00}},
-
-{0x13, 1,{0x40}},
-
-{0x14, 1,{0x00}},
-
-{0x15, 1,{0xC5}},
-
-{0x16, 1,{0x08}},
-
-{0x17, 1,{0x09}},
-
-{0x18, 1,{0x0A}},
-
-{0x19, 1,{0x0B}},
-
-{0x1A, 1,{0x0C}},
-
-{0x1B, 1,{0x00}},
-
-{0x1C, 1,{0x40}},
-
-{0x1D, 1,{0x00}},
-
-{0x1E, 1,{0x85}},
-
-{0x1F, 1,{0x08}},
-
-{0x20, 1,{0x00}},
-
-{0x21, 1,{0x00}},
-
-{0x22, 1,{0x05}},
-
-{0x23, 1,{0x0C}},
-
-{0x24, 1,{0x00}},
-
-{0x25, 1,{0x2D}},
-
-{0x26, 1,{0x00}},
-
-{0x27, 1,{0x10}},
-
-{0x28, 1,{0x00}},
-
-{0x29, 1,{0x2D}},
-
-{0x2A, 1,{0x00}},
-
-{0x2B, 1,{0x00}},
-
-{0x2D, 1,{0x00}},
-
-{0x2F, 1,{0x00}},
-
-{0x30, 1,{0x00}},
-
-{0x31, 1,{0x00}},
-
-{0x32, 1,{0x00}},
-
-{0x33, 1,{0x00}},
-
-{0x34, 1,{0x00}},
-
-{0x35, 1,{0x00}},
-
-{0x36, 1,{0x00}},
-
-{0x37, 1,{0x00}},
-
-{0x38, 1,{0x00}},
-
-{0x39, 1,{0x00}},
-
-{0x3A, 1,{0x00}},
-
-{0x3B, 1,{0x00}},
-
-{0x3D, 1,{0x00}},
-
-{0x3F, 1,{0x00}},
-
-{0x40, 1,{0x00}},
-
-{0x41, 1,{0x00}},
-
-{0x42, 1,{0x00}},
-
-{0x43, 1,{0x00}},
-
-{0x44, 1,{0x00}},
-
-{0x45, 1,{0x00}},
-
-{0x46, 1,{0x00}},
-
-{0x47, 1,{0x00}},
-
-{0x48, 1,{0x00}},
-
-{0x49, 1,{0x00}},
-
-{0x4A, 1,{0x00}},
-
-{0x4B, 1,{0x00}},
-
-{0x4C, 1,{0x00}},
-
-{0x4D, 1,{0x00}},
-
-{0x4E, 1,{0x00}},
-
-{0x4F, 1,{0x00}},
-
-{0x50, 1,{0x00}},
-
-{0x51, 1,{0x00}},
-
-{0x52, 1,{0x00}},
-
-{0x53, 1,{0x00}},
-
-{0x54, 1,{0x00}},
-
-{0x55, 1,{0x00}},
-
-{0x56, 1,{0x00}},
-
-{0x58, 1,{0x00}},
-
-{0x59, 1,{0x00}},
-
-{0x5A, 1,{0x00}},
-
-{0x5B, 1,{0x00}},
-
-{0x5C, 1,{0x00}},
-
-{0x5D, 1,{0x00}},
-
-{0x5E, 1,{0x00}},
-
-{0x5F, 1,{0x00}},
-
-{0x60, 1,{0x00}},
-
-{0x61, 1,{0x00}},
-
-{0x62, 1,{0x00}},
-
-{0x63, 1,{0x00}},
-
-{0x64, 1,{0x00}},
-
-{0x65, 1,{0x00}},
-
-{0x66, 1,{0x00}},
-
-{0x67, 1,{0x00}},
-
-{0x68, 1,{0x00}},
-
-{0x69, 1,{0x00}},
-
-{0x6A, 1,{0x00}},
-
-{0x6B, 1,{0x00}},
-
-{0x6C, 1,{0x00}},
-
-{0x6D, 1,{0xBC}},
-
-{0x6E, 1,{0x20}},
-
-{0x6F, 1,{0x00}},
-
-{0x70, 1,{0x00}},
-
-{0x71, 1,{0x88}},
-
-{0x72, 1,{0x00}},
-
-{0x73, 1,{0x00}},
-
-{0x74, 1,{0x01}},//01
-
-{0x75, 1,{0x01}},//01
-
-{0x76, 1,{0x01}},//01
-
-{0x77, 1,{0x01}},//01
-
-{0x78, 1,{0x01}},//01
-
-{0x79, 1,{0x01}},//01
-
-{0x7A, 1,{0x00}},
-
-{0x7B, 1,{0x00}},
-
-{0x7C, 1,{0x00}},
-
-{0x7D, 1,{0x00}},
-
-{0x7E, 1,{0x0D}},
-
-{0x7F, 1,{0x0F}},
-
-{0x80, 1,{0x09}},
-
-{0x81, 1,{0x0B}},
-
-{0x82, 1,{0x01}},
-
-{0x83, 1,{0x03}},
-
-{0x84, 1,{0x1C}},
-
-{0x85, 1,{0x1C}},
-
-{0x86, 1,{0x1C}},
-
-{0x87, 1,{0x3F}},
-
-{0x88, 1,{0x1D}},
-
-{0x89, 1,{0x1C}},
-
-{0x8A, 1,{0x3F}},
-
-{0x8B, 1,{0x1A}},
-
-{0x8C, 1,{0x1B}},
-
-{0x8D, 1,{0x3F}},
-
-{0x8E, 1,{0x3F}},
-
-{0x8F, 1,{0x3F}},
-
-{0x90, 1,{0x3F}},
-
-{0x91, 1,{0x3F}},
-
-{0x92, 1,{0x3F}},
-
-{0x93, 1,{0x3F}},
-
-{0x94, 1,{0x3F}},
-
-{0x95, 1,{0x3F}},
-
-{0x96, 1,{0x3F}},
-
-{0x97, 1,{0x3F}},
-
-{0x98, 1,{0x3F}},
-
-{0x99, 1,{0x3F}},
-
-{0x9A, 1,{0x3F}},
-
-{0x9B, 1,{0x19}},
-
-{0x9C, 1,{0x18}},
-
-{0x9D, 1,{0x3F}},
-
-{0x9E, 1,{0x1C}},
-
-{0x9F, 1,{0x1D}},
-
-{0xA0, 1,{0x3F}},
-
-{0xA2, 1,{0x1C}},
-
-{0xA3, 1,{0x1C}},
-
-{0xA4, 1,{0x1C}},
-
-{0xA5, 1,{0x02}},
-
-{0xA6, 1,{0x00}},
-
-{0xA7, 1,{0x0A}},
-
-{0xA9, 1,{0x08}},
-
-{0xAA, 1,{0x0E}},
-
-{0xAB, 1,{0x0C}},
-
-{0xAC, 1,{0x0A}},
-
-{0xAD, 1,{0x08}},
-
-{0xAE, 1,{0x0E}},
-
-{0xAF, 1,{0x0C}},
-
-{0xB0, 1,{0x02}},
-
-{0xB1, 1,{0x00}},
-
-{0xB2, 1,{0x1C}},
-
-{0xB3, 1,{0x1C}},
-
-{0xB4, 1,{0x1C}},
-
-{0xB5, 1,{0x3F}},
-
-{0xB6, 1,{0x1C}},
-
-{0xB7, 1,{0x1D}},
-
-{0xB8, 1,{0x3F}},
-
-{0xB9, 1,{0x1A}},
-
-{0xBA, 1,{0x1B}},
-
-{0xBB, 1,{0x3F}},
-
-{0xBC, 1,{0x3F}},
-
-{0xBD, 1,{0x3F}},
-
-{0xBE, 1,{0x3f}},//3F
-
-{0xBF, 1,{0x3F}},
-
-{0xC0, 1,{0x3F}},
-
-{0xC1, 1,{0x3F}},
-
-{0xC2, 1,{0x3F}},
-
-{0xC3, 1,{0x3F}},
-
-{0xC4, 1,{0x3F}},
-
-{0xC5, 1,{0x3F}},
-
-{0xC6, 1,{0x3F}},
-
-{0xC7, 1,{0x3F}},
-
-{0xC8, 1,{0x3F}},
-
-{0xC9, 1,{0x19}},
-
-{0xCA, 1,{0x18}},
-
-{0xCB, 1,{0x3F}},
-
-{0xCC, 1,{0x1D}},
-
-{0xCD, 1,{0x1C}},
-
-{0xCE, 1,{0x3F}},
-
-{0xCF, 1,{0x1C}},
-
-{0xD0, 1,{0x1C}},
-
-{0xD1, 1,{0x1C}},
-
-{0xD2, 1,{0x01}},
-
-{0xD3, 1,{0x03}},
-
-{0xD4, 1,{0x0D}},
-
-{0xD5, 1,{0x0F}},
-
-{0xD6, 1,{0x09}},
-
-{0xD7, 1,{0x0B}},
-
-{0xDC, 1,{0x02}},
-
-{0xDE, 1,{0x0C}},
-
-{0xDF, 1,{0x00}},
-
-
-
-{0xFE, 1,{0x0E}},
-
-{0x01, 1,{0x75}},
-
-{0x1B, 1,{0x00}},
-
-{0x1C, 1,{0x00}},
-
-{0xFE, 1,{0x0C}},
-
-{0x08, 1,{0x03}},
-
-{0x09, 1,{0x03}},
-
-{0xFE, 1,{0x04}},
-
-{0x60, 1,{0x00}},
-
-{0x61, 1,{0x0A}},
-
-{0x62, 1,{0x11}},
-
-{0x63, 1,{0x0E}},
-
-{0x64, 1,{0x07}},
-
-{0x65, 1,{0x12}},
-
-{0x66, 1,{0x0F}},
-
-{0x67, 1,{0x0A}},
-
-{0x68, 1,{0x17}},
-
-{0x69, 1,{0x0D}},
-
-{0x6A, 1,{0x10}},
-
-{0x6B, 1,{0x09}},
-
-{0x6C, 1,{0x10}},
-
-{0x6D, 1,{0x11}},
-
-{0x6E, 1,{0x0A}},
-
-{0x6F, 1,{0x00}},
-
-{0x70, 1,{0x00}},
-
-{0x71, 1,{0x0A}},
-
-{0x72, 1,{0x11}},
-
-{0x73, 1,{0x0E}},
-
-{0x74, 1,{0x07}},
-
-{0x75, 1,{0x12}},
-
-{0x76, 1,{0x0F}},
-
-{0x77, 1,{0x0A}},
-
-{0x78, 1,{0x17}},
-
-{0x79, 1,{0x0D}},
-
-{0x7A, 1,{0x10}},
-
-{0x7B, 1,{0x09}},
-
-{0x7C, 1,{0x10}},
-
-{0x7D, 1,{0x11}},
-
-{0x7E, 1,{0x0A}},
-
-{0x7F, 1,{0x00}},
-
-
-{0xFE, 1,{0x00}},
-
-//{0x58, 1,{0xA9}},  //ce
-
-		{0x35, 1, {0x00}},
-
-		{0x11, 1, {0x00}},
-		{REGFLAG_DELAY, 120, {}},
-		{0x29, 1, {0x00}},
-	
-		{REGFLAG_DELAY, 20, {}},
-		{REGFLAG_END_OF_TABLE, 0x00, {}}
-};
-
-
-static struct LCM_setting_table lcm_sleep_out_setting[] = {
-	// Sleep Out
-	{0x11, 0, {0x00}},
-	{REGFLAG_DELAY, 120, {}},
-
-	// Display ON
-	{0x29, 0, {0x00}},
-	{REGFLAG_DELAY, 50, {}},
-
-	{REGFLAG_END_OF_TABLE, 0x00, {}}
-};
-
-
-static struct LCM_setting_table lcm_sleep_in_setting[] = {
-	// Display off sequence
-	
-	{0x28, 0, {0x00}},
-	{REGFLAG_DELAY, 50, {}},
-
-	// Sleep Mode On
-	{0x10, 1, {0x00}},
-	{REGFLAG_DELAY, 150, {}},
-
-	{0x4f, 0, {0x01}},
-	{REGFLAG_DELAY, 150, {}},
-	
-
-	{REGFLAG_END_OF_TABLE, 0x00, {}}
-};
-
-static void push_table(struct LCM_setting_table *table, unsigned int count,
-		unsigned char force_update)
-{
-	unsigned int i;
-
-	for (i = 0; i < count; i++) {
-
-		unsigned cmd;
-		cmd = table[i].cmd;
-
-		switch (cmd) {
-
-		case REGFLAG_DELAY:
-			MDELAY(table[i].count);
-			break;
-
-		case REGFLAG_END_OF_TABLE:
-			break;
-
-		default:
-			dsi_set_cmdq_V2(cmd, table[i].count,
-					table[i].para_list, force_update);
-		}
-	}
-
-}
-
-
-// ---------------------------------------------------------------------------
-//  LCM Driver Implementations
-// ---------------------------------------------------------------------------
-
-static void lcm_set_util_funcs(const LCM_UTIL_FUNCS * util)
-{
-	memcpy(&lcm_util, util, sizeof(LCM_UTIL_FUNCS));
-}
-
-
-static void lcm_get_params(LCM_PARAMS * params)
-{
-	memset(params, 0, sizeof(LCM_PARAMS));
-
-	params->type = LCM_TYPE_DSI;
-
-	params->width = FRAME_WIDTH;
-	params->height = FRAME_HEIGHT;
-
-	// enable tearing-free
-	params->dbi.te_mode = LCM_DBI_TE_MODE_VSYNC_ONLY;//LCM_DBI_TE_MODE_DISABLED;
-	params->dbi.te_edge_polarity = LCM_POLARITY_RISING;
-
-#if (LCM_DSI_CMD_MODE)
-	params->dsi.mode = CMD_MODE;
-#else
-	params->dsi.mode   = SYNC_PULSE_VDO_MODE;//SYNC_EVENT_VDO_MODE;//BURST_VDO_MODE;////
-#endif
-
-	// DSI
-	/* Command mode setting */
-		params->dsi.LANE_NUM				= LCM_FOUR_LANE;
-	
-	//The following defined the fomat for data coming from LCD engine.
-	params->dsi.data_format.color_order = LCM_COLOR_ORDER_RGB;
-	params->dsi.data_format.trans_seq   = LCM_DSI_TRANS_SEQ_MSB_FIRST;
-	params->dsi.data_format.padding     = LCM_DSI_PADDING_ON_LSB;
-	params->dsi.data_format.format      = LCM_DSI_FORMAT_RGB888;
-	
-	
-	params->dsi.PS=LCM_PACKED_PS_24BIT_RGB888;
-	
-#if (LCM_DSI_CMD_MODE)
-	params->dsi.intermediat_buffer_num = 0;//because DSI/DPI HW design change, this parameters should be 0 when video mode in MT658X; or memory leakage
-	params->dsi.word_count=FRAME_WIDTH*3;	//DSI CMD mode need set these two bellow params, different to 6577
-#else
-	params->dsi.intermediat_buffer_num = 0;	//because DSI/DPI HW design change, this parameters should be 0 when video mode in MT658X; or memory leakage
-#endif
-
-	// Video mode setting
-	params->dsi.packet_size=256;
-
-	params->dsi.vertical_sync_active				=  2;//2
-	params->dsi.vertical_backporch					= 14;//50;
-	params->dsi.vertical_frontporch					= 16;//50;
-	params->dsi.vertical_active_line				= FRAME_HEIGHT; 
-
-	params->dsi.horizontal_sync_active				= 8;//10
-	params->dsi.horizontal_backporch				= 80;//34; 
-	params->dsi.horizontal_frontporch				= 80;//24;
-	params->dsi.horizontal_active_pixel				= FRAME_WIDTH;
-
-	// Bit rate calculation
-//params->dsi.ssc_disable = 1;
-	//1 Every lane speed
-params->dsi.PLL_CLOCK=210;//195
-
-//ESD
-    params->dsi.esd_check_enable            = 1;
-    params->dsi.customization_esd_check_enable  = 1;
-    params->dsi.lcm_esd_check_table[0].cmd          = 0x0a;
-    params->dsi.lcm_esd_check_table[0].count        = 1;
-    params->dsi.lcm_esd_check_table[0].para_list[0] = 0x9c;
-
-    params->dsi.noncont_clock = 1;
-    params->dsi.noncont_clock_period = 1;
-
-}
-
-static void lcm_init(void)
-{
-
-	SET_RESET_PIN(1);
-	MDELAY(10);
-	SET_RESET_PIN(0);
-	MDELAY(50);
-	SET_RESET_PIN(1);
-	MDELAY(120);
-
-	push_table(lcm_initialization_setting,sizeof(lcm_initialization_setting) /sizeof(struct LCM_setting_table), 1);
-}
-
-static void lcm_suspend(void)
-{
-	unsigned int array[16];
-	array[0] = 0x00FE1500;
-	dsi_set_cmdq(array, 1, 1);
-	MDELAY(50);
-	array[0] = 0x00011500;
-	dsi_set_cmdq(array, 1, 1);
-	MDELAY(50);
-	array[0] = 0x00280500;
-	dsi_set_cmdq(array, 1, 1);
-	MDELAY(50);
-	array[0] = 0x00100500;
-	dsi_set_cmdq(array, 1, 1);
-	MDELAY(50);
-	array[0] = 0x014F1500;
-	dsi_set_cmdq(array, 1, 1);
-	MDELAY(50);
-}
-
-
-static void lcm_resume(void)
-{   
-	lcm_init();
-}
-
-
-static void lcm_update(unsigned int x, unsigned int y,
-		unsigned int width, unsigned int height)
-{
-	unsigned int x0 = x;
-	unsigned int y0 = y;
-	unsigned int x1 = x0 + width - 1;
-	unsigned int y1 = y0 + height - 1;
-
-	unsigned char x0_MSB = ((x0 >> 8) & 0xFF);
-	unsigned char x0_LSB = (x0 & 0xFF);
-	unsigned char x1_MSB = ((x1 >> 8) & 0xFF);
-	unsigned char x1_LSB = (x1 & 0xFF);
-	unsigned char y0_MSB = ((y0 >> 8) & 0xFF);
-	unsigned char y0_LSB = (y0 & 0xFF);
-	unsigned char y1_MSB = ((y1 >> 8) & 0xFF);
-	unsigned char y1_LSB = (y1 & 0xFF);
-
-	unsigned int data_array[16];
-
-	data_array[0] = 0x00053902;
-	data_array[1] =
-		(x1_MSB << 24) | (x0_LSB << 16) | (x0_MSB << 8) | 0x2a;
-	data_array[2] = (x1_LSB);
-	data_array[3] = 0x00053902;
-	data_array[4] =
-		(y1_MSB << 24) | (y0_LSB << 16) | (y0_MSB << 8) | 0x2b;
-	data_array[5] = (y1_LSB);
-	data_array[6] = 0x002c3909;
-
-	dsi_set_cmdq(data_array, 7, 0);
-
-}
-
-
-static unsigned int lcm_compare_id(void)
-{
-		int array[4];
-		char buffer[5];
-		char id_high=0;
-		char id_low=0;
-		int id1=0;
-		int id2=0;
-
-		SET_RESET_PIN(1);
-		MDELAY(10);
-		SET_RESET_PIN(0);
-		MDELAY(10);
-		SET_RESET_PIN(1);
-		MDELAY(200);
-		array[0]=0x01FE1500;
-		dsi_set_cmdq(array,1, 1);
-
-		array[0] = 0x00013700;
-		dsi_set_cmdq(array, 1, 1);
-		read_reg_v2(0xde, buffer, 1);
-
-		id_high = buffer[0];
-		read_reg_v2(0xdf, buffer, 1);
-		id_low = buffer[0];
-		id1 = (id_high<<8) | id_low;
-
-		#if defined(BUILD_LK)
-		printf("rm68200a %s id1 = 0x%04x, id2 = 0x%04x\n", __func__, id1,id2);
-		#else
-		printk("rm68200a %s id1 = 0x%04x, id2 = 0x%04x\n", __func__, id1,id2);
-		#endif
-		return (LCM_RM68200_ID == id1)?1:0;
-
-}
-//no use
-static unsigned int lcm_esd_recover(void)
-{
-    unsigned char para = 0;
-	unsigned int data_array1[16];
-
-#ifndef BUILD_LK
-    printk("RM68190 lcm_esd_recover enter\n");
-#endif
-    
-
-    SET_RESET_PIN(1);
-    MDELAY(10);
-    SET_RESET_PIN(0);
-    MDELAY(30);
-    SET_RESET_PIN(1);
-    MDELAY(130);
-    #if 0
-	push_table(lcm_initialization_setting, sizeof(lcm_initialization_setting) / sizeof(struct LCM_setting_table), 1);
-	MDELAY(10);
-	push_table(lcm_sleep_out_setting, sizeof(lcm_sleep_out_setting) / sizeof(struct LCM_setting_table), 1);
-    	MDELAY(10);
-    #else
-        lcm_init();
-    #endif
-   
-   data_array1[0]= 0x00320500;
-   dsi_set_cmdq(data_array1, 1, 1);
-   MDELAY(50);
-
-    return 1;
-}
-static unsigned int lcm_esd_check(void)
-{
-    unsigned char buffer[1] ={0};
-    //unsigned int data_array[1];
-   // data_array[0] = 0x00013700;// read id return two byte,version and id 3 byte 
-  // dsi_set_cmdq(&data_array, 1, 1);
-   read_reg_v2(0x0a, buffer, 1);
-   
-#ifndef BUILD_LK
-    printk("RM68190 lcm_esd_check enter %x\n",buffer[0]);
-#endif
-#ifndef BUILD_LK
-        if(buffer[0] == 0x9C)
-        {
-          #ifndef BUILD_LK
-          printk("RM68190 lcm_esd_check false \n");
-          #endif
-
-            return false;
-        }
-        else
-        {      
-           #ifndef BUILD_LK
-          printk("RM68190 lcm_esd_check true \n");
-          #endif
-           //lcm_esd_recover();
-            return true;
-        }
-#endif
-}
-
-// ---------------------------------------------------------------------------
-//  Get LCM Driver Hooks
-// ---------------------------------------------------------------------------
-LCM_DRIVER hct_rm68200_dsi_vdo_hd_cpt = 
-{
-	.name			= "hct_rm68200_dsi_vdo_hd_cpt",
-	.set_util_funcs = lcm_set_util_funcs,
-	.get_params     = lcm_get_params,
-	.init           = lcm_init,
-	.suspend        = lcm_suspend,
-	.resume         = lcm_resume,	
-	.compare_id     = lcm_compare_id,	
-    .esd_check   	= lcm_esd_check,	
-    .esd_recover   	= lcm_esd_recover,	
-#if (LCM_DSI_CMD_MODE)
-    .update         = lcm_update,
-#endif	//wqtao
-};
-
diff --git a/drivers/misc/mediatek/lcm/ili9807_qhd_dsi/Makefile~ b/drivers/misc/mediatek/lcm/ili9807_qhd_dsi/Makefile~
deleted file mode 100755
index 59977c1..0000000
--- a/drivers/misc/mediatek/lcm/ili9807_qhd_dsi/Makefile~
+++ /dev/null
@@ -1,10 +0,0 @@
-#
-# Makefile for misc devices that really don't fit anywhere else.
-#
-include $(srctree)/drivers/misc/mediatek/Makefile.custom
-
-obj-y += otm1284a_hd_dsi_vdo.o
-
-
-
-
diff --git a/drivers/misc/mediatek/lcm/ili9807_qhd_dsi/ili9807_qhd_dsi.c~ b/drivers/misc/mediatek/lcm/ili9807_qhd_dsi/ili9807_qhd_dsi.c~
deleted file mode 100755
index 8ed4da7..0000000
--- a/drivers/misc/mediatek/lcm/ili9807_qhd_dsi/ili9807_qhd_dsi.c~
+++ /dev/null
@@ -1,660 +0,0 @@
-/* Copyright Statement:
- *
- * This software/firmware and related documentation ("MediaTek Software") are
- * protected under relevant copyright laws. The information contained herein
- * is confidential and proprietary to MediaTek Inc. and/or its licensors.
- * Without the prior written permission of MediaTek inc. and/or its licensors,
- * any reproduction, modification, use or disclosure of MediaTek Software,
- * and information contained herein, in whole or in part, shall be strictly prohibited.
- */
-/* MediaTek Inc. (C) 2010. All rights reserved.
- *
- * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
- * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
- * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
- * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
- * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
- * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
- * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
- * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
- * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
- * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
- * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
- * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
- * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
- * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
- * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
- * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
- *
- * The following software/firmware and/or related documentation ("MediaTek Software")
- * have been modified by MediaTek Inc. All revisions are subject to any receiver's
- * applicable license agreements with MediaTek Inc.
- */
-
-/*****************************************************************************
-*  Copyright Statement:
-*  --------------------
-*  This software is protected by Copyright and the information contained
-*  herein is confidential. The software may not be copied and the information
-*  contained herein may not be used or disclosed except with the written
-*  permission of MediaTek Inc. (C) 2008
-*
-*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
-*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
-*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
-*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
-*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
-*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
-*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
-*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
-*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
-*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
-*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
-*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
-*
-*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
-*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
-*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
-*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
-*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
-*
-*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
-*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
-*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
-*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
-*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
-*
-*****************************************************************************/
-
-#ifndef BUILD_LK
-#include <linux/string.h>
-#endif
-#include "lcm_drv.h"
-
-#ifdef BUILD_LK
-	#include <platform/mt_gpio.h>
-#elif defined(BUILD_UBOOT)
-	#include <asm/arch/mt_gpio.h>
-#else
-	#include <mach/mt_gpio.h>
-#endif
-// ---------------------------------------------------------------------------
-//  Local Constants
-// ---------------------------------------------------------------------------
-
-#define FRAME_WIDTH                                         (540)
-#define FRAME_HEIGHT                                        (960)
-
-#define ILI9807_LCM_ID (0x9807)
-
-#define REGFLAG_DELAY             							0XFE
-#define REGFLAG_END_OF_TABLE      							0xFA   // END OF REGISTERS MARKER
-
-#ifndef TRUE
-    #define TRUE 1
-#endif
-
-#ifndef FALSE
-    #define FALSE 0
-#endif
-//#define LCM_DSI_CMD_MODE  1
-static unsigned int lcm_esd_test = FALSE;      ///only for ESD test
-
-// ---------------------------------------------------------------------------
-//  Local Variables
-// ---------------------------------------------------------------------------
-
-static LCM_UTIL_FUNCS lcm_util = {0};
-
-#define SET_RESET_PIN(v)    (lcm_util.set_reset_pin((v)))
-
-#define UDELAY(n) (lcm_util.udelay(n))
-#define MDELAY(n) (lcm_util.mdelay(n))
-
-
-// ---------------------------------------------------------------------------
-//  Local Functions
-// ---------------------------------------------------------------------------
-
-#define dsi_set_cmdq_V2(cmd, count, ppara, force_update)	        lcm_util.dsi_set_cmdq_V2(cmd, count, ppara, force_update)
-#define dsi_set_cmdq(pdata, queue_size, force_update)		lcm_util.dsi_set_cmdq(pdata, queue_size, force_update)
-#define wrtie_cmd(cmd)										lcm_util.dsi_write_cmd(cmd)
-#define write_regs(addr, pdata, byte_nums)					lcm_util.dsi_write_regs(addr, pdata, byte_nums)
-#define read_reg(cmd)											lcm_util.dsi_dcs_read_lcm_reg(cmd)
-#define read_reg_v2(cmd, buffer, buffer_size)   				lcm_util.dsi_dcs_read_lcm_reg_v2(cmd, buffer, buffer_size)   
-
-#define changecmd(a,b,c,d) ((d<<24)|(c<<16)|(b<<8)|a)
-
-struct LCM_setting_table {
-    unsigned cmd;
-    unsigned char count;
-    unsigned char para_list[128];
-};
-
-
-// ---------------------------------------------------------------------------
-//  LCM Driver Implementations
-// ---------------------------------------------------------------------------
-
-static struct LCM_setting_table lcm_initialization_setting[] = {
-//************* Start Initial Sequence **********//
-{0xFF,5,{0xFF,0x98,0x07,0x00,0x01}}, // EXTC Command Set enable register       //Change to page 1
-
-{0x31,1,{0x00}}, // Inversion Type
-
-{0x22,1,{0x03}}, // mirr
-
-{0x40,1,{0x55}}, // Power Contorl 1
-
-
-{0x41,1,{0x33}}, // Power Contorl 2
-
-
-{0x46,1,{0xDC}}, // Power Contorl 7
-
-
-{0x47,1,{0xBB}},// Power Contorl 8
-
-
-{0x52,1,{0x00}},// VCOM Control 1
-
-
-{0x53,1,{0x2e}}, // VCOM Control 2 {0x53,1,{0x2a}}, 
-
-
-{0x60,1,{0x05}},// SOURCE TIMING ADJUST 1
-
-
-{0x61,1,{0x00}}, // SOURCE TIMING ADJUST 2
-
-
-{0x62,1,{0x08}}, // SOURCE TIMING ADJUST 3
-
-
-{0x63,1,{0x00}},// SOURCE TIMING ADJUST 4
-
-
-{0x64,1,{0x88}}, // SOURCE TIMING ADJUST 5
-
-
-{0xA0,1,{0x00}}, // Positive Gamma Control 1
-
-
-{0xA1,1,{0x0E}}, // Positive Gamma Control 2
-
-
-{0xA2,1,{0x14}}, // Positive Gamma Control 3
-
-
-{0xA3,1,{0x0E}}, // Positive Gamma Control 4
-
-
-{0xA4,1,{0x05}}, // Positive Gamma Control 5
-
-
-{0xA5,1,{0x0C}}, // Positive Gamma Control 6
-
-
-{0xA6,1,{0x08}}, // Positive Gamma Control 7
-
-
-{0xA7,1,{0x05}}, // Positive Gamma Control 8
-
-
-{0xA8,1,{0x06}}, // Positive Gamma Control 9
-
-
-{0xA9,1,{0x0B}}, // Positive Gamma Control 10
-
-
-{0xAA,1,{0x0F}}, // Positive Gamma Control 11
-
-
-{0xAB,1,{0x07}}, // Positive Gamma Control 12
-
-
-{0xAC,1,{0x0F}}, // Positive Gamma Control 13
-
-
-{0xAD,1,{0x14}}, // Positive Gamma Control 14
-
-
-{0xAE,1,{0x0B}}, // Positive Gamma Control 15
-
-
-{0xAF,1,{0x00}}, // Positive Gamma Control 16
-
-
-{0xC0,1,{0x00}}, // Negative Gamma Control 1
-
-
-{0xC1,1,{0x0C}}, // Negative Gamma Control 2
-
-
-{0xC2,1,{0x14}}, // Negative Gamma Control 3
-
-
-{0xC3,1,{0x0E}}, // Negative Gamma Control 4
-
-
-{0xC4,1,{0x05}}, // Negative Gamma Control 5
-
-
-{0xC5,1,{0x0C}}, // Negative Gamma Control 6
-
-
-{0xC6,1,{0x06}}, // Negative Gamma Control 7
-
-
-{0xC7,1,{0x05}}, // Negative Gamma Control 8
-
-
-{0xC8,1,{0x07}}, // Negative Gamma Control 9
-
-
-{0xC9,1,{0x0B}}, // Negative Gamma Control 10
-
-
-{0xCA,1,{0x0E}}, // Negative Gamma Control 11
-
-
-{0xCB,1,{0x08}}, // Negative Gamma Control 12
-
-
-{0xCC,1,{0x0E}}, // Negative Gamma Control 13
-
-
-{0xCD,1,{0x14}}, // Negative Gamma Control 14
-
-
-{0xCE,1,{0x0C}}, // Negative Gamma Control 15
-
-
-{0xCF,1,{0x00}}, // Negative Gamma Control 16
-
-
-{0xFF,5,{0xFF,0x98,0x07,0x00,0x06}}, // EXTC Command Set enable register         //Change to page 6
- 
-
-{0x00,1,{0x21}},
-
-{0x01,1,{0x06}},
-
-{0x02,1,{0x00}},
-
-{0x03,1,{0x01}},
-
-{0x04,1,{0x16}},
-
-{0x05,1,{0x16}},
-
-{0x06,1,{0x80}},
-
-{0x07,1,{0x01}},
-
-{0x08,1,{0x06}},
-
-{0x09,1,{0x00}},
-
-{0x0A,1,{0x00}},
-
-{0x0B,1,{0x00}},
-
-{0x0C,1,{0x0F}},
-
-{0x0D,1,{0x0F}},
-
-{0x0E,1,{0x1F}},
-
-{0x0F,1,{0x00}},
-
-{0x10,1,{0x77}},
-
-{0x11,1,{0xE0}},
-
-{0x12,1,{0x00}},
-
-{0x13,1,{0x00}},
-
-{0x14,1,{0x00}},
-
-{0x15,1,{0xC0}},
-
-{0x16,1,{0x08}},
-
-{0x17,1,{0x00}},
-
-{0x18,1,{0x00}},
-
-{0x19,1,{0x00}},
-
-{0x1A,1,{0x00}},
-
-{0x1B,1,{0x00}},
-
-{0x1C,1,{0x00}},
-
-{0x1D,1,{0x00}},
-
-{0x20,1,{0x01}},
-
-{0x21,1,{0x23}},
-
-{0x22,1,{0x45}},
-
-{0x23,1,{0x67}},
-
-{0x24,1,{0x01}},
-
-{0x25,1,{0x23}},
-
-{0x26,1,{0x45}},
-
-{0x27,1,{0x67}},
-
-{0x30,1,{0x01}},
-
-{0x31,1,{0x22}},
-
-{0x32,1,{0x22}},
-
-{0x33,1,{0x11}},
-
-{0x34,1,{0x00}},
-
-{0x35,1,{0x86}},
-
-{0x36,1,{0x68}},
-
-{0x37,1,{0x22}},
-
-{0x38,1,{0x22}},
-
-{0x39,1,{0xDA}},
-
-{0x3A,1,{0xBC}},
-
-{0x3B,1,{0xCB}},
-
-{0x3C,1,{0xAD}},
-
-{0x3D,1,{0x22}},
-
-{0x3E,1,{0x22}},
-
-{0x3F,1,{0x22}},
-
-{0x40,1,{0x22}},
-
-{0x41,1,{0x22}},
-
-{0x42,1,{0x22}},
-
-{0x43,1,{0x22}},
-
-{0xFF,5,{0xFF,0x98,0x07,0x00,0x07}}, // EXTC Command Set enable register  //Change to page 7
-  
-
-{0x02,1,{0x77}}, //DDVDH/DDVDL ADVANCE ADJUST
-
-
-{0x26,1,{0xA2}}, //SOURCE Control
-
-
-{0xFF,5,{0xFF,0x98,0x07,0x00,0x00}},  // EXTC Command Set enable register       //Change to page 0
-
-
-{0x35,1,{0x00}}, //TE On
-
-
-
-{0x11,0,{0x00}},
-{REGFLAG_DELAY, 120, {}},
-
-{0x29,0,{0x00}},
-{REGFLAG_DELAY, 10, {}},
-
-	{REGFLAG_END_OF_TABLE, 0x00, {}}
-};
-
-static void push_table(struct LCM_setting_table *table, unsigned int count, unsigned char force_update)
-{
-    unsigned int i;
-
-    for(i = 0; i < count; i++) {
-        
-        unsigned cmd;
-        cmd = table[i].cmd;
-        
-        switch (cmd) {
-            
-            case REGFLAG_DELAY :
-                MDELAY(table[i].count);
-                break;
-				
-            case REGFLAG_END_OF_TABLE :
-                break;
-				
-            default:
-                dsi_set_cmdq_V2(cmd, table[i].count, table[i].para_list, force_update);
-                MDELAY(2);
-        }
-    }
-    
-}
-
-
-
-
-// ---------------------------------------------------------------------------
-//  LCM Driver Implementations
-// ---------------------------------------------------------------------------
-
-static void lcm_set_util_funcs(const LCM_UTIL_FUNCS *util)
-{
-    memcpy(&lcm_util, util, sizeof(LCM_UTIL_FUNCS));
-}
-
-
-static void lcm_get_params(LCM_PARAMS *params)
-{
-		memset(params, 0, sizeof(LCM_PARAMS));
-	
-		params->type   = LCM_TYPE_DSI;
-
-		params->width  = FRAME_WIDTH;
-		params->height = FRAME_HEIGHT;
-#if (LCM_DSI_CMD_MODE)
-		params->dsi.mode   = CMD_MODE;//BURST_VDO_MODE;//SYNC_PULSE_VDO_MODE; //SYNC_PULSE_VDO_MODE;//BURST_VDO_MODE; CMD_MODE
-#else
-		params->dsi.mode   =BURST_VDO_MODE;
-#endif
-		params->dbi.te_mode 				= LCM_DBI_TE_MODE_VSYNC_ONLY;
-		params->dbi.te_edge_polarity		= LCM_POLARITY_RISING;
-
-		// DSI
-		/* Command mode setting */
-		params->dsi.LANE_NUM				= LCM_TWO_LANE;//LCM_FOUR_LANE;//LCM_FOUR_LANE;LCM_TWO_LANE
-		//The following defined the fomat for data coming from LCD engine.
-		params->dsi.data_format.color_order = LCM_COLOR_ORDER_RGB;
-		params->dsi.data_format.trans_seq   = LCM_DSI_TRANS_SEQ_MSB_FIRST;
-		params->dsi.data_format.padding     = LCM_DSI_PADDING_ON_LSB;
-		params->dsi.data_format.format      = LCM_DSI_FORMAT_RGB888;
-
-		// Highly depends on LCD driver capability.
-		// Not support in MT6573
-		params->dsi.packet_size=256;
-
-		// Video mode setting		
-               params->dsi.intermediat_buffer_num = 0;//because DSI/DPI HW design change, this parameters should be 0 when video mode in MT658X; or memory leakage
-		params->dsi.PS=LCM_PACKED_PS_24BIT_RGB888;
-		params->dsi.word_count=480*3;	
-
-		params->dsi.vertical_sync_active				= 4;// 4;2
-		params->dsi.vertical_backporch					= 16;// 8;2
-		params->dsi.vertical_frontporch					= 20;// 8;2
-		params->dsi.vertical_active_line				= FRAME_HEIGHT; 
-
-		params->dsi.horizontal_sync_active				= 10;//6
-		params->dsi.horizontal_backporch				= 80;//37
-		params->dsi.horizontal_frontporch				= 80;//37
-		params->dsi.horizontal_active_pixel				= FRAME_WIDTH;
-	    //params->dsi.LPX=8; 
-
-		// Bit rate calculation
-		//1 Every lane speed
-		params->dsi.PLL_CLOCK= 245;
-# if 1
-			params->dsi.clk_lp_per_line_enable = 0;
-			params->dsi.esd_check_enable = 1;
-			params->dsi.customization_esd_check_enable = 0;
-			params->dsi.lcm_esd_check_table[0].cmd          = 0x0A;
-			params->dsi.lcm_esd_check_table[0].count        = 1;
-			params->dsi.lcm_esd_check_table[0].para_list[0] = 0x9C;
-#endif
-}
-//static unsigned int vcom = 0x60;
-static void lcm_init(void)
-{
-
-  unsigned int data_array[16]; 
-  SET_RESET_PIN(1);    
-  MDELAY(10); 
-  SET_RESET_PIN(0);
-  MDELAY(10); 
-  SET_RESET_PIN(1);
-  MDELAY(120); 
-  push_table(lcm_initialization_setting, sizeof(lcm_initialization_setting) / sizeof(struct LCM_setting_table), 1);
-
- }
-
-
-
-static void lcm_suspend(void)
-{
-	unsigned int data_array[16];
-	data_array[0] = 0x00280500;
-	dsi_set_cmdq(data_array, 1,1);
-	MDELAY(50);
-	
-	data_array[0] = 0x00100500;
-	dsi_set_cmdq(data_array, 1,1);
-	MDELAY(100);
-	
-}
-
-static unsigned int lcm_compare_id(void);
-static void lcm_resume(void)
-{
-	unsigned int data_array[16];
-//	vcom++;
-#if !defined(BUILD_LK)
-//		printk("otm1283a %s vcom  = 0x%02x\n", __func__, vcom);
-#endif
-#if 1//20150407 
-	data_array[0] = 0x00110500;
-	dsi_set_cmdq(data_array, 1,1);
-	MDELAY(50);
-	
-	data_array[0] = 0x00290500;
-	dsi_set_cmdq(data_array, 1,1);
-	MDELAY(100);
-#else
-//	lcm_compare_id();
-	lcm_init();
-#endif
-}
-         
-#if (LCM_DSI_CMD_MODE)
-static void lcm_update(unsigned int x, unsigned int y,
-                       unsigned int width, unsigned int height)
-{
-	unsigned int x0 = x;
-	unsigned int y0 = y;
-	unsigned int x1 = x0 + width - 1;
-	unsigned int y1 = y0 + height - 1;
-
-	unsigned char x0_MSB = ((x0>>8)&0xFF);
-	unsigned char x0_LSB = (x0&0xFF);
-	unsigned char x1_MSB = ((x1>>8)&0xFF);
-	unsigned char x1_LSB = (x1&0xFF);
-	unsigned char y0_MSB = ((y0>>8)&0xFF);
-	unsigned char y0_LSB = (y0&0xFF);
-	unsigned char y1_MSB = ((y1>>8)&0xFF);
-	unsigned char y1_LSB = (y1&0xFF);
-
-	unsigned int data_array[16];
-
-	data_array[0]= 0x00053902;
-	data_array[1]= (x1_MSB<<24)|(x0_LSB<<16)|(x0_MSB<<8)|0x2a;
-	data_array[2]= (x1_LSB);
-	dsi_set_cmdq(data_array, 3, 1);
-	
-	data_array[0]= 0x00053902;
-	data_array[1]= (y1_MSB<<24)|(y0_LSB<<16)|(y0_MSB<<8)|0x2b;
-	data_array[2]= (y1_LSB);
-	dsi_set_cmdq(data_array, 3, 1);
-
-	data_array[0]= 0x002c3909;
-	dsi_set_cmdq(data_array, 1, 0);
-
-}
-#endif
-//extern int IMM_GetOneChannelValueEX(int dwChannel, int deCount);
-static unsigned int lcm_compare_id(void)
-{
-    unsigned int id = 0;
-    unsigned int id1 = 0;
-    unsigned int id2 = 0;
-    unsigned char buffer[3];
-    unsigned int array[16];
-	unsigned int lcm_id = 0;
-    return 1;
-    SET_RESET_PIN(1);  //NOTE:should reset LCM firstly
-    SET_RESET_PIN(0);
-    MDELAY(25);
-    SET_RESET_PIN(1);
-    MDELAY(50);
-    //return 1;
-	array[0]=0x00063902;  // change to page 6
-	array[1]=changecmd(0xff,0xff,0x98,0x07);
-	array[2]=changecmd(0x04,0x01,0x00,0x00);
-	dsi_set_cmdq(array, 3, 1);
-	MDELAY(10);
-    array[0] = 0x00013700;// read id return two byte,version and id
-    dsi_set_cmdq(array, 1, 1);
-    read_reg_v2(0x00, buffer, 1);
-    id = buffer[0]; //we only need ID
-    read_reg_v2(0x01, buffer, 1);
-	id1 = buffer[0];
-    read_reg_v2(0x02, buffer, 1);
-	id2 = buffer[0];
-    lcm_id = id << 8 | id1;
-#if defined(BUILD_LK)
-    printf("-------ili9608c_fwvga_dsi_vdo %s, id0 = 0x%02x,id1 = 0x%02x,id2 = 0x%02x , lcm_id = 0x%04x\n", __func__, id,id1,id2,lcm_id);
-#else
-    printk("-------ili9608c_fwvga_dsi_vdo %s, id0 = 0x%02x,id1 = 0x%02x,id2 = 0x%02x , lcm_id = 0x%04x\n", __func__, id,id1,id2,lcm_id);
-
-#endif
-    return (ILI9807_LCM_ID == lcm_id)?1:0;
-    
-}
-
-
-LCM_DRIVER ili9807_qhd_dsi_drv = 
-{
-.name = "ili9807_qhd_dsi",
-    .set_util_funcs = lcm_set_util_funcs,
-    .get_params     = lcm_get_params,
-    .init           = lcm_init,
-    .suspend        = lcm_suspend,
-    .resume         = lcm_resume,
- //   .compare_id     = lcm_compare_id,
-    //.esd_check = lcm_esd_check,
-    //.esd_recover = lcm_esd_recover,
-#if (LCM_DSI_CMD_MODE)
-    .update         = lcm_update,
-#endif
-    };
diff --git a/drivers/misc/mediatek/lcm/otm1284a_hd_dsi_vdo/otm1284a_hd_dsi_vdo.c~ b/drivers/misc/mediatek/lcm/otm1284a_hd_dsi_vdo/otm1284a_hd_dsi_vdo.c~
deleted file mode 100755
index 6cfbf1a..0000000
--- a/drivers/misc/mediatek/lcm/otm1284a_hd_dsi_vdo/otm1284a_hd_dsi_vdo.c~
+++ /dev/null
@@ -1,572 +0,0 @@
-#ifndef BUILD_LK
-#include <linux/string.h>
-#endif
-#include "lcm_drv.h"
-
-#ifdef BUILD_LK
-	#include <platform/mt_gpio.h>
-#elif defined(BUILD_UBOOT)
-	#include <asm/arch/mt_gpio.h>
-#else
-	#include <mach/mt_gpio.h>
-#endif
-
-#if 0
-#ifdef BUILD_LK
-#include <platform/mt_gpio.h>
-#include <platform/mt_pmic.h>
-#elif defined(BUILD_UBOOT)
-#include <asm/arch/mt_gpio.h>
-#else
-#include <mach/mt_gpio.h>
-#include <linux/xlog.h>
-#include <mach/mt_pm_ldo.h>
-#endif
-#endif
-// ---------------------------------------------------------------------------
-//  Local Constants
-// ---------------------------------------------------------------------------
-
-#define FRAME_WIDTH  			(720)
-#define FRAME_HEIGHT 			(1280)
-#define LCM_OTM1283_ID			(0x1283)
-
-#define REGFLAG_DELAY          		(0XFEE)
-#define REGFLAG_END_OF_TABLE      	(0xFFFF)	// END OF REGISTERS MARKER
-
-#ifndef FALSE
-#define FALSE 0
-#endif
-//#define GPIO_LCD_RST_EN      (GPIO112)
-
-// ---------------------------------------------------------------------------
-//  Local Variables
-// ---------------------------------------------------------------------------
-
-static LCM_UTIL_FUNCS lcm_util = { 0 };
-
-#define SET_RESET_PIN(v)    		(lcm_util.set_reset_pin((v)))
-
-#define UDELAY(n) 					(lcm_util.udelay(n))
-#define MDELAY(n) 					(lcm_util.mdelay(n))
-
-
-// ---------------------------------------------------------------------------
-//  Local Functions
-// ---------------------------------------------------------------------------
-
-#define dsi_set_cmdq_V2(cmd, count, ppara, force_update)        (lcm_util.dsi_set_cmdq_V2(cmd, count, ppara, force_update))
-#define dsi_set_cmdq(pdata, queue_size, force_update)		(lcm_util.dsi_set_cmdq(pdata, queue_size, force_update))
-#define wrtie_cmd(cmd)						(lcm_util.dsi_write_cmd(cmd))
-#define write_regs(addr, pdata, byte_nums)			(lcm_util.dsi_write_regs(addr, pdata, byte_nums))
-#define read_reg						(lcm_util.dsi_read_reg())
-#define read_reg_v2(cmd, buffer, buffer_size)   		(lcm_util.dsi_dcs_read_lcm_reg_v2(cmd, buffer, buffer_size))
-
-static struct LCM_setting_table {
-	unsigned cmd;
-	unsigned char count;
-	unsigned char para_list[64];
-};
-
-static void lcm_suspend(void);
-
-static struct LCM_setting_table lcm_initialization_setting[] = {
-                  
-//qicai otm1284a auo hd                                                                                               
-
-	{0x00,1,{0x00}},
-	{0xff,3,{0x12,0x84,0x01}},	//EXTC=1
-	{0x00,1,{0x80}},	        //Orise mode enable
-	{0xff,2,{0x12,0x84}},
-
-	{0x00,1,{0xa6}},             //zigzag setting
-	{0xb3,1,{0x0f}},
-
-//-------------------- panel setting --------------------//
-	{0x00,1,{0x80}},             //TCON Setting
-	{0xc0,9,{0x00,0x64,0x00,0x10,0x10,0x00,0x64,0x10,0x10}},
-
-	{0x00,1,{0x90}},             //Panel Timing Setting
-  {0xc0,6,{0x00,0x5c,0x00,0x01,0x00,0x04}},
-
-	{0x00,1,{0xa2}},
-	{0xC0,3,{0x01,0x00,0x00}},
-
-	{0x00,1,{0xb3}},             //Interval Scan Frame: 0 frame, column inversion
-	{0xc0,2,{0x00,0x55}},
-
-
-        {0x00,1,{0xb5}},             
-	{0xc0,1,{0x18}},
-
-	{0x00,1,{0x81}},             //frame rate:60Hz
-	{0xc1,1,{0x55}},
-
-//-------------------- power setting --------------------//
-	{0x00,1,{0xa0}},             //dcdc setting
-	{0xc4,14,{0x05,0x10,0x04,0x02,0x05,0x15,0x11,0x05,0x10,0x07,0x02,0x05,0x15,0x11}},
-
-	{0x00,1,{0xb0}},             //clamp voltage setting
-	{0xc4,2,{0x00,0x00}},
-
-	{0x00,1,{0x91}},             //VGH=13V, VGL=-12V, pump ratio:VGH=6x, VGL=-5x
-	{0xc5,2,{0x29,0x52}},
-
-	{0x00,1,{0x00}},             //GVDD=4.9V, NGVDD=-4.9V
-	{0xd8,2,{0xbe,0xbe}},             
-
-	{0x00,1,{0x00}}, 		//VCOM=-1.15V           
-	{0xd9,1,{0x59}},             
-
-	{0x00,1,{0xb3}},             //VDD_18V=1.7V, LVDSVDD=1.6V
-	{0xc5,1,{0x84}},
-
-	{0x00,1,{0xbb}},             //LVD voltage level setting
-	{0xc5,1,{0x8a}},
-
-	{0x00,1,{0x82}},		//chopper
-	{0xC4,1,{0x0a}},
-
-	{0x00,1,{0xc6}},		//debounce
-	{0xb0,1,{0x03}},
-
-	{0x00,1,{0xc2}},             //precharge disable
-	{0xf5,1,{0x40}},
-
-	{0x00,1,{0xc3}},             //sample hold gvdd
-	{0xf5,1,{0x85}},
-
-//-------------------- control setting --------------------//
-	{0x00,1,{0x00}},             //ID1
-	{0xd0,1,{0x40}},
-
-	{0x00,1,{0x00}},             //ID2, ID3
-	{0xd1,2,{0x00,0x00}},
-
-//-------------------- power on setting --------------------//
-	{0x00,1,{0x80}},             //source blanking frame = black, defacult='30'
-	{0xc4,1,{0x00}},
-
-	{0x00,1,{0x98}},             //vcom discharge=gnd:'10', '00'=disable
-	{0xc5,1,{0x10}},
-
-	{0x00,1,{0x81}},
-	{0xf5,1,{0x15}},  // ibias off
-	{0x00,1,{0x83}}, 
-	{0xf5,1,{0x15}},  // lvd off
-	{0x00,1,{0x85}},
-	{0xf5,1,{0x15}},  // gvdd off
-	{0x00,1,{0x87}}, 
-	{0xf5,1,{0x15}},  // lvdsvdd off
-	{0x00,1,{0x89}},
-	{0xf5,1,{0x15}},  // nvdd_18 off
-	{0x00,1,{0x8b}}, 
-	{0xf5,1,{0x15}},  // en_vcom off
-
-	{0x00,1,{0x95}},
-	{0xf5,1,{0x15}},  // pump3 off
-	{0x00,1,{0x97}}, 
-	{0xf5,1,{0x15}},  // pump4 off
-	{0x00,1,{0x99}},
-	{0xf5,1,{0x15}},  // pump5 off
-
-	{0x00,1,{0xa1}}, 
-	{0xf5,1,{0x15}},  // gamma off
-	{0x00,1,{0xa3}},
-	{0xf5,1,{0x15}},  // sd ibias off
-	{0x00,1,{0xa5}}, 
-	{0xf5,1,{0x15}},  // sdpch off
-	{0x00,1,{0xa7}}, 
-	{0xf5,1,{0x15}},  // sdpch bias off
-	{0x00,1,{0xab}},
-	{0xf5,1,{0x18}},  // ddc osc off
-
-	{0x00,1,{0x94}},             //VCL pump dis
-	{0xf5,2,{0x00,0x00}},
-
-	{0x00,1,{0xd2}},             //VCL reg. en
-	{0xf5,2,{0x06,0x15}},
-
-	{0x00,1,{0xb1}},             //VGLO, VGHO setting
-	{0xf5,13,{0x15,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x15,0x08,0x15}},
-
-	{0x00,1,{0xb4}},             //VGLO1/2 Pull low setting
-	{0xc5,1,{0xcc}},		//d[7] vglo1 d[6] vglo2 => 0: pull vss, 1: pull vgl
-
-//-------------------- for Power IC ---------------------------------
-	{0x00,1,{0x90}},             //Mode-3
-	{0xf5,4,{0x02,0x11,0x02,0x15}},
-
-	{0x00,1,{0x90}},             //2xVPNL, 1.5*=00, 2*=50, 3*=a0
-	{0xc5,1,{0x50}},
-
-	{0x00,1,{0x94}},             //Frequency
-	{0xc5,1,{0x66}},
-
-//-------------------- panel timing state control --------------------//
-	{0x00,1,{0x80}},             //panel timing state control
-	{0xcb,11,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
-
-	{0x00,1,{0x90}},             //panel timing state control
-	{0xcb,15,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x00,0xff,0x00}},
-
-	{0x00,1,{0xa0}},             //panel timing state control
-	{0xcb,15,{0xff,0x00,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
-
-	{0x00,1,{0xb0}},             //panel timing state control
-	{0xcb,15,{0x00,0x00,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0x00,0x00,0x00,0x00}},
-
-	{0x00,1,{0xc0}},             //panel timing state control
-	{0xcb,15,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x05,0x00,0x05,0x05,0x05,0x05,0x05}},
-
-	{0x00,1,{0xd0}},             //panel timing state control
-	{0xcb,15,{0x05,0x05,0x05,0x05,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05}},
-
-	{0x00,1,{0xe0}},             //panel timing state control
-	{0xcb,14,{0x05,0x00,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x00,0x00}},
-
-	{0x00,1,{0xf0}},             //panel timing state control
-	{0xcb,11,{0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff}},
-
-//-------------------- panel pad mapping control --------------------//
-	{0x00,1,{0x80}},             //panel pad mapping control
-	{0xcc,15,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x07,0x00,0x0d,0x09,0x0f,0x0b,0x11}},
-
-	{0x00,1,{0x90}},             //panel pad mapping control
-	{0xcc,15,{0x15,0x13,0x17,0x01,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06}},
-
-	{0x00,1,{0xa0}},             //panel pad mapping control
-	{0xcc,14,{0x08,0x00,0x0e,0x0a,0x10,0x0c,0x12,0x16,0x14,0x18,0x02,0x04,0x00,0x00}},
-
-	{0x00,1,{0xb0}},             //panel pad mapping control
-	{0xcc,15,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x02,0x00,0x0c,0x10,0x0a,0x0e,0x14}},
-
-	{0x00,1,{0xc0}},             //panel pad mapping control
-	{0xcc,15,{0x18,0x12,0x16,0x08,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03}},
-
-	{0x00,1,{0xd0}},             //panel pad mapping control
-	{0xcc,14,{0x01,0x00,0x0b,0x0f,0x09,0x0d,0x13,0x17,0x11,0x15,0x07,0x05,0x00,0x00}},
-
-//-------------------- panel timing setting --------------------//
-	{0x00,1,{0x80}},             //panel VST setting
-	{0xce,12,{0x87,0x03,0x28,0x86,0x03,0x28,0x85,0x03,0x28,0x84,0x03,0x28}},
-
-	{0x00,1,{0x90}},             //panel VEND setting
-	{0xce,14,{0x34,0xfc,0x28,0x34,0xfd,0x28,0x34,0xfe,0x28,0x34,0xff,0x28,0x00,0x00}},
-
-	{0x00,1,{0xa0}},             //panel CLKA1/2 setting
-	{0xce,14,{0x38,0x07,0x05,0x00,0x00,0x28,0x00,0x38,0x06,0x05,0x01,0x00,0x28,0x00}},
-
-	{0x00,1,{0xb0}},             //panel CLKA3/4 setting
-	{0xce,14,{0x38,0x05,0x05,0x02,0x00,0x28,0x00,0x38,0x04,0x05,0x03,0x00,0x28,0x00}},
-
-	{0x00,1,{0xc0}},             //panel CLKb1/2 setting
-	{0xce,14,{0x38,0x03,0x05,0x04,0x00,0x28,0x00,0x38,0x02,0x05,0x05,0x00,0x28,0x00}},
-
-	{0x00,1,{0xd0}},             //panel CLKb3/4 setting
-	{0xce,14,{0x38,0x01,0x05,0x06,0x00,0x28,0x00,0x38,0x00,0x05,0x07,0x00,0x28,0x00}},
-
-	{0x00,1,{0x80}},             //panel CLKc1/2 setting
-	{0xcf,14,{0x38,0x07,0x05,0x00,0x00,0x18,0x25,0x38,0x06,0x05,0x01,0x00,0x18,0x25}},
-
-	{0x00,1,{0x90}},             //panel CLKc3/4 setting
-	{0xcf,14,{0x38,0x05,0x05,0x02,0x00,0x18,0x25,0x38,0x04,0x05,0x03,0x00,0x18,0x25}},
-
-	{0x00,1,{0xa0}},             //panel CLKd1/2 setting
-	{0xcf,14,{0x38,0x03,0x05,0x04,0x00,0x18,0x25,0x38,0x02,0x05,0x05,0x00,0x18,0x25}},
-
-	{0x00,1,{0xb0}},             //panel CLKd3/4 setting
-	{0xcf,14,{0x38,0x01,0x05,0x06,0x00,0x18,0x25,0x38,0x00,0x05,0x07,0x00,0x18,0x25}},
-
-	{0x00,1,{0xc0}},             //panel ECLK setting
-	{0xcf,11,{0x01,0x01,0x20,0x20,0x00,0x00,0x01,0x81,0x00,0x03,0x08}},
-
-//-------------------- gamma --------------------//
-	{0x00,1,{0x00}},                                                                                                                                                               
-	{0xE1,20,{0x08,0x13,0x1d,0x2b,0x3b,0x4b,0x4e,0x7e,0x75,0x91,0x72,0x5b,0x6a,0x47,0x46,0x3d,0x31,0x24,0x1a,0x12}}, 
-                                                                                        
-	{0x00,1,{0x00}},                                                                                                                                                           
-	{0xE2,20,{0x08,0x13,0x1d,0x2b,0x3b,0x4b,0x4e,0x7e,0x75,0x91,0x72,0x5b,0x6a,0x47,0x46,0x3d,0x31,0x24,0x1a,0x12}}, 
-
-
-  	{0x00,1,{0x00}},             //Orise mode disable
-  	{0xff,3,{0xff,0xff,0xff}},
-
-
-	{0x11,0,{0x00}},//SLEEP OUT                                                                                             
-	{REGFLAG_DELAY,120,{}},                                                                                                 
-	                               				                                                                                
-	{0x29,0,{0x00}},//Display ON                                                                                            
-	{REGFLAG_DELAY,50,{}},  
-	{REGFLAG_END_OF_TABLE, 0x00, {}}
-
-};
-
-static struct LCM_setting_table lcm_sleep_out_setting[] = {
-	// Sleep Out
-	{0x11, 0, {0x00}},
-	{REGFLAG_DELAY, 120, {}},
-
-	// Display ON
-	{0x29, 0, {0x00}},
-	{REGFLAG_DELAY, 50, {}},
-	{REGFLAG_END_OF_TABLE, 0x00, {}}
-};
-
-
-static struct LCM_setting_table lcm_sleep_in_setting[] = {
-	// Display off sequence
-	{0x28, 0, {0x00}},
-	{REGFLAG_DELAY, 50, {}},
-	// Sleep Mode On
-	{0x10, 0, {0x00}},
-	{REGFLAG_DELAY, 100, {}},
-
-	{REGFLAG_END_OF_TABLE, 0x00, {}}
-};
-
-static void push_table(struct LCM_setting_table *table, unsigned int count,
-		       unsigned char force_update)
-{
-	unsigned int i;
-
-	for (i = 0; i < count; i++) {
-
-		unsigned cmd;
-		cmd = table[i].cmd;
-
-		switch (cmd) {
-
-		case REGFLAG_DELAY:
-			MDELAY(table[i].count);
-			break;
-
-		case REGFLAG_END_OF_TABLE:
-			break;
-
-		default:
-			dsi_set_cmdq_V2(cmd, table[i].count,
-					table[i].para_list, force_update);
-		}
-
-	}
-
-}
-
-// ---------------------------------------------------------------------------
-//  LCM Driver Implementations
-// ---------------------------------------------------------------------------
-
-static void lcm_set_util_funcs(const LCM_UTIL_FUNCS * util)
-{
-	memcpy(&lcm_util, util, sizeof(LCM_UTIL_FUNCS));
-}
-
-
-static void lcm_get_params(LCM_PARAMS * params)
-{
-	memset(params, 0, sizeof(LCM_PARAMS));
-
-	params->type = LCM_TYPE_DSI;
-
-	params->width = FRAME_WIDTH;
-	params->height = FRAME_HEIGHT;
-
-		params->dsi.mode   = BURST_VDO_MODE;
-
-	// DSI
-	/* Command mode setting */
-	params->dsi.LANE_NUM = LCM_FOUR_LANE;
-            params->dsi.data_format.color_order     = LCM_COLOR_ORDER_RGB;
-            params->dsi.data_format.trans_seq       = LCM_DSI_TRANS_SEQ_MSB_FIRST;
-            params->dsi.data_format.padding         = LCM_DSI_PADDING_ON_LSB;
-	params->dsi.data_format.format = LCM_DSI_FORMAT_RGB888;
-	params->dsi.PS = LCM_PACKED_PS_24BIT_RGB888;
-                 params->dsi.packet_size=256;
-	//params->dsi.intermediat_buffer_num = 2;
-    // Video mode setting		
-    params->dsi.vertical_sync_active = 6;
-    params->dsi.vertical_backporch = 24;
-    params->dsi.vertical_frontporch = 26;
-    params->dsi.vertical_active_line = FRAME_HEIGHT;
-    params->dsi.horizontal_sync_active = 8;
-    params->dsi.horizontal_backporch = 42;
-    params->dsi.horizontal_frontporch = 44;	
-    params->dsi.horizontal_active_pixel = FRAME_WIDTH;	
-#ifndef FPGA_EARLY_PORTING
-    params->dsi.PLL_CLOCK = 220; //this value must be in MTK suggested table
-#else
-    params->dsi.pll_div1 = 1;
-    params->dsi.pll_div2 = 1;
-    params->dsi.fbk_div = 30;	//26;    // fref=26MHz, fvco=fref*(fbk_div+1)*2/(div1_real*div2_real)
-    params->dsi.fbk_sel = 0;
-#endif
-}
-
-static void lcm_init(void)
-{
-	unsigned int data_array[16];
-#if 0
-#if defined(BUILD_LK)
-	printf("%s, otm1283a lcm_init \n", __func__);
-#else
-	printk("%s, otm1283a lcm_init  \n", __func__);
-#endif
-
-#ifdef BUILD_LK
-	upmu_set_rg_vgp2_en(0);
-	upmu_set_rg_vgp2_vosel(6);
-	upmu_set_rg_vgp2_en(1);
-#else
-	hwPowerOn(MT65XX_POWER_LDO_VGP6, VOL_3300, "LCM");
-#endif
-	mt_set_gpio_mode(GPIO_LCD_RST_EN, GPIO_MODE_00);
-	mt_set_gpio_dir(GPIO_LCD_RST_EN, GPIO_DIR_OUT);
-	mt_set_gpio_out(GPIO_LCD_RST_EN, GPIO_OUT_ONE);
-	MDELAY(10);
-	mt_set_gpio_out(GPIO_LCD_RST_EN, GPIO_OUT_ZERO);
-	MDELAY(50);
-	mt_set_gpio_out(GPIO_LCD_RST_EN, GPIO_OUT_ONE);
-	MDELAY(150);
-#endif
-
-	SET_RESET_PIN(1);
-	MDELAY(10); 
-	SET_RESET_PIN(0);
-	MDELAY(50); 
-	SET_RESET_PIN(1);
-	MDELAY(150);  
-
-/*
-	push_table(lcm_initialization_setting,
-		   sizeof(lcm_initialization_setting) /
-		   sizeof(struct LCM_setting_table), 1);
-*/	
-	push_table(lcm_initialization_setting,
-		   sizeof(lcm_initialization_setting) /
-		   sizeof(struct LCM_setting_table), 1);
-}
-
-
-static void lcm_suspend(void)
-{
-	unsigned int data_array[16];
-
-	data_array[0] = 0x00280500;	// Display Off
-	dsi_set_cmdq(&data_array, 1, 1);
-	MDELAY(20);
-
-	data_array[0] = 0x00100500;	// Sleep In
-	dsi_set_cmdq(&data_array, 1, 1);
-	MDELAY(120);
-
-#if 0
-#ifdef BUILD_LK
-	upmu_set_rg_vgp2_en(0);
-#else
-	hwPowerDown(MT65XX_POWER_LDO_VGP6, "LCM");
-#endif
-#endif
-
-	SET_RESET_PIN(1);	
-	SET_RESET_PIN(0);
-	MDELAY(1); // 1ms
-	
-	SET_RESET_PIN(1);
-	MDELAY(120);     
-
-}
-
-
-static void lcm_resume(void)
-{
-//#ifndef BUILD_LK
-	lcm_init();
-//#endif
-}
-
-
-static unsigned int lcm_compare_id(void)
-{
-	unsigned int id0, id1, id2, id3, id4;
-	unsigned char buffer[5];
-	unsigned int array[5];
-return 1;
-
-#if 0
-#ifdef BUILD_LK
-	upmu_set_rg_vgp2_vosel(6);
-	upmu_set_rg_vgp2_en(1);
-#else
-	hwPowerOn(MT65XX_POWER_LDO_VGP6, VOL_3300, "LCM");
-#endif
-
-	mt_set_gpio_mode(GPIO_LCD_RST_EN, GPIO_MODE_00);
-	mt_set_gpio_dir(GPIO_LCD_RST_EN, GPIO_DIR_OUT);
-	mt_set_gpio_out(GPIO_LCD_RST_EN, GPIO_OUT_ONE);
-	MDELAY(10);
-	mt_set_gpio_out(GPIO_LCD_RST_EN, GPIO_OUT_ZERO);
-	MDELAY(10);
-	mt_set_gpio_out(GPIO_LCD_RST_EN, GPIO_OUT_ONE);
-	MDELAY(100);
-#endif
-
-	SET_RESET_PIN(1);
-	MDELAY(10);
-	SET_RESET_PIN(0);
-	MDELAY(10);
-	SET_RESET_PIN(1);
-	MDELAY(100); 
-
-	// Set Maximum return byte = 1
-	array[0] = 0x00053700;
-	dsi_set_cmdq(array, 1, 1);
-
-	read_reg_v2(0xA1, buffer, 5);
-	id0 = buffer[0];
-	id1 = buffer[1];
-	id2 = buffer[2];
-	id3 = buffer[3];
-	id4 = buffer[4];
-
-#if defined(BUILD_LK)
-	printf("%s, otm1283a Module ID = {%x, %x, %x, %x, %x} \n", __func__, id0,
-	       id1, id2, id3, id4);
-#else
-	printk("%s, otm1283a Module ID = {%x, %x, %x, %x,%x} \n", __func__, id0,
-	       id1, id2, id3, id4);
-#endif
-	id0 = (id2 << 8) | id3;
-	//return (LCM_OTM1283_ID == ((id2 << 8) | id3)) ? 1 : 0;
-
-#if defined(BUILD_LK)
-	printf("otm1283a Module ID = %x \n", id0);
-#else
-	printk("otm1283a Module ID = %x \n", id0);
-#endif
-
-    if(id0 == LCM_OTM1283_ID)
-    	return 1;
-    else
-        return 0;
-}
-
-//
-
-// ---------------------------------------------------------------------------
-//  Get LCM Driver Hooks
-// ---------------------------------------------------------------------------
-//LCM_DRIVER otm1283a_bft_ivo_hd_dsi_vdo_lcm_drv = 
-LCM_DRIVER otm1284a_hd_dsi_vdo_qc_lcm_drv = 
-{
-       .name			= "otm1284a_hd_dsi_vdo_qc",
-	.set_util_funcs = lcm_set_util_funcs,
-	.compare_id     = lcm_compare_id,
-	.get_params     = lcm_get_params,
-	.init           = lcm_init,
-	.suspend        = lcm_suspend,
-	.resume         = lcm_resume,
-    #if defined(LCM_DSI_CMD_MODE)
-        .update         = lcm_update,
-    #endif
-};
diff --git a/drivers/misc/mediatek/lens/Makefile~ b/drivers/misc/mediatek/lens/Makefile~
deleted file mode 100755
index 95c959c..0000000
--- a/drivers/misc/mediatek/lens/Makefile~
+++ /dev/null
@@ -1,116 +0,0 @@
-#
-# Makefile for misc devices that really don't fit anywhere else.
-#
-include $(srctree)/drivers/misc/mediatek/Makefile.custom
-
-#obj-y += sensordriver/sensordrive_lens.o
-
- 
-ifeq ($(CONFIG_ARCH_MT8127),y)
-		obj-$(CONFIG_MTK_LENS_FM50AF_SUPPORT)      += mt8127/fm50af/
-else
-	ifeq ($(CONFIG_ARCH_MT6580),y)
-	obj-$(CONFIG_MTK_LENS_DW9814AF_SUPPORT)      += mt6580/dw9814af/
-	obj-$(CONFIG_MTK_LENS_DW9714AF_SUPPORT)      += mt6580/dw9714af/
-	else
-		ifeq ($(CONFIG_ARCH_MT6592),y)
-		obj-$(CONFIG_MTK_LENS_DUMMYLENS_SUPPORT) +=  mt6592/dummy_lens/
-		obj-$(CONFIG_MTK_LENS_FM50AF_SUPPORT)    +=  mt6592/fm50af/
-		obj-$(CONFIG_MTK_LENS_GAF001AF_SUPPORT)  +=  mt6592/gaf001af/
-		obj-$(CONFIG_MTK_LENS_GAF002AF_SUPPORT)  +=  mt6592/gaf002af/
-		obj-$(CONFIG_MTK_LENS_GAF008AF_SUPPORT)  +=  mt6592/gaf008af/
-		obj-$(CONFIG_MTK_LENS_DW9714AF_SUPPORT)  +=  mt6592/dw9714af/
-		obj-$(CONFIG_MTK_LENS_DW9714A_SUPPORT)   +=  mt6592/dw9714a/
-		obj-$(CONFIG_MTK_LENS_DW9718AF_SUPPORT)  +=  mt6592/dw9718af/
-		obj-$(CONFIG_MTK_LENS_AK7345AF_SUPPORT)  +=  mt6592/ak7345af/
-		obj-$(CONFIG_MTK_LENS_SENSORDRIVE_SUPPORT) += mt6592/sensordrive/
-		else 
-			ifeq ($(CONFIG_ARCH_MT6582),y)
-			obj-$(CONFIG_MTK_LENS_DUMMYLENS_SUPPORT) +=  mt6582/dummy_lens/
-			obj-$(CONFIG_MTK_LENS_FM50AF_SUPPORT)    +=  mt6582/fm50af/
-			obj-$(CONFIG_MTK_LENS_GAF001AF_SUPPORT)  +=  mt6582/gaf001af/
-			obj-$(CONFIG_MTK_LENS_GAF002AF_SUPPORT)  +=  mt6582/gaf002af/
-			obj-$(CONFIG_MTK_LENS_GAF008AF_SUPPORT)  +=  mt6582/gaf008af/
-			obj-$(CONFIG_MTK_LENS_DW9714AF_SUPPORT)  +=  mt6582/dw9714af/
-			obj-$(CONFIG_MTK_LENS_DW9714A_SUPPORT)   +=  mt6582/dw9714a/
-			obj-$(CONFIG_MTK_LENS_DW9718AF_SUPPORT)  +=  mt6582/dw9718af/
-			else 
-				ifeq ($(CONFIG_ARCH_MT6752),y)
-				obj-$(CONFIG_MTK_LENS_DUMMYLENS_SUPPORT) += mt6752/dummy_lens/
-				obj-$(CONFIG_MTK_LENS_AD5820AF_SUPPORT) += mt6752/ad5820af/
-				obj-$(CONFIG_MTK_LENS_AD5823_SUPPORT) += mt6752/ad5823/
-				obj-$(CONFIG_MTK_LENS_AD5823AF_SUPPORT) += mt6752/ad5823af/
-				obj-$(CONFIG_MTK_LENS_BU6424AF_SUPPORT) += mt6752/bu6424af/
-				obj-$(CONFIG_MTK_LENS_BU6429AF_SUPPORT) += mt6752/bu6429af/
-				obj-$(CONFIG_MTK_LENS_BU64745GWZAF_SUPPORT) += mt6752/bu64745gwzaf/
-				obj-$(CONFIG_MTK_LENS_DW9714AF_SUPPORT) += mt6752/dw9714af/
-				obj-$(CONFIG_MTK_LENS_DW9718AF_SUPPORT) += mt6752/dw9718af/
-				obj-$(CONFIG_MTK_LENS_FM50AF_SUPPORT) += mt6752/fm50af/
-				obj-$(CONFIG_MTK_LENS_MT9P017AF_SUPPORT) += mt6752/mt9p017af/
-				obj-$(CONFIG_MTK_LENS_OV8825AF_SUPPORT) += mt6752/ov8825af/
-				obj-$(CONFIG_MTK_LENS_SENSORDRIVE_SUPPORT) += mt6752/sensordrive/
-				obj-$(CONFIG_MTK_LENS_LC898122AF_SUPPORT) += mt6752/lc898122af/
-				obj-$(CONFIG_MTK_LENS_LC898212AF_SUPPORT) += mt6752/lc898212af/
-				else
-					ifneq (,$(filter y,$(CONFIG_ARCH_MT6735) $(CONFIG_ARCH_MT6735M) $(CONFIG_ARCH_MT6753)))
-					obj-$(CONFIG_MTK_LENS_DUMMYLENS_SUPPORT)   += mt6735/dummy_lens/
-					obj-$(CONFIG_MTK_LENS_AD5820AF_SUPPORT)    += mt6735/ad5820af/
-					obj-$(CONFIG_MTK_LENS_AD5823_SUPPORT)    += mt6735/ad5823/
-					obj-$(CONFIG_MTK_LENS_AD5823AF_SUPPORT)    += mt6735/ad5823af/
-					obj-$(CONFIG_MTK_LENS_BU6424AF_SUPPORT)    += mt6735/bu6424af/
-					obj-$(CONFIG_MTK_LENS_BU6429AF_SUPPORT)    += mt6735/bu6429af/
-					obj-$(CONFIG_MTK_LENS_BU64745GWZAF_SUPPORT)+= mt6735/bu64745gwzaf/
-					obj-$(CONFIG_MTK_LENS_DW9714AF_SUPPORT)    += mt6735/dw9714af/
-					obj-$(CONFIG_MTK_LENS_DW9718AF_SUPPORT)    += mt6735/dw9718af/
-					obj-$(CONFIG_MTK_LENS_FM50AF_SUPPORT)      += mt6735/fm50af/
-					obj-$(CONFIG_MTK_LENS_MT9P017AF_SUPPORT)   += mt6735/mt9p017af/
-					obj-$(CONFIG_MTK_LENS_OV8825AF_SUPPORT)    += mt6735/ov8825af/
-					obj-$(CONFIG_MTK_LENS_SENSORDRIVE_SUPPORT) += mt6735/sensordrive/
-					obj-$(CONFIG_MTK_LENS_LC898122AF_SUPPORT)  += mt6735/lc898122af/
-					obj-$(CONFIG_MTK_LENS_LC898212AF_SUPPORT)  += mt6735/lc898212af/
-					obj-$(CONFIG_MTK_LENS_AK7345AF_SUPPORT)    += mt6735/ak7345af/
-					else
-						ifeq ($(CONFIG_ARCH_MT6795),y)
-						obj-$(CONFIG_MTK_LENS_DUMMYLENS_SUPPORT)   += mt6795/dummy_lens/
-						obj-$(CONFIG_MTK_LENS_AD5820AF_SUPPORT)    += mt6795/ad5820af/
-						obj-$(CONFIG_MTK_LENS_AD5823_SUPPORT)    += mt6795/ad5823/
-						obj-$(CONFIG_MTK_LENS_AD5823AF_SUPPORT)    += mt6795/ad5823af/
-						obj-$(CONFIG_MTK_LENS_BU6424AF_SUPPORT)    += mt6795/bu6424af/
-						obj-$(CONFIG_MTK_LENS_BU6429AF_SUPPORT)    += mt6795/bu6429af/
-						obj-$(CONFIG_MTK_LENS_BU64745GWZAF_SUPPORT)+= mt6795/bu64745gwzaf/
-						obj-$(CONFIG_MTK_LENS_DW9714AF_SUPPORT)    += mt6795/dw9714af/
-						obj-$(CONFIG_MTK_LENS_DW9718AF_SUPPORT)    += mt6795/dw9718af/
-						obj-$(CONFIG_MTK_LENS_FM50AF_SUPPORT)      += mt6795/fm50af/
-						obj-$(CONFIG_MTK_LENS_MT9P017AF_SUPPORT)   += mt6795/mt9p017af/
-						obj-$(CONFIG_MTK_LENS_OV8825AF_SUPPORT)    += mt6795/ov8825af/
-						obj-$(CONFIG_MTK_LENS_SENSORDRIVE_SUPPORT) += mt6795/sensordrive/
-						obj-$(CONFIG_MTK_LENS_LC898122AF_SUPPORT) += mt6795/lc898122af/
-						obj-$(CONFIG_MTK_LENS_LC898212AF_SUPPORT)    += mt6795/lc898212af/
-						obj-$(CONFIG_MTK_LENS_AK7345AF_SUPPORT)    += mt6795/ak7345af/
-						else
-						obj-$(CONFIG_MTK_LENS_DUMMYLENS_SUPPORT)   += common/dummy_lens/
-						obj-$(CONFIG_MTK_LENS_AD5820AF_SUPPORT)    += common/ad5820af/
-						obj-$(CONFIG_MTK_LENS_AD5823_SUPPORT)    += common/ad5823/
-						obj-$(CONFIG_MTK_LENS_AD5823AF_SUPPORT)    += common/ad5823af/
-						obj-$(CONFIG_MTK_LENS_BU6424AF_SUPPORT)    += common/bu6424af/
-						obj-$(CONFIG_MTK_LENS_BU6429AF_SUPPORT)    += common/bu6429af/
-						obj-$(CONFIG_MTK_LENS_BU64745GWZAF_SUPPORT)+= common/bu64745gwzaf/
-						obj-$(CONFIG_MTK_LENS_DW9714AF_SUPPORT)    += common/dw9714af/
-						obj-$(CONFIG_MTK_LENS_DW9718AF_SUPPORT)    += common/dw9718af/
-						obj-$(CONFIG_MTK_LENS_FM50AF_SUPPORT)      += common/fm50af/
-						obj-$(CONFIG_MTK_LENS_MT9P017AF_SUPPORT)   += common/mt9p017af/
-						obj-$(CONFIG_MTK_LENS_OV8825AF_SUPPORT)    += common/ov8825af/
-						obj-$(CONFIG_MTK_LENS_SENSORDRIVE_SUPPORT) += common/sensordrive/
-						obj-$(CONFIG_MTK_LENS_LC898122AF_SUPPORT) += common/lc898122af/
-						obj-$(CONFIG_MTK_LENS_LC898212AF_SUPPORT)    += common/lc898212af/
-						obj-$(CONFIG_MTK_LENS_AK7345AF_SUPPORT)    += common/ak7345af/	                			
-						endif
-					endif
-				endif
-			endif
-		endif
-	endif
-endif
-
-
-
diff --git a/drivers/misc/mediatek/lens/mt6735/ad5823/AD5823.c~ b/drivers/misc/mediatek/lens/mt6735/ad5823/AD5823.c~
deleted file mode 100644
index 920bc56..0000000
--- a/drivers/misc/mediatek/lens/mt6735/ad5823/AD5823.c~
+++ /dev/null
@@ -1,582 +0,0 @@
-/*
- * MD218A voice coil motor driver
- *
- *
- */
-
-#include <linux/i2c.h>
-#include <linux/delay.h>
-#include <linux/platform_device.h>
-#include <linux/cdev.h>
-#include <linux/uaccess.h>
-#include <linux/fs.h>
-#include <asm/atomic.h>
-#include "AD5823.h"
-#include "../camera/kd_camera_hw.h"
-#include <linux/xlog.h>
-#ifdef CONFIG_COMPAT
-#include <linux/compat.h>
-#endif
-
-
-#define LENS_I2C_BUSNUM 0//1
-static struct i2c_board_info kd_lens_dev __initdata = { I2C_BOARD_INFO("AD5823", 0x6C) };
-
-
-#define AD5823_DRVNAME "AD5823"
-#define AD5823_VCM_WRITE_ID           0x18
-
-#define AD5823_DEBUG
-#ifdef AD5823_DEBUG
-#define AD5823DB pr_debug
-#else
-#define AD5823DB(x, ...)
-#endif
-
-static spinlock_t g_AD5823_SpinLock;
-
-static struct i2c_client *g_pstAD5823_I2Cclient;
-
-static dev_t g_AD5823_devno;
-static struct cdev *g_pAD5823_CharDrv;
-static struct class *actuator_class;
-
-static int g_s4AD5823_Opened;
-static long g_i4MotorStatus;
-static long g_i4Dir;
-static unsigned long g_u4AD5823_INF;
-static unsigned long g_u4AD5823_MACRO = 1023;
-static unsigned long g_u4TargetPosition;
-static unsigned long g_u4CurrPosition;
-
-static int mode_init = 1;
-
-static int g_sr = 3;
-
-#if 0
-extern s32 mt_set_gpio_mode(u32 u4Pin, u32 u4Mode);
-extern s32 mt_set_gpio_out(u32 u4Pin, u32 u4PinOut);
-extern s32 mt_set_gpio_dir(u32 u4Pin, u32 u4Dir);
-#endif
-
-static int s4AD5823_ReadReg(unsigned short *a_pu2Result)
-{
-
-    int  i4RetValue = 0;
-    char pBuff[2];
-    g_pstAD5823_I2Cclient->addr = 0x0C;
-    i4RetValue = i2c_master_recv(g_pstAD5823_I2Cclient, pBuff , 2);
-
-    if (i4RetValue < 0)
-    {
-	AD5823DB("[AD5823] I2C read failed!!\n");
-	return -1;
-    }
-
-    *a_pu2Result = (((u16)pBuff[0]) << 4) + (pBuff[1] >> 4);
-    
-#if 0//by zhu
-	int i4RetValue = 0;
-	char pBuff[2];
-	char VCMMSB[1] = { (char)(0x04) };
-	char VCMLSB[1] = { (char)(0x05) };
-
-	g_pstAD5823_I2Cclient->addr = 0x0C;
-
-	AD5823DB("[AD5823] s4AD5823_ReadReg\n");
-
-	/* Read MSB */
-	i4RetValue = i2c_master_send(g_pstAD5823_I2Cclient, VCMMSB, 1);
-
-	if (i4RetValue < 0) {
-		AD5823DB("[AD5823] I2C send failed!!\n");
-		return -1;
-	}
-	i4RetValue = i2c_master_recv(g_pstAD5823_I2Cclient, &pBuff[1], 1);
-
-	AD5823DB("[AD5823] s4AD5823_ReadReg VCMMSB: 0x%x\n", pBuff[1]);
-
-	/* Read LSB */
-	i4RetValue = i2c_master_send(g_pstAD5823_I2Cclient, VCMLSB, 1);
-
-	if (i4RetValue < 0) {
-		AD5823DB("[AD5823] I2C send failed!!\n");
-		return -1;
-	}
-
-
-	i4RetValue = i2c_master_recv(g_pstAD5823_I2Cclient, &pBuff[0], 1);
-	AD5823DB("[AD5823] s4AD5823_ReadReg VCMLSB: 0x%x\n", pBuff[0]);
-
-	if (i4RetValue < 0) {
-		AD5823DB("[AD5823] I2C read failed!!\n");
-		return -1;
-	}
-
-	*a_pu2Result = ((u16) pBuff[0] + (u16) (pBuff[1] << 8));
-	AD5823DB("[AD5823] s4AD5823_ReadReg *a_pu2Result: %d\n", *a_pu2Result);
-#endif
-	return 0;
-}
-
-static int s4AD5823_WriteReg(u16 a_u2Data)
-{
-
-    int  i4RetValue = 0;
-
-    char puSendCmd[2] = {(char)(a_u2Data >> 4) , (char)(((a_u2Data & 0xF) << 4)+g_sr)};
-     g_pstAD5823_I2Cclient->addr = 0x0C;
-    //AD5823DB("[AD5823] g_sr %d, write %d\n", g_sr, a_u2Data);
-    g_pstAD5823_I2Cclient->ext_flag |= I2C_A_FILTER_MSG;
-    i4RetValue = i2c_master_send(g_pstAD5823_I2Cclient, puSendCmd, 2);
-
-    if (i4RetValue < 0)
-    {
-	AD5823DB("[AD5823] I2C send failed!!\n");
-	return -1;
-    }
-    
-#if 0//by zhu
-	int i4RetValue = 0;
-
-	/* AD5823DB("[AD5823] g_sr %d, write %d\n", g_sr, a_u2Data); */
-
-	/* 0x04[1:0] VCM MSB data */
-	/* 0x05[7:0] VCM LSB data */
-	char VCMMSB[2] = { (char)(0x04), (char)((a_u2Data >> 8) & 0x03) };
-	char VCMLSB[2] = { (char)(0x05), (char)(a_u2Data & 0xFF) };
-
-	g_pstAD5823_I2Cclient->ext_flag |= I2C_A_FILTER_MSG;
-	g_pstAD5823_I2Cclient->addr = 0x0C;
-
-	i4RetValue = i2c_master_send(g_pstAD5823_I2Cclient, VCMMSB, 2);
-	i4RetValue = i2c_master_send(g_pstAD5823_I2Cclient, VCMLSB, 2);
-
-	if (i4RetValue < 0) {
-		AD5823DB("[AD5823] I2C send failed!!\n");
-		return -1;
-	}
-#endif
-	return 0;
-}
-
-inline static int getAD5823Info(__user stAD5823_MotorInfo * pstMotorInfo)
-{
-	stAD5823_MotorInfo stMotorInfo;
-	stMotorInfo.u4MacroPosition = g_u4AD5823_MACRO;
-	stMotorInfo.u4InfPosition = g_u4AD5823_INF;
-	stMotorInfo.u4CurrentPosition = g_u4CurrPosition;
-	stMotorInfo.bIsSupportSR = TRUE;
-
-	if (g_i4MotorStatus == 1) {
-		stMotorInfo.bIsMotorMoving = 1;
-	} else {
-		stMotorInfo.bIsMotorMoving = 0;
-	}
-
-	if (g_s4AD5823_Opened >= 1) {
-		stMotorInfo.bIsMotorOpen = 1;
-	} else {
-		stMotorInfo.bIsMotorOpen = 0;
-	}
-
-	if (copy_to_user(pstMotorInfo, &stMotorInfo, sizeof(stAD5823_MotorInfo))) {
-		AD5823DB("[AD5823] copy to user failed when getting motor information\n");
-	}
-
-	return 0;
-}
-
-
-static int AD5823_Mode_Init(int a)
-{
-	int i4RetValue = 0;
-	/* char puSendCmd[2] = {(char)(a_u2Data >> 4) , (char)(((a_u2Data & 0xF) << 4)+0xF)}; */
-	char Mode[2] = { (char)(0x02), (char)(0x01) };
-	char MoveTime[2] = { (char)(0x03), (char)(0x4B) };
-	char VCMMSB[2] = { (char)(0x04), (char)(0x05) };
-	char VCMLSB[2] = { (char)(0x05), (char)(0x32) };
-	AD5823DB("[AD5823] s4AD5823_mode_init :0x02\n");
-
-	g_pstAD5823_I2Cclient->addr = 0x0C;
-
-	i4RetValue = i2c_master_send(g_pstAD5823_I2Cclient, Mode, 2);
-	i4RetValue = i2c_master_send(g_pstAD5823_I2Cclient, MoveTime, 2);
-#if 1
-	i4RetValue = i2c_master_send(g_pstAD5823_I2Cclient, VCMMSB, 2);
-	i4RetValue = i2c_master_send(g_pstAD5823_I2Cclient, VCMLSB, 2);
-#endif
-	mode_init = 0;
-	return 0;
-}
-
-
-
-inline static int moveAD5823(unsigned long a_u4Position)
-{
-	int ret = 0;
-
-	if (mode_init) {
-		AD5823_Mode_Init(1);
-	}
-
-	if ((a_u4Position > g_u4AD5823_MACRO) || (a_u4Position < g_u4AD5823_INF)) {
-		AD5823DB("[AD5823] out of range\n");
-		return -EINVAL;
-	}
-
-	if (g_s4AD5823_Opened == 1) {
-		unsigned short InitPos;
-		ret = s4AD5823_ReadReg(&InitPos);
-
-		spin_lock(&g_AD5823_SpinLock);
-		if (ret == 0) {
-			AD5823DB("[AD5823] Init Pos %6d\n", InitPos);
-			g_u4CurrPosition = (unsigned long)InitPos;
-		} else {
-			g_u4CurrPosition = 0;
-		}
-		g_s4AD5823_Opened = 2;
-		spin_unlock(&g_AD5823_SpinLock);
-	}
-
-	if (g_u4CurrPosition < a_u4Position) {
-		spin_lock(&g_AD5823_SpinLock);
-		g_i4Dir = 1;
-		spin_unlock(&g_AD5823_SpinLock);
-	} else if (g_u4CurrPosition > a_u4Position) {
-		spin_lock(&g_AD5823_SpinLock);
-		g_i4Dir = -1;
-		spin_unlock(&g_AD5823_SpinLock);
-	} else {
-		return 0;
-	}
-
-	spin_lock(&g_AD5823_SpinLock);
-	g_u4TargetPosition = a_u4Position;
-	spin_unlock(&g_AD5823_SpinLock);
-
-	/* AD5823DB("[AD5823] move [curr] %d [target] %d\n", g_u4CurrPosition, g_u4TargetPosition); */
-
-	spin_lock(&g_AD5823_SpinLock);
-	g_sr = 3;
-	g_i4MotorStatus = 0;
-	spin_unlock(&g_AD5823_SpinLock);
-
-	if (s4AD5823_WriteReg((unsigned short)g_u4TargetPosition) == 0) {
-		spin_lock(&g_AD5823_SpinLock);
-		g_u4CurrPosition = (unsigned long)g_u4TargetPosition;
-		spin_unlock(&g_AD5823_SpinLock);
-	} else {
-		AD5823DB("[AD5823] set I2C failed when moving the motor\n");
-		spin_lock(&g_AD5823_SpinLock);
-		g_i4MotorStatus = -1;
-		spin_unlock(&g_AD5823_SpinLock);
-	}
-
-	return 0;
-}
-
-inline static int setAD5823Inf(unsigned long a_u4Position)
-{
-	spin_lock(&g_AD5823_SpinLock);
-	g_u4AD5823_INF = a_u4Position;
-	spin_unlock(&g_AD5823_SpinLock);
-	return 0;
-}
-
-inline static int setAD5823Macro(unsigned long a_u4Position)
-{
-	spin_lock(&g_AD5823_SpinLock);
-	g_u4AD5823_MACRO = a_u4Position;
-	spin_unlock(&g_AD5823_SpinLock);
-	return 0;
-}
-
-/* ////////////////////////////////////////////////////////////// */
-static long AD5823_Ioctl(struct file *a_pstFile, unsigned int a_u4Command, unsigned long a_u4Param)
-{
-	long i4RetValue = 0;
-
-	switch (a_u4Command) {
-	case AD5823IOC_G_MOTORINFO:
-		i4RetValue = getAD5823Info((__user stAD5823_MotorInfo *) (a_u4Param));
-		break;
-
-	case AD5823IOC_T_MOVETO:
-		i4RetValue = moveAD5823(a_u4Param);
-		break;
-
-	case AD5823IOC_T_SETINFPOS:
-		i4RetValue = setAD5823Inf(a_u4Param);
-		break;
-
-	case AD5823IOC_T_SETMACROPOS:
-		i4RetValue = setAD5823Macro(a_u4Param);
-		break;
-
-	default:
-		AD5823DB("[AD5823] No CMD\n");
-		i4RetValue = -EPERM;
-		break;
-	}
-
-	return i4RetValue;
-}
-
-/* Main jobs: */
-/* 1.check for device-specified errors, device not ready. */
-/* 2.Initialize the device if it is opened for the first time. */
-/* 3.Update f_op pointer. */
-/* 4.Fill data structures into private_data */
-/* CAM_RESET */
-static int AD5823_Open(struct inode *a_pstInode, struct file *a_pstFile)
-{
-	AD5823DB("[AD5823] AD5823_Open - Start\n");
-
-	spin_lock(&g_AD5823_SpinLock);
-
-	if (g_s4AD5823_Opened) {
-		spin_unlock(&g_AD5823_SpinLock);
-		AD5823DB("[AD5823] the device is opened\n");
-		return -EBUSY;
-	}
-
-	g_s4AD5823_Opened = 1;
-
-	spin_unlock(&g_AD5823_SpinLock);
-
-	AD5823DB("[AD5823] AD5823_Open - End\n");
-
-	return 0;
-}
-
-/* Main jobs: */
-/* 1.Deallocate anything that "open" allocated in private_data. */
-/* 2.Shut down the device on last close. */
-/* 3.Only called once on last time. */
-/* Q1 : Try release multiple times. */
-static int AD5823_Release(struct inode *a_pstInode, struct file *a_pstFile)
-{
-	AD5823DB("[AD5823] AD5823_Release - Start\n");
-
-    if (g_s4AD5823_Opened == 2)
-    {
-		g_sr = 5;
-		s4AD5823_WriteReg(200);
-		msleep(10);
-		s4AD5823_WriteReg(100);
-		msleep(10);   
-    }
-
-	if (g_s4AD5823_Opened) {
-		AD5823DB("[AD5823] feee\n");
-
-		spin_lock(&g_AD5823_SpinLock);
-		g_s4AD5823_Opened = 0;
-		spin_unlock(&g_AD5823_SpinLock);
-
-	}
-
-	AD5823DB("[AD5823] AD5823_Release - End\n");
-
-	return 0;
-}
-
-static const struct file_operations g_stAD5823_fops = {
-	.owner = THIS_MODULE,
-	.open = AD5823_Open,
-	.release = AD5823_Release,
-	.unlocked_ioctl = AD5823_Ioctl,
-#ifdef CONFIG_COMPAT
-    .compat_ioctl = AD5823_Ioctl,
-#endif
-};
-
-inline static int Register_AD5823_CharDrv(void)
-{
-	struct device *vcm_device = NULL;
-
-	AD5823DB("[AD5823] Register_AD5823_CharDrv - Start\n");
-
-	/* Allocate char driver no. */
-	if (alloc_chrdev_region(&g_AD5823_devno, 0, 1, AD5823_DRVNAME)) {
-		AD5823DB("[AD5823] Allocate device no failed\n");
-
-		return -EAGAIN;
-	}
-	/* Allocate driver */
-	g_pAD5823_CharDrv = cdev_alloc();
-
-	if (NULL == g_pAD5823_CharDrv) {
-		unregister_chrdev_region(g_AD5823_devno, 1);
-
-		AD5823DB("[AD5823] Allocate mem for kobject failed\n");
-
-		return -ENOMEM;
-	}
-	/* Attatch file operation. */
-	cdev_init(g_pAD5823_CharDrv, &g_stAD5823_fops);
-
-	g_pAD5823_CharDrv->owner = THIS_MODULE;
-
-	/* Add to system */
-	if (cdev_add(g_pAD5823_CharDrv, g_AD5823_devno, 1)) {
-		AD5823DB("[AD5823] Attatch file operation failed\n");
-
-		unregister_chrdev_region(g_AD5823_devno, 1);
-
-		return -EAGAIN;
-	}
-
-	actuator_class = class_create(THIS_MODULE, "actuatordrvAD5823");
-	if (IS_ERR(actuator_class)) {
-		int ret = PTR_ERR(actuator_class);
-		AD5823DB("Unable to create class, err = %d\n", ret);
-		return ret;
-	}
-
-	vcm_device = device_create(actuator_class, NULL, g_AD5823_devno, NULL, AD5823_DRVNAME);
-
-	if (NULL == vcm_device) {
-		return -EIO;
-	}
-
-	AD5823DB("[AD5823] Register_AD5823_CharDrv - End\n");
-	return 0;
-}
-
-inline static void Unregister_AD5823_CharDrv(void)
-{
-	AD5823DB("[AD5823] Unregister_AD5823_CharDrv - Start\n");
-
-	/* Release char driver */
-	cdev_del(g_pAD5823_CharDrv);
-
-	unregister_chrdev_region(g_AD5823_devno, 1);
-
-	device_destroy(actuator_class, g_AD5823_devno);
-
-	class_destroy(actuator_class);
-
-	AD5823DB("[AD5823] Unregister_AD5823_CharDrv - End\n");
-}
-
-/* //////////////////////////////////////////////////////////////////// */
-
-static int AD5823_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id);
-static int AD5823_i2c_remove(struct i2c_client *client);
-static const struct i2c_device_id AD5823_i2c_id[] = { {AD5823_DRVNAME, 0}, {} };
-
-struct i2c_driver AD5823_i2c_driver = {
-	.probe = AD5823_i2c_probe,
-	.remove = AD5823_i2c_remove,
-	.driver.name = AD5823_DRVNAME,
-	.id_table = AD5823_i2c_id,
-};
-
-#if 0
-static int AD5823_i2c_detect(struct i2c_client *client, int kind, struct i2c_board_info *info)
-{
-	strcpy(info->type, AD5823_DRVNAME);
-	return 0;
-}
-#endif
-static int AD5823_i2c_remove(struct i2c_client *client)
-{
-	return 0;
-}
-
-/* Kirby: add new-style driver {*/
-static int AD5823_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
-{
-	int i4RetValue = 0;
-
-	AD5823DB("[AD5823] AD5823_i2c_probe\n");
-
-	/* Kirby: add new-style driver { */
-	g_pstAD5823_I2Cclient = client;
-
-	g_pstAD5823_I2Cclient->addr = g_pstAD5823_I2Cclient->addr >> 1;
-
-	/* Register char driver */
-	i4RetValue = Register_AD5823_CharDrv();
-
-	if (i4RetValue) {
-
-		AD5823DB("[AD5823] register char device failed!\n");
-
-		return i4RetValue;
-	}
-
-	spin_lock_init(&g_AD5823_SpinLock);
-
-	AD5823DB("[AD5823] Attached!!\n");
-
-	return 0;
-}
-
-static int AD5823_probe(struct platform_device *pdev)
-{
-	return i2c_add_driver(&AD5823_i2c_driver);
-}
-
-static int AD5823_remove(struct platform_device *pdev)
-{
-	i2c_del_driver(&AD5823_i2c_driver);
-	return 0;
-}
-
-static int AD5823_suspend(struct platform_device *pdev, pm_message_t mesg)
-{
-	return 0;
-}
-
-static int AD5823_resume(struct platform_device *pdev)
-{
-	return 0;
-}
-
-/* platform structure */
-static struct platform_driver g_stAD5823_Driver = {
-	.probe = AD5823_probe,
-	.remove = AD5823_remove,
-	.suspend = AD5823_suspend,
-	.resume = AD5823_resume,
-	.driver = {
-		   .name = "lens_actuatorAD5823",
-		   .owner = THIS_MODULE,
-		   }
-};
-static struct platform_device g_stAD5823_device = {
-    .name = "lens_actuatorAD5823",
-    .id = 0,
-    .dev = {}
-};
-static int __init AD5823_i2C_init(void)
-{
-	i2c_register_board_info(LENS_I2C_BUSNUM, &kd_lens_dev, 1);
-
-  if(platform_device_register(&g_stAD5823_device)){
-    AD5823DB("failed to register AF driver\n");
-    return -ENODEV;
-  }
-
-	if (platform_driver_register(&g_stAD5823_Driver)) {
-		AD5823DB("failed to register AD5823 driver\n");
-		return -ENODEV;
-	}
-
-	return 0;
-}
-
-static void __exit AD5823_i2C_exit(void)
-{
-	platform_driver_unregister(&g_stAD5823_Driver);
-}
-module_init(AD5823_i2C_init);
-module_exit(AD5823_i2C_exit);
-
-MODULE_DESCRIPTION("AD5823 lens module driver");
-MODULE_AUTHOR("KY Chen <ky.chen@Mediatek.com>");
-MODULE_LICENSE("GPL");
diff --git a/drivers/misc/mediatek/mac_fingerprint/madev.c~ b/drivers/misc/mediatek/mac_fingerprint/madev.c~
deleted file mode 100755
index e53d5ba..0000000
--- a/drivers/misc/mediatek/mac_fingerprint/madev.c~
+++ /dev/null
@@ -1,700 +0,0 @@
-#include <asm/memory.h>
-#include <asm/uaccess.h>
-#include <asm/dma.h>
-#include <linux/ioport.h>
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/earlysuspend.h>
-#include <linux/ioctl.h>
-#include <linux/fs.h>
-#include <linux/device.h>
-#include <linux/list.h>
-#include <linux/mutex.h>
-#include <linux/slab.h>
-#include <linux/compat.h>
-#include <linux/spi/spi.h>
-#include <linux/interrupt.h>
-#include <linux/kthread.h>
-#include <linux/sched.h>
-#include <linux/time.h>
-#include "madev.h"
-#if 0
-#include <linux/delay.h>
-#include <linux/spi/spi.h>
-#include <linux/cdev.h>
-#include <linux/types.h>
-
-#include <mach/mt_pm_ldo.h>
-#include <mach/mt_spi.h>
-#include <cust_gpio_usage.h>
-#include <mach/mt_gpio.h>
-#endif
-
-
-
-
-
-#define MODE_NAME  "AFS120"
-
-#ifndef MTK
-#define MASPI_MAJOR		172	/* assigned */
-#else
-unsigned int  MASPI_MAJOR = 0;	/* assigned */
-#define MADEV_EINT_PIN     	(GPIO0| 0x80000000)
-#define MADEV_EN_PIN         (GPIO1| 0x80000000) 
-struct cdev sdev;
-#endif
-#define MASPI_MINOR		32	/* ... up to 256 */
-
-struct maspi {
-	u32 speed; // xfer??
-
-	dev_t devt;
-	spinlock_t spi_lock;
-	struct spi_device *spi;
-	struct list_head dev_entry;
-	struct class *cls;
-
-	struct spi_message msg;
-	struct spi_transfer xfer;
-	struct early_suspend	early_suspend;
-};
-static struct maspi *smas = NULL;
-static u8 *sbuf = NULL;
-
-static DECLARE_BITMAP(minors, MASPI_MINOR);
-static LIST_HEAD(dev_list);
-static DEFINE_MUTEX(dev_lock);
-
-int mas_frame(struct spi_device *spi, char *buf);
-
-/*--------------------------------- print -----------------------------------*/
-static u8 sdeb = 1; // ???1?????0???
-
-//#define DEBUG
-
-void printd(char *fmt, ...) {
-#ifdef DEBUG
-	if (sdeb == 1) {
-		va_list args;
-		va_start(args, fmt);
-		vprintk(fmt, args);
-		va_end(args);
-	}
-#endif
-}
-
-void printw(char *fmt, ...) {
-	va_list args;
-	va_start(args, fmt);
-	vprintk(fmt, args);
-	va_end(args);
-}
-
-void printn(const char *func, char *buf, int len) {
-	int i;
-
-	printd("%s: buf:\n", func);
-	for (i = 0; i < len; i++) {
-		printd("%.2x ", buf[i]);
-		if (i > 0 && (i + 1) % 30 == 0) printd("\n");
-	}
-	printd("\n");
-}
-
-
-#ifdef MTK
-void finger_en_h(void) {
-	mt_set_gpio_out(MADEV_EN_PIN, 1);
-}
-
-void finger_en_l(void) {
-	mt_set_gpio_out(MADEV_EN_PIN, 0);
-}
-
-static void mt_spi_set_mod(void) {
-	//set shutdown mode ,set pin default staus as high 
-	mt_set_gpio_mode(MADEV_EN_PIN,GPIO_MODE_00);  
-	mt_set_gpio_dir(MADEV_EN_PIN,GPIO_DIR_OUT);
-	mt_set_gpio_pull_select(MADEV_EN_PIN, GPIO_PULL_UP);
-	mt_set_gpio_pull_enable(MADEV_EN_PIN, GPIO_PULL_ENABLE);
-	mt_set_gpio_out(MADEV_EN_PIN,GPIO_OUT_ONE);
-	mdelay(10);
-
-	//set dir pull to save power
-#if 1
-	//mt_set_gpio_mode(GPIO_SPI_CS_PIN, GPIO_SPI_CS_PIN_M_GPIO);
-	mt_set_gpio_mode(GPIO_SPI_CS_PIN, GPIO_SPI_CS_PIN_M_SPI_CSA);
-	mt_set_gpio_dir(GPIO_SPI_CS_PIN, GPIO_DIR_OUT);
-	mt_set_gpio_pull_select(GPIO_SPI_CS_PIN, GPIO_PULL_UP);
-	mt_set_gpio_pull_enable(GPIO_SPI_CS_PIN, GPIO_PULL_ENABLE);
-
-	mt_set_gpio_mode(GPIO_SPI_SCK_PIN, GPIO_SPI_SCK_PIN_M_SPI_CKA);
-	mt_set_gpio_dir(GPIO_SPI_SCK_PIN, GPIO_DIR_OUT);
-	mt_set_gpio_pull_select(GPIO_SPI_SCK_PIN, GPIO_PULL_UP);
-	mt_set_gpio_pull_enable(GPIO_SPI_SCK_PIN, GPIO_PULL_ENABLE);
-
-	mt_set_gpio_mode(GPIO_SPI_MISO_PIN, GPIO_SPI_MISO_PIN_M_SPI_MIA);
-	mt_set_gpio_dir(GPIO_SPI_MISO_PIN, GPIO_DIR_IN);
-	mt_set_gpio_pull_select(GPIO_SPI_MISO_PIN, GPIO_PULL_UP);
-	mt_set_gpio_pull_enable(GPIO_SPI_MISO_PIN, GPIO_PULL_ENABLE);
-
-	mt_set_gpio_mode(GPIO_SPI_MOSI_PIN, GPIO_SPI_MOSI_PIN_M_SPI_MOA);
-	mt_set_gpio_dir(GPIO_SPI_MOSI_PIN, GPIO_DIR_OUT);
-	mt_set_gpio_pull_select(GPIO_SPI_MOSI_PIN, GPIO_PULL_UP);
-	mt_set_gpio_pull_enable(GPIO_SPI_MOSI_PIN, GPIO_PULL_ENABLE);
-	mdelay(10);
-#else
-
-	        mt_set_gpio_mode(GPIO65,GPIO_MODE_01);
-		mt_set_gpio_dir(GPIO65,GPIO_DIR_OUT);
-	        mt_set_gpio_pull_select(GPIO65, GPIO_PULL_UP);
-		mt_set_gpio_pull_enable(GPIO65,GPIO_PULL_ENABLE);
-
-		mt_set_gpio_mode(GPIO66,GPIO_MODE_01);
-		mt_set_gpio_dir(GPIO66,GPIO_DIR_OUT);
-	        mt_set_gpio_pull_select(GPIO66, GPIO_PULL_UP);
-		mt_set_gpio_pull_enable(GPIO66,GPIO_PULL_ENABLE);
-
-		mt_set_gpio_mode(GPIO67,GPIO_MODE_01);
-		mt_set_gpio_dir(GPIO67,GPIO_DIR_IN);
-	        mt_set_gpio_pull_select(GPIO67, GPIO_PULL_UP);
-		mt_set_gpio_pull_enable(GPIO67,GPIO_PULL_ENABLE);
-
-		mt_set_gpio_mode(GPIO68,GPIO_MODE_01);
-		mt_set_gpio_dir(GPIO68,GPIO_DIR_OUT);
-	        mt_set_gpio_pull_select(GPIO68, GPIO_PULL_UP);
-		mt_set_gpio_pull_enable(GPIO68,GPIO_PULL_ENABLE);
-
-		//mt_set_gpio_mode(GPIO65,GPIO_MODE_01);
-		//mt_set_gpio_mode(GPIO66,GPIO_MODE_01);
-		//mt_set_gpio_mode(GPIO67,GPIO_MODE_01);
-		//mt_set_gpio_mode(GPIO68,GPIO_MODE_01);
-	        mdelay(10);
-#endif
-	return;
-}
-#endif
-/*---------------------------------- fops ------------------------------------*/
-static int mas_open(struct inode *inode, struct file *filp) {
-	int ret = -ENXIO;
-
-	printd("%s: start\n", __func__);
-	mutex_lock(&dev_lock);
-#if  1//def MTK
-	hwPowerOn(MT6328_POWER_LDO_VGP1, VOL_3000, MODE_NAME);
-#endif
-	list_for_each_entry(smas, &dev_list, dev_entry) {
-		if (smas->devt == inode->i_rdev) {
-			ret = 0;
-			break;
-		}
-	}
-	if (!ret) {
-		nonseekable_open(inode, filp);
-	} else {
-		printw("%s: nothing for minor\n", __func__);
-	}
-	mutex_unlock(&dev_lock);
-	printd("%s: end\n", __func__);
-
-	return ret;
-}
-
-/* ????????
- * @buf ??????,
- * 		?: buf[0]???,?????
- * 		?: ??????len?????
- * @len ????len=0???len>0??
- * @????0???????
- */
-int mas_sync(struct spi_device *spi, char *buf, int len) {
-	int ret;
-
-	printd("%s: start. len=%d\n", __func__, len);
-	smas->xfer.tx_buf = buf + 1;
-	smas->xfer.rx_buf = buf;
-	smas->xfer.delay_usecs = 1;
-	smas->xfer.len = len == 0 ? buf[0] : len;
-	smas->xfer.bits_per_word = 8;
-	smas->xfer.speed_hz = smas->speed;
-	spi_message_init(&smas->msg);
-	spi_message_add_tail(&smas->xfer, &smas->msg);
-	ret = spi_sync(spi, &smas->msg);
-
-	printd("%s: end. ret=%d\n", __func__, ret);
-	return ret;
-}
-
-// 
-int mas_send(char *buf, int len) {
-	int ret = 0;
-	struct mt_chip_conf *conf = (struct mt_chip_conf *) smas->spi->controller_data;
-	conf->com_mod = FIFO_TRANSFER;
-	spi_setup(smas->spi);
-
-	ret = mas_sync(smas->spi, buf, len);
-	msleep(10);
-	return ret;
-}
-// ????
-int mas_frame(struct spi_device *spi, char *buf) {
-	int ret;
-
-	printd("%s: start.\n", __func__);
-	buf[0] = MA_READ_FRAME_REG;
-	memset(buf+1, 0xff, FBUF-1);
-	smas->xfer.tx_buf = buf;
-	smas->xfer.rx_buf = buf;
-	smas->xfer.len = FBUF;
-	smas->xfer.bits_per_word = 8;
-	smas->xfer.speed_hz = smas->speed;
-	spi_message_init(&smas->msg);
-	spi_message_add_tail(&smas->xfer, &smas->msg);
-	ret = spi_sync(spi, &smas->msg);
-	printd("%s: end. ret=%d\n", __func__, ret);
-
-	return ret;
-}
-
-static ssize_t mas_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos) {
-	int ret = 0;
-
-	printd("%s: start. count=%d\n", __func__, count);
-	if(count>FBUF) {
-		printw("%s: read data too long.\n", __func__);
-		return -EMSGSIZE;
-	}
-#ifdef MTK
-	struct mt_chip_conf *conf = (struct mt_chip_conf *) smas->spi->controller_data;
-	conf->com_mod = count==FBUF? DMA_TRANSFER: FIFO_TRANSFER;
-	spi_setup(smas->spi);
-#endif
-	if(count==FBUF) { // ????
-		ret = mas_frame(smas->spi, sbuf);
-	} else { // ?????
-		ret = mas_sync(smas->spi, sbuf, count);
-	}
-	if(ret) {
-		printw("%s: mas_sync failed.\n", __func__);
-	} else {
-		if(count) {
-			ret = copy_to_user(buf, sbuf, count);
-			if(!ret) ret = count;
-			else {
-				ret = -EFAULT;
-				printw("%s: copy_to_user failed.\n", __func__);
-			}
-		}
-	}
-	printd("%s: end. ret=%d\n", __func__, ret);
-
-	return count==0? 0: ret;
-}
-
-static ssize_t mas_write(struct file *filp, const char __user *buf,size_t count, loff_t *f_pos) {
-	int ret;
-	printd("%s: start. count=%d\n", __func__, count);
-	//printk("[spi hxq]:aaa 888\n");
-		
-		//finger_cs_l();
-/*
-
-	unsigned char pix_read[]={0x50,0x00,0x20,0x00};
-
-	unsigned char i,j;
-	
-	
-	for(i=0;i<10;i++)
-		{
-		for(j=0;j<4;j++)
-			{
-				spi_write_finger(&pix_read[i],1);
-			printk("spi_write_finger---number=[%d]\n",i);
-			}
-		}
-	*/
-	
-	if(count>FBUF) {
-		printw("%s: write data too long.\n", __func__);
-		return -EMSGSIZE;
-	}
-	memset(sbuf, 0, FBUF);
-	ret = copy_from_user(sbuf, buf, count);
-	if(ret) {
-		printw("%s: copy_from_user failed.\n", __func__);
-		ret = -EFAULT;
-	} else {
-		ret = count;
-	}
-	printd("%s: end. ret =%d\n", __func__, ret);
-
-	return ret;
-}
-
-static long mas_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) {
-	int ret = 0;
-
-	printd("%s: start cmd=%d arg=%d\n", __func__, cmd, arg);
-	switch (cmd) {
-	case DRV_DEBUG:
-		sdeb = (u8) arg;
-		break;
-	case DRV_SPI_SPEED:
-		smas->speed = (u32)arg;
-		break;
-	case DRV_FBUF:
-		ret = FBUF;
-		break;
-	case DRV_AUTOTEST_FBUF:
-	{
-		int i;
-		const unsigned char cdat[] = { 0x41, 0x78, 0x4d, 0x41 };
-		sbuf[0] = 3;
-		sbuf[1] = 0x8c;
-		sbuf[2] = 0xff;
-		sbuf[3] = 0xff;
-		if( mas_send(sbuf, 0) ) return 0;
-		for(i=0; i<4; i++) {
-			sbuf[0] = 4;
-			sbuf[1] = i*4;
-			sbuf[2] = cdat[i];
-			sbuf[3] = 0xff;
-			sbuf[4] = 0xff;
-			if( mas_send(sbuf, 0)) return 0;
-			if(sbuf[2]!=cdat[i]) return 0;
-		}
-		ret = 1;
-		break;
-	}
-	}
-	printd("%s: end\n", __func__);
-
-	return ret;
-}
-
-static int mas_release(struct inode *inode, struct file *filp) {
-	int ret = 0;
-
-	printd("%s: start\n", __func__);
-#if  0//def MTK
-	if (hwPowerDown(MT6323_POWER_LDO_VGP1, MODE_NAME)!=1) {
-		printw("%s: Fail to disable analog power\n", __func__);
-	}
-#endif
-	printd("%s: end\n", __func__);
-
-	return ret;
-}
-
-static const struct file_operations mas_fops = {
-	.owner = THIS_MODULE,
-	.write = mas_write,
-	.read = mas_read,
-	.unlocked_ioctl = mas_ioctl,
-	.open = mas_open,
-	.release = mas_release,
-};
-
-static int mas_probe(struct spi_device *spi) {
-	int ret;
-	unsigned long minor;
-
-	printd("%s: start\n", __func__);
-	//smas->speed = 10*000000;
-	smas->spi = spi;
-	spi->max_speed_hz = smas->speed;
-	spi_setup(spi);
-	spin_lock_init(&smas->spi_lock);
-	INIT_LIST_HEAD(&smas->dev_entry);
-	mutex_lock(&dev_lock);
-	minor = find_first_zero_bit(minors, MASPI_MINOR);
-	if (minor < MASPI_MINOR) {
-		struct device *dev;
-		smas->devt = MKDEV(MASPI_MAJOR, minor);
-		dev = device_create(smas->cls, &spi->dev, smas->devt, smas, "madev0");
-		ret = IS_ERR(dev) ? PTR_ERR(dev) : 0;
-		if (ret == 0) {
-			set_bit(minor, minors);
-			list_add(&smas->dev_entry, &dev_list);
-		}
-	} else {
-		printw("%s: no minor number available!\n", __func__);
-		ret = -ENODEV;
-		goto fail;
-	}
-	mutex_unlock(&dev_lock);
-	spi_set_drvdata(spi, smas);
-	printw("%s: insmod successfully.\n", __func__);
-	return ret;
-fail:
-	printw("%s: insmod failed.\n", __func__);
-
-	return ret;
-}
-
-static int mas_remove(struct spi_device *spi) {
-	printd("%s: start\n", __func__);
-	// make sure ops on existing fds can abort cleanly
-	spin_lock_irq(&smas->spi_lock);
-	smas->spi = NULL;
-	spi_set_drvdata(spi, NULL);
-	spin_unlock_irq(&smas->spi_lock);
-
-	// prevent new opens
-	mutex_lock(&dev_lock);
-	list_del(&smas->dev_entry);
-	device_destroy(smas->cls, smas->devt);
-	clear_bit(MINOR(smas->devt), minors);
-	mutex_unlock(&dev_lock);
-	printd("%s: end\n", __func__);
-
-	return 0;
-}
-
-#ifndef MTK
-static struct spi_driver mas_driver = {
-	.driver = {
-		.name = "ma_dev",
-		.owner = THIS_MODULE,
-	},
-	.probe = mas_probe,
-	.remove = __devexit_p(mas_remove),
-};
-#else
-
-#ifdef CONFIG_HAS_EARLYSUSPEND
-//static void mas_ts_suspend(struct device *dev, pm_message_t message)
-static void mas_ts_suspend(struct early_suspend *handler)
-{
-//	struct spi_driver *drv = to_spi_driver(dev->driver);
-
-	printd("%s: start\n", __func__);
-
-/*	sbuf[0] = 3;
-	sbuf[1] = 0x80;
-	sbuf[2] = 0xff;
-	sbuf[3] = 0xff;
-	mas_send(sbuf, 0);
-	*/
-	mdelay(10);
-	finger_en_l();
-
-	/* suspend will stop irqs and dma; no more i/o */
-		/* DMA */
-/*	if (drv) {
-
-		if (drv->suspend) {
-			drv->suspend(to_spi_device(dev), message);
-		} else {
-			printw("%s: can't suspend\n", __func__);
-		}
-	}
-	*/
-}
-
-//static void mas_ts_resume(struct device *dev) 
-static void mas_ts_resume(struct early_suspend *handler) 
-{
-	//struct spi_driver *drv = to_spi_driver(dev->driver);
-
-	printd("%s: start\n", __func__);
-	finger_en_h();
-	mdelay(10);	
-	/* resume may restart the i/o queue */
-	/*  */
-	/*if (drv) {
-		if (drv->resume) {
-			drv->resume(to_spi_device(dev));
-		} else {
-			printw("%s: can't resume\n", __func__);
-		}
-	}*/
-	/*
-	sbuf[0] = 3;
-	sbuf[1] = 0x8c;
-	sbuf[2] = 0xff;
-	sbuf[3] = 0xff;
-	mas_send(sbuf, 0);
-	*/
-}
-#endif
-
-struct spi_device_id device_id = {"ma_dev", 0};
-#if 0
-static struct spi_driver mas_driver = {
-	.driver = {
-		.name =	"ma_dev",
-		.owner = THIS_MODULE,
-	},
-	.probe = mas_probe,
-#if  0//def CONFIG_HAS_EARLYSUSPEND
-	.suspend = mas_ts_suspend,
-	.resume	= mas_ts_resume,
-#endif
-	.remove = __devexit_p(mas_remove),
-	.id_table = &device_id,
-};
-#endif
-#ifdef CONFIG_OF
-static const struct of_device_id mas_of_match[] = {
-	{ .compatible = "mediatek,ma_dev", },
-	{},
-};
-#endif
-static struct spi_driver mas_driver = {
-	.driver = {
-		.name =	"ma_dev",
-		#ifdef CONFIG_OF
-		.of_match_table = mas_of_match,
-		#endif
-		.owner = THIS_MODULE,
-	},
-	.probe = mas_probe,
-	.remove = mas_remove,
-	.id_table = &device_id,
-};
-
-static struct mt_chip_conf mt_conf = {
-	.setuptime = 1,
-	.holdtime = 1,
-	.high_time = 4, // 10--6m 15--4m 20--3m 30--2m [ 60--1m 120--0.5m  300--0.2m]
-	.low_time = 4,
-	.cs_idletime = 2,
-	.ulthgh_thrsh = 0,
-	.cpol = 0,
-	.cpha = 0,
-	.rx_mlsb = SPI_MSB,
-	.tx_mlsb = SPI_MSB,
-	.tx_endian = 0,
-	.rx_endian = 0,
-	.com_mod = DMA_TRANSFER,
-	.pause = 0,
-	.finish_intr = 1,
-	.deassert = 0,
-	.ulthigh = 0,
-	.tckdly = 0,
-};
-static struct spi_board_info sfp_spi1_board_info[] __initdata = {
-	{
-		.modalias = "ma_dev",
-		//.max_speed_hz = 16 * 1000000,
-		.bus_num = 0,
-		.chip_select = 1,
-		.mode = SPI_MODE_0,
-		.controller_data=&mt_conf
-	}
-};
-
-#endif
-
-/*---------------------------------- module ------------------------------------*/
-static int __init mas_init(void) {
-	int status;
-	int ret;
-	dev_t devno;
-	printk("%s: start\n", __func__);
-	mt_spi_set_mod();
-
-	smas = kmalloc(sizeof(struct maspi), GFP_KERNEL);
-	hwPowerOn(MT6328_POWER_LDO_VGP1, VOL_3000, MODE_NAME);
-	if (!smas) {
-		printw("%s: smas kzalloc failed.\n", __func__);
-		return -ENOMEM;
-	}
-
-	smas->xfer.speed_hz = 10*1000*1000;
-	if(KMALLOC_MAX_SIZE<FBUF) {
-		printw("%s: KMALLOC_MAX_SIZE too small.\n", __func__);
-	}
-
-	sbuf = kmalloc(FBUF, GFP_KERNEL);
-
-	if(!sbuf) {
-		printw("%s: sbuf kmalloc failed.\n", __func__);
-		kfree(smas);
-		smas = NULL;
-		return -ENOMEM;
-	}
-
-#ifdef MTK
-	{
-		
-		spi_register_board_info(sfp_spi1_board_info, ARRAY_SIZE(sfp_spi1_board_info));
-
-		status = alloc_chrdev_region(&devno, 0, 255, "maspidev");
-		if(status < 0) {
-			printw("%s: alloc_chrdev_region failed.ret=%d\n", __func__, ret);
-			return status;
-		}
-
-		MASPI_MAJOR = MAJOR(devno);
-		cdev_init(&sdev, &mas_fops);
-	    sdev.owner = THIS_MODULE;
-		status = cdev_add(&sdev, MKDEV(MASPI_MAJOR, 0), MASPI_MINOR);
-
-		if(status != 0) {
-			printw("%s: cdev_add failed. ret=%d\n", __func__, ret);
-			return status;
-		}
-	}
-
-#ifdef CONFIG_HAS_EARLYSUSPEND
-	//device_init_wakeup(&sdev, 1);
-	//smas->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
-	smas->early_suspend.level = EARLY_SUSPEND_LEVEL_DISABLE_FB + 1;
-	smas->early_suspend.suspend = mas_ts_suspend;
-	smas->early_suspend.resume	= mas_ts_resume;
-	register_early_suspend(&smas->early_suspend);
-#endif
-#else
-	BUILD_BUG_ON(MASPI_MINOR > 256);
-	ret = register_chrdev(MASPI_MAJOR, "madev", &mas_fops);
-	if (ret < 0) {
-		printw("%s: register_chrdev failed.\n", __func__);
-		return ret;
-	}
-#endif
-
-	smas->cls = class_create(THIS_MODULE, "madev");
-	if (IS_ERR(smas->cls)) {
-		printw("%s: class_create failed.\n", __func__);
-		unregister_chrdev(MASPI_MAJOR, mas_driver.driver.name);
-		return PTR_ERR(smas->cls);
-	}
-
-	ret = spi_register_driver(&mas_driver);
-	if (ret < 0) {
-		printw("%s: spi_register_driver failed.\n", __func__);
-		class_destroy(smas->cls);
-		unregister_chrdev(MASPI_MAJOR, mas_driver.driver.name);
-	}
-
-	printd("%s: end\n", __func__);
-	return ret;
-}
-
-
-static void __exit mas_exit(void) {
-	printd("%s: start\n", __func__);
-
-	spi_unregister_driver(&mas_driver);
-	class_destroy(smas->cls);
-	unregister_chrdev(MASPI_MAJOR, mas_driver.driver.name);
-#ifdef CONFIG_HAS_EARLYSUSPEND
-	//device_init_wakeup(&sdev, 0);
-	unregister_early_suspend(&smas->early_suspend);
-#endif
-	if(smas!=NULL) kfree(smas);
-	if(sbuf!=NULL) kfree(sbuf);
-
-	printd("%s: end\n", __func__);
-}
-
-module_init(mas_init);
-module_exit(mas_exit);
-
-MODULE_AUTHOR("zlchen");
-MODULE_DESCRIPTION("for fprint driver");
-MODULE_LICENSE("GPL");
-
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/accelerometer/KXTJ2_1009-new/Makefile~ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/accelerometer/KXTJ2_1009-new/Makefile~
deleted file mode 100755
index c2ff2dc..0000000
--- a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/accelerometer/KXTJ2_1009-new/Makefile~
+++ /dev/null
@@ -1,4 +0,0 @@
-include $(srctree)/drivers/misc/mediatek/Makefile.custom
-
-obj-y	:=  kxtj2_1009_cust_acc.o
-
diff --git a/drivers/misc/mediatek/mach/mt6735/benefit_m7/accelerometer/KXTJ2_1009-new/Makefile~ b/drivers/misc/mediatek/mach/mt6735/benefit_m7/accelerometer/KXTJ2_1009-new/Makefile~
deleted file mode 100755
index c2ff2dc..0000000
--- a/drivers/misc/mediatek/mach/mt6735/benefit_m7/accelerometer/KXTJ2_1009-new/Makefile~
+++ /dev/null
@@ -1,4 +0,0 @@
-include $(srctree)/drivers/misc/mediatek/Makefile.custom
-
-obj-y	:=  kxtj2_1009_cust_acc.o
-
diff --git a/drivers/misc/mediatek/mach/mt6735/benefit_m7/accelerometer/KXTJ2_1009_auto/Makefile~ b/drivers/misc/mediatek/mach/mt6735/benefit_m7/accelerometer/KXTJ2_1009_auto/Makefile~
deleted file mode 100755
index 426c46e..0000000
--- a/drivers/misc/mediatek/mach/mt6735/benefit_m7/accelerometer/KXTJ2_1009_auto/Makefile~
+++ /dev/null
@@ -1,4 +0,0 @@
-include $(srctree)/drivers/misc/mediatek/Makefile.custom
-
-obj-y	:=  mc3xxx_cust_acc.o
-
diff --git a/drivers/misc/mediatek/mach/mt6735/benefit_m7/accelerometer/mc3xxx_auto/Makefile~ b/drivers/misc/mediatek/mach/mt6735/benefit_m7/accelerometer/mc3xxx_auto/Makefile~
deleted file mode 100755
index 426c46e..0000000
--- a/drivers/misc/mediatek/mach/mt6735/benefit_m7/accelerometer/mc3xxx_auto/Makefile~
+++ /dev/null
@@ -1,4 +0,0 @@
-include $(srctree)/drivers/misc/mediatek/Makefile.custom
-
-obj-y	:=  mc3xxx_cust_acc.o
-
diff --git a/drivers/misc/mediatek/mach/mt6735/benefit_m7/camera/camera/kd_camera_hw.c~ b/drivers/misc/mediatek/mach/mt6735/benefit_m7/camera/camera/kd_camera_hw.c~
deleted file mode 100755
index d590e1b..0000000
--- a/drivers/misc/mediatek/mach/mt6735/benefit_m7/camera/camera/kd_camera_hw.c~
+++ /dev/null
@@ -1,1089 +0,0 @@
-#include <linux/videodev2.h>
-#include <linux/i2c.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/cdev.h>
-#include <linux/uaccess.h>
-#include <linux/fs.h>
-#include <asm/atomic.h>
-#include <linux/xlog.h>
-
-#include "kd_camera_hw.h"
-
-#include "kd_imgsensor.h"
-#include "kd_imgsensor_define.h"
-#include "kd_camera_feature.h"
-
-/******************************************************************************
- * Debug configuration
-******************************************************************************/
-#define PFX "[kd_camera_hw]"
-#define PK_DBG_NONE(fmt, arg...)    do {} while (0)
-#define PK_DBG_FUNC(fmt, args...)    pr_debug(PFX  fmt, ##args)
-
-#define DEBUG_CAMERA_HW_K
-#ifdef DEBUG_CAMERA_HW_K
-#define PK_DBG PK_DBG_FUNC
-#define PK_ERR(fmt, arg...)   pr_err(fmt, ##arg)
-#define PK_XLOG_INFO(fmt, args...) \
-                do {    \
-                   pr_debug(PFX  fmt, ##args); \
-                } while(0)
-#else
-#define PK_DBG(a,...)
-#define PK_ERR(a,...)
-#define PK_XLOG_INFO(fmt, args...)
-#endif
-
-/*
-#ifndef BOOL
-typedef unsigned char BOOL;
-#endif
-*/
-
-/* Mark: need to verify whether ISP_MCLK1_EN is required in here //Jessy @2014/06/04*/
-extern void ISP_MCLK1_EN(BOOL En);
-
-int cntVCAMD =0;
-int cntVCAMA =0;
-int cntVCAMIO =0;
-int cntVCAMAF =0;
-int cntVCAMD_SUB =0;
-
-static DEFINE_SPINLOCK(kdsensor_pw_cnt_lock);
-
-
-bool _hwPowerOn(MT65XX_POWER powerId, int powerVolt, char *mode_name){
-
-	if( hwPowerOn( powerId,  powerVolt, mode_name))
-	{
-	    spin_lock(&kdsensor_pw_cnt_lock);
-		if(powerId==CAMERA_POWER_VCAM_D)
-			cntVCAMD+= 1;
-		else if(powerId==CAMERA_POWER_VCAM_A)
-			cntVCAMA+= 1;
-		else if(powerId==CAMERA_POWER_VCAM_IO)
-			cntVCAMIO+= 1;
-		else if(powerId==CAMERA_POWER_VCAM_AF)
-			cntVCAMAF+= 1;
-		else if(powerId==SUB_CAMERA_POWER_VCAM_D)
-			cntVCAMD_SUB+= 1;
-		spin_unlock(&kdsensor_pw_cnt_lock);
-		return true;
-	}
-	return false;
-}
-
-bool _hwPowerDown(MT65XX_POWER powerId, char *mode_name){
-
-	if( hwPowerDown( powerId, mode_name))
-	{
-	    spin_lock(&kdsensor_pw_cnt_lock);
-		if(powerId==CAMERA_POWER_VCAM_D)
-			cntVCAMD-= 1;
-		else if(powerId==CAMERA_POWER_VCAM_A)
-			cntVCAMA-= 1;
-		else if(powerId==CAMERA_POWER_VCAM_IO)
-			cntVCAMIO-= 1;
-		else if(powerId==CAMERA_POWER_VCAM_AF)
-			cntVCAMAF-= 1;
-		else if(powerId==SUB_CAMERA_POWER_VCAM_D)
-			cntVCAMD_SUB-= 1;
-		spin_unlock(&kdsensor_pw_cnt_lock);
-		return true;
-	}
-	return false;
-}
-
-void checkPowerBeforClose( char* mode_name)
-{
-
-	int i= 0;
-
-	PK_DBG("[checkPowerBeforClose]cntVCAMD:%d, cntVCAMA:%d,cntVCAMIO:%d, cntVCAMAF:%d, cntVCAMD_SUB:%d,\n",
-		cntVCAMD, cntVCAMA,cntVCAMIO,cntVCAMAF,cntVCAMD_SUB);
-
-
-	for(i=0;i<cntVCAMD;i++)
-		hwPowerDown(CAMERA_POWER_VCAM_D,mode_name);
-	for(i=0;i<cntVCAMA;i++)
-		hwPowerDown(CAMERA_POWER_VCAM_A,mode_name);
-	for(i=0;i<cntVCAMIO;i++)
-		hwPowerDown(CAMERA_POWER_VCAM_IO,mode_name);
-	for(i=0;i<cntVCAMAF;i++)
-		hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name);
-	for(i=0;i<cntVCAMD_SUB;i++)
-		hwPowerDown(SUB_CAMERA_POWER_VCAM_D,mode_name);
-
-	 cntVCAMD =0;
-	 cntVCAMA =0;
-	 cntVCAMIO =0;
-	 cntVCAMAF =0;
-	 cntVCAMD_SUB =0;
-
-}
-
-
-
-int kdCISModulePowerOn(CAMERA_DUAL_CAMERA_SENSOR_ENUM SensorIdx, char *currSensorName, BOOL On, char* mode_name)
-{
-
-u32 pinSetIdx = 0;//default main sensor
-
-#define IDX_PS_CMRST 0
-#define IDX_PS_CMPDN 4
-#define IDX_PS_MODE 1
-#define IDX_PS_ON   2
-#define IDX_PS_OFF  3
-
-
-u32 pinSet[3][8] = {
-                        //for main sensor
-                     {  CAMERA_CMRST_PIN, // The reset pin of main sensor uses GPIO10 of mt6306, please call mt6306 API to set
-                        CAMERA_CMRST_PIN_M_GPIO,   /* mode */
-                        GPIO_OUT_ONE,              /* ON state */
-                        GPIO_OUT_ZERO,             /* OFF state */
-                        CAMERA_CMPDN_PIN,
-                        CAMERA_CMPDN_PIN_M_GPIO,
-                        GPIO_OUT_ONE,
-                        GPIO_OUT_ZERO,
-                     },
-                     //for sub sensor
-                     {  CAMERA_CMRST_PIN,
-                        CAMERA_CMRST_PIN_M_GPIO,
-                        GPIO_OUT_ONE,
-                        GPIO_OUT_ZERO,
-                        CAMERA_CMPDN1_PIN,
-                        CAMERA_CMPDN1_PIN_M_GPIO,
-                        GPIO_OUT_ONE,
-                        GPIO_OUT_ZERO,
-                     },
-                     //for main_2 sensor
-                     {  GPIO_CAMERA_INVALID,
-                        GPIO_CAMERA_INVALID,   /* mode */
-                        GPIO_OUT_ONE,               /* ON state */
-                        GPIO_OUT_ZERO,              /* OFF state */
-                        GPIO_CAMERA_INVALID,
-                        GPIO_CAMERA_INVALID,
-                        GPIO_OUT_ONE,
-                        GPIO_OUT_ZERO,
-                     }
-                   };
-
-
-
-    if (DUAL_CAMERA_MAIN_SENSOR == SensorIdx){
-        pinSetIdx = 0;
-    }
-    else if (DUAL_CAMERA_SUB_SENSOR == SensorIdx) {
-        pinSetIdx = 1;
-    }
-    else if (DUAL_CAMERA_MAIN_2_SENSOR == SensorIdx) {
-        pinSetIdx = 2;
-    }
-
-
-    //power ON
-    if (On) {
-
-            ISP_MCLK1_EN(1);
-
-        PK_DBG("[PowerON]pinSetIdx:%d, currSensorName: %s\n", pinSetIdx, currSensorName);
-
-        if ((currSensorName && (0 == strcmp(currSensorName,"imx135mipiraw")))||
-            (currSensorName && (0 == strcmp(currSensorName,"imx220mipiraw"))))
-        {
-            //First Power Pin low and Reset Pin Low
-            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
-                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
-                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
-                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
-            }
-
-
-            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
-                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
-                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
-                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
-            }
-
-            //AF_VCC
-            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
-            {
-                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-            mdelay(1);
-
-            //VCAM_A
-            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
-            {
-                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-            mdelay(1);
-
-            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1000,mode_name))
-            {
-                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", CAMERA_POWER_VCAM_D);
-                 goto _kdCISModulePowerOn_exit_;
-            }
-
-            mdelay(1);
-
-            //VCAM_IO
-            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
-            {
-                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-            mdelay(2);
-
-
-            //enable active sensor
-            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
-                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
-                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
-                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
-            }
-
-            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
-                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
-            }
-
-        }
-        else if (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV5648_MIPI_RAW, currSensorName)) && (pinSetIdx == 0))
-        {
-           // mt_set_gpio_mode(GPIO_SPI_MOSI_PIN,GPIO_MODE_00);
-           // mt_set_gpio_dir(GPIO_SPI_MOSI_PIN,GPIO_DIR_OUT);
-           // mt_set_gpio_out(GPIO_SPI_MOSI_PIN,GPIO_OUT_ONE);
-            //First Power Pin low and Reset Pin Low
-            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
-                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
-                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
-                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
-            }
-			mdelay(2);
-            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
-                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
-                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
-                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
-			mdelay(2);
-            }
-
-	     //VCAM_A
-            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
-            {
-                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-            mdelay(2);
-            //VCAM_IO
-            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
-            {
-                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-            mdelay(2);
-
-            if(TRUE != _hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1500,mode_name))
-            {
-                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", SUB_CAMERA_POWER_VCAM_D);
-                 goto _kdCISModulePowerOn_exit_;
-            }
-
-            mdelay(5);
-
-            //AF_VCC
-            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
-            {
-                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-
-            mdelay(1);
-
-
-           if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST])
-		{
-			if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");}
-			mdelay(5);
-	
-			//RST pin
-			if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");}
-			mdelay(5);
-		}
-		mdelay(50);
-
-	#if 1
-	        //disable inactive sensor
-	        //jeff modify for Q26 V1.1   
-	        //cause Main and Sub Cameras use the same RST pin.
-	        //so remove this part's CMRST.
-	       //disable sub
-	        if (GPIO_CAMERA_INVALID != pinSet[1][IDX_PS_CMRST]) {
-	  //          if(mt_set_gpio_mode(pinSet[1][IDX_PS_CMRST],pinSet[1][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! \n");}
-	            if(mt_set_gpio_mode(pinSet[1][IDX_PS_CMPDN],pinSet[1][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! \n");}
-	  //          if(mt_set_gpio_dir(pinSet[1][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! \n");}
-	            if(mt_set_gpio_dir(pinSet[1][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! \n");}
-	  //          if(mt_set_gpio_out(pinSet[1][IDX_PS_CMRST],pinSet[1][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");} //low == reset sensor
-	            if(mt_set_gpio_out(pinSet[1][IDX_PS_CMPDN],pinSet[1][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");} //high == power down lens module
-	        }
-	#endif
-        }
-
-/////////////////////////////////////////////////
-	else if (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV8858_MIPI_RAW, currSensorName)) && (pinSetIdx == 0))
-        {
-          //  mt_set_gpio_mode(GPIO_SPI_MOSI_PIN,GPIO_MODE_00);
-          //  mt_set_gpio_dir(GPIO_SPI_MOSI_PIN,GPIO_DIR_OUT);
-          //  mt_set_gpio_out(GPIO_SPI_MOSI_PIN,GPIO_OUT_ONE);
-            //First Power Pin low and Reset Pin Low
-            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
-                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
-                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
-                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
-            }
-			mdelay(2);
-            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
-                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
-                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
-                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
-			mdelay(2);
-            }
-
-	   //VCAM_A
-            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
-            {
-                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-            mdelay(2);
-            //VCAM_IO
-            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
-            {
-                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-            mdelay(2);
-
-            if(TRUE != _hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1200,mode_name))
-            {
-                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", SUB_CAMERA_POWER_VCAM_D);
-                 goto _kdCISModulePowerOn_exit_;
-            }
-
-            mdelay(5);
-
-            //AF_VCC
-            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
-            {
-                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-
-            mdelay(2);
-
-
-            //PDN/STBY pin
-		if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST])
-		{
-			if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");}
-			mdelay(5);
-	
-			//RST pin
-			if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");}
-			mdelay(5);
-		}
-		mdelay(50);
-
-	#if 1
-	        //disable inactive sensor
-	        //jeff modify for Q26 V1.1   
-	        //cause Main and Sub Cameras use the same RST pin.
-	        //so remove this part's CMRST.
-	       //disable sub
-	        if (GPIO_CAMERA_INVALID != pinSet[1][IDX_PS_CMRST]) {
-	  //          if(mt_set_gpio_mode(pinSet[1][IDX_PS_CMRST],pinSet[1][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! \n");}
-	            if(mt_set_gpio_mode(pinSet[1][IDX_PS_CMPDN],pinSet[1][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! \n");}
-	  //          if(mt_set_gpio_dir(pinSet[1][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! \n");}
-	            if(mt_set_gpio_dir(pinSet[1][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! \n");}
-	  //          if(mt_set_gpio_out(pinSet[1][IDX_PS_CMRST],pinSet[1][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");} //low == reset sensor
-	            if(mt_set_gpio_out(pinSet[1][IDX_PS_CMPDN],pinSet[1][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");} //high == power down lens module
-	        }
-	#endif
-        }
-       else if (currSensorName && (0 == strcmp(SENSOR_DRVNAME_IMX219_MIPI_RAW, currSensorName)) && (pinSetIdx == 0))
-        {
-          //  mt_set_gpio_mode(GPIO_SPI_MOSI_PIN,GPIO_MODE_00);
-          //  mt_set_gpio_dir(GPIO_SPI_MOSI_PIN,GPIO_DIR_OUT);
-          //  mt_set_gpio_out(GPIO_SPI_MOSI_PIN,GPIO_OUT_ONE);
-            //First Power Pin low and Reset Pin Low
-            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
-                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
-                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
-                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
-            }
-			mdelay(2);
-            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
-                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
-                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
-                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
-			mdelay(2);
-            }
-
-	   //VCAM_A
-            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
-            {
-                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-            mdelay(2);
-            //VCAM_IO
-            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
-            {
-                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-            mdelay(2);
-
-            if(TRUE != _hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1200,mode_name))
-            {
-                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", SUB_CAMERA_POWER_VCAM_D);
-                 goto _kdCISModulePowerOn_exit_;
-            }
-
-            mdelay(5);
-
-            //AF_VCC
-            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
-            {
-                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-
-            mdelay(2);
-
-
-            //PDN/STBY pin
-		if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST])
-		{
-			if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");}
-			mdelay(5);
-	
-			//RST pin
-			if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");}
-			mdelay(5);
-		}
-		mdelay(50);
-
-	#if 1
-	        //disable inactive sensor
-	        //jeff modify for Q26 V1.1   
-	        //cause Main and Sub Cameras use the same RST pin.
-	        //so remove this part's CMRST.
-	       //disable sub
-	        if (GPIO_CAMERA_INVALID != pinSet[1][IDX_PS_CMRST]) {
-	  //          if(mt_set_gpio_mode(pinSet[1][IDX_PS_CMRST],pinSet[1][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! \n");}
-	            if(mt_set_gpio_mode(pinSet[1][IDX_PS_CMPDN],pinSet[1][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! \n");}
-	  //          if(mt_set_gpio_dir(pinSet[1][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! \n");}
-	            if(mt_set_gpio_dir(pinSet[1][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! \n");}
-	  //          if(mt_set_gpio_out(pinSet[1][IDX_PS_CMRST],pinSet[1][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");} //low == reset sensor
-	            if(mt_set_gpio_out(pinSet[1][IDX_PS_CMPDN],pinSet[1][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");} //high == power down lens module
-	        }
-	#endif
-        }
-     else if (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV2680_MIPI_RAW, currSensorName)) && (pinSetIdx == 1))
-        {
-          //  mt_set_gpio_mode(GPIO_SPI_MOSI_PIN,GPIO_MODE_00);
-          //  mt_set_gpio_dir(GPIO_SPI_MOSI_PIN,GPIO_DIR_OUT);
-          //  mt_set_gpio_out(GPIO_SPI_MOSI_PIN,GPIO_OUT_ONE);
-            //First Power Pin low and Reset Pin Low
-           if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
-	            if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! \n");}
-	            if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! \n");}
-	            if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");}
-	            mdelay(10);
-
-	            //PDN pin
-	            if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! \n");}
-	            if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! \n");}
-	            if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");}
-	        }
-	//VCAM_IO
-            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
-            {
-                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-            mdelay(10);
-	   //VCAM_A
-            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
-            {
-                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-            mdelay(10);
-            
-
-            if(TRUE != _hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1500,mode_name))
-            {
-                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", SUB_CAMERA_POWER_VCAM_D);
-                 goto _kdCISModulePowerOn_exit_;
-            }
-
-            mdelay(10);
-
-            //AF_VCC
-            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
-            {
-                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-
-            mdelay(10);
-
-
-            #if 1
-	        //enable active sensor
-	        if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
-	            //PDN pin
-	            if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! \n");}
-	            if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! \n");}
-	            if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");}
-
-				
-	        //    if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! \n");}
-	        //    if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! \n");}
-	        //    if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");}
-	        //    mdelay(1);
-
-	        }
-#endif
-	#if 1
-	        //disable inactive sensor
-	        //jeff modify for Q26 V1.1   
-	        //cause Main and Sub Cameras use the same RST pin.
-	        //so remove this part's CMRST.
-	        if (GPIO_CAMERA_INVALID != pinSet[0][IDX_PS_CMRST]) {
-	  //          if(mt_set_gpio_mode(pinSet[0][IDX_PS_CMRST],pinSet[0][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! \n");}
-	            if(mt_set_gpio_mode(pinSet[0][IDX_PS_CMPDN],pinSet[0][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! \n");}
-	  //          if(mt_set_gpio_dir(pinSet[0][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! \n");}
-	            if(mt_set_gpio_dir(pinSet[0][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! \n");}
-	  //          if(mt_set_gpio_out(pinSet[0][IDX_PS_CMRST],pinSet[0][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");} //low == reset sensor
-	            if(mt_set_gpio_out(pinSet[0][IDX_PS_CMPDN],pinSet[0][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");} //high == power down lens module
-	        }
-	#endif
-        }
-///////////////////////////////////////////
-
-        else  if (currSensorName && (0 == strcmp(SENSOR_DRVNAME_GC2355_MIPI_RAW, currSensorName)))
-        {
-           // mt_set_gpio_mode(GPIO_SPI_MOSI_PIN,GPIO_MODE_00);
-          //  mt_set_gpio_dir(GPIO_SPI_MOSI_PIN,GPIO_DIR_OUT);
-           // mt_set_gpio_out(GPIO_SPI_MOSI_PIN,GPIO_OUT_ONE);
-            //First Power Pin low and Reset Pin Low
-            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
-                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
-                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
-                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
-            }
-
-            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
-                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
-                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
-                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
-            }
-
-            mdelay(50);
-
-            //VCAM_A
-            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
-            {
-                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-            mdelay(10);
-
-            //VCAM_IO
-            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
-            {
-                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-            mdelay(10);
-
-            if(TRUE != _hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1500,mode_name))
-            {
-                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", SUB_CAMERA_POWER_VCAM_D);
-                 goto _kdCISModulePowerOn_exit_;
-            }
-
-            mdelay(10);
-
-            //AF_VCC
-            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
-            {
-                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-
-            mdelay(50);
-
-            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
-                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
-                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
-                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
-                mdelay(5);
-                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
-
-            }
-            mdelay(5);
-            //enable active sensor
-            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
-                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
-                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
-                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
-                mdelay(5);
-                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
-            }
-
-            mdelay(5);
-        }
-        else
-        {
-            //First Power Pin low and Reset Pin Low
-            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
-                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
-                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
-                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
-            }
-
-            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
-                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
-                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
-                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
-            }
-
-            //VCAM_IO
-            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
-            {
-                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-            //VCAM_A
-            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
-            {
-                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
-                goto _kdCISModulePowerOn_exit_;
-            }
-            //VCAM_D
-            if(currSensorName && (0 == strcmp(SENSOR_DRVNAME_S5K2P8_MIPI_RAW, currSensorName)))
-            {
-                if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1200,mode_name))
-                {
-                     PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
-                     goto _kdCISModulePowerOn_exit_;
-                }
-            }
-            else if(currSensorName && (0 == strcmp(SENSOR_DRVNAME_IMX219_MIPI_RAW, currSensorName)))
-            {
-                if(pinSetIdx == 0 && TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1200,mode_name))
-                {
-                     PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
-                     goto _kdCISModulePowerOn_exit_;
-                }
-            }
-            else { // Main VCAMD max 1.5V
-                if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1500,mode_name))
-                {
-                     PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
-                     goto _kdCISModulePowerOn_exit_;
-                }
-
-            }
-
-
-             //AF_VCC
-            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
-            {
-                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-            mdelay(5);
-
-            //enable active sensor
-            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
-                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
-                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
-                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
-            }
-
-            mdelay(1);
-
-            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
-                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
-                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
-                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
-            }
-        }
-    }
-    else {//power OFF
-
-        PK_DBG("[PowerOFF]pinSetIdx:%d\n", pinSetIdx);
-            ISP_MCLK1_EN(0);
-
-        if ((currSensorName && (0 == strcmp(currSensorName,"imx135mipiraw")))||
-            (currSensorName && (0 == strcmp(currSensorName,"imx220mipiraw"))))
-
-        {
-            //Set Power Pin low and Reset Pin Low
-            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
-                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
-                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
-                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
-            }
-
-            //Set Reset Pin Low
-             if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
-                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
-                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
-                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
-            }
-
-            //AF_VCC
-            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name))
-            {
-                PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
-                //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-            //VCAM_IO
-            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
-                PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
-                //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_D,mode_name))
-            {
-                 PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D), power id = %d \n",CAMERA_POWER_VCAM_D);
-                 goto _kdCISModulePowerOn_exit_;
-            }
-
-            //VCAM_A
-            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
-                PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
-                //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-        }
-        else if (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV5648_MIPI_RAW, currSensorName)) && (pinSetIdx == 0))
-        {
-             //PK_DBG("[OFF]sensorIdx:%d \n",SensorIdx);
-	        printk("[CAMERA SENSOR] jeff imx219 poweroff.\n"); //jeff add 
-	        if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
-	        //    if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! \n");}
-	            if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! \n");}
-	       //     if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! \n");}
-	            if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! \n");}
-	    	    if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");} //high == power down lens module
-	       //     if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");} //low == reset sensor
-		}
-
-            if(TRUE != _hwPowerDown(SUB_CAMERA_POWER_VCAM_D,mode_name))
-            {
-                 PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D), power id = %d \n",SUB_CAMERA_POWER_VCAM_D);
-                 goto _kdCISModulePowerOn_exit_;
-            }
-
-            //VCAM_A
-            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
-                PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
-                //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-            //VCAM_IO
-            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
-                PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
-                //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-            //AF_VCC
-            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name))
-            {
-                PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
-                //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-        }
-//////////////////
-	else if (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV2680_MIPI_RAW, currSensorName)) && (pinSetIdx == 1))
-        {
-          //  mt_set_gpio_out(GPIO_SPI_MOSI_PIN,GPIO_OUT_ZERO);
-            //Set Power Pin low and Reset Pin Low
-            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
-	        //    if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! \n");}
-	            if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! \n");}
-	       //     if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! \n");}
-	            if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! \n");}
-	    	    if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");} //high == power down lens module
-	       //     if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");} //low == reset sensor
-		}
-
-            if(TRUE != _hwPowerDown(SUB_CAMERA_POWER_VCAM_D,mode_name))
-            {
-                 PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D), power id = %d \n",SUB_CAMERA_POWER_VCAM_D);
-                 goto _kdCISModulePowerOn_exit_;
-            }
-
-            //VCAM_A
-            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
-                PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
-                //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-            //VCAM_IO
-            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
-                PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
-                //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-            //AF_VCC
-            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name))
-            {
-                PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
-                //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-        }
-	 else if (currSensorName && (0 == strcmp(SENSOR_DRVNAME_IMX219_MIPI_RAW, currSensorName)) && (pinSetIdx == 0))
-        {
-          //  mt_set_gpio_out(GPIO_SPI_MOSI_PIN,GPIO_OUT_ZERO);
-            //Set Power Pin low and Reset Pin Low
-            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
-	        //    if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! \n");}
-	            if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! \n");}
-	       //     if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! \n");}
-	            if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! \n");}
-	    	    if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");} //high == power down lens module
-	       //     if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");} //low == reset sensor
-		}
-
-            if(TRUE != _hwPowerDown(SUB_CAMERA_POWER_VCAM_D,mode_name))
-            {
-                 PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D), power id = %d \n",SUB_CAMERA_POWER_VCAM_D);
-                 goto _kdCISModulePowerOn_exit_;
-            }
-
-            //VCAM_A
-            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
-                PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
-                //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-            //VCAM_IO
-            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
-                PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
-                //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-            //AF_VCC
-            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name))
-            {
-                PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
-                //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-        }
-        else if (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV8858_MIPI_RAW, currSensorName)) && (pinSetIdx == 0))
-        {
-          //  mt_set_gpio_out(GPIO_SPI_MOSI_PIN,GPIO_OUT_ZERO);
-            //Set Power Pin low and Reset Pin Low
-            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
-	        //    if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! \n");}
-	            if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! \n");}
-	       //     if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! \n");}
-	            if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! \n");}
-	    	    if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");} //high == power down lens module
-	       //     if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");} //low == reset sensor
-		}
-
-            if(TRUE != _hwPowerDown(SUB_CAMERA_POWER_VCAM_D,mode_name))
-            {
-                 PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D), power id = %d \n",SUB_CAMERA_POWER_VCAM_D);
-                 goto _kdCISModulePowerOn_exit_;
-            }
-
-            //VCAM_A
-            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
-                PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
-                //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-            //VCAM_IO
-            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
-                PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
-                //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-            //AF_VCC
-            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name))
-            {
-                PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
-                //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-        }
-//////////////////
-        else if (currSensorName && (0 == strcmp(SENSOR_DRVNAME_GC2355_MIPI_RAW, currSensorName)))
-        {
-           // mt_set_gpio_out(GPIO_SPI_MOSI_PIN,GPIO_OUT_ZERO);
-            //Set Power Pin low and Reset Pin Low
-            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
-                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
-                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
-                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
-            }
-
-            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
-                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
-                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
-                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
-            }
-
-
-            if(TRUE != _hwPowerDown(SUB_CAMERA_POWER_VCAM_D,mode_name))
-            {
-                 PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D), power id = %d \n",SUB_CAMERA_POWER_VCAM_D);
-                 goto _kdCISModulePowerOn_exit_;
-            }
-
-            //VCAM_A
-            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
-                PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
-                //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-            //VCAM_IO
-            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
-                PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
-                //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-            //AF_VCC
-            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name))
-            {
-                PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
-                //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-        }
-        else
-        {
-            //Set Power Pin low and Reset Pin Low
-            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
-                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
-                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
-                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
-            }
-
-
-            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
-                    if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
-                    if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
-                    if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
-            }
-
-            if(currSensorName && (0 == strcmp(SENSOR_DRVNAME_IMX219_MIPI_RAW, currSensorName)))
-	    {
-		if(pinSetIdx == 0 && TRUE != _hwPowerDown(CAMERA_POWER_VCAM_D, mode_name))
-		 {
-		   PK_DBG("[CAMERA SENSOR] main imx220 Fail to OFF core power (VCAM_D), power id = %d \n",CAMERA_POWER_VCAM_D);
-		   goto _kdCISModulePowerOn_exit_;
-		 }
-	    } else {
-
-	         if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_D,mode_name))
-	         {
-	            PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D), power id = %d \n",CAMERA_POWER_VCAM_D);
-	            goto _kdCISModulePowerOn_exit_;
-	          }
-	   }
-
-            //VCAM_A
-            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
-                PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
-                //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-            //VCAM_IO
-            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
-                PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
-                //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-            //AF_VCC
-            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name))
-            {
-                PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
-                //return -EIO;
-                goto _kdCISModulePowerOn_exit_;
-            }
-
-        }
-
-    }
-
-    return 0;
-
-_kdCISModulePowerOn_exit_:
-    return -EIO;
-
-}
-
-EXPORT_SYMBOL(kdCISModulePowerOn);
-
-//!--
-//
-
-
diff --git a/drivers/misc/mediatek/mach/mt6735/lentk6735_65c_l1/accelerometer/KXTJ2_1009-new/Makefile~ b/drivers/misc/mediatek/mach/mt6735/lentk6735_65c_l1/accelerometer/KXTJ2_1009-new/Makefile~
deleted file mode 100755
index c2ff2dc..0000000
--- a/drivers/misc/mediatek/mach/mt6735/lentk6735_65c_l1/accelerometer/KXTJ2_1009-new/Makefile~
+++ /dev/null
@@ -1,4 +0,0 @@
-include $(srctree)/drivers/misc/mediatek/Makefile.custom
-
-obj-y	:=  kxtj2_1009_cust_acc.o
-
diff --git a/drivers/misc/mediatek/mach/mt6735/lentk6735_65c_l1/accelerometer/KXTJ2_1009_auto/Makefile~ b/drivers/misc/mediatek/mach/mt6735/lentk6735_65c_l1/accelerometer/KXTJ2_1009_auto/Makefile~
deleted file mode 100755
index 426c46e..0000000
--- a/drivers/misc/mediatek/mach/mt6735/lentk6735_65c_l1/accelerometer/KXTJ2_1009_auto/Makefile~
+++ /dev/null
@@ -1,4 +0,0 @@
-include $(srctree)/drivers/misc/mediatek/Makefile.custom
-
-obj-y	:=  mc3xxx_cust_acc.o
-
diff --git a/drivers/misc/mediatek/mach/mt6735/lentk6735_65c_l1/accelerometer/mc3xxx_auto/Makefile~ b/drivers/misc/mediatek/mach/mt6735/lentk6735_65c_l1/accelerometer/mc3xxx_auto/Makefile~
deleted file mode 100755
index 426c46e..0000000
--- a/drivers/misc/mediatek/mach/mt6735/lentk6735_65c_l1/accelerometer/mc3xxx_auto/Makefile~
+++ /dev/null
@@ -1,4 +0,0 @@
-include $(srctree)/drivers/misc/mediatek/Makefile.custom
-
-obj-y	:=  mc3xxx_cust_acc.o
-
diff --git a/drivers/misc/mediatek/power/mt6735/Makefile~ b/drivers/misc/mediatek/power/mt6735/Makefile~
deleted file mode 100755
index fccd41b..0000000
--- a/drivers/misc/mediatek/power/mt6735/Makefile~
+++ /dev/null
@@ -1,31 +0,0 @@
-include $(srctree)/drivers/misc/mediatek/Makefile.custom
-
-obj-$(CONFIG_MTK_PMIC)          += pmic.o upmu_common.o pmic_auxadc.o pmic_chr_type_det.o mt6311.o
-
-ifeq ($(CONFIG_MTK_PMIC_DVT_SUPPORT),y)
-     obj-$(CONFIG_MTK_PMIC)     += pmic_dvt.o
-endif
-
-obj-$(CONFIG_MTK_SMART_BATTERY) += battery_meter_hal.o 
-
-ifeq ($(CONFIG_MTK_BQ24261_SUPPORT),y)
-     obj-$(CONFIG_MTK_SMART_BATTERY) += bq24261.o charging_hw_bq24261.o
-else
-     ifeq ($(CONFIG_MTK_SWCHR_SUPPORT),y)
-          obj-$(CONFIG_MTK_SMART_BATTERY) += charging_hw_mt_sw_charger.o                
-     else
-          ifeq ($(CONFIG_MTK_NCP1854_SUPPORT),y)
-               obj-$(CONFIG_MTK_SMART_BATTERY) += ncp1854.o charging_hw_ncp1854.o             
-          else
-               ifeq ($(CONFIG_MTK_BQ24296_SUPPORT),y)
-                    obj-$(CONFIG_MTK_SMART_BATTERY) += bq24296.o charging_hw_bq24296.o			  
-               else
-                    ifeq ($(CONFIG_MTK_FAN5405_SUPPORT),y)
-                        obj-$(CONFIG_MTK_SMART_BATTERY) += fan5405.o charging_hw_fan5405.o
-                    else               
-                    obj-$(CONFIG_MTK_SMART_BATTERY) += charging_hw_pmic999.o
-               endif
-          endif
-     endif
-endif
-endif
diff --git a/drivers/misc/mediatek/power/mt6735/charging_hw_pmic.c~ b/drivers/misc/mediatek/power/mt6735/charging_hw_pmic.c~
deleted file mode 100755
index e56767a..0000000
--- a/drivers/misc/mediatek/power/mt6735/charging_hw_pmic.c~
+++ /dev/null
@@ -1,724 +0,0 @@
-#include <mach/charging.h>
-#include <mach/upmu_common.h>
-#include <mach/upmu_sw.h>
-#include <mach/upmu_hw.h>
-#include <linux/xlog.h>
-#include <linux/delay.h>
-#include <linux/reboot.h>
-
-#include <mach/mt_sleep.h>
-#include <mach/mt_boot.h>
-#include <mach/system.h>
-
-#include "cust_battery_meter.h"
-#include <cust_charging.h>
-#include <cust_pmic.h>
-#include <mach/mt6311.h>
-
-     
- // ============================================================ //
- //define
- // ============================================================ //
-#define STATUS_OK    0
-#define STATUS_FAIL	1
-#define STATUS_UNSUPPORTED    -1
-#define GETARRAYNUM(array) (sizeof(array)/sizeof(array[0]))
-
-
- // ============================================================ //
- //global variable
- // ============================================================ //
-kal_bool chargin_hw_init_done = KAL_TRUE; 
-kal_bool charging_type_det_done = KAL_TRUE;
-
-const kal_uint32 VBAT_CV_VTH[]=
-{
-	BATTERY_VOLT_03_775000_V, BATTERY_VOLT_03_800000_V, BATTERY_VOLT_03_850000_V, BATTERY_VOLT_03_900000_V,
-	BATTERY_VOLT_04_000000_V, BATTERY_VOLT_04_050000_V, BATTERY_VOLT_04_100000_V, BATTERY_VOLT_04_125000_V,
-	BATTERY_VOLT_04_137500_V, BATTERY_VOLT_04_150000_V, BATTERY_VOLT_04_162500_V, BATTERY_VOLT_04_175000_V,
-	BATTERY_VOLT_04_187500_V, BATTERY_VOLT_04_200000_V, BATTERY_VOLT_04_212500_V, BATTERY_VOLT_04_225000_V,
-    
-	BATTERY_VOLT_04_237500_V, BATTERY_VOLT_04_250000_V, BATTERY_VOLT_04_262500_V, BATTERY_VOLT_04_275000_V,
-	BATTERY_VOLT_04_300000_V, BATTERY_VOLT_04_325000_V, BATTERY_VOLT_04_350000_V, BATTERY_VOLT_04_375000_V,
-	BATTERY_VOLT_04_440000_V, BATTERY_VOLT_04_425000_V, BATTERY_VOLT_02_200000_V, BATTERY_VOLT_02_200000_V,    
-	BATTERY_VOLT_02_200000_V, BATTERY_VOLT_02_200000_V, BATTERY_VOLT_02_200000_V, BATTERY_VOLT_02_200000_V,
-    
-	BATTERY_VOLT_02_200000_V, BATTERY_VOLT_02_200000_V, BATTERY_VOLT_02_200000_V, BATTERY_VOLT_02_200000_V,
-	BATTERY_VOLT_02_200000_V, BATTERY_VOLT_02_200000_V, BATTERY_VOLT_02_200000_V, BATTERY_VOLT_02_200000_V,
-	BATTERY_VOLT_02_200000_V, BATTERY_VOLT_02_200000_V, BATTERY_VOLT_02_200000_V, BATTERY_VOLT_02_200000_V,
-    BATTERY_VOLT_02_200000_V, BATTERY_VOLT_02_200000_V, BATTERY_VOLT_02_200000_V, BATTERY_VOLT_02_200000_V,
-    
-    BATTERY_VOLT_02_200000_V, BATTERY_VOLT_02_200000_V, BATTERY_VOLT_02_200000_V, BATTERY_VOLT_02_200000_V,
-    BATTERY_VOLT_02_200000_V, BATTERY_VOLT_02_200000_V, BATTERY_VOLT_02_200000_V, BATTERY_VOLT_02_200000_V,
-    BATTERY_VOLT_02_200000_V, BATTERY_VOLT_02_200000_V, BATTERY_VOLT_02_200000_V, BATTERY_VOLT_02_200000_V,
-    BATTERY_VOLT_02_200000_V, BATTERY_VOLT_02_200000_V, BATTERY_VOLT_02_200000_V, BATTERY_VOLT_02_200000_V
-};
-
-const kal_uint32 CS_VTH[]=
-{    
-	CHARGE_CURRENT_2000_00_MA, CHARGE_CURRENT_1600_00_MA, CHARGE_CURRENT_1500_00_MA, CHARGE_CURRENT_1350_00_MA,
-	CHARGE_CURRENT_1200_00_MA, CHARGE_CURRENT_1100_00_MA, CHARGE_CURRENT_1000_00_MA, CHARGE_CURRENT_900_00_MA,
-	CHARGE_CURRENT_800_00_MA,  CHARGE_CURRENT_700_00_MA,  CHARGE_CURRENT_650_00_MA,  CHARGE_CURRENT_550_00_MA,
-	CHARGE_CURRENT_450_00_MA,  CHARGE_CURRENT_300_00_MA,  CHARGE_CURRENT_200_00_MA,  CHARGE_CURRENT_70_00_MA
-}; 
-
-
-const kal_uint32 VCDT_HV_VTH[]=
-{
-	 BATTERY_VOLT_04_200000_V, BATTERY_VOLT_04_250000_V, BATTERY_VOLT_04_300000_V, BATTERY_VOLT_04_350000_V,
-	 BATTERY_VOLT_04_400000_V, BATTERY_VOLT_04_450000_V, BATTERY_VOLT_04_500000_V, BATTERY_VOLT_04_550000_V,
-	 
-	 BATTERY_VOLT_04_600000_V, BATTERY_VOLT_06_000000_V, BATTERY_VOLT_06_500000_V, BATTERY_VOLT_07_000000_V,
-	 BATTERY_VOLT_07_500000_V, BATTERY_VOLT_08_500000_V, BATTERY_VOLT_09_500000_V, BATTERY_VOLT_10_500000_V		 
-};
-
-// ============================================================ //
-// function prototype
-// ============================================================ //
- 
- 
-// ============================================================ //
-//extern variable
-// ============================================================ //
- 
-// ============================================================ //
-//extern function
-// ============================================================ //
-extern kal_uint32 upmu_get_reg_value(kal_uint32 reg);
-extern void Charger_Detect_Init(void);
-extern void Charger_Detect_Release(void);
-extern int hw_charging_get_charger_type(void);
-extern void mt_power_off(void);
-extern kal_uint32 mt6311_get_chip_id(void);
-extern int is_mt6311_exist(void);
-extern int is_mt6311_sw_ready(void);
-
- 
- // ============================================================ //
-kal_uint32 charging_value_to_parameter(const kal_uint32 *parameter, const kal_uint32 array_size, const kal_uint32 val)
-{
-    if (val < array_size)
-    {
-        return parameter[val];
-    }
-    else
-    {
-        battery_log(BAT_LOG_CRTI, "Can't find the parameter \r\n");    
-        return parameter[0];
-    }
-}
-
- 
-kal_uint32 charging_parameter_to_value(const kal_uint32 *parameter, const kal_uint32 array_size, const kal_uint32 val)
-{
-    kal_uint32 i;
-
-    for(i=0;i<array_size;i++)
-    {
-        if (val == *(parameter + i))
-        {
-                return i;
-        }
-    }
-
-     battery_log(BAT_LOG_CRTI, "NO register value match \r\n");
-    //TODO: ASSERT(0);    // not find the value
-    return 0;
-}
-
-
-static kal_uint32 bmt_find_closest_level(const kal_uint32 *pList,kal_uint32 number,kal_uint32 level)
-{
-     kal_uint32 i;
-     kal_uint32 max_value_in_last_element;
- 
-     if(pList[0] < pList[1])
-         max_value_in_last_element = KAL_TRUE;
-     else
-         max_value_in_last_element = KAL_FALSE;
- 
-     if(max_value_in_last_element == KAL_TRUE)
-     {
-         for(i = (number-1); i != 0; i--)     //max value in the last element
-         {
-             if(pList[i] <= level)
-             {
-                 return pList[i];
-             }      
-         }
-
-         battery_log(BAT_LOG_CRTI, "Can't find closest level \r\n");    
-         return pList[0];
-         //return CHARGE_CURRENT_0_00_MA;
-     }
-     else
-     {
-         for(i = 0; i< number; i++)  // max value in the first element
-         {
-             if(pList[i] <= level)
-             {
-                 return pList[i];
-             }      
-         }
-
-          battery_log(BAT_LOG_CRTI, "Can't find closest level \r\n");
-         return pList[number -1];
-         //return CHARGE_CURRENT_0_00_MA;
-     }
-}
-
-static kal_uint32 charging_hw_init(void *data)
-{
-    kal_uint32 status = STATUS_OK;
-
-	pmic_set_register_value(PMIC_RG_CHRWDT_TD,0); 	// CHRWDT_TD, 4s
-	pmic_set_register_value(PMIC_RG_CHRWDT_INT_EN,1); // CHRWDT_INT_EN
-	pmic_set_register_value(PMIC_RG_CHRWDT_EN,1); // CHRWDT_EN
-	pmic_set_register_value(PMIC_RG_CHRWDT_WR,1);// CHRWDT_WR
-
-	pmic_set_register_value(PMIC_RG_VCDT_MODE,0);//VCDT_MODE
-	pmic_set_register_value(PMIC_RG_VCDT_HV_EN,1);//VCDT_HV_EN 
-
-	pmic_set_register_value(PMIC_RG_USBDL_SET,0);//force leave USBDL mode 
-	pmic_set_register_value(PMIC_RG_USBDL_RST,1);//force leave USBDL mode
-
-	pmic_set_register_value(PMIC_RG_BC11_BB_CTRL,1);//BC11_BB_CTRL 
-	pmic_set_register_value(PMIC_RG_BC11_RST,1);//BC11_RST
-
-	pmic_set_register_value(PMIC_RG_CSDAC_MODE,1);//CSDAC_MODE
-	pmic_set_register_value(PMIC_RG_VBAT_OV_EN,1);//VBAT_OV_EN
-
-#ifdef HIGH_BATTERY_VOLTAGE_SUPPORT
-	pmic_set_register_value(PMIC_RG_VBAT_OV_VTH,3);//VBAT_OV_VTH, 4.4V,
-#else
-	pmic_set_register_value(PMIC_RG_VBAT_OV_VTH,2);//VBAT_OV_VTH, 4.3V,
-#endif
-	pmic_set_register_value(PMIC_RG_BATON_EN,1);//BATON_EN
-
-	//Tim, for TBAT
-	pmic_set_register_value(PMIC_RG_BATON_HT_EN,0);//BATON_HT_EN
-
-	pmic_set_register_value(PMIC_RG_ULC_DET_EN,1);// RG_ULC_DET_EN=1
-	pmic_set_register_value(PMIC_RG_LOW_ICH_DB,1);// RG_LOW_ICH_DB=000001'b
-
-
-    #if defined(CONFIG_MTK_PUMP_EXPRESS_SUPPORT)
-	pmic_set_register_value(PMIC_RG_CSDAC_DLY,0);// CSDAC_DLY	
-	pmic_set_register_value(PMIC_RG_CSDAC_STP,1);// CSDAC_STP
-	pmic_set_register_value(PMIC_RG_CSDAC_STP_INC,1);// CSDAC_STP_INC 
-	pmic_set_register_value(PMIC_RG_CSDAC_STP_DEC,7);// CSDAC_STP_DEC
-	pmic_set_register_value(PMIC_RG_CS_EN,1);// CS_EN 
-
-	pmic_set_register_value(PMIC_RG_HWCV_EN,1);
-	pmic_set_register_value(PMIC_RG_VBAT_CV_EN,1);// CV_EN 
-
-	pmic_set_register_value(PMIC_RG_CHR_EN,1);// CHR_EN 
-	pmic_set_register_value(PMIC_RG_CSDAC_EN,1);// CSDAC_EN 
-    #endif
-
-    return status;
-}
-
-
-static kal_uint32 charging_dump_register(void *data)
-{
-    kal_uint32 status = STATUS_OK;
-
-    kal_uint32 reg_val = 0;    
-    kal_uint32 i = 0;
-
-    for(i=MT6328_CHR_CON0 ; i<=MT6328_CHR_CON40 ; i+=2)
-    {
-        reg_val = upmu_get_reg_value(i);
-        battery_log(BAT_LOG_CRTI, "[0x%x]=0x%x,", i, reg_val);
-    }
-
-    battery_log(BAT_LOG_CRTI, "\n");
-
-    return status;
-}
-     
-
-static kal_uint32 charging_enable(void *data)
-{
-    kal_uint32 status = STATUS_OK;
-    kal_uint32 enable = *(kal_uint32*)(data);
-
-    if(KAL_TRUE == enable)
-    {
-		pmic_set_register_value(PMIC_RG_CSDAC_DLY,4);// CSDAC_DLY
-		pmic_set_register_value(PMIC_RG_CSDAC_STP,1);// CSDAC_STP
-		pmic_set_register_value(PMIC_RG_CSDAC_STP_INC,1);// CSDAC_STP_INC
-		pmic_set_register_value(PMIC_RG_CSDAC_STP_DEC,2);// CSDAC_STP_DEC
-		pmic_set_register_value(PMIC_RG_CS_EN,1);// CS_EN, check me
-	
-		pmic_set_register_value(PMIC_RG_HWCV_EN,1);
-
-		pmic_set_register_value(PMIC_RG_VBAT_CV_EN,1);// CV_EN
-		pmic_set_register_value(PMIC_RG_CSDAC_EN,1);// CSDAC_EN	
-
-		pmic_set_register_value(PMIC_RG_PCHR_FLAG_EN,1);// enable debug falg output
-
-		pmic_set_register_value(PMIC_RG_CHR_EN,1);// CHR_EN
-
-   		pmic_set_register_value(PMIC_RG_CSDAC_MODE,1);//CSDAC_MODE 
-                pmic_set_register_value(PMIC_RG_CSDAC_EN,1);// CSDAC_EN	
-
-
-        if(Enable_BATDRV_LOG == BAT_LOG_FULL)
-            charging_dump_register(NULL);
-    }
-	else
-	{
-		pmic_set_register_value(PMIC_RG_CHRWDT_INT_EN,0);// CHRWDT_INT_EN
-		pmic_set_register_value(PMIC_RG_CHRWDT_EN,0);// CHRWDT_EN
-		pmic_set_register_value(PMIC_RG_CHRWDT_FLAG_WR,0);// CHRWDT_FLAG
-		pmic_set_register_value(PMIC_RG_CSDAC_EN,0);// CSDAC_EN
-		pmic_set_register_value(PMIC_RG_CHR_EN,0);// CHR_EN
-		pmic_set_register_value(PMIC_RG_HWCV_EN,0);// RG_HWCV_EN
-	}    
-    return status;
-}
-
-
-static kal_uint32 charging_set_cv_voltage(void *data)
-{
-    kal_uint32 status = STATUS_OK;
-    kal_uint16 register_value;
-
-    register_value = charging_parameter_to_value(VBAT_CV_VTH, GETARRAYNUM(VBAT_CV_VTH) ,*(kal_uint32 *)(data));
-
-/*
-    #if 0
-    mt6325_upmu_set_rg_vbat_cv_vth(register_value); 
-    #else
-    //PCB workaround
-    if(mt6325_upmu_get_swcid() == PMIC6325_E1_CID_CODE)
-    {
-        pmic_config_interface(0xEFE,0x0,0xF,1); // [4:1]: RG_VBAT_OV_VTH; Set charger OV=3.9V
-        pmic_config_interface(0xEF8,0x3,0x3F,0); // [5:0]: RG_VBAT_CV_VTH; Set charger CV=3.8V
-        battery_log(BAT_LOG_CRTI,"[charging_set_cv_voltage] set low CV by 6325 E1\n");
-    }
-    else
-    {
-        if(is_mt6311_exist())
-        {
-            if(mt6311_get_chip_id()==PMIC6311_E1_CID_CODE)
-            {
-                pmic_config_interface(0xEFE,0x0,0xF,1); // [4:1]: RG_VBAT_OV_VTH; Set charger OV=3.9V
-                pmic_config_interface(0xEF8,0x3,0x3F,0); // [5:0]: RG_VBAT_CV_VTH; Set charger CV=3.8V 
-                battery_log(BAT_LOG_CRTI,"[charging_set_cv_voltage] set low CV by 6311 E1\n");
-            }
-            else
-            {
-                mt6325_upmu_set_rg_vbat_cv_vth(register_value);
-            }
-        }
-        else
-        {
-            mt6325_upmu_set_rg_vbat_cv_vth(register_value);
-        } 
-    }  
-    #endif
-*/
-
-    pmic_set_register_value(PMIC_RG_VBAT_CV_VTH,register_value);
-
-    battery_log(BAT_LOG_CRTI,"[charging_set_cv_voltage] [0x%x]=0x%x, [0x%x]=0x%x\n",
-                    0xf54, upmu_get_reg_value(0xf54),
-                    0xf4e, upmu_get_reg_value(0xf4e)
-                    );
-
-    return status;
-}     
-
-
-static kal_uint32 charging_get_current(void *data)
-{
-    kal_uint32 status = STATUS_OK;
-    kal_uint32 array_size;
-    kal_uint32 reg_value;
-
-    array_size = GETARRAYNUM(CS_VTH);
-        reg_value=pmic_get_register_value(PMIC_RG_CS_VTH);//RG_CS_VTH
-    *(kal_uint32 *)data = charging_value_to_parameter(CS_VTH,array_size,reg_value);
-    
-    return status;
-}  
-  
-
-static kal_uint32 charging_set_current(void *data)
-{
-    kal_uint32 status = STATUS_OK;
-    kal_uint32 set_chr_current;
-    kal_uint32 array_size;
-    kal_uint32 register_value;
-    
-    array_size = GETARRAYNUM(CS_VTH);
-    set_chr_current = bmt_find_closest_level(CS_VTH, array_size, *(kal_uint32 *)data);
-    register_value = charging_parameter_to_value(CS_VTH, array_size ,set_chr_current);
-    pmic_set_register_value(PMIC_RG_CS_VTH,register_value);	
-
-    return status;
-}     
-
-
-static kal_uint32 charging_set_input_current(void *data)
-{
-    kal_uint32 status = STATUS_OK;
-    return status;
-}     
-
-static kal_uint32 charging_get_charging_status(void *data)
-{
-    kal_uint32 status = STATUS_OK;
-    return status;
-}
-
- 
-static kal_uint32 charging_reset_watch_dog_timer(void *data)
-{
-	kal_uint32 status = STATUS_OK;
-
-	pmic_set_register_value(PMIC_RG_CHRWDT_TD,0);	// CHRWDT_TD, 4s
-	pmic_set_register_value(PMIC_RG_CHRWDT_WR,1);	// CHRWDT_WR
-	pmic_set_register_value(PMIC_RG_CHRWDT_INT_EN,1);	 // CHRWDT_INT_EN
-	pmic_set_register_value(PMIC_RG_CHRWDT_EN,1);	// CHRWDT_EN
-	pmic_set_register_value(PMIC_RG_CHRWDT_FLAG_WR,1);	// CHRWDT_WR
-
-	return status;
-}
-
-fdfdf
-static kal_uint32 charging_set_hv_threshold(void *data)
-{
-	kal_uint32 status = STATUS_OK;
-
-	kal_uint32 set_hv_voltage;
-	kal_uint32 array_size;
-	kal_uint16 register_value;
-	kal_uint32 voltage = *(kal_uint32*)(data);
-
-	array_size = GETARRAYNUM(VCDT_HV_VTH);
-	set_hv_voltage = bmt_find_closest_level(VCDT_HV_VTH, array_size, voltage);
-	register_value = charging_parameter_to_value(VCDT_HV_VTH, array_size ,set_hv_voltage);
-	pmic_set_register_value(PMIC_RG_VCDT_HV_VTH,register_value);
-
-	return status;
-}
-
-
-static kal_uint32 charging_get_hv_status(void *data)
-{
-    kal_uint32 status = STATUS_OK;
-
-    *(kal_bool*)(data) = pmic_get_register_value(PMIC_RGS_VCDT_HV_DET);
-       
-    return status;
-}
-
-        
-static kal_uint32 charging_get_battery_status(void *data)
-{
-    kal_uint32 status = STATUS_OK;
-    kal_uint32 val = 0;
-#if defined(CONFIG_POWER_EXT) || defined(CONFIG_MTK_FPGA)
-    *(kal_bool*)(data) = 0; // battery exist
-    battery_log(BAT_LOG_CRTI,"bat exist for evb\n");
-#else
-	val=pmic_get_register_value(PMIC_BATON_TDET_EN);
-	battery_log(BAT_LOG_FULL,"[charging_get_battery_status] BATON_TDET_EN = %d\n", val);
-	if (val) {
-	pmic_set_register_value(PMIC_BATON_TDET_EN,1);
-	pmic_set_register_value(PMIC_RG_BATON_EN,1);
-	*(kal_bool*)(data) = pmic_get_register_value(PMIC_RGS_BATON_UNDET);
-	} else {
-		*(kal_bool*)(data) =  KAL_FALSE;
-	}
-#endif
-      
-    return status;
-}
-
-    
-static kal_uint32 charging_get_charger_det_status(void *data)
-{
-	kal_uint32 status = STATUS_OK;
-
-#if defined(CONFIG_MTK_FPGA)
-	*(kal_bool*)(data) = 1; 
-	battery_log(BAT_LOG_CRTI,"chr exist for fpga\n");
-#else    
-	*(kal_bool*)(data) = pmic_get_register_value(PMIC_RGS_CHRDET);
-#endif     
-	   
-	 return status;
-}
-
-
-kal_bool charging_type_detection_done(void)
-{
-     return charging_type_det_done;
-}
-
-
-static kal_uint32 charging_get_charger_type(void *data)
-{
-    kal_uint32 status = STATUS_OK;
-     
-#if defined(CONFIG_POWER_EXT) || defined(CONFIG_MTK_FPGA)
-    *(CHARGER_TYPE*)(data) = STANDARD_HOST;
-#else
-    *(CHARGER_TYPE*)(data) = hw_charging_get_charger_type();
-#endif
-
-     return status;
-}
-
-static kal_uint32 charging_get_is_pcm_timer_trigger(void *data)
-{
-     kal_uint32 status = STATUS_OK;
-     
-#if defined(CONFIG_POWER_EXT) || defined(CONFIG_MTK_FPGA)
-    *(kal_bool*)(data) = KAL_FALSE;
-#else 
-
-     if(slp_get_wake_reason() == WR_PCM_TIMER)
-         *(kal_bool*)(data) = KAL_TRUE;
-     else
-         *(kal_bool*)(data) = KAL_FALSE;
- 
-     battery_log(BAT_LOG_CRTI, "slp_get_wake_reason=%d\n", slp_get_wake_reason());
-
-#endif
-        
-    return status;
- }
- 
- static kal_uint32 charging_set_platform_reset(void *data)
- {
-     kal_uint32 status = STATUS_OK;
-     
-#if defined(CONFIG_POWER_EXT) || defined(CONFIG_MTK_FPGA)    
-#else 
-     battery_log(BAT_LOG_CRTI, "charging_set_platform_reset\n");
-  
-  	kernel_restart("battery service reboot system");
-     //arch_reset(0,NULL);
-#endif
-         
-     return status;
- }
- 
- static kal_uint32 charging_get_platfrom_boot_mode(void *data)
- {
-     kal_uint32 status = STATUS_OK;
-     
-#if defined(CONFIG_POWER_EXT) || defined(CONFIG_MTK_FPGA)   
-#else   
-     *(kal_uint32*)(data) = get_boot_mode();
- 
-     battery_log(BAT_LOG_CRTI, "get_boot_mode=%d\n", get_boot_mode());
-#endif
-          
-     return status;
-}
-
-static kal_uint32 charging_set_power_off(void *data)
-{
-    kal_uint32 status = STATUS_OK;
-  
-#if defined(CONFIG_POWER_EXT) || defined(CONFIG_MTK_FPGA)
-#else
-    battery_log(BAT_LOG_CRTI, "charging_set_power_off\n");
-    kernel_power_off();
-#endif
-         
-    return status;
-}
-
-static kal_uint32 charging_get_power_source(void *data)
-{
-    kal_uint32 status = STATUS_OK;
-
-#if 0 //#if defined(MTK_POWER_EXT_DETECT)
-    if (MT_BOARD_PHONE == mt_get_board_type())
-        *(kal_bool *)data = KAL_FALSE;
-    else
-        *(kal_bool *)data = KAL_TRUE;
-#else
-        *(kal_bool *)data = KAL_FALSE;
-#endif
-
-    return status;
-}
-
-static kal_uint32 charging_get_csdac_full_flag(void *data)
-{
-    kal_uint32 status = STATUS_OK;
-    *(kal_bool *)data = KAL_FALSE;
-	return status;	
-}
-
-static kal_uint32 charging_set_ta_current_pattern(void *data)
-{
-	kal_uint32 status = STATUS_OK;
-	kal_uint32 increase = *(kal_uint32*)(data);
-	kal_uint32 debug_val = 0;
-	U8 count = 0;
-
-		pmic_set_register_value(PMIC_RG_CS_VTH,0xc);
-
-	if(increase == KAL_TRUE) {
-	    	/* Set communication mode high/low current */
-		pmic_set_register_value(PMIC_RG_CM_CS_VTHH,0xa);/* 650mA */
-		pmic_set_register_value(PMIC_RG_CM_CS_VTHL,0xf);/* 70mA */	
-	        
-		/* Set CM_VINC high period time (HPRD1, HPRD2) */
-		pmic_set_register_value(PMIC_RG_CM_VINC_HPRD1,9);/* 100ms */
-		pmic_set_register_value(PMIC_RG_CM_VINC_HPRD2,9);/* 100ms */			
-		
-		/* Set CM_VINC high period time (HPRD3, HPRD4) */
-		pmic_set_register_value(PMIC_RG_CM_VINC_HPRD3,29);/* 300ms */
-		pmic_set_register_value(PMIC_RG_CM_VINC_HPRD4,29);/* 300ms */			
-		
-		/* Set CM_VINC high period time (HPRD5, HPRD6) */
-		pmic_set_register_value(PMIC_RG_CM_VINC_HPRD5,29);/* 300ms */
-		pmic_set_register_value(PMIC_RG_CM_VINC_HPRD6,49);/* 500ms */	
-		
-		/* Enable CM_VINC interrupt */
-		//mt6325_upmu_set_rg_int_en_pchr_cm_vinc(0x1);
-			   pmic_set_register_value(PMIC_RG_INT_EN_PCHR_CM_VINC,1);
-		
-		/* Select PCHR debug flag to monitor abnormal abort */
-		pmic_set_register_value(PMIC_RG_PCHR_FLAG_SEL,0x2e);	
-		
-		/* Enable PCHR debug flag */
-		pmic_set_register_value(PMIC_RG_PCHR_FLAG_EN,0x1);	
-		
-		/* Trigger CM VINC mode */
-		pmic_set_register_value(PMIC_RG_CM_VINC_TRIG,0x1);	
-		
-		/* wait for interrupt */
-		while(pmic_get_register_value(PMIC_PCHR_CM_VINC_STATUS) != 1) {
-				msleep(50);
-			count++;
-				if (count > 42)
-				break;
-		}
-	} else {
-	    	/* Set communication mode high/low current */
-		pmic_set_register_value(PMIC_RG_CM_CS_VTHH,0xa);/* 650mA */
-		pmic_set_register_value(PMIC_RG_CM_CS_VTHL,0xf);/* 70mA */	
-	        
-		/* Set CM_VINC high period time (HPRD1, HPRD2) */
-			pmic_set_register_value(PMIC_RG_CM_VDEC_HPRD1,29);/* 100ms */
-			pmic_set_register_value(PMIC_RG_CM_VDEC_HPRD2,29);/* 100ms */			
-		
-		/* Set CM_VINC high period time (HPRD3, HPRD4) */
-			pmic_set_register_value(PMIC_RG_CM_VDEC_HPRD3,29);/* 300ms */
-			pmic_set_register_value(PMIC_RG_CM_VDEC_HPRD4,9);/* 300ms */			
-		
-		/* Set CM_VINC high period time (HPRD5, HPRD6) */
-			pmic_set_register_value(PMIC_RG_CM_VDEC_HPRD5,9);/* 300ms */
-			pmic_set_register_value(PMIC_RG_CM_VDEC_HPRD6,49);/* 500ms */	
-
-
-		
-		/* Enable CM_VINC interrupt */
-		//mt6325_upmu_set_rg_int_en_pchr_cm_vinc(0x1);
-			pmic_set_register_value(PMIC_RG_INT_EN_PCHR_CM_VDEC,1);
-		
-		/* Select PCHR debug flag to monitor abnormal abort */
-		pmic_set_register_value(PMIC_RG_PCHR_FLAG_SEL,0x2e);
-		
-		/* Enable PCHR debug flag */
-		pmic_set_register_value(PMIC_RG_PCHR_FLAG_EN,0x1);
-		
-		/* Trigger CM VINC mode */
-		pmic_set_register_value(PMIC_RG_CM_VDEC_TRIG,0x1);
-
-		/* wait for interrupt */
-		while(pmic_get_register_value(PMIC_PCHR_CM_VDEC_STATUS) != 1) {
-				msleep(50);
-			count++;
-				if (count > 42)
-				break;
-		}        
-	}
-
-	debug_val = pmic_get_register_value(PMIC_RGS_PCHR_FLAG_OUT);
-	battery_log(BAT_LOG_CRTI, "[charging_set_ta_current_pattern] debug_val=0x%x cnt=%d\n", debug_val,count);
-	if (count > 10 || debug_val != 0) {
-		status = STATUS_FAIL;
-	}
-	return status;
-}
-
-static kal_uint32 charging_get_error_state(void *data)
-{
-	return STATUS_UNSUPPORTED;
-}
-
-static kal_uint32 charging_set_error_state(void *data)
-{
-	return STATUS_UNSUPPORTED;	
-}
-
-static kal_uint32 (* const charging_func[CHARGING_CMD_NUMBER])(void *data)=
-{
-	 charging_hw_init
-	,charging_dump_register      
-	,charging_enable
-	,charging_set_cv_voltage
-	,charging_get_current
-	,charging_set_current
-	,charging_set_input_current
-	,charging_get_charging_status
-	,charging_reset_watch_dog_timer
-	,charging_set_hv_threshold
-	,charging_get_hv_status
-	,charging_get_battery_status
-	,charging_get_charger_det_status
-	,charging_get_charger_type
-	,charging_get_is_pcm_timer_trigger
-	,charging_set_platform_reset
-	,charging_get_platfrom_boot_mode
-	,charging_set_power_off
-	,charging_get_power_source
-	,charging_get_csdac_full_flag
-	,charging_set_ta_current_pattern
-	,charging_set_error_state
-};
- 
- 
- /*
- * FUNCTION
- *        Internal_chr_control_handler
- *
- * DESCRIPTION                                                             
- *         This function is called to set the charger hw
- *
- * CALLS  
- *
- * PARAMETERS
- *        None
- *     
- * RETURNS
- *        
- *
- * GLOBALS AFFECTED
- *       None
- */
-kal_int32 chr_control_interface(CHARGING_CTRL_CMD cmd, void *data)
-{
-     kal_int32 status;
-     if(cmd < CHARGING_CMD_NUMBER)
-         status = charging_func[cmd](data);
-     else
-         return STATUS_UNSUPPORTED;
- 
-     return status;
-}
-
-
diff --git a/drivers/misc/mediatek/spi/mt6735/spi-dev.c~ b/drivers/misc/mediatek/spi/mt6735/spi-dev.c~
deleted file mode 100755
index d29f45e..0000000
--- a/drivers/misc/mediatek/spi/mt6735/spi-dev.c~
+++ /dev/null
@@ -1,901 +0,0 @@
-#include <linux/spi/spi.h>
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/device.h>
-#include <linux/delay.h>
-#include <mach/mt_spi.h>
-
-#include <linux/dma-mapping.h>
-#include <linux/sched.h>
-#include "mt_spi_hal.h"
-#include <linux/kthread.h>
-
-#ifdef CONFIG_TRUSTONIC_TEE_SUPPORT
-#define SPI_TRUSTONIC_TEE_SUPPORT
-#endif
-
-#ifdef SPI_TRUSTONIC_TEE_SUPPORT
-#include <mobicore_driver_api.h>
-#include <tlspi_Api.h>
-#endif
-
-#define SPIDEV_LOG(fmt, args...) printk("[SPI-UT]: [%s]:[%d]" fmt, __func__, __LINE__, ##args) 
-#define SPIDEV_MSG(fmt, args...) printk(KERN_ERR  fmt, ##args )
-//#define SPI_STRESS_MAX 512
-#define SPI_STRESS_MAX 1 
-DECLARE_COMPLETION(mt_spi_done);
-static u32 stress_err = 0;
-static struct task_struct *spi_concur1;
-static struct task_struct *spi_concur2;
-static struct task_struct *spi_concur3;
-static struct task_struct *spi_concur4;
-
-static struct spi_transfer stress_xfer[SPI_STRESS_MAX];
-static struct spi_transfer stress_xfer_con[SPI_STRESS_MAX];
-
-static struct spi_message stress_msg[SPI_STRESS_MAX];
-static struct spi_device *spi_test;
-
-static int spi_setup_xfer(struct device *dev, struct spi_transfer *xfer, u32 len, u32 flag)
-{
-	u32 tx_buffer = 0x12345678;
-	u32 cnt, i;
-#if 0
-	u8 *p;
-#endif
-#define SPI_CROSS_ALIGN_OFFSET 1008	
-	xfer->len=len;
-
-	xfer->tx_buf = ( u32 * ) kzalloc ( len, GFP_KERNEL);
-	xfer->rx_buf = ( u32 * ) kzalloc ( len, GFP_KERNEL);
-	
-	if((xfer->tx_buf == NULL) || (xfer->rx_buf == NULL)  )
-			return -1;
-	
-	cnt = (len%4)?(len/4 + 1):(len/4);
-
-	if(flag == 0){
-		for ( i = 0; i < cnt; i++ )
-			*(( u32 * )xfer->tx_buf + i) = tx_buffer;
-	}else if(flag == 1){
-		for ( i = 0; i < cnt; i++ )
-			*(( u32 * )xfer->tx_buf + i) = tx_buffer + i;
-	}else if(flag == 2){//cross 1 K boundary
-		if(len < 2048)
-			return -EINVAL;
-		for ( i = 0; i < cnt; i++ )
-			*(( u32 * )xfer->tx_buf + i) = tx_buffer + i;
-
-		xfer->tx_dma = dma_map_single(dev, (void *)xfer->tx_buf, 	
-				xfer->len,  DMA_TO_DEVICE);				
-		if (dma_mapping_error(dev, xfer->tx_dma)) {
-			SPIDEV_LOG("dma mapping tx_buf error.\n");
-			return -ENOMEM;	
-		}
-		xfer->rx_dma = dma_map_single(dev, (void *)xfer->rx_buf, 	
-				xfer->len,  DMA_TO_DEVICE);				
-		if (dma_mapping_error(dev, xfer->rx_dma)) {
-			SPIDEV_LOG("dma mapping rx_buf error.\n");
-			return -ENOMEM;	
-		}
-#ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT
-		SPIDEV_LOG("Transfer addr:Tx:0x%llx, Rx:0x%llx, before\n", xfer->tx_dma,xfer->rx_dma);
-#else
-		SPIDEV_LOG("Transfer addr:Tx:0x%x, Rx:0x%x, before\n", xfer->tx_dma,xfer->rx_dma);
-#endif
-		xfer->len=32;
-#if 0
-		p= (u8*)xfer->tx_dma;
-		xfer->tx_dma = (u32)(p+ SPI_CROSS_ALIGN_OFFSET);
-		p= (u8*)xfer->rx_dma;
-		xfer->rx_dma = (u32)(p+ SPI_CROSS_ALIGN_OFFSET);
-
-		p= (u8*)xfer->tx_buf;
-		xfer->tx_buf =(u32*)(p+ SPI_CROSS_ALIGN_OFFSET);
-		p= (u8*)xfer->rx_buf;
-		xfer->rx_buf =(u32*)(p+ SPI_CROSS_ALIGN_OFFSET);
-#else
-		xfer->tx_dma += SPI_CROSS_ALIGN_OFFSET;
-		xfer->rx_dma += SPI_CROSS_ALIGN_OFFSET;
-
-		xfer->tx_buf += SPI_CROSS_ALIGN_OFFSET;
-		xfer->rx_buf += SPI_CROSS_ALIGN_OFFSET;
-#endif
-#ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT
-		SPIDEV_LOG("Transfer addr:Tx:0x%llx, Rx:0x%llx\n", xfer->tx_dma,xfer->rx_dma);
-#else
-		SPIDEV_LOG("Transfer addr:Tx:0x%x, Rx:0x%x\n", xfer->tx_dma,xfer->rx_dma);
-#endif
-		SPIDEV_LOG("Transfer addr:Tx:0x%p, Rx:0x%p\n", xfer->tx_buf,xfer->rx_buf);
-		//for ( i = 0; i < cnt; i++ )
-		//	*(( u32 * )xfer->tx_buf + i) = tx_buffer + i;
-	}else{
-	return -EINVAL;
-	}
-	return 0;
-	
-}
-static inline int 
-is_last_xfer(struct spi_message *msg, struct spi_transfer *xfer)
-{
-	return msg->transfers.prev == &xfer->transfer_list;
-}
-
-static int spi_recv_check(struct spi_message *msg)
-{
-
-	struct spi_transfer *xfer;
-	u32 cnt, i, err=0;
-	
-	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
-
-		if (!xfer) {
-			SPIDEV_MSG ( "rv msg is NULL.\n" );
-			return -1;
-		}
-//			SPIDEV_LOG("xfer:0x%p, length is:%d\n", xfer,xfer->len);
-		cnt = (xfer->len%4)?(xfer->len/4 + 1):(xfer->len/4);
-		for(i=0; i<cnt; i++){
-			if(*( ( u32 * ) xfer->rx_buf + i ) != *( ( u32 * ) xfer->tx_buf + i )){ 					
-				SPIDEV_LOG("tx xfer %d is:%.8x\n",i,  *( ( u32 * ) xfer->tx_buf + i ) );
-				SPIDEV_LOG("rx xfer %d is:%.8x\n",i,  *( ( u32 * ) xfer->rx_buf + i ) ); 
-				//SPIDEV_LOG("tx xfer %d dma is:%.8x\n",i,  ( ( u32 * )xfer->tx_dma + i ) );
-				//SPIDEV_LOG("rx xfer %d dma is:%.8x\n",i,  ( ( u32 * )xfer->rx_dma + i ) );
-				SPIDEV_LOG("\n");
-				err++;
-			}
-		}
-		//memset(xfer->tx_buf,0,xfer->len);
-		//memset(xfer->rx_buf,0,xfer->len);
-		kfree(xfer->tx_buf);
-		kfree(xfer->rx_buf);
-	}
-	
-		SPIDEV_LOG("Message:0x%p,error %d,actual xfer length is:%d\n", msg,err, msg->actual_length);
-
-	return err;
-	
-}
-static int spi_recv_check_all(struct spi_device *spi, struct spi_message *msg)
-{
-
-	struct spi_transfer *xfer;
-	u32 i, err=0;
-	int j;
-	u8 rec_cac = 0;
-	
-	struct mt_chip_conf *chip_config;
-	chip_config = (struct mt_chip_conf *) spi->controller_data;
-	
-	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
-
-		if (!xfer) {
-			SPIDEV_MSG ( "rv msg is NULL.\n" );
-			return -1;
-		}
-//			SPIDEV_LOG("xfer:0x%p, length is:%d\n", xfer,xfer->len);
-//		cnt = (xfer->len%4)?(xfer->len/4 + 1):(xfer->len/4);
-		for(i=0; i<xfer->len; i++){
-			if(chip_config->tx_mlsb ^ chip_config->rx_mlsb){
-				rec_cac = 0;
-				for(j=7;j>=0;j--){
-					rec_cac |= ((*((u8 *)xfer->tx_buf + i) & (1<<j)) >> j)<< (7-j);					
-				}				
-				//SPIDEV_LOG("rec_cac %x :%x\n",rec_cac,	*( ( u8 * ) xfer->tx_buf + i ) );
-				
-			}else{
-				rec_cac = *( ( u8 * ) xfer->tx_buf + i );
-			}
-			if(*( ( u8 * ) xfer->rx_buf + i ) != rec_cac ){ 					
-				SPIDEV_LOG("tx xfer %d is:%x\n",i,  *( ( u8 * ) xfer->tx_buf + i ) );
-				SPIDEV_LOG("rx xfer %d is:%x\n",i,  *( ( u8 * ) xfer->rx_buf + i ) ); 
-				err++;
-			}
-		}
-		kfree(xfer->tx_buf);
-		kfree(xfer->rx_buf);
-	}
-	
-		SPIDEV_LOG("Message:0x%p,error %d,actual xfer length is:%d\n", msg,err, msg->actual_length);
-
-	return err;
-	
-}
-
-static void spi_complete(void *arg)
-{
-	static u32 i = 0;
-	stress_err += spi_recv_check((struct spi_message *)arg);
-	if(stress_err > 0){
-		
-		SPIDEV_LOG("Message transfer err:%d\n", stress_err);
-//		BUG();
-	}
-		
-//		SPIDEV_LOG("Message:%d\n", i);
-	if(++i == SPI_STRESS_MAX){
-		i = 0;
-		complete(&mt_spi_done);
-	}
-}
-
-
-static int threadfunc1(void *data)
-{
-	struct spi_transfer transfer;
-	struct spi_message msg;
-	struct spi_device *spi=(struct spi_device *) data;
-	u32 len= 8;
-	int ret;	
-
-	while(1){
-		spi_message_init(&msg);
-		
-		set_current_state(TASK_INTERRUPTIBLE);
-		if(kthread_should_stop()) break;
-		
-		spi_setup_xfer(&spi->dev,&transfer,len,0);
-		spi_message_add_tail(&transfer, &msg);
-		ret = spi_sync(spi, &msg);
-		if(ret < 0){
-			stress_err ++;
-			SPIDEV_LOG("Message transfer err:%d\n", ret);
-		}else{
-			ret = spi_recv_check(&msg);
-			if(ret != 0){
-				stress_err += ret;					
-				SPIDEV_LOG("thread Message transfer err:%d\n", ret);
-			}
-		}
-		schedule_timeout(HZ);
-	}
-	return 0;
-}
-static int threadfunc2(void *data)
-{
-	struct spi_transfer transfer;
-	struct spi_message msg;	
-	struct spi_device *spi=(struct spi_device *) data;
-	
-	u32 len= 128;
-	int ret;
-
-	while(1){
-		spi_message_init(&msg);
-		
-		set_current_state(TASK_INTERRUPTIBLE);
-		if(kthread_should_stop()) break;
-		
-		spi_setup_xfer(&spi->dev,&transfer,len,0);
-		spi_message_add_tail(&transfer, &msg);
-		ret = spi_sync(spi, &msg);
-		if(ret < 0){
-			stress_err ++;
-			SPIDEV_LOG("Message transfer err:%d\n", ret);
-		}else{
-			ret = spi_recv_check(&msg);
-			if(ret != 0){
-				stress_err += ret;					
-				SPIDEV_LOG("thread Message transfer err:%d\n", ret);
-			}
-		}
-		schedule_timeout(HZ);
-	}
-	return 0;
-}
-static int threadfunc3(void *data)
-{
-	//struct spi_transfer transfer;
-	struct spi_message msg;	
-	struct spi_device *spi=(struct spi_device *) data;
-	static struct spi_message *p;
-	u32 len= 64;
-	int ret;
-	u16 i;
-	
-	while(1){
-		spi_message_init(&msg);
-		
-		set_current_state(TASK_INTERRUPTIBLE);
-		if(kthread_should_stop()) break;
-		
-		p = stress_msg;
-		for(i=0;i<SPI_STRESS_MAX;i++){
-			spi_message_init(p);
-			ret = spi_setup_xfer(&spi->dev,&stress_xfer[i],len,0);
-			if(ret != 0){									
-				SPIDEV_LOG("xfer set up err:%d\n", ret);
-			}
-			spi_message_add_tail(&stress_xfer[i], p);
-		
-			p->complete = spi_complete;
-			p->context = p;
-			ret = spi_async(spi, p);
-			if(ret < 0){
-				SPIDEV_LOG("Message %d transfer err:%d\n",i, ret);
-			}
-			p ++;
-		}
-		
-		wait_for_completion(&mt_spi_done);
-
-		schedule_timeout(5*HZ);
-	}
-	return 0;
-}
-static int threadfunc4(void *data)
-{
-	//struct spi_transfer transfer;
-	struct spi_message msg;	
-	struct spi_device *spi=(struct spi_device *) data;
-
-	u32 len= 32;
-	int ret;
-	u16 i;
-	
-	while(1){
-		spi_message_init(&msg);
-		
-		set_current_state(TASK_INTERRUPTIBLE);
-		if(kthread_should_stop()) break;
-		
-	
-		for(i=0;i<SPI_STRESS_MAX;i++){			
-			ret = spi_setup_xfer(&spi->dev,&stress_xfer_con[i],len,1);
-			if(ret != 0){									
-				SPIDEV_LOG("Message set up err:%d\n", ret);
-			}
-			spi_message_add_tail(&stress_xfer_con[i], &msg);
-			
-		}
-		ret = spi_sync(spi, &msg);
-		if(ret < 0){
-			SPIDEV_LOG("Message transfer err:%d\n", ret);
-		}else{
-			ret = spi_recv_check(&msg);
-			if(ret != 0){
-				ret -= ret;
-				stress_err += ret;
-				SPIDEV_LOG("Message transfer err:%d\n", ret);
-			}
-//				SPIDEV_LOG("Message multi xfer stress pass\n");
-		}
-
-		schedule_timeout(2*HZ);
-	}
-	return 0;
-}
-
-#ifdef CONFIG_TRUSTONIC_TEE_SUPPORT
-extern int secspi_session_open(void);
-extern int secspi_execute(u32 cmd, tciSpiMessage_t *param);
-#endif
-
-static ssize_t spi_store(struct device *dev, 
-	struct device_attribute *attr, 
-	const char *buf, size_t count)
-{
-	struct spi_device *spi;
-
-	struct mt_chip_conf *chip_config;
-	
-	u32 setuptime, holdtime, high_time, low_time;
-	u32 cs_idletime, ulthgh_thrsh;
-	int cpol, cpha,tx_mlsb, rx_mlsb, tx_endian, sample_sel, cs_pol;
-	int rx_endian, com_mod, pause, finish_intr;
-	int deassert, tckdly, ulthigh;
-	
-	spi = container_of(dev, struct spi_device, dev);
-
-	SPIDEV_LOG("SPIDEV name is:%s\n", spi->modalias);
-
-	chip_config = (struct mt_chip_conf *) spi->controller_data;
-
-	if (!chip_config) {
-		SPIDEV_LOG ( "chip_config is NULL.\n");
-		chip_config = kzalloc ( sizeof ( struct mt_chip_conf ), GFP_KERNEL );
-		if ( !chip_config ) 
-			return -ENOMEM;
-	}	
-#ifdef CONFIG_TRUSTONIC_TEE_SUPPORT
-	if (!strncmp(buf, "-1", 2 ) ) { /*TRANSFER*/
-		    SPIDEV_MSG("start to access TL SPI driver.\n");
-			secspi_session_open();
-			secspi_execute(1, NULL);
-			SPIDEV_MSG("secspi_execute 1 finished!!!\n");
-	}else if(!strncmp(buf, "-2", 2 ) ) { /*HW CONFIG*/
-		    SPIDEV_MSG("start to access TL SPI driver.\n");
-			secspi_session_open();
-			secspi_execute(2, NULL);
-			SPIDEV_MSG("secspi_execute 2 finished!!!\n");
-	}else if(!strncmp(buf, "-3", 2 ) ) { /*DEBUG*/
-		    SPIDEV_MSG("start to access TL SPI driver.\n");
-			secspi_session_open();
-			secspi_execute(3, NULL);
-			SPIDEV_MSG("secspi_execute 3 finished!!!\n");
-	}else if(!strncmp(buf, "-4", 2 ) ) { /*TEST*/
-		    SPIDEV_MSG("start to access TL SPI driver.\n");
-			secspi_session_open();
-			secspi_execute(4, NULL);
-			SPIDEV_MSG("secspi_execute 4 finished!!!\n");
-#else
-	if (!strncmp(buf, "-h", 2 ) ) {
-		SPIDEV_MSG("Please input the parameters for this device.\n");
-#endif
-	} else if ( !strncmp(buf, "-w", 2 ) ) {
-		buf += 3;
-		if (!buf) {
-			SPIDEV_LOG("buf is NULL.\n");
-			goto out;
-		}
-		if (!strncmp(buf, "setuptime=",10) && (1 == sscanf(buf+10, "%d", &setuptime))) {
-			SPIDEV_MSG("setuptime is:%d\n", setuptime);
-			chip_config->setuptime=setuptime;
-		}else if (!strncmp(buf, "holdtime=", 9)&&(1==sscanf(buf+9, "%d", &holdtime))) {
-			SPIDEV_MSG("Set holdtime is:%d\n", holdtime);
-			chip_config->holdtime=holdtime;	
-		}else if (!strncmp(buf, "high_time=", 10)&&(1==sscanf(buf+10, "%d", &high_time))) {
-			SPIDEV_MSG("Set high_time is:%d\n", high_time);
-			chip_config->high_time=high_time;	
-		}else if (!strncmp(buf, "low_time=", 9)&&(1==sscanf(buf+9, "%d", &low_time))) {
-			SPIDEV_MSG("Set low_time is:%d\n", low_time);
-			chip_config->low_time=low_time;
-		}else if (!strncmp(buf, "cs_idletime=", 12)&&(1==sscanf(buf+12, "%d", &cs_idletime))) {
-			SPIDEV_MSG("Set cs_idletime is:%d\n", cs_idletime);
-			chip_config->cs_idletime=cs_idletime;	
-		}else if (!strncmp(buf, "ulthgh_thrsh=", 13)&&(1==sscanf(buf+13, "%d", &ulthgh_thrsh))) {
-			SPIDEV_MSG("Set slwdown_thrsh is:%d\n", ulthgh_thrsh);
-			chip_config->ulthgh_thrsh=ulthgh_thrsh; 
-		}else if (!strncmp(buf, "cpol=", 5) && (1 == sscanf(buf+5, "%d", &cpol))){
-			SPIDEV_MSG("Set cpol is:%d\n", cpol);
-			chip_config->cpol = cpol;
-		}else if (!strncmp(buf, "cpha=", 5) && (1 == sscanf(buf+5, "%d", &cpha))) {
-			SPIDEV_MSG("Set cpha is:%d\n", cpha);
-			chip_config->cpha = cpha;
-		}else if (!strncmp(buf, "tx_mlsb=", 8)&&(1==sscanf(buf+8, "%d", &tx_mlsb))) {
-			SPIDEV_MSG("Set tx_mlsb is:%d\n", tx_mlsb);
-			chip_config->tx_mlsb=tx_mlsb;	
-		}else if (!strncmp(buf, "rx_mlsb=", 8)&&(1==sscanf(buf+8, "%d", &rx_mlsb))) {
-			SPIDEV_MSG("Set rx_mlsb is:%d\n", rx_mlsb);
-			chip_config->rx_mlsb=rx_mlsb;	
-		}else if (!strncmp(buf, "tx_endian=", 10)&&(1==sscanf(buf+10, "%d", &tx_endian))) {
-			SPIDEV_MSG("Set tx_endian is:%d\n", tx_endian);
-			chip_config->tx_endian=tx_endian;	
-		}else if (!strncmp(buf, "rx_endian=", 10)&&(1==sscanf(buf+10, "%d", &rx_endian))) {
-			SPIDEV_MSG("Set rx_endian is:%d\n", rx_endian);
-			chip_config->rx_endian=rx_endian;	
-		}else if (!strncmp(buf, "com_mod=", 8)&&(1==sscanf(buf+8, "%d", &com_mod))) {
-			chip_config->com_mod=com_mod;
-			SPIDEV_MSG("Set com_mod is:%d\n", com_mod);
-		}else if (!strncmp(buf, "pause=", 6)&&(1==sscanf(buf+6, "%d", &pause))) {
-			SPIDEV_MSG("Set pause is:%d\n", pause);
-			chip_config->pause=pause;
-		}else if (!strncmp(buf, "finish_intr=", 12)&&(1==sscanf(buf+12, "%d", &finish_intr))) {
-			SPIDEV_MSG("Set finish_intr is:%d\n", finish_intr);
-			chip_config->finish_intr=finish_intr;
-		}else if (!strncmp(buf, "deassert=", 9)&&(1==sscanf(buf+9, "%d", &deassert))) {
-			SPIDEV_MSG("Set deassert is:%d\n", deassert);
-			chip_config->deassert=deassert;	
-		}else if (!strncmp(buf, "ulthigh=", 8 ) && ( 1 == sscanf(buf+8, "%d", &ulthigh))) {
-			SPIDEV_MSG("Set ulthigh is:%d\n", ulthigh);	
-			chip_config->ulthigh=ulthigh;
-		}else if (!strncmp(buf, "tckdly=",7) && ( 1 == sscanf(buf+7, "%d", &tckdly))) {
-			SPIDEV_MSG("Set tckdly is:%d\n", tckdly);
-			chip_config->tckdly=tckdly;
-		}else if (!strncmp(buf, "sample_sel=", 11 ) && ( 1 == sscanf(buf+11, "%d", &sample_sel))) {
-			SPIDEV_MSG("Set sample_sel is:%d\n", sample_sel);	
-			chip_config->sample_sel=sample_sel;
-		}else if (!strncmp(buf, "cs_pol=",7) && ( 1 == sscanf(buf+7, "%d", &cs_pol))) {
-			SPIDEV_MSG("Set cs_pol is:%d\n", cs_pol);
-			chip_config->cs_pol=cs_pol;
-		}else {
-			SPIDEV_LOG("Wrong parameters.\n");
-			goto out;
-		}
-		spi->controller_data = chip_config;
-//			spi_setup(spi);
-			
-	}
-out:
-	return count;
-}
-
-static int tc_spi_cross_1k(struct spi_device *spi)
-{
-	int ret=0;
-	//struct spi_transfer transfer;
-	//struct spi_message msg;
-	//spi_setup_xfer(&transfer,2048,2);
-	//spi_message_add_tail ( &transfer, &msg );
-	//msg.is_dma_mapped=1;
-	//ret = spi_sync ( spi_test, &msg );
-	//if(ret < 0){
-	//	SPIDEV_LOG("Message transfer err:%d\n", ret);
-	//}else{
-	//	ret = spi_recv_check(&msg);
-	//}
-	return ret;
-}
-static ssize_t 
-spi_msg_store(struct device *dev, struct device_attribute *attr, 
-				const char *buf, size_t count)
-{
-	//struct spi_transfer *xfer;
-	//struct spi_message *msg_str;
-	struct spi_message *p;
-
-	int ret = 0;
-	struct spi_device *spi;
-
-	struct spi_transfer transfer;
-	struct spi_transfer transfer2;
-	struct spi_transfer transfer3;
-	struct spi_message msg;
-	struct mt_chip_conf *chip_config;
-
-	u32 i, len=4;
-	u32 tx_buffer = 0x12345678;
-	u32 rx_buffer = 0xaaaaaaaa;
-
-	transfer.tx_buf = &tx_buffer;
-	transfer.rx_buf = &rx_buffer;
-	transfer.len = 4;	
-	
-	spi = container_of ( dev, struct spi_device, dev );
-
-	if(unlikely(!spi)){
-		SPIDEV_LOG ( "spi device is invalid\n" );
-		goto out;
-	}
-	if(unlikely(!buf)){
-		SPIDEV_LOG("buf is invalid\n" );
-		goto out;
-	}
-	spi_message_init(&msg);
-	
-	if( !strncmp ( buf, "-h", 2 ) ) {
-		SPIDEV_MSG("Please input the message \
-			of this device to send and receive. \n" );
-	}else if(!strncmp(buf, "-w", 2)) {
-		buf += 3;
-		if (!buf) {
-			SPIDEV_LOG("Parameter is not enough.\n");
-			goto out;
-		}
-		if (!strncmp ( buf, "len=", 4 ) && 1 == sscanf ( buf+4, "%d", &len ) ) {
-			spi_setup_xfer(&spi->dev,&transfer,len,0);
-			spi_message_add_tail ( &transfer, &msg );
-			ret = spi_sync ( spi, &msg );
-			if(ret < 0){
-				SPIDEV_LOG("Message transfer err:%d\n", ret);
-			}else{
-				ret = spi_recv_check_all(spi,&msg);
-				if(ret != 0){
-					ret = -ret;					
-					SPIDEV_LOG("Message transfer err:%d\n", ret);
-					goto out;
-				}
-			}				
-		}
-	}else if(!strncmp(buf, "-func", 5)) {
-		buf += 6;
-		if (!buf) {
-			SPIDEV_LOG("Parameter is not enough.\n");
-			goto out;
-		}
-		if (!strncmp ( buf, "len=", 4 ) && 1 == sscanf ( buf+4, "%d", &len ) ) {
-			spi_setup_xfer(&spi->dev,&transfer,len,1);
-			spi_message_add_tail ( &transfer, &msg );
-			ret = spi_sync ( spi, &msg );
-			if(ret < 0){
-				SPIDEV_LOG("Message transfer err:%d\n", ret);
-			}else{
-				ret = spi_recv_check(&msg);
-				if(ret != 0){
-					ret = -ret;					
-					SPIDEV_LOG("Message transfer err:%d\n", ret);
-					goto out;
-				}
-			}				
-		}
-		if (!strncmp ( buf, "cross", 5 )) {
-			ret = tc_spi_cross_1k(spi);
-			if(ret < 0){
-				SPIDEV_LOG("Message transfer err:%d\n", ret);
-			}else if(ret != 0){
-				ret = -ret;					
-				SPIDEV_LOG("Message transfer err:%d\n", ret);
-				goto out;
-			}
-		}				
-	}else if(!strncmp(buf, "-err", 4)) {
-		buf += 5;
-		chip_config = (struct mt_chip_conf *) spi->controller_data;
-		
-		if(!strncmp(buf, "buf", 3)) {	//case: tx_buf = NULL,rx_buf = NULL		
-			transfer.len = 8;
-			transfer.tx_buf = NULL;
-			transfer.rx_buf = NULL;
-		}else if(!strncmp(buf, "len", 3)){//case: tx_buf != NULL,rx_buf != NULL, len = 0
-			transfer.len = 0;
-			transfer.tx_buf = ( u32 * ) kzalloc ( 8, GFP_KERNEL);
-			transfer.rx_buf = ( u32 * ) kzalloc ( 8, GFP_KERNEL);
-		}else if(!strncmp(buf, "nomem", 5)){//case: DMA mapping error
-			spi_setup_xfer(&spi->dev,&transfer,8,0);
-		}else if(!strncmp(buf, "fifo_len", 8)){//case: len exceed FIFO size
-			chip_config->com_mod = 0;
-			spi_setup_xfer(&spi->dev,&transfer,33,0);
-		}else if(!strncmp(buf, "dma_len", 7)){//case: len exceed DMA size
-			chip_config->com_mod = 1;
-			spi_setup_xfer(&spi->dev,&transfer,1025,0);
-		}else if(!strncmp(buf, "xfer", 4)){//case: len exceed DMA size
-			;
-		}else if(!strncmp(buf, "msg", 3)){//case: len exceed DMA size
-			;
-		}else{
-			SPIDEV_LOG("Error test Wrong parameters.\n");
-			ret = -1;
-			goto out;
-		}
-		
-		if(strncmp(buf, "xfer", 4)){	//case: MSG empty
-			spi_message_add_tail(&transfer, &msg);
-		}
-		if(!strncmp(buf, "msg", 3)) {	//case: message = NULL	
-			ret = spi_sync(spi, NULL);
-				
-		}else{
-			ret = spi_sync(spi, &msg);			
-		}		
-		if(ret != -EINVAL){
-				return -100;
-		}else{			
-			SPIDEV_LOG("Message transfer error test passed ret:%d\n", ret);
-		}
-	}else if( !strncmp(buf, "-pause", 6)){
-		spi_setup_xfer(&spi->dev,&transfer,32,0);
-		spi_message_add_tail(&transfer, &msg);
-		spi_setup_xfer(&spi->dev,&transfer2,1024,0);
-		spi_message_add_tail(&transfer2, &msg);
-		spi_setup_xfer(&spi->dev,&transfer3,32,0);
-		spi_message_add_tail(&transfer3, &msg);
-		
-		ret = spi_sync(spi, &msg);
-		if(ret < 0){
-			SPIDEV_LOG("Message transfer err:%d\n", ret);
-		}else{
-			ret = spi_recv_check(&msg);
-			if(ret != 0){
-				ret = -ret;					
-				printk(KERN_ERR"Message transfer err:%d\n", ret);
-			}
-		}		
-	}else if(!strncmp(buf, "-stress", 7)){
-		sscanf ( buf+8, "%d", &len );
-		stress_err = 0;	
-		if(len == 0){
-	//			xfer = (struct spi_transfer *)kzalloc(SPI_STRESS_MAX*sizeof( struct spi_transfer) , GFP_KERNEL);
-			//will release in spi_recv_check() function
-			SPIDEV_LOG("Message multi xfer stress start\n");
-			for(i=0;i<SPI_STRESS_MAX;i++){			
-				ret = spi_setup_xfer(&spi->dev,&stress_xfer[i],32,0);
-				if(ret != 0){									
-					SPIDEV_LOG("Message set up err:%d\n", ret);
-				}
-				spi_message_add_tail(&stress_xfer[i], &msg);
-				
-			}
-			ret = spi_sync(spi, &msg);
-			if(ret < 0){
-				SPIDEV_LOG("Message transfer err:%d\n", ret);
-			}else{
-				ret = spi_recv_check(&msg);
-				if(ret != 0){
-					ret = -ret;					
-					SPIDEV_LOG("Message transfer err:%d\n", ret);
-				}else{
-					SPIDEV_LOG("Message multi xfer stress pass\n");
-				}
-			}
-		}else if(len == 1){	
-			int loop_count = 0;
-			//loop_count  =250, take aboat half a hour.
-			for(loop_count=0;loop_count <= 5000;loop_count ++){
-		//			msg_str = (struct spi_message *)kzalloc(SPI_STRESS_MAX * sizeof(struct spi_message) , GFP_KERNEL);
-		//			xfer = ( struct spi_transfer * )kzalloc(SPI_STRESS_MAX * sizeof(struct spi_transfer) , GFP_KERNEL);
-				SPIDEV_LOG("Message multi msg stress start\n");
-				p = stress_msg;
-				for(i=0;i<SPI_STRESS_MAX;i++){
-					spi_message_init(p);
-					ret = spi_setup_xfer(&spi->dev,&stress_xfer[i],32,0);
-					if(ret != 0){									
-						SPIDEV_LOG("xfer set up err:%d\n", ret);
-					}
-					spi_message_add_tail(&stress_xfer[i], p);
-				
-					p->complete = spi_complete;
-					p->context = p;
-		//				ret = spi_async(spi, p);
-		//				if(ret < 0){
-		//					SPIDEV_LOG("Message %d transfer err:%d\n",i, ret);
-		//				}
-					p ++;
-				}
-				p = stress_msg;
-				for(i=0;i<SPI_STRESS_MAX;i++){
-					ret = spi_async(spi, p);
-					if(ret < 0){
-						SPIDEV_LOG("Message %d transfer err:%d\n",i, ret);
-					}
-					p++;
-				}
-				wait_for_completion(&mt_spi_done);
-			}
-	//			kfree(msg_str);
-			if(stress_err != 0){
-				ret = -stress_err;					
-				stress_err = 0;
-				SPIDEV_LOG("Message stress err:%d\n", ret);
-			}else{
-				SPIDEV_LOG("Message stress Pass\n");
-				ret = 0;
-			}
-		}else{
-		}	
-	}else if(!strncmp(buf, "-concurrent", 11)){
-
-		stress_err = 0;
-		spi_concur1 = kthread_run(threadfunc1,(void *)spi,"spi_concrrent1");
-		if(IS_ERR(spi_concur1)){
-			SPIDEV_LOG("Unable to start kernelthread 1\n");
-			ret = -5;
-			goto out;
-		}
-		spi_concur2 = kthread_run(threadfunc2,(void *)spi,"spi_concrrent2");
-		if(IS_ERR(spi_concur2)){
-			SPIDEV_LOG("Unable to start kernelthread 2\n");
-			ret = -5;
-			goto out;
-		}
-		spi_concur3 = kthread_run(threadfunc3,(void *)spi,"spi_concrrent3");
-		if(IS_ERR(spi_concur3)){
-			SPIDEV_LOG("Unable to start kernelthread 3\n");
-			ret = -5;
-			goto out;
-		}
-		spi_concur4 = kthread_run(threadfunc4,(void *)spi,"spi_concrrent4");
-		if(IS_ERR(spi_concur4)){
-			SPIDEV_LOG("Unable to start kernelthread 4\n");
-			ret = -5;
-			goto out;
-		}
-
-		msleep(10000);
-		SPIDEV_LOG("stop kernelthread \n");
-
-		kthread_stop(spi_concur1);
-		kthread_stop(spi_concur2);
-		kthread_stop(spi_concur3);
-		kthread_stop(spi_concur4);
-		ret = -stress_err;
-		stress_err = 0;
-		SPIDEV_LOG("concurrent test done %d\n\n\n",ret);
-		
-	}else{
-		SPIDEV_LOG("Wrong parameters.\n");
-		ret = -1;
-		goto out;
-	}
-	ret = count;
-
-out:
-	return ret;
-		
-}
-
-static DEVICE_ATTR(spi, 0200, NULL, spi_store);
-static DEVICE_ATTR(spi_msg, 0200, NULL, spi_msg_store);
-
-
-
-static struct device_attribute *spi_attribute[]={
-	&dev_attr_spi,
-	&dev_attr_spi_msg,
-};
-
-static int spi_create_attribute(struct device *dev)
-{
-	int num,idx;
-	int err =0;
-	num = (int)(sizeof(spi_attribute)/sizeof(spi_attribute[0]));
-
-	for (idx = 0; idx < num; idx ++) {
-		if ((err = device_create_file(dev, spi_attribute[idx])))
-			break;
-	}
-	return err;
-	
-}
-
-static void spi_remove_attribute(struct device *dev)
-{
-	int num, idx;
-	num = (int)(sizeof(spi_attribute)/sizeof(spi_attribute[0]));
-
-	for (idx = 0; idx < num; idx ++) {
-		device_remove_file(dev, spi_attribute[idx]);
-	}
-
-	return;
-}
-
-static int spi_test_remove(struct spi_device *spi)
-{
-
-	SPIDEV_LOG("spi_test_remove.\n");
-	spi_remove_attribute(&spi->dev);
-	return 0;
-}
-
-static int __init spi_test_probe(struct spi_device *spi)
-{
-	SPIDEV_LOG("spi test probe  enter\n");
-	spi_test=spi;
-	spi->mode = SPI_MODE_3;
-	spi->bits_per_word = 32;
-	return spi_create_attribute( &spi->dev );
-	return 0;
-}
-
-//struct spi_device_id spi_id_table = {"test_spi", 0};
-struct spi_device_id spi_id_table = {"spi-ut", 0};
-
-static struct spi_driver spi_test_driver = {
-	.driver = {
-		.name = "test_spi",
-		.bus = &spi_bus_type,
-		.owner = THIS_MODULE,
-	},
-	.probe = spi_test_probe,
-	.remove=spi_test_remove,
-	.id_table = &spi_id_table,
-};
-static struct spi_board_info spi_board_devs[] __initdata = {
-//remove by zhu
-	[0] = {
-        	.modalias="spi-ut",
-		.bus_num = 0,
-		.chip_select=1,
-		.mode = SPI_MODE_3,
-	},//remove by zhu
-	//by zhu
-  [1] = {
-        	.modalias="eh570",
-		.bus_num = 0,
-		.chip_select=0,
-		.mode = SPI_MODE_3,
-	},
-};
-
-static int __init spi_dev_init(void)
-{
-	SPIDEV_LOG("SPI_DEV_INIT.\n");
-	spi_register_board_info(spi_board_devs, ARRAY_SIZE(spi_board_devs));
-	return spi_register_driver(&spi_test_driver);
-}
-
-static void __exit spi_test_exit(void)
-{
-	SPIDEV_LOG("SPI_DEV_EXIT.\n");
-	spi_unregister_driver(&spi_test_driver);
-	
-	return;
-}
-
-module_init(spi_dev_init);
-module_exit(spi_test_exit);
-
-MODULE_DESCRIPTION ( "mt SPI test device driver" );
-MODULE_AUTHOR ( "Ranran Lu <ranran.lu@mediatek.com>" );
-MODULE_LICENSE("GPL");
diff --git a/drivers/misc/mediatek/thermal/mt6735/mtk_cooler_bcct.c~ b/drivers/misc/mediatek/thermal/mt6735/mtk_cooler_bcct.c~
deleted file mode 100755
index de606d5..0000000
--- a/drivers/misc/mediatek/thermal/mt6735/mtk_cooler_bcct.c~
+++ /dev/null
@@ -1,478 +0,0 @@
-#include <linux/version.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/kobject.h>
-#include <linux/proc_fs.h>
-#include <linux/seq_file.h>
-#include <asm/uaccess.h>
-#include <linux/err.h>
-#include <linux/syscalls.h>
-#include "mach/mtk_thermal_monitor.h"
-#include <mach/charging.h>
-#include "cust_charging.h"
-// Extern two API functions from battery driver to limit max charging current.
-#if 1
-/**
- *  return value means charging current in mA
- *  -1 means error
- *  Implementation in mt_battery.c and mt_battery_fan5405.c
- */
-extern int get_bat_charging_current_level(void);
-
-/**
- *  current_limit means limit of charging current in mA
- *  -1 means no limit
- *  Implementation in mt_battery.c and mt_battery_fan5405.c
- */
-extern int set_bat_charging_current_limit(int current_limit);
-#endif
-
-extern struct proc_dir_entry * mtk_thermal_get_proc_drv_therm_dir_entry(void);
-
-#define mtk_cooler_bcct_dprintk_always(fmt, args...) \
-  do { pr_notice("[thermal/cooler/bcct]" fmt, ##args); } while(0)
-
-#define mtk_cooler_bcct_dprintk(fmt, args...) \
-  do { \
-    if (1 == cl_bcct_klog_on) { \
-      pr_notice("[thermal/cooler/bcct]" fmt, ##args); \
-    } \
-  } while(0)
-
-#define MAX_NUM_INSTANCE_MTK_COOLER_BCCT  3
-
-#define MTK_CL_BCCT_GET_LIMIT(limit, state) \
-    do { (limit) = (short) (((unsigned long) (state))>>16); } while(0)
-
-#define MTK_CL_BCCT_SET_LIMIT(limit, state) \
-    do { state = ((((unsigned long) (state))&0xFFFF) | ((short) limit<<16)); } while(0)
-
-#define MTK_CL_BCCT_GET_CURR_STATE(curr_state, state) \
-    do { curr_state = (((unsigned long) (state))&0xFFFF); } while(0)
-
-#define MTK_CL_BCCT_SET_CURR_STATE(curr_state, state) \
-    do { if (0 == curr_state) \
-           state &= ~0x1; \
-         else \
-           state |= 0x1; \
-    } while(0)
-
-static int cl_bcct_klog_on = 0;
-static struct thermal_cooling_device *cl_bcct_dev[MAX_NUM_INSTANCE_MTK_COOLER_BCCT] = {0};
-static unsigned long cl_bcct_state[MAX_NUM_INSTANCE_MTK_COOLER_BCCT] = {0};
-static int cl_bcct_cur_limit = 65535;
-extern CHARGER_TYPE mt_get_charger_type(void);
-
-static void
-mtk_cl_bcct_set_bcct_limit(void)
-{
-	// TODO: optimize
-	int i = 0;
-	int min_limit = 65535;
-	for (; i < MAX_NUM_INSTANCE_MTK_COOLER_BCCT; i++)
-	{
-		unsigned long curr_state;
-
-		MTK_CL_BCCT_GET_CURR_STATE(curr_state, cl_bcct_state[i]);
-		if (1 == curr_state)
-		{
-			int limit;
-			MTK_CL_BCCT_GET_LIMIT(limit, cl_bcct_state[i]);
-			if ((min_limit > limit) && (limit > 0))
-			min_limit = limit;
-		}
-	}
-
-	if (min_limit != cl_bcct_cur_limit)
-	{
-		cl_bcct_cur_limit = min_limit;
-
-		if (65535 <= cl_bcct_cur_limit)
-		{
-			set_bat_charging_current_limit(-1);
-			mtk_cooler_bcct_dprintk_always("mtk_cl_bcct_set_bcct_limit() limit=-1\n");
-		}
-		else
-		{
-			/*
-			CHARGER_UNKNOWN = 0,
-			STANDARD_HOST,      // USB : 450mA
-			CHARGING_HOST,
-			NONSTANDARD_CHARGER,// AC : 450mA~1A
-			STANDARD_CHARGER,  	// AC : ~1A
-			APPLE_2_1A_CHARGER, // 2.1A apple charger
-			APPLE_1_0A_CHARGER, // 1A apple charger
-			APPLE_0_5A_CHARGER, // 0.5A apple charger
-			WIRELESS_CHARGER,
-			*/
-			if(mt_get_charger_type()==STANDARD_HOST)//usb charger
-			{
-				mtk_cooler_bcct_dprintk_always("Current is USB charger, limit=%d\n",cl_bcct_cur_limit);
-				if(cl_bcct_cur_limit >= 500)//if usb charger, max current can't > 500mA
-				{
-				set_bat_charging_current_limit(499);
-				}
-				else
-				{
-				set_bat_charging_current_limit(cl_bcct_cur_limit);
-				}
-			}
-			else
-			{
-				set_bat_charging_current_limit(cl_bcct_cur_limit);
-			}
-			mtk_cooler_bcct_dprintk_always("mtk_cl_bcct_set_bcct_limit() limit=%d\n", cl_bcct_cur_limit);
-		}
-
-		mtk_cooler_bcct_dprintk_always("mtk_cl_bcct_set_bcct_limit() real limit=%d\n", get_bat_charging_current_level()/100);
-
-	}
-}
-
-static int 
-mtk_cl_bcct_get_max_state(struct thermal_cooling_device *cdev,
-                          unsigned long *state)
-{        
-  *state = 1;
-  mtk_cooler_bcct_dprintk("mtk_cl_bcct_get_max_state() %s %lu\n", cdev->type, *state);
-  return 0;
-}
-
-static int 
-mtk_cl_bcct_get_cur_state(struct thermal_cooling_device *cdev,
-                          unsigned long *state)
-{
-  MTK_CL_BCCT_GET_CURR_STATE(*state, *((unsigned long*) cdev->devdata));
-  mtk_cooler_bcct_dprintk("mtk_cl_bcct_get_cur_state() %s %lu\n", cdev->type, *state);
-  mtk_cooler_bcct_dprintk("mtk_cl_bcct_get_cur_state() %s limit=%d\n", cdev->type, get_bat_charging_current_level()/100);
-  return 0;
-}
-
-static int 
-mtk_cl_bcct_set_cur_state(struct thermal_cooling_device *cdev,
-                          unsigned long state)
-{
-  mtk_cooler_bcct_dprintk("mtk_cl_bcct_set_cur_state() %s %lu\n", cdev->type, state);
-  MTK_CL_BCCT_SET_CURR_STATE(state, *((unsigned long*) cdev->devdata));
-  mtk_cl_bcct_set_bcct_limit();
-  mtk_cooler_bcct_dprintk("mtk_cl_bcct_set_cur_state() %s limit=%d\n", cdev->type, get_bat_charging_current_level()/100);
-  
-  return 0;
-}
-
-/* bind fan callbacks to fan device */
-static struct thermal_cooling_device_ops mtk_cl_bcct_ops = {
-  .get_max_state = mtk_cl_bcct_get_max_state,
-  .get_cur_state = mtk_cl_bcct_get_cur_state,
-  .set_cur_state = mtk_cl_bcct_set_cur_state,
-};
-
-static int mtk_cooler_bcct_register_ltf(void)
-{
-  int i;
-  mtk_cooler_bcct_dprintk("register ltf\n");
-
-  for (i = MAX_NUM_INSTANCE_MTK_COOLER_BCCT; i-- > 0; )
-  {
-    char temp[20] = {0};
-    sprintf(temp, "mtk-cl-bcct%02d", i);
-    cl_bcct_dev[i] = mtk_thermal_cooling_device_register(temp, 
-                                                         (void*) &cl_bcct_state[i], // put bcct state to cooler devdata
-                                                         &mtk_cl_bcct_ops);
-  }
-
-  return 0;
-}
-
-static void mtk_cooler_bcct_unregister_ltf(void)
-{
-  int i;
-  mtk_cooler_bcct_dprintk("unregister ltf\n");
-
-  for (i = MAX_NUM_INSTANCE_MTK_COOLER_BCCT; i-- > 0; )
-  {
-    if (cl_bcct_dev[i])
-    {
-      mtk_thermal_cooling_device_unregister(cl_bcct_dev[i]);
-      cl_bcct_dev[i] = NULL;
-      cl_bcct_state[i] = 0;
-    }
-  }
-}
-
-#if 0
-static int _mtk_cl_bcct_proc_read(char *buf, char **start, off_t off, int count, int *eof, void *data)
-{
-    int len = 0;
-    char *p = buf;
-
-    mtk_cooler_bcct_dprintk("[_mtk_cl_bcct_proc_read] invoked.\n");
-
-    /**
-     * The format to print out: 
-     *  kernel_log <0 or 1>
-     *  <mtk-cl-bcct<ID>> <bcc limit>
-     *  ..
-     */
-    if (NULL == data)
-    {
-        mtk_cooler_bcct_dprintk("[_mtk_cl_bcct_proc_read] null data\n");
-    }
-    else
-    {
-        int i = 0;
-
-        p += sprintf(p, "klog %d\n", cl_bcct_klog_on);
-        p += sprintf(p, "curr_limit %d\n", cl_bcct_cur_limit);
-
-        for (; i < MAX_NUM_INSTANCE_MTK_COOLER_BCCT; i++)
-        {
-            int limit;
-            unsigned int curr_state;
-            
-            MTK_CL_BCCT_GET_LIMIT(limit, cl_bcct_state[i]);
-            MTK_CL_BCCT_GET_CURR_STATE(curr_state, cl_bcct_state[i]);
-        
-            p += sprintf(p, "mtk-cl-bcct%02d %d mA, state %d\n", i, limit, curr_state);
-        }
-    }
-
-    *start = buf + off;
-
-    len = p - buf;
-    if (len > off)
-        len -= off;
-    else
-        len = 0;
-
-    return len < count ? len  : count;
-}
-
-static ssize_t _mtk_cl_bcct_proc_write(struct file *file, const char *buffer, unsigned long count, void *data)
-{
-    int len = 0;
-    char desc[128];
-    int klog_on, limit0, limit1, limit2;
-
-    len = (count < (sizeof(desc) - 1)) ? count : (sizeof(desc) - 1);
-    if (copy_from_user(desc, buffer, len))
-    {
-        return 0;
-    }
-    desc[len] = '\0';
-
-    /**
-     * sscanf format <klog_on> <mtk-cl-bcct00 limit> <mtk-cl-bcct01 limit> ...
-     * <klog_on> can only be 0 or 1
-     * <mtk-cl-bcct00 limit> can only be positive integer or -1 to denote no limit
-     */
-
-    if (NULL == data)
-    {
-        mtk_cooler_bcct_dprintk("[_mtk_cl_bcct_proc_write] null data\n");
-        return -EINVAL;
-    }
-
-    // WARNING: Modify here if MTK_THERMAL_MONITOR_COOLER_MAX_EXTRA_CONDITIONS is changed to other than 3
-#if (3 == MAX_NUM_INSTANCE_MTK_COOLER_BCCT)
-    MTK_CL_BCCT_SET_LIMIT(-1, cl_bcct_state[0]);
-    MTK_CL_BCCT_SET_LIMIT(-1, cl_bcct_state[1]);
-    MTK_CL_BCCT_SET_LIMIT(-1, cl_bcct_state[2]);
-
-    if (1 <= sscanf(desc, "%d %d %d %d",
-                    &klog_on, &limit0, &limit1, &limit2))
-    {
-        if (klog_on == 0 || klog_on == 1)
-        {
-          cl_bcct_klog_on = klog_on;
-        }
-
-        if (limit0 >= -1) MTK_CL_BCCT_SET_LIMIT(limit0, cl_bcct_state[0]);
-        if (limit1 >= -1) MTK_CL_BCCT_SET_LIMIT(limit1, cl_bcct_state[1]);
-        if (limit2 >= -1) MTK_CL_BCCT_SET_LIMIT(limit2, cl_bcct_state[2]);
-        
-        return count;
-    }
-    else
-#else
-#error "Change correspondent part when changing MAX_NUM_INSTANCE_MTK_COOLER_BCCT!"
-#endif
-    {
-        mtk_cooler_bcct_dprintk("[_mtk_cl_bcct_proc_write] bad argument\n");
-    }
-
-    return -EINVAL;
-}
-#endif
-
-static ssize_t _cl_bcct_write(struct file *filp, const char __user *buf, size_t len, loff_t *data)
-{
-    //int ret = 0;
-	char tmp[128] = {0};
-	int klog_on, limit0, limit1, limit2;
-
-	/* write data to the buffer */
-	if ( copy_from_user(tmp, buf, len) ) {
-		return -EFAULT;
-	}
-
-    /**
-     * sscanf format <klog_on> <mtk-cl-bcct00 limit> <mtk-cl-bcct01 limit> ...
-     * <klog_on> can only be 0 or 1
-     * <mtk-cl-bcct00 limit> can only be positive integer or -1 to denote no limit
-     */
-
-    if (NULL == data)
-    {
-        mtk_cooler_bcct_dprintk("[_mtk_cl_bcct_proc_write] null data\n");
-        return -EINVAL;
-    }
-
-    // WARNING: Modify here if MTK_THERMAL_MONITOR_COOLER_MAX_EXTRA_CONDITIONS is changed to other than 3
-#if (3 == MAX_NUM_INSTANCE_MTK_COOLER_BCCT)
-    MTK_CL_BCCT_SET_LIMIT(-1, cl_bcct_state[0]);
-    MTK_CL_BCCT_SET_LIMIT(-1, cl_bcct_state[1]);
-    MTK_CL_BCCT_SET_LIMIT(-1, cl_bcct_state[2]);
-
-    if (1 <= sscanf(tmp, "%d %d %d %d",
-                    &klog_on, &limit0, &limit1, &limit2))
-    {
-        if (klog_on == 0 || klog_on == 1)
-        {
-          cl_bcct_klog_on = klog_on;
-        }
-
-        if (limit0 >= -1) MTK_CL_BCCT_SET_LIMIT(limit0, cl_bcct_state[0]);
-        if (limit1 >= -1) MTK_CL_BCCT_SET_LIMIT(limit1, cl_bcct_state[1]);
-        if (limit2 >= -1) MTK_CL_BCCT_SET_LIMIT(limit2, cl_bcct_state[2]);
-        
-        return len;
-    }
-    else
-#else
-#error "Change correspondent part when changing MAX_NUM_INSTANCE_MTK_COOLER_BCCT!"
-#endif
-    {
-        mtk_cooler_bcct_dprintk("[_mtk_cl_bcct_proc_write] bad argument\n");
-    }
-
-    return -EINVAL;
-}
-
-static int _cl_bcct_read(struct seq_file *m, void *v)
-{
-    /**
-     * The format to print out: 
-     *  kernel_log <0 or 1>
-     *  <mtk-cl-bcct<ID>> <bcc limit>
-     *  ..
-     */
-
-    mtk_cooler_bcct_dprintk("_cl_bcct_read invoked.\n");
-
-    {
-        int i = 0;
-
-        seq_printf(m, "klog %d\n", cl_bcct_klog_on);
-        seq_printf(m, "curr_limit %d\n", cl_bcct_cur_limit);
-
-        for (; i < MAX_NUM_INSTANCE_MTK_COOLER_BCCT; i++)
-        {
-            int limit;
-            unsigned int curr_state;
-            
-            MTK_CL_BCCT_GET_LIMIT(limit, cl_bcct_state[i]);
-            MTK_CL_BCCT_GET_CURR_STATE(curr_state, cl_bcct_state[i]);
-        
-            seq_printf(m, "mtk-cl-bcct%02d %d mA, state %d\n", i, limit, curr_state);
-        }
-    }
-
-	return 0;
-}
-
-static int _cl_bcct_open(struct inode *inode, struct file *file)
-{
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
-    return single_open(file, _cl_bcct_read, PDE_DATA(inode));
-#else
-    return single_open(file, _cl_bcct_read, PDE(inode)->data);
-#endif
-}
-
-static const struct file_operations _cl_bcct_fops = {
-    .owner = THIS_MODULE,
-    .open = _cl_bcct_open,
-    .read = seq_read,
-    .llseek = seq_lseek,
-    .write = _cl_bcct_write,
-    .release = single_release,
-};
-
-
-static int __init mtk_cooler_bcct_init(void)
-{
-  int err = 0;
-  int i;
-
-  for (i = MAX_NUM_INSTANCE_MTK_COOLER_BCCT; i-- > 0; )
-  {
-    cl_bcct_dev[i] = NULL;
-    cl_bcct_state[i] = 0;
-  }
-
-  //cl_bcct_dev = NULL;
-
-  mtk_cooler_bcct_dprintk("init\n");
-
-  err = mtk_cooler_bcct_register_ltf();
-  if (err)
-    goto err_unreg;
-
-  /* create a proc file */
-  {
-        struct proc_dir_entry *entry = NULL;
-        struct proc_dir_entry *dir_entry = NULL;
-
-        dir_entry = mtk_thermal_get_proc_drv_therm_dir_entry();
-        if (!dir_entry) {
-        	mtk_cooler_bcct_dprintk("[%s]: mkdir /proc/driver/thermal failed\n", __func__);
-        }
-
-        entry =
-            proc_create("clbcct", S_IRUGO | S_IWUSR | S_IWGRP, dir_entry,
-                &_cl_bcct_fops);
-		if (!entry) {
-			mtk_cooler_bcct_dprintk_always("%s clbcct creation failed\n", 
-						                   __func__);
-		} else {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
-            proc_set_user(entry, 0, 1000);
-#else
-            entry->gid = 1000;
-#endif
-        }
-  }
-  return 0;
-
-err_unreg:
-  mtk_cooler_bcct_unregister_ltf();
-  return err;
-}
-
-static void __exit mtk_cooler_bcct_exit(void)
-{
-  mtk_cooler_bcct_dprintk("exit\n");
-
-  /* remove the proc file */
-  remove_proc_entry("driver/mtk-cl-bcct", NULL);
-    
-  mtk_cooler_bcct_unregister_ltf();
-}
-
-module_init(mtk_cooler_bcct_init);
-module_exit(mtk_cooler_bcct_exit);
-
-
-
diff --git a/drivers/power/mediatek/battery_common.c~ b/drivers/power/mediatek/battery_common.c~
deleted file mode 100755
index e51fce8..0000000
--- a/drivers/power/mediatek/battery_common.c~
+++ /dev/null
@@ -1,4465 +0,0 @@
-/*****************************************************************************
- *
- * Filename:
- * ---------
- *    battery_common.c
- *
- * Project:
- * --------
- *   Android_Software
- *
- * Description:
- * ------------
- *   This Module defines functions of mt6323 Battery charging algorithm
- *   and the Anroid Battery service for updating the battery status
- *
- * Author:
- * -------
- * Oscar Liu
- *
- ****************************************************************************/
-#include <linux/init.h>		/* For init/exit macros */
-#include <linux/module.h>	/* For MODULE_ marcros  */
-#include <linux/fs.h>
-#include <linux/device.h>
-#include <linux/interrupt.h>
-#include <linux/spinlock.h>
-#include <linux/platform_device.h>
-#include <linux/device.h>
-#include <linux/kdev_t.h>
-#include <linux/fs.h>
-#include <linux/cdev.h>
-#include <linux/delay.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/wait.h>
-#include <linux/slab.h>
-#include <linux/fs.h>
-#include <linux/sched.h>
-#include <linux/poll.h>
-#include <linux/power_supply.h>
-#include <linux/wakelock.h>
-#include <linux/time.h>
-#include <linux/mutex.h>
-#include <linux/kthread.h>
-#include <linux/proc_fs.h>
-#include <linux/platform_device.h>
-#include <linux/seq_file.h>
-#include <linux/scatterlist.h>
-#ifdef CONFIG_OF
-#include <linux/of.h>
-#include <linux/of_irq.h>
-#include <linux/of_address.h>
-#endif
-#include <linux/suspend.h>
-
-#include <asm/scatterlist.h>
-#include <asm/uaccess.h>
-#include <asm/io.h>
-#include <asm/irq.h>
-#include <mach/hardware.h>
-#include <mach/system.h>
-#include <mach/mt_sleep.h>
-
-#include <mach/mt_typedefs.h>
-#include <mach/mt_gpt.h>
-#include <mach/mt_boot.h>
-
-#include <cust_charging.h>
-#include <mach/upmu_common.h>
-#include <mach/upmu_hw.h>
-#include <mach/charging.h>
-#include <mach/battery_common.h>
-#include <mach/battery_meter.h>
-#include "cust_battery_meter.h"
-#include "cust_charging.h"
-#include "cust_pmic.h"
-#include <mach/mt_boot.h>
-#include "mach/mtk_rtc.h"
-#include <linux/reboot.h>
-
-#if defined(CONFIG_MTK_DUAL_INPUT_CHARGER_SUPPORT)
-#include <mach/diso.h>
-#endif
-
-#if defined(CONFIG_MTK_PUMP_EXPRESS_PLUS_SUPPORT)
-#include "cust_pe.h"
-#endif
-/* ////////////////////////////////////////////////////////////////////////////// */
-/* Battery Logging Entry */
-/* ////////////////////////////////////////////////////////////////////////////// */
-int Enable_BATDRV_LOG = BAT_LOG_CRTI+100;
-/* static struct proc_dir_entry *proc_entry; */
-char proc_bat_data[32];
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Smart Battery Structure */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-PMU_ChargerStruct BMT_status;
-#if defined(CONFIG_MTK_DUAL_INPUT_CHARGER_SUPPORT)
-DISO_ChargerStruct DISO_data;
-/* Debug Msg */
-static char *DISO_state_s[8] = {
-	"IDLE",
-	"OTG_ONLY",
-	"USB_ONLY",
-	"USB_WITH_OTG",
-	"DC_ONLY",
-	"DC_WITH_OTG",
-	"DC_WITH_USB",
-	"DC_USB_OTG",
-};
-#endif
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Thermal related flags */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-int g_battery_thermal_throttling_flag = 3;	/* 0:nothing, 1:enable batTT&chrTimer, 2:disable batTT&chrTimer, 3:enable batTT, disable chrTimer */
-int battery_cmd_thermal_test_mode = 0;
-int battery_cmd_thermal_test_mode_value = 0;
-int g_battery_tt_check_flag = 0;	/* 0:default enable check batteryTT, 1:default disable check batteryTT */
-
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Global Variable */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-struct wake_lock battery_suspend_lock;
-struct wake_lock battery_fg_lock;
-CHARGING_CONTROL battery_charging_control;
-unsigned int g_BatteryNotifyCode = 0x0000;
-unsigned int g_BN_TestMode = 0x0000;
-kal_bool g_bat_init_flag = 0;
-unsigned int g_call_state = CALL_IDLE;
-kal_bool g_charging_full_reset_bat_meter = KAL_FALSE;
-int g_platform_boot_mode = 0;
-struct timespec g_bat_time_before_sleep;
-int g_smartbook_update = 0;
-
-#if defined(CONFIG_MTK_DUAL_INPUT_CHARGER_SUPPORT)
-kal_bool g_vcdt_irq_delay_flag = 0;
-#endif
-
-#if defined(MTK_TEMPERATURE_RECHARGE_SUPPORT)
-kal_uint32 g_batt_temp_status = TEMP_POS_NORMAL;
-#endif
-
-kal_bool battery_suspended = KAL_FALSE;
-#ifdef MTK_ENABLE_AGING_ALGORITHM
-extern U32 suspend_time;
-#endif
-
-#if defined(CUST_SYSTEM_OFF_VOLTAGE)
-#define SYSTEM_OFF_VOLTAGE CUST_SYSTEM_OFF_VOLTAGE
-#endif
-
-/* ////////////////////////////////////////////////////////////////////////////// */
-/* Integrate with NVRAM */
-/* ////////////////////////////////////////////////////////////////////////////// */
-#define ADC_CALI_DEVNAME "MT_pmic_adc_cali"
-#define TEST_ADC_CALI_PRINT _IO('k', 0)
-#define SET_ADC_CALI_Slop _IOW('k', 1, int)
-#define SET_ADC_CALI_Offset _IOW('k', 2, int)
-#define SET_ADC_CALI_Cal _IOW('k', 3, int)
-#define ADC_CHANNEL_READ _IOW('k', 4, int)
-#define BAT_STATUS_READ _IOW('k', 5, int)
-#define Set_Charger_Current _IOW('k', 6, int)
-/* add for meta tool----------------------------------------- */
-#define Get_META_BAT_VOL _IOW('k', 10, int)
-#define Get_META_BAT_SOC _IOW('k', 11, int)
-/* add for meta tool----------------------------------------- */
-
-static struct class *adc_cali_class;
-static int adc_cali_major;
-static dev_t adc_cali_devno;
-static struct cdev *adc_cali_cdev;
-
-int adc_cali_slop[14] =
-    { 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000 };
-int adc_cali_offset[14] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
-int adc_cali_cal[1] = { 0 };
-int battery_in_data[1] = { 0 };
-int battery_out_data[1] = { 0 };
-int charging_level_data[1] = { 0 };
-
-kal_bool g_ADC_Cali = KAL_FALSE;
-kal_bool g_ftm_battery_flag = KAL_FALSE;
-#if !defined(CONFIG_POWER_EXT)
-static int g_wireless_state;
-#endif
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Thread related */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-#define BAT_MS_TO_NS(x) (x * 1000 * 1000)
-static kal_bool bat_thread_timeout = KAL_FALSE;
-static kal_bool chr_wake_up_bat = KAL_FALSE;	/* charger in/out to wake up battery thread */
-static kal_bool fg_wake_up_bat= KAL_FALSE;
-static kal_bool bat_meter_timeout = KAL_FALSE;
-static DEFINE_MUTEX(bat_mutex);
-static DEFINE_MUTEX(charger_type_mutex);
-static DECLARE_WAIT_QUEUE_HEAD(bat_thread_wq);
-static struct hrtimer charger_hv_detect_timer;
-static struct task_struct *charger_hv_detect_thread = NULL;
-static kal_bool charger_hv_detect_flag = KAL_FALSE;
-static DECLARE_WAIT_QUEUE_HEAD(charger_hv_detect_waiter);
-static struct hrtimer battery_kthread_timer;
-static kal_bool g_battery_soc_ready = KAL_FALSE;
-extern BOOL bat_spm_timeout;
-extern U32 _g_bat_sleep_total_time;
-
-/* ////////////////////////////////////////////////////////////////////////////// */
-/* FOR ADB CMD */
-/* ////////////////////////////////////////////////////////////////////////////// */
-/* Dual battery */
-int g_status_smb = POWER_SUPPLY_STATUS_NOT_CHARGING;
-int g_capacity_smb = 50;
-int g_present_smb = 0;
-/* ADB charging CMD */
-static int cmd_discharging = -1;
-static int adjust_power = -1;
-static int suspend_discharging = -1;
-
-/* ////////////////////////////////////////////////////////////////////////////// */
-/* FOR ANDROID BATTERY SERVICE */
-/* ////////////////////////////////////////////////////////////////////////////// */
-
-struct wireless_data {
-	struct power_supply psy;
-	int WIRELESS_ONLINE;
-};
-
-struct ac_data {
-	struct power_supply psy;
-	int AC_ONLINE;
-};
-
-struct usb_data {
-	struct power_supply psy;
-	int USB_ONLINE;
-};
-
-struct battery_data {
-	struct power_supply psy;
-	int BAT_STATUS;
-	int BAT_HEALTH;
-	int BAT_PRESENT;
-	int BAT_TECHNOLOGY;
-	int BAT_CAPACITY;
-	/* Add for Battery Service */
-	int BAT_batt_vol;
-	int BAT_batt_temp;
-	/* Add for EM */
-	int BAT_TemperatureR;
-	int BAT_TempBattVoltage;
-	int BAT_InstatVolt;
-	int BAT_BatteryAverageCurrent;
-	int BAT_BatterySenseVoltage;
-	int BAT_ISenseVoltage;
-	int BAT_ChargerVoltage;
-	/* Dual battery */
-	int status_smb;
-	int capacity_smb;
-	int present_smb;
-	int adjust_power;
-};
-
-static enum power_supply_property wireless_props[] = {
-	POWER_SUPPLY_PROP_ONLINE,
-};
-
-static enum power_supply_property ac_props[] = {
-	POWER_SUPPLY_PROP_ONLINE,
-};
-
-static enum power_supply_property usb_props[] = {
-	POWER_SUPPLY_PROP_ONLINE,
-};
-
-static enum power_supply_property battery_props[] = {
-	POWER_SUPPLY_PROP_STATUS,
-	POWER_SUPPLY_PROP_HEALTH,
-	POWER_SUPPLY_PROP_PRESENT,
-	POWER_SUPPLY_PROP_TECHNOLOGY,
-	POWER_SUPPLY_PROP_CAPACITY,
-	/* Add for Battery Service */
-	POWER_SUPPLY_PROP_batt_vol,
-	POWER_SUPPLY_PROP_batt_temp,
-	/* Add for EM */
-	POWER_SUPPLY_PROP_TemperatureR,
-	POWER_SUPPLY_PROP_TempBattVoltage,
-	POWER_SUPPLY_PROP_InstatVolt,
-	POWER_SUPPLY_PROP_BatteryAverageCurrent,
-	POWER_SUPPLY_PROP_BatterySenseVoltage,
-	POWER_SUPPLY_PROP_ISenseVoltage,
-	POWER_SUPPLY_PROP_ChargerVoltage,
-	/* Dual battery */
-	POWER_SUPPLY_PROP_status_smb,
-	POWER_SUPPLY_PROP_capacity_smb,
-	POWER_SUPPLY_PROP_present_smb,
-	/* ADB CMD Discharging */
-	POWER_SUPPLY_PROP_adjust_power,
-};
-
-
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // extern function */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* extern void mt_power_off(void); */
-extern bool mt_usb_is_device(void);
-#if defined(CONFIG_USB_MTK_HDRC) || defined(CONFIG_USB_MU3D_DRV)
-extern void mt_usb_connect(void);
-extern void mt_usb_disconnect(void);
-#else
-#define mt_usb_connect() do { } while (0)
-#define mt_usb_disconnect() do { } while (0)
-#endif
-/* extern int set_rtc_spare_fg_value(int val); */
-
-#if defined(CUST_CAPACITY_OCV2CV_TRANSFORM)
-extern void battery_meter_set_reset_soc(kal_bool bUSE_UI_SOC);
-extern kal_int32 battery_meter_get_battery_soc(void);
-#endif
-
-void check_battery_exist(void);
-void charging_suspend_enable(void)
-{
-    U32 charging_enable = true;
-
-    suspend_discharging = 0;
-    battery_charging_control(CHARGING_CMD_ENABLE,&charging_enable);
-}
-
-void charging_suspend_disable(void)
-{
-    U32 charging_enable = false;
-
-    suspend_discharging = 1;
-    battery_charging_control(CHARGING_CMD_ENABLE,&charging_enable);
-}
-
-int read_tbat_value(void)
-{
-	return BMT_status.temperature;
-}
-
-int get_charger_detect_status(void)
-{
-	kal_bool chr_status;
-
-	battery_charging_control(CHARGING_CMD_GET_CHARGER_DET_STATUS, &chr_status);
-	return chr_status;
-}
-
-#if defined(CONFIG_MTK_POWER_EXT_DETECT)
-kal_bool bat_is_ext_power(void)
-{
-	kal_bool pwr_src = 0;
-
-	battery_charging_control(CHARGING_CMD_GET_POWER_SOURCE, &pwr_src);
-	battery_log(BAT_LOG_FULL, "[BAT_IS_EXT_POWER] is_ext_power = %d\n", pwr_src);
-	return pwr_src;
-}
-#endif
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // PMIC PCHR Related APIs */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-kal_bool upmu_is_chr_det(void)
-{
-#if !defined(CONFIG_POWER_EXT)
-	kal_uint32 tmp32;
-#endif	
-
-    if(battery_charging_control == NULL)
-    {
-        battery_charging_control = chr_control_interface;
-    }
-#if defined(CONFIG_POWER_EXT)
-	/* return KAL_TRUE; */
-	return get_charger_detect_status();
-#else
-        if (suspend_discharging==1)
-        return KAL_FALSE;
-
-	tmp32 = get_charger_detect_status();
-
-#ifdef CONFIG_MTK_POWER_EXT_DETECT
-	if (KAL_TRUE == bat_is_ext_power())
-		return tmp32;
-#endif
-
-	if (tmp32 == 0) {
-		return KAL_FALSE;
-	} else {
-		#if !defined(CONFIG_MTK_DUAL_INPUT_CHARGER_SUPPORT)
-		if (mt_usb_is_device()) {
-			battery_log(BAT_LOG_FULL,
-					    "[upmu_is_chr_det] Charger exist and USB is not host\n");
-
-			return KAL_TRUE;
-		} else {
-			battery_log(BAT_LOG_CRTI,
-					    "[upmu_is_chr_det] Charger exist but USB is host\n");
-
-			return KAL_FALSE;
-		}
-		#else
-		return KAL_TRUE;
-		#endif
-	}
-#endif
-}
-EXPORT_SYMBOL(upmu_is_chr_det);
-
-
-void wake_up_bat(void)
-{
-	battery_log(BAT_LOG_CRTI, "[BATTERY] wake_up_bat. \r\n");
-
-	chr_wake_up_bat = KAL_TRUE;
-	bat_thread_timeout = KAL_TRUE;
-#ifdef MTK_ENABLE_AGING_ALGORITHM
-	suspend_time = 0;
-#endif
-    _g_bat_sleep_total_time = 0;
-	wake_up(&bat_thread_wq);
-}
-EXPORT_SYMBOL(wake_up_bat);
-
-
-#ifdef FG_BAT_INT
-void wake_up_bat2(void)
-{
-	battery_log(BAT_LOG_CRTI, "[BATTERY] wake_up_bat2. \r\n");
-
-	wake_lock(&battery_fg_lock);
-	fg_wake_up_bat = KAL_TRUE;
-	bat_thread_timeout = KAL_TRUE;
-#ifdef MTK_ENABLE_AGING_ALGORITHM
-	suspend_time = 0;
-#endif
-    _g_bat_sleep_total_time = 0;
-	wake_up(&bat_thread_wq);
-}
-EXPORT_SYMBOL(wake_up_bat2);
-#endif //#ifdef FG_BAT_INT
-
-void wake_up_bat3(void)
-{
-	battery_log(BAT_LOG_CRTI, "[BATTERY] wake_up_ba3t. \r\n");
-
-	bat_thread_timeout = KAL_TRUE;
-#ifdef MTK_ENABLE_AGING_ALGORITHM
-	suspend_time = 0;
-#endif
-    _g_bat_sleep_total_time = 0;
-	wake_up(&bat_thread_wq);
-}
-EXPORT_SYMBOL(wake_up_bat3);
-
-
-
-static ssize_t bat_log_write(struct file *filp, const char __user *buff, size_t len, loff_t *data)
-{
-	if (copy_from_user(&proc_bat_data, buff, len)) {
-		battery_log(BAT_LOG_FULL, "bat_log_write error.\n");
-		return -EFAULT;
-	}
-
-	if (proc_bat_data[0] == '1') {
-		battery_log(BAT_LOG_CRTI, "enable battery driver log system\n");
-		Enable_BATDRV_LOG = 1;
-	} else if (proc_bat_data[0] == '2') {
-		battery_log(BAT_LOG_CRTI, "enable battery driver log system:2\n");
-		Enable_BATDRV_LOG = 2;
-	} else {
-		battery_log(BAT_LOG_CRTI, "Disable battery driver log system\n");
-		Enable_BATDRV_LOG = 0;
-	}
-
-	return len;
-}
-
-static const struct file_operations bat_proc_fops = {
-	.write = bat_log_write,
-};
-
-int init_proc_log(void)
-{
-	int ret = 0;
-
-#if 1
-	proc_create("batdrv_log", 0644, NULL, &bat_proc_fops);
-	battery_log(BAT_LOG_CRTI, "proc_create bat_proc_fops\n");
-#else
-	proc_entry = create_proc_entry("batdrv_log", 0644, NULL);
-
-	if (proc_entry == NULL) {
-		ret = -ENOMEM;
-		battery_log(BAT_LOG_FULL, "init_proc_log: Couldn't create proc entry\n");
-	} else {
-		proc_entry->write_proc = bat_log_write;
-		battery_log(BAT_LOG_CRTI, "init_proc_log loaded.\n");
-	}
-#endif
-
-	return ret;
-}
-
-
-static int wireless_get_property(struct power_supply *psy,
-				 enum power_supply_property psp, union power_supply_propval *val)
-{
-	int ret = 0;
-	struct wireless_data *data = container_of(psy, struct wireless_data, psy);
-
-	switch (psp) {
-	case POWER_SUPPLY_PROP_ONLINE:
-		val->intval = data->WIRELESS_ONLINE;
-		break;
-	default:
-		ret = -EINVAL;
-		break;
-	}
-	return ret;
-}
-
-static int ac_get_property(struct power_supply *psy,
-			   enum power_supply_property psp, union power_supply_propval *val)
-{
-	int ret = 0;
-	struct ac_data *data = container_of(psy, struct ac_data, psy);
-
-	switch (psp) {
-	case POWER_SUPPLY_PROP_ONLINE:
-		val->intval = data->AC_ONLINE;
-		break;
-	default:
-		ret = -EINVAL;
-		break;
-	}
-	return ret;
-}
-
-static int usb_get_property(struct power_supply *psy,
-			    enum power_supply_property psp, union power_supply_propval *val)
-{
-	int ret = 0;
-	struct usb_data *data = container_of(psy, struct usb_data, psy);
-
-	switch (psp) {
-	case POWER_SUPPLY_PROP_ONLINE:
-#if defined(CONFIG_POWER_EXT)
-		/* #if 0 */
-		data->USB_ONLINE = 1;
-		val->intval = data->USB_ONLINE;
-#else
-#if defined(CONFIG_MTK_POWER_EXT_DETECT)
-		if (KAL_TRUE == bat_is_ext_power())
-			data->USB_ONLINE = 1;
-#endif
-		val->intval = data->USB_ONLINE;
-#endif
-		break;
-	default:
-		ret = -EINVAL;
-		break;
-	}
-	return ret;
-}
-
-static int battery_get_property(struct power_supply *psy,
-				enum power_supply_property psp, union power_supply_propval *val)
-{
-	int ret = 0;
-	struct battery_data *data = container_of(psy, struct battery_data, psy);
-
-	switch (psp) {
-	case POWER_SUPPLY_PROP_STATUS:
-		val->intval = data->BAT_STATUS;
-		break;
-	case POWER_SUPPLY_PROP_HEALTH:
-		val->intval = data->BAT_HEALTH;
-		break;
-	case POWER_SUPPLY_PROP_PRESENT:
-		val->intval = data->BAT_PRESENT;
-		break;
-	case POWER_SUPPLY_PROP_TECHNOLOGY:
-		val->intval = data->BAT_TECHNOLOGY;
-		break;
-	case POWER_SUPPLY_PROP_CAPACITY:
-		val->intval = data->BAT_CAPACITY;
-		break;
-	case POWER_SUPPLY_PROP_batt_vol:
-		val->intval = data->BAT_batt_vol;
-		break;
-	case POWER_SUPPLY_PROP_batt_temp:
-		val->intval = data->BAT_batt_temp;
-		break;
-	case POWER_SUPPLY_PROP_TemperatureR:
-		val->intval = data->BAT_TemperatureR;
-		break;
-	case POWER_SUPPLY_PROP_TempBattVoltage:
-		val->intval = data->BAT_TempBattVoltage;
-		break;
-	case POWER_SUPPLY_PROP_InstatVolt:
-		val->intval = data->BAT_InstatVolt;
-		break;
-	case POWER_SUPPLY_PROP_BatteryAverageCurrent:
-		val->intval = data->BAT_BatteryAverageCurrent;
-		break;
-	case POWER_SUPPLY_PROP_BatterySenseVoltage:
-		val->intval = data->BAT_BatterySenseVoltage;
-		break;
-	case POWER_SUPPLY_PROP_ISenseVoltage:
-		val->intval = data->BAT_ISenseVoltage;
-		break;
-	case POWER_SUPPLY_PROP_ChargerVoltage:
-		val->intval = data->BAT_ChargerVoltage;
-		break;
-		/* Dual battery */
-	case POWER_SUPPLY_PROP_status_smb:
-		val->intval = data->status_smb;
-		break;
-	case POWER_SUPPLY_PROP_capacity_smb:
-		val->intval = data->capacity_smb;
-		break;
-	case POWER_SUPPLY_PROP_present_smb:
-		val->intval = data->present_smb;
-		break;
-	case POWER_SUPPLY_PROP_adjust_power :
-		val->intval = data->adjust_power;
-		break;
-
-	default:
-		ret = -EINVAL;
-		break;
-	}
-
-	return ret;
-}
-
-/* wireless_data initialization */
-static struct wireless_data wireless_main = {
-	.psy = {
-		.name = "wireless",
-		.type = POWER_SUPPLY_TYPE_WIRELESS,
-		.properties = wireless_props,
-		.num_properties = ARRAY_SIZE(wireless_props),
-		.get_property = wireless_get_property,
-		},
-	.WIRELESS_ONLINE = 0,
-};
-
-/* ac_data initialization */
-static struct ac_data ac_main = {
-	.psy = {
-		.name = "ac",
-		.type = POWER_SUPPLY_TYPE_MAINS,
-		.properties = ac_props,
-		.num_properties = ARRAY_SIZE(ac_props),
-		.get_property = ac_get_property,
-		},
-	.AC_ONLINE = 0,
-};
-
-/* usb_data initialization */
-static struct usb_data usb_main = {
-	.psy = {
-		.name = "usb",
-		.type = POWER_SUPPLY_TYPE_USB,
-		.properties = usb_props,
-		.num_properties = ARRAY_SIZE(usb_props),
-		.get_property = usb_get_property,
-		},
-	.USB_ONLINE = 0,
-};
-
-/* battery_data initialization */
-static struct battery_data battery_main = {
-	.psy = {
-		.name = "battery",
-		.type = POWER_SUPPLY_TYPE_BATTERY,
-		.properties = battery_props,
-		.num_properties = ARRAY_SIZE(battery_props),
-		.get_property = battery_get_property,
-		},
-/* CC: modify to have a full power supply status */
-#if defined(CONFIG_POWER_EXT)
-	.BAT_STATUS = POWER_SUPPLY_STATUS_FULL,
-	.BAT_HEALTH = POWER_SUPPLY_HEALTH_GOOD,
-	.BAT_PRESENT = 1,
-	.BAT_TECHNOLOGY = POWER_SUPPLY_TECHNOLOGY_LION,
-	.BAT_CAPACITY = 100,
-	.BAT_batt_vol = 4200,
-	.BAT_batt_temp = 22,
-	/* Dual battery */
-	.status_smb = POWER_SUPPLY_STATUS_NOT_CHARGING,
-	.capacity_smb = 50,
-	.present_smb = 0,
-	/* ADB CMD discharging*/
-	.adjust_power = -1,
-#else
-	.BAT_STATUS = POWER_SUPPLY_STATUS_NOT_CHARGING,
-	.BAT_HEALTH = POWER_SUPPLY_HEALTH_GOOD,
-	.BAT_PRESENT = 1,
-	.BAT_TECHNOLOGY = POWER_SUPPLY_TECHNOLOGY_LION,
-	#if defined(CONFIG_MTK_PUMP_EXPRESS_SUPPORT) || defined(CONFIG_MTK_PUMP_EXPRESS_PLUS_SUPPORT)
-	.BAT_CAPACITY = -1,
-	#else
-	.BAT_CAPACITY = 50,
-	#endif
-	.BAT_batt_vol = 0,
-	.BAT_batt_temp = 0,
-	/* Dual battery */
-	.status_smb = POWER_SUPPLY_STATUS_NOT_CHARGING,
-	.capacity_smb = 50,
-	.present_smb = 0,
-	/* ADB CMD discharging*/
-	.adjust_power = -1,
-#endif
-};
-
-
-#if !defined(CONFIG_POWER_EXT)
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : ADC_Charger_Voltage */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_ADC_Charger_Voltage(struct device *dev, struct device_attribute *attr,
-					char *buf)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] show_ADC_Charger_Voltage : %d\n",
-			    BMT_status.charger_vol);
-	return sprintf(buf, "%d\n", BMT_status.charger_vol);
-}
-
-static ssize_t store_ADC_Charger_Voltage(struct device *dev, struct device_attribute *attr,
-					 const char *buf, size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(ADC_Charger_Voltage, 0664, show_ADC_Charger_Voltage, store_ADC_Charger_Voltage);
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : ADC_Channel_0_Slope */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_ADC_Channel_0_Slope(struct device *dev, struct device_attribute *attr,
-					char *buf)
-{
-	int ret_value = 1;
-	ret_value = (*(adc_cali_slop + 0));
-	battery_log(BAT_LOG_CRTI, "[EM] ADC_Channel_0_Slope : %d\n", ret_value);
-	return sprintf(buf, "%u\n", ret_value);
-}
-
-static ssize_t store_ADC_Channel_0_Slope(struct device *dev, struct device_attribute *attr,
-					 const char *buf, size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(ADC_Channel_0_Slope, 0664, show_ADC_Channel_0_Slope, store_ADC_Channel_0_Slope);
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : ADC_Channel_1_Slope */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_ADC_Channel_1_Slope(struct device *dev, struct device_attribute *attr,
-					char *buf)
-{
-	int ret_value = 1;
-	ret_value = (*(adc_cali_slop + 1));
-	battery_log(BAT_LOG_CRTI, "[EM] ADC_Channel_1_Slope : %d\n", ret_value);
-	return sprintf(buf, "%u\n", ret_value);
-}
-
-static ssize_t store_ADC_Channel_1_Slope(struct device *dev, struct device_attribute *attr,
-					 const char *buf, size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(ADC_Channel_1_Slope, 0664, show_ADC_Channel_1_Slope, store_ADC_Channel_1_Slope);
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : ADC_Channel_2_Slope */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_ADC_Channel_2_Slope(struct device *dev, struct device_attribute *attr,
-					char *buf)
-{
-	int ret_value = 1;
-	ret_value = (*(adc_cali_slop + 2));
-	battery_log(BAT_LOG_CRTI, "[EM] ADC_Channel_2_Slope : %d\n", ret_value);
-	return sprintf(buf, "%u\n", ret_value);
-}
-
-static ssize_t store_ADC_Channel_2_Slope(struct device *dev, struct device_attribute *attr,
-					 const char *buf, size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(ADC_Channel_2_Slope, 0664, show_ADC_Channel_2_Slope, store_ADC_Channel_2_Slope);
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : ADC_Channel_3_Slope */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_ADC_Channel_3_Slope(struct device *dev, struct device_attribute *attr,
-					char *buf)
-{
-	int ret_value = 1;
-	ret_value = (*(adc_cali_slop + 3));
-	battery_log(BAT_LOG_CRTI, "[EM] ADC_Channel_3_Slope : %d\n", ret_value);
-	return sprintf(buf, "%u\n", ret_value);
-}
-
-static ssize_t store_ADC_Channel_3_Slope(struct device *dev, struct device_attribute *attr,
-					 const char *buf, size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(ADC_Channel_3_Slope, 0664, show_ADC_Channel_3_Slope, store_ADC_Channel_3_Slope);
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : ADC_Channel_4_Slope */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_ADC_Channel_4_Slope(struct device *dev, struct device_attribute *attr,
-					char *buf)
-{
-	int ret_value = 1;
-	ret_value = (*(adc_cali_slop + 4));
-	battery_log(BAT_LOG_CRTI, "[EM] ADC_Channel_4_Slope : %d\n", ret_value);
-	return sprintf(buf, "%u\n", ret_value);
-}
-
-static ssize_t store_ADC_Channel_4_Slope(struct device *dev, struct device_attribute *attr,
-					 const char *buf, size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(ADC_Channel_4_Slope, 0664, show_ADC_Channel_4_Slope, store_ADC_Channel_4_Slope);
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : ADC_Channel_5_Slope */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_ADC_Channel_5_Slope(struct device *dev, struct device_attribute *attr,
-					char *buf)
-{
-	int ret_value = 1;
-	ret_value = (*(adc_cali_slop + 5));
-	battery_log(BAT_LOG_CRTI, "[EM] ADC_Channel_5_Slope : %d\n", ret_value);
-	return sprintf(buf, "%u\n", ret_value);
-}
-
-static ssize_t store_ADC_Channel_5_Slope(struct device *dev, struct device_attribute *attr,
-					 const char *buf, size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(ADC_Channel_5_Slope, 0664, show_ADC_Channel_5_Slope, store_ADC_Channel_5_Slope);
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : ADC_Channel_6_Slope */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_ADC_Channel_6_Slope(struct device *dev, struct device_attribute *attr,
-					char *buf)
-{
-	int ret_value = 1;
-	ret_value = (*(adc_cali_slop + 6));
-	battery_log(BAT_LOG_CRTI, "[EM] ADC_Channel_6_Slope : %d\n", ret_value);
-	return sprintf(buf, "%u\n", ret_value);
-}
-
-static ssize_t store_ADC_Channel_6_Slope(struct device *dev, struct device_attribute *attr,
-					 const char *buf, size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(ADC_Channel_6_Slope, 0664, show_ADC_Channel_6_Slope, store_ADC_Channel_6_Slope);
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : ADC_Channel_7_Slope */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_ADC_Channel_7_Slope(struct device *dev, struct device_attribute *attr,
-					char *buf)
-{
-	int ret_value = 1;
-	ret_value = (*(adc_cali_slop + 7));
-	battery_log(BAT_LOG_CRTI, "[EM] ADC_Channel_7_Slope : %d\n", ret_value);
-	return sprintf(buf, "%u\n", ret_value);
-}
-
-static ssize_t store_ADC_Channel_7_Slope(struct device *dev, struct device_attribute *attr,
-					 const char *buf, size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(ADC_Channel_7_Slope, 0664, show_ADC_Channel_7_Slope, store_ADC_Channel_7_Slope);
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : ADC_Channel_8_Slope */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_ADC_Channel_8_Slope(struct device *dev, struct device_attribute *attr,
-					char *buf)
-{
-	int ret_value = 1;
-	ret_value = (*(adc_cali_slop + 8));
-	battery_log(BAT_LOG_CRTI, "[EM] ADC_Channel_8_Slope : %d\n", ret_value);
-	return sprintf(buf, "%u\n", ret_value);
-}
-
-static ssize_t store_ADC_Channel_8_Slope(struct device *dev, struct device_attribute *attr,
-					 const char *buf, size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(ADC_Channel_8_Slope, 0664, show_ADC_Channel_8_Slope, store_ADC_Channel_8_Slope);
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : ADC_Channel_9_Slope */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_ADC_Channel_9_Slope(struct device *dev, struct device_attribute *attr,
-					char *buf)
-{
-	int ret_value = 1;
-	ret_value = (*(adc_cali_slop + 9));
-	battery_log(BAT_LOG_CRTI, "[EM] ADC_Channel_9_Slope : %d\n", ret_value);
-	return sprintf(buf, "%u\n", ret_value);
-}
-
-static ssize_t store_ADC_Channel_9_Slope(struct device *dev, struct device_attribute *attr,
-					 const char *buf, size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(ADC_Channel_9_Slope, 0664, show_ADC_Channel_9_Slope, store_ADC_Channel_9_Slope);
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : ADC_Channel_10_Slope */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_ADC_Channel_10_Slope(struct device *dev, struct device_attribute *attr,
-					 char *buf)
-{
-	int ret_value = 1;
-	ret_value = (*(adc_cali_slop + 10));
-	battery_log(BAT_LOG_CRTI, "[EM] ADC_Channel_10_Slope : %d\n", ret_value);
-	return sprintf(buf, "%u\n", ret_value);
-}
-
-static ssize_t store_ADC_Channel_10_Slope(struct device *dev, struct device_attribute *attr,
-					  const char *buf, size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(ADC_Channel_10_Slope, 0664, show_ADC_Channel_10_Slope,
-		   store_ADC_Channel_10_Slope);
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : ADC_Channel_11_Slope */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_ADC_Channel_11_Slope(struct device *dev, struct device_attribute *attr,
-					 char *buf)
-{
-	int ret_value = 1;
-	ret_value = (*(adc_cali_slop + 11));
-	battery_log(BAT_LOG_CRTI, "[EM] ADC_Channel_11_Slope : %d\n", ret_value);
-	return sprintf(buf, "%u\n", ret_value);
-}
-
-static ssize_t store_ADC_Channel_11_Slope(struct device *dev, struct device_attribute *attr,
-					  const char *buf, size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(ADC_Channel_11_Slope, 0664, show_ADC_Channel_11_Slope,
-		   store_ADC_Channel_11_Slope);
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : ADC_Channel_12_Slope */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_ADC_Channel_12_Slope(struct device *dev, struct device_attribute *attr,
-					 char *buf)
-{
-	int ret_value = 1;
-	ret_value = (*(adc_cali_slop + 12));
-	battery_log(BAT_LOG_CRTI, "[EM] ADC_Channel_12_Slope : %d\n", ret_value);
-	return sprintf(buf, "%u\n", ret_value);
-}
-
-static ssize_t store_ADC_Channel_12_Slope(struct device *dev, struct device_attribute *attr,
-					  const char *buf, size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(ADC_Channel_12_Slope, 0664, show_ADC_Channel_12_Slope,
-		   store_ADC_Channel_12_Slope);
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : ADC_Channel_13_Slope */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_ADC_Channel_13_Slope(struct device *dev, struct device_attribute *attr,
-					 char *buf)
-{
-	int ret_value = 1;
-	ret_value = (*(adc_cali_slop + 13));
-	battery_log(BAT_LOG_CRTI, "[EM] ADC_Channel_13_Slope : %d\n", ret_value);
-	return sprintf(buf, "%u\n", ret_value);
-}
-
-static ssize_t store_ADC_Channel_13_Slope(struct device *dev, struct device_attribute *attr,
-					  const char *buf, size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(ADC_Channel_13_Slope, 0664, show_ADC_Channel_13_Slope,
-		   store_ADC_Channel_13_Slope);
-
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : ADC_Channel_0_Offset */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_ADC_Channel_0_Offset(struct device *dev, struct device_attribute *attr,
-					 char *buf)
-{
-	int ret_value = 1;
-	ret_value = (*(adc_cali_offset + 0));
-	battery_log(BAT_LOG_CRTI, "[EM] ADC_Channel_0_Offset : %d\n", ret_value);
-	return sprintf(buf, "%u\n", ret_value);
-}
-
-static ssize_t store_ADC_Channel_0_Offset(struct device *dev, struct device_attribute *attr,
-					  const char *buf, size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(ADC_Channel_0_Offset, 0664, show_ADC_Channel_0_Offset,
-		   store_ADC_Channel_0_Offset);
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : ADC_Channel_1_Offset */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_ADC_Channel_1_Offset(struct device *dev, struct device_attribute *attr,
-					 char *buf)
-{
-	int ret_value = 1;
-	ret_value = (*(adc_cali_offset + 1));
-	battery_log(BAT_LOG_CRTI, "[EM] ADC_Channel_1_Offset : %d\n", ret_value);
-	return sprintf(buf, "%u\n", ret_value);
-}
-
-static ssize_t store_ADC_Channel_1_Offset(struct device *dev, struct device_attribute *attr,
-					  const char *buf, size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(ADC_Channel_1_Offset, 0664, show_ADC_Channel_1_Offset,
-		   store_ADC_Channel_1_Offset);
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : ADC_Channel_2_Offset */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_ADC_Channel_2_Offset(struct device *dev, struct device_attribute *attr,
-					 char *buf)
-{
-	int ret_value = 1;
-	ret_value = (*(adc_cali_offset + 2));
-	battery_log(BAT_LOG_CRTI, "[EM] ADC_Channel_2_Offset : %d\n", ret_value);
-	return sprintf(buf, "%u\n", ret_value);
-}
-
-static ssize_t store_ADC_Channel_2_Offset(struct device *dev, struct device_attribute *attr,
-					  const char *buf, size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(ADC_Channel_2_Offset, 0664, show_ADC_Channel_2_Offset,
-		   store_ADC_Channel_2_Offset);
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : ADC_Channel_3_Offset */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_ADC_Channel_3_Offset(struct device *dev, struct device_attribute *attr,
-					 char *buf)
-{
-	int ret_value = 1;
-	ret_value = (*(adc_cali_offset + 3));
-	battery_log(BAT_LOG_CRTI, "[EM] ADC_Channel_3_Offset : %d\n", ret_value);
-	return sprintf(buf, "%u\n", ret_value);
-}
-
-static ssize_t store_ADC_Channel_3_Offset(struct device *dev, struct device_attribute *attr,
-					  const char *buf, size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(ADC_Channel_3_Offset, 0664, show_ADC_Channel_3_Offset,
-		   store_ADC_Channel_3_Offset);
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : ADC_Channel_4_Offset */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_ADC_Channel_4_Offset(struct device *dev, struct device_attribute *attr,
-					 char *buf)
-{
-	int ret_value = 1;
-	ret_value = (*(adc_cali_offset + 4));
-	battery_log(BAT_LOG_CRTI, "[EM] ADC_Channel_4_Offset : %d\n", ret_value);
-	return sprintf(buf, "%u\n", ret_value);
-}
-
-static ssize_t store_ADC_Channel_4_Offset(struct device *dev, struct device_attribute *attr,
-					  const char *buf, size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(ADC_Channel_4_Offset, 0664, show_ADC_Channel_4_Offset,
-		   store_ADC_Channel_4_Offset);
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : ADC_Channel_5_Offset */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_ADC_Channel_5_Offset(struct device *dev, struct device_attribute *attr,
-					 char *buf)
-{
-	int ret_value = 1;
-	ret_value = (*(adc_cali_offset + 5));
-	battery_log(BAT_LOG_CRTI, "[EM] ADC_Channel_5_Offset : %d\n", ret_value);
-	return sprintf(buf, "%u\n", ret_value);
-}
-
-static ssize_t store_ADC_Channel_5_Offset(struct device *dev, struct device_attribute *attr,
-					  const char *buf, size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(ADC_Channel_5_Offset, 0664, show_ADC_Channel_5_Offset,
-		   store_ADC_Channel_5_Offset);
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : ADC_Channel_6_Offset */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_ADC_Channel_6_Offset(struct device *dev, struct device_attribute *attr,
-					 char *buf)
-{
-	int ret_value = 1;
-	ret_value = (*(adc_cali_offset + 6));
-	battery_log(BAT_LOG_CRTI, "[EM] ADC_Channel_6_Offset : %d\n", ret_value);
-	return sprintf(buf, "%u\n", ret_value);
-}
-
-static ssize_t store_ADC_Channel_6_Offset(struct device *dev, struct device_attribute *attr,
-					  const char *buf, size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(ADC_Channel_6_Offset, 0664, show_ADC_Channel_6_Offset,
-		   store_ADC_Channel_6_Offset);
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : ADC_Channel_7_Offset */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_ADC_Channel_7_Offset(struct device *dev, struct device_attribute *attr,
-					 char *buf)
-{
-	int ret_value = 1;
-	ret_value = (*(adc_cali_offset + 7));
-	battery_log(BAT_LOG_CRTI, "[EM] ADC_Channel_7_Offset : %d\n", ret_value);
-	return sprintf(buf, "%u\n", ret_value);
-}
-
-static ssize_t store_ADC_Channel_7_Offset(struct device *dev, struct device_attribute *attr,
-					  const char *buf, size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(ADC_Channel_7_Offset, 0664, show_ADC_Channel_7_Offset,
-		   store_ADC_Channel_7_Offset);
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : ADC_Channel_8_Offset */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_ADC_Channel_8_Offset(struct device *dev, struct device_attribute *attr,
-					 char *buf)
-{
-	int ret_value = 1;
-	ret_value = (*(adc_cali_offset + 8));
-	battery_log(BAT_LOG_CRTI, "[EM] ADC_Channel_8_Offset : %d\n", ret_value);
-	return sprintf(buf, "%u\n", ret_value);
-}
-
-static ssize_t store_ADC_Channel_8_Offset(struct device *dev, struct device_attribute *attr,
-					  const char *buf, size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(ADC_Channel_8_Offset, 0664, show_ADC_Channel_8_Offset,
-		   store_ADC_Channel_8_Offset);
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : ADC_Channel_9_Offset */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_ADC_Channel_9_Offset(struct device *dev, struct device_attribute *attr,
-					 char *buf)
-{
-	int ret_value = 1;
-	ret_value = (*(adc_cali_offset + 9));
-	battery_log(BAT_LOG_CRTI, "[EM] ADC_Channel_9_Offset : %d\n", ret_value);
-	return sprintf(buf, "%u\n", ret_value);
-}
-
-static ssize_t store_ADC_Channel_9_Offset(struct device *dev, struct device_attribute *attr,
-					  const char *buf, size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(ADC_Channel_9_Offset, 0664, show_ADC_Channel_9_Offset,
-		   store_ADC_Channel_9_Offset);
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : ADC_Channel_10_Offset */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_ADC_Channel_10_Offset(struct device *dev, struct device_attribute *attr,
-					  char *buf)
-{
-	int ret_value = 1;
-	ret_value = (*(adc_cali_offset + 10));
-	battery_log(BAT_LOG_CRTI, "[EM] ADC_Channel_10_Offset : %d\n", ret_value);
-	return sprintf(buf, "%u\n", ret_value);
-}
-
-static ssize_t store_ADC_Channel_10_Offset(struct device *dev, struct device_attribute *attr,
-					   const char *buf, size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(ADC_Channel_10_Offset, 0664, show_ADC_Channel_10_Offset,
-		   store_ADC_Channel_10_Offset);
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : ADC_Channel_11_Offset */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_ADC_Channel_11_Offset(struct device *dev, struct device_attribute *attr,
-					  char *buf)
-{
-	int ret_value = 1;
-	ret_value = (*(adc_cali_offset + 11));
-	battery_log(BAT_LOG_CRTI, "[EM] ADC_Channel_11_Offset : %d\n", ret_value);
-	return sprintf(buf, "%u\n", ret_value);
-}
-
-static ssize_t store_ADC_Channel_11_Offset(struct device *dev, struct device_attribute *attr,
-					   const char *buf, size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(ADC_Channel_11_Offset, 0664, show_ADC_Channel_11_Offset,
-		   store_ADC_Channel_11_Offset);
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : ADC_Channel_12_Offset */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_ADC_Channel_12_Offset(struct device *dev, struct device_attribute *attr,
-					  char *buf)
-{
-	int ret_value = 1;
-	ret_value = (*(adc_cali_offset + 12));
-	battery_log(BAT_LOG_CRTI, "[EM] ADC_Channel_12_Offset : %d\n", ret_value);
-	return sprintf(buf, "%u\n", ret_value);
-}
-
-static ssize_t store_ADC_Channel_12_Offset(struct device *dev, struct device_attribute *attr,
-					   const char *buf, size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(ADC_Channel_12_Offset, 0664, show_ADC_Channel_12_Offset,
-		   store_ADC_Channel_12_Offset);
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : ADC_Channel_13_Offset */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_ADC_Channel_13_Offset(struct device *dev, struct device_attribute *attr,
-					  char *buf)
-{
-	int ret_value = 1;
-	ret_value = (*(adc_cali_offset + 13));
-	battery_log(BAT_LOG_CRTI, "[EM] ADC_Channel_13_Offset : %d\n", ret_value);
-	return sprintf(buf, "%u\n", ret_value);
-}
-
-static ssize_t store_ADC_Channel_13_Offset(struct device *dev, struct device_attribute *attr,
-					   const char *buf, size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(ADC_Channel_13_Offset, 0664, show_ADC_Channel_13_Offset,
-		   store_ADC_Channel_13_Offset);
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : ADC_Channel_Is_Calibration */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_ADC_Channel_Is_Calibration(struct device *dev, struct device_attribute *attr,
-					       char *buf)
-{
-	int ret_value = 2;
-	ret_value = g_ADC_Cali;
-	battery_log(BAT_LOG_CRTI, "[EM] ADC_Channel_Is_Calibration : %d\n", ret_value);
-	return sprintf(buf, "%u\n", ret_value);
-}
-
-static ssize_t store_ADC_Channel_Is_Calibration(struct device *dev, struct device_attribute *attr,
-						const char *buf, size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(ADC_Channel_Is_Calibration, 0664, show_ADC_Channel_Is_Calibration,
-		   store_ADC_Channel_Is_Calibration);
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : Power_On_Voltage */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_Power_On_Voltage(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	int ret_value = 1;
-	ret_value = 3400;
-	battery_log(BAT_LOG_CRTI, "[EM] Power_On_Voltage : %d\n", ret_value);
-	return sprintf(buf, "%u\n", ret_value);
-}
-
-static ssize_t store_Power_On_Voltage(struct device *dev, struct device_attribute *attr,
-				      const char *buf, size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(Power_On_Voltage, 0664, show_Power_On_Voltage, store_Power_On_Voltage);
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : Power_Off_Voltage */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_Power_Off_Voltage(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	int ret_value = 1;
-	ret_value = 3400;
-	battery_log(BAT_LOG_CRTI, "[EM] Power_Off_Voltage : %d\n", ret_value);
-	return sprintf(buf, "%u\n", ret_value);
-}
-
-static ssize_t store_Power_Off_Voltage(struct device *dev, struct device_attribute *attr,
-				       const char *buf, size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(Power_Off_Voltage, 0664, show_Power_Off_Voltage, store_Power_Off_Voltage);
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : Charger_TopOff_Value */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_Charger_TopOff_Value(struct device *dev, struct device_attribute *attr,
-					 char *buf)
-{
-	int ret_value = 1;
-	ret_value = 4110;
-	battery_log(BAT_LOG_CRTI, "[EM] Charger_TopOff_Value : %d\n", ret_value);
-	return sprintf(buf, "%u\n", ret_value);
-}
-
-static ssize_t store_Charger_TopOff_Value(struct device *dev, struct device_attribute *attr,
-					  const char *buf, size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(Charger_TopOff_Value, 0664, show_Charger_TopOff_Value,
-		   store_Charger_TopOff_Value);
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : FG_Battery_CurrentConsumption */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_FG_Battery_CurrentConsumption(struct device *dev, struct device_attribute *attr,
-						  char *buf)
-{
-	int ret_value = 8888;
-	ret_value = battery_meter_get_battery_current();
-	battery_log(BAT_LOG_CRTI, "[EM] FG_Battery_CurrentConsumption : %d/10 mA\n",
-			    ret_value);
-	return sprintf(buf, "%u\n", ret_value);
-}
-
-static ssize_t store_FG_Battery_CurrentConsumption(struct device *dev,
-						   struct device_attribute *attr, const char *buf,
-						   size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(FG_Battery_CurrentConsumption, 0664, show_FG_Battery_CurrentConsumption,
-		   store_FG_Battery_CurrentConsumption);
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Create File For EM : FG_SW_CoulombCounter */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_FG_SW_CoulombCounter(struct device *dev, struct device_attribute *attr,
-					 char *buf)
-{
-	kal_int32 ret_value = 7777;
-	ret_value = battery_meter_get_car();
-	battery_log(BAT_LOG_CRTI, "[EM] FG_SW_CoulombCounter : %d\n", ret_value);
-	return sprintf(buf, "%u\n", ret_value);
-}
-
-static ssize_t store_FG_SW_CoulombCounter(struct device *dev, struct device_attribute *attr,
-					  const char *buf, size_t size)
-{
-	battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-	return size;
-}
-
-static DEVICE_ATTR(FG_SW_CoulombCounter, 0664, show_FG_SW_CoulombCounter,
-		   store_FG_SW_CoulombCounter);
-
-
-static ssize_t show_Charging_CallState(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	battery_log(BAT_LOG_CRTI, "call state = %d\n", g_call_state);
-	return sprintf(buf, "%u\n", g_call_state);
-}
-
-static ssize_t store_Charging_CallState(struct device *dev, struct device_attribute *attr,
-					const char *buf, size_t size)
-{
-	sscanf(buf, "%u", &g_call_state);
-	battery_log(BAT_LOG_CRTI, "call state = %d\n", g_call_state);
-	return size;
-}
-
-static DEVICE_ATTR(Charging_CallState, 0664, show_Charging_CallState, store_Charging_CallState);
-
-static ssize_t show_Charger_Type(struct device *dev,struct device_attribute *attr,
-					char *buf)
-{
-    UINT32 chr_ype = CHARGER_UNKNOWN;
-    chr_ype = BMT_status.charger_exist ? BMT_status.charger_type : CHARGER_UNKNOWN;
-
-    battery_log(BAT_LOG_CRTI, "CHARGER_TYPE = %d\n",chr_ype);
-    return sprintf(buf, "%u\n", chr_ype);
-}
-static ssize_t store_Charger_Type(struct device *dev,struct device_attribute *attr, const char *buf, size_t size)
-{
-    battery_log(BAT_LOG_CRTI, "[EM] Not Support Write Function\n");
-    return size;
-}
-static DEVICE_ATTR(Charger_Type, 0664, show_Charger_Type, store_Charger_Type);
-
-#if defined(CONFIG_MTK_PUMP_EXPRESS_SUPPORT) || defined(CONFIG_MTK_PUMP_EXPRESS_PLUS_SUPPORT)
-static ssize_t show_Pump_Express(struct device *dev,struct device_attribute *attr,
-					char *buf)
-{
-    #if defined(CONFIG_MTK_PUMP_EXPRESS_PLUS_SUPPORT)
-    int icount = 20;  //max debouncing time 20 * 0.2 sec
-
-    if (KAL_TRUE == ta_check_chr_type &&
-      STANDARD_CHARGER == BMT_status.charger_type &&
-      BMT_status.SOC >= TA_START_BATTERY_SOC &&
-      BMT_status.SOC < TA_STOP_BATTERY_SOC)
-    {
-        battery_log(BAT_LOG_CRTI, "[%s]Wait for PE detection\n", __func__);
-        do
-        {
-            icount--;
-            msleep(200);
-        }while(icount && ta_check_chr_type);
-    }
-    #endif
-
-    #if defined(CONFIG_MTK_PUMP_EXPRESS_SUPPORT)
-
-    if ( (KAL_TRUE == ta_check_chr_type) &&
-      (STANDARD_CHARGER == BMT_status.charger_type) )
-    {
-        battery_log(BAT_LOG_CRTI, "[%s]Wait for PE detection\n", __func__);
-        do
-        {
-            msleep(200);
-        }while(ta_check_chr_type);
-    }
-    #endif
-
-
-    battery_log(BAT_LOG_CRTI, "Pump express = %d\n",is_ta_connect);    
-    return sprintf(buf, "%u\n", is_ta_connect);
-}
-static ssize_t store_Pump_Express(struct device *dev,struct device_attribute *attr, const char *buf, size_t size)
-{
-	sscanf(buf, "%u", &is_ta_connect);
-    battery_log(BAT_LOG_CRTI, "Pump express= %d\n",is_ta_connect);    
-    return size;
-}
-static DEVICE_ATTR(Pump_Express, 0664, show_Pump_Express, store_Pump_Express);
-#endif
-
-static void mt_battery_update_EM(struct battery_data *bat_data)
-{
-	bat_data->BAT_CAPACITY = BMT_status.UI_SOC;
-	bat_data->BAT_TemperatureR = BMT_status.temperatureR;	/* API */
-	bat_data->BAT_TempBattVoltage = BMT_status.temperatureV;	/* API */
-	bat_data->BAT_InstatVolt = BMT_status.bat_vol;	/* VBAT */
-	bat_data->BAT_BatteryAverageCurrent = BMT_status.ICharging;
-	bat_data->BAT_BatterySenseVoltage = BMT_status.bat_vol;
-	bat_data->BAT_ISenseVoltage = BMT_status.Vsense;	/* API */
-	bat_data->BAT_ChargerVoltage = BMT_status.charger_vol;
-	/* Dual battery */
-	bat_data->status_smb = g_status_smb;
-	bat_data->capacity_smb = g_capacity_smb;
-	bat_data->present_smb = g_present_smb;
-	battery_log(BAT_LOG_FULL, "status_smb = %d, capacity_smb = %d, present_smb = %d\n",
-			    bat_data->status_smb, bat_data->capacity_smb, bat_data->present_smb);
-	if ((BMT_status.UI_SOC == 100) && (BMT_status.charger_exist == KAL_TRUE))
-		bat_data->BAT_STATUS = POWER_SUPPLY_STATUS_FULL;
-
-#ifdef CONFIG_MTK_DISABLE_POWER_ON_OFF_VOLTAGE_LIMITATION
-	if (bat_data->BAT_CAPACITY <= 0)
-		bat_data->BAT_CAPACITY = 1;
-
-	battery_log(BAT_LOG_CRTI,
-			    "BAT_CAPACITY=1, due to define CONFIG_MTK_DISABLE_POWER_ON_OFF_VOLTAGE_LIMITATION\r\n");
-#endif
-}
-
-
-static kal_bool mt_battery_100Percent_tracking_check(void)
-{
-	kal_bool resetBatteryMeter = KAL_FALSE;
-
-#if defined(CONFIG_MTK_JEITA_STANDARD_SUPPORT)
-	kal_uint32 cust_sync_time = CUST_SOC_JEITA_SYNC_TIME;
-	static kal_uint32 timer_counter = (CUST_SOC_JEITA_SYNC_TIME / BAT_TASK_PERIOD);
-#else
-	kal_uint32 cust_sync_time = ONEHUNDRED_PERCENT_TRACKING_TIME;
-	static kal_uint32 timer_counter = (ONEHUNDRED_PERCENT_TRACKING_TIME / BAT_TASK_PERIOD);
-#endif
-
-	if (BMT_status.bat_full == KAL_TRUE)	/* charging full first, UI tracking to 100% */
-	{
-		if (BMT_status.UI_SOC >= 100) {
-			BMT_status.UI_SOC = 100;
-
-			if ((g_charging_full_reset_bat_meter == KAL_TRUE)
-			    && (BMT_status.bat_charging_state == CHR_BATFULL)) {
-				resetBatteryMeter = KAL_TRUE;
-				g_charging_full_reset_bat_meter = KAL_FALSE;
-			} else {
-				resetBatteryMeter = KAL_FALSE;
-			}
-		} else {
-			/* increase UI percentage every xxs */
-			if (timer_counter >= (cust_sync_time / BAT_TASK_PERIOD)) {
-				timer_counter = 1;
-				BMT_status.UI_SOC++;
-			} else {
-				timer_counter++;
-
-				return resetBatteryMeter;
-			}
-
-			resetBatteryMeter = KAL_TRUE;
-		}
-
-		battery_log(BAT_LOG_CRTI, "[100percent], UI_SOC(%d), reset(%d)\n",
-				    BMT_status.UI_SOC, resetBatteryMeter);
-	} else {
-		/* charging is not full,  UI keep 99% if reaching 100%, */
-
-		if (BMT_status.UI_SOC >= 99) {
-			BMT_status.UI_SOC = 99;
-			resetBatteryMeter = KAL_FALSE;
-
-			battery_log(BAT_LOG_CRTI, "[100percent],UI_SOC = %d\n",
-					    BMT_status.UI_SOC);
-		}
-
-		timer_counter = (cust_sync_time / BAT_TASK_PERIOD);
-
-	}
-
-	return resetBatteryMeter;
-}
-
-
-static kal_bool mt_battery_nPercent_tracking_check(void)
-{
-	kal_bool resetBatteryMeter = KAL_FALSE;
-#if defined(SOC_BY_HW_FG)
-	static kal_uint32 timer_counter = (NPERCENT_TRACKING_TIME / BAT_TASK_PERIOD);
-
-	if (BMT_status.nPrecent_UI_SOC_check_point == 0)
-		return KAL_FALSE;
-
-	/* fuel gauge ZCV < 15%, but UI > 15%,  15% can be customized */
-	if ((BMT_status.ZCV <= BMT_status.nPercent_ZCV)
-	    && (BMT_status.UI_SOC > BMT_status.nPrecent_UI_SOC_check_point)) {
-		if (timer_counter == (NPERCENT_TRACKING_TIME / BAT_TASK_PERIOD))	/* every x sec decrease UI percentage */
-		{
-			BMT_status.UI_SOC--;
-			timer_counter = 1;
-		} else {
-			timer_counter++;
-			return resetBatteryMeter;
-		}
-
-		resetBatteryMeter = KAL_TRUE;
-
-		battery_log(BAT_LOG_CRTI,
-				    "[nPercent] ZCV %d <= nPercent_ZCV %d, UI_SOC=%d., tracking UI_SOC=%d\n",
-				    BMT_status.ZCV, BMT_status.nPercent_ZCV, BMT_status.UI_SOC,
-				    BMT_status.nPrecent_UI_SOC_check_point);
-	} else if ((BMT_status.ZCV > BMT_status.nPercent_ZCV)
-		   && (BMT_status.UI_SOC == BMT_status.nPrecent_UI_SOC_check_point)) {
-		/* UI less than 15 , but fuel gague is more than 15, hold UI 15% */
-		timer_counter = (NPERCENT_TRACKING_TIME / BAT_TASK_PERIOD);
-		resetBatteryMeter = KAL_TRUE;
-
-		battery_log(BAT_LOG_CRTI,
-				    "[nPercent] ZCV %d > BMT_status.nPercent_ZCV %d and UI SOC=%d, then keep %d.\n",
-				    BMT_status.ZCV, BMT_status.nPercent_ZCV, BMT_status.UI_SOC,
-				    BMT_status.nPrecent_UI_SOC_check_point);
-	} else {
-		timer_counter = (NPERCENT_TRACKING_TIME / BAT_TASK_PERIOD);
-	}
-#endif
-	return resetBatteryMeter;
-
-}
-
-static kal_bool mt_battery_0Percent_tracking_check(void)
-{
-	kal_bool resetBatteryMeter = KAL_TRUE;
-	static kal_uint16 reboot_cnt=0;
-
-	if (BMT_status.UI_SOC <= 0) {
-		BMT_status.UI_SOC = 0;
-#ifndef DISABLE_DLPT_FEATURE
-		if (BMT_status.bat_vol <= SYSTEM_OFF_VOLTAGE)
-		{
-			reboot_cnt++;
-			if(reboot_cnt>=2)
-			{
-				battery_log(BAT_LOG_CRTI, "0Percent, shutdown ,VBAT < %d UI_SOC=%d reboot_cnt:%d \r\n", SYSTEM_OFF_VOLTAGE,BMT_status.UI_SOC,reboot_cnt);
-				kernel_restart("battery 0% reboot system");
-			}
-		}
-#endif // #ifndef DISABLE_DLPT_FEATURE		
-	} else {
-		if (BMT_status.bat_vol > SYSTEM_OFF_VOLTAGE && BMT_status.UI_SOC > 1) {
-			BMT_status.UI_SOC--;
-		} else if (BMT_status.bat_vol <= SYSTEM_OFF_VOLTAGE) {
-			BMT_status.UI_SOC--;
-		} 
-		
-		reboot_cnt=0;
-	}
-
-	battery_log(BAT_LOG_CRTI, "0Percent, VBAT < %d UI_SOC=%d reboot_cnt:%d\r\n", SYSTEM_OFF_VOLTAGE,
-			    BMT_status.UI_SOC,reboot_cnt);
-
-	return resetBatteryMeter;
-}
-
-
-static void mt_battery_Sync_UI_Percentage_to_Real(void)
-{
-	static kal_uint32 timer_counter;
-
-	if ((BMT_status.UI_SOC > BMT_status.SOC) && ((BMT_status.UI_SOC != 1))) {
-#if !defined (SYNC_UI_SOC_IMM)
-		/* reduce after xxs */
-		if(chr_wake_up_bat==KAL_FALSE)
-		{
-			if (timer_counter == (SYNC_TO_REAL_TRACKING_TIME / BAT_TASK_PERIOD)) 
-			{
-			BMT_status.UI_SOC--;
-			timer_counter = 0;
-			} 
-#ifdef FG_BAT_INT
-			else if(fg_wake_up_bat==KAL_TRUE)
-			{
-				BMT_status.UI_SOC--;	
-			}
-#endif //#ifdef FG_BAT_INT			
-			else 
-			{
-			timer_counter++;
-		}
-		}
-		else
-		{
-			battery_log(BAT_LOG_CRTI, "[Sync_Real] chr_wake_up_bat=1 , do not update UI_SOC\n");		
-		}
-#else
-		BMT_status.UI_SOC--;
-#endif
-		battery_log(BAT_LOG_CRTI, "[Sync_Real] UI_SOC=%d, SOC=%d, counter = %d\n",
-				    BMT_status.UI_SOC, BMT_status.SOC, timer_counter);
-	} else {
-		timer_counter = 0;
-
-		#if !defined(CUST_CAPACITY_OCV2CV_TRANSFORM)
-		BMT_status.UI_SOC = BMT_status.SOC;
-		#else
-		if (BMT_status.UI_SOC == -1)
-			BMT_status.UI_SOC = BMT_status.SOC;
-		else if (BMT_status.charger_exist && BMT_status.bat_charging_state != CHR_ERROR) {
-			if (BMT_status.UI_SOC < BMT_status.SOC
-			    && (BMT_status.SOC - BMT_status.UI_SOC > 1))
-				BMT_status.UI_SOC++;
-			else
-				BMT_status.UI_SOC = BMT_status.SOC;
-		}
-		#endif
-	}
-
-	if (BMT_status.UI_SOC <= 0) {
-		BMT_status.UI_SOC = 1;
-		battery_log(BAT_LOG_CRTI, "[Battery]UI_SOC get 0 first (%d)\r\n",
-				    BMT_status.UI_SOC);
-	}
-}
-
-static void battery_update(struct battery_data *bat_data)
-{
-	struct power_supply *bat_psy = &bat_data->psy;
-	kal_bool resetBatteryMeter = KAL_FALSE;
-
-	bat_data->BAT_TECHNOLOGY = POWER_SUPPLY_TECHNOLOGY_LION;
-	bat_data->BAT_HEALTH = POWER_SUPPLY_HEALTH_GOOD;
-	bat_data->BAT_batt_vol = BMT_status.bat_vol;
-	bat_data->BAT_batt_temp = BMT_status.temperature * 10;
-	bat_data->BAT_PRESENT = BMT_status.bat_exist;
-
-	if ((BMT_status.charger_exist == KAL_TRUE) && (BMT_status.bat_charging_state != CHR_ERROR)) {
-		if (BMT_status.bat_exist) {	/* charging */
-			if (BMT_status.bat_vol <= V_0PERCENT_TRACKING) {
-				resetBatteryMeter = mt_battery_0Percent_tracking_check();
-			} else {
-				resetBatteryMeter = mt_battery_100Percent_tracking_check();
-			}
-
-			bat_data->BAT_STATUS = POWER_SUPPLY_STATUS_CHARGING;
-		} else {	/* No Battery, Only Charger */
-
-			bat_data->BAT_STATUS = POWER_SUPPLY_STATUS_UNKNOWN;
-			BMT_status.UI_SOC = 0;
-		}
-
-	} else {		/* Only Battery */
-
-		bat_data->BAT_STATUS = POWER_SUPPLY_STATUS_NOT_CHARGING;
-		if (BMT_status.bat_vol <= V_0PERCENT_TRACKING)
-			resetBatteryMeter = mt_battery_0Percent_tracking_check();
-		else
-			resetBatteryMeter = mt_battery_nPercent_tracking_check();
-	}
-
-	if (resetBatteryMeter == KAL_TRUE) {
-		battery_meter_reset();
-	} else {
-		if (bat_is_recharging_phase() == KAL_TRUE) {
-			BMT_status.UI_SOC = 100;
-			battery_log(BAT_LOG_CRTI, "[recharging] UI_SOC=%d, SOC=%d\n",
-					    BMT_status.UI_SOC, BMT_status.SOC);
-		} else {
-			mt_battery_Sync_UI_Percentage_to_Real();
-		}
-	}
-
-	battery_log(BAT_LOG_CRTI, "UI_SOC=(%d), resetBatteryMeter=(%d)\n",
-			    BMT_status.UI_SOC, resetBatteryMeter);
-
-#if !defined(CUST_CAPACITY_OCV2CV_TRANSFORM)
-	/* set RTC SOC to 1 to avoid SOC jump in charger boot. */
-	if (BMT_status.UI_SOC <= 1) {
-		set_rtc_spare_fg_value(1);
-	} else {
-		set_rtc_spare_fg_value(BMT_status.UI_SOC);
-	}
-#else
-	/* We store capacity before loading compenstation in RTC */
-	if (battery_meter_get_battery_soc() <= 1)
-		set_rtc_spare_fg_value(1);
-	else
-		set_rtc_spare_fg_value(battery_meter_get_battery_soc()); /*use battery_soc */
-
-	battery_log(BAT_LOG_FULL, "RTC_SOC=(%d)\n", get_rtc_spare_fg_value());
-#endif
-
-	mt_battery_update_EM(bat_data);
-
-	if (cmd_discharging == 1) {
-		bat_data->BAT_STATUS = POWER_SUPPLY_STATUS_CMD_DISCHARGING;
-	}
-	if (adjust_power != -1) {
-			bat_data->adjust_power = adjust_power;
-			battery_log(BAT_LOG_CRTI, "adjust_power=(%d)\n", adjust_power);
-	}
-        battery_log(BAT_LOG_CRTI, "battery_update.\n");
-
-#ifdef DLPT_POWER_OFF_EN
-    #ifndef DISABLE_DLPT_FEATURE
-    extern int dlpt_check_power_off(void);
-    if(bat_data->BAT_CAPACITY <= DLPT_POWER_OFF_THD)
-    {
-    	static kal_uint8 cnt=0;
-        battery_log(BAT_LOG_CRTI, "[DLPT_POWER_OFF_EN] run\n");
-        
-        //if(bat_data->BAT_CAPACITY==0)
-        //{
-        //    bat_data->BAT_CAPACITY=1;
-        //    battery_log(BAT_LOG_CRTI, "[DLPT_POWER_OFF_EN] SOC=0 but keep %d\n", bat_data->BAT_CAPACITY);
-        //}
-        if(dlpt_check_power_off()==1)
-        {
-            bat_data->BAT_CAPACITY=0;
-			cnt++;
-            battery_log(BAT_LOG_CRTI, "[DLPT_POWER_OFF_EN] SOC=%d to power off , cnt=%d \n", bat_data->BAT_CAPACITY,cnt);
-
-			if(cnt>=2)
-			{
-				kernel_restart("DLPT reboot system");
-			}
-        }
-		else
-		{
-			cnt=0;
-		}
-    }
-    else
-    {
-        battery_log(BAT_LOG_CRTI, "[DLPT_POWER_OFF_EN] disable(%d)\n", bat_data->BAT_CAPACITY);
-    }
-    #endif
-#endif
-
-	power_supply_changed(bat_psy);
-}
-
-void update_charger_info(int wireless_state)
-{
-#if defined(CONFIG_POWER_VERIFY)
-	battery_log(BAT_LOG_CRTI, "[update_charger_info] no support\n");
-#else
-	g_wireless_state = wireless_state;
-	battery_log(BAT_LOG_CRTI, "[update_charger_info] get wireless_state=%d\n",
-			    wireless_state);
-
-	wake_up_bat();
-#endif
-}
-
-static void wireless_update(struct wireless_data *wireless_data)
-{
-	struct power_supply *wireless_psy = &wireless_data->psy;
-
-	if (BMT_status.charger_exist == KAL_TRUE || g_wireless_state) {
-		if ((BMT_status.charger_type == WIRELESS_CHARGER) || g_wireless_state) {
-			wireless_data->WIRELESS_ONLINE = 1;
-			wireless_psy->type = POWER_SUPPLY_TYPE_WIRELESS;
-		} else {
-			wireless_data->WIRELESS_ONLINE = 0;
-		}
-	} else {
-		wireless_data->WIRELESS_ONLINE = 0;
-	}
-
-	power_supply_changed(wireless_psy);
-}
-
-static void ac_update(struct ac_data *ac_data)
-{
-	struct power_supply *ac_psy = &ac_data->psy;
-
-	if (BMT_status.charger_exist == KAL_TRUE) {
-		#if !defined(CONFIG_MTK_DUAL_INPUT_CHARGER_SUPPORT)
-		if ((BMT_status.charger_type == NONSTANDARD_CHARGER) ||
-		    (BMT_status.charger_type == STANDARD_CHARGER)    ||
-			(BMT_status.charger_type == APPLE_2_1A_CHARGER) ||
-			(BMT_status.charger_type == APPLE_1_0A_CHARGER) ||
-			(BMT_status.charger_type == APPLE_0_5A_CHARGER)) {
-		#else
-		if ((BMT_status.charger_type == NONSTANDARD_CHARGER) ||
-		    (BMT_status.charger_type == STANDARD_CHARGER)    ||
-			(BMT_status.charger_type == APPLE_2_1A_CHARGER) ||
-			(BMT_status.charger_type == APPLE_1_0A_CHARGER) ||
-			(BMT_status.charger_type == APPLE_0_5A_CHARGER) ||
-			(DISO_data.diso_state.cur_vdc_state == DISO_ONLINE)) {
-		#endif
-			ac_data->AC_ONLINE = 1;
-			ac_psy->type = POWER_SUPPLY_TYPE_MAINS;
-		} else {
-			ac_data->AC_ONLINE = 0;
-		}
-	} else {
-		ac_data->AC_ONLINE = 0;
-	}
-
-	power_supply_changed(ac_psy);
-}
-
-static void usb_update(struct usb_data *usb_data)
-{
-	struct power_supply *usb_psy = &usb_data->psy;
-
-	if (BMT_status.charger_exist == KAL_TRUE) {
-		if ((BMT_status.charger_type == STANDARD_HOST) ||
-		    (BMT_status.charger_type == CHARGING_HOST)) {
-			usb_data->USB_ONLINE = 1;
-			usb_psy->type = POWER_SUPPLY_TYPE_USB;
-		} else {
-			usb_data->USB_ONLINE = 0;
-		}
-	} else {
-		usb_data->USB_ONLINE = 0;
-	}
-
-	power_supply_changed(usb_psy);
-}
-
-#endif
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Battery Temprature Parameters and functions */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-kal_bool pmic_chrdet_status(void)
-{
-	if (upmu_is_chr_det() == KAL_TRUE) {
-		return KAL_TRUE;
-	} else {
-		battery_log(BAT_LOG_CRTI, "[pmic_chrdet_status] No charger\r\n");
-		return KAL_FALSE;
-	}
-}
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Pulse Charging Algorithm */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-kal_bool bat_is_charger_exist(void)
-{
-	return get_charger_detect_status();
-}
-
-
-kal_bool bat_is_charging_full(void)
-{
-	if ((BMT_status.bat_full == KAL_TRUE) && (BMT_status.bat_in_recharging_state == KAL_FALSE))
-		return KAL_TRUE;
-	else
-		return KAL_FALSE;
-}
-
-
-kal_uint32 bat_get_ui_percentage(void)
-{
-	/* for plugging out charger in recharge phase, using SOC as UI_SOC */
-
-#if defined(CONFIG_POWER_EXT)
-	battery_log(BAT_LOG_CRTI,
-				    "[BATTERY] bat_get_ui_percentage return 100 !!\n\r");
-	return 100;
-#else
-	if (chr_wake_up_bat == KAL_TRUE)
-		return BMT_status.SOC;
-	else
-		return BMT_status.UI_SOC;
-#endif
-}
-
-/* Full state --> recharge voltage --> full state */
-kal_uint32 bat_is_recharging_phase(void)
-{
-	return (BMT_status.bat_in_recharging_state || BMT_status.bat_full == KAL_TRUE);
-}
-
-
-int get_bat_charging_current_level(void)
-{
-	CHR_CURRENT_ENUM charging_current;
-
-	battery_charging_control(CHARGING_CMD_GET_CURRENT, &charging_current);
-
-	return charging_current;
-}
-
-#if defined(MTK_TEMPERATURE_RECHARGE_SUPPORT)
-PMU_STATUS do_batt_temp_state_machine(void)
-{
-	if (BMT_status.temperature == ERR_CHARGE_TEMPERATURE) {
-		return PMU_STATUS_FAIL;
-	}
-#ifdef BAT_LOW_TEMP_PROTECT_ENABLE
-	if (BMT_status.temperature < MIN_CHARGE_TEMPERATURE) {
-		battery_log(BAT_LOG_CRTI,
-				    "[BATTERY] Battery Under Temperature or NTC fail !!\n\r");
-		g_batt_temp_status = TEMP_POS_LOW;
-		return PMU_STATUS_FAIL;
-	} else if (g_batt_temp_status == TEMP_POS_LOW) {
-		if (BMT_status.temperature >= MIN_CHARGE_TEMPERATURE_PLUS_X_DEGREE) {
-			battery_log(BAT_LOG_CRTI,
-					    "[BATTERY] Battery Temperature raise from %d to %d(%d), allow charging!!\n\r",
-					    MIN_CHARGE_TEMPERATURE, BMT_status.temperature,
-					    MIN_CHARGE_TEMPERATURE_PLUS_X_DEGREE);
-			g_batt_temp_status = TEMP_POS_NORMAL;
-			BMT_status.bat_charging_state = CHR_PRE;
-			return PMU_STATUS_OK;
-		} else {
-			return PMU_STATUS_FAIL;
-		}
-	} else
-#endif
-	if (BMT_status.temperature >= MAX_CHARGE_TEMPERATURE) {
-		battery_log(BAT_LOG_CRTI, "[BATTERY] Battery Over Temperature !!\n\r");
-		g_batt_temp_status = TEMP_POS_HIGH;
-		return PMU_STATUS_FAIL;
-	} else if (g_batt_temp_status == TEMP_POS_HIGH) {
-		if (BMT_status.temperature < MAX_CHARGE_TEMPERATURE_MINUS_X_DEGREE) {
-			battery_log(BAT_LOG_CRTI,
-					    "[BATTERY] Battery Temperature down from %d to %d(%d), allow charging!!\n\r",
-					    MAX_CHARGE_TEMPERATURE, BMT_status.temperature,
-					    MAX_CHARGE_TEMPERATURE_MINUS_X_DEGREE);
-			g_batt_temp_status = TEMP_POS_NORMAL;
-			BMT_status.bat_charging_state = CHR_PRE;
-			return PMU_STATUS_OK;
-		} else {
-			return PMU_STATUS_FAIL;
-		}
-	} else {
-		g_batt_temp_status = TEMP_POS_NORMAL;
-	}
-	return PMU_STATUS_OK;
-}
-#endif
-
-unsigned long BAT_Get_Battery_Voltage(int polling_mode)
-{
-	unsigned long ret_val = 0;
-
-#if defined(CONFIG_POWER_EXT)
-	ret_val = 4000;
-#else
-    ret_val=battery_meter_get_battery_voltage(KAL_FALSE);
-#endif
-
-	return ret_val;
-}
-
-
-static void mt_battery_average_method_init(BATTERY_AVG_ENUM type, kal_uint32 *bufferdata, kal_uint32 data,
-					   kal_int32 *sum)
-{
-	kal_uint32 i;
-	static kal_bool batteryBufferFirst = KAL_TRUE;
-	static kal_bool previous_charger_exist = KAL_FALSE;
-	static kal_bool previous_in_recharge_state = KAL_FALSE;
-	static kal_uint8 index;
-    printk("zhunengqin54545--%d\n",type);
-	/* reset charging current window while plug in/out { */
-    if (type == BATTERY_AVG_CURRENT) {
-    printk("zhunengqinssss54545--%d\n",type);
-	if (BMT_status.charger_exist == KAL_TRUE) {
-    printk("zhunengqin54545dddd--BMT_status.bat_in_recharging_state==%d\n",BMT_status.bat_in_recharging_state);
-		if (previous_charger_exist == KAL_FALSE) {
-    printk("zhunengqingggggggggggggggggggggggggggggggggggggggggggggggg--%d\n",type);
-			batteryBufferFirst = KAL_TRUE;
-			previous_charger_exist = KAL_TRUE;
-			#if !defined(CONFIG_MTK_DUAL_INPUT_CHARGER_SUPPORT)
-			if (BMT_status.charger_type == STANDARD_CHARGER) {
-			#else
-			if ((BMT_status.charger_type == STANDARD_CHARGER) || 
-			    (DISO_data.diso_state.cur_vdc_state == DISO_ONLINE)) {
-			#endif
-				data = AC_CHARGER_CURRENT / 100;
-    				printk("zhunengqinwwwwwwwwwwwwwwwwwwwwww--%d\n",data);
-			} else if (BMT_status.charger_type == CHARGING_HOST) {
-				data = CHARGING_HOST_CHARGER_CURRENT / 100;
-    				printk("zhunengqin111wwwwwwddd--%d\n",data);
-			} else if (BMT_status.charger_type == NONSTANDARD_CHARGER){
-				data = NON_STD_AC_CHARGER_CURRENT / 100;	/* mA */
-    				printk("zhunengqin22rrrrrrrrrrrrrrrrrr--%d\n",data);
-			}else	/* USB */
-				data = USB_CHARGER_CURRENT / 100;	/* mA */
-            #ifdef AVG_INIT_WITH_R_SENSE
-            data = AVG_INIT_WITH_R_SENSE(data);
-            #endif
-    				printk("zhunengqin22wwwwwwwdddrrrrrr--%d\n",data);
-		} else if ((previous_in_recharge_state == KAL_FALSE)
-			   && (BMT_status.bat_in_recharging_state == KAL_TRUE)) {
-    printk("zhunengqin54545ddssssdd--BMT_status.charger_type==%d\n",BMT_status.charger_type);
-    printk("zhunengqin54545ddssssdd--STANDARD_CHARGER==%d\n",STANDARD_CHARGER);
-			batteryBufferFirst = KAL_TRUE;
-			#if !defined(CONFIG_MTK_DUAL_INPUT_CHARGER_SUPPORT)
-			if (BMT_status.charger_type == STANDARD_CHARGER) {
-			#else
-			if ((BMT_status.charger_type == STANDARD_CHARGER) || 
-			    (DISO_data.diso_state.cur_vdc_state == DISO_ONLINE)) {
-			#endif			
-				data = AC_CHARGER_CURRENT / 100;
-    				printk("zhunengqinwww--%d\n",data);
-			} else if (BMT_status.charger_type == CHARGING_HOST) {
-				data = CHARGING_HOST_CHARGER_CURRENT / 100;
-    				printk("zhunengqinaaaa--%d\n",data);
-			} else if (BMT_status.charger_type == NONSTANDARD_CHARGER){
-				data = NON_STD_AC_CHARGER_CURRENT / 100;	/* mA */
-    				printk("zhunengqinfff--%d\n",data);
-			}else	/* USB */
-				data = USB_CHARGER_CURRENT / 100;	/* mA */
-            #ifdef AVG_INIT_WITH_R_SENSE
-            data = AVG_INIT_WITH_R_SENSE(data);
-            #endif
-    				printk("zhunengqin22wwwwwwwdddrrrrrr--%d\n",data);
-		}
-
-		previous_in_recharge_state = BMT_status.bat_in_recharging_state;
-	} else {
-		if (previous_charger_exist == KAL_TRUE) {
-			batteryBufferFirst = KAL_TRUE;
-			previous_charger_exist = KAL_FALSE;
-			data = 0;
-    				printk("zhunengqintttttt--%d\n",batteryBufferFirst);
-		}
-
-	}
-    }
-	/* reset charging current window while plug in/out } */
-
-	battery_log(BAT_LOG_FULL, "batteryBufferFirst =%d, data= (%d)\n",
-			    batteryBufferFirst, data);
-
-	if (batteryBufferFirst == KAL_TRUE) {
-		for (i = 0; i < BATTERY_AVERAGE_SIZE; i++) {
-			bufferdata[i] = data;
-		}
-
-		*sum = data * BATTERY_AVERAGE_SIZE;
-	}
-
-	index++;
-	if (index >= BATTERY_AVERAGE_DATA_NUMBER) {
-		index = BATTERY_AVERAGE_DATA_NUMBER;
-		batteryBufferFirst = KAL_FALSE;
-	}
-}
-
-
-static kal_uint32 mt_battery_average_method(BATTERY_AVG_ENUM type, kal_uint32 *bufferdata, kal_uint32 data,
-					    kal_int32 *sum, kal_uint8 batteryIndex)
-{
-	kal_uint32 avgdata;
-
-	mt_battery_average_method_init(type, bufferdata, data, sum);
-
-	*sum -= bufferdata[batteryIndex];
-	*sum += data;
-	bufferdata[batteryIndex] = data;
-	avgdata = (*sum) / BATTERY_AVERAGE_SIZE;
-
-	battery_log(BAT_LOG_FULL, "bufferdata[%d]= (%d)\n", batteryIndex,
-			    bufferdata[batteryIndex]);
-	return avgdata;
-}
-
-void mt_battery_GetBatteryData(void)
-{
-	kal_uint32 bat_vol, charger_vol, Vsense, ZCV;
-	kal_int32 ICharging, temperature, temperatureR, temperatureV, SOC;
-	static kal_int32 bat_sum, icharging_sum, temperature_sum;
-	static kal_int32 batteryVoltageBuffer[BATTERY_AVERAGE_SIZE];
-	static kal_int32 batteryCurrentBuffer[BATTERY_AVERAGE_SIZE];
-	static kal_int32 batteryTempBuffer[BATTERY_AVERAGE_SIZE];
-	static kal_uint8 batteryIndex = 0;
-	static kal_int32 previous_SOC = -1;
-
-	bat_vol = battery_meter_get_battery_voltage(KAL_TRUE);
-	Vsense = battery_meter_get_VSense();
-	if( upmu_is_chr_det() == KAL_TRUE ) {
-	ICharging = battery_meter_get_charging_current();
-	printk("zhunengqin---ICharging=%d Vsense=%d\n\n",ICharging,Vsense);
-	} else {
-		ICharging = 0;
-	}
-
-	charger_vol = battery_meter_get_charger_voltage();
-	temperature = battery_meter_get_battery_temperature();
-	temperatureV = battery_meter_get_tempV();
-	temperatureR = battery_meter_get_tempR(temperatureV);
-	printk("zhunengqin---charger_vol=%d temperature=%d\n\n",charger_vol,temperature);
-	if (bat_meter_timeout == KAL_TRUE || bat_spm_timeout == TRUE || fg_wake_up_bat== KAL_TRUE) 
-	{
-		SOC = battery_meter_get_battery_percentage();
-		//if (bat_spm_timeout == true)
-			//BMT_status.UI_SOC = battery_meter_get_battery_percentage();
-	printk("zhunengqin222---SOC=%d temperature=%d\n\n",SOC,temperature);
-		bat_meter_timeout = KAL_FALSE;
-		bat_spm_timeout = FALSE;
-	} else {
-		if (previous_SOC == -1)
-			SOC = battery_meter_get_battery_percentage();
-		else
-			SOC = previous_SOC;
-	}
-
-	ZCV = battery_meter_get_battery_zcv();
-	printk("zhunengqin---SOC=%d ZCV=%d\n\n",SOC,ZCV);
-	BMT_status.ICharging =
-	    mt_battery_average_method(BATTERY_AVG_CURRENT, &batteryCurrentBuffer[0], ICharging, &icharging_sum,
-				      batteryIndex);
-
-    	printk("zhunengqin---BMT_status.ICharging=%d ZCV=%d\n\n",BMT_status.ICharging,ZCV);
-	if (previous_SOC == -1 && bat_vol <= V_0PERCENT_TRACKING) {
-		battery_log(BAT_LOG_CRTI,
-				    "battery voltage too low, use ZCV to init average data.\n");
-		BMT_status.bat_vol =
-		    mt_battery_average_method(BATTERY_AVG_VOLT, &batteryVoltageBuffer[0], ZCV, &bat_sum,
-					      batteryIndex);
-	} else {
-		BMT_status.bat_vol =
-		    mt_battery_average_method(BATTERY_AVG_VOLT, &batteryVoltageBuffer[0], bat_vol, &bat_sum,
-					      batteryIndex);
-	}
-
-
-	if (battery_cmd_thermal_test_mode == 1)
-	{
-		battery_log(BAT_LOG_CRTI,
-				    "test mode , battery temperature is fixed.\n");	
-	}
-	else
-	{
-	BMT_status.temperature =
-	    mt_battery_average_method(BATTERY_AVG_TEMP, &batteryTempBuffer[0], temperature, &temperature_sum,
-				      batteryIndex);
-	}
-
-
-	BMT_status.Vsense = Vsense;
-	BMT_status.charger_vol = charger_vol;
-	BMT_status.temperatureV = temperatureV;
-	BMT_status.temperatureR = temperatureR;
-	BMT_status.SOC = SOC;
-	BMT_status.ZCV = ZCV;
-
-#if !defined(CUST_CAPACITY_OCV2CV_TRANSFORM)
-	if (BMT_status.charger_exist == KAL_FALSE) {
-		if (BMT_status.SOC > previous_SOC && previous_SOC >= 0)
-			BMT_status.SOC = previous_SOC;
-	}
-#endif
-
-	previous_SOC = BMT_status.SOC;
-
-	batteryIndex++;
-	if (batteryIndex >= BATTERY_AVERAGE_SIZE)
-		batteryIndex = 0;
-
-
-	if (g_battery_soc_ready == KAL_FALSE)
-		g_battery_soc_ready = KAL_TRUE;
-
-	battery_log(BAT_LOG_CRTI,
-			    "AvgVbat=(%d),bat_vol=(%d),AvgI=(%d),I=(%d),VChr=(%d),AvgT=(%d),T=(%d),pre_SOC=(%d),SOC=(%d),ZCV=(%d)\n",
-			    BMT_status.bat_vol, bat_vol, BMT_status.ICharging, ICharging,
-			    BMT_status.charger_vol, BMT_status.temperature, temperature,
-			    previous_SOC, BMT_status.SOC, BMT_status.ZCV);
-
-
-}
-
-
-static PMU_STATUS mt_battery_CheckBatteryTemp(void)
-{
-	PMU_STATUS status = PMU_STATUS_OK;
-
-#if defined(CONFIG_MTK_JEITA_STANDARD_SUPPORT)
-
-	battery_log(BAT_LOG_CRTI, "[BATTERY] support JEITA, temperature=%d\n",
-			    BMT_status.temperature);
-
-	if (do_jeita_state_machine() == PMU_STATUS_FAIL) {
-		battery_log(BAT_LOG_CRTI, "[BATTERY] JEITA : fail\n");
-		status = PMU_STATUS_FAIL;
-	}
-#else
-
-#if defined(MTK_TEMPERATURE_RECHARGE_SUPPORT)
-	if (do_batt_temp_state_machine() == PMU_STATUS_FAIL) {
-		battery_log(BAT_LOG_CRTI, "[BATTERY] Batt temp check : fail\n");
-		status = PMU_STATUS_FAIL;
-	}
-#else
-#ifdef BAT_LOW_TEMP_PROTECT_ENABLE
-	if ((BMT_status.temperature < MIN_CHARGE_TEMPERATURE)
-	    || (BMT_status.temperature == ERR_CHARGE_TEMPERATURE)) {
-		battery_log(BAT_LOG_CRTI,
-				    "[BATTERY] Battery Under Temperature or NTC fail !!\n\r");
-		status = PMU_STATUS_FAIL;
-	}
-#endif
-	if (BMT_status.temperature >= MAX_CHARGE_TEMPERATURE) {
-		battery_log(BAT_LOG_CRTI, "[BATTERY] Battery Over Temperature !!\n\r");
-		status = PMU_STATUS_FAIL;
-	}
-#endif
-
-#endif
-
-	return status;
-}
-
-
-static PMU_STATUS mt_battery_CheckChargerVoltage(void)
-{
-	PMU_STATUS status = PMU_STATUS_OK;
-	#if defined(CONFIG_MTK_DUAL_INPUT_CHARGER_SUPPORT)
-	kal_uint32 v_charger_max = DISO_data.hv_voltage;
-	#endif
-
-	if (BMT_status.charger_exist == KAL_TRUE) {
-#if (V_CHARGER_ENABLE == 1)
-		if (BMT_status.charger_vol <= V_CHARGER_MIN) {
-			battery_log(BAT_LOG_CRTI, "[BATTERY]Charger under voltage!!\r\n");
-			BMT_status.bat_charging_state = CHR_ERROR;
-			status = PMU_STATUS_FAIL;
-		}
-#endif
-		#if !defined(CONFIG_MTK_DUAL_INPUT_CHARGER_SUPPORT)
-		if (BMT_status.charger_vol >= V_CHARGER_MAX) {
-		#else
-		if (BMT_status.charger_vol >= v_charger_max) {
-		#endif
-			battery_log(BAT_LOG_CRTI, "[BATTERY]Charger over voltage !!\r\n");
-			BMT_status.charger_protect_status = charger_OVER_VOL;
-			BMT_status.bat_charging_state = CHR_ERROR;
-			status = PMU_STATUS_FAIL;
-		}
-	}
-
-	return status;
-}
-
-
-static PMU_STATUS mt_battery_CheckChargingTime(void)
-{
-	PMU_STATUS status = PMU_STATUS_OK;
-
-	if ((g_battery_thermal_throttling_flag == 2) || (g_battery_thermal_throttling_flag == 3)) {
-		battery_log(BAT_LOG_FULL,
-				    "[TestMode] Disable Safty Timer. bat_tt_enable=%d, bat_thr_test_mode=%d, bat_thr_test_value=%d\n",
-				    g_battery_thermal_throttling_flag,
-				    battery_cmd_thermal_test_mode,
-				    battery_cmd_thermal_test_mode_value);
-
-	} else {
-		/* Charging OT */
-		if (BMT_status.total_charging_time >= MAX_CHARGING_TIME) {
-			battery_log(BAT_LOG_CRTI, "[BATTERY] Charging Over Time.\n");
-
-			status = PMU_STATUS_FAIL;
-		}
-	}
-
-	return status;
-
-}
-
-#if defined(STOP_CHARGING_IN_TAKLING)
-static PMU_STATUS mt_battery_CheckCallState(void)
-{
-	PMU_STATUS status = PMU_STATUS_OK;
-
-	if ((g_call_state == CALL_ACTIVE) && (BMT_status.bat_vol > V_CC2TOPOFF_THRES))
-		status = PMU_STATUS_FAIL;
-
-	return status;
-}
-#endif
-
-static void mt_battery_CheckBatteryStatus(void)
-{
-	battery_log(BAT_LOG_FULL, "[mt_battery_CheckBatteryStatus] cmd_discharging=(%d)\n",
-			    cmd_discharging);
-	if (cmd_discharging == 1) {
-		battery_log(BAT_LOG_CRTI,
-				    "[mt_battery_CheckBatteryStatus] cmd_discharging=(%d)\n",
-				    cmd_discharging);
-		BMT_status.bat_charging_state = CHR_ERROR;
-		battery_charging_control(CHARGING_CMD_SET_ERROR_STATE, &cmd_discharging);	
-		return;
-	} else if (cmd_discharging == 0) {
-		BMT_status.bat_charging_state = CHR_PRE;
-		battery_charging_control(CHARGING_CMD_SET_ERROR_STATE, &cmd_discharging);
-		cmd_discharging = -1;
-	}
-	if (mt_battery_CheckBatteryTemp() != PMU_STATUS_OK) {
-		BMT_status.bat_charging_state = CHR_ERROR;
-		return;
-	}
-
-	if (mt_battery_CheckChargerVoltage() != PMU_STATUS_OK) {
-		BMT_status.bat_charging_state = CHR_ERROR;
-		return;
-	}
-#if defined(STOP_CHARGING_IN_TAKLING)
-	if (mt_battery_CheckCallState() != PMU_STATUS_OK) {
-		BMT_status.bat_charging_state = CHR_HOLD;
-		return;
-	}
-#endif
-
-	if (mt_battery_CheckChargingTime() != PMU_STATUS_OK) {
-		BMT_status.bat_charging_state = CHR_ERROR;
-		return;
-	}
-}
-
-
-static void mt_battery_notify_TotalChargingTime_check(void)
-{
-#if defined(BATTERY_NOTIFY_CASE_0005_TOTAL_CHARGINGTIME)
-	if ((g_battery_thermal_throttling_flag == 2) || (g_battery_thermal_throttling_flag == 3)) {
-		battery_log(BAT_LOG_FULL,
-				    "[TestMode] Disable Safty Timer : no UI display\n");
-	} else {
-		if (BMT_status.total_charging_time >= MAX_CHARGING_TIME)
-			/* if(BMT_status.total_charging_time >= 60) //test */
-		{
-			g_BatteryNotifyCode |= 0x0010;
-			battery_log(BAT_LOG_CRTI, "[BATTERY] Charging Over Time\n");
-		} else {
-			g_BatteryNotifyCode &= ~(0x0010);
-		}
-	}
-
-	battery_log(BAT_LOG_CRTI,
-			    "[BATTERY] BATTERY_NOTIFY_CASE_0005_TOTAL_CHARGINGTIME (%x)\n",
-			    g_BatteryNotifyCode);
-#endif
-}
-
-
-static void mt_battery_notify_VBat_check(void)
-{
-#if defined(BATTERY_NOTIFY_CASE_0004_VBAT)
-	if (BMT_status.bat_vol > 4350)
-		/* if(BMT_status.bat_vol > 3800) //test */
-	{
-		g_BatteryNotifyCode |= 0x0008;
-		battery_log(BAT_LOG_CRTI, "[BATTERY] bat_vlot(%ld) > 4350mV\n",
-				    BMT_status.bat_vol);
-	} else {
-		g_BatteryNotifyCode &= ~(0x0008);
-	}
-
-	battery_log(BAT_LOG_CRTI, "[BATTERY] BATTERY_NOTIFY_CASE_0004_VBAT (%x)\n",
-			    g_BatteryNotifyCode);
-
-#endif
-}
-
-
-static void mt_battery_notify_ICharging_check(void)
-{
-#if defined(BATTERY_NOTIFY_CASE_0003_ICHARGING)
-	if ((BMT_status.ICharging > 1000) && (BMT_status.total_charging_time > 300)) {
-		g_BatteryNotifyCode |= 0x0004;
-		battery_log(BAT_LOG_CRTI, "[BATTERY] I_charging(%ld) > 1000mA\n",
-				    BMT_status.ICharging);
-	} else {
-		g_BatteryNotifyCode &= ~(0x0004);
-	}
-
-	battery_log(BAT_LOG_CRTI, "[BATTERY] BATTERY_NOTIFY_CASE_0003_ICHARGING (%x)\n",
-			    g_BatteryNotifyCode);
-
-#endif
-}
-
-
-static void mt_battery_notify_VBatTemp_check(void)
-{
-#if defined(BATTERY_NOTIFY_CASE_0002_VBATTEMP)
-
-	if (BMT_status.temperature >= MAX_CHARGE_TEMPERATURE) {
-		g_BatteryNotifyCode |= 0x0002;
-		battery_log(BAT_LOG_CRTI, "[BATTERY] bat_temp(%d) out of range(too high)\n",
-				    BMT_status.temperature);
-	}
-#if defined(CONFIG_MTK_JEITA_STANDARD_SUPPORT)
-	else if (BMT_status.temperature < TEMP_NEG_10_THRESHOLD) {
-		g_BatteryNotifyCode |= 0x0020;
-		battery_log(BAT_LOG_CRTI, "[BATTERY] bat_temp(%d) out of range(too low)\n",
-				    BMT_status.temperature);
-	}
-#else
-#ifdef BAT_LOW_TEMP_PROTECT_ENABLE
-	else if (BMT_status.temperature < MIN_CHARGE_TEMPERATURE) {
-		g_BatteryNotifyCode |= 0x0020;
-		battery_log(BAT_LOG_CRTI, "[BATTERY] bat_temp(%d) out of range(too low)\n",
-				    BMT_status.temperature);
-	}
-#endif
-#endif
-
-	battery_log(BAT_LOG_FULL, "[BATTERY] BATTERY_NOTIFY_CASE_0002_VBATTEMP (%x)\n",
-			    g_BatteryNotifyCode);
-
-#endif
-}
-
-
-static void mt_battery_notify_VCharger_check(void)
-{
-#if defined(BATTERY_NOTIFY_CASE_0001_VCHARGER)
-	#if defined(CONFIG_MTK_DUAL_INPUT_CHARGER_SUPPORT)
-	kal_uint32 v_charger_max = DISO_data.hv_voltage;
-	#endif
-
-	#if !defined(CONFIG_MTK_DUAL_INPUT_CHARGER_SUPPORT)
-	if (BMT_status.charger_vol > V_CHARGER_MAX) {
-	#else
-	if (BMT_status.charger_vol > v_charger_max) {
-	#endif
-		g_BatteryNotifyCode |= 0x0001;
-		battery_log(BAT_LOG_CRTI, "[BATTERY] BMT_status.charger_vol(%d) > %d mV\n",
-				    BMT_status.charger_vol, V_CHARGER_MAX);
-	} else {
-		g_BatteryNotifyCode &= ~(0x0001);
-	}
-	if (g_BatteryNotifyCode != 0x0000)
-		battery_log(BAT_LOG_CRTI,
-				    "[BATTERY] BATTERY_NOTIFY_CASE_0001_VCHARGER (%x)\n",
-				    g_BatteryNotifyCode);
-#endif
-}
-
-
-static void mt_battery_notify_UI_test(void)
-{
-	if (g_BN_TestMode == 0x0001) {
-		g_BatteryNotifyCode = 0x0001;
-		battery_log(BAT_LOG_CRTI,
-				    "[BATTERY_TestMode] BATTERY_NOTIFY_CASE_0001_VCHARGER\n");
-	} else if (g_BN_TestMode == 0x0002) {
-		g_BatteryNotifyCode = 0x0002;
-		battery_log(BAT_LOG_CRTI,
-				    "[BATTERY_TestMode] BATTERY_NOTIFY_CASE_0002_VBATTEMP\n");
-	} else if (g_BN_TestMode == 0x0003) {
-		g_BatteryNotifyCode = 0x0004;
-		battery_log(BAT_LOG_CRTI,
-				    "[BATTERY_TestMode] BATTERY_NOTIFY_CASE_0003_ICHARGING\n");
-	} else if (g_BN_TestMode == 0x0004) {
-		g_BatteryNotifyCode = 0x0008;
-		battery_log(BAT_LOG_CRTI,
-				    "[BATTERY_TestMode] BATTERY_NOTIFY_CASE_0004_VBAT\n");
-	} else if (g_BN_TestMode == 0x0005) {
-		g_BatteryNotifyCode = 0x0010;
-		battery_log(BAT_LOG_CRTI,
-				    "[BATTERY_TestMode] BATTERY_NOTIFY_CASE_0005_TOTAL_CHARGINGTIME\n");
-	} else {
-		battery_log(BAT_LOG_CRTI, "[BATTERY] Unknown BN_TestMode Code : %x\n",
-				    g_BN_TestMode);
-	}
-}
-
-
-void mt_battery_notify_check(void)
-{
-	g_BatteryNotifyCode = 0x0000;
-
-	if (g_BN_TestMode == 0x0000) {	/* for normal case */
-		battery_log(BAT_LOG_FULL, "[BATTERY] mt_battery_notify_check\n");
-
-		mt_battery_notify_VCharger_check();
-
-		mt_battery_notify_VBatTemp_check();
-
-		mt_battery_notify_ICharging_check();
-
-		mt_battery_notify_VBat_check();
-
-		mt_battery_notify_TotalChargingTime_check();
-	} else {		/* for UI test */
-
-		mt_battery_notify_UI_test();
-	}
-}
-
-static void mt_battery_thermal_check(void)
-{
-	if ((g_battery_thermal_throttling_flag == 1) || (g_battery_thermal_throttling_flag == 3)) {
-		if (battery_cmd_thermal_test_mode == 1) {
-			BMT_status.temperature = battery_cmd_thermal_test_mode_value;
-			battery_log(BAT_LOG_FULL,
-					    "[Battery] In thermal_test_mode , Tbat=%d\n",
-					    BMT_status.temperature);
-		}
-#if defined(CONFIG_MTK_JEITA_STANDARD_SUPPORT)
-		/* ignore default rule */
-#else
-		//if (BMT_status.temperature >= 60) {
-		if (0) {//by zhu
-#if defined(CONFIG_POWER_EXT)
-			battery_log(BAT_LOG_CRTI,
-					    "[BATTERY] CONFIG_POWER_EXT, no update battery update power down.\n");
-#else
-			{
-				if ((g_platform_boot_mode == META_BOOT)
-				    || (g_platform_boot_mode == ADVMETA_BOOT)
-				    || (g_platform_boot_mode == ATE_FACTORY_BOOT)) {
-					battery_log(BAT_LOG_FULL,
-							    "[BATTERY] boot mode = %d, bypass temperature check\n",
-							    g_platform_boot_mode);
-				} else {
-					struct battery_data *bat_data = &battery_main;
-					struct power_supply *bat_psy = &bat_data->psy;
-
-					battery_log(BAT_LOG_CRTI,
-							    "[Battery] Tbat(%d)>=60, system need power down.\n",
-							    BMT_status.temperature);
-
-					bat_data->BAT_CAPACITY = 0;
-
-					power_supply_changed(bat_psy);
-
-					if (BMT_status.charger_exist == KAL_TRUE) {
-						/* can not power down due to charger exist, so need reset system */
-						battery_charging_control
-						    (CHARGING_CMD_SET_PLATFORM_RESET, NULL);
-					}
-					/* avoid SW no feedback */
-					battery_charging_control(CHARGING_CMD_SET_POWER_OFF, NULL);
-					/* mt_power_off(); */
-				}
-			}
-#endif
-		}
-#endif
-
-	}
-
-}
-
-
-static void mt_battery_update_status(void)
-{
-#if defined(CONFIG_POWER_EXT)
-	battery_log(BAT_LOG_CRTI, "[BATTERY] CONFIG_POWER_EXT, no update Android.\n");
-#else
-	{
-		usb_update(&usb_main);
-		ac_update(&ac_main);
-		wireless_update(&wireless_main);
-		battery_update(&battery_main);
-	}
-
-#endif
-}
-
-
-CHARGER_TYPE mt_charger_type_detection(void)
-{
-	CHARGER_TYPE CHR_Type_num = CHARGER_UNKNOWN;
-
-	mutex_lock(&charger_type_mutex);
-
-#if defined(CONFIG_MTK_WIRELESS_CHARGER_SUPPORT)
-	battery_charging_control(CHARGING_CMD_GET_CHARGER_TYPE, &CHR_Type_num);
-	BMT_status.charger_type = CHR_Type_num;
-#else
-	#if !defined(CONFIG_MTK_DUAL_INPUT_CHARGER_SUPPORT)
-	if (BMT_status.charger_type == CHARGER_UNKNOWN) {
-	#else
-	if ((BMT_status.charger_type == CHARGER_UNKNOWN) &&
-	    (DISO_data.diso_state.cur_vusb_state == DISO_ONLINE)) {
-	#endif
-		battery_charging_control(CHARGING_CMD_GET_CHARGER_TYPE, &CHR_Type_num);
-		BMT_status.charger_type = CHR_Type_num;
-
-#if defined(CONFIG_MTK_KERNEL_POWER_OFF_CHARGING)&&(defined(CONFIG_MTK_PUMP_EXPRESS_SUPPORT) || defined(CONFIG_MTK_PUMP_EXPRESS_PLUS_SUPPORT))
- 	    if (BMT_status.UI_SOC == 100)
-		{
-			BMT_status.bat_charging_state = CHR_BATFULL;
-			BMT_status.bat_full = KAL_TRUE;
-			g_charging_full_reset_bat_meter = KAL_TRUE;
-		}	
-
-		 if(g_battery_soc_ready == KAL_FALSE) {
-			if(BMT_status.nPercent_ZCV == 0)
-				battery_meter_initial();
-					
-			BMT_status.SOC = battery_meter_get_battery_percentage();
-		}
-
-		if (BMT_status.bat_vol > 0)
-		{
-        	mt_battery_update_status();
-	}
-		
-#endif
-	}
-#endif
-	mutex_unlock(&charger_type_mutex);
-
-	return BMT_status.charger_type;
-}
-
-CHARGER_TYPE mt_get_charger_type(void)
-{
-#if defined(CONFIG_POWER_EXT) || defined(CONFIG_MTK_FPGA)
-    return STANDARD_HOST;
-#else
-	return BMT_status.charger_type;
-#endif
-}
-
-static void mt_battery_charger_detect_check(void)
-{
-	if (upmu_is_chr_det() == KAL_TRUE) {
-		wake_lock(&battery_suspend_lock);
-
-		#if !defined(CONFIG_MTK_DUAL_INPUT_CHARGER_SUPPORT)
-		BMT_status.charger_exist = KAL_TRUE;
-		#endif
-
-#if defined(CONFIG_MTK_WIRELESS_CHARGER_SUPPORT)
-		mt_charger_type_detection();
-
-		if ((BMT_status.charger_type == STANDARD_HOST)
-		    || (BMT_status.charger_type == CHARGING_HOST)) {
-			mt_usb_connect();
-		}
-#else
-		#if !defined(CONFIG_MTK_DUAL_INPUT_CHARGER_SUPPORT)
-		if (BMT_status.charger_type == CHARGER_UNKNOWN) {
-		#else
-		if ((BMT_status.charger_type == CHARGER_UNKNOWN) &&
-		    (DISO_data.diso_state.cur_vusb_state == DISO_ONLINE)) {
-		#endif
-			mt_charger_type_detection();
-
-			if ((BMT_status.charger_type == STANDARD_HOST)
-			    || (BMT_status.charger_type == CHARGING_HOST)) {
-				mt_usb_connect();
-			}
-		}
-#endif
-
-		battery_log(BAT_LOG_CRTI, "[BAT_thread]Cable in, CHR_Type_num=%d\r\n",
-				    BMT_status.charger_type);
-
-	} else {
-		wake_unlock(&battery_suspend_lock);
-
-		BMT_status.charger_exist = KAL_FALSE;
-		BMT_status.charger_type = CHARGER_UNKNOWN;
-		BMT_status.bat_full = KAL_FALSE;
-		BMT_status.bat_in_recharging_state = KAL_FALSE;
-		BMT_status.bat_charging_state = CHR_PRE;
-		BMT_status.total_charging_time = 0;
-		BMT_status.PRE_charging_time = 0;
-		BMT_status.CC_charging_time = 0;
-		BMT_status.TOPOFF_charging_time = 0;
-		BMT_status.POSTFULL_charging_time = 0;
-
-		battery_log(BAT_LOG_CRTI, "[BAT_thread]Cable out \r\n");
-
-		mt_usb_disconnect();
-	}
-}
-
-static void mt_kpoc_power_off_check(void)
-{
-#ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
-	battery_log(BAT_LOG_CRTI,
-			    "[mt_kpoc_power_off_check] , chr_vol=%d, boot_mode=%d\r\n", BMT_status.charger_vol,
-			    g_platform_boot_mode);
-	if (g_platform_boot_mode == KERNEL_POWER_OFF_CHARGING_BOOT
-	    || g_platform_boot_mode == LOW_POWER_OFF_CHARGING_BOOT) {
-		if ((upmu_is_chr_det() == KAL_FALSE) && (BMT_status.charger_vol < 2500))	/* vbus < 2.5V */
-		{
-			battery_log(BAT_LOG_CRTI,
-					    "[bat_thread_kthread] Unplug Charger/USB In Kernel Power Off Charging Mode!  Shutdown OS!\r\n");
-			battery_charging_control(CHARGING_CMD_SET_POWER_OFF, NULL);
-		}
-	}
-#endif	
-}
-
-void update_battery_2nd_info(int status_smb, int capacity_smb, int present_smb)
-{
-#if defined(CONFIG_POWER_VERIFY)
-	battery_log(BAT_LOG_CRTI, "[update_battery_smb_info] no support\n");
-#else
-	g_status_smb = status_smb;
-	g_capacity_smb = capacity_smb;
-	g_present_smb = present_smb;
-	battery_log(BAT_LOG_CRTI,
-			    "[update_battery_smb_info] get status_smb=%d,capacity_smb=%d,present_smb=%d\n",
-			    status_smb, capacity_smb, present_smb);
-
-	wake_up_bat();
-	g_smartbook_update = 1;
-#endif
-}
-
-void do_chrdet_int_task(void)
-{
-	if (g_bat_init_flag == KAL_TRUE) {
-		#if !defined(CONFIG_MTK_DUAL_INPUT_CHARGER_SUPPORT)
-		if (upmu_is_chr_det() == KAL_TRUE) {
-		#else
-		battery_charging_control(CHARGING_CMD_GET_DISO_STATE, &DISO_data);
-		if ((DISO_data.diso_state.cur_vusb_state == DISO_ONLINE) ||
-		    (DISO_data.diso_state.cur_vdc_state == DISO_ONLINE)) {
-		#endif
-			battery_log(BAT_LOG_CRTI, "[do_chrdet_int_task] charger exist!\n");
-			BMT_status.charger_exist = KAL_TRUE;
-
-			wake_lock(&battery_suspend_lock);
-
-#if defined(CONFIG_POWER_EXT)
-			mt_usb_connect();
-			battery_log(BAT_LOG_CRTI,
-					    "[do_chrdet_int_task] call mt_usb_connect() in EVB\n");
-#elif defined(CONFIG_MTK_POWER_EXT_DETECT)
-			if (KAL_TRUE == bat_is_ext_power()) {
-				mt_usb_connect();
-				battery_log(BAT_LOG_CRTI,
-						    "[do_chrdet_int_task] call mt_usb_connect() in EVB\n");
-				return;
-			}
-#endif
-		} else {
-			battery_log(BAT_LOG_CRTI,
-					    "[do_chrdet_int_task] charger NOT exist!\n");
-			BMT_status.charger_exist = KAL_FALSE;
-
-			#if defined(CONFIG_MTK_DUAL_INPUT_CHARGER_SUPPORT)
-			battery_log(BAT_LOG_CRTI, 
-					    "turn off charging for no avaliable charging source\n");
-			battery_charging_control(CHARGING_CMD_ENABLE,&BMT_status.charger_exist); 
-			#endif
-
-#ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
-			if (g_platform_boot_mode == KERNEL_POWER_OFF_CHARGING_BOOT
-			    || g_platform_boot_mode == LOW_POWER_OFF_CHARGING_BOOT) {
-				battery_log(BAT_LOG_CRTI,
-						    "[pmic_thread_kthread] Unplug Charger/USB In Kernel Power Off Charging Mode!  Shutdown OS!\r\n");
-				battery_charging_control(CHARGING_CMD_SET_POWER_OFF, NULL);
-				/* mt_power_off(); */
-			}
-#endif
-
-			wake_unlock(&battery_suspend_lock);
-
-#if defined(CONFIG_POWER_EXT)
-			mt_usb_disconnect();
-			battery_log(BAT_LOG_CRTI,
-					    "[do_chrdet_int_task] call mt_usb_disconnect() in EVB\n");
-#elif defined(CONFIG_MTK_POWER_EXT_DETECT)
-			if (KAL_TRUE == bat_is_ext_power()) {
-				mt_usb_disconnect();
-				battery_log(BAT_LOG_CRTI,
-						    "[do_chrdet_int_task] call mt_usb_disconnect() in EVB\n");
-				return;
-			}
-#endif
-			#if defined(CONFIG_MTK_PUMP_EXPRESS_SUPPORT) || defined(CONFIG_MTK_PUMP_EXPRESS_PLUS_SUPPORT)
-				 is_ta_connect = KAL_FALSE;    
-				 ta_check_chr_type = KAL_TRUE;
-				 ta_cable_out_occur = KAL_TRUE;
-			#endif
-
-		}
-
-		/* Place charger detection and battery update here is used to speed up charging icon display. */
-
-		mt_battery_charger_detect_check();
-		if (BMT_status.UI_SOC == 100 && BMT_status.charger_exist == KAL_TRUE) {
-			BMT_status.bat_charging_state = CHR_BATFULL;
-			BMT_status.bat_full = KAL_TRUE;
-			g_charging_full_reset_bat_meter = KAL_TRUE;
-		}
-
-		if (g_battery_soc_ready == KAL_FALSE) {
-			if (BMT_status.nPercent_ZCV == 0)
-				battery_meter_initial();
-
-			BMT_status.SOC = battery_meter_get_battery_percentage();
-		}
-
-		if (BMT_status.bat_vol > 0) {
-			mt_battery_update_status();
-		}
-
-		#if defined(CONFIG_MTK_DUAL_INPUT_CHARGER_SUPPORT)
-		DISO_data.chr_get_diso_state = KAL_TRUE;
-		#endif
-
-		wake_up_bat();
-	} else {
-		#if defined(CONFIG_MTK_DUAL_INPUT_CHARGER_SUPPORT)
-		g_vcdt_irq_delay_flag  = KAL_TRUE;
-		#endif
-		battery_log(BAT_LOG_CRTI,
-				    "[do_chrdet_int_task] battery thread not ready, will do after bettery init.\n");
-	}
-
-}
-
-extern void dodprint(void);
-
-void BAT_thread(void)
-{
-	static kal_bool battery_meter_initilized = KAL_FALSE;
-	if (battery_meter_initilized == KAL_FALSE) {
-		battery_meter_initial();	/* move from battery_probe() to decrease booting time */
-		BMT_status.nPercent_ZCV = battery_meter_get_battery_nPercent_zcv();
-		battery_meter_initilized = KAL_TRUE;
-	}
-
-	dodprint();
-	mt_battery_charger_detect_check();
-	mt_battery_GetBatteryData();
-	if (BMT_status.charger_exist == KAL_TRUE) {
-		check_battery_exist();
-	}
-	mt_battery_thermal_check();
-	mt_battery_notify_check();
-
-	if (BMT_status.charger_exist == KAL_TRUE) {
-		mt_battery_CheckBatteryStatus();
-		mt_battery_charging_algorithm();
-	}
-
-	mt_battery_update_status();
-	mt_kpoc_power_off_check();
-}
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Internal API */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-
-#ifdef BATTERY_CDP_WORKAROUND
-extern kal_bool is_charger_detection_rdy(void);
-#endif
-
-
-int bat_thread_kthread(void *x)
-{
-	ktime_t ktime = ktime_set(3, 0);	/* 10s, 10* 1000 ms */
-
-#ifdef BATTERY_CDP_WORKAROUND
-	if(is_charger_detection_rdy()==KAL_FALSE){
-		battery_log(BAT_LOG_CRTI, "CDP, block\n");
-		wait_event(bat_thread_wq, (is_charger_detection_rdy()==KAL_TRUE));
-		battery_log(BAT_LOG_CRTI, "CDP, free\n");
-	}else{
-		battery_log(BAT_LOG_CRTI, "CDP, PASS\n");
-	}
-#endif
-
-	/* Run on a process content */
-	while (1) {
-		mutex_lock(&bat_mutex);
-
-		if (((chargin_hw_init_done == KAL_TRUE) && (battery_suspended == KAL_FALSE)) || ((chargin_hw_init_done == KAL_TRUE) && (fg_wake_up_bat == KAL_TRUE)))
-			BAT_thread();
-
-		mutex_unlock(&bat_mutex);
-
-#ifdef FG_BAT_INT
-		if(fg_wake_up_bat==KAL_TRUE)
-		{
-			wake_unlock(&battery_fg_lock);
-			fg_wake_up_bat=KAL_FALSE;
-			battery_log(BAT_LOG_CRTI, "unlock battery_fg_lock \n");
-		}
-#endif //#ifdef FG_BAT_INT
-
-		battery_log(BAT_LOG_FULL, "wait event\n");
-
-		wait_event(bat_thread_wq, (bat_thread_timeout == KAL_TRUE));
-
-		bat_thread_timeout = KAL_FALSE;
-		hrtimer_start(&battery_kthread_timer, ktime, HRTIMER_MODE_REL);
-		ktime = ktime_set(BAT_TASK_PERIOD, 0);	/* 10s, 10* 1000 ms */
-		if (chr_wake_up_bat == KAL_TRUE && g_smartbook_update != 1)	/* for charger plug in/ out */
-		{
-			#if defined(CONFIG_MTK_DUAL_INPUT_CHARGER_SUPPORT)
-			if (DISO_data.chr_get_diso_state) {
-				DISO_data.chr_get_diso_state = KAL_FALSE;
-				battery_charging_control(CHARGING_CMD_GET_DISO_STATE, &DISO_data);
-			}
-			#endif
-
-			g_smartbook_update = 0;
-			#if defined(CUST_CAPACITY_OCV2CV_TRANSFORM)
-			battery_meter_set_reset_soc(KAL_FALSE);
-			#endif
-			battery_meter_reset();
-			chr_wake_up_bat = KAL_FALSE;
-
-			battery_log(BAT_LOG_CRTI,
-					    "[BATTERY] Charger plug in/out, Call battery_meter_reset. (%d)\n",
-					    BMT_status.UI_SOC);
-		}
-
-	}
-
-	return 0;
-}
-
-void bat_thread_wakeup(void)
-{
-	battery_log(BAT_LOG_FULL, "******** battery : bat_thread_wakeup  ********\n");
-
-	bat_thread_timeout = KAL_TRUE;
-	bat_meter_timeout = KAL_TRUE;
-#ifdef MTK_ENABLE_AGING_ALGORITHM
-    suspend_time = 0;
-#endif
-    _g_bat_sleep_total_time = 0;
-	wake_up(&bat_thread_wq);
-}
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // fop API */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static long adc_cali_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
-{
-	int *user_data_addr;
-	int *naram_data_addr;
-	int i = 0;
-	int ret = 0;
-	int adc_in_data[2] = { 1, 1 };
-	int adc_out_data[2] = { 1, 1 };
-
-	mutex_lock(&bat_mutex);
-
-	switch (cmd) {
-	case TEST_ADC_CALI_PRINT:
-		g_ADC_Cali = KAL_FALSE;
-		break;
-
-	case SET_ADC_CALI_Slop:
-		naram_data_addr = (int *)arg;
-		ret = copy_from_user(adc_cali_slop, naram_data_addr, 36);
-		g_ADC_Cali = KAL_FALSE;	/* enable calibration after setting ADC_CALI_Cal */
-		/* Protection */
-		for (i = 0; i < 14; i++) {
-			if ((*(adc_cali_slop + i) == 0) || (*(adc_cali_slop + i) == 1)) {
-				*(adc_cali_slop + i) = 1000;
-			}
-		}
-		for (i = 0; i < 14; i++)
-			battery_log(BAT_LOG_CRTI, "adc_cali_slop[%d] = %d\n", i,
-					    *(adc_cali_slop + i));
-		battery_log(BAT_LOG_FULL,
-				    "**** unlocked_ioctl : SET_ADC_CALI_Slop Done!\n");
-		break;
-
-	case SET_ADC_CALI_Offset:
-		naram_data_addr = (int *)arg;
-		ret = copy_from_user(adc_cali_offset, naram_data_addr, 36);
-		g_ADC_Cali = KAL_FALSE;	/* enable calibration after setting ADC_CALI_Cal */
-		for (i = 0; i < 14; i++)
-			battery_log(BAT_LOG_CRTI, "adc_cali_offset[%d] = %d\n", i,
-					    *(adc_cali_offset + i));
-		battery_log(BAT_LOG_FULL,
-				    "**** unlocked_ioctl : SET_ADC_CALI_Offset Done!\n");
-		break;
-
-	case SET_ADC_CALI_Cal:
-		naram_data_addr = (int *)arg;
-		ret = copy_from_user(adc_cali_cal, naram_data_addr, 4);
-		g_ADC_Cali = KAL_TRUE;
-		if (adc_cali_cal[0] == 1) {
-			g_ADC_Cali = KAL_TRUE;
-		} else {
-			g_ADC_Cali = KAL_FALSE;
-		}
-		for (i = 0; i < 1; i++)
-			battery_log(BAT_LOG_CRTI, "adc_cali_cal[%d] = %d\n", i,
-					    *(adc_cali_cal + i));
-		battery_log(BAT_LOG_FULL, "**** unlocked_ioctl : SET_ADC_CALI_Cal Done!\n");
-		break;
-
-	case ADC_CHANNEL_READ:
-		/* g_ADC_Cali = KAL_FALSE; */ /* 20100508 Infinity */
-		user_data_addr = (int *)arg;
-		ret = copy_from_user(adc_in_data, user_data_addr, 8);	/* 2*int = 2*4 */
-
-		if (adc_in_data[0] == 0)	/* I_SENSE */
-		{
-			adc_out_data[0] = battery_meter_get_VSense() * adc_in_data[1];
-		} else if (adc_in_data[0] == 1)	/* BAT_SENSE */
-		{
-			adc_out_data[0] = battery_meter_get_battery_voltage(KAL_TRUE) * adc_in_data[1];
-		} else if (adc_in_data[0] == 3)	/* V_Charger */
-		{
-			adc_out_data[0] = battery_meter_get_charger_voltage() * adc_in_data[1];
-			/* adc_out_data[0] = adc_out_data[0] / 100; */
-		} else if (adc_in_data[0] == 30)	/* V_Bat_temp magic number */
-		{
-			adc_out_data[0] = battery_meter_get_battery_temperature() * adc_in_data[1];
-		} else if (adc_in_data[0] == 66) {
-			adc_out_data[0] = (battery_meter_get_battery_current()) / 10;
-
-			if (battery_meter_get_battery_current_sign() == KAL_TRUE) {
-				adc_out_data[0] = 0 - adc_out_data[0];	/* charging */
-			}
-		} else {
-			battery_log(BAT_LOG_FULL, "unknown channel(%d,%d)\n",
-					    adc_in_data[0], adc_in_data[1]);
-		}
-
-		if (adc_out_data[0] < 0)
-			adc_out_data[1] = 1;	/* failed */
-		else
-			adc_out_data[1] = 0;	/* success */
-
-		if (adc_in_data[0] == 30)
-			adc_out_data[1] = 0;	/* success */
-
-		if (adc_in_data[0] == 66)
-			adc_out_data[1] = 0;	/* success */
-
-		ret = copy_to_user(user_data_addr, adc_out_data, 8);
-		battery_log(BAT_LOG_CRTI,
-				    "**** unlocked_ioctl : Channel %d * %d times = %d\n",
-				    adc_in_data[0], adc_in_data[1], adc_out_data[0]);
-		break;
-
-	case BAT_STATUS_READ:
-		user_data_addr = (int *)arg;
-		ret = copy_from_user(battery_in_data, user_data_addr, 4);
-		/* [0] is_CAL */
-		if (g_ADC_Cali) {
-			battery_out_data[0] = 1;
-		} else {
-			battery_out_data[0] = 0;
-		}
-		ret = copy_to_user(user_data_addr, battery_out_data, 4);
-		battery_log(BAT_LOG_CRTI, "**** unlocked_ioctl : CAL:%d\n",
-				    battery_out_data[0]);
-		break;
-
-	case Set_Charger_Current:	/* For Factory Mode */
-		user_data_addr = (int *)arg;
-		ret = copy_from_user(charging_level_data, user_data_addr, 4);
-		g_ftm_battery_flag = KAL_TRUE;
-		if (charging_level_data[0] == 0) {
-			charging_level_data[0] = CHARGE_CURRENT_70_00_MA;
-		} else if (charging_level_data[0] == 1) {
-			charging_level_data[0] = CHARGE_CURRENT_200_00_MA;
-		} else if (charging_level_data[0] == 2) {
-			charging_level_data[0] = CHARGE_CURRENT_400_00_MA;
-		} else if (charging_level_data[0] == 3) {
-			charging_level_data[0] = CHARGE_CURRENT_450_00_MA;
-		} else if (charging_level_data[0] == 4) {
-			charging_level_data[0] = CHARGE_CURRENT_550_00_MA;
-		} else if (charging_level_data[0] == 5) {
-			charging_level_data[0] = CHARGE_CURRENT_650_00_MA;
-		} else if (charging_level_data[0] == 6) {
-			charging_level_data[0] = CHARGE_CURRENT_700_00_MA;
-		} else if (charging_level_data[0] == 7) {
-			charging_level_data[0] = CHARGE_CURRENT_800_00_MA;
-		} else if (charging_level_data[0] == 8) {
-			charging_level_data[0] = CHARGE_CURRENT_900_00_MA;
-		} else if (charging_level_data[0] == 9) {
-			charging_level_data[0] = CHARGE_CURRENT_1000_00_MA;
-		} else if (charging_level_data[0] == 10) {
-			charging_level_data[0] = CHARGE_CURRENT_1100_00_MA;
-		} else if (charging_level_data[0] == 11) {
-			charging_level_data[0] = CHARGE_CURRENT_1200_00_MA;
-		} else if (charging_level_data[0] == 12) {
-			charging_level_data[0] = CHARGE_CURRENT_1300_00_MA;
-		} else if (charging_level_data[0] == 13) {
-			charging_level_data[0] = CHARGE_CURRENT_1400_00_MA;
-		} else if (charging_level_data[0] == 14) {
-			charging_level_data[0] = CHARGE_CURRENT_1500_00_MA;
-		} else if (charging_level_data[0] == 15) {
-			charging_level_data[0] = CHARGE_CURRENT_1600_00_MA;
-		} else {
-			charging_level_data[0] = CHARGE_CURRENT_450_00_MA;
-		}
-		wake_up_bat();
-		battery_log(BAT_LOG_CRTI, "**** unlocked_ioctl : set_Charger_Current:%d\n",
-				    charging_level_data[0]);
-		break;
-		/* add for meta tool------------------------------- */
-	case Get_META_BAT_VOL:
-		user_data_addr = (int *)arg;
-		ret = copy_from_user(adc_in_data, user_data_addr, 8);
-		adc_out_data[0] = BMT_status.bat_vol;
-		ret = copy_to_user(user_data_addr, adc_out_data, 8);
-
-		break;
-	case Get_META_BAT_SOC:
-		user_data_addr = (int *)arg;
-		ret = copy_from_user(adc_in_data, user_data_addr, 8);
-		adc_out_data[0] = BMT_status.UI_SOC;
-		ret = copy_to_user(user_data_addr, adc_out_data, 8);
-
-		break;
-		/* add bing meta tool------------------------------- */
-
-	default :
-		g_ADC_Cali = KAL_FALSE;
-		break;
-	}
-
-	mutex_unlock(&bat_mutex);
-
-	return 0;
-}
-
-static int adc_cali_open(struct inode *inode, struct file *file)
-{
-	return 0;
-}
-
-static int adc_cali_release(struct inode *inode, struct file *file)
-{
-	return 0;
-}
-
-
-static struct file_operations adc_cali_fops = {
-	.owner = THIS_MODULE,
-	.unlocked_ioctl = adc_cali_ioctl,
-	.open = adc_cali_open,
-	.release = adc_cali_release,
-};
-
-
-void check_battery_exist(void)
-{
-#if defined(CONFIG_DIS_CHECK_BATTERY)
-	battery_log(BAT_LOG_CRTI, "[BATTERY] Disable check battery exist.\n");
-#else
-	kal_uint32 baton_count = 0;
-	kal_uint32 charging_enable = KAL_FALSE;
-	kal_uint32 battery_status;
-	kal_uint32 i;
-
-	for (i = 0; i < 3; i++) {
-		battery_charging_control(CHARGING_CMD_GET_BATTERY_STATUS, &battery_status);
-		baton_count += battery_status;
-
-	}
-
-	if (baton_count >= 3) {
-		if ((g_platform_boot_mode == META_BOOT) || (g_platform_boot_mode == ADVMETA_BOOT)
-		    || (g_platform_boot_mode == ATE_FACTORY_BOOT)) {
-			battery_log(BAT_LOG_FULL,
-					    "[BATTERY] boot mode = %d, bypass battery check\n",
-					    g_platform_boot_mode);
-		} else {
-			battery_log(BAT_LOG_CRTI,
-					    "[BATTERY] Battery is not exist, power off FAN5405 and system (%d)\n",
-					    baton_count);
-
-			//battery_charging_control(CHARGING_CMD_ENABLE, &charging_enable);//by zhu
-			//battery_charging_control(CHARGING_CMD_SET_POWER_OFF, NULL);
-		}
-	}
-#endif
-}
-
-
-#if defined(MTK_PLUG_OUT_DETECTION)
-
-void charger_plug_out_sw_mode(void)
-{
-	kal_int32 ICharging;
-	kal_int16 i;
-	kal_int16 cnt=0;				
-	kal_bool enable;
-	kal_uint32 charging_enable;
-	kal_int32 VCharger;
-
-	if (BMT_status.charger_exist == KAL_TRUE)
-	{
-		if (chargin_hw_init_done && upmu_is_chr_det() == KAL_TRUE)
-		{
-
-			for(i=0;i<4;i++)
-			{
-				enable=pmic_get_register_value(PMIC_RG_CHR_EN);
-
-					if(enable==1)
-					{
-
-						ICharging=battery_meter_get_charging_current_imm();
-						VCharger=battery_meter_get_charger_voltage();
-						if(ICharging<70 && VCharger<4400)
-						{
-							cnt++;
-							battery_log(BAT_LOG_CRTI,"[charger_hv_detect_sw_thread_handler] fail ICharging=%d , VCHR=%d cnt=%d \n",ICharging,VCharger,cnt);	
-						}
-						else
-						{
-							battery_log(BAT_LOG_CRTI,"[charger_hv_detect_sw_thread_handler] success ICharging=%d , VCHR=%d cnt=%d \n",ICharging,VCharger,cnt);	
-							break;
-						}
-					}
-					else
-					{
-						break;
-					}
-			}
-
-			if (cnt>=3)
-			{
-				charging_enable = KAL_FALSE;
-				battery_charging_control(CHARGING_CMD_ENABLE, &charging_enable);
-				battery_log(BAT_LOG_CRTI,"[charger_hv_detect_sw_thread_handler] ICharging=%d VCHR=%d cnt=%d turn off charging\n",ICharging,VCharger,cnt);					
-			}	
-
-		}
-	}
-
-}
-
-
-extern kal_uint32 upmu_get_reg_value(kal_uint32 reg);
-void hv_sw_mode(void)
-{
-	kal_bool hv_status;
-	kal_uint32 charging_enable;
-
-		if ((upmu_is_chr_det() == KAL_TRUE)) {
-			check_battery_exist();
-		}
-
-
-		if (chargin_hw_init_done)
-			battery_charging_control(CHARGING_CMD_GET_HV_STATUS, &hv_status);
-
-		if (hv_status == KAL_TRUE) {
-			battery_log(BAT_LOG_CRTI,
-					    "[charger_hv_detect_sw_thread_handler] charger hv\n");
-
-			charging_enable = KAL_FALSE;
-			if (chargin_hw_init_done)
-				battery_charging_control(CHARGING_CMD_ENABLE, &charging_enable);
-		} else {
-			battery_log(BAT_LOG_FULL,
-					    "[charger_hv_detect_sw_thread_handler] upmu_chr_get_vcdt_hv_det() != 1\n");
-		}
-
-	//battery_log(BAT_LOG_CRTI,"[PMIC_BIAS_GEN_EN & PMIC_BIAS_GEN_EN_SEL] 0xa=0x%x \n",upmu_get_reg_value(0x000a));	
-	if(pmic_get_register_value(PMIC_BIAS_GEN_EN)==1 || pmic_get_register_value(PMIC_BIAS_GEN_EN_SEL)==0)
-	{
-		battery_log(BAT_LOG_CRTI,"[PMIC_BIAS_GEN_EN & PMIC_BIAS_GEN_EN_SEL] be writen 0xa=0x%x \n",upmu_get_reg_value(0x000a));	
-		BUG_ON(1);
-	}
-		
-	if (chargin_hw_init_done)
-		battery_charging_control(CHARGING_CMD_RESET_WATCH_DOG_TIMER, NULL);
-
-	}
-
-int charger_hv_detect_sw_thread_handler(void *unused)
-		{
-	ktime_t ktime;
-	kal_uint32 hv_voltage = V_CHARGER_MAX*1000;
-
-
-	kal_uint8 cnt=0;
-
-	#if defined(CONFIG_MTK_DUAL_INPUT_CHARGER_SUPPORT)
-	hv_voltage = DISO_data.hv_voltage;
-#endif
-
-	do {
-
-			if (BMT_status.charger_exist == KAL_TRUE)
-			{
-			ktime = ktime_set(0, BAT_MS_TO_NS(200));
-		}
-		else
-				{
-			ktime = ktime_set(0, BAT_MS_TO_NS(1000));
-		}		
-
-
-		if (chargin_hw_init_done)
-			battery_charging_control(CHARGING_CMD_SET_HV_THRESHOLD, &hv_voltage);
-
-		wait_event_interruptible(charger_hv_detect_waiter,
-					 (charger_hv_detect_flag == KAL_TRUE));
-
-		if(BMT_status.charger_exist == KAL_TRUE)
-							{
-			if(cnt>=5)
-			{
-				//battery_log(BAT_LOG_CRTI,
-				//"[charger_hv_detect_sw_thread_handler] charger in do hv_sw_mode\n");			
-				hv_sw_mode();
-				cnt=0;
-}
-							else
-							{
-				cnt++;
-							}
-
-			//battery_log(BAT_LOG_CRTI,
-			//	"[charger_hv_detect_sw_thread_handler] charger in cnt=%d \n",cnt);				
-			charger_plug_out_sw_mode();
-						}
-						else
-						{
-			//		battery_log(BAT_LOG_CRTI,
-			//		"[charger_hv_detect_sw_thread_handler] charger out do hv_sw_mode\n");
-			hv_sw_mode();
-						}
-
-
-		charger_hv_detect_flag = KAL_FALSE;
-		hrtimer_start(&charger_hv_detect_timer, ktime, HRTIMER_MODE_REL);
-
-	} while (!kthread_should_stop());
-
-	return 0;
-					}
-
-#else
-int charger_hv_detect_sw_thread_handler(void *unused)
-{
-	ktime_t ktime;
-	kal_uint32 charging_enable;
-	kal_uint32 hv_voltage = V_CHARGER_MAX*1000;
-	kal_bool hv_status;
-
-	#if defined(CONFIG_MTK_DUAL_INPUT_CHARGER_SUPPORT)
-	hv_voltage = DISO_data.hv_voltage;
-	#endif
-
-	do {
-		ktime = ktime_set(0, BAT_MS_TO_NS(1000));
-
-		if (chargin_hw_init_done)
-			battery_charging_control(CHARGING_CMD_SET_HV_THRESHOLD, &hv_voltage);
-
-		wait_event_interruptible(charger_hv_detect_waiter,
-					 (charger_hv_detect_flag == KAL_TRUE));
-
-		if ((upmu_is_chr_det() == KAL_TRUE)) {
-			check_battery_exist();
-		}
-
-
-
-		charger_hv_detect_flag = KAL_FALSE;
-
-		if (chargin_hw_init_done)
-			battery_charging_control(CHARGING_CMD_GET_HV_STATUS, &hv_status);
-
-		if (hv_status == KAL_TRUE) {
-			battery_log(BAT_LOG_CRTI,
-					    "[charger_hv_detect_sw_thread_handler] charger hv\n");
-
-			charging_enable = KAL_FALSE;
-			if (chargin_hw_init_done)
-				battery_charging_control(CHARGING_CMD_ENABLE, &charging_enable);
-		} else {
-			battery_log(BAT_LOG_FULL,
-					    "[charger_hv_detect_sw_thread_handler] upmu_chr_get_vcdt_hv_det() != 1\n");
-		}
-
-
-
-		if (chargin_hw_init_done)
-			battery_charging_control(CHARGING_CMD_RESET_WATCH_DOG_TIMER, NULL);
-
-		hrtimer_start(&charger_hv_detect_timer, ktime, HRTIMER_MODE_REL);
-
-	} while (!kthread_should_stop());
-
-	return 0;
-}
-#endif //#if defined(MTK_PLUG_OUT_DETECTION)
-
-enum hrtimer_restart charger_hv_detect_sw_workaround(struct hrtimer *timer)
-{
-	charger_hv_detect_flag = KAL_TRUE;
-	wake_up_interruptible(&charger_hv_detect_waiter);
-
-	battery_log(BAT_LOG_FULL, "[charger_hv_detect_sw_workaround]\n");
-
-	return HRTIMER_NORESTART;
-}
-
-void charger_hv_detect_sw_workaround_init(void)
-{
-	ktime_t ktime;
-
-	ktime = ktime_set(0, BAT_MS_TO_NS(2000));
-	hrtimer_init(&charger_hv_detect_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-	charger_hv_detect_timer.function = charger_hv_detect_sw_workaround;
-	hrtimer_start(&charger_hv_detect_timer, ktime, HRTIMER_MODE_REL);
-
-	charger_hv_detect_thread =
-	    kthread_run(charger_hv_detect_sw_thread_handler, 0,
-			"mtk charger_hv_detect_sw_workaround");
-	if (IS_ERR(charger_hv_detect_thread)) {
-		battery_log(BAT_LOG_FULL,
-				    "[%s]: failed to create charger_hv_detect_sw_workaround thread\n",
-				    __func__);
-	}
-	check_battery_exist();
-	battery_log(BAT_LOG_CRTI, "charger_hv_detect_sw_workaround_init : done\n");
-}
-
-
-enum hrtimer_restart battery_kthread_hrtimer_func(struct hrtimer *timer)
-{
-	bat_thread_wakeup();
-
-	return HRTIMER_NORESTART;
-}
-
-void battery_kthread_hrtimer_init(void)
-{
-	ktime_t ktime;
-
-	ktime = ktime_set(1, 0);	/* 3s, 10* 1000 ms */
-	hrtimer_init(&battery_kthread_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-	battery_kthread_timer.function = battery_kthread_hrtimer_func;
-	hrtimer_start(&battery_kthread_timer, ktime, HRTIMER_MODE_REL);
-
-	battery_log(BAT_LOG_CRTI, "battery_kthread_hrtimer_init : done\n");
-}
-
-
-static void get_charging_control(void)
-{
-	battery_charging_control = chr_control_interface;
-}
-
-#if defined(CONFIG_MTK_DUAL_INPUT_CHARGER_SUPPORT)
-static irqreturn_t diso_auxadc_irq_thread(int irq, void *dev_id)
-{
-	int pre_diso_state = (DISO_data.diso_state.pre_otg_state |
-		(DISO_data.diso_state.pre_vusb_state << 1) |
-		(DISO_data.diso_state.pre_vdc_state << 2)) & 0x7;
-
-	battery_log(BAT_LOG_CRTI,
-			    "[DISO]auxadc IRQ threaded handler triggered, pre_diso_state is %s\n",
-			    DISO_state_s[pre_diso_state]);
-
-	switch (pre_diso_state) {
-	#ifdef MTK_DISCRETE_SWITCH /*for DSC DC plugin handle */
-	case USB_ONLY:
-	#endif
-	case OTG_ONLY:
-		BMT_status.charger_exist = KAL_TRUE;
-		wake_lock(&battery_suspend_lock);
-		wake_up_bat();
-		break;
-	case DC_WITH_OTG:
-		BMT_status.charger_exist = KAL_FALSE;
-		battery_charging_control(CHARGING_CMD_ENABLE,&BMT_status.charger_exist); // need stop charger quickly
-		BMT_status.charger_exist = KAL_FALSE; //reset charger status
-		BMT_status.charger_type = CHARGER_UNKNOWN;
-		wake_unlock(&battery_suspend_lock);
-		wake_up_bat();
-		break;
-	case DC_WITH_USB:
-		/*usb delayed work will reflact BMT_staus , so need update state ASAP*/
-		if((BMT_status.charger_type==STANDARD_HOST) || (BMT_status.charger_type==CHARGING_HOST))
-			mt_usb_disconnect(); /* disconnect if connected */
-		BMT_status.charger_type = CHARGER_UNKNOWN;// reset chr_type
-		wake_up_bat();
-		break;
-	case DC_ONLY:
-		BMT_status.charger_type = CHARGER_UNKNOWN;
-		mt_battery_charger_detect_check(); //plug in VUSB, check if need connect usb
-		break;
-	default:
-		battery_log(BAT_LOG_CRTI,
-				    "[DISO]VUSB auxadc threaded handler triggered ERROR OR TEST\n");
-		break;
-	}
-	return IRQ_HANDLED;
-}
-
-static void dual_input_init(void)
-{
-	DISO_data.irq_callback_func = diso_auxadc_irq_thread;
-	battery_charging_control(CHARGING_CMD_DISO_INIT, &DISO_data);
-}
-#endif
-static int battery_probe(struct platform_device *dev)
-{
-	struct class_device *class_dev = NULL;
-	int ret = 0;
-
-	battery_log(BAT_LOG_CRTI, "******** battery driver probe!! ********\n");
-
-	/* Integrate with NVRAM */
-	ret = alloc_chrdev_region(&adc_cali_devno, 0, 1, ADC_CALI_DEVNAME);
-	if (ret)
-		battery_log(BAT_LOG_CRTI, "Error: Can't Get Major number for adc_cali\n");
-	adc_cali_cdev = cdev_alloc();
-	adc_cali_cdev->owner = THIS_MODULE;
-	adc_cali_cdev->ops = &adc_cali_fops;
-	ret = cdev_add(adc_cali_cdev, adc_cali_devno, 1);
-	if (ret)
-		battery_log(BAT_LOG_CRTI, "adc_cali Error: cdev_add\n");
-	adc_cali_major = MAJOR(adc_cali_devno);
-	adc_cali_class = class_create(THIS_MODULE, ADC_CALI_DEVNAME);
-	class_dev = (struct class_device *)device_create(adc_cali_class,
-							 NULL,
-							 adc_cali_devno, NULL, ADC_CALI_DEVNAME);
-	battery_log(BAT_LOG_CRTI, "[BAT_probe] adc_cali prepare : done !!\n ");
-
-	get_charging_control();
-
-	battery_charging_control(CHARGING_CMD_GET_PLATFORM_BOOT_MODE, &g_platform_boot_mode);
-	battery_log(BAT_LOG_CRTI, "[BAT_probe] g_platform_boot_mode = %d\n ",
-			    g_platform_boot_mode);
-
-	wake_lock_init(&battery_fg_lock, WAKE_LOCK_SUSPEND, "battery fg wakelock");
-
-	wake_lock_init(&battery_suspend_lock, WAKE_LOCK_SUSPEND, "battery suspend wakelock");
-	#if defined(CONFIG_MTK_PUMP_EXPRESS_SUPPORT) || defined(CONFIG_MTK_PUMP_EXPRESS_PLUS_SUPPORT)
-	wake_lock_init(&TA_charger_suspend_lock, WAKE_LOCK_SUSPEND, "TA charger suspend wakelock");  
-	#endif
-
-	/* Integrate with Android Battery Service */
-	ret = power_supply_register(&(dev->dev), &ac_main.psy);
-	if (ret) {
-		battery_log(BAT_LOG_CRTI, "[BAT_probe] power_supply_register AC Fail !!\n");
-		return ret;
-	}
-	battery_log(BAT_LOG_CRTI, "[BAT_probe] power_supply_register AC Success !!\n");
-
-	ret = power_supply_register(&(dev->dev), &usb_main.psy);
-	if (ret) {
-		battery_log(BAT_LOG_CRTI,
-				    "[BAT_probe] power_supply_register USB Fail !!\n");
-		return ret;
-	}
-	battery_log(BAT_LOG_CRTI, "[BAT_probe] power_supply_register USB Success !!\n");
-
-	ret = power_supply_register(&(dev->dev), &wireless_main.psy);
-	if (ret) {
-		battery_log(BAT_LOG_CRTI,
-				    "[BAT_probe] power_supply_register WIRELESS Fail !!\n");
-		return ret;
-	}
-	battery_log(BAT_LOG_CRTI,
-			    "[BAT_probe] power_supply_register WIRELESS Success !!\n");
-
-	ret = power_supply_register(&(dev->dev), &battery_main.psy);
-	if (ret) {
-		battery_log(BAT_LOG_CRTI,
-				    "[BAT_probe] power_supply_register Battery Fail !!\n");
-		return ret;
-	}
-	battery_log(BAT_LOG_CRTI, "[BAT_probe] power_supply_register Battery Success !!\n");
-
-#if !defined(CONFIG_POWER_EXT)
-
-#ifdef CONFIG_MTK_POWER_EXT_DETECT
-	if (KAL_TRUE == bat_is_ext_power()) {
-		battery_main.BAT_STATUS = POWER_SUPPLY_STATUS_FULL;
-		battery_main.BAT_HEALTH = POWER_SUPPLY_HEALTH_GOOD;
-		battery_main.BAT_PRESENT = 1;
-		battery_main.BAT_TECHNOLOGY = POWER_SUPPLY_TECHNOLOGY_LION;
-		battery_main.BAT_CAPACITY = 100;
-		battery_main.BAT_batt_vol = 4200;
-		battery_main.BAT_batt_temp = 220;
-
-		g_bat_init_flag = KAL_TRUE;
-		return 0;
-	}
-#endif
-	/* For EM */
-	{
-		int ret_device_file = 0;
-
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_ADC_Charger_Voltage);
-
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_ADC_Channel_0_Slope);
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_ADC_Channel_1_Slope);
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_ADC_Channel_2_Slope);
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_ADC_Channel_3_Slope);
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_ADC_Channel_4_Slope);
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_ADC_Channel_5_Slope);
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_ADC_Channel_6_Slope);
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_ADC_Channel_7_Slope);
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_ADC_Channel_8_Slope);
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_ADC_Channel_9_Slope);
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_ADC_Channel_10_Slope);
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_ADC_Channel_11_Slope);
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_ADC_Channel_12_Slope);
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_ADC_Channel_13_Slope);
-
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_ADC_Channel_0_Offset);
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_ADC_Channel_1_Offset);
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_ADC_Channel_2_Offset);
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_ADC_Channel_3_Offset);
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_ADC_Channel_4_Offset);
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_ADC_Channel_5_Offset);
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_ADC_Channel_6_Offset);
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_ADC_Channel_7_Offset);
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_ADC_Channel_8_Offset);
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_ADC_Channel_9_Offset);
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_ADC_Channel_10_Offset);
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_ADC_Channel_11_Offset);
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_ADC_Channel_12_Offset);
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_ADC_Channel_13_Offset);
-
-		ret_device_file =
-		    device_create_file(&(dev->dev), &dev_attr_ADC_Channel_Is_Calibration);
-
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_Power_On_Voltage);
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_Power_Off_Voltage);
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_Charger_TopOff_Value);
-
-		ret_device_file =
-		    device_create_file(&(dev->dev), &dev_attr_FG_Battery_CurrentConsumption);
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_FG_SW_CoulombCounter);
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_Charging_CallState);
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_Charger_Type);
-#if defined(CONFIG_MTK_PUMP_EXPRESS_SUPPORT) || defined(CONFIG_MTK_PUMP_EXPRESS_PLUS_SUPPORT)
-		ret_device_file = device_create_file(&(dev->dev), &dev_attr_Pump_Express);
-#endif
-	}
-
-	/* battery_meter_initial();      //move to mt_battery_GetBatteryData() to decrease booting time */
-
-	/* Initialization BMT Struct */
-	BMT_status.bat_exist = KAL_TRUE;	/* phone must have battery */
-	BMT_status.charger_exist = KAL_FALSE;	/* for default, no charger */
-	BMT_status.bat_vol = 0;
-	BMT_status.ICharging = 0;
-	BMT_status.temperature = 0;
-	BMT_status.charger_vol = 0;
-	BMT_status.total_charging_time = 0;
-	BMT_status.PRE_charging_time = 0;
-	BMT_status.CC_charging_time = 0;
-	BMT_status.TOPOFF_charging_time = 0;
-	BMT_status.POSTFULL_charging_time = 0;
-	BMT_status.SOC = 0;
-	BMT_status.UI_SOC = 0;
-
-	BMT_status.bat_charging_state = CHR_PRE;
-	BMT_status.bat_in_recharging_state = KAL_FALSE;
-	BMT_status.bat_full = KAL_FALSE;
-	BMT_status.nPercent_ZCV = 0;
-	BMT_status.nPrecent_UI_SOC_check_point = battery_meter_get_battery_nPercent_UI_SOC();
-
-	#if defined(CONFIG_MTK_DUAL_INPUT_CHARGER_SUPPORT)
-	dual_input_init();
-	#endif
-
-	/* battery kernel thread for 10s check and charger in/out event */
-	/* Replace GPT timer by hrtime */
-	battery_kthread_hrtimer_init();
-
-	kthread_run(bat_thread_kthread, NULL, "bat_thread_kthread");
-	battery_log(BAT_LOG_CRTI, "[battery_probe] bat_thread_kthread Done\n");
-
-
-	charger_hv_detect_sw_workaround_init();
-
-
-	/*LOG System Set */
-	init_proc_log();
-
-#else
-	//keep HW alive
-	//charger_hv_detect_sw_workaround_init();
-#endif
-	g_bat_init_flag = KAL_TRUE;
-
-#if defined(CONFIG_MTK_DUAL_INPUT_CHARGER_SUPPORT)
-    if (g_vcdt_irq_delay_flag == KAL_TRUE)
-        do_chrdet_int_task();
-#endif
-
-	return 0;
-
-}
-
-static void battery_timer_pause(void)
-{
-	struct timespec xts, tom;
-
-    //battery_log(BAT_LOG_CRTI, "******** battery driver suspend!! ********\n" );
-#ifdef CONFIG_POWER_EXT
-#else
-
-#ifdef CONFIG_MTK_POWER_EXT_DETECT
-	if (KAL_TRUE == bat_is_ext_power())
-		return 0;
-#endif
-	mutex_lock(&bat_mutex);
-	//cancel timer
-	hrtimer_cancel(&battery_kthread_timer);
-	hrtimer_cancel(&charger_hv_detect_timer);
-
-	battery_suspended = KAL_TRUE;
-	mutex_unlock(&bat_mutex);
-
-	battery_log(BAT_LOG_CRTI, "@bs=1@\n");
-#endif
-
-	get_xtime_and_monotonic_and_sleep_offset(&xts, &tom, &g_bat_time_before_sleep);
-}
-
-static void battery_timer_resume(void)
-{
-#ifdef CONFIG_POWER_EXT
-#else
-	kal_bool is_pcm_timer_trigger = KAL_FALSE;
-	struct timespec xts, tom, bat_time_after_sleep;
-	ktime_t ktime, hvtime;
-
-#ifdef CONFIG_MTK_POWER_EXT_DETECT
-	if (KAL_TRUE == bat_is_ext_power())
-		return 0;
-#endif
-
-    ktime = ktime_set(BAT_TASK_PERIOD, 0);  // 10s, 10* 1000 ms
-	hvtime = ktime_set(0, BAT_MS_TO_NS(2000));
-
-	get_xtime_and_monotonic_and_sleep_offset(&xts, &tom, &bat_time_after_sleep);
-	battery_charging_control(CHARGING_CMD_GET_IS_PCM_TIMER_TRIGGER, &is_pcm_timer_trigger);
-
-	if(is_pcm_timer_trigger == KAL_TRUE || bat_spm_timeout)
-	{	
-		mutex_lock(&bat_mutex);
-		BAT_thread();
-		mutex_unlock(&bat_mutex);
-	}
-	else
-	{
-		battery_log(BAT_LOG_CRTI, "battery resume NOT by pcm timer!!\n");
-	}
-
-	if(g_call_state == CALL_ACTIVE && (bat_time_after_sleep.tv_sec - g_bat_time_before_sleep.tv_sec >= TALKING_SYNC_TIME))	// phone call last than x min
-	{
-		BMT_status.UI_SOC = battery_meter_get_battery_percentage();
-		battery_log(BAT_LOG_CRTI, "Sync UI SOC to SOC immediately\n");
-	}
-
-	mutex_lock(&bat_mutex);
-
-	//restore timer
-	hrtimer_start(&battery_kthread_timer, ktime, HRTIMER_MODE_REL);
-	hrtimer_start(&charger_hv_detect_timer, hvtime, HRTIMER_MODE_REL);
-
-	battery_suspended = KAL_FALSE;
-	battery_log(BAT_LOG_CRTI, "@bs=0@\n");
-	mutex_unlock(&bat_mutex);
-
-#endif
-}
-
-static int battery_remove(struct platform_device *dev)
-{
-	battery_log(BAT_LOG_CRTI, "******** battery driver remove!! ********\n");
-
-	return 0;
-}
-
-static void battery_shutdown(struct platform_device *dev)
-{
-	battery_log(BAT_LOG_CRTI, "******** battery driver shutdown!! ********\n");
-
-}
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // Battery Notify API */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-static ssize_t show_BatteryNotify(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	battery_log(BAT_LOG_CRTI, "[Battery] show_BatteryNotify : %x\n",
-			    g_BatteryNotifyCode);
-
-	return sprintf(buf, "%u\n", g_BatteryNotifyCode);
-}
-
-static ssize_t store_BatteryNotify(struct device *dev, struct device_attribute *attr,
-				   const char *buf, size_t size)
-{
-	char *pvalue = NULL;
-	unsigned int reg_BatteryNotifyCode = 0;
-	battery_log(BAT_LOG_CRTI, "[Battery] store_BatteryNotify\n");
-	if (buf != NULL && size != 0) {
-		battery_log(BAT_LOG_CRTI, "[Battery] buf is %s and size is %Zu\n", buf,
-				    size);
-		reg_BatteryNotifyCode = simple_strtoul(buf, &pvalue, 16);
-		g_BatteryNotifyCode = reg_BatteryNotifyCode;
-		battery_log(BAT_LOG_CRTI, "[Battery] store code : %x\n",
-				    g_BatteryNotifyCode);
-	}
-	return size;
-}
-
-static DEVICE_ATTR(BatteryNotify, 0664, show_BatteryNotify, store_BatteryNotify);
-
-static ssize_t show_BN_TestMode(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	battery_log(BAT_LOG_CRTI, "[Battery] show_BN_TestMode : %x\n", g_BN_TestMode);
-	return sprintf(buf, "%u\n", g_BN_TestMode);
-}
-
-static ssize_t store_BN_TestMode(struct device *dev, struct device_attribute *attr, const char *buf,
-				 size_t size)
-{
-	char *pvalue = NULL;
-	unsigned int reg_BN_TestMode = 0;
-	battery_log(BAT_LOG_CRTI, "[Battery] store_BN_TestMode\n");
-	if (buf != NULL && size != 0) {
-		battery_log(BAT_LOG_CRTI, "[Battery] buf is %s and size is %Zu\n", buf,
-				    size);
-		reg_BN_TestMode = simple_strtoul(buf, &pvalue, 16);
-		g_BN_TestMode = reg_BN_TestMode;
-		battery_log(BAT_LOG_CRTI, "[Battery] store g_BN_TestMode : %x\n",
-				    g_BN_TestMode);
-	}
-	return size;
-}
-
-static DEVICE_ATTR(BN_TestMode, 0664, show_BN_TestMode, store_BN_TestMode);
-
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // platform_driver API */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-#if 0
-static int battery_cmd_read(char *buf, char **start, off_t off, int count, int *eof, void *data)
-{
-	int len = 0;
-	char *p = buf;
-
-	p += sprintf(p,
-		     "g_battery_thermal_throttling_flag=%d,\nbattery_cmd_thermal_test_mode=%d,\nbattery_cmd_thermal_test_mode_value=%d\n",
-		     g_battery_thermal_throttling_flag, battery_cmd_thermal_test_mode,
-		     battery_cmd_thermal_test_mode_value);
-
-	*start = buf + off;
-
-	len = p - buf;
-	if (len > off)
-		len -= off;
-	else
-		len = 0;
-
-	return len < count ? len : count;
-}
-#endif
-
-static ssize_t battery_cmd_write(struct file *file, const char *buffer, size_t count, loff_t *data)
-{
-	int len = 0, bat_tt_enable = 0, bat_thr_test_mode = 0, bat_thr_test_value = 0;
-	char desc[32];
-
-	len = (count < (sizeof(desc) - 1)) ? count : (sizeof(desc) - 1);
-	if (copy_from_user(desc, buffer, len)) {
-		return 0;
-	}
-	desc[len] = '\0';
-
-	if (sscanf(desc, "%d %d %d", &bat_tt_enable, &bat_thr_test_mode, &bat_thr_test_value) == 3) {
-		g_battery_thermal_throttling_flag = bat_tt_enable;
-		battery_cmd_thermal_test_mode = bat_thr_test_mode;
-		battery_cmd_thermal_test_mode_value = bat_thr_test_value;
-
-		battery_log(BAT_LOG_CRTI,
-				    "bat_tt_enable=%d, bat_thr_test_mode=%d, bat_thr_test_value=%d\n",
-				    g_battery_thermal_throttling_flag,
-				    battery_cmd_thermal_test_mode,
-				    battery_cmd_thermal_test_mode_value);
-
-		return count;
-	} else {
-		battery_log(BAT_LOG_CRTI,
-				    "  bad argument, echo [bat_tt_enable] [bat_thr_test_mode] [bat_thr_test_value] > battery_cmd\n");
-	}
-
-	return -EINVAL;
-}
-
-static int proc_utilization_show(struct seq_file *m, void *v)
-{
-	seq_printf(m,
-		   "=> g_battery_thermal_throttling_flag=%d,\nbattery_cmd_thermal_test_mode=%d,\nbattery_cmd_thermal_test_mode_value=%d\n",
-		   g_battery_thermal_throttling_flag, battery_cmd_thermal_test_mode,
-		   battery_cmd_thermal_test_mode_value);
-
-	seq_printf(m, "=> get_usb_current_unlimited=%d,\ncmd_discharging = %d\n",
-		   get_usb_current_unlimited(), cmd_discharging);
-	return 0;
-}
-
-static int proc_utilization_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, proc_utilization_show, NULL);
-}
-
-static const struct file_operations battery_cmd_proc_fops = {
-	.open = proc_utilization_open,
-	.read = seq_read,
-	.write = battery_cmd_write,
-};
-
-static ssize_t current_cmd_write(struct file *file, const char *buffer, size_t count, loff_t *data)
-{
-	int len = 0;
-	char desc[32];
-	int cmd_current_unlimited = false;
-	U32 charging_enable = false;
-
-	len = (count < (sizeof(desc) - 1)) ? count : (sizeof(desc) - 1);
-	if (copy_from_user(desc, buffer, len)) {
-		return 0;
-	}
-	desc[len] = '\0';
-
-	if (sscanf(desc, "%d %d", &cmd_current_unlimited, &cmd_discharging) == 2) {
-		set_usb_current_unlimited(cmd_current_unlimited);
-		if (cmd_discharging == 1) {
-			charging_enable = false;
-			adjust_power = -1;
-		} else if (cmd_discharging == 0) {
-			charging_enable = true;
-			adjust_power = -1;
-		}
-		battery_charging_control(CHARGING_CMD_ENABLE, &charging_enable);
-
-		battery_log(BAT_LOG_CRTI,
-				    "[current_cmd_write] cmd_current_unlimited=%d, cmd_discharging=%d\n",
-				    cmd_current_unlimited, cmd_discharging);
-		return count;
-	} else {
-		battery_log(BAT_LOG_CRTI, "  bad argument, echo [enable] > current_cmd\n");
-	}
-
-	return -EINVAL;
-}
-
-static int current_cmd_read(struct seq_file *m, void *v)
-{
-	U32 charging_enable = false;
-
-	cmd_discharging = 1;
-	charging_enable = false;
-	adjust_power = -1;
-
-	battery_charging_control(CHARGING_CMD_ENABLE, &charging_enable);
-
-	battery_log(BAT_LOG_CRTI,
-			    "[current_cmd_write] cmd_discharging=%d\n", cmd_discharging);
-
-	return 0;
-}
-
-static int proc_utilization_open_cur_stop(struct inode *inode, struct file *file)
-{
-	return single_open(file, current_cmd_read, NULL);
-}
-static ssize_t discharging_cmd_write(struct file *file, const char *buffer, size_t count, loff_t *data)
-{
-	int len = 0;
-	char desc[32];
-	U32 charging_enable = false;
-    
-	len = (count < (sizeof(desc) - 1)) ? count : (sizeof(desc) - 1);
-	if (copy_from_user(desc, buffer, len)) {
-		return 0;
-	}
-	desc[len] = '\0';
-    
-	if (sscanf(desc, "%d %d", &charging_enable, &adjust_power) == 2) {
-		battery_log(BAT_LOG_CRTI, "[current_cmd_write] adjust_power = %d\n", adjust_power);
-		return count;
-	} else {
-		battery_log(BAT_LOG_CRTI, "  bad argument, echo [enable] > current_cmd\n");
-	}
-
-    	return -EINVAL;
-}
-
-static const struct file_operations discharging_cmd_proc_fops = { 
-	.open  = proc_utilization_open, 
-	.read  = seq_read,
-	.write = discharging_cmd_write,
-};
-
-static const struct file_operations current_cmd_proc_fops = {
-	.open = proc_utilization_open_cur_stop,
-	.read = seq_read,
-	.write = current_cmd_write,
-};
-
-static int mt_batteryNotify_probe(struct platform_device *dev)
-{
-	int ret_device_file = 0;
-	/* struct proc_dir_entry *entry = NULL; */
-	struct proc_dir_entry *battery_dir = NULL;
-
-	battery_log(BAT_LOG_CRTI, "******** mt_batteryNotify_probe!! ********\n");
-
-	ret_device_file = device_create_file(&(dev->dev), &dev_attr_BatteryNotify);
-	ret_device_file = device_create_file(&(dev->dev), &dev_attr_BN_TestMode);
-
-	battery_dir = proc_mkdir("mtk_battery_cmd", NULL);
-	if (!battery_dir) {
-		pr_err("[%s]: mkdir /proc/mtk_battery_cmd failed\n", __func__);
-	} else {
-#if 1
-		proc_create("battery_cmd", S_IRUGO | S_IWUSR, battery_dir, &battery_cmd_proc_fops);
-		battery_log(BAT_LOG_CRTI, "proc_create battery_cmd_proc_fops\n");
-
-		proc_create("current_cmd", S_IRUGO | S_IWUSR, battery_dir, &current_cmd_proc_fops);
-		battery_log(BAT_LOG_CRTI, "proc_create current_cmd_proc_fops\n");
-		proc_create("discharging_cmd", S_IRUGO | S_IWUSR, battery_dir, &discharging_cmd_proc_fops);
-		battery_log(BAT_LOG_CRTI, "proc_create discharging_cmd_proc_fops\n");
-            
-
-#else
-		entry = create_proc_entry("battery_cmd", S_IRUGO | S_IWUSR, battery_dir);
-		if (entry) {
-			entry->read_proc = battery_cmd_read;
-			entry->write_proc = battery_cmd_write;
-		}
-#endif
-	}
-
-	battery_log(BAT_LOG_CRTI, "******** mtk_battery_cmd!! ********\n");
-
-	return 0;
-
-}
-#ifdef CONFIG_OF
-static const struct of_device_id mt_battery_of_match[] = {
-	{ .compatible = "mediatek,battery", },
-	{},
-};
-
-MODULE_DEVICE_TABLE(of, mt_battery_of_match);
-#endif
-
-static int battery_pm_suspend(struct device *device)
-{
-	int ret = 0;
-	struct platform_device *pdev = to_platform_device(device);
-	BUG_ON(pdev == NULL);
-
-	return ret;
-}
-
-static int battery_pm_resume(struct device *device)
-{
-	int ret = 0;
-	struct platform_device *pdev = to_platform_device(device);
-	BUG_ON(pdev == NULL);
-
-	return ret;
-}
-
-static int battery_pm_freeze(struct device *device)
-{
-	int ret = 0;
-	struct platform_device *pdev = to_platform_device(device);
-	BUG_ON(pdev == NULL);
-
-	return ret;
-}
-
-static int battery_pm_restore(struct device *device)
-{
-	int ret = 0;
-	struct platform_device *pdev = to_platform_device(device);
-	BUG_ON(pdev == NULL);
-
-	return ret;
-}
-
-static int battery_pm_restore_noirq(struct device *device)
-{
-	int ret = 0;
-	struct platform_device *pdev = to_platform_device(device);
-	BUG_ON(pdev == NULL);
-
-	return ret;
-}
-
-struct dev_pm_ops battery_pm_ops = {
-	.suspend = battery_pm_suspend,
-	.resume = battery_pm_resume,
-	.freeze = battery_pm_freeze,
-	.thaw = battery_pm_restore,
-	.restore = battery_pm_restore,
-	.restore_noirq = battery_pm_restore_noirq,
-};
-
-#if defined(CONFIG_OF) || defined(BATTERY_MODULE_INIT)
-struct platform_device battery_device = {
-    .name   = "battery",
-    .id        = -1,
-};
-#endif
-
-static struct platform_driver battery_driver = {
-	.probe = battery_probe,
-	.remove = battery_remove,
-	.shutdown = battery_shutdown,
-	.driver = {
-		   .name = "battery",
-		.pm = &battery_pm_ops,
-	},
-};
-
-#ifdef CONFIG_OF
-static int battery_dts_probe(struct platform_device *dev)
-{
-	int ret = 0;
-	battery_log(BAT_LOG_CRTI, "******** battery_dts_probe!! ********\n");
-
-	battery_device.dev.of_node = dev->dev.of_node;
-	ret = platform_device_register(&battery_device);
-    if (ret) {
-		battery_log(BAT_LOG_CRTI,
-				    "****[battery_dts_probe] Unable to register device (%d)\n", ret);
-		return ret;
-	}
-	return 0;
-
-}
-
-static struct platform_driver battery_dts_driver = {
-	.probe = battery_dts_probe,
-	.remove = NULL,
-	.shutdown = NULL,
-	.driver = {
-		   .name = "battery-dts",
-        #ifdef CONFIG_OF 
- 		.of_match_table = mt_battery_of_match,
-        #endif
-	},
-};
-
-//--------------------------------------------------------
-
-static const struct of_device_id mt_bat_notify_of_match[] = {
-	{ .compatible = "mediatek,bat_notify", },
-	{},
-};
-
-MODULE_DEVICE_TABLE(of, mt_bat_notify_of_match);
-#endif
-
-struct platform_device MT_batteryNotify_device = {
-	.name = "mt-battery",
-	.id = -1,
-};
-
-static struct platform_driver mt_batteryNotify_driver = {
-	.probe = mt_batteryNotify_probe,
-	.driver = {
-		   .name = "mt-battery",
-		   },
-};
-
-#ifdef CONFIG_OF
-static int mt_batteryNotify_dts_probe(struct platform_device *dev)
-{
-	int ret = 0;
-	/* struct proc_dir_entry *entry = NULL; */
-
-	battery_log(BAT_LOG_CRTI, "******** mt_batteryNotify_dts_probe!! ********\n");
-
-	MT_batteryNotify_device.dev.of_node = dev->dev.of_node;
-	ret = platform_device_register(&MT_batteryNotify_device);
-    if (ret) {
-		battery_log(BAT_LOG_CRTI,
-				    "****[mt_batteryNotify_dts] Unable to register device (%d)\n", ret);
-		return ret;
-	}
-	return 0;
-
-}
-
-
-static struct platform_driver mt_batteryNotify_dts_driver = {
-	.probe = mt_batteryNotify_dts_probe,
-	.driver = {
-		   .name = "mt-dts-battery",
-        #ifdef CONFIG_OF
-		.of_match_table = mt_bat_notify_of_match,    
-        #endif
-	},
-};
-#endif
-//--------------------------------------------------------
-
-static int battery_pm_event(struct notifier_block *notifier, unsigned long pm_event, void *unused)
-{
-	switch(pm_event) {
-	case PM_HIBERNATION_PREPARE: /* Going to hibernate */
-	case PM_RESTORE_PREPARE: /* Going to restore a saved image */
-	case PM_SUSPEND_PREPARE: /* Going to suspend the system */
-		pr_warn("[%s] pm_event %lu\n", __func__, pm_event);
-		battery_timer_pause();
-		return NOTIFY_DONE;
-	case PM_POST_HIBERNATION: /* Hibernation finished */
-	case PM_POST_SUSPEND: /* Suspend finished */
-	case PM_POST_RESTORE: /* Restore failed */
-		pr_warn("[%s] pm_event %lu\n", __func__, pm_event);
-		battery_timer_resume();
-		return NOTIFY_DONE;
-	}
-	return NOTIFY_OK;
-}
-
-static struct notifier_block battery_pm_notifier_block = {
-    .notifier_call = battery_pm_event,
-    .priority = 0,
-};
-
-static int __init battery_init(void)
-{
-	int ret;
-
-	printk("battery_init\n");
-
-#ifdef CONFIG_OF
-	//
-#else
-    
-#ifdef BATTERY_MODULE_INIT
-	ret = platform_device_register(&battery_device);
-	if (ret) {
-		battery_log(BAT_LOG_CRTI,
-				    "****[battery_device] Unable to device register(%d)\n", ret);
-		return ret;
-	}
-#endif
-#endif
-
-	ret = platform_driver_register(&battery_driver);
-	if (ret) {
-		battery_log(BAT_LOG_CRTI,
-				    "****[battery_driver] Unable to register driver (%d)\n", ret);
-		return ret;
-	}
-	/* battery notofy UI */
-#ifdef CONFIG_OF
-    //
-#else
-	ret = platform_device_register(&MT_batteryNotify_device);
-	if (ret) {
-		battery_log(BAT_LOG_CRTI,
-				    "****[mt_batteryNotify] Unable to device register(%d)\n", ret);
-		return ret;
-	}
-#endif
-	ret = platform_driver_register(&mt_batteryNotify_driver);
-	if (ret) {
-		battery_log(BAT_LOG_CRTI,
-				    "****[mt_batteryNotify] Unable to register driver (%d)\n", ret);
-		return ret;
-	}
-#ifdef CONFIG_OF
-	ret = platform_driver_register(&battery_dts_driver);
-	ret = platform_driver_register(&mt_batteryNotify_dts_driver);
-#endif	
-	ret = register_pm_notifier(&battery_pm_notifier_block);
-	if (ret)
-		printk("[%s] failed to register PM notifier %d\n", __func__, ret);
-
-	battery_log(BAT_LOG_CRTI, "****[battery_driver] Initialization : DONE !!\n");
-	return 0;
-}
-
-#ifdef BATTERY_MODULE_INIT
-late_initcall(battery_init);
-#else
-static void __exit battery_exit(void)
-{
-}
-module_init(battery_init);
-module_exit(battery_exit);
-#endif
-
-MODULE_AUTHOR("Oscar Liu");
-MODULE_DESCRIPTION("Battery Device Driver");
-MODULE_LICENSE("GPL");
diff --git a/drivers/power/mediatek/battery_meter.c~ b/drivers/power/mediatek/battery_meter.c~
deleted file mode 100755
index 91ee194..0000000
--- a/drivers/power/mediatek/battery_meter.c~
+++ /dev/null
@@ -1,4197 +0,0 @@
-#include <linux/init.h>		/* For init/exit macros */
-#include <linux/module.h>	/* For MODULE_ marcros  */
-#include <linux/fs.h>
-#include <linux/device.h>
-#include <linux/interrupt.h>
-#include <linux/spinlock.h>
-#include <linux/platform_device.h>
-
-#include <linux/device.h>
-#include <linux/kdev_t.h>
-#include <linux/fs.h>
-#include <linux/cdev.h>
-#include <linux/delay.h>
-#include <linux/mutex.h>
-#include <linux/kthread.h>
-#include <linux/proc_fs.h>
-#include <linux/rtc.h>
-#include <linux/time.h>
-#include <linux/slab.h>
-#ifdef CONFIG_OF
-#include <linux/of.h>
-#include <linux/of_irq.h>
-#include <linux/of_address.h>
-#endif
-
-#include <asm/uaccess.h>
-#include <mach/mt_typedefs.h>
-#include <mach/hardware.h>
-#include <mach/mt_boot.h>
-#include <mach/mt_boot_reason.h>
-
-#include <mach/battery_common.h>
-#include <mach/battery_meter.h>
-#include <mach/battery_meter_hal.h>
-#include "cust_battery_meter.h"
-#include "cust_battery_meter_table.h"
-#include "cust_pmic.h"
-#include "mach/mtk_rtc.h"
-
-#include <mach/upmu_common.h>
-
-
-/* ============================================================ // */
-/* define */
-/* ============================================================ // */
-#define PROFILE_SIZE 4
-
-static DEFINE_MUTEX(FGADC_mutex);
-
-int Enable_FGADC_LOG = 100;
-
-/* ============================================================ // */
-/* global variable */
-/* ============================================================ // */
-BATTERY_METER_CONTROL battery_meter_ctrl = NULL;
-
-/* static struct proc_dir_entry *proc_entry_fgadc; */
-static char proc_fgadc_data[32];
-
-kal_bool gFG_Is_Charging = KAL_FALSE;
-kal_int32 g_auxadc_solution = 0;
-U32 g_spm_timer = 600;
-bool bat_spm_timeout = false;
-U32 _g_bat_sleep_total_time = NORMAL_WAKEUP_PERIOD;
-#ifdef MTK_ENABLE_AGING_ALGORITHM
-U32 suspend_time = 0;
-#endif
-kal_int32 g_booting_vbat = 0;
-static U32 temperature_change = 1;
-
-#if defined(CUST_CAPACITY_OCV2CV_TRANSFORM)
-static kal_int32 g_currentfactor = 100;
-static kal_bool g_USE_UI_SOC = KAL_TRUE;
-#if defined(CUST_SYSTEM_OFF_VOLTAGE)
-#define SYSTEM_OFF_VOLTAGE CUST_SYSTEM_OFF_VOLTAGE
-#endif
-#endif
-
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-/* // PMIC AUXADC Related Variable */
-/* ///////////////////////////////////////////////////////////////////////////////////////// */
-int g_R_BAT_SENSE = R_BAT_SENSE;
-int g_R_I_SENSE = R_I_SENSE;
-int g_R_CHARGER_1 = R_CHARGER_1;
-int g_R_CHARGER_2 = R_CHARGER_2;
-
-int fg_qmax_update_for_aging_flag = 1;
-
-/* HW FG */
-kal_int32 gFG_DOD0 = 0;
-kal_int32 gFG_DOD1 = 0;
-kal_int32 gFG_columb = 0;
-kal_int32 gFG_voltage = 0;
-kal_int32 gFG_current = 0;
-kal_int32 gFG_capacity = 0;
-kal_int32 gFG_capacity_by_c = 0;
-kal_int32 gFG_capacity_by_c_init = 0;
-kal_int32 gFG_capacity_by_v = 0;
-kal_int32 gFG_capacity_by_v_init = 0;
-kal_int32 gFG_temp = 100;
-kal_int32 gFG_resistance_bat = 0;
-kal_int32 gFG_compensate_value = 0;
-kal_int32 gFG_ori_voltage = 0;
-kal_int32 gFG_BATT_CAPACITY = 0;
-kal_int32 gFG_voltage_init = 0;
-kal_int32 gFG_current_auto_detect_R_fg_total = 0;
-kal_int32 gFG_current_auto_detect_R_fg_count = 0;
-kal_int32 gFG_current_auto_detect_R_fg_result = 0;
-kal_int32 gFG_15_vlot = 3700;
-kal_int32 gFG_BATT_CAPACITY_init_high_current = 1200;
-kal_int32 gFG_BATT_CAPACITY_aging = 1200;
-
-/* voltage mode */
-kal_int32 gfg_percent_check_point = 50;
-kal_int32 volt_mode_update_timer = 0;
-kal_int32 volt_mode_update_time_out = 6;	/* 1mins */
-
-/* EM */
-kal_int32 g_fg_dbg_bat_volt = 0;
-kal_int32 g_fg_dbg_bat_current = 0;
-kal_int32 g_fg_dbg_bat_zcv = 0;
-kal_int32 g_fg_dbg_bat_temp = 0;
-kal_int32 g_fg_dbg_bat_r = 0;
-kal_int32 g_fg_dbg_bat_car = 0;
-kal_int32 g_fg_dbg_bat_qmax = 0;
-kal_int32 g_fg_dbg_d0 = 0;
-kal_int32 g_fg_dbg_d1 = 0;
-kal_int32 g_fg_dbg_percentage = 0;
-kal_int32 g_fg_dbg_percentage_fg = 0;
-kal_int32 g_fg_dbg_percentage_voltmode = 0;
-
-kal_int32 FGvbatVoltageBuffer[FG_VBAT_AVERAGE_SIZE];
-kal_int32 FGbatteryIndex = 0;
-kal_int32 FGbatteryVoltageSum = 0;
-kal_int32 gFG_voltage_AVG = 0;
-kal_int32 gFG_vbat_offset = 0;
-#ifdef Q_MAX_BY_CURRENT
-kal_int32 FGCurrentBuffer[FG_CURRENT_AVERAGE_SIZE];
-kal_int32 FGCurrentIndex = 0;
-kal_int32 FGCurrentSum = 0;
-kal_int32 gFG_current_AVG = 0;
-#endif
-kal_int32 g_tracking_point = CUST_TRACKING_POINT;
-kal_int32 g_rtc_fg_soc = 0;
-kal_int32 g_I_SENSE_offset = 0;
-
-/* SW FG */
-kal_int32 oam_v_ocv_init = 0;
-kal_int32 oam_v_ocv_1 = 0;
-kal_int32 oam_v_ocv_2 = 0;
-kal_int32 oam_r_1 = 0;
-kal_int32 oam_r_2 = 0;
-kal_int32 oam_d0 = 0;
-kal_int32 oam_i_ori = 0;
-kal_int32 oam_i_1 = 0;
-kal_int32 oam_i_2 = 0;
-kal_int32 oam_car_1 = 0;
-kal_int32 oam_car_2 = 0;
-kal_int32 oam_d_1 = 1;
-kal_int32 oam_d_2 = 1;
-kal_int32 oam_d_3 = 1;
-kal_int32 oam_d_3_pre = 0;
-kal_int32 oam_d_4 = 0;
-kal_int32 oam_d_4_pre = 0;
-kal_int32 oam_d_5 = 0;
-kal_int32 oam_init_i = 0;
-kal_int32 oam_run_i = 0;
-kal_int32 d5_count = 0;
-kal_int32 d5_count_time = 60;
-kal_int32 d5_count_time_rate = 1;
-kal_int32 g_d_hw_ocv = 0;
-kal_int32 g_vol_bat_hw_ocv = 0;
-kal_int32 g_hw_ocv_before_sleep = 0;
-struct timespec g_rtc_time_before_sleep, xts_before_sleep;
-kal_int32 g_sw_vbat_temp = 0;
-struct timespec last_oam_run_time;
-
-/* aging mechanism */
-#ifdef MTK_ENABLE_AGING_ALGORITHM
-
-static kal_int32 aging_ocv_1 = 0;
-static kal_int32 aging_ocv_2 = 0;
-static kal_int32 aging_car_1 = 0;
-static kal_int32 aging_car_2 = 0;
-static kal_int32 aging_dod_1 = 0;
-static kal_int32 aging_dod_2 = 0;
-#ifdef MD_SLEEP_CURRENT_CHECK
-static kal_int32 columb_before_sleep = 0x123456;
-#endif
-//static time_t aging_resume_time_1 = 0;
-//static time_t aging_resume_time_2 = 0;
-
-#ifndef SELF_DISCHARGE_CHECK_THRESHOLD
-#define SELF_DISCHARGE_CHECK_THRESHOLD 10
-#endif
-
-#ifndef OCV_RECOVER_TIME
-#define OCV_RECOVER_TIME 2100
-#endif
-
-#ifndef DOD1_ABOVE_THRESHOLD
-#define DOD1_ABOVE_THRESHOLD 30
-#endif
-
-#ifndef DOD2_BELOW_THRESHOLD
-#define DOD2_BELOW_THRESHOLD 70
-#endif
-
-#ifndef MIN_DOD_DIFF_THRESHOLD
-#define MIN_DOD_DIFF_THRESHOLD 60
-#endif
-
-#ifndef MIN_AGING_FACTOR
-#define MIN_AGING_FACTOR 90
-#endif
-
-#endif				/* aging mechanism */
-
-/* battery info */
-#ifdef MTK_BATTERY_LIFETIME_DATA_SUPPORT
-
-kal_int32 gFG_battery_cycle = 0;
-kal_int32 gFG_aging_factor = 100;
-kal_int32 gFG_columb_sum = 0;
-kal_int32 gFG_pre_columb_count = 0;
-
-kal_int32 gFG_max_voltage = 0;
-kal_int32 gFG_min_voltage = 10000;
-kal_int32 gFG_max_current = 0;
-kal_int32 gFG_min_current = 0;
-kal_int32 gFG_max_temperature = -20;
-kal_int32 gFG_min_temperature = 100;
-
-#endif				/* battery info */
-
-extern char* saved_command_line;
-/* Temperature window size */
-#define TEMP_AVERAGE_SIZE	30
-
-kal_bool  gFG_Is_offset_init = KAL_FALSE;
-
-#ifdef MTK_MULTI_BAT_PROFILE_SUPPORT
-extern int IMM_GetOneChannelValue_Cali(int Channel, int *voltage);
-kal_uint32 g_fg_battery_id = 0;
-
-#ifdef MTK_GET_BATTERY_ID_BY_AUXADC
-void fgauge_get_profile_id(void)
-{
-	int id_volt = 0;
-	int id = 0;
-	int ret = 0;
-
-	ret = IMM_GetOneChannelValue_Cali(BATTERY_ID_CHANNEL_NUM, &id_volt);
-	if (ret != 0)
-		bm_print(BM_LOG_CRTI, "[fgauge_get_profile_id]id_volt read fail\n");
-	else
-		bm_print(BM_LOG_CRTI, "[fgauge_get_profile_id]id_volt = %d\n", id_volt);
-
-	if ((sizeof(g_battery_id_voltage) / sizeof(kal_int32)) != TOTAL_BATTERY_NUMBER) {
-		bm_print(BM_LOG_CRTI, "[fgauge_get_profile_id]error! voltage range incorrect!\n");
-		return;
-	}
-
-	for (id = 0; id < TOTAL_BATTERY_NUMBER; id++) {
-		if (id_volt < g_battery_id_voltage[id]) {
-			g_fg_battery_id = id;
-			break;
-		} else if (g_battery_id_voltage[id] == -1) {
-			g_fg_battery_id = TOTAL_BATTERY_NUMBER - 1;
-		}
-	}
-
-	bm_print(BM_LOG_CRTI, "[fgauge_get_profile_id]Battery id (%d)\n", g_fg_battery_id);
-}
-#elif defined(MTK_GET_BATTERY_ID_BY_GPIO)
-void fgauge_get_profile_id(void)
-{
-	g_fg_battery_id = 0;
-}
-#else
-void fgauge_get_profile_id(void)
-{
-	g_fg_battery_id = 0;
-}
-#endif
-#endif
-
-/* ============================================================ // */
-/* function prototype */
-/* ============================================================ // */
-
-/* ============================================================ // */
-/* extern variable */
-/* ============================================================ // */
-
-/* ============================================================ // */
-/* extern function */
-/* ============================================================ // */
-/* extern int get_rtc_spare_fg_value(void); */
-/* extern unsigned long rtc_read_hw_time(void); */
-
-
-
-/* ============================================================ // */
-int get_r_fg_value(void)
-{
-	return (R_FG_VALUE + CUST_R_FG_OFFSET);
-}
-
-#ifdef MTK_MULTI_BAT_PROFILE_SUPPORT
-int BattThermistorConverTemp(int Res)
-{
-	int i = 0;
-	int RES1 = 0, RES2 = 0;
-	int TBatt_Value = -200, TMP1 = 0, TMP2 = 0;
-
-	BATT_TEMPERATURE *batt_temperature_table = &Batt_Temperature_Table[g_fg_battery_id];
-	if (Res >= batt_temperature_table[0].TemperatureR) {
-		TBatt_Value = -20;
-	} else if (Res <= batt_temperature_table[16].TemperatureR) {
-		TBatt_Value = 60;
-	} else {
-		RES1 = batt_temperature_table[0].TemperatureR;
-		TMP1 = batt_temperature_table[0].BatteryTemp;
-
-		for (i = 0; i <= 16; i++) {
-			if (Res >= batt_temperature_table[i].TemperatureR) {
-				RES2 = batt_temperature_table[i].TemperatureR;
-				TMP2 = batt_temperature_table[i].BatteryTemp;
-				break;
-			} else {
-				RES1 = batt_temperature_table[i].TemperatureR;
-				TMP1 = batt_temperature_table[i].BatteryTemp;
-			}
-		}
-
-		TBatt_Value = (((Res - RES2) * TMP1) + ((RES1 - Res) * TMP2)) / (RES1 - RES2);
-	}
-
-	return TBatt_Value;
-}
-
-kal_int32 fgauge_get_Q_max(kal_int16 temperature)
-{
-	kal_int32 ret_Q_max = 0;
-	kal_int32 low_temperature = 0, high_temperature = 0;
-	kal_int32 low_Q_max = 0, high_Q_max = 0;
-
-	if (temperature <= TEMPERATURE_T1) {
-		low_temperature = (-10);
-		low_Q_max = g_Q_MAX_NEG_10[g_fg_battery_id];
-		high_temperature = TEMPERATURE_T1;
-		high_Q_max = g_Q_MAX_POS_0[g_fg_battery_id];
-
-		if (temperature < low_temperature) {
-			temperature = low_temperature;
-		}
-	} else if (temperature <= TEMPERATURE_T2) {
-		low_temperature = TEMPERATURE_T1;
-		low_Q_max = g_Q_MAX_POS_0[g_fg_battery_id];
-		high_temperature = TEMPERATURE_T2;
-		high_Q_max = g_Q_MAX_POS_25[g_fg_battery_id];
-
-		if (temperature < low_temperature) {
-			temperature = low_temperature;
-		}
-	} else {
-		low_temperature = TEMPERATURE_T2;
-		low_Q_max = g_Q_MAX_POS_25[g_fg_battery_id];
-		high_temperature = TEMPERATURE_T3;
-		high_Q_max = g_Q_MAX_POS_50[g_fg_battery_id];
-
-		if (temperature > high_temperature) {
-			temperature = high_temperature;
-		}
-	}
-
-	ret_Q_max = low_Q_max + (((temperature - low_temperature) * (high_Q_max - low_Q_max)
-				 ) / (high_temperature - low_temperature)
-	    );
-
-	bm_print(BM_LOG_FULL, "[fgauge_get_Q_max] Q_max = %d\r\n", ret_Q_max);
-
-	return ret_Q_max;
-}
-
-
-kal_int32 fgauge_get_Q_max_high_current(kal_int16 temperature)
-{
-	kal_int32 ret_Q_max = 0;
-	kal_int32 low_temperature = 0, high_temperature = 0;
-	kal_int32 low_Q_max = 0, high_Q_max = 0;
-
-	if (temperature <= TEMPERATURE_T1) {
-		low_temperature = (-10);
-		low_Q_max = g_Q_MAX_NEG_10_H_CURRENT[g_fg_battery_id];
-		high_temperature = TEMPERATURE_T1;
-		high_Q_max = g_Q_MAX_POS_0_H_CURRENT[g_fg_battery_id];
-
-		if (temperature < low_temperature) {
-			temperature = low_temperature;
-		}
-	} else if (temperature <= TEMPERATURE_T2) {
-		low_temperature = TEMPERATURE_T1;
-		low_Q_max = g_Q_MAX_POS_0_H_CURRENT[g_fg_battery_id];
-		high_temperature = TEMPERATURE_T2;
-		high_Q_max = g_Q_MAX_POS_25_H_CURRENT[g_fg_battery_id];
-
-		if (temperature < low_temperature) {
-			temperature = low_temperature;
-		}
-	} else {
-		low_temperature = TEMPERATURE_T2;
-		low_Q_max = g_Q_MAX_POS_25_H_CURRENT[g_fg_battery_id];
-		high_temperature = TEMPERATURE_T3;
-		high_Q_max = g_Q_MAX_POS_50_H_CURRENT[g_fg_battery_id];
-
-		if (temperature > high_temperature) {
-			temperature = high_temperature;
-		}
-	}
-
-	ret_Q_max = low_Q_max + (((temperature - low_temperature) * (high_Q_max - low_Q_max)
-				 ) / (high_temperature - low_temperature)
-	    );
-
-	bm_print(BM_LOG_FULL, "[fgauge_get_Q_max_high_current] Q_max = %d\r\n", ret_Q_max);
-
-	return ret_Q_max;
-}
-
-#else
-
-int BattThermistorConverTemp(int Res)
-{
-	int i = 0;
-	int RES1 = 0, RES2 = 0;
-	int TBatt_Value = -200, TMP1 = 0, TMP2 = 0;
-
-	if (Res >= Batt_Temperature_Table[0].TemperatureR) {
-		TBatt_Value = -20;
-	} else if (Res <= Batt_Temperature_Table[16].TemperatureR) {
-		TBatt_Value = 60;
-	} else {
-		RES1 = Batt_Temperature_Table[0].TemperatureR;
-		TMP1 = Batt_Temperature_Table[0].BatteryTemp;
-
-		for (i = 0; i <= 16; i++) {
-			if (Res >= Batt_Temperature_Table[i].TemperatureR) {
-				RES2 = Batt_Temperature_Table[i].TemperatureR;
-				TMP2 = Batt_Temperature_Table[i].BatteryTemp;
-				break;
-			} else {
-				RES1 = Batt_Temperature_Table[i].TemperatureR;
-				TMP1 = Batt_Temperature_Table[i].BatteryTemp;
-			}
-		}
-
-		TBatt_Value = (((Res - RES2) * TMP1) + ((RES1 - Res) * TMP2)) / (RES1 - RES2);
-	}
-
-	return TBatt_Value;
-}
-
-kal_int32 fgauge_get_Q_max(kal_int16 temperature)
-{
-	kal_int32 ret_Q_max = 0;
-	kal_int32 low_temperature = 0, high_temperature = 0;
-	kal_int32 low_Q_max = 0, high_Q_max = 0;
-
-	if (temperature <= TEMPERATURE_T1) {
-		low_temperature = (-10);
-		low_Q_max = Q_MAX_NEG_10;
-		high_temperature = TEMPERATURE_T1;
-		high_Q_max = Q_MAX_POS_0;
-
-		if (temperature < low_temperature) {
-			temperature = low_temperature;
-		}
-	} else if (temperature <= TEMPERATURE_T2) {
-		low_temperature = TEMPERATURE_T1;
-		low_Q_max = Q_MAX_POS_0;
-		high_temperature = TEMPERATURE_T2;
-		high_Q_max = Q_MAX_POS_25;
-
-		if (temperature < low_temperature) {
-			temperature = low_temperature;
-		}
-	} else {
-		low_temperature = TEMPERATURE_T2;
-		low_Q_max = Q_MAX_POS_25;
-		high_temperature = TEMPERATURE_T3;
-		high_Q_max = Q_MAX_POS_50;
-
-		if (temperature > high_temperature) {
-			temperature = high_temperature;
-		}
-	}
-
-	ret_Q_max = low_Q_max + (((temperature - low_temperature) * (high_Q_max - low_Q_max)
-				 ) / (high_temperature - low_temperature)
-	    );
-
-	bm_print(BM_LOG_FULL, "[fgauge_get_Q_max] Q_max = %d\r\n", ret_Q_max);
-
-	return ret_Q_max;
-}
-
-
-kal_int32 fgauge_get_Q_max_high_current(kal_int16 temperature)
-{
-	kal_int32 ret_Q_max = 0;
-	kal_int32 low_temperature = 0, high_temperature = 0;
-	kal_int32 low_Q_max = 0, high_Q_max = 0;
-
-	if (temperature <= TEMPERATURE_T1) {
-		low_temperature = (-10);
-		low_Q_max = Q_MAX_NEG_10_H_CURRENT;
-		high_temperature = TEMPERATURE_T1;
-		high_Q_max = Q_MAX_POS_0_H_CURRENT;
-
-		if (temperature < low_temperature) {
-			temperature = low_temperature;
-		}
-	} else if (temperature <= TEMPERATURE_T2) {
-		low_temperature = TEMPERATURE_T1;
-		low_Q_max = Q_MAX_POS_0_H_CURRENT;
-		high_temperature = TEMPERATURE_T2;
-		high_Q_max = Q_MAX_POS_25_H_CURRENT;
-
-		if (temperature < low_temperature) {
-			temperature = low_temperature;
-		}
-	} else {
-		low_temperature = TEMPERATURE_T2;
-		low_Q_max = Q_MAX_POS_25_H_CURRENT;
-		high_temperature = TEMPERATURE_T3;
-		high_Q_max = Q_MAX_POS_50_H_CURRENT;
-
-		if (temperature > high_temperature) {
-			temperature = high_temperature;
-		}
-	}
-
-	ret_Q_max = low_Q_max + (((temperature - low_temperature) * (high_Q_max - low_Q_max)
-				 ) / (high_temperature - low_temperature)
-	    );
-
-	bm_print(BM_LOG_FULL, "[fgauge_get_Q_max_high_current] Q_max = %d\r\n", ret_Q_max);
-
-	return ret_Q_max;
-}
-
-#endif
-
-int BattVoltToTemp(int dwVolt)
-{
-	kal_int64 TRes_temp;
-	kal_int64 TRes;
-	int sBaTTMP = -100;
-
-	/* TRes_temp = ((kal_int64)RBAT_PULL_UP_R*(kal_int64)dwVolt) / (RBAT_PULL_UP_VOLT-dwVolt); */
-	/* TRes = (TRes_temp * (kal_int64)RBAT_PULL_DOWN_R)/((kal_int64)RBAT_PULL_DOWN_R - TRes_temp); */
-
-	TRes_temp = (RBAT_PULL_UP_R * (kal_int64) dwVolt);
-	do_div(TRes_temp, (RBAT_PULL_UP_VOLT - dwVolt));
-
-#ifdef RBAT_PULL_DOWN_R
-	TRes = (TRes_temp * RBAT_PULL_DOWN_R);
-	do_div(TRes, abs(RBAT_PULL_DOWN_R - TRes_temp));
-#else
-	TRes = TRes_temp;
-#endif
-
-	/* convert register to temperature */
-	sBaTTMP = BattThermistorConverTemp((int)TRes);
-
-	return sBaTTMP;
-}
-
-int force_get_tbat(kal_bool update)
-{
-#if defined(CONFIG_POWER_EXT) || defined(FIXED_TBAT_25)
-	bm_print(BM_LOG_CRTI, "[force_get_tbat] fixed TBAT=25 t\n");
-	return 25;
-#else
-	int bat_temperature_volt = 0;
-	int bat_temperature_val = 0;
-	static int pre_bat_temperature_val = -1;
-	int fg_r_value = 0;
-	kal_int32 fg_current_temp = 0;
-	kal_bool fg_current_state = KAL_FALSE;
-	int bat_temperature_volt_temp = 0;
-	int ret = 0;
-
-	if (update == KAL_TRUE || pre_bat_temperature_val == -1) {
-		/* Get V_BAT_Temperature */
-		bat_temperature_volt = 2;
-		ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_ADC_V_BAT_TEMP, &bat_temperature_volt);
-
-		if (bat_temperature_volt != 0) {
-#if defined(SOC_BY_HW_FG)
-			fg_r_value = get_r_fg_value();
-
-			ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_HW_FG_CURRENT, &fg_current_temp);
-			ret =
-			    battery_meter_ctrl(BATTERY_METER_CMD_GET_HW_FG_CURRENT_SIGN, &fg_current_state);
-			fg_current_temp = fg_current_temp / 10;
-
-			if (fg_current_state == KAL_TRUE) {
-				bat_temperature_volt_temp = bat_temperature_volt;
-				bat_temperature_volt =
-				    bat_temperature_volt - ((fg_current_temp * fg_r_value) / 1000);
-			} else {
-				bat_temperature_volt_temp = bat_temperature_volt;
-				bat_temperature_volt =
-				    bat_temperature_volt + ((fg_current_temp * fg_r_value) / 1000);
-			}
-#endif
-
-			bat_temperature_val = BattVoltToTemp(bat_temperature_volt);
-		}
-
-	bm_print(BM_LOG_CRTI, "[force_get_tbat] %d,%d,%d,%d,%d,%d\n",
-		 bat_temperature_volt_temp, bat_temperature_volt, fg_current_state, fg_current_temp,
-		 fg_r_value, bat_temperature_val);
-		pre_bat_temperature_val = bat_temperature_val;
-	} else {
-		bat_temperature_val = pre_bat_temperature_val;
-	}
-	return 25;//by zhu
-	//return bat_temperature_val;
-#endif
-}
-EXPORT_SYMBOL(force_get_tbat);
-
-#ifdef MTK_MULTI_BAT_PROFILE_SUPPORT
-int fgauge_get_saddles(void)
-{
-	return sizeof(battery_profile_temperature) / sizeof(BATTERY_PROFILE_STRUC);
-}
-
-int fgauge_get_saddles_r_table(void)
-{
-	return sizeof(r_profile_temperature) / sizeof(R_PROFILE_STRUC);
-}
-
-BATTERY_PROFILE_STRUC_P fgauge_get_profile(kal_uint32 temperature)
-{
-	switch (temperature) {
-	case TEMPERATURE_T0:
-		return &battery_profile_t0[g_fg_battery_id][0];
-		break;
-	case TEMPERATURE_T1:
-		return &battery_profile_t1[g_fg_battery_id][0];
-		break;
-	case TEMPERATURE_T2:
-		return &battery_profile_t2[g_fg_battery_id][0];
-		break;
-	case TEMPERATURE_T3:
-		return &battery_profile_t3[g_fg_battery_id][0];
-		break;
-	case TEMPERATURE_T:
-		return &battery_profile_temperature[0];
-		break;
-	default:
-		return NULL;
-		break;
-	}
-}
-
-R_PROFILE_STRUC_P fgauge_get_profile_r_table(kal_uint32 temperature)
-{
-	switch (temperature) {
-	case TEMPERATURE_T0:
-		return &r_profile_t0[g_fg_battery_id][0];
-		break;
-	case TEMPERATURE_T1:
-		return &r_profile_t1[g_fg_battery_id][0];
-		break;
-	case TEMPERATURE_T2:
-		return &r_profile_t2[g_fg_battery_id][0];
-		break;
-	case TEMPERATURE_T3:
-		return &r_profile_t3[g_fg_battery_id][0];
-		break;
-	case TEMPERATURE_T:
-		return &r_profile_temperature[0];
-		break;
-	default:
-		return NULL;
-		break;
-	}
-}
-#else
-int fgauge_get_saddles(void)
-{
-	return sizeof(battery_profile_t2) / sizeof(BATTERY_PROFILE_STRUC);
-}
-
-int fgauge_get_saddles_r_table(void)
-{
-	return sizeof(r_profile_t2) / sizeof(R_PROFILE_STRUC);
-}
-
-BATTERY_PROFILE_STRUC_P fgauge_get_profile(kal_uint32 temperature)
-{
-	switch (temperature) {
-	case TEMPERATURE_T0:
-		return &battery_profile_t0[0];
-		break;
-	case TEMPERATURE_T1:
-		return &battery_profile_t1[0];
-		break;
-	case TEMPERATURE_T2:
-		return &battery_profile_t2[0];
-		break;
-	case TEMPERATURE_T3:
-		return &battery_profile_t3[0];
-		break;
-	case TEMPERATURE_T:
-		return &battery_profile_temperature[0];
-		break;
-	default:
-		return NULL;
-		break;
-	}
-}
-
-R_PROFILE_STRUC_P fgauge_get_profile_r_table(kal_uint32 temperature)
-{
-	switch (temperature) {
-	case TEMPERATURE_T0:
-		return &r_profile_t0[0];
-		break;
-	case TEMPERATURE_T1:
-		return &r_profile_t1[0];
-		break;
-	case TEMPERATURE_T2:
-		return &r_profile_t2[0];
-		break;
-	case TEMPERATURE_T3:
-		return &r_profile_t3[0];
-		break;
-	case TEMPERATURE_T:
-		return &r_profile_temperature[0];
-		break;
-	default:
-		return NULL;
-		break;
-	}
-}
-#endif
-
-kal_int32 fgauge_read_capacity_by_v(kal_int32 voltage)
-{
-	int i = 0, saddles = 0;
-	BATTERY_PROFILE_STRUC_P profile_p;
-	kal_int32 ret_percent = 0;
-
-	profile_p = fgauge_get_profile(TEMPERATURE_T);
-	if (profile_p == NULL) {
-		bm_print(BM_LOG_CRTI, "[FGADC] fgauge get ZCV profile : fail !\r\n");
-		return 100;
-	}
-
-	saddles = fgauge_get_saddles();
-
-	if (voltage > (profile_p + 0)->voltage) {
-		return 100;	/* battery capacity, not dod */
-	}
-	if (voltage < (profile_p + saddles - 1)->voltage) {
-		return 0;	/* battery capacity, not dod */
-	}
-
-	for (i = 0; i < saddles - 1; i++) {
-		if ((voltage <= (profile_p + i)->voltage)
-		    && (voltage >= (profile_p + i + 1)->voltage)) {
-			ret_percent =
-			    (profile_p + i)->percentage +
-			    (((((profile_p + i)->voltage) -
-			       voltage) * (((profile_p + i + 1)->percentage) -
-					   ((profile_p + i)->percentage))
-			     ) / (((profile_p + i)->voltage) - ((profile_p + i + 1)->voltage))
-			    );
-
-			break;
-		}
-
-	}
-	ret_percent = 100 - ret_percent;
-
-	return ret_percent;
-}
-
-kal_int32 fgauge_read_v_by_capacity(int bat_capacity)
-{
-	int i = 0, saddles = 0;
-	BATTERY_PROFILE_STRUC_P profile_p;
-	kal_int32 ret_volt = 0;
-
-	profile_p = fgauge_get_profile(TEMPERATURE_T);
-	if (profile_p == NULL) {
-		bm_print(BM_LOG_CRTI,
-			 "[fgauge_read_v_by_capacity] fgauge get ZCV profile : fail !\r\n");
-		return 3700;
-	}
-
-	saddles = fgauge_get_saddles();
-
-	if (bat_capacity < (profile_p + 0)->percentage) {
-		return 3700;
-	}
-	if (bat_capacity > (profile_p + saddles - 1)->percentage) {
-		return 3700;
-	}
-
-	for (i = 0; i < saddles - 1; i++) {
-		if ((bat_capacity >= (profile_p + i)->percentage)
-		    && (bat_capacity <= (profile_p + i + 1)->percentage)) {
-			ret_volt =
-			    (profile_p + i)->voltage -
-			    (((bat_capacity -
-			       ((profile_p + i)->percentage)) * (((profile_p + i)->voltage) -
-								 ((profile_p + i + 1)->voltage))
-			     ) / (((profile_p + i + 1)->percentage) - ((profile_p + i)->percentage))
-			    );
-
-			break;
-		}
-	}
-
-	return ret_volt;
-}
-
-kal_int32 fgauge_read_d_by_v(kal_int32 volt_bat)
-{
-	int i = 0, saddles = 0;
-	BATTERY_PROFILE_STRUC_P profile_p;
-	kal_int32 ret_d = 0;
-
-	profile_p = fgauge_get_profile(TEMPERATURE_T);
-	if (profile_p == NULL) {
-		bm_print(BM_LOG_CRTI, "[FGADC] fgauge get ZCV profile : fail !\r\n");
-		return 100;
-	}
-
-	saddles = fgauge_get_saddles();
-
-	if (volt_bat > (profile_p + 0)->voltage) {
-		return 0;
-	}
-	if (volt_bat < (profile_p + saddles - 1)->voltage) {
-		return 100;
-	}
-
-	for (i = 0; i < saddles - 1; i++) {
-		if ((volt_bat <= (profile_p + i)->voltage)
-		    && (volt_bat >= (profile_p + i + 1)->voltage)) {
-			ret_d =
-			    (profile_p + i)->percentage +
-			    (((((profile_p + i)->voltage) -
-			       volt_bat) * (((profile_p + i + 1)->percentage) -
-					    ((profile_p + i)->percentage))
-			     ) / (((profile_p + i)->voltage) - ((profile_p + i + 1)->voltage))
-			    );
-
-			break;
-		}
-
-	}
-
-	return ret_d;
-}
-
-kal_int32 fgauge_read_v_by_d(int d_val)
-{
-	int i = 0, saddles = 0;
-	BATTERY_PROFILE_STRUC_P profile_p;
-	kal_int32 ret_volt = 0;
-
-	profile_p = fgauge_get_profile(TEMPERATURE_T);
-	if (profile_p == NULL) {
-		bm_print(BM_LOG_CRTI,
-			 "[fgauge_read_v_by_capacity] fgauge get ZCV profile : fail !\r\n");
-		return 3700;
-	}
-
-	saddles = fgauge_get_saddles();
-
-	if (d_val < (profile_p + 0)->percentage) {
-		return 3700;
-	}
-	if (d_val > (profile_p + saddles - 1)->percentage) {
-		return 3700;
-	}
-
-	for (i = 0; i < saddles - 1; i++) {
-		if ((d_val >= (profile_p + i)->percentage)
-		    && (d_val <= (profile_p + i + 1)->percentage)) {
-			ret_volt =
-			    (profile_p + i)->voltage -
-			    (((d_val -
-			       ((profile_p + i)->percentage)) * (((profile_p + i)->voltage) -
-								 ((profile_p + i + 1)->voltage))
-			     ) / (((profile_p + i + 1)->percentage) - ((profile_p + i)->percentage))
-			    );
-
-			break;
-		}
-	}
-
-	return ret_volt;
-}
-
-kal_int32 fgauge_read_r_bat_by_v(kal_int32 voltage)
-{
-	int i = 0, saddles = 0;
-	R_PROFILE_STRUC_P profile_p;
-	kal_int32 ret_r = 0;
-
-	profile_p = fgauge_get_profile_r_table(TEMPERATURE_T);
-	if (profile_p == NULL) {
-		bm_print(BM_LOG_CRTI, "[FGADC] fgauge get R-Table profile : fail !\r\n");
-		return (profile_p + 0)->resistance;
-	}
-
-	saddles = fgauge_get_saddles_r_table();
-
-	if (voltage > (profile_p + 0)->voltage) {
-		return (profile_p + 0)->resistance;
-	}
-	if (voltage < (profile_p + saddles - 1)->voltage) {
-		return (profile_p + saddles - 1)->resistance;
-	}
-
-	for (i = 0; i < saddles - 1; i++) {
-		if ((voltage <= (profile_p + i)->voltage)
-		    && (voltage >= (profile_p + i + 1)->voltage)) {
-			ret_r =
-			    (profile_p + i)->resistance +
-			    (((((profile_p + i)->voltage) -
-			       voltage) * (((profile_p + i + 1)->resistance) -
-					   ((profile_p + i)->resistance))
-			     ) / (((profile_p + i)->voltage) - ((profile_p + i + 1)->voltage))
-			    );
-			break;
-		}
-	}
-
-	return ret_r;
-}
-
-void fgauge_construct_battery_profile_init(void)
-{
-	BATTERY_PROFILE_STRUC_P temp_profile_p, profile_p[PROFILE_SIZE];
-	int i, j, saddles, profile_index;
-	kal_int32 low_p = 0, high_p = 0, now_p = 0, low_vol = 0, high_vol = 0;
-	
-	profile_p[0] = fgauge_get_profile(TEMPERATURE_T0);
-	profile_p[1] = fgauge_get_profile(TEMPERATURE_T1);
-	profile_p[2] = fgauge_get_profile(TEMPERATURE_T2);
-	profile_p[3] = fgauge_get_profile(TEMPERATURE_T3);
-	saddles = fgauge_get_saddles();
-	temp_profile_p = (BATTERY_PROFILE_STRUC_P) kmalloc(51 * sizeof(*temp_profile_p), GFP_KERNEL);
-	memset(temp_profile_p, 0, 51 * sizeof(*temp_profile_p));
-	for (i=0; i< PROFILE_SIZE; i++) {
-		profile_index = 0;
-		for (j=0; j*2 <= 100; j++) {
-			while (profile_index < saddles && profile_index >=0) {
-				if (((profile_p[i] + profile_index)->percentage) < j*2) {
-					profile_index ++;
-					continue;
-				} else if (((profile_p[i] + profile_index)->percentage) == j*2) {
-					(temp_profile_p + j)->voltage = (profile_p[i] + profile_index)->voltage;
-					(temp_profile_p + j)->percentage = (profile_p[i] + profile_index)->percentage;
-					break;
-				}
-				low_p = (profile_p[i]+profile_index-1)->percentage;
-				high_p = (profile_p[i]+profile_index)->percentage;
-				now_p = j*2;
-				low_vol = (profile_p[i]+profile_index)->voltage;
-				high_vol = (profile_p[i]+profile_index-1)-> voltage;
-				(temp_profile_p + j)->voltage = (low_vol*1000 + ((high_vol - low_vol) * 1000 * (now_p - low_p) / (high_p - low_p))) / 1000;
-				(temp_profile_p + j)->percentage = j*2;
-				
-				break;
-			}
-			bm_print(BM_LOG_CRTI, "new battery_profile[%d,%d] <%d,%d>\n", i, j, (temp_profile_p + j)->percentage, (temp_profile_p + j)->voltage);
-		}
-		
-		for (j=0; j*2 <= 100; j++) {
-			(profile_p[i]+j) -> voltage = (temp_profile_p + j) -> voltage;
-			(profile_p[i]+j) -> percentage = (temp_profile_p + j) -> percentage;
-		}
-	}
-	kfree(temp_profile_p);
-}
-
-void fgauge_construct_battery_profile(kal_int32 temperature, BATTERY_PROFILE_STRUC_P temp_profile_p)
-{
-	BATTERY_PROFILE_STRUC_P low_profile_p, high_profile_p;
-	kal_int32 low_temperature, high_temperature;
-	int i, saddles;
-	kal_int32 temp_v_1 = 0, temp_v_2 = 0;
-
-	if (temperature <= TEMPERATURE_T1) {
-		low_profile_p = fgauge_get_profile(TEMPERATURE_T0);
-		high_profile_p = fgauge_get_profile(TEMPERATURE_T1);
-		low_temperature = (-10);
-		high_temperature = TEMPERATURE_T1;
-
-		if (temperature < low_temperature) {
-			temperature = low_temperature;
-		}
-	} else if (temperature <= TEMPERATURE_T2) {
-		low_profile_p = fgauge_get_profile(TEMPERATURE_T1);
-		high_profile_p = fgauge_get_profile(TEMPERATURE_T2);
-		low_temperature = TEMPERATURE_T1;
-		high_temperature = TEMPERATURE_T2;
-
-		if (temperature < low_temperature) {
-			temperature = low_temperature;
-		}
-	} else {
-		low_profile_p = fgauge_get_profile(TEMPERATURE_T2);
-		high_profile_p = fgauge_get_profile(TEMPERATURE_T3);
-		low_temperature = TEMPERATURE_T2;
-		high_temperature = TEMPERATURE_T3;
-
-		if (temperature > high_temperature) {
-			temperature = high_temperature;
-		}
-	}
-
-	saddles = fgauge_get_saddles();
-
-	for (i = 0; i < saddles; i++) {
-		if (((high_profile_p + i)->voltage) > ((low_profile_p + i)->voltage)) {
-			temp_v_1 = (high_profile_p + i)->voltage;
-			temp_v_2 = (low_profile_p + i)->voltage;
-
-			(temp_profile_p + i)->voltage = temp_v_2 +
-			    (((temperature - low_temperature) * (temp_v_1 - temp_v_2)
-			     ) / (high_temperature - low_temperature)
-			    );
-		} else {
-			temp_v_1 = (low_profile_p + i)->voltage;
-			temp_v_2 = (high_profile_p + i)->voltage;
-
-			(temp_profile_p + i)->voltage = temp_v_2 +
-			    (((high_temperature - temperature) * (temp_v_1 - temp_v_2)
-			     ) / (high_temperature - low_temperature)
-			    );
-		}
-
-		(temp_profile_p + i)->percentage = (high_profile_p + i)->percentage;
-#if 0
-		(temp_profile_p + i)->voltage = temp_v_2 +
-		    (((temperature - low_temperature) * (temp_v_1 - temp_v_2)
-		     ) / (high_temperature - low_temperature)
-		    );
-#endif
-	}
-
-
-	/* Dumpt new battery profile */
-	for (i = 0; i < saddles; i++) {
-		bm_print(BM_LOG_CRTI, "<DOD,Voltage> at %d = <%d,%d>\r\n",
-			 temperature, (temp_profile_p + i)->percentage,
-			 (temp_profile_p + i)->voltage);
-	}
-
-}
-
-void fgauge_construct_r_table_profile(kal_int32 temperature, R_PROFILE_STRUC_P temp_profile_p)
-{
-	R_PROFILE_STRUC_P low_profile_p, high_profile_p;
-	kal_int32 low_temperature, high_temperature;
-	int i, saddles;
-	kal_int32 temp_v_1 = 0, temp_v_2 = 0;
-	kal_int32 temp_r_1 = 0, temp_r_2 = 0;
-
-	if (temperature <= TEMPERATURE_T1) {
-		low_profile_p = fgauge_get_profile_r_table(TEMPERATURE_T0);
-		high_profile_p = fgauge_get_profile_r_table(TEMPERATURE_T1);
-		low_temperature = (-10);
-		high_temperature = TEMPERATURE_T1;
-
-		if (temperature < low_temperature) {
-			temperature = low_temperature;
-		}
-	} else if (temperature <= TEMPERATURE_T2) {
-		low_profile_p = fgauge_get_profile_r_table(TEMPERATURE_T1);
-		high_profile_p = fgauge_get_profile_r_table(TEMPERATURE_T2);
-		low_temperature = TEMPERATURE_T1;
-		high_temperature = TEMPERATURE_T2;
-
-		if (temperature < low_temperature) {
-			temperature = low_temperature;
-		}
-	} else {
-		low_profile_p = fgauge_get_profile_r_table(TEMPERATURE_T2);
-		high_profile_p = fgauge_get_profile_r_table(TEMPERATURE_T3);
-		low_temperature = TEMPERATURE_T2;
-		high_temperature = TEMPERATURE_T3;
-
-		if (temperature > high_temperature) {
-			temperature = high_temperature;
-		}
-	}
-
-	saddles = fgauge_get_saddles_r_table();
-
-	/* Interpolation for V_BAT */
-	for (i = 0; i < saddles; i++) {
-		if (((high_profile_p + i)->voltage) > ((low_profile_p + i)->voltage)) {
-			temp_v_1 = (high_profile_p + i)->voltage;
-			temp_v_2 = (low_profile_p + i)->voltage;
-
-			(temp_profile_p + i)->voltage = temp_v_2 +
-			    (((temperature - low_temperature) * (temp_v_1 - temp_v_2)
-			     ) / (high_temperature - low_temperature)
-			    );
-		} else {
-			temp_v_1 = (low_profile_p + i)->voltage;
-			temp_v_2 = (high_profile_p + i)->voltage;
-
-			(temp_profile_p + i)->voltage = temp_v_2 +
-			    (((high_temperature - temperature) * (temp_v_1 - temp_v_2)
-			     ) / (high_temperature - low_temperature)
-			    );
-		}
-
-#if 0
-		/* (temp_profile_p + i)->resistance = (high_profile_p + i)->resistance; */
-
-		(temp_profile_p + i)->voltage = temp_v_2 +
-		    (((temperature - low_temperature) * (temp_v_1 - temp_v_2)
-		     ) / (high_temperature - low_temperature)
-		    );
-#endif
-	}
-
-	/* Interpolation for R_BAT */
-	for (i = 0; i < saddles; i++) {
-		if (((high_profile_p + i)->resistance) > ((low_profile_p + i)->resistance)) {
-			temp_r_1 = (high_profile_p + i)->resistance;
-			temp_r_2 = (low_profile_p + i)->resistance;
-
-			(temp_profile_p + i)->resistance = temp_r_2 +
-			    (((temperature - low_temperature) * (temp_r_1 - temp_r_2)
-			     ) / (high_temperature - low_temperature)
-			    );
-		} else {
-			temp_r_1 = (low_profile_p + i)->resistance;
-			temp_r_2 = (high_profile_p + i)->resistance;
-
-			(temp_profile_p + i)->resistance = temp_r_2 +
-			    (((high_temperature - temperature) * (temp_r_1 - temp_r_2)
-			     ) / (high_temperature - low_temperature)
-			    );
-		}
-
-#if 0
-		/* (temp_profile_p + i)->voltage = (high_profile_p + i)->voltage; */
-
-		(temp_profile_p + i)->resistance = temp_r_2 +
-		    (((temperature - low_temperature) * (temp_r_1 - temp_r_2)
-		     ) / (high_temperature - low_temperature)
-		    );
-#endif
-	}
-
-	/* Dumpt new r-table profile */
-	for (i = 0; i < saddles; i++) {
-		bm_print(BM_LOG_CRTI, "<Rbat,VBAT> at %d = <%d,%d>\r\n",
-			 temperature, (temp_profile_p + i)->resistance,
-			 (temp_profile_p + i)->voltage);
-	}
-
-}
-
-void fgauge_construct_table_by_temp(void)
-{
-#if defined(CONFIG_POWER_EXT)
-#else
-	kal_uint32 i;
-	static kal_int32 init_temp = KAL_TRUE;
-	static kal_int32 curr_temp, last_temp, avg_temp;
-	static kal_int32 battTempBuffer[TEMP_AVERAGE_SIZE];
-	static kal_int32 temperature_sum;
-	static kal_uint8 tempIndex;
-
-	curr_temp = battery_meter_get_battery_temperature();
-
-	/* Temperature window init */
-	if (init_temp == KAL_TRUE) {
-		for (i = 0; i < TEMP_AVERAGE_SIZE; i++) {
-			battTempBuffer[i] = curr_temp;
-		}
-		last_temp = curr_temp;
-		temperature_sum = curr_temp * TEMP_AVERAGE_SIZE;
-		init_temp = KAL_FALSE;
-	}
-	/* Temperature sliding window */
-	temperature_sum -= battTempBuffer[tempIndex];
-	temperature_sum += curr_temp;
-	battTempBuffer[tempIndex] = curr_temp;
-	avg_temp = (temperature_sum) / TEMP_AVERAGE_SIZE;
-
-	if (avg_temp != last_temp) {
-		bm_print(BM_LOG_FULL,
-			 "[fgauge_construct_table_by_temp] reconstruct table by temperature change from (%d) to (%d)\r\n",
-			 last_temp, avg_temp);
-		fgauge_construct_r_table_profile(curr_temp,
-						 fgauge_get_profile_r_table(TEMPERATURE_T));
-		fgauge_construct_battery_profile(curr_temp, fgauge_get_profile(TEMPERATURE_T));
-		last_temp = avg_temp;
-        	temperature_change = 1;
-	}
-
-	tempIndex = (tempIndex + 1) % TEMP_AVERAGE_SIZE;
-
-#endif
-}
-
-#if defined(CUST_CAPACITY_OCV2CV_TRANSFORM)
-/*
-	ZCV table is created by 600mA loading.
-	Here we calculate average current and get a factor based on 600mA.
-*/
-void fgauge_get_current_factor(void)
-{
-#if defined(CONFIG_POWER_EXT)
-#else
-	kal_uint32 i;
-	static kal_int32 init_current = KAL_TRUE;
-	static kal_int32 inst_current, avg_current;
-	static kal_int32 battCurrentBuffer[TEMP_AVERAGE_SIZE];
-	static kal_int32 current_sum;
-	static kal_uint8 tempcurrentIndex;
-
-	if (KAL_TRUE == gFG_Is_Charging) {
-		init_current = KAL_TRUE;
-		g_currentfactor = 100;
-		bm_print(BM_LOG_CRTI, "[fgauge_get_current_factor] Charging!!\r\n");
-		return;
-	}
-
-	inst_current = gFG_current;
-
-	if (init_current == KAL_TRUE) {
-		for (i = 0; i < TEMP_AVERAGE_SIZE; i++)
-			battCurrentBuffer[i] = inst_current;
-
-		current_sum = inst_current * TEMP_AVERAGE_SIZE;
-		init_current = KAL_FALSE;
-	}
-
-	/* current sliding window */
-	current_sum -= battCurrentBuffer[tempcurrentIndex];
-	current_sum += inst_current;
-	battCurrentBuffer[tempcurrentIndex] = inst_current;
-	avg_current = (current_sum) / TEMP_AVERAGE_SIZE;
-
-	g_currentfactor = avg_current * 100 / CV_CURRENT;	/* calculate factor by 600ma */
-
-	bm_print(BM_LOG_CRTI, "[fgauge_get_current_factor] %d,%d,%d,%d\r\n",
-		 inst_current, avg_current, g_currentfactor, gFG_Is_Charging);
-
-	tempcurrentIndex = (tempcurrentIndex + 1) % TEMP_AVERAGE_SIZE;
-#endif
-}
-
-/*
-	ZCV table has battery OCV-to-resistance information.
-	Based on a given discharging current value, we can get a new estimated Qmax.
-	Qmax is defined as OCV -I*R < power off voltage.
-	Default power off voltage is 3400mV.
-*/
-
-kal_int32 fgauge_get_Q_max_high_current_by_current(kal_int32 i_current, kal_int16 val_temp)
-{
-	kal_int32 ret_Q_max = 0;
-	kal_int32 iIndex = 0, saddles = 0;
-	kal_int32 OCV_temp = 0, Rbat_temp = 0, V_drop = 0;
-	R_PROFILE_STRUC_P p_profile_r;
-	BATTERY_PROFILE_STRUC_P p_profile_battery;
-	kal_int32 threshold = SYSTEM_OFF_VOLTAGE;
-	/* for Qmax initialization */
-	ret_Q_max = fgauge_get_Q_max_high_current(val_temp);
-
-	/* get Rbat and OCV table of the current temperature */
-	p_profile_r = fgauge_get_profile_r_table(TEMPERATURE_T);
-	p_profile_battery = fgauge_get_profile(TEMPERATURE_T);
-	if (p_profile_r == NULL || p_profile_battery == NULL) {
-		bm_print(BM_LOG_CRTI, "get R-Table profile/OCV table profile : fail !\r\n");
-		return ret_Q_max;
-	}
-
-	if (0 == p_profile_r->resistance || 0 == p_profile_battery->voltage) {
-		bm_print(BM_LOG_CRTI, "get R-Table profile/OCV table profile : not ready !\r\n");
-		return ret_Q_max;
-	}
-
-	saddles = fgauge_get_saddles();
-
-	/* get Qmax in current temperature (>3.4) */
-	for (iIndex = 0; iIndex < saddles - 1; iIndex++) {
-		OCV_temp = (p_profile_battery + iIndex)->voltage;
-		Rbat_temp = (p_profile_r + iIndex)->resistance;
-		V_drop = (i_current * Rbat_temp) / 10000;
-
-		if (OCV_temp - V_drop < threshold) {
-			if (iIndex <= 1)
-				ret_Q_max = STEP_OF_QMAX;
-			else
-				ret_Q_max = (iIndex - 1) * STEP_OF_QMAX;
-			break;
-		}
-	}
-
-	bm_print(BM_LOG_CRTI, "[fgauge_get_Q_max_by_current] %d,%d,%d,%d,%d\r\n",
-		 i_current, iIndex, OCV_temp, Rbat_temp, ret_Q_max);
-
-	return ret_Q_max;
-}
-#endif
-
-void fg_qmax_update_for_aging(void)
-{
-#if defined(CONFIG_POWER_EXT)
-#else
-	kal_bool hw_charging_done = bat_is_charging_full();
-
-	if (hw_charging_done == KAL_TRUE)	/* charging full, g_HW_Charging_Done == 1 */
-	{
-		if (gFG_DOD0 > 85) {
-			if (gFG_columb < 0)
-				gFG_columb = gFG_columb - gFG_columb * 2;	/* absolute value */
-
-			gFG_BATT_CAPACITY_aging =
-			    (((gFG_columb * 1000) + (5 * gFG_DOD0)) / gFG_DOD0) / 10;
-
-			/* tuning */
-			gFG_BATT_CAPACITY_aging =
-			    (gFG_BATT_CAPACITY_aging * 100) / AGING_TUNING_VALUE;
-
-			if (gFG_BATT_CAPACITY_aging == 0) {
-				gFG_BATT_CAPACITY_aging =
-				    fgauge_get_Q_max(battery_meter_get_battery_temperature());
-				bm_print(BM_LOG_CRTI,
-					 "[fg_qmax_update_for_aging] error, restore gFG_BATT_CAPACITY_aging (%d)\n",
-					 gFG_BATT_CAPACITY_aging);
-			}
-
-			bm_print(BM_LOG_CRTI,
-				 "[fg_qmax_update_for_aging] need update : gFG_columb=%d, gFG_DOD0=%d, new_qmax=%d\r\n",
-				 gFG_columb, gFG_DOD0, gFG_BATT_CAPACITY_aging);
-		} else {
-			bm_print(BM_LOG_CRTI,
-				 "[fg_qmax_update_for_aging] no update : gFG_columb=%d, gFG_DOD0=%d, new_qmax=%d\r\n",
-				 gFG_columb, gFG_DOD0, gFG_BATT_CAPACITY_aging);
-		}
-	} else {
-		bm_print(BM_LOG_CRTI, "[fg_qmax_update_for_aging] hw_charging_done=%d\r\n",
-			 hw_charging_done);
-	}
-#endif
-}
-
-char doddbg[100];
-void dodprint(void)
-{
-	printk(doddbg);
-}
-
-void dod_init(void)
-{
-#if defined(SOC_BY_SW_FG)
-	kal_int32 gFG_capacity_by_sw_ocv = gFG_capacity_by_v;	
-#endif//by zhu
-#if defined(SOC_BY_HW_FG)
-	int ret = 0;
-
-#if defined(IS_BATTERY_REMOVE_BY_PMIC)
-	kal_int32 gFG_capacity_by_sw_ocv = gFG_capacity_by_v;	
-#endif //#if defined(IS_BATTERY_REMOVE_BY_PMIC)
-
-	/* use get_hw_ocv----------------------------------------------------------------- */
-	ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_HW_OCV, &gFG_voltage);
-	gFG_capacity_by_v = fgauge_read_capacity_by_v(gFG_voltage);
-
-	bm_print(BM_LOG_CRTI, "[FGADC] get_hw_ocv=%d, HW_SOC=%d, SW_SOC = %d\n",
-		 gFG_voltage, gFG_capacity_by_v, gFG_capacity_by_v_init);
-#if defined(EXTERNAL_SWCHR_SUPPORT)
-	/* compare with hw_ocv & sw_ocv, check if less than or equal to 5% tolerance */
-	if ((abs(gFG_capacity_by_v_init - gFG_capacity_by_v) > 5)
-	    && (bat_is_charger_exist() == KAL_TRUE)) {
-		gFG_capacity_by_v = gFG_capacity_by_v_init;
-	}
-#endif
-#if defined(HW_FG_FORCE_USE_SW_OCV)
-	gFG_capacity_by_v = gFG_capacity_by_v_init;
-	bm_print(BM_LOG_CRTI, "[FGADC] HW_FG_FORCE_USE_SW_OCV : HW_SOC=%d, SW_SOC = %d\n",
-		 gFG_capacity_by_v, gFG_capacity_by_v_init);
-#endif
-	/* ------------------------------------------------------------------------------- */
-#endif
-
-#if defined(CONFIG_POWER_EXT)
-	g_rtc_fg_soc = gFG_capacity_by_v;
-#else
-	g_rtc_fg_soc = get_rtc_spare_fg_value();
-#endif
-
-
-#if defined(IS_BATTERY_REMOVE_BY_PMIC)
-
-	sprintf(doddbg,"rtc:%d hwocv:(%d:%d) swocv:(%d,%d) battery_remove:%d %d %d %d",g_rtc_fg_soc,gFG_voltage,gFG_capacity_by_v,gFG_voltage_init,gFG_capacity_by_v_init,is_battery_remove_pmic(),
-	CUST_POWERON_DELTA_CAPACITY_TOLRANCE,CUST_POWERON_LOW_CAPACITY_TOLRANCE,CUST_POWERON_DELTA_HW_SW_OCV_CAPACITY_TOLRANCE);
-
-/*
-		if(is_battery_remove_pmic()==0 && (g_rtc_fg_soc != 0))
-		{
-			bm_print(BM_LOG_CRTI, "[FGADC]is_battery_remove()==0 , use rtc_fg_soc%d\n",g_rtc_fg_soc);
-			gFG_capacity_by_v = g_rtc_fg_soc;
-		}
-		else
-*/
-		{
-
-#if defined(INIT_SOC_BY_SW_SOC)
-			if (((g_rtc_fg_soc != 0)
-				 && (((abs(g_rtc_fg_soc - gFG_capacity_by_v)) <= CUST_POWERON_DELTA_CAPACITY_TOLRANCE)
-				|| (abs(gFG_capacity_by_v_init - g_rtc_fg_soc) < abs(gFG_capacity_by_v - gFG_capacity_by_v_init))))
-				|| ((g_rtc_fg_soc != 0)
-				&& (g_boot_reason == BR_WDT_BY_PASS_PWK || g_boot_reason == BR_WDT
-					|| g_boot_reason == BR_TOOL_BY_PASS_PWK || g_boot_reason == BR_2SEC_REBOOT
-					|| g_boot_mode == RECOVERY_BOOT)))
-		
-#else
-			if (((g_rtc_fg_soc != 0)
-				 && (((abs(g_rtc_fg_soc - gFG_capacity_by_v)) < CUST_POWERON_DELTA_CAPACITY_TOLRANCE))
-				 &&
-				 ((gFG_capacity_by_v > CUST_POWERON_LOW_CAPACITY_TOLRANCE
-				   || bat_is_charger_exist() == KAL_TRUE)))
-				|| ((g_rtc_fg_soc != 0)
-				&& (g_boot_reason == BR_WDT_BY_PASS_PWK || g_boot_reason == BR_WDT
-					|| g_boot_reason == BR_TOOL_BY_PASS_PWK || g_boot_reason == BR_2SEC_REBOOT
-					|| g_boot_mode == RECOVERY_BOOT)))
-#endif
-			{
-				gFG_capacity_by_v = g_rtc_fg_soc;
-			}
-			else
-			{
-				if(abs(gFG_capacity_by_v-gFG_capacity_by_sw_ocv)>CUST_POWERON_DELTA_HW_SW_OCV_CAPACITY_TOLRANCE)
-				{
-					bm_print(BM_LOG_CRTI, "[FGADC] gFG_capacity_by_v=%d, gFG_capacity_by_sw_ocv=%d use SWOCV\n",gFG_capacity_by_v, gFG_capacity_by_sw_ocv);
-					gFG_capacity_by_v=gFG_capacity_by_sw_ocv;
-				}
-				else
-				{
-					bm_print(BM_LOG_CRTI, "[FGADC] gFG_capacity_by_v=%d, gFG_capacity_by_sw_ocv=%d use HWOCV\n",gFG_capacity_by_v, gFG_capacity_by_sw_ocv);
-				}
-			}
-		
-		}
-
-#else
-
-#if defined(SOC_BY_HW_FG)
-#if defined(INIT_SOC_BY_SW_SOC)
-	if (((g_rtc_fg_soc != 0)
-	     && (((abs(g_rtc_fg_soc - gFG_capacity_by_v)) <= CUST_POWERON_DELTA_CAPACITY_TOLRANCE)
-	    || (abs(gFG_capacity_by_v_init - g_rtc_fg_soc) < abs(gFG_capacity_by_v - gFG_capacity_by_v_init))))
-	    || ((g_rtc_fg_soc != 0)
-		&& (g_boot_reason == BR_WDT_BY_PASS_PWK || g_boot_reason == BR_WDT
-		    || g_boot_reason == BR_TOOL_BY_PASS_PWK || g_boot_reason == BR_2SEC_REBOOT
-		    || g_boot_mode == RECOVERY_BOOT)))
-
-#else
-	if (((g_rtc_fg_soc != 0)
-	     && (((abs(g_rtc_fg_soc - gFG_capacity_by_v)) < CUST_POWERON_DELTA_CAPACITY_TOLRANCE))
-	     &&
-	     ((gFG_capacity_by_v > CUST_POWERON_LOW_CAPACITY_TOLRANCE
-	       || bat_is_charger_exist() == KAL_TRUE)))
-	    || ((g_rtc_fg_soc != 0)
-		&& (g_boot_reason == BR_WDT_BY_PASS_PWK || g_boot_reason == BR_WDT
-		    || g_boot_reason == BR_TOOL_BY_PASS_PWK || g_boot_reason == BR_2SEC_REBOOT
-		    || g_boot_mode == RECOVERY_BOOT)))
-#endif
-	{
-		gFG_capacity_by_v = g_rtc_fg_soc;
-	}
-#elif defined(SOC_BY_SW_FG)
-	if (((g_rtc_fg_soc != 0)
-	     && (((abs(g_rtc_fg_soc - gFG_capacity_by_v)) < CUST_POWERON_DELTA_CAPACITY_TOLRANCE)
-		 || (abs(g_rtc_fg_soc - g_booting_vbat) < CUST_POWERON_DELTA_CAPACITY_TOLRANCE))
-	     &&
-	     ((gFG_capacity_by_v > CUST_POWERON_LOW_CAPACITY_TOLRANCE
-	       || bat_is_charger_exist() == KAL_TRUE)))
-	    || ((g_rtc_fg_soc != 0)
-		&& (g_boot_reason == BR_WDT_BY_PASS_PWK || g_boot_reason == BR_WDT
-		    || g_boot_reason == BR_TOOL_BY_PASS_PWK || g_boot_reason == BR_2SEC_REBOOT
-		    || g_boot_mode == RECOVERY_BOOT)))
-	{
-		gFG_capacity_by_v = g_rtc_fg_soc;
-	}
-#endif
-#endif     
-
-    
-	bm_print(BM_LOG_CRTI, "[FGADC] g_rtc_fg_soc=%d, gFG_capacity_by_v=%d\n",
-		 g_rtc_fg_soc, gFG_capacity_by_v);
-
-	if (gFG_capacity_by_v == 0 && bat_is_charger_exist() == KAL_TRUE) {
-		gFG_capacity_by_v = 1;
-
-		bm_print(BM_LOG_CRTI, "[FGADC] gFG_capacity_by_v=%d\n", gFG_capacity_by_v);
-	}
-	gFG_capacity = gFG_capacity_by_v;
-	gFG_capacity_by_c_init = gFG_capacity;
-	gFG_capacity_by_c = gFG_capacity;
-
-	gFG_DOD0 = 100 - gFG_capacity;
-	gFG_DOD1 = gFG_DOD0;
-
-	gfg_percent_check_point = gFG_capacity;
-
-#if defined(CHANGE_TRACKING_POINT)
-	gFG_15_vlot = fgauge_read_v_by_capacity((100 - g_tracking_point));
-	bm_print(BM_LOG_CRTI, "[FGADC] gFG_15_vlot = %dmV\n", gFG_15_vlot);
-#else
-	/* gFG_15_vlot = fgauge_read_v_by_capacity(86); //14% */
-	gFG_15_vlot = fgauge_read_v_by_capacity((100 - g_tracking_point));
-	bm_print(BM_LOG_CRTI, "[FGADC] gFG_15_vlot = %dmV\n", gFG_15_vlot);
-	if ((gFG_15_vlot > 3800) || (gFG_15_vlot < 3600)) {
-		bm_print(BM_LOG_CRTI, "[FGADC] gFG_15_vlot(%d) over range, reset to 3700\n",
-			 gFG_15_vlot);
-		gFG_15_vlot = 3700;
-	}
-#endif
-}
-
-/* ============================================================ // SW FG */
-kal_int32 mtk_imp_tracking(kal_int32 ori_voltage, kal_int32 ori_current, kal_int32 recursion_time)
-{
-	kal_int32 ret_compensate_value = 0;
-	kal_int32 temp_voltage_1 = ori_voltage;
-	kal_int32 temp_voltage_2 = temp_voltage_1;
-	int i = 0;
-
-	for (i = 0; i < recursion_time; i++) {
-		gFG_resistance_bat = fgauge_read_r_bat_by_v(temp_voltage_2);
-		ret_compensate_value = ((ori_current) * (gFG_resistance_bat + R_FG_VALUE)) / 1000;
-		ret_compensate_value = (ret_compensate_value + (10 / 2)) / 10;
-		temp_voltage_2 = temp_voltage_1 + ret_compensate_value;
-
-		bm_print(BM_LOG_FULL,
-			 "[mtk_imp_tracking] temp_voltage_2=%d,temp_voltage_1=%d,ret_compensate_value=%d,gFG_resistance_bat=%d\n",
-			 temp_voltage_2, temp_voltage_1, ret_compensate_value, gFG_resistance_bat);
-	}
-
-	gFG_resistance_bat = fgauge_read_r_bat_by_v(temp_voltage_2);
-	ret_compensate_value =
-	    ((ori_current) * (gFG_resistance_bat + R_FG_VALUE + FG_METER_RESISTANCE)) / 1000;
-	ret_compensate_value = (ret_compensate_value + (10 / 2)) / 10;
-
-	gFG_compensate_value = ret_compensate_value;
-
-	bm_print(BM_LOG_FULL,
-		 "[mtk_imp_tracking] temp_voltage_2=%d,temp_voltage_1=%d,ret_compensate_value=%d,gFG_resistance_bat=%d\n",
-		 temp_voltage_2, temp_voltage_1, ret_compensate_value, gFG_resistance_bat);
-
-	return ret_compensate_value;
-}
-
-void oam_init(void)
-{
-	int ret = 0;
-	kal_int32 vbat_capacity = 0;
-	kal_bool charging_enable = KAL_FALSE;
-
-	/*stop charging for vbat measurement */
-	battery_charging_control(CHARGING_CMD_ENABLE, &charging_enable);
-
-	msleep(50);
-
-	g_booting_vbat = 5;	/* set avg times */
-	ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_HW_OCV, &gFG_voltage);
-	ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_ADC_V_BAT_SENSE, &g_booting_vbat);
-
-
-	gFG_capacity_by_v = fgauge_read_capacity_by_v(gFG_voltage);
-	vbat_capacity = fgauge_read_capacity_by_v(g_booting_vbat);
-
-	if (bat_is_charger_exist() == KAL_TRUE) {
-		bm_print(BM_LOG_CRTI, "[oam_init_inf] gFG_capacity_by_v=%d, vbat_capacity=%d,\n",
-			 gFG_capacity_by_v, vbat_capacity);
-
-		/* to avoid plug in cable without battery, then plug in battery to make hw soc = 100% */
-		/* if the difference bwtween ZCV and vbat is too large, using vbat instead ZCV */
-		if (((gFG_capacity_by_v == 100) && (vbat_capacity < CUST_POWERON_MAX_VBAT_TOLRANCE))
-		    || (abs(gFG_capacity_by_v - vbat_capacity) >
-			CUST_POWERON_DELTA_VBAT_TOLRANCE)) {
-			bm_print(BM_LOG_CRTI,
-				 "[oam_init] fg_vbat=(%d), vbat=(%d), set fg_vat as vat\n",
-				 gFG_voltage, g_booting_vbat);
-
-			gFG_voltage = g_booting_vbat;
-			gFG_capacity_by_v = vbat_capacity;
-		}
-	}
-
-	gFG_capacity_by_v_init = gFG_capacity_by_v;
-
-	dod_init();
-
-	gFG_BATT_CAPACITY_aging = fgauge_get_Q_max(force_get_tbat(KAL_FALSE));
-
-	/* oam_v_ocv_1 = gFG_voltage; */
-	/* oam_v_ocv_2 = gFG_voltage; */
-
-
-	oam_v_ocv_init = fgauge_read_v_by_d(gFG_DOD0);
-	oam_v_ocv_2 = oam_v_ocv_1 = oam_v_ocv_init;
-	g_vol_bat_hw_ocv = gFG_voltage;
-
-	/* vbat = 5; //set avg times */
-	/* ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_ADC_V_BAT_SENSE, &vbat); */
-	/* oam_r_1 = fgauge_read_r_bat_by_v(vbat); */
-	oam_r_1 = fgauge_read_r_bat_by_v(gFG_voltage);
-	oam_r_2 = oam_r_1;
-
-	oam_d0 = gFG_DOD0;
-	oam_d_5 = oam_d0;
-	oam_i_ori = gFG_current;
-	g_d_hw_ocv = oam_d0;
-
-	if (oam_init_i == 0) {
-		bm_print(BM_LOG_CRTI,
-			 "[oam_init] oam_v_ocv_1,oam_v_ocv_2,oam_r_1,oam_r_2,oam_d0,oam_i_ori\n");
-		oam_init_i = 1;
-	}
-
-	bm_print(BM_LOG_CRTI, "[oam_init] %d,%d,%d,%d,%d,%d\n",
-		 oam_v_ocv_1, oam_v_ocv_2, oam_r_1, oam_r_2, oam_d0, oam_i_ori);
-
-	bm_print(BM_LOG_CRTI, "[oam_init_inf] hw_OCV, hw_D0, RTC, D0, oam_OCV_init, tbat\n");
-	bm_print(BM_LOG_CRTI,
-		 "[oam_run_inf] oam_OCV1, oam_OCV2, vbat, I1, I2, R1, R2, Car1, Car2,qmax, tbat\n");
-	bm_print(BM_LOG_CRTI, "[oam_result_inf] D1, D2, D3, D4, D5, UI_SOC\n");
-
-
-	bm_print(BM_LOG_CRTI, "[oam_init_inf] %d, %d, %d, %d, %d, %d\n",
-		 gFG_voltage, (100 - fgauge_read_capacity_by_v(gFG_voltage)), g_rtc_fg_soc,
-		 gFG_DOD0, oam_v_ocv_init, force_get_tbat(KAL_FALSE));
-
-}
-
-
-void oam_run(void)
-{
-	int vol_bat = 0;
-	/* int vol_bat_hw_ocv=0; */
-	/* int d_hw_ocv=0; */
-	int charging_current = 0;
-	int ret = 0;
-	/* kal_uint32 now_time; */
-	struct timespec now_time;
-	kal_int32 delta_time = 0;
-
-	/* now_time = rtc_read_hw_time(); */
-	getrawmonotonic(&now_time);
-
-	/* delta_time = now_time - last_oam_run_time; */
-	delta_time = now_time.tv_sec - last_oam_run_time.tv_sec;
-
-	bm_print(BM_LOG_CRTI, "[oam_run_time] delta time=%d\n", delta_time);
-
-	last_oam_run_time = now_time;
-
-	/* Reconstruct table if temp changed; */
-	fgauge_construct_table_by_temp();
-
-#if defined(CUST_CAPACITY_OCV2CV_TRANSFORM)
-	fgauge_get_current_factor();
-#endif
-
-	vol_bat = 15;		/* set avg times */
-	ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_ADC_V_BAT_SENSE, &vol_bat);
-
-	/* ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_HW_OCV, &vol_bat_hw_ocv); */
-	/* d_hw_ocv = fgauge_read_d_by_v(vol_bat_hw_ocv); */
-
-	oam_i_1 = (((oam_v_ocv_1 - vol_bat) * 1000) * 10) / oam_r_1;	/* 0.1mA */
-	oam_i_2 = (((oam_v_ocv_2 - vol_bat) * 1000) * 10) / oam_r_2;	/* 0.1mA */
-
-	oam_car_1 = (oam_i_1 * delta_time / 3600) + oam_car_1;	/* 0.1mAh */
-	oam_car_2 = (oam_i_2 * delta_time / 3600) + oam_car_2;	/* 0.1mAh */
-
-	oam_d_1 = oam_d0 + (oam_car_1 * 100 / 10) / gFG_BATT_CAPACITY_aging;
-	if (oam_d_1 < 0)
-		oam_d_1 = 0;
-	if (oam_d_1 > 100)
-		oam_d_1 = 100;
-
-	oam_d_2 = oam_d0 + (oam_car_2 * 100 / 10) / gFG_BATT_CAPACITY_aging;
-	if (oam_d_2 < 0)
-		oam_d_2 = 0;
-	if (oam_d_2 > 100)
-		oam_d_2 = 100;
-
-	oam_v_ocv_1 = vol_bat + mtk_imp_tracking(vol_bat, oam_i_2, 5);
-
-	oam_d_3 = fgauge_read_d_by_v(oam_v_ocv_1);
-	if (oam_d_3 < 0)
-		oam_d_3 = 0;
-	if (oam_d_3 > 100)
-		oam_d_3 = 100;
-
-	oam_r_1 = fgauge_read_r_bat_by_v(oam_v_ocv_1);
-
-	oam_v_ocv_2 = fgauge_read_v_by_d(oam_d_2);
-	oam_r_2 = fgauge_read_r_bat_by_v(oam_v_ocv_2);
-
-#if 0
-	oam_d_4 = (oam_d_2 + oam_d_3) / 2;
-#else
-	oam_d_4 = oam_d_3;
-#endif
-
-	gFG_columb = oam_car_2 / 10;	/* mAh */
-
-	if ((oam_i_1 < 0) || (oam_i_2 < 0))
-		gFG_Is_Charging = KAL_TRUE;
-	else
-		gFG_Is_Charging = KAL_FALSE;
-
-#if 0
-	if (gFG_Is_Charging == KAL_FALSE) {
-		d5_count_time = 60;
-	} else {
-		charging_current = get_charging_setting_current();
-		charging_current = charging_current / 100;
-		d5_count_time_rate =
-		    (((gFG_BATT_CAPACITY_aging * 60 * 60 / 100 / (charging_current - 50)) * 10) +
-		     5) / 10;
-
-		if (d5_count_time_rate < 1)
-			d5_count_time_rate = 1;
-
-		d5_count_time = d5_count_time_rate;
-	}
-#else
-	d5_count_time = 60;
-#endif
-	d5_count = d5_count + delta_time;
-	if (d5_count >= d5_count_time) {
-		if (gFG_Is_Charging == KAL_FALSE) {
-			if (oam_d_3 > oam_d_5) {
-				oam_d_5 = oam_d_5 + 1;
-			} else {
-				if (oam_d_4 > oam_d_5) {
-					oam_d_5 = oam_d_5 + 1;
-				}
-			}
-		} else {
-			if (oam_d_5 > oam_d_3) {
-				oam_d_5 = oam_d_5 - 1;
-			} else {
-				if (oam_d_4 < oam_d_5) {
-					oam_d_5 = oam_d_5 - 1;
-				}
-			}
-		}
-		d5_count = 0;
-		oam_d_3_pre = oam_d_3;
-		oam_d_4_pre = oam_d_4;
-	}
-
-	bm_print(BM_LOG_CRTI, "[oam_run] %d,%d,%d,%d,%d,%d,%d,%d\n",
-		 d5_count, d5_count_time, oam_d_3_pre, oam_d_3, oam_d_4_pre, oam_d_4, oam_d_5,
-		 charging_current);
-
-	if (oam_run_i == 0) {
-		bm_print(BM_LOG_FULL,
-			 "[oam_run] oam_i_1,oam_i_2,oam_car_1,oam_car_2,oam_d_1,oam_d_2,oam_v_ocv_1,oam_d_3,oam_r_1,oam_v_ocv_2,oam_r_2,vol_bat,g_vol_bat_hw_ocv,g_d_hw_ocv\n");
-		oam_run_i = 1;
-	}
-
-	bm_print(BM_LOG_FULL, "[oam_run] %d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d\n",
-		 oam_i_1, oam_i_2, oam_car_1, oam_car_2, oam_d_1, oam_d_2, oam_v_ocv_1, oam_d_3,
-		 oam_r_1, oam_v_ocv_2, oam_r_2, vol_bat, g_vol_bat_hw_ocv, g_d_hw_ocv);
-
-	bm_print(BM_LOG_FULL, "[oam_total] %d,%d,%d,%d,%d,%d,%d,%d,%d,%d\n",
-		 gFG_capacity_by_c, gFG_capacity_by_v, gfg_percent_check_point,
-		 oam_d_1, oam_d_2, oam_d_3, oam_d_4, oam_d_5, gFG_capacity_by_c_init, g_d_hw_ocv);
-
-	bm_print(BM_LOG_CRTI, "[oam_total_s] %d,%d,%d,%d,%d,%d,%d,%d,%d,%d\n", gFG_capacity_by_c,	/* 1 */
-		 gFG_capacity_by_v,	/* 2 */
-		 gfg_percent_check_point,	/* 3 */
-		 (100 - oam_d_1),	/* 4 */
-		 (100 - oam_d_2),	/* 5 */
-		 (100 - oam_d_3),	/* 6 */
-		 (100 - oam_d_4),	/* 9 */
-		 (100 - oam_d_5),	/* 10 */
-		 gFG_capacity_by_c_init,	/* 7 */
-		 (100 - g_d_hw_ocv)	/* 8 */
-	    );
-
-	bm_print(BM_LOG_FULL, "[oam_total_s_err] %d,%d,%d,%d,%d,%d,%d\n",
-		 (gFG_capacity_by_c - gFG_capacity_by_v),
-		 (gFG_capacity_by_c - gfg_percent_check_point),
-		 (gFG_capacity_by_c - (100 - oam_d_1)),
-		 (gFG_capacity_by_c - (100 - oam_d_2)),
-		 (gFG_capacity_by_c - (100 - oam_d_3)),
-		 (gFG_capacity_by_c - (100 - oam_d_4)), (gFG_capacity_by_c - (100 - oam_d_5))
-	    );
-
-	bm_print(BM_LOG_CRTI, "[oam_init_inf] %d, %d, %d, %d, %d, %d\n",
-		 gFG_voltage, (100 - fgauge_read_capacity_by_v(gFG_voltage)), g_rtc_fg_soc,
-		 gFG_DOD0, oam_v_ocv_init, force_get_tbat(KAL_FALSE));
-
-	bm_print(BM_LOG_CRTI, "[oam_run_inf] %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d\n",
-		 oam_v_ocv_1, oam_v_ocv_2, vol_bat, oam_i_1, oam_i_2, oam_r_1, oam_r_2, oam_car_1,
-		 oam_car_2, gFG_BATT_CAPACITY_aging, force_get_tbat(KAL_FALSE), oam_d0);
-
-	bm_print(BM_LOG_CRTI, "[oam_result_inf] %d, %d, %d, %d, %d, %d\n",
-		 oam_d_1, oam_d_2, oam_d_3, oam_d_4, oam_d_5, BMT_status.UI_SOC);
-}
-
-/* ============================================================ // */
-
-
-
-void table_init(void)
-{
-	BATTERY_PROFILE_STRUC_P profile_p;
-	R_PROFILE_STRUC_P profile_p_r_table;
-
-	int temperature = force_get_tbat(KAL_FALSE);
-
-	/* Re-constructure r-table profile according to current temperature */
-	profile_p_r_table = fgauge_get_profile_r_table(TEMPERATURE_T);
-	if (profile_p_r_table == NULL) {
-		bm_print(BM_LOG_CRTI,
-			 "[FGADC] fgauge_get_profile_r_table : create table fail !\r\n");
-	}
-	fgauge_construct_r_table_profile(temperature, profile_p_r_table);
-
-	/* Re-constructure battery profile according to current temperature */
-	profile_p = fgauge_get_profile(TEMPERATURE_T);
-	if (profile_p == NULL) {
-		bm_print(BM_LOG_CRTI, "[FGADC] fgauge_get_profile : create table fail !\r\n");
-	}
-	fgauge_construct_battery_profile(temperature, profile_p);
-}
-
-kal_int32 auxadc_algo_run(void)
-{
-	kal_int32 val = 0;
-
-	gFG_voltage = battery_meter_get_battery_voltage(KAL_FALSE);
-	val = fgauge_read_capacity_by_v(gFG_voltage);
-
-	bm_print(BM_LOG_CRTI, "[auxadc_algo_run] %d,%d\n", gFG_voltage, val);
-
-	return val;
-}
-
-#if defined(SOC_BY_HW_FG)
-void update_fg_dbg_tool_value(void)
-{
-	g_fg_dbg_bat_volt = gFG_voltage_init;
-
-	if (gFG_Is_Charging == KAL_TRUE)
-		g_fg_dbg_bat_current = 1 - gFG_current - 1;
-	else
-		g_fg_dbg_bat_current = gFG_current;
-
-	g_fg_dbg_bat_zcv = gFG_voltage;
-
-	g_fg_dbg_bat_temp = gFG_temp;
-
-	g_fg_dbg_bat_r = gFG_resistance_bat;
-
-	g_fg_dbg_bat_car = gFG_columb;
-
-	g_fg_dbg_bat_qmax = gFG_BATT_CAPACITY_aging;
-
-	g_fg_dbg_d0 = gFG_DOD0;
-
-	g_fg_dbg_d1 = gFG_DOD1;
-
-	g_fg_dbg_percentage = bat_get_ui_percentage();
-
-	g_fg_dbg_percentage_fg = gFG_capacity_by_c;
-
-	g_fg_dbg_percentage_voltmode = gfg_percent_check_point;
-}
-
-kal_int32 fgauge_compensate_battery_voltage(kal_int32 ori_voltage)
-{
-	kal_int32 ret_compensate_value = 0;
-
-	gFG_ori_voltage = ori_voltage;
-	gFG_resistance_bat = fgauge_read_r_bat_by_v(ori_voltage);	/* Ohm */
-	ret_compensate_value = (gFG_current * (gFG_resistance_bat + R_FG_VALUE)) / 1000;
-	ret_compensate_value = (ret_compensate_value + (10 / 2)) / 10;
-
-	if (gFG_Is_Charging == KAL_TRUE) {
-		ret_compensate_value = ret_compensate_value - (ret_compensate_value * 2);
-	}
-
-	gFG_compensate_value = ret_compensate_value;
-
-	bm_print(BM_LOG_FULL,
-		 "[CompensateVoltage] Ori_voltage:%d, compensate_value:%d, gFG_resistance_bat:%d, gFG_current:%d\r\n",
-		 ori_voltage, ret_compensate_value, gFG_resistance_bat, gFG_current);
-
-	return ret_compensate_value;
-}
-
-kal_int32 fgauge_compensate_battery_voltage_recursion(kal_int32 ori_voltage,
-						      kal_int32 recursion_time)
-{
-	kal_int32 ret_compensate_value = 0;
-	kal_int32 temp_voltage_1 = ori_voltage;
-	kal_int32 temp_voltage_2 = temp_voltage_1;
-	int i = 0;
-
-	for (i = 0; i < recursion_time; i++) {
-		gFG_resistance_bat = fgauge_read_r_bat_by_v(temp_voltage_2);	/* Ohm */
-		ret_compensate_value = (gFG_current * (gFG_resistance_bat + R_FG_VALUE)) / 1000;
-		ret_compensate_value = (ret_compensate_value + (10 / 2)) / 10;
-
-		if (gFG_Is_Charging == KAL_TRUE) {
-			ret_compensate_value = ret_compensate_value - (ret_compensate_value * 2);
-		}
-		temp_voltage_2 = temp_voltage_1 + ret_compensate_value;
-
-		bm_print(BM_LOG_FULL,
-			 "[fgauge_compensate_battery_voltage_recursion] %d,%d,%d,%d\r\n",
-			 temp_voltage_1, temp_voltage_2, gFG_resistance_bat, ret_compensate_value);
-	}
-
-	gFG_resistance_bat = fgauge_read_r_bat_by_v(temp_voltage_2);	/* Ohm */
-	ret_compensate_value =
-	    (gFG_current * (gFG_resistance_bat + R_FG_VALUE + FG_METER_RESISTANCE)) / 1000;
-	ret_compensate_value = (ret_compensate_value + (10 / 2)) / 10;
-
-	if (gFG_Is_Charging == KAL_TRUE) {
-		ret_compensate_value = ret_compensate_value - (ret_compensate_value * 2);
-	}
-
-	gFG_compensate_value = ret_compensate_value;
-
-	bm_print(BM_LOG_FULL, "[fgauge_compensate_battery_voltage_recursion] %d,%d,%d,%d\r\n",
-		 temp_voltage_1, temp_voltage_2, gFG_resistance_bat, ret_compensate_value);
-
-	return ret_compensate_value;
-}
-
-
-kal_int32 fgauge_get_dod0(kal_int32 voltage, kal_int32 temperature, kal_bool bOcv)
-{
-	kal_int32 dod0 = 0;
-	int i = 0, saddles = 0, jj = 0;
-	BATTERY_PROFILE_STRUC_P profile_p;
-	R_PROFILE_STRUC_P profile_p_r_table;
-	int ret = 0;
-
-/* R-Table (First Time) */
-	/* Re-constructure r-table profile according to current temperature */
-	profile_p_r_table = fgauge_get_profile_r_table(TEMPERATURE_T);
-	if (profile_p_r_table == NULL) {
-		bm_print(BM_LOG_CRTI,
-			 "[FGADC] fgauge_get_profile_r_table : create table fail !\r\n");
-	}
-	fgauge_construct_r_table_profile(temperature, profile_p_r_table);
-
-	/* Re-constructure battery profile according to current temperature */
-	profile_p = fgauge_get_profile(TEMPERATURE_T);
-	if (profile_p == NULL) {
-		bm_print(BM_LOG_CRTI, "[FGADC] fgauge_get_profile : create table fail !\r\n");
-		return 100;
-	}
-	fgauge_construct_battery_profile(temperature, profile_p);
-
-	/* Get total saddle points from the battery profile */
-	saddles = fgauge_get_saddles();
-
-	/* If the input voltage is not OCV, compensate to ZCV due to battery loading */
-	/* Compasate battery voltage from current battery voltage */
-	jj = 0;
-	if (bOcv == KAL_FALSE) {
-		while (gFG_current == 0) {
-			ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_HW_FG_CURRENT, &gFG_current);
-			if (jj > 10)
-				break;
-			jj++;
-		}
-		/* voltage = voltage + fgauge_compensate_battery_voltage(voltage); //mV */
-		voltage = voltage + fgauge_compensate_battery_voltage_recursion(voltage, 5);	/* mV */
-		bm_print(BM_LOG_CRTI, "[FGADC] compensate_battery_voltage, voltage=%d\r\n",
-			 voltage);
-	}
-	/* If battery voltage is less then mimimum profile voltage, then return 100 */
-	/* If battery voltage is greater then maximum profile voltage, then return 0 */
-	if (voltage > (profile_p + 0)->voltage) {
-		return 0;
-	}
-	if (voltage < (profile_p + saddles - 1)->voltage) {
-		return 100;
-	}
-	/* get DOD0 according to current temperature */
-	for (i = 0; i < saddles - 1; i++) {
-		if ((voltage <= (profile_p + i)->voltage)
-		    && (voltage >= (profile_p + i + 1)->voltage)) {
-			dod0 =
-			    (profile_p + i)->percentage +
-			    (((((profile_p + i)->voltage) -
-			       voltage) * (((profile_p + i + 1)->percentage) -
-					   ((profile_p + i)->percentage))
-			     ) / (((profile_p + i)->voltage) - ((profile_p + i + 1)->voltage))
-			    );
-
-			break;
-		}
-	}
-
-	return dod0;
-}
-
-
-kal_int32 fgauge_update_dod(void)
-{
-	kal_int32 FG_dod_1 = 0;
-	int adjust_coulomb_counter = CAR_TUNE_VALUE;
-#ifdef Q_MAX_BY_CURRENT
-	kal_int32 C_0mA=0;
-	kal_int32 C_400mA=0;
-	kal_int32 C_FGCurrent=0;
-#endif
-
-	if (gFG_DOD0 > 100) {
-		gFG_DOD0 = 100;
-		bm_print(BM_LOG_FULL, "[fgauge_update_dod] gFG_DOD0 set to 100, gFG_columb=%d\r\n",
-			 gFG_columb);
-	} else if (gFG_DOD0 < 0) {
-		gFG_DOD0 = 0;
-		bm_print(BM_LOG_FULL, "[fgauge_update_dod] gFG_DOD0 set to 0, gFG_columb=%d\r\n",
-			 gFG_columb);
-	} else {
-	}
-
-	gFG_temp = force_get_tbat(KAL_FALSE);
-
-	if (temperature_change == 1) {
-		gFG_BATT_CAPACITY = fgauge_get_Q_max(gFG_temp);
-		bm_print(BM_LOG_CRTI,
-			 "[fgauge_update_dod] gFG_BATT_CAPACITY=%d, gFG_BATT_CAPACITY_aging=%d, gFG_BATT_CAPACITY_init_high_current=%d\r\n",
-			 gFG_BATT_CAPACITY, gFG_BATT_CAPACITY_aging,
-			 gFG_BATT_CAPACITY_init_high_current);
-		temperature_change = 0;
-	}
-#if 0
-	C_0mA = fgauge_get_Q_max(gFG_temp);
-	C_400mA = fgauge_get_Q_max_high_current(gFG_temp);
-	C_FGCurrent = C_0mA - (C_0mA-C_400mA) * gFG_current_AVG / 4000;
-	if (C_FGCurrent!=0)
-		FG_dod_1 =  gFG_DOD0 - ((gFG_columb*100)/gFG_BATT_CAPACITY_aging)*C_0mA/C_FGCurrent;
-    
-	bm_print(BM_LOG_CRTI, "[fgauge_update_dod] FG_dod_1=%d, adjust_coulomb_counter=%d, gFG_columb=%d, gFG_DOD0=%d, gFG_temp=%d, gFG_BATT_CAPACITY=%d, C_0mA=%d, C_400mA=%d, C_FGCurrent=%d, gFG_current_AVG=%d\n", 
-		FG_dod_1, adjust_coulomb_counter, gFG_columb, gFG_DOD0, gFG_temp, gFG_BATT_CAPACITY, C_0mA, C_400mA, C_FGCurrent, gFG_current_AVG);
-#else
-	FG_dod_1 = gFG_DOD0 - ((gFG_columb * 100) / gFG_BATT_CAPACITY_aging);
-
-	bm_print(BM_LOG_FULL,
-		 "[fgauge_update_dod] FG_dod_1=%d, adjust_coulomb_counter=%d, gFG_columb=%d, gFG_DOD0=%d, gFG_temp=%d, gFG_BATT_CAPACITY=%d  %d\r\n",
-		 FG_dod_1, adjust_coulomb_counter, gFG_columb, gFG_DOD0, gFG_temp,
-		 gFG_BATT_CAPACITY,gFG_BATT_CAPACITY_aging);
-#endif
-	if (FG_dod_1 > 100) {
-		FG_dod_1 = 100;
-		bm_print(BM_LOG_FULL, "[fgauge_update_dod] FG_dod_1 set to 100, gFG_columb=%d\r\n",
-			 gFG_columb);
-	} else if (FG_dod_1 < 0) {
-		FG_dod_1 = 0;
-		bm_print(BM_LOG_FULL, "[fgauge_update_dod] FG_dod_1 set to 0, gFG_columb=%d\r\n",
-			 gFG_columb);
-	} else {
-	}
-
-	return FG_dod_1;
-}
-
-
-kal_int32 fgauge_read_capacity(kal_int32 type)
-{
-	kal_int32 voltage;
-	kal_int32 temperature;
-	kal_int32 dvalue = 0;
-	kal_int32 temp_val = 0;
-
-	if (type == 0)		/* for initialization */
-	{
-		/* Use voltage to calculate capacity */
-		voltage = battery_meter_get_battery_voltage(KAL_TRUE);	/* in unit of mV */
-		temperature = force_get_tbat(KAL_FALSE);
-		dvalue = fgauge_get_dod0(voltage, temperature, KAL_FALSE);	/* need compensate vbat */
-	} else {
-		/* Use DOD0 and columb counter to calculate capacity */
-		dvalue = fgauge_update_dod();	/* DOD1 = DOD0 + (-CAR)/Qmax */
-	}
-
-	gFG_DOD1 = dvalue;
-
-	temp_val = dvalue;
-	dvalue = 100 - temp_val;
-
-	if (dvalue <= 1) {
-		dvalue = 1;
-		bm_print(BM_LOG_FULL, "[fgauge_read_capacity] dvalue<=1 and set dvalue=1 !!\r\n");
-	}
-
-	return dvalue;
-}
-
-
-void fg_voltage_mode(void)
-{
-#if defined(CONFIG_POWER_EXT)
-#else
-	if (bat_is_charger_exist() == KAL_TRUE) {
-		/* SOC only UP when charging */
-		if (gFG_capacity_by_v > gfg_percent_check_point) {
-			gfg_percent_check_point++;
-		}
-	} else {
-		/* SOC only Done when dis-charging */
-		if (gFG_capacity_by_v < gfg_percent_check_point) {
-			gfg_percent_check_point--;
-		}
-	}
-
-	bm_print(BM_LOG_FULL,
-		 "[FGADC_VoltageMothod] gFG_capacity_by_v=%d,gfg_percent_check_point=%d\r\n",
-		 gFG_capacity_by_v, gfg_percent_check_point);
-#endif
-}
-
-
-void fgauge_algo_run(void)
-{
-	int i = 0;
-	int ret = 0;
-#ifdef MTK_BATTERY_LIFETIME_DATA_SUPPORT
-	int columb_delta = 0;
-	int charge_current = 0;
-#endif
-
-	/* Reconstruct table if temp changed; */
-	fgauge_construct_table_by_temp();
-
-/* 1. Get Raw Data */
-	ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_HW_FG_CURRENT, &gFG_current);
-	ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_HW_FG_CURRENT_SIGN, &gFG_Is_Charging);
-
-	gFG_voltage = battery_meter_get_battery_voltage(KAL_FALSE);
-	gFG_voltage_init = gFG_voltage;
-	gFG_voltage = gFG_voltage + fgauge_compensate_battery_voltage_recursion(gFG_voltage, 5);	/* mV */
-	gFG_voltage = gFG_voltage + OCV_BOARD_COMPESATE;
-
-#if defined(CUST_CAPACITY_OCV2CV_TRANSFORM)
-	fgauge_get_current_factor();
-#endif
-
-	ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_HW_FG_CAR, &gFG_columb);
-
-#ifdef MTK_BATTERY_LIFETIME_DATA_SUPPORT
-	if (gFG_Is_Charging) {
-		charge_current -= gFG_current;
-		if (charge_current < gFG_min_current)
-			gFG_min_current = charge_current;
-	} else {
-		if (gFG_current > gFG_max_current)
-			gFG_max_current = gFG_current;
-	}
-
-	columb_delta = gFG_pre_columb_count - gFG_columb;
-
-	if (columb_delta < 0)
-		columb_delta = columb_delta - 2 * columb_delta;	/* absolute value */
-
-	gFG_pre_columb_count = gFG_columb;
-	gFG_columb_sum += columb_delta;
-
-	/* should we use gFG_BATT_CAPACITY or gFG_BATT_CAPACITY_aging ?? */
-	if (gFG_columb_sum >= 2 * gFG_BATT_CAPACITY_aging) {
-		gFG_battery_cycle++;
-		gFG_columb_sum -= 2 * gFG_BATT_CAPACITY_aging;
-		bm_print(BM_LOG_CRTI, "Update battery cycle count to %d. \r\n", gFG_battery_cycle);
-	}
-	bm_print(BM_LOG_FULL, "@@@ bat cycle count %d, columb sum %d. \r\n", gFG_battery_cycle,
-		 gFG_columb_sum);
-#endif
-
-	// add by willcai 2014-12-18 begin 
-	if(BMT_status.charger_exist == KAL_FALSE) {
-		if(gFG_Is_offset_init == KAL_FALSE) {
-			for (i=0; i<FG_VBAT_AVERAGE_SIZE; i++) {
-				FGvbatVoltageBuffer[i] = gFG_voltage;            
-			}
-
-			FGbatteryVoltageSum = gFG_voltage * FG_VBAT_AVERAGE_SIZE;
-			gFG_voltage_AVG = gFG_voltage;
-			gFG_Is_offset_init = KAL_TRUE;
-		}
-/* 1.1 Average FG_voltage */
-    /**************** Averaging : START ****************/
-	if (gFG_voltage >= gFG_voltage_AVG) {
-		gFG_vbat_offset = (gFG_voltage - gFG_voltage_AVG);
-	} else {
-		gFG_vbat_offset = (gFG_voltage_AVG - gFG_voltage);
-	}
-
-	if (gFG_vbat_offset <= MinErrorOffset) {
-		FGbatteryVoltageSum -= FGvbatVoltageBuffer[FGbatteryIndex];
-		FGbatteryVoltageSum += gFG_voltage;
-		FGvbatVoltageBuffer[FGbatteryIndex] = gFG_voltage;
-
-		gFG_voltage_AVG = FGbatteryVoltageSum / FG_VBAT_AVERAGE_SIZE;
-		gFG_voltage = gFG_voltage_AVG;
-
-		FGbatteryIndex++;
-		if (FGbatteryIndex >= FG_VBAT_AVERAGE_SIZE)
-			FGbatteryIndex = 0;
-
-		bm_print(BM_LOG_FULL, "[FG_BUFFER] ");
-		for (i = 0; i < FG_VBAT_AVERAGE_SIZE; i++) {
-			bm_print(BM_LOG_FULL, "%d,", FGvbatVoltageBuffer[i]);
-		}
-		bm_print(BM_LOG_FULL, "\r\n");
-	} else {
-		bm_print(BM_LOG_FULL, "[FG] Over MinErrorOffset:V=%d,Avg_V=%d, ", gFG_voltage,
-			 gFG_voltage_AVG);
-
-		gFG_voltage = gFG_voltage_AVG;
-
-		bm_print(BM_LOG_FULL, "Avg_V need write back to V : V=%d,Avg_V=%d.\r\n",
-			 gFG_voltage, gFG_voltage_AVG);
-	}
-	} else  {
-		gFG_Is_offset_init = KAL_FALSE;
-	}
-#ifdef Q_MAX_BY_CURRENT
-/* 1.2 Average FG_current */
-    /**************** Averaging : START ****************/
-	if (gFG_current_AVG == 0) {
-		for (i=0; i<FG_CURRENT_AVERAGE_SIZE; i++) {
-			FGCurrentBuffer[i] = gFG_current;            
-		}
-		
-		FGCurrentSum = gFG_current * FG_CURRENT_AVERAGE_SIZE;
-		gFG_current_AVG = gFG_current;
-	} else {
-		FGCurrentSum -= FGCurrentBuffer[FGCurrentIndex];
-		FGCurrentSum += gFG_current;
-		FGCurrentBuffer[FGCurrentIndex] = gFG_current;
-		
-		gFG_current_AVG = FGCurrentSum / FG_CURRENT_AVERAGE_SIZE;
-		
-		FGCurrentIndex++;
-		if (FGCurrentIndex >= FG_CURRENT_AVERAGE_SIZE)
-			FGCurrentIndex = 0;
-
-		bm_print(BM_LOG_FULL, "[FG_BUFFER] ");
-		for (i=0; i<FG_CURRENT_AVERAGE_SIZE; i++) {
-			bm_print(BM_LOG_FULL, "%d,", FGCurrentBuffer[i]);          
-		}
-		bm_print(BM_LOG_FULL, "\n");
-	}
-#endif
-/* 2. Calculate battery capacity by VBAT */
-	gFG_capacity_by_v = fgauge_read_capacity_by_v(gFG_voltage);
-
-/* 3. Calculate battery capacity by Coulomb Counter */
-	gFG_capacity_by_c = fgauge_read_capacity(1);
-
-/* 4. voltage mode */
-	if (volt_mode_update_timer >= volt_mode_update_time_out) {
-		volt_mode_update_timer = 0;
-
-		fg_voltage_mode();
-	} else {
-		volt_mode_update_timer++;
-	}
-
-/* 5. Logging */
-	bm_print(BM_LOG_CRTI,
-		 "[FGADC] %d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d\r\n",
-		 gFG_Is_Charging, gFG_current, gFG_columb, gFG_voltage, gFG_capacity_by_v,
-		 gFG_capacity_by_c, gFG_capacity_by_c_init, gFG_BATT_CAPACITY,
-		 gFG_BATT_CAPACITY_aging, gFG_compensate_value, gFG_ori_voltage,
-		 OCV_BOARD_COMPESATE, R_FG_BOARD_SLOPE, gFG_voltage_init, MinErrorOffset, gFG_DOD0,
-		 gFG_DOD1, CAR_TUNE_VALUE, AGING_TUNING_VALUE);
-	update_fg_dbg_tool_value();
-}
-
-void fgauge_algo_run_init(void)
-{
-	int i = 0;
-	int ret = 0;
-
-#ifdef INIT_SOC_BY_SW_SOC
-	kal_bool charging_enable = KAL_FALSE;
-#if defined (CONFIG_MTK_KERNEL_POWER_OFF_CHARGING) && !defined(SWCHR_POWER_PATH)
-	if(LOW_POWER_OFF_CHARGING_BOOT != g_boot_mode)
-#endif
-		/*stop charging for vbat measurement*/
-		battery_charging_control(CHARGING_CMD_ENABLE,&charging_enable);
-	
-	msleep(50);
-#endif
-/* 1. Get Raw Data */
-	gFG_voltage = battery_meter_get_battery_voltage(KAL_TRUE);
-	gFG_voltage_init = gFG_voltage;	
-	ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_HW_FG_CURRENT, &gFG_current);
-	ret=battery_meter_ctrl(BATTERY_METER_CMD_GET_HW_FG_CURRENT_SIGN, &gFG_Is_Charging);
-
-	gFG_voltage = gFG_voltage + fgauge_compensate_battery_voltage_recursion(gFG_voltage, 5);	/* mV */
-	gFG_voltage = gFG_voltage + OCV_BOARD_COMPESATE;
-
-	bm_print(BM_LOG_CRTI, "[FGADC] SWOCV : %d,%d,%d,%d,%d,%d\n",
-		 gFG_voltage_init, gFG_voltage, gFG_current, gFG_Is_Charging, gFG_resistance_bat,
-		 gFG_compensate_value);
-#ifdef INIT_SOC_BY_SW_SOC
-	charging_enable = KAL_TRUE;
-	battery_charging_control(CHARGING_CMD_ENABLE,&charging_enable);
-#endif
-	ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_HW_FG_CAR, &gFG_columb);
-
-/* 1.1 Average FG_voltage */
-	for (i = 0; i < FG_VBAT_AVERAGE_SIZE; i++) {
-		FGvbatVoltageBuffer[i] = gFG_voltage;
-	}
-
-	FGbatteryVoltageSum = gFG_voltage * FG_VBAT_AVERAGE_SIZE;
-	gFG_voltage_AVG = gFG_voltage;
-
-#ifdef Q_MAX_BY_CURRENT
-/* 1.2 Average FG_current */
-	for (i=0; i<FG_CURRENT_AVERAGE_SIZE; i++) {
-		FGCurrentBuffer[i] = gFG_current;            
-	}
-	
-	FGCurrentSum = gFG_current * FG_CURRENT_AVERAGE_SIZE;
-	gFG_current_AVG = gFG_current;
-#endif
-
-/* 2. Calculate battery capacity by VBAT */
-	gFG_capacity_by_v = fgauge_read_capacity_by_v(gFG_voltage);
-	gFG_capacity_by_v_init = gFG_capacity_by_v;
-
-/* 3. Calculate battery capacity by Coulomb Counter */
-	gFG_capacity_by_c = fgauge_read_capacity(1);
-
-/* 4. update DOD0 */
-
-	dod_init();
-
-	gFG_current_auto_detect_R_fg_count = 0;
-
-	for (i = 0; i < 10; i++) {
-		ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_HW_FG_CURRENT, &gFG_current);
-
-		gFG_current_auto_detect_R_fg_total += gFG_current;
-		gFG_current_auto_detect_R_fg_count++;
-	}
-
-	/* double check */
-	if (gFG_current_auto_detect_R_fg_total <= 0) {
-		bm_print(BM_LOG_CRTI, "gFG_current_auto_detect_R_fg_total=0, need double check\n");
-
-		gFG_current_auto_detect_R_fg_count = 0;
-
-		for (i = 0; i < 10; i++) {
-			ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_HW_FG_CURRENT, &gFG_current);
-
-			gFG_current_auto_detect_R_fg_total += gFG_current;
-			gFG_current_auto_detect_R_fg_count++;
-		}
-	}
-
-	gFG_current_auto_detect_R_fg_result =
-	    gFG_current_auto_detect_R_fg_total / gFG_current_auto_detect_R_fg_count;
-#if !defined(DISABLE_RFG_EXIST_CHECK)
-	if (gFG_current_auto_detect_R_fg_result <= CURRENT_DETECT_R_FG) {
-		g_auxadc_solution = 1;
-
-		bm_print(BM_LOG_CRTI,
-			 "[FGADC] Detect NO Rfg, use AUXADC report. (%d=%d/%d)(%d)\r\n",
-			 gFG_current_auto_detect_R_fg_result, gFG_current_auto_detect_R_fg_total,
-			 gFG_current_auto_detect_R_fg_count, g_auxadc_solution);
-	} else {
-		if (g_auxadc_solution == 0) {
-			g_auxadc_solution = 0;
-
-			bm_print(BM_LOG_CRTI,
-				 "[FGADC] Detect Rfg, use FG report. (%d=%d/%d)(%d)\r\n",
-				 gFG_current_auto_detect_R_fg_result,
-				 gFG_current_auto_detect_R_fg_total,
-				 gFG_current_auto_detect_R_fg_count, g_auxadc_solution);
-		} else {
-			bm_print(BM_LOG_CRTI,
-				 "[FGADC] Detect Rfg, but use AUXADC report. due to g_auxadc_solution=%d \r\n",
-				 g_auxadc_solution);
-		}
-	}
-#endif
-/* 5. Logging */
-	bm_print(BM_LOG_CRTI,
-		 "[FGADC] %d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d\r\n",
-		 gFG_Is_Charging, gFG_current, gFG_columb, gFG_voltage, gFG_capacity_by_v,
-		 gFG_capacity_by_c, gFG_capacity_by_c_init, gFG_BATT_CAPACITY,
-		 gFG_BATT_CAPACITY_aging, gFG_compensate_value, gFG_ori_voltage,
-		 OCV_BOARD_COMPESATE, R_FG_BOARD_SLOPE, gFG_voltage_init, MinErrorOffset, gFG_DOD0,
-		 gFG_DOD1, CAR_TUNE_VALUE, AGING_TUNING_VALUE);
-	update_fg_dbg_tool_value();
-}
-
-
-#ifdef FG_BAT_INT
-kal_uint8 reset_fg_bat_int=KAL_TRUE;
-void fg_bat_int_handler(void)
-{
-	reset_fg_bat_int=KAL_TRUE;
-	wake_up_bat2();
-}
-#endif
-
-void fgauge_initialization(void)
-{
-#if defined(CONFIG_POWER_EXT)
-#else
-	int i = 0;
-	kal_uint32 ret = 0;
-
-	/* gFG_BATT_CAPACITY_init_high_current = fgauge_get_Q_max_high_current(25); */
-	/* gFG_BATT_CAPACITY_aging = fgauge_get_Q_max(25); */
-
-	/* 1. HW initialization */
-	ret = battery_meter_ctrl(BATTERY_METER_CMD_HW_FG_INIT, NULL);
-
-	/* 2. SW algorithm initialization */
-	ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_HW_OCV, &gFG_voltage);
-
-	ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_HW_FG_CURRENT, &gFG_current);
-	i = 0;
-	while (gFG_current == 0) {
-		ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_HW_FG_CURRENT, &gFG_current);
-		if (i > 10) {
-			bm_print(BM_LOG_CRTI, "[fgauge_initialization] gFG_current == 0\n");
-			break;
-		}
-		i++;
-	}
-
-	ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_HW_FG_CAR, &gFG_columb);
-	#if !defined(CUST_CAPACITY_OCV2CV_TRANSFORM)
-	fgauge_construct_battery_profile_init();
-	#endif
-	gFG_temp = force_get_tbat(KAL_FALSE);
-	gFG_capacity = fgauge_read_capacity(0);
-
-	gFG_capacity_by_c_init = gFG_capacity;
-	gFG_capacity_by_c = gFG_capacity;
-	gFG_capacity_by_v = gFG_capacity;
-
-	gFG_DOD0 = 100 - gFG_capacity;
-	bm_print(BM_LOG_CRTI, "[fgauge_initialization] gFG_DOD0 =%d %d \n",gFG_DOD0,gFG_capacity);
-
-	gFG_BATT_CAPACITY = fgauge_get_Q_max(gFG_temp);
-
-	gFG_BATT_CAPACITY_init_high_current = fgauge_get_Q_max_high_current(gFG_temp);
-	gFG_BATT_CAPACITY_aging = fgauge_get_Q_max(gFG_temp);
-
-	ret = battery_meter_ctrl(BATTERY_METER_CMD_DUMP_REGISTER, NULL);
-
-	bm_print(BM_LOG_CRTI, "[fgauge_initialization] Done HW_OCV:%d FG_Current:%d FG_CAR:%d tmp=%d capacity=%d Qmax=%d\n",
-		gFG_voltage,gFG_current,gFG_columb,gFG_temp,gFG_capacity,gFG_BATT_CAPACITY);
-
-#if defined(FG_BAT_INT)
-	pmic_register_interrupt_callback(41,fg_bat_int_handler);
-	pmic_register_interrupt_callback(40,fg_bat_int_handler);
-#endif 
-#endif
-}
-#endif
-
-kal_int32 get_dynamic_period(int first_use, int first_wakeup_time, int battery_capacity_level)
-{
-#if defined(CONFIG_POWER_EXT)
-
-	return first_wakeup_time;
-
-#elif defined(SOC_BY_AUXADC) ||  defined(SOC_BY_SW_FG)
-
-	kal_int32 vbat_val = 0;
-
-#ifdef CONFIG_MTK_POWER_EXT_DETECT
-	if (KAL_TRUE == bat_is_ext_power())
-		return NORMAL_WAKEUP_PERIOD;
-#endif
-
-	vbat_val = g_sw_vbat_temp;
-
-	/* change wake up period when system suspend. */
-	if (vbat_val > VBAT_NORMAL_WAKEUP)	/* 3.6v */
-		g_spm_timer = NORMAL_WAKEUP_PERIOD;	/* 90 min */
-	else if (vbat_val > VBAT_LOW_POWER_WAKEUP)	/* 3.5v */
-		g_spm_timer = LOW_POWER_WAKEUP_PERIOD;	/* 5 min */
-	else
-		g_spm_timer = CLOSE_POWEROFF_WAKEUP_PERIOD;	/* 0.5 min */
-
-
-
-	bm_print(BM_LOG_CRTI, "vbat_val=%d, g_spm_timer=%d\n", vbat_val, g_spm_timer);
-
-	return g_spm_timer;
-#else
-
-	kal_int32 car_instant = 0;
-	kal_int32 current_instant = 0;
-	static kal_int32 car_sleep=0x12345678;
-	kal_int32 car_wakeup = 0;
-	static kal_int32 last_time=0;
-
-	kal_int32 ret_val = -1;
-	int check_fglog = 0;
-	kal_int32 I_sleep = 0;
-	kal_int32 new_time = 0;
-	kal_int32 vbat_val = 0;
-	int ret = 0;
-
-	check_fglog = Enable_FGADC_LOG;
-	if (check_fglog == 0) {
-		/* Enable_FGADC_LOG=1; */
-	}
-
-
-	vbat_val = g_sw_vbat_temp;
-
-	ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_HW_FG_CURRENT, &current_instant);
-
-	ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_HW_FG_CAR, &car_instant);
-
-	if (check_fglog == 0) {
-		/* Enable_FGADC_LOG=0; */
-	}
-	if (car_instant < 0) {
-		car_instant = car_instant - (car_instant * 2);
-	}
-
-	if (vbat_val > VBAT_NORMAL_WAKEUP)	/* 3.6v */
-	{
-		car_wakeup = car_instant;
-
-		if (last_time == 0)
-			last_time = 1;
-
-		if (car_sleep > car_wakeup || car_sleep == 0x12345678) {
-			car_sleep = car_wakeup;
-			bm_print(BM_LOG_CRTI, "[get_dynamic_period] reset car_sleep\n");
-		}
-
-		I_sleep = ((car_wakeup - car_sleep) * 3600) / last_time;	/* unit: second */
-
-		if (I_sleep == 0) {
-			if (check_fglog == 0) {
-				/* Enable_FGADC_LOG=1; */
-			}
-
-			ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_HW_FG_CURRENT, &I_sleep);
-
-			I_sleep = I_sleep / 10;
-			if (check_fglog == 0) {
-				/* Enable_FGADC_LOG=0; */
-			}
-		}
-
-		if (I_sleep == 0) {
-			new_time = first_wakeup_time;
-		} else {
-			new_time =
-			    ((gFG_BATT_CAPACITY * battery_capacity_level * 3600) / 100) / I_sleep;
-		}
-		ret_val = new_time;
-
-		if (ret_val == 0)
-			ret_val = first_wakeup_time;
-
-		bm_print(BM_LOG_CRTI,
-			 "[get_dynamic_period] car_instant=%d, car_wakeup=%d, car_sleep=%d, I_sleep=%d, gFG_BATT_CAPACITY=%d, last_time=%d, new_time=%d\r\n",
-			 car_instant, car_wakeup, car_sleep, I_sleep, gFG_BATT_CAPACITY, last_time,
-			 new_time);
-
-		/* update parameter */
-		car_sleep = car_wakeup;
-		last_time = ret_val;
-		g_spm_timer = ret_val;
-	} else if (vbat_val > VBAT_LOW_POWER_WAKEUP) {	/* 3.5v */
-		g_spm_timer = LOW_POWER_WAKEUP_PERIOD;	/* 5 min */
-	} else {
-		g_spm_timer = CLOSE_POWEROFF_WAKEUP_PERIOD;	/* 0.5 min */
-	}
-
-	bm_print(BM_LOG_CRTI, "vbat_val=%d, g_spm_timer=%d\n", vbat_val, g_spm_timer);
-	return g_spm_timer;
-
-#endif
-}
-
-/* ============================================================ // */
-kal_int32 battery_meter_get_battery_voltage(kal_bool update)
-{
-	int ret = 0;
-	int val = 5;
-	static int pre_val = -1;
-
-	if (update == KAL_TRUE || pre_val == -1) {
-		val = 5;		/* set avg times */
-		ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_ADC_V_BAT_SENSE, &val);
-		pre_val = val;
-	} else {
-		val = pre_val;
-	}
-	g_sw_vbat_temp = val;
-
-#ifdef MTK_BATTERY_LIFETIME_DATA_SUPPORT
-	if (g_sw_vbat_temp > gFG_max_voltage) {
-		gFG_max_voltage = g_sw_vbat_temp;
-	}
-
-	if (g_sw_vbat_temp < gFG_min_voltage) {
-		gFG_min_voltage = g_sw_vbat_temp;
-	}
-#endif
-
-	return val;
-}
-
-kal_int32 battery_meter_get_charging_current_imm(void)
-{
-#ifdef AUXADC_SUPPORT_IMM_CURRENT_MODE
-	return PMIC_IMM_GetCurrent();
-#else
-	 int ret;
-	 kal_int32 ADC_I_SENSE=1;   // 1 measure time
-	 kal_int32 ADC_BAT_SENSE=1;	// 1 measure time
- 	 int ICharging=0;
-
-	 ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_ADC_V_BAT_SENSE, &ADC_BAT_SENSE);
- 	 ret =  battery_meter_ctrl(BATTERY_METER_CMD_GET_ADC_V_I_SENSE, &ADC_I_SENSE);
-
-	 ICharging = (ADC_I_SENSE - ADC_BAT_SENSE + g_I_SENSE_offset)*1000/CUST_R_SENSE;
-	 return ICharging;	
-#endif
-}
-
-kal_int32 battery_meter_get_charging_current(void)
-{
-#ifdef DISABLE_CHARGING_CURRENT_MEASURE
-	return 0;
-#elif !defined (EXTERNAL_SWCHR_SUPPORT)
-	kal_int32 ADC_BAT_SENSE_tmp[20] =
-	    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
-	kal_int32 ADC_BAT_SENSE_sum = 0;
-	kal_int32 ADC_BAT_SENSE = 0;
-	kal_int32 ADC_I_SENSE_tmp[20] =
-	    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
-	kal_int32 ADC_I_SENSE_sum = 0;
-	kal_int32 ADC_I_SENSE = 0;
-	int repeat = 20;
-	int i = 0;
-	int j = 0;
-	kal_int32 temp = 0;
-	int ICharging = 0;
-	int ret = 0;
-	int val = 1;
-
-	for (i = 0; i < repeat; i++) {
-		val = 1;	/* set avg times */
-		ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_ADC_V_BAT_SENSE, &val);
-		ADC_BAT_SENSE_tmp[i] = val;
-
-		val = 1;	/* set avg times */
-		ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_ADC_V_I_SENSE, &val);
-		ADC_I_SENSE_tmp[i] = val;
-
-		ADC_BAT_SENSE_sum += ADC_BAT_SENSE_tmp[i];
-		ADC_I_SENSE_sum += ADC_I_SENSE_tmp[i];
-	}
-
-	/* sorting    BAT_SENSE */
-	for (i = 0; i < repeat; i++) {
-		for (j = i; j < repeat; j++) {
-			if (ADC_BAT_SENSE_tmp[j] < ADC_BAT_SENSE_tmp[i]) {
-				temp = ADC_BAT_SENSE_tmp[j];
-				ADC_BAT_SENSE_tmp[j] = ADC_BAT_SENSE_tmp[i];
-				ADC_BAT_SENSE_tmp[i] = temp;
-			}
-		}
-	}
-
-	bm_print(BM_LOG_FULL, "[g_Get_I_Charging:BAT_SENSE]\r\n");
-	for (i = 0; i < repeat; i++) {
-		bm_print(BM_LOG_FULL, "%d,", ADC_BAT_SENSE_tmp[i]);
-	}
-	bm_print(BM_LOG_FULL, "\r\n");
-
-	/* sorting    I_SENSE */
-	for (i = 0; i < repeat; i++) {
-		for (j = i; j < repeat; j++) {
-			if (ADC_I_SENSE_tmp[j] < ADC_I_SENSE_tmp[i]) {
-				temp = ADC_I_SENSE_tmp[j];
-				ADC_I_SENSE_tmp[j] = ADC_I_SENSE_tmp[i];
-				ADC_I_SENSE_tmp[i] = temp;
-			}
-		}
-	}
-
-	bm_print(BM_LOG_FULL, "[g_Get_I_Charging:I_SENSE]\r\n");
-	for (i = 0; i < repeat; i++) {
-		bm_print(BM_LOG_FULL, "%d,", ADC_I_SENSE_tmp[i]);
-	}
-	bm_print(BM_LOG_FULL, "\r\n");
-
-	ADC_BAT_SENSE_sum -= ADC_BAT_SENSE_tmp[0];
-	ADC_BAT_SENSE_sum -= ADC_BAT_SENSE_tmp[1];
-	ADC_BAT_SENSE_sum -= ADC_BAT_SENSE_tmp[18];
-	ADC_BAT_SENSE_sum -= ADC_BAT_SENSE_tmp[19];
-	ADC_BAT_SENSE = ADC_BAT_SENSE_sum / (repeat - 4);
-
-	bm_print(BM_LOG_FULL, "[g_Get_I_Charging] ADC_BAT_SENSE=%d\r\n", ADC_BAT_SENSE);
-
-	ADC_I_SENSE_sum -= ADC_I_SENSE_tmp[0];
-	ADC_I_SENSE_sum -= ADC_I_SENSE_tmp[1];
-	ADC_I_SENSE_sum -= ADC_I_SENSE_tmp[18];
-	ADC_I_SENSE_sum -= ADC_I_SENSE_tmp[19];
-	ADC_I_SENSE = ADC_I_SENSE_sum / (repeat - 4);
-
-	bm_print(BM_LOG_FULL, "[g_Get_I_Charging] ADC_I_SENSE(Before)=%d\r\n", ADC_I_SENSE);
-
-
-	bm_print(BM_LOG_FULL, "[g_Get_I_Charging] ADC_I_SENSE(After)=%d\r\n", ADC_I_SENSE);
-
-	if (ADC_I_SENSE > ADC_BAT_SENSE) {
-		ICharging = (ADC_I_SENSE - ADC_BAT_SENSE + g_I_SENSE_offset) * 1000 / CUST_R_SENSE;
-	} else {
-		ICharging = 0;
-	}
-
-	return ICharging;
-#else
-    return 0;
-#endif
-}
-
-kal_int32 battery_meter_get_battery_current(void)
-{
-	int ret = 0;
-	kal_int32 val = 0;
-
-	if (g_auxadc_solution == 1)
-		val = oam_i_2;
-	else
-		ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_HW_FG_CURRENT, &val);
-
-	return val;
-}
-
-kal_bool battery_meter_get_battery_current_sign(void)
-{
-	int ret = 0;
-	kal_bool val = 0;
-
-	if (g_auxadc_solution == 1)
-		val = 0;	/* discharging */
-	else
-		ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_HW_FG_CURRENT_SIGN, &val);
-
-	return val;
-}
-
-kal_int32 battery_meter_get_car(void)
-{
-	int ret = 0;
-	kal_int32 val = 0;
-
-	if (g_auxadc_solution == 1)
-		val = oam_car_2;
-	else
-		ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_HW_FG_CAR, &val);
-
-	return val;
-}
-
-kal_int32 battery_meter_get_battery_temperature(void)
-{
-#ifdef MTK_BATTERY_LIFETIME_DATA_SUPPORT
-	kal_int32 batt_temp = force_get_tbat(KAL_TRUE);
-
-	if (batt_temp > gFG_max_temperature)
-		gFG_max_temperature = batt_temp;
-	if (batt_temp < gFG_min_temperature)
-		gFG_min_temperature = batt_temp;
-
-	return batt_temp;
-#else
-	return force_get_tbat(KAL_TRUE);
-#endif
-}
-
-kal_int32 battery_meter_get_charger_voltage(void)
-{
-	int ret = 0;
-	int val = 0;
-
-	val = 5;		/* set avg times */
-	ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_ADC_V_CHARGER, &val);
-
-	/* val = (((R_CHARGER_1+R_CHARGER_2)*100*val)/R_CHARGER_2)/100; */
-	return val;
-}
-
-#if defined(CUST_CAPACITY_OCV2CV_TRANSFORM)
-void battery_meter_set_reset_soc(kal_bool bUSE_UI_SOC)
-{
-	g_USE_UI_SOC = bUSE_UI_SOC;
-}
-
-kal_int32 battery_meter_get_battery_soc(void)
-{
-#if defined(SOC_BY_HW_FG)
-	return gFG_capacity_by_c;
-#else
-	return 50;
-#endif
-
-#if defined(SOC_BY_SW_FG)
-	#if (OAM_D5 == 1)
-		return (100-oam_d_5);
-	#else
-		return (100-oam_d_2);
-	#endif
-#else
-	return 50;
-#endif
-}
-
-/* Here we compensate D1 by a factor from Qmax with loading. */
-kal_int32 battery_meter_trans_battery_percentage(kal_bool d_val)
-{
-	kal_int32 d_val_before = 0;
-	kal_int32 temp_val = 0;
-	kal_int32 C_0mA = 0;
-	kal_int32 C_600mA = 0;
-	kal_int32 C_current = 0;
-	kal_int32 i_avg_current = 0;
-
-	d_val_before = d_val;
-	temp_val = battery_meter_get_battery_temperature();
-	C_0mA = fgauge_get_Q_max(temp_val);
-
-	/* discharging and current > 600ma */
-	i_avg_current = g_currentfactor * CV_CURRENT / 100;
-	if (KAL_FALSE == gFG_Is_Charging && g_currentfactor > 100) {
-		C_600mA = fgauge_get_Q_max_high_current(temp_val);
-		C_current = fgauge_get_Q_max_high_current_by_current(i_avg_current, temp_val);
-		if (C_current < C_600mA)
-			C_600mA = C_current;
-	} else
-		C_600mA = fgauge_get_Q_max_high_current(temp_val);
-
-	if (C_0mA > C_600mA)
-		d_val = d_val + (((C_0mA - C_600mA) * (d_val)) / C_600mA);
-
-	if (d_val > 100)
-		d_val = 100;
-
-	bm_print(BM_LOG_CRTI, "[battery_meter_trans_battery_percentage] %d,%d,%d,%d,%d,%d\r\n",
-		 temp_val, C_0mA, C_600mA, d_val_before, d_val, g_currentfactor);
-
-	return d_val;
-}
-#endif
-
-#if defined(FG_BAT_INT)
-kal_int32 battery_meter_set_columb_interrupt(kal_uint32 val)
-{
-	battery_log(BAT_LOG_FULL, "battery_meter_set_columb_interrupt=%d \n",val);
-	battery_meter_ctrl(BATTERY_METER_CMD_SET_COLUMB_INTERRUPT, &val);
-}
-#endif //#if defined(FG_BAT_INT)
-
-kal_int32 battery_meter_get_battery_percentage(void)
-{
-#if defined(CONFIG_POWER_EXT)
-	return 50;
-#else
-
-	if (bat_is_charger_exist() == KAL_FALSE)
-		fg_qmax_update_for_aging_flag = 1;
-
-#if defined(SOC_BY_AUXADC)
-	return auxadc_algo_run();
-#endif
-
-#if defined(SOC_BY_HW_FG)
-	if (g_auxadc_solution == 1) {
-		return auxadc_algo_run();
-	} else {
-		fgauge_algo_run();
-		#if !defined(CUST_CAPACITY_OCV2CV_TRANSFORM)
-		return gFG_capacity_by_c;	/* hw fg, //return gfg_percent_check_point; // voltage mode */
-		#else
-		/* We keep gFG_capacity_by_c as capacity before compensation */
-		/* Compensated capacity is returned for UI SOC tracking */
-		return 100 - battery_meter_trans_battery_percentage(100 - gFG_capacity_by_c);
-		#endif
-	}
-#endif
-
-#if defined(SOC_BY_SW_FG)
-	oam_run();
-#if !defined(CUST_CAPACITY_OCV2CV_TRANSFORM)
-#if (OAM_D5 == 1)
-	return (100 - oam_d_5);
-#else
-	return (100 - oam_d_2);
-#endif
-#else
-	#if (OAM_D5 == 1)
-	return (100-battery_meter_trans_battery_percentage(oam_d_5));
-	#else
-	return (100-battery_meter_trans_battery_percentage(oam_d_2));
-	#endif
-#endif
-#endif
-
-#endif
-}
-
-
-kal_int32 battery_meter_initial(void)
-{
-#if defined(CONFIG_POWER_EXT)
-	return 0;
-#else
-	static kal_bool meter_initilized = KAL_FALSE;
-
-	mutex_lock(&FGADC_mutex);
-	if (meter_initilized == KAL_FALSE) {
-#ifdef MTK_MULTI_BAT_PROFILE_SUPPORT
-		fgauge_get_profile_id();
-#endif
-
-#if defined(SOC_BY_AUXADC)
-		g_auxadc_solution = 1;
-		table_init();
-		bm_print(BM_LOG_CRTI, "[battery_meter_initial] SOC_BY_AUXADC done\n");
-#endif
-
-#if defined(SOC_BY_HW_FG)
-		fgauge_initialization();
-		fgauge_algo_run_init();
-		bm_print(BM_LOG_CRTI, "[battery_meter_initial] SOC_BY_HW_FG done\n");
-#endif
-
-#if defined(SOC_BY_SW_FG)
-		g_auxadc_solution = 1;
-		table_init();
-		oam_init();
-		bm_print(BM_LOG_CRTI, "[battery_meter_initial] SOC_BY_SW_FG done\n");
-#endif
-
-		meter_initilized = KAL_TRUE;
-	}
-	mutex_unlock(&FGADC_mutex);
-	return 0;
-#endif
-}
-
-void reset_parameter_car(void)
-{
-#if defined(SOC_BY_HW_FG)
-	int ret = 0;
-	ret = battery_meter_ctrl(BATTERY_METER_CMD_HW_RESET, NULL);
-	gFG_columb = 0;
-
-#ifdef MTK_BATTERY_LIFETIME_DATA_SUPPORT
-	gFG_pre_columb_count = 0;
-#endif
-
-#ifdef MTK_ENABLE_AGING_ALGORITHM
-	aging_ocv_1 = 0;
-	aging_ocv_2 = 0;
-#ifdef MD_SLEEP_CURRENT_CHECK
-	columb_before_sleep = 0x123456;
-#endif
-#endif
-
-#endif
-
-#if defined(SOC_BY_SW_FG)
-	oam_car_1 = 0;
-	oam_car_2 = 0;
-	gFG_columb = 0;
-#endif
-}
-
-void reset_parameter_dod_change(void)
-{
-#if defined(SOC_BY_HW_FG)
-	bm_print(BM_LOG_CRTI, "[FGADC] Update DOD0(%d) by %d \r\n", gFG_DOD0, gFG_DOD1);
-	gFG_DOD0 = gFG_DOD1;
-#endif
-
-#if defined(SOC_BY_SW_FG)
-	bm_print(BM_LOG_CRTI, "[FGADC] Update oam_d0(%d) by %d \r\n", oam_d0, oam_d_5);
-	oam_d0 = oam_d_5;
-	gFG_DOD0 = oam_d0;
-	oam_d_1 = oam_d_5;
-	oam_d_2 = oam_d_5;
-	oam_d_3 = oam_d_5;
-	oam_d_4 = oam_d_5;
-#endif
-}
-
-void reset_parameter_dod_full(kal_uint32 ui_percentage)
-{
-#if defined(SOC_BY_HW_FG)
-	bm_print(BM_LOG_CRTI, "[battery_meter_reset]1 DOD0=%d,DOD1=%d,ui=%d\n", gFG_DOD0, gFG_DOD1,
-		 ui_percentage);
-	gFG_DOD0 = 100 - ui_percentage;
-	gFG_DOD1 = gFG_DOD0;
-	bm_print(BM_LOG_CRTI, "[battery_meter_reset]2 DOD0=%d,DOD1=%d,ui=%d\n", gFG_DOD0, gFG_DOD1,
-		 ui_percentage);
-#endif
-
-#if defined(SOC_BY_SW_FG)
-	bm_print(BM_LOG_CRTI, "[battery_meter_reset]1 oam_d0=%d,oam_d_5=%d,ui=%d\n", oam_d0,
-		 oam_d_5, ui_percentage);
-	oam_d0 = 100 - ui_percentage;
-	gFG_DOD0 = oam_d0;
-	gFG_DOD1 = oam_d0;
-	oam_d_1 = oam_d0;
-	oam_d_2 = oam_d0;
-	oam_d_3 = oam_d0;
-	oam_d_4 = oam_d0;
-	oam_d_5 = oam_d0;
-	bm_print(BM_LOG_CRTI, "[battery_meter_reset]2 oam_d0=%d,oam_d_5=%d,ui=%d\n", oam_d0,
-		 oam_d_5, ui_percentage);
-#endif
-}
-
-kal_int32 battery_meter_reset(void)
-{
-#if defined(CONFIG_POWER_EXT)
-	return 0;
-#else
-	kal_uint32 ui_percentage = bat_get_ui_percentage();
-
-#if defined(CUST_CAPACITY_OCV2CV_TRANSFORM)
-	if (KAL_FALSE == g_USE_UI_SOC) {
-		ui_percentage = battery_meter_get_battery_soc();
-		g_USE_UI_SOC = KAL_TRUE;
-		bm_print(BM_LOG_FULL, "[CUST_CAPACITY_OCV2CV_TRANSFORM]Use Battery SOC: %d\n",
-			 ui_percentage);
-	}
-#endif
-
-	reset_parameter_car();
-	reset_parameter_dod_full(ui_percentage);
-
-	return 0;
-#endif
-}
-
-kal_int32 battery_meter_sync(kal_int32 bat_i_sense_offset)
-{
-#if defined(CONFIG_POWER_EXT)
-	return 0;
-#else
-	g_I_SENSE_offset = bat_i_sense_offset;
-	return 0;
-#endif
-}
-
-kal_int32 battery_meter_get_battery_zcv(void)
-{
-#if defined(CONFIG_POWER_EXT)
-	return 3987;
-#else
-	return gFG_voltage;
-#endif
-}
-
-kal_int32 battery_meter_get_battery_nPercent_zcv(void)
-{
-#if defined(CONFIG_POWER_EXT)
-	return 3700;
-#else
-	return gFG_15_vlot;	/* 15% zcv,  15% can be customized by 100-g_tracking_point */
-#endif
-}
-
-kal_int32 battery_meter_get_battery_nPercent_UI_SOC(void)
-{
-#if defined(CONFIG_POWER_EXT)
-	return 15;
-#else
-	return g_tracking_point;	/* tracking point */
-#endif
-}
-
-kal_int32 battery_meter_get_tempR(kal_int32 dwVolt)
-{
-#if defined(CONFIG_POWER_EXT)
-	return 0;
-#else
-	int TRes;
-
-	TRes = (RBAT_PULL_UP_R * dwVolt) / (RBAT_PULL_UP_VOLT - dwVolt);
-
-	return TRes;
-#endif
-}
-
-kal_int32 battery_meter_get_tempV(void)
-{
-#if defined(CONFIG_POWER_EXT)
-	return 0;
-#else
-	int ret = 0;
-	int val = 0;
-
-	val = 1;		/* set avg times */
-	ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_ADC_V_BAT_TEMP, &val);
-	return val;
-#endif
-}
-
-kal_int32 battery_meter_get_VSense(void)
-{
-#if defined(CONFIG_POWER_EXT)
-	return 0;
-#else
-	int ret = 0;
-	int val = 0;
-
-	val = 1;		/* set avg times */
-	ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_ADC_V_I_SENSE, &val);
-	return val;
-#endif
-}
-
-/* ============================================================ // */
-static ssize_t fgadc_log_write(struct file *filp, const char __user *buff,
-			       size_t len, loff_t *data)
-{
-	if (copy_from_user(&proc_fgadc_data, buff, len)) {
-		bm_print(BM_LOG_CRTI, "fgadc_log_write error.\n");
-		return -EFAULT;
-	}
-
-	if (proc_fgadc_data[0] == '1') {
-		bm_print(BM_LOG_CRTI, "enable FGADC driver log system\n");
-		Enable_FGADC_LOG = 1;
-	} else if (proc_fgadc_data[0] == '2') {
-		bm_print(BM_LOG_CRTI, "enable FGADC driver log system:2\n");
-		Enable_FGADC_LOG = 2;
-	} else {
-		bm_print(BM_LOG_CRTI, "Disable FGADC driver log system\n");
-		Enable_FGADC_LOG = 0;
-	}
-
-	return len;
-}
-
-static const struct file_operations fgadc_proc_fops = {
-	.write = fgadc_log_write,
-};
-
-int init_proc_log_fg(void)
-{
-	int ret = 0;
-
-#if 1
-	proc_create("fgadc_log", 0644, NULL, &fgadc_proc_fops);
-	bm_print(BM_LOG_CRTI, "proc_create fgadc_proc_fops\n");
-#else
-	proc_entry_fgadc = create_proc_entry("fgadc_log", 0644, NULL);
-
-	if (proc_entry_fgadc == NULL) {
-		ret = -ENOMEM;
-		bm_print(BM_LOG_CRTI, "init_proc_log_fg: Couldn't create proc entry\n");
-	} else {
-		proc_entry_fgadc->write_proc = fgadc_log_write;
-		bm_print(BM_LOG_CRTI, "init_proc_log_fg loaded.\n");
-	}
-#endif
-
-	return ret;
-}
-
-#ifdef MTK_BATTERY_LIFETIME_DATA_SUPPORT
-
-/* ============================================================ // */
-
-#ifdef CUSTOM_BATTERY_CYCLE_AGING_DATA
-
-kal_int32 get_battery_aging_factor(kal_int32 cycle)
-{
-	kal_int32 i, f1, f2, c1, c2;
-	kal_int32 saddles;
-
-	saddles = sizeof(battery_aging_table) / sizeof(BATTERY_CYCLE_STRUC);
-
-	for (i = 0; i < saddles; i++) {
-		if (battery_aging_table[i].cycle == cycle) {
-			return battery_aging_table[i].aging_factor;
-		}
-
-		if (battery_aging_table[i].cycle > cycle) {
-			if (i == 0) {
-				return 100;
-			}
-
-			if (battery_aging_table[i].aging_factor >
-			    battery_aging_table[i - 1].aging_factor) {
-				f1 = battery_aging_table[i].aging_factor;
-				f2 = battery_aging_table[i - 1].aging_factor;
-				c1 = battery_aging_table[i].cycle;
-				c2 = battery_aging_table[i - 1].cycle;
-				return (f2 + ((cycle - c2) * (f1 - f2)) / (c1 - c2));
-			} else {
-				f1 = battery_aging_table[i - 1].aging_factor;
-				f2 = battery_aging_table[i].aging_factor;
-				c1 = battery_aging_table[i].cycle;
-				c2 = battery_aging_table[i - 1].cycle;
-				return (f2 + ((cycle - c2) * (f1 - f2)) / (c1 - c2));
-			}
-		}
-	}
-
-	return battery_aging_table[saddles - 1].aging_factor;
-}
-
-#endif
-
-static ssize_t show_FG_Battery_Cycle(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	bm_print(BM_LOG_CRTI, "[FG] gFG_battery_cycle  : %d\n", gFG_battery_cycle);
-	return sprintf(buf, "%d\n", gFG_battery_cycle);
-}
-
-static ssize_t store_FG_Battery_Cycle(struct device *dev, struct device_attribute *attr,
-				      const char *buf, size_t size)
-{
-	kal_int32 cycle;
-
-#ifdef CUSTOM_BATTERY_CYCLE_AGING_DATA
-	kal_int32 aging_capacity;
-	kal_int32 factor;
-#endif
-
-	if (1 == sscanf(buf, "%d", &cycle)) {
-		bm_print(BM_LOG_CRTI, "[FG] update battery cycle count: %d\n", cycle);
-		gFG_battery_cycle = cycle;
-
-#ifdef CUSTOM_BATTERY_CYCLE_AGING_DATA
-		/* perform cycle aging calculation */
-
-		factor = get_battery_aging_factor(gFG_battery_cycle);
-		if (factor > 0 && factor < 100) {
-			bm_print(BM_LOG_CRTI, "[FG] cycle count to aging factor %d\n", factor);
-			aging_capacity = gFG_BATT_CAPACITY * factor / 100;
-			if (aging_capacity < gFG_BATT_CAPACITY_aging) {
-				bm_print(BM_LOG_CRTI, "[FG] update gFG_BATT_CAPACITY_aging to %d\n",
-					 aging_capacity);
-				gFG_BATT_CAPACITY_aging = aging_capacity;
-			}
-		}
-#endif
-	} else {
-		bm_print(BM_LOG_CRTI, "[FG] format error!\n");
-	}
-	return size;
-}
-
-static DEVICE_ATTR(FG_Battery_Cycle, 0664, show_FG_Battery_Cycle, store_FG_Battery_Cycle);
-
-/* ------------------------------------------------------------------------------------------- */
-
-static ssize_t show_FG_Max_Battery_Voltage(struct device *dev, struct device_attribute *attr,
-					   char *buf)
-{
-	bm_print(BM_LOG_CRTI, "[FG] gFG_max_voltage  : %d\n", gFG_max_voltage);
-	return sprintf(buf, "%d\n", gFG_max_voltage);
-}
-
-static ssize_t store_FG_Max_Battery_Voltage(struct device *dev, struct device_attribute *attr,
-					    const char *buf, size_t size)
-{
-	kal_int32 voltage;
-	if (1 == sscanf(buf, "%d", &voltage)) {
-		if (voltage > gFG_max_voltage) {
-			bm_print(BM_LOG_CRTI, "[FG] update battery max voltage: %d\n", voltage);
-			gFG_max_voltage = voltage;
-		}
-	} else {
-		bm_print(BM_LOG_CRTI, "[FG] format error!\n");
-	}
-	return size;
-}
-
-static DEVICE_ATTR(FG_Max_Battery_Voltage, 0664, show_FG_Max_Battery_Voltage,
-		   store_FG_Max_Battery_Voltage);
-
-/* ------------------------------------------------------------------------------------------- */
-
-static ssize_t show_FG_Min_Battery_Voltage(struct device *dev, struct device_attribute *attr,
-					   char *buf)
-{
-	bm_print(BM_LOG_CRTI, "[FG] gFG_min_voltage  : %d\n", gFG_min_voltage);
-	return sprintf(buf, "%d\n", gFG_min_voltage);
-}
-
-static ssize_t store_FG_Min_Battery_Voltage(struct device *dev, struct device_attribute *attr,
-					    const char *buf, size_t size)
-{
-	kal_int32 voltage;
-	if (1 == sscanf(buf, "%d", &voltage)) {
-		if (voltage < gFG_min_voltage) {
-			bm_print(BM_LOG_CRTI, "[FG] update battery min voltage: %d\n", voltage);
-			gFG_min_voltage = voltage;
-		}
-	} else {
-		bm_print(BM_LOG_CRTI, "[FG] format error!\n");
-	}
-	return size;
-}
-
-static DEVICE_ATTR(FG_Min_Battery_Voltage, 0664, show_FG_Min_Battery_Voltage,
-		   store_FG_Min_Battery_Voltage);
-
-/* ------------------------------------------------------------------------------------------- */
-
-static ssize_t show_FG_Max_Battery_Current(struct device *dev, struct device_attribute *attr,
-					   char *buf)
-{
-	bm_print(BM_LOG_CRTI, "[FG] gFG_max_current  : %d\n", gFG_max_current);
-	return sprintf(buf, "%d\n", gFG_max_current);
-}
-
-static ssize_t store_FG_Max_Battery_Current(struct device *dev, struct device_attribute *attr,
-					    const char *buf, size_t size)
-{
-	kal_int32 bat_current;
-	if (1 == sscanf(buf, "%d", &bat_current)) {
-		if (bat_current > gFG_max_current) {
-			bm_print(BM_LOG_CRTI, "[FG] update battery max current: %d\n", bat_current);
-			gFG_max_current = bat_current;
-		}
-	} else {
-		bm_print(BM_LOG_CRTI, "[FG] format error!\n");
-	}
-	return size;
-}
-
-static DEVICE_ATTR(FG_Max_Battery_Current, 0664, show_FG_Max_Battery_Current,
-		   store_FG_Max_Battery_Current);
-
-/* ------------------------------------------------------------------------------------------- */
-
-static ssize_t show_FG_Min_Battery_Current(struct device *dev, struct device_attribute *attr,
-					   char *buf)
-{
-	bm_print(BM_LOG_CRTI, "[FG] gFG_min_current  : %d\n", gFG_min_current);
-	return sprintf(buf, "%d\n", gFG_min_current);
-}
-
-static ssize_t store_FG_Min_Battery_Current(struct device *dev, struct device_attribute *attr,
-					    const char *buf, size_t size)
-{
-	kal_int32 bat_current;
-	if (1 == sscanf(buf, "%d", &bat_current)) {
-		if (bat_current < gFG_min_current) {
-			bm_print(BM_LOG_CRTI, "[FG] update battery min current: %d\n", bat_current);
-			gFG_min_current = bat_current;
-		}
-	} else {
-		bm_print(BM_LOG_CRTI, "[FG] format error!\n");
-	}
-	return size;
-}
-
-static DEVICE_ATTR(FG_Min_Battery_Current, 0664, show_FG_Min_Battery_Current,
-		   store_FG_Min_Battery_Current);
-
-/* ------------------------------------------------------------------------------------------- */
-
-static ssize_t show_FG_Max_Battery_Temperature(struct device *dev, struct device_attribute *attr,
-					       char *buf)
-{
-	bm_print(BM_LOG_CRTI, "[FG] gFG_max_temperature  : %d\n", gFG_max_temperature);
-	return sprintf(buf, "%d\n", gFG_max_temperature);
-}
-
-static ssize_t store_FG_Max_Battery_Temperature(struct device *dev, struct device_attribute *attr,
-						const char *buf, size_t size)
-{
-	kal_int32 temp;
-	if (1 == sscanf(buf, "%d", &temp)) {
-		if (temp > gFG_max_temperature) {
-			bm_print(BM_LOG_CRTI, "[FG] update battery max temp: %d\n", temp);
-			gFG_max_temperature = temp;
-		}
-	} else {
-		bm_print(BM_LOG_CRTI, "[FG] format error!\n");
-	}
-	return size;
-}
-
-static DEVICE_ATTR(FG_Max_Battery_Temperature, 0664, show_FG_Max_Battery_Temperature,
-		   store_FG_Max_Battery_Temperature);
-
-/* ------------------------------------------------------------------------------------------- */
-
-static ssize_t show_FG_Min_Battery_Temperature(struct device *dev, struct device_attribute *attr,
-					       char *buf)
-{
-	bm_print(BM_LOG_CRTI, "[FG] gFG_min_temperature  : %d\n", gFG_min_temperature);
-	return sprintf(buf, "%d\n", gFG_min_temperature);
-}
-
-static ssize_t store_FG_Min_Battery_Temperature(struct device *dev, struct device_attribute *attr,
-						const char *buf, size_t size)
-{
-	kal_int32 temp;
-	if (1 == sscanf(buf, "%d", &temp)) {
-		if (temp < gFG_min_temperature) {
-			bm_print(BM_LOG_CRTI, "[FG] update battery min temp: %d\n", temp);
-			gFG_min_temperature = temp;
-		}
-	} else {
-		bm_print(BM_LOG_CRTI, "[FG] format error!\n");
-	}
-	return size;
-}
-
-static DEVICE_ATTR(FG_Min_Battery_Temperature, 0664, show_FG_Min_Battery_Temperature,
-		   store_FG_Min_Battery_Temperature);
-
-/* ------------------------------------------------------------------------------------------- */
-
-static ssize_t show_FG_Aging_Factor(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	bm_print(BM_LOG_CRTI, "[FG] gFG_aging_factor  : %d\n", gFG_aging_factor);
-	return sprintf(buf, "%d\n", gFG_aging_factor);
-}
-
-static ssize_t store_FG_Aging_Factor(struct device *dev, struct device_attribute *attr,
-				     const char *buf, size_t size)
-{
-	kal_int32 factor;
-	kal_int32 aging_capacity;
-
-	if (1 == sscanf(buf, "%d", &factor)) {
-		if (factor <= 100 && factor >= 0) {
-			bm_print(BM_LOG_CRTI,
-				 "[FG] update battery aging factor: old(%d), new(%d)\n",
-				 gFG_aging_factor, factor);
-
-			gFG_aging_factor = factor;
-
-			if (gFG_aging_factor != 100) {
-				aging_capacity = gFG_BATT_CAPACITY * gFG_aging_factor / 100;
-				if (aging_capacity < gFG_BATT_CAPACITY_aging) {
-					bm_print(BM_LOG_CRTI,
-						 "[FG] update gFG_BATT_CAPACITY_aging to %d\n",
-						 aging_capacity);
-					gFG_BATT_CAPACITY_aging = aging_capacity;
-				}
-			}
-		}
-	} else {
-		bm_print(BM_LOG_CRTI, "[FG] format error!\n");
-	}
-
-	return size;
-}
-
-static DEVICE_ATTR(FG_Aging_Factor, 0664, show_FG_Aging_Factor, store_FG_Aging_Factor);
-
-/* ------------------------------------------------------------------------------------------- */
-
-#endif
-
-/* ============================================================ // */
-static ssize_t show_FG_Current(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	kal_int32 ret = 0;
-	kal_int32 fg_current_inout_battery = 0;
-	kal_int32 val = 0;
-	kal_bool is_charging = 0;
-
-	ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_HW_FG_CURRENT, &val);
-	ret = battery_meter_ctrl(BATTERY_METER_CMD_GET_HW_FG_CURRENT_SIGN, &is_charging);
-
-	if (is_charging == KAL_TRUE) {
-		fg_current_inout_battery = 0 - val;
-	} else {
-		fg_current_inout_battery = val;
-	}
-
-	bm_print(BM_LOG_CRTI, "[FG] gFG_current_inout_battery : %d\n", fg_current_inout_battery);
-	return sprintf(buf, "%d\n", fg_current_inout_battery);
-}
-
-static ssize_t store_FG_Current(struct device *dev, struct device_attribute *attr, const char *buf,
-				size_t size)
-{
-	return size;
-}
-
-static DEVICE_ATTR(FG_Current, 0664, show_FG_Current, store_FG_Current);
-
-/* ============================================================ // */
-static ssize_t show_FG_g_fg_dbg_bat_volt(struct device *dev, struct device_attribute *attr,
-					 char *buf)
-{
-	bm_print(BM_LOG_CRTI, "[FG] g_fg_dbg_bat_volt : %d\n", g_fg_dbg_bat_volt);
-	return sprintf(buf, "%d\n", g_fg_dbg_bat_volt);
-}
-
-static ssize_t store_FG_g_fg_dbg_bat_volt(struct device *dev, struct device_attribute *attr,
-					  const char *buf, size_t size)
-{
-	return size;
-}
-
-static DEVICE_ATTR(FG_g_fg_dbg_bat_volt, 0664, show_FG_g_fg_dbg_bat_volt,
-		   store_FG_g_fg_dbg_bat_volt);
-/* ------------------------------------------------------------------------------------------- */
-static ssize_t show_FG_g_fg_dbg_bat_current(struct device *dev, struct device_attribute *attr,
-					    char *buf)
-{
-	bm_print(BM_LOG_CRTI, "[FG] g_fg_dbg_bat_current : %d\n", g_fg_dbg_bat_current);
-	return sprintf(buf, "%d\n", g_fg_dbg_bat_current);
-}
-
-static ssize_t store_FG_g_fg_dbg_bat_current(struct device *dev, struct device_attribute *attr,
-					     const char *buf, size_t size)
-{
-	return size;
-}
-
-static DEVICE_ATTR(FG_g_fg_dbg_bat_current, 0664, show_FG_g_fg_dbg_bat_current,
-		   store_FG_g_fg_dbg_bat_current);
-/* ------------------------------------------------------------------------------------------- */
-static ssize_t show_FG_g_fg_dbg_bat_zcv(struct device *dev, struct device_attribute *attr,
-					char *buf)
-{
-	bm_print(BM_LOG_CRTI, "[FG] g_fg_dbg_bat_zcv : %d\n", g_fg_dbg_bat_zcv);
-	return sprintf(buf, "%d\n", g_fg_dbg_bat_zcv);
-}
-
-static ssize_t store_FG_g_fg_dbg_bat_zcv(struct device *dev, struct device_attribute *attr,
-					 const char *buf, size_t size)
-{
-	return size;
-}
-
-static DEVICE_ATTR(FG_g_fg_dbg_bat_zcv, 0664, show_FG_g_fg_dbg_bat_zcv, store_FG_g_fg_dbg_bat_zcv);
-/* ------------------------------------------------------------------------------------------- */
-static ssize_t show_FG_g_fg_dbg_bat_temp(struct device *dev, struct device_attribute *attr,
-					 char *buf)
-{
-	bm_print(BM_LOG_CRTI, "[FG] g_fg_dbg_bat_temp : %d\n", g_fg_dbg_bat_temp);
-	return sprintf(buf, "%d\n", g_fg_dbg_bat_temp);
-}
-
-static ssize_t store_FG_g_fg_dbg_bat_temp(struct device *dev, struct device_attribute *attr,
-					  const char *buf, size_t size)
-{
-	return size;
-}
-
-static DEVICE_ATTR(FG_g_fg_dbg_bat_temp, 0664, show_FG_g_fg_dbg_bat_temp,
-		   store_FG_g_fg_dbg_bat_temp);
-/* ------------------------------------------------------------------------------------------- */
-static ssize_t show_FG_g_fg_dbg_bat_r(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	bm_print(BM_LOG_CRTI, "[FG] g_fg_dbg_bat_r : %d\n", g_fg_dbg_bat_r);
-	return sprintf(buf, "%d\n", g_fg_dbg_bat_r);
-}
-
-static ssize_t store_FG_g_fg_dbg_bat_r(struct device *dev, struct device_attribute *attr,
-				       const char *buf, size_t size)
-{
-	return size;
-}
-
-static DEVICE_ATTR(FG_g_fg_dbg_bat_r, 0664, show_FG_g_fg_dbg_bat_r, store_FG_g_fg_dbg_bat_r);
-/* ------------------------------------------------------------------------------------------- */
-static ssize_t show_FG_g_fg_dbg_bat_car(struct device *dev, struct device_attribute *attr,
-					char *buf)
-{
-	bm_print(BM_LOG_CRTI, "[FG] g_fg_dbg_bat_car : %d\n", g_fg_dbg_bat_car);
-	return sprintf(buf, "%d\n", g_fg_dbg_bat_car);
-}
-
-static ssize_t store_FG_g_fg_dbg_bat_car(struct device *dev, struct device_attribute *attr,
-					 const char *buf, size_t size)
-{
-	return size;
-}
-
-static DEVICE_ATTR(FG_g_fg_dbg_bat_car, 0664, show_FG_g_fg_dbg_bat_car, store_FG_g_fg_dbg_bat_car);
-/* ------------------------------------------------------------------------------------------- */
-static ssize_t show_FG_g_fg_dbg_bat_qmax(struct device *dev, struct device_attribute *attr,
-					 char *buf)
-{
-	bm_print(BM_LOG_CRTI, "[FG] g_fg_dbg_bat_qmax : %d\n", g_fg_dbg_bat_qmax);
-	return sprintf(buf, "%d\n", g_fg_dbg_bat_qmax);
-}
-
-static ssize_t store_FG_g_fg_dbg_bat_qmax(struct device *dev, struct device_attribute *attr,
-					  const char *buf, size_t size)
-{
-	return size;
-}
-
-static DEVICE_ATTR(FG_g_fg_dbg_bat_qmax, 0664, show_FG_g_fg_dbg_bat_qmax,
-		   store_FG_g_fg_dbg_bat_qmax);
-/* ------------------------------------------------------------------------------------------- */
-static ssize_t show_FG_g_fg_dbg_d0(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	bm_print(BM_LOG_CRTI, "[FG] g_fg_dbg_d0 : %d\n", g_fg_dbg_d0);
-	return sprintf(buf, "%d\n", g_fg_dbg_d0);
-}
-
-static ssize_t store_FG_g_fg_dbg_d0(struct device *dev, struct device_attribute *attr,
-				    const char *buf, size_t size)
-{
-	return size;
-}
-
-static DEVICE_ATTR(FG_g_fg_dbg_d0, 0664, show_FG_g_fg_dbg_d0, store_FG_g_fg_dbg_d0);
-/* ------------------------------------------------------------------------------------------- */
-static ssize_t show_FG_g_fg_dbg_d1(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	bm_print(BM_LOG_CRTI, "[FG] g_fg_dbg_d1 : %d\n", g_fg_dbg_d1);
-	return sprintf(buf, "%d\n", g_fg_dbg_d1);
-}
-
-static ssize_t store_FG_g_fg_dbg_d1(struct device *dev, struct device_attribute *attr,
-				    const char *buf, size_t size)
-{
-	return size;
-}
-
-static DEVICE_ATTR(FG_g_fg_dbg_d1, 0664, show_FG_g_fg_dbg_d1, store_FG_g_fg_dbg_d1);
-/* ------------------------------------------------------------------------------------------- */
-static ssize_t show_FG_g_fg_dbg_percentage(struct device *dev, struct device_attribute *attr,
-					   char *buf)
-{
-	bm_print(BM_LOG_CRTI, "[FG] g_fg_dbg_percentage : %d\n", g_fg_dbg_percentage);
-	return sprintf(buf, "%d\n", g_fg_dbg_percentage);
-}
-
-static ssize_t store_FG_g_fg_dbg_percentage(struct device *dev, struct device_attribute *attr,
-					    const char *buf, size_t size)
-{
-	return size;
-}
-
-static DEVICE_ATTR(FG_g_fg_dbg_percentage, 0664, show_FG_g_fg_dbg_percentage,
-		   store_FG_g_fg_dbg_percentage);
-/* ------------------------------------------------------------------------------------------- */
-static ssize_t show_FG_g_fg_dbg_percentage_fg(struct device *dev, struct device_attribute *attr,
-					      char *buf)
-{
-	bm_print(BM_LOG_CRTI, "[FG] g_fg_dbg_percentage_fg : %d\n", g_fg_dbg_percentage_fg);
-	return sprintf(buf, "%d\n", g_fg_dbg_percentage_fg);
-}
-
-static ssize_t store_FG_g_fg_dbg_percentage_fg(struct device *dev, struct device_attribute *attr,
-					       const char *buf, size_t size)
-{
-	return size;
-}
-
-static DEVICE_ATTR(FG_g_fg_dbg_percentage_fg, 0664, show_FG_g_fg_dbg_percentage_fg,
-		   store_FG_g_fg_dbg_percentage_fg);
-/* ------------------------------------------------------------------------------------------- */
-static ssize_t show_FG_g_fg_dbg_percentage_voltmode(struct device *dev,
-						    struct device_attribute *attr, char *buf)
-{
-	bm_print(BM_LOG_CRTI, "[FG] g_fg_dbg_percentage_voltmode : %d\n",
-		 g_fg_dbg_percentage_voltmode);
-	return sprintf(buf, "%d\n", g_fg_dbg_percentage_voltmode);
-}
-
-static ssize_t store_FG_g_fg_dbg_percentage_voltmode(struct device *dev,
-						     struct device_attribute *attr, const char *buf,
-						     size_t size)
-{
-	return size;
-}
-
-static DEVICE_ATTR(FG_g_fg_dbg_percentage_voltmode, 0664, show_FG_g_fg_dbg_percentage_voltmode,
-		   store_FG_g_fg_dbg_percentage_voltmode);
-
-/* ============================================================ // */
-static int battery_meter_probe(struct platform_device *dev)
-{
-	int ret_device_file = 0;
-#if defined (CONFIG_MTK_KERNEL_POWER_OFF_CHARGING)
-	char* temp_strptr;
-#endif
-	battery_meter_ctrl = bm_ctrl_cmd;
-
-	bm_print(BM_LOG_CRTI, "[battery_meter_probe] probe\n");
-	/* select battery meter control method */
-	battery_meter_ctrl = bm_ctrl_cmd;
-#if defined (CONFIG_MTK_KERNEL_POWER_OFF_CHARGING)
-	if (g_boot_mode == LOW_POWER_OFF_CHARGING_BOOT || g_boot_mode == KERNEL_POWER_OFF_CHARGING_BOOT) {
-		temp_strptr = kzalloc(strlen(saved_command_line)+strlen(" androidboot.mode=charger")+1, GFP_KERNEL);
-		strcpy(temp_strptr, saved_command_line);
-		strcat(temp_strptr, " androidboot.mode=charger");
-		saved_command_line = temp_strptr;
-	}
-#endif
-	/* LOG System Set */
-	init_proc_log_fg();
-
-	/* last_oam_run_time = rtc_read_hw_time(); */
-	getrawmonotonic(&last_oam_run_time);
-	/* Create File For FG UI DEBUG */
-	ret_device_file = device_create_file(&(dev->dev), &dev_attr_FG_Current);
-	ret_device_file = device_create_file(&(dev->dev), &dev_attr_FG_g_fg_dbg_bat_volt);
-	ret_device_file = device_create_file(&(dev->dev), &dev_attr_FG_g_fg_dbg_bat_current);
-	ret_device_file = device_create_file(&(dev->dev), &dev_attr_FG_g_fg_dbg_bat_zcv);
-	ret_device_file = device_create_file(&(dev->dev), &dev_attr_FG_g_fg_dbg_bat_temp);
-	ret_device_file = device_create_file(&(dev->dev), &dev_attr_FG_g_fg_dbg_bat_r);
-	ret_device_file = device_create_file(&(dev->dev), &dev_attr_FG_g_fg_dbg_bat_car);
-	ret_device_file = device_create_file(&(dev->dev), &dev_attr_FG_g_fg_dbg_bat_qmax);
-	ret_device_file = device_create_file(&(dev->dev), &dev_attr_FG_g_fg_dbg_d0);
-	ret_device_file = device_create_file(&(dev->dev), &dev_attr_FG_g_fg_dbg_d1);
-	ret_device_file = device_create_file(&(dev->dev), &dev_attr_FG_g_fg_dbg_percentage);
-	ret_device_file = device_create_file(&(dev->dev), &dev_attr_FG_g_fg_dbg_percentage_fg);
-	ret_device_file =
-	    device_create_file(&(dev->dev), &dev_attr_FG_g_fg_dbg_percentage_voltmode);
-
-#ifdef MTK_BATTERY_LIFETIME_DATA_SUPPORT
-	ret_device_file = device_create_file(&(dev->dev), &dev_attr_FG_Battery_Cycle);
-	ret_device_file = device_create_file(&(dev->dev), &dev_attr_FG_Aging_Factor);
-	ret_device_file = device_create_file(&(dev->dev), &dev_attr_FG_Max_Battery_Voltage);
-	ret_device_file = device_create_file(&(dev->dev), &dev_attr_FG_Min_Battery_Voltage);
-	ret_device_file = device_create_file(&(dev->dev), &dev_attr_FG_Max_Battery_Current);
-	ret_device_file = device_create_file(&(dev->dev), &dev_attr_FG_Min_Battery_Current);
-	ret_device_file = device_create_file(&(dev->dev), &dev_attr_FG_Max_Battery_Temperature);
-	ret_device_file = device_create_file(&(dev->dev), &dev_attr_FG_Min_Battery_Temperature);
-#endif
-
-	return 0;
-}
-
-static int battery_meter_remove(struct platform_device *dev)
-{
-	bm_print(BM_LOG_CRTI, "[battery_meter_remove]\n");
-	return 0;
-}
-
-static void battery_meter_shutdown(struct platform_device *dev)
-{
-	bm_print(BM_LOG_CRTI, "[battery_meter_shutdown]\n");
-}
-
-static int battery_meter_suspend(struct platform_device *dev, pm_message_t state)
-{
-#if defined(CONFIG_POWER_EXT)
-
-#elif defined(SOC_BY_SW_FG) || defined(SOC_BY_HW_FG)
-	struct timespec xts, tom;
-#endif
-
-#if defined(FG_BAT_INT)
-#if defined(CONFIG_POWER_EXT)
-#elif defined(SOC_BY_HW_FG)
-	if (reset_fg_bat_int==KAL_TRUE)
-	{
-		battery_meter_set_columb_interrupt(gFG_BATT_CAPACITY/100);
-		reset_fg_bat_int=KAL_FALSE;
-	}
-	else
-	{
-		battery_meter_set_columb_interrupt(0x1ffff);	
-	}
-#endif
-#endif //#if defined(FG_BAT_INT)
-
-	/* -- hibernation path */
-	if (state.event == PM_EVENT_FREEZE) {
-		pr_warn("[%s] %p:%p\n", __func__, battery_meter_ctrl, &bm_ctrl_cmd);
-		battery_meter_ctrl = bm_ctrl_cmd;
-	}
-	/* -- end of hibernation path */
-#if defined(CONFIG_POWER_EXT)
-
-#elif defined(SOC_BY_SW_FG) || defined(SOC_BY_HW_FG)
-	{
-#ifdef MTK_POWER_EXT_DETECT
-		if (KAL_TRUE == bat_is_ext_power())
-			return 0;
-#endif
-		get_xtime_and_monotonic_and_sleep_offset(&xts_before_sleep, &tom, &g_rtc_time_before_sleep);
-		if (_g_bat_sleep_total_time < g_spm_timer) {
-			return 0;
-		}
-		_g_bat_sleep_total_time = 0;
-		battery_meter_ctrl(BATTERY_METER_CMD_GET_HW_OCV, &g_hw_ocv_before_sleep);
-	}
-#endif
-	bm_print(BM_LOG_CRTI, "[battery_meter_suspend]\n");
-	return 0;
-}
-
-#if defined(SOC_BY_HW_FG)
-#ifdef MTK_ENABLE_AGING_ALGORITHM
-static void battery_aging_check(void)
-{
-	kal_int32 hw_ocv_after_sleep;
-	struct timespec xts, tom, sleeptime;
-	kal_int32 vbat;
-	kal_int32 qmax_aging = 0;
-	kal_int32 dod_gap = 10;
-	kal_int32 columb_after_sleep = 0;
-#if defined (MD_SLEEP_CURRENT_CHECK)
-	kal_int32 DOD_hwocv;
-	kal_int32 DOD_now;
-	kal_int32 suspend_current = 0;
-#endif
-
-	battery_meter_ctrl(BATTERY_METER_CMD_GET_HW_OCV, &hw_ocv_after_sleep);
-	vbat = battery_meter_get_battery_voltage(KAL_TRUE);
-	bm_print(BM_LOG_CRTI, "@@@ HW_OCV_D3=%d, HW_OCV_D1=%d, VBAT=%d\n", hw_ocv_after_sleep, g_hw_ocv_before_sleep, vbat);
-
-	// gauge correct
-	battery_meter_ctrl(BATTERY_METER_CMD_GET_HW_FG_CAR, &columb_after_sleep); //update columb counter to get DOD_now.
-
-	get_xtime_and_monotonic_and_sleep_offset(&xts, &tom, &sleeptime);
-	suspend_time += abs(xts.tv_sec - xts_before_sleep.tv_sec);
-	_g_bat_sleep_total_time += abs(xts.tv_sec - xts_before_sleep.tv_sec);
-#if defined (MD_SLEEP_CURRENT_CHECK)
-	bm_print(BM_LOG_CRTI, "sleeptime=(%d)s, car_be = %d, car_af = %d\n", suspend_time, columb_before_sleep, columb_after_sleep);
-	if (columb_before_sleep == 0x123456) {
-		columb_before_sleep = columb_after_sleep;
-		suspend_time = 0;
-		return;
-	}
-	if (hw_ocv_after_sleep != g_hw_ocv_before_sleep) {
-		if(suspend_time > OCV_RECOVER_TIME) {   //35 mins
-			suspend_current = abs(columb_after_sleep - columb_before_sleep) * 3600 / suspend_time;
-			bm_print(BM_LOG_CRTI, "[aging check]sleeptime = %d, HW_OCV_D3=%d, car_be = %d, car_af = %d, suspend cur = %d ", suspend_time, hw_ocv_after_sleep, columb_before_sleep, columb_after_sleep, suspend_current);
-			if (suspend_current < 10) { //10mA
-				columb_before_sleep = columb_after_sleep;
-				suspend_time = 0;
-				bm_print(BM_LOG_CRTI, "1\n");
-			} else {
-				columb_before_sleep = columb_after_sleep;
-				suspend_time = 0;
-				bm_print(BM_LOG_CRTI, "0\n");
-				return ;
-			}
-		} else {
-			return ;	
-		}
-	} else {
-		return ;
-	}
-#endif
-   	// aging
-#if !defined (MD_SLEEP_CURRENT_CHECK)
-    	if(suspend_time > OCV_RECOVER_TIME)
-#endif
-	{
-		if (aging_ocv_1 == 0) {
-			aging_ocv_1 = hw_ocv_after_sleep;
-			aging_car_1 = columb_after_sleep;
-			//aging_resume_time_1 = time_after_sleep.tv_sec;
-
-			if (fgauge_read_d_by_v(aging_ocv_1) > DOD1_ABOVE_THRESHOLD) {
-				aging_ocv_1 = 0;
-				bm_print(BM_LOG_CRTI, "[aging check] reset and find next aging_ocv1 for better precision\n");
-			}
-		} else if (aging_ocv_2 == 0) {
-			aging_ocv_2 = hw_ocv_after_sleep;
-			aging_car_2 = columb_after_sleep;
-			//aging_resume_time_2 = time_after_sleep.tv_sec;
-
-			if (fgauge_read_d_by_v(aging_ocv_2) < DOD2_BELOW_THRESHOLD) {
-				aging_ocv_2 = 0;
-				bm_print(BM_LOG_CRTI, "[aging check] reset and find next aging_ocv2 for better precision\n");
-			}
-		} else {
-			aging_ocv_1 = aging_ocv_2;
-			aging_car_1 = aging_car_2;
-			//aging_resume_time_1 = aging_resume_time_2;
-
-			aging_ocv_2 = hw_ocv_after_sleep;
-			aging_car_2 = columb_after_sleep;
-			//aging_resume_time_2 = time_after_sleep.tv_sec;
-		}
-	}
-
-	if (aging_ocv_2 > 0) {
-		aging_dod_1 = fgauge_read_d_by_v(aging_ocv_1);
-		aging_dod_2 = fgauge_read_d_by_v(aging_ocv_2);
-
-		/* check dod region to avoid hwocv error margin */
-		dod_gap = MIN_DOD_DIFF_THRESHOLD;
-
-		/* check if DOD gap bigger than setting */
-		if(aging_dod_2 > aging_dod_1 && (aging_dod_2 - aging_dod_1) >= dod_gap) {
-			/* do aging calculation */
-			qmax_aging = (100*(aging_car_1 - aging_car_2))/(aging_dod_2 - aging_dod_1);
-
-			/* update if aging over 10%. */
-			if (gFG_BATT_CAPACITY > qmax_aging
-				&& ((gFG_BATT_CAPACITY - qmax_aging) >
-				(gFG_BATT_CAPACITY / (100 - MIN_AGING_FACTOR)))) {
-				bm_print(BM_LOG_CRTI,
-					"[aging check] before apply aging, qmax_aging(%d) qmax_now(%d) ocv1(%d) dod1(%d) car1(%d) ocv2(%d) dod2(%d) car2(%d)\n",
-					qmax_aging, gFG_BATT_CAPACITY, aging_ocv_1,
-					aging_dod_1, aging_car_1, aging_ocv_2, aging_dod_2,
-					aging_car_2);
-
-#ifdef MTK_BATTERY_LIFETIME_DATA_SUPPORT
-				gFG_aging_factor =
-					((gFG_BATT_CAPACITY -
-					qmax_aging) * 100) / gFG_BATT_CAPACITY;
-#endif
-
-				if (gFG_BATT_CAPACITY_aging > qmax_aging) {
-					bm_print(BM_LOG_CRTI,
-						"[aging check] new qmax_aging %d old qmax_aging %d\n",
-						qmax_aging, gFG_BATT_CAPACITY_aging);
-					gFG_BATT_CAPACITY_aging = qmax_aging;
-					gFG_DOD0 = aging_dod_2;
-					gFG_DOD1 = gFG_DOD0;
-					reset_parameter_car();
-				} else {
-					bm_print(BM_LOG_CRTI,
-						"[aging check] current qmax_aging %d is smaller than calculated qmax_aging %d\n",
-						gFG_BATT_CAPACITY_aging, qmax_aging);
-				}
-			} else {
-				aging_ocv_2 = 0;
-				bm_print(BM_LOG_CRTI,
-					"[aging check] show no degrade, qmax_aging(%d) qmax_now(%d) ocv1(%d) dod1(%d) car1(%d) ocv2(%d) dod2(%d) car2(%d)\n",
-					qmax_aging, gFG_BATT_CAPACITY, aging_ocv_1,
-					aging_dod_1, aging_car_1, aging_ocv_2, aging_dod_2,
-					aging_car_2);
-				bm_print(BM_LOG_CRTI,
-					"[aging check] reset and find next aging_ocv2\n");
-			}
-		} else {
-			aging_ocv_2 = 0;
-			bm_print(BM_LOG_CRTI,
-				"[aging check] reset and find next aging_ocv2\n");
-		}
-		bm_print(BM_LOG_CRTI,
-			"[aging check] qmax_aging(%d) qmax_now(%d) ocv1(%d) dod1(%d) car1(%d) ocv2(%d) dod2(%d) car2(%d)\n",
-			qmax_aging, gFG_BATT_CAPACITY, aging_ocv_1, aging_dod_1,
-			aging_car_1, aging_ocv_2, aging_dod_2, aging_car_2);
-	}
-#if defined (MD_SLEEP_CURRENT_CHECK)
-	/* self-discharging */
-	if (hw_ocv_after_sleep < vbat) {
-		bm_print(BM_LOG_CRTI, "Ignore HW_OCV : smaller than VBAT\n");
-	} else {
-
-		DOD_hwocv = fgauge_read_d_by_v(hw_ocv_after_sleep);
-
-		battery_meter_ctrl(BATTERY_METER_CMD_GET_HW_FG_CAR, &gFG_columb);	/* update columb counter to get DOD_now. */
-		DOD_now = 100 - fgauge_read_capacity(1);
-
-		if (DOD_hwocv > DOD_now
-		    && (DOD_hwocv - DOD_now > SELF_DISCHARGE_CHECK_THRESHOLD)) {
-			gFG_DOD0 = DOD_hwocv;
-			gFG_DOD1 = gFG_DOD0;
-			reset_parameter_car();
-			bm_print(BM_LOG_CRTI,
-				 "[self-discharge check] reset to HWOCV. dod_ocv(%d) dod_now(%d)\n",
-				 DOD_hwocv, DOD_now);
-		}
-		bm_print(BM_LOG_CRTI, "[self-discharge check] dod_ocv(%d) dod_now(%d)\n",
-			 DOD_hwocv, DOD_now);
-		bm_print(BM_LOG_CRTI,
-			 "be_ocv=(%d), af_ocv=(%d), D0=(%d), car=(%d)\n",
-			 g_hw_ocv_before_sleep, hw_ocv_after_sleep,
-			 gFG_DOD0, gFG_columb);
-	}
-#endif
-}
-#endif
-#endif
-
-static int battery_meter_resume(struct platform_device *dev)
-{
-#if defined(CONFIG_POWER_EXT)
-
-#elif defined(SOC_BY_SW_FG) || defined(SOC_BY_HW_FG)
-#if defined(SOC_BY_SW_FG)
-	kal_int32 hw_ocv_after_sleep;
-#endif
-	struct timespec xts, tom, rtc_time_after_sleep;
-#ifdef MTK_POWER_EXT_DETECT
-	if (KAL_TRUE == bat_is_ext_power())
-		return 0;
-#endif
-
-	get_xtime_and_monotonic_and_sleep_offset(&xts, &tom, &rtc_time_after_sleep);
-	_g_bat_sleep_total_time += rtc_time_after_sleep.tv_sec - g_rtc_time_before_sleep.tv_sec;
-	battery_log(BAT_LOG_CRTI,
-			    "[battery_meter_resume] sleep time = %d, g_spm_timer = %d\n",
-			    _g_bat_sleep_total_time, g_spm_timer);
-
-#if defined(SOC_BY_HW_FG)
-#ifdef MTK_ENABLE_AGING_ALGORITHM
-    if(bat_is_charger_exist() == KAL_FALSE)
-    {
-        battery_aging_check();
-    }
-#endif
-#endif
-
-	if (_g_bat_sleep_total_time < g_spm_timer) {
-		return 0;
-	}
-	bat_spm_timeout = true;
-#if defined(SOC_BY_SW_FG)    
-	battery_meter_ctrl(BATTERY_METER_CMD_GET_HW_OCV, &hw_ocv_after_sleep);
-	if (_g_bat_sleep_total_time > 3600) {	/* 1hr */
-		if (hw_ocv_after_sleep < g_hw_ocv_before_sleep) {
-			oam_d0 = fgauge_read_d_by_v(hw_ocv_after_sleep);
-			oam_v_ocv_2 = oam_v_ocv_1 = hw_ocv_after_sleep;
-			oam_car_1 = 0;
-			oam_car_2 = 0;
-		} else {
-			oam_car_1 = oam_car_1 + (40* (rtc_time_after_sleep.tv_sec - g_rtc_time_before_sleep.tv_sec)/3600); //0.1mAh
-			oam_car_2 = oam_car_2 + (40* (rtc_time_after_sleep.tv_sec - g_rtc_time_before_sleep.tv_sec)/3600); //0.1mAh	
-		}
-	}
-    //FIXME
-    
-	bm_print(BM_LOG_CRTI,
-		 "sleeptime=(%d)s, be_ocv=(%d), af_ocv=(%d), D0=(%d), car1=(%d), car2=(%d)\n",
-		 _g_bat_sleep_total_time,
-		 g_hw_ocv_before_sleep, hw_ocv_after_sleep, oam_d0, oam_car_1, oam_car_2);
-#endif
-#endif
-
-#if defined(FG_BAT_INT)
-#if defined(CONFIG_POWER_EXT)
-#elif defined(SOC_BY_HW_FG)
-	battery_meter_set_columb_interrupt(0);
-#endif
-#endif //#if defined(FG_BAT_INT)
-
-	bm_print(BM_LOG_CRTI, "[battery_meter_resume]\n");
-	return 0;
-}
-
-//-----------------------------------------------------
-
-#ifdef CONFIG_OF
-static const struct of_device_id mt_bat_meter_of_match[] = {
-	{ .compatible = "mediatek,bat_meter", },
-	{},
-};
-
-MODULE_DEVICE_TABLE(of, mt_bat_meter_of_match);
-#endif
-struct platform_device battery_meter_device = {
-	.name = "battery_meter",
-	.id = -1,
-};
-
-
-static struct platform_driver battery_meter_driver = {
-	.probe = battery_meter_probe,
-	.remove = battery_meter_remove,
-	.shutdown = battery_meter_shutdown,
-	.suspend = battery_meter_suspend,
-	.resume = battery_meter_resume,
-	.driver = {
-		   .name = "battery_meter",
-		   },
-};
-
-static int battery_meter_dts_probe(struct platform_device *dev)
-{
-	int ret = 0;
-	/* struct proc_dir_entry *entry = NULL; */
-
-	battery_log(BAT_LOG_CRTI, "******** battery_meter_dts_probe!! ********\n");
-
-	battery_meter_device.dev.of_node = dev->dev.of_node;
-	ret = platform_device_register(&battery_meter_device);
-    if (ret) {
-		battery_log(BAT_LOG_CRTI,
-				    "****[battery_meter_dts_probe] Unable to register device (%d)\n", ret);
-		return ret;
-	}
-	return 0;
-
-}
-
-static struct platform_driver battery_meter_dts_driver = {
-	.probe = battery_meter_dts_probe,
-	.remove = NULL,
-	.shutdown = NULL,
-	.suspend = NULL,
-	.resume = NULL,
-	.driver = {
-		   .name = "battery_meter_dts",
-        #ifdef CONFIG_OF 
-        .of_match_table = mt_bat_meter_of_match,    
-        #endif
-		   },
-};
-
-static int __init battery_meter_init(void)
-{
-	int ret;
-
-#ifdef CONFIG_OF
-	//
-#else
-	ret = platform_device_register(&battery_meter_device);
-	if (ret) {
-		bm_print(BM_LOG_CRTI, "[battery_meter_driver] Unable to device register(%d)\n",
-			 ret);
-		return ret;
-	}
-#endif
-
-	ret = platform_driver_register(&battery_meter_driver);
-	if (ret) {
-		bm_print(BM_LOG_CRTI, "[battery_meter_driver] Unable to register driver (%d)\n",
-			 ret);
-		return ret;
-	}
-#ifdef CONFIG_OF
-	ret = platform_driver_register(&battery_meter_dts_driver);
-#endif
-	bm_print(BM_LOG_CRTI, "[battery_meter_driver] Initialization : DONE\n");
-
-	return 0;
-
-}
-#ifdef BATTERY_MODULE_INIT
-//#if 0
-//late_initcall(battery_meter_init);
-device_initcall(battery_meter_init);
-#else
-static void __exit battery_meter_exit(void)
-{
-}
-module_init(battery_meter_init);
-//module_exit(battery_meter_exit);
-#endif
-
-MODULE_AUTHOR("James Lo");
-MODULE_DESCRIPTION("Battery Meter Device Driver");
-MODULE_LICENSE("GPL");
diff --git a/drivers/power/mediatek/linear_charging.c~ b/drivers/power/mediatek/linear_charging.c~
deleted file mode 100755
index 179a9d1..0000000
--- a/drivers/power/mediatek/linear_charging.c~
+++ /dev/null
@@ -1,1272 +0,0 @@
-/*****************************************************************************
- *
- * Filename:
- * ---------
- *    linear_charging.c
- *
- * Project:
- * --------
- *   ALPS_Software
- *
- * Description:
- * ------------
- *   This file implements the interface between BMT and ADC scheduler.
- *
- * Author:
- * -------
- *  Oscar Liu
- *
- *============================================================================
-  * $Revision:   1.0  $
- * $Modtime:   11 Aug 2005 10:28:16  $
- * $Log:   //mtkvs01/vmdata/Maui_sw/archives/mcu/hal/peripheral/inc/bmt_chr_setting.h-arc  $
- *
- * 03 10 2015 wy.chuang
- * [ALPS01974124] Device keep popup Power off charging mode notify while using USB cable and connect with Specify USB port
- * .
- *
- * 03 05 2015 wy.chuang
- * [ALPS01921641] [L1_merge] for PMIC and charging
- * .
- *
- * 01 20 2015 wy.chuang
- * [ALPS01814017] MT6328 check in
- * .
- *
- * 01 18 2015 wy.chuang
- * [ALPS01814017] MT6328 check in
- * .
- *             HISTORY
- * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
- *------------------------------------------------------------------------------
- *------------------------------------------------------------------------------
- * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
- *============================================================================
- ****************************************************************************/
-#include <linux/kernel.h>
-#include <mach/battery_common.h>
-#include <mach/charging.h>
-#include "cust_charging.h"
-#include <mach/mt_boot.h>
-#include <linux/delay.h>
-#include <mach/battery_meter.h>
-#include <linux/mutex.h>
-#include <linux/wakelock.h>
-
- /* ============================================================ // */
- /* define */
- /* ============================================================ // */
- /* cut off to full */
-#define POST_CHARGING_TIME		30 * 60		/* 30mins */
-#define CV_CHECK_DELAT_FOR_BANDGAP	80		/* 80mV */
-#if defined(CONFIG_MTK_PUMP_EXPRESS_SUPPORT)
-#define BJT_LIMIT			1200000		/* 1.2W */
-#ifndef TA_START_VCHR_TUNUNG_VOLTAG
-#define TA_START_VCHR_TUNUNG_VOLTAGE	3700		/* for isink blink issue */
-#define TA_CHARGING_CURRENT		CHARGE_CURRENT_1500_00_MA
-#endif	/* TA_START_VCHR_TUNUNG_VOLTAG */
-#endif	/* MTK_PUMP_EXPRESS_SUPPORT */
-
-
- /* ============================================================ // */
- /* global variable */
- /* ============================================================ // */
-kal_uint32 		g_bcct_flag = 0;
-CHR_CURRENT_ENUM 	g_temp_CC_value = CHARGE_CURRENT_0_00_MA;
-kal_uint32 		g_usb_state = USB_UNCONFIGURED;
-kal_uint32 		charging_full_current = CHARGING_FULL_CURRENT;	/* mA */
-kal_uint32 		v_cc2topoff_threshold = V_CC2TOPOFF_THRES;
- CHR_CURRENT_ENUM	ulc_cv_charging_current = AC_CHARGER_CURRENT;	
- kal_bool 		ulc_cv_charging_current_flag = KAL_FALSE;
-static bool 		usb_unlimited=false;
-
-  /* ///////////////////////////////////////////////////////////////////////////////////////// */
-  /* // JEITA */
-  /* ///////////////////////////////////////////////////////////////////////////////////////// */
-#if defined(CONFIG_MTK_JEITA_STANDARD_SUPPORT)
-int g_jeita_recharging_voltage = JEITA_RECHARGE_VOLTAGE;
-int g_temp_status = TEMP_POS_10_TO_POS_45;
-kal_bool temp_error_recovery_chr_flag = KAL_TRUE;
-#endif
-
-  /* ///////////////////////////////////////////////////////////////////////////////////////// */
-  /* // PUMP EXPRESS */
-  /* ///////////////////////////////////////////////////////////////////////////////////////// */
-#if defined(CONFIG_MTK_PUMP_EXPRESS_SUPPORT)
-struct wake_lock TA_charger_suspend_lock;
-CHR_CURRENT_ENUM ta_charging_current =	TA_CHARGING_CURRENT;
-int ta_current_level = 5000;
-int ta_pre_vbat = 0;
-kal_bool ta_check_chr_type = KAL_TRUE;
-kal_bool ta_check_ta_control = KAL_FALSE;
-kal_bool ta_vchr_tuning = KAL_FALSE;
-kal_bool first_vchr_det = KAL_TRUE;
-kal_bool ta_cable_out_occur = KAL_FALSE;
-kal_bool is_ta_connect = KAL_FALSE;
-#endif
-
-
- /* ============================================================ // */
- /* function prototype */
- /* ============================================================ // */
-
-
- /* ============================================================ // */
- /* extern variable */
- /* ============================================================ // */
-extern int g_platform_boot_mode;
-
- /* ============================================================ // */
- /* extern function */
- /* ============================================================ // */
-
-
- /* ============================================================ // */
-void BATTERY_SetUSBState(int usb_state_value)
-{
-#if defined(CONFIG_POWER_EXT)
-	battery_log(BAT_LOG_CRTI, "[BATTERY_SetUSBState] in FPGA/EVB, no service\r\n");
-#else
-	if ((usb_state_value < USB_SUSPEND) || ((usb_state_value > USB_CONFIGURED))) {
-		battery_log(BAT_LOG_CRTI,
-				    "[BATTERY] BAT_SetUSBState Fail! Restore to default value\r\n");
-		usb_state_value = USB_UNCONFIGURED;
-	} else {
-		battery_log(BAT_LOG_CRTI, "[BATTERY] BAT_SetUSBState Success! Set %d\r\n",
-				    usb_state_value);
-		g_usb_state = usb_state_value;
-	}
-#endif
-}
-
-/* EXPORT_SYMBOL(BATTERY_SetUSBState); */
-
-
-//EXPORT_SYMBOL(BATTERY_SetUSBState);
-
-
-kal_uint32 get_charging_setting_current()
-{
-	return g_temp_CC_value;
-}
-
-
-#if defined(CONFIG_MTK_PUMP_EXPRESS_SUPPORT)
-
-static DEFINE_MUTEX(ta_mutex);
-
- 
-static void mtk_ta_decrease(void)
-{
- 	kal_bool ta_current_pattern = KAL_FALSE;		// FALSE = decrease
- 	 
-	//if(BMT_status.charger_exist == KAL_TRUE) 	
-	if(ta_cable_out_occur == KAL_FALSE) {
-		battery_charging_control(CHARGING_CMD_SET_TA_CURRENT_PATTERN,&ta_current_pattern);	
-	 	ta_current_level -= 200;
-	} else {
-	 	ta_check_chr_type = KAL_TRUE;
-  	 	//is_ta_connect = KAL_FALSE;
-		battery_log(BAT_LOG_CRTI, "mtk_ta_decrease() Cable out \n");
-	}
-}
- 
-static void mtk_ta_increase(void)
-{
-	kal_bool ta_current_pattern = KAL_TRUE;		// TRUE = increase
- 	 
-	//if(BMT_status.charger_exist == KAL_TRUE)
-	if(ta_cable_out_occur == KAL_FALSE) {
-		battery_charging_control(CHARGING_CMD_SET_TA_CURRENT_PATTERN,&ta_current_pattern);	
-		ta_current_level += 200;
- 	 } else {
-		ta_check_chr_type = KAL_TRUE;
-		//is_ta_connect = KAL_FALSE;
-		battery_log(BAT_LOG_CRTI, "mtk_ta_increase() Cable out \n");
-	}
-}
-
-static void mtk_ta_reset_vchr(void)
-{
-	CHR_CURRENT_ENUM	chr_current = CHARGE_CURRENT_70_00_MA;
-	
-	battery_charging_control(CHARGING_CMD_SET_CURRENT,&chr_current);
-	msleep(250);	// reset Vchr to 5V 
-
-	ta_current_level = 5000;
-
-	battery_log(BAT_LOG_CRTI, "mtk_ta_reset_vchr(): reset Vchr to 5V \n");
-}
- 
-static void mtk_ta_init(void)
-{
-	ta_current_level = 5000;
-	is_ta_connect = KAL_FALSE;
-	ta_pre_vbat = 0;
-	ta_vchr_tuning = KAL_FALSE;
-	ta_check_ta_control = KAL_FALSE;
-	ta_cable_out_occur = KAL_FALSE;
-
-	battery_charging_control(CHARGING_CMD_INIT,NULL);
- 
-}
- 
-static void mtk_ta_detector(void)
-{
-	int real_v_chrA;
-	int real_v_chrB;
-	kal_bool retransmit = KAL_TRUE;
-	kal_uint32 retransmit_count=0;
- 
-	battery_log(BAT_LOG_CRTI, "mtk_ta_detector() start\n");
-	do {
-		real_v_chrA = battery_meter_get_charger_voltage();
-		mtk_ta_decrease(); 		
-		mtk_ta_decrease(); 		
-		real_v_chrB = battery_meter_get_charger_voltage();
-
-		if(real_v_chrA - real_v_chrB >= 300) {	/* 0.3V */
-			retransmit = KAL_FALSE;
-			is_ta_connect = KAL_TRUE;
-		 } else {
-			retransmit_count++;	
-			
-			battery_log(BAT_LOG_CRTI, "mtk_ta_detector(): retransmit_count =%d, chrA=%d, chrB=%d\n", 
-				retransmit_count, real_v_chrA, real_v_chrB);
-
-			mtk_ta_reset_vchr();
-		}	
-
-		if((retransmit_count == 3) || (BMT_status.charger_exist == KAL_FALSE)) {
-			retransmit = KAL_FALSE;
-			is_ta_connect = KAL_FALSE;
-		}
-		 
-	} while((retransmit == KAL_TRUE) && (ta_cable_out_occur == KAL_FALSE));	 
- 
-
-	battery_log(BAT_LOG_CRTI, "mtk_ta_detector() ta_current_level=%d, real_v_chrA=%d, real_v_chrB=%d, is_ta_connect=%d\n", 
-		ta_current_level, real_v_chrA, real_v_chrB,is_ta_connect);
-
-	battery_log(BAT_LOG_CRTI, "mtk_ta_detector() end, retry_count=%d, ta_cable_out_occur=%d \n",retransmit_count,ta_cable_out_occur);
-}
- 
-static void mtk_tuning_voltage(int curr_level, int target_level)
-{
-	int is_increase = 0;
-	int exec_level = 0;
-	CHR_CURRENT_ENUM	chr_current = CHARGE_CURRENT_70_00_MA;
-	
-	/* if(BMT_status.charger_exist == KAL_TRUE) */
-	if(ta_cable_out_occur == KAL_FALSE) {
-		battery_log(BAT_LOG_CRTI, "mtk_tuning_voltage() start\n");
-	 
-		if(curr_level >= target_level) {
-			exec_level = (curr_level-target_level)/200;
-			is_increase = 0;		 
-		} else {
-			exec_level = (target_level-curr_level)/200;
-			is_increase = 1;
-		}
-
-		if(exec_level == 0) {	/* curr_level == target_level */
-			battery_charging_control(CHARGING_CMD_SET_CURRENT,&chr_current);
-			msleep(50);	// for VChr reading to check error occur or not
-		}
-
-		 
-		battery_log(BAT_LOG_CRTI, "mtk_tuning_voltage() before : ta_current_level=%d, real_v_chr=%d, is_ta_connect=%d, is_increase=%d, exec_level=%d\n", 
-			ta_current_level, battery_meter_get_charger_voltage(), is_ta_connect, is_increase, exec_level);
-	 
-		while((exec_level > 0) && (ta_cable_out_occur == KAL_FALSE)) {
-			if(is_increase == 1)
-				mtk_ta_increase();
-			else
-				mtk_ta_decrease();
-			battery_log(BAT_LOG_CRTI, "mtk_tuning_voltage() after ta_current_level=%d, real_v_chr=%d, is_ta_connect=%d, is_increase=%d, exec_level=%d\n", 
-				ta_current_level, battery_meter_get_charger_voltage(), is_ta_connect, is_increase, exec_level);
-	 
-			exec_level--;
-		}
-	 	 
-		battery_log(BAT_LOG_CRTI, "mtk_tuning_voltage() end\n");
- 	} else {
-		ta_check_chr_type = KAL_TRUE;
-		//is_ta_connect = KAL_FALSE; 
-		battery_log(BAT_LOG_CRTI, "mtk_tuning_voltage(), Cable Out\n");
-	}
-}
- 
-static void select_v_chr_candidate(int curr_vbat, int ta_v_chr_candidate[])
-{
-	battery_log(BAT_LOG_CRTI, "select_v_chr_candidate() start\n");
-	 
-	if(curr_vbat > 4200)		 ta_v_chr_candidate[0]=4600;
-	else if(curr_vbat > 4000)  ta_v_chr_candidate[0]=4400;
-	else if(curr_vbat > 3800)  ta_v_chr_candidate[0]=4200;
-	else if(curr_vbat > 3600)  ta_v_chr_candidate[0]=4000;
-	else						 ta_v_chr_candidate[0]=3800;
- 
-	ta_v_chr_candidate[1]=ta_v_chr_candidate[0]+200;
-	ta_v_chr_candidate[2]=ta_v_chr_candidate[0]+400;
-	ta_v_chr_candidate[3]=ta_v_chr_candidate[0]+600;
- 
-	battery_log(BAT_LOG_CRTI, "select_v_chr_candidate() vbat=%d, candidate=%d,%d,%d\n",
-		curr_vbat, ta_v_chr_candidate[1], ta_v_chr_candidate[2], ta_v_chr_candidate[3]);
-	 
-	battery_log(BAT_LOG_CRTI, "select_v_chr_candidate() end\n");
-}
-
-
-static void mtk_ta_vchr_select(int i,int ta_v_chr_candidate[], int ta_charging_current_candidate[], int *max_charging_current, int *max_charging_current_i)
-{
- 	int current_vchr;
-	kal_bool retransmit = KAL_TRUE;
-	kal_uint32 retransmit_count=0;
-
-	current_vchr = battery_meter_get_charger_voltage();
-	if(ta_current_level != 5000 && current_vchr >= 4900) {	/* pattern error before, so reset vchr to 5V */
-		battery_log(BAT_LOG_CRTI, "mtk_ta_vchr_select() : curr_VChr=%d, ta_current_level=%d\n",current_vchr,ta_current_level);
-
-		mtk_ta_reset_vchr();
-	}
-
-	do {
-		mtk_tuning_voltage(ta_current_level, ta_v_chr_candidate[i]);
-
-		current_vchr = battery_meter_get_charger_voltage();
-		if((abs(current_vchr - ta_current_level) > 300) && (ta_cable_out_occur == KAL_FALSE)) {		/* variation > 0.3V, error occur */
-			retransmit_count++;
-		
-			battery_log(BAT_LOG_CRTI, "mtk_ta_vchr_select(): retransmit_count =%d, cur_chr=%d, ta_current_level=%d\n", 
-				retransmit_count, current_vchr, ta_current_level);
-			
-			mtk_ta_reset_vchr(); 
-		} else {
-			retransmit = KAL_FALSE;
-		}
-
-		if((retransmit_count == 2) || (ta_cable_out_occur == KAL_TRUE)) {
-			retransmit = KAL_FALSE;
-		}
-
-	} while((retransmit == KAL_TRUE) && (ta_cable_out_occur == KAL_FALSE));		
-
-	battery_charging_control(CHARGING_CMD_SET_CURRENT,&ta_charging_current);	//1.5A
-
-	battery_log(BAT_LOG_CRTI, "mtk_ta_vchr_select() : use 1.5A for select max current\n");
-	msleep(900); // over 800ms to avoid interference pattern
-	 
-	ta_charging_current_candidate[i] = battery_meter_get_charging_current_imm();
-
-	/* we hope to choose the less VChr if the current difference between 2 step is not large, so we add weighting for different VChr step */
-	if(i == 1)
-		ta_charging_current_candidate[i] += 100;	// weighting, plus 120mA for Vbat+0.4V
-	else if(i == 2)
-		ta_charging_current_candidate[i] += 50;	// weighting, plug 60mA for Vbat+0.6V
-
-	if(ta_charging_current_candidate[i] > *max_charging_current) {
-		*max_charging_current = ta_charging_current_candidate[i];
-		*max_charging_current_i = i;
-	}
-}
-
-  
-static void mtk_ta_BJT_check(void)
-{
-	int curr_vbat = 0;
-	int curr_current = 0;
-	int vchr = 0;
-	int watt = 0;
-	int i=0,cnt=0;
-
-	for(i=0;i<3;i++)
-	{
-		vchr = battery_meter_get_charger_voltage();
-		curr_vbat = battery_meter_get_battery_voltage(KAL_TRUE);
-		curr_current = battery_meter_get_charging_current_imm();
-		
-		watt = ((vchr - curr_vbat)*curr_current);
-
-		battery_log(BAT_LOG_CRTI, "mtk_ta_BJT_check() vchr=%d, vbat=%d, current=%d, Watt=%d, ta_current_level=%d\n",
-			vchr,curr_vbat,curr_current,watt, ta_current_level);
-	
-		if(watt > BJT_LIMIT)//1.2W
-		{
-			cnt++;
-		}
-		else
-		{
-			break;
-		}
-		msleep(200);
-		
-	}
-
-	if(cnt>=3)
-	{
-		is_ta_connect = KAL_FALSE;
-	}
-
-	battery_log(BAT_LOG_CRTI, "mtk_ta_BJT_check() vchr=%d, vbat=%d, current=%d, Watt=%d, ta_current_level=%d cnt=%d\n",
-		vchr,curr_vbat,curr_current,watt, ta_current_level,cnt);
-}				
- 
-static void battery_pump_express_charger_check(void)
-{
-	if (ta_check_chr_type == KAL_TRUE && BMT_status.charger_type == STANDARD_CHARGER) {
-		mutex_lock(&ta_mutex);
-		wake_lock(&TA_charger_suspend_lock);
-		
-		mtk_ta_reset_vchr();
-		mtk_ta_init();
-		mtk_ta_detector();
-
-		first_vchr_det = KAL_TRUE;
-
-		if(ta_cable_out_occur == KAL_FALSE) {
-			ta_check_chr_type = KAL_FALSE;
-		} else {
-			/* need to re-check if the charger plug out during ta detector */
-			ta_check_chr_type = KAL_TRUE;
-		}
-
-		wake_unlock(&TA_charger_suspend_lock);
-		mutex_unlock(&ta_mutex);
- 	}
-
-}
- 
-static void battery_pump_express_algorithm_start(void)
-{
-	int ta_v_chr_candidate[4]={0,0,0,0};
-	int ta_charging_current_candidate[4]={0,0,0,0};
-	int max_charging_current = 0;
-	int max_charging_current_i = 0;
-	int curr_vbat = 0;
-	int i = 0;
-	int ta_cv_vchr;
-#ifdef HIGH_BATTERY_VOLTAGE_SUPPORT
-		kal_uint32 cv_voltage = 4350;
-#else
-		kal_uint32 cv_voltage = 4200;
-#endif
-	
-	mutex_lock(&ta_mutex);
-	wake_lock(&TA_charger_suspend_lock);
- 
-	if(is_ta_connect == KAL_TRUE) {
-		battery_log(BAT_LOG_CRTI, "mtk_ta_algorithm() start\n");
-				 	 
-		curr_vbat = battery_meter_get_battery_voltage(KAL_TRUE);
-		if( ((curr_vbat-ta_pre_vbat)>100) && (curr_vbat < (cv_voltage - (CV_CHECK_DELAT_FOR_BANDGAP+20))) && (curr_vbat > TA_START_VCHR_TUNUNG_VOLTAGE) ) {		/*cv -0.12V && to avoid screen flash( VBAT less than 3.7V) */
-			ta_pre_vbat = curr_vbat;
-		 
-			select_v_chr_candidate(curr_vbat, ta_v_chr_candidate);
-
-			if(first_vchr_det == KAL_TRUE) {
-				for(i=3 ; i>=1 ; i--) {		/* measure  VBAT+0.8V, VBAT+0.6V then VBAT+0.4V */
-					if(ta_cable_out_occur == KAL_FALSE)
-						mtk_ta_vchr_select(i,ta_v_chr_candidate,ta_charging_current_candidate,&max_charging_current,&max_charging_current_i);
-				}
-
-				first_vchr_det = KAL_FALSE;
-			} else {
-			 	for(i=1 ; i<=3 ; i++) {		/* measure VBAT+0.4V,VBAT+0.6V then VBAT+0.8V */
-					if(ta_cable_out_occur == KAL_FALSE)
-						mtk_ta_vchr_select(i,ta_v_chr_candidate,ta_charging_current_candidate,&max_charging_current,&max_charging_current_i);
-				}
-			}
- 
-			battery_log(BAT_LOG_CRTI, "mtk_ta_algorithm() candidate=%d,%d,%d,%d ; i=%d,%d,%d,%d ; max_charging_current_i=%d\n",
-				ta_v_chr_candidate[0], ta_v_chr_candidate[1], ta_v_chr_candidate[2], ta_v_chr_candidate[3],
-				ta_charging_current_candidate[0], ta_charging_current_candidate[1], ta_charging_current_candidate[2],ta_charging_current_candidate[3],
-				max_charging_current_i
-				);
- 
-			mtk_tuning_voltage(ta_current_level, ta_v_chr_candidate[max_charging_current_i]);
-
-			ta_vchr_tuning = KAL_TRUE;
-			ta_check_ta_control = KAL_TRUE;
-		} else if(curr_vbat >= (cv_voltage - (CV_CHECK_DELAT_FOR_BANDGAP+20))) {
-			if(cv_voltage == 4200)
-				ta_cv_vchr = 4800;
-			else	// cv 4.35V
-				ta_cv_vchr = 5000;
-
-			if(ta_current_level != ta_cv_vchr) {
-				mtk_tuning_voltage(ta_current_level, ta_cv_vchr);
-			}	
-
-			ta_vchr_tuning = KAL_TRUE;
-			ta_check_ta_control = KAL_FALSE;
-
-			battery_log(BAT_LOG_CRTI, "mtk_ta_algorithm(),curr_vbat > cv_voltage, ta_current_level=%d, cv_voltage=%d, ta_cv_vchr=%d,",ta_current_level,cv_voltage,ta_cv_vchr);
-		}
-
-		/* --for normal charging */
-		if((is_ta_connect == KAL_TRUE) && (curr_vbat > TA_START_VCHR_TUNUNG_VOLTAGE) &&(ta_check_ta_control == KAL_TRUE)) {	/* to avoid screen flash( VBAT less than 3.7V) */
-		 	battery_charging_control(CHARGING_CMD_SET_CURRENT,&ta_charging_current);	/* 1.5A */
-			battery_log(BAT_LOG_CRTI, "mtk_ta_algorithm() : detect TA, use 1.5A for normal charging, curr_vbat=%d, ta_pre_vbat=%d, ta_current_level=%d\n",
-				curr_vbat, ta_pre_vbat, ta_current_level);
-			//msleep(1500);
-		}
-		//------------------------
-		 
-		mtk_ta_BJT_check();
-		battery_log(BAT_LOG_CRTI, "mtk_ta_algorithm() end\n");
-	} else {
-		battery_log(BAT_LOG_CRTI, "It's not a TA charger, bypass TA algorithm\n");
-	}
-
-	wake_unlock(&TA_charger_suspend_lock);
-	mutex_unlock(&ta_mutex);
-}
-
-#endif
-
-#if defined(CONFIG_MTK_JEITA_STANDARD_SUPPORT)
-
-static BATTERY_VOLTAGE_ENUM select_jeita_cv(void)
-{
-	BATTERY_VOLTAGE_ENUM cv_voltage;
-
-	if (g_temp_status == TEMP_ABOVE_POS_60) {
-		cv_voltage = JEITA_TEMP_ABOVE_POS_60_CV_VOLTAGE;
-	} else if (g_temp_status == TEMP_POS_45_TO_POS_60) {
-		cv_voltage = JEITA_TEMP_POS_45_TO_POS_60_CV_VOLTAGE;
-	} else if (g_temp_status == TEMP_POS_10_TO_POS_45) {
-#ifdef HIGH_BATTERY_VOLTAGE_SUPPORT
-		cv_voltage = BATTERY_VOLT_04_350000_V;
-#else
-		cv_voltage = JEITA_TEMP_POS_10_TO_POS_45_CV_VOLTAGE;
-#endif
-	} else if (g_temp_status == TEMP_POS_0_TO_POS_10) {
-		cv_voltage = JEITA_TEMP_POS_0_TO_POS_10_CV_VOLTAGE;
-	} else if (g_temp_status == TEMP_NEG_10_TO_POS_0) {
-		cv_voltage = JEITA_TEMP_NEG_10_TO_POS_0_CV_VOLTAGE;
-	} else if (g_temp_status == TEMP_BELOW_NEG_10) {
-		cv_voltage = JEITA_TEMP_BELOW_NEG_10_CV_VOLTAGE;
-	} else {
-		cv_voltage = BATTERY_VOLT_04_200000_V;
-	}
-
-	return cv_voltage;
-}
-
-PMU_STATUS do_jeita_state_machine(void)
-{
-	int previous_g_temp_status;
-	BATTERY_VOLTAGE_ENUM cv_voltage;
-
-	previous_g_temp_status = g_temp_status;
-	/* JEITA battery temp Standard */
-	if (BMT_status.temperature >= TEMP_POS_60_THRESHOLD) {
-		battery_log(BAT_LOG_CRTI,
-				    "[BATTERY] Battery Over high Temperature(%d) !!\n\r",
-				    TEMP_POS_60_THRESHOLD);
-		g_temp_status = TEMP_ABOVE_POS_60;
-		return PMU_STATUS_FAIL;
-	} else if (BMT_status.temperature > TEMP_POS_45_THRESHOLD) {
-		if ((g_temp_status == TEMP_ABOVE_POS_60)
-		    && (BMT_status.temperature >= TEMP_POS_60_THRES_MINUS_X_DEGREE)) {
-			battery_log(BAT_LOG_CRTI,
-					    "[BATTERY] Battery Temperature between %d and %d,not allow charging yet!!\n\r",
-					    TEMP_POS_60_THRES_MINUS_X_DEGREE,
-					    TEMP_POS_60_THRESHOLD);
-			return PMU_STATUS_FAIL;
-		} else {
-			battery_log(BAT_LOG_CRTI,
-					    "[BATTERY] Battery Temperature between %d and %d !!\n\r",
-					    TEMP_POS_45_THRESHOLD, TEMP_POS_60_THRESHOLD);
-			g_temp_status = TEMP_POS_45_TO_POS_60;
-			g_jeita_recharging_voltage = JEITA_TEMP_POS_45_TO_POS_60_RECHARGE_VOLTAGE;
-			v_cc2topoff_threshold = JEITA_TEMP_POS_45_TO_POS_60_CC2TOPOFF_THRESHOLD;
-			charging_full_current = CHARGING_FULL_CURRENT;
-		}
-	} else if (BMT_status.temperature >= TEMP_POS_10_THRESHOLD) {
-		if (((g_temp_status == TEMP_POS_45_TO_POS_60)
-		     && (BMT_status.temperature >= TEMP_POS_45_THRES_MINUS_X_DEGREE))
-		    || ((g_temp_status == TEMP_POS_0_TO_POS_10)
-			&& (BMT_status.temperature <= TEMP_POS_10_THRES_PLUS_X_DEGREE))) {
-			battery_log(BAT_LOG_CRTI,
-					    "[BATTERY] Battery Temperature not recovery to normal temperature charging mode yet!!\n\r");
-		} else {
-			battery_log(BAT_LOG_CRTI,
-					    "[BATTERY] Battery Normal Temperature between %d and %d !!\n\r",
-					    TEMP_POS_10_THRESHOLD, TEMP_POS_45_THRESHOLD);
-
-			g_temp_status = TEMP_POS_10_TO_POS_45;
-#ifdef HIGH_BATTERY_VOLTAGE_SUPPORT
-			g_jeita_recharging_voltage = 4200;
-#else
-			g_jeita_recharging_voltage = JEITA_TEMP_POS_10_TO_POS_45_RECHARGE_VOLTAGE;
-#endif
-			v_cc2topoff_threshold = JEITA_TEMP_POS_10_TO_POS_45_CC2TOPOFF_THRESHOLD;
-			charging_full_current = CHARGING_FULL_CURRENT;
-		}
-	} else if (BMT_status.temperature >= TEMP_POS_0_THRESHOLD) {
-		if ((g_temp_status == TEMP_NEG_10_TO_POS_0 || g_temp_status == TEMP_BELOW_NEG_10)
-		    && (BMT_status.temperature <= TEMP_POS_0_THRES_PLUS_X_DEGREE)) {
-			if (g_temp_status == TEMP_NEG_10_TO_POS_0) {
-				battery_log(BAT_LOG_CRTI,
-						    "[BATTERY] Battery Temperature between %d and %d !!\n\r",
-						    TEMP_POS_0_THRES_PLUS_X_DEGREE,
-						    TEMP_POS_10_THRESHOLD);
-			}
-			if (g_temp_status == TEMP_BELOW_NEG_10) {
-				battery_log(BAT_LOG_CRTI,
-						    "[BATTERY] Battery Temperature between %d and %d,not allow charging yet!!\n\r",
-						    TEMP_POS_0_THRESHOLD,
-						    TEMP_POS_0_THRES_PLUS_X_DEGREE);
-				return PMU_STATUS_FAIL;
-			}
-		} else {
-			battery_log(BAT_LOG_CRTI,
-					    "[BATTERY] Battery Temperature between %d and %d !!\n\r",
-					    TEMP_POS_0_THRESHOLD, TEMP_POS_10_THRESHOLD);
-			g_temp_status = TEMP_POS_0_TO_POS_10;
-			g_jeita_recharging_voltage = JEITA_TEMP_POS_0_TO_POS_10_RECHARGE_VOLTAGE;
-			v_cc2topoff_threshold = JEITA_TEMP_POS_0_TO_POS_10_CC2TOPOFF_THRESHOLD;
-			charging_full_current = CHARGING_FULL_CURRENT;
-		}
-	} else if (BMT_status.temperature >= TEMP_NEG_10_THRESHOLD) {
-		if ((g_temp_status == TEMP_BELOW_NEG_10)
-		    && (BMT_status.temperature <= TEMP_NEG_10_THRES_PLUS_X_DEGREE)) {
-			battery_log(BAT_LOG_CRTI,
-					    "[BATTERY] Battery Temperature between %d and %d,not allow charging yet!!\n\r",
-					    TEMP_NEG_10_THRESHOLD, TEMP_NEG_10_THRES_PLUS_X_DEGREE);
-			return PMU_STATUS_FAIL;
-		} else {
-			battery_log(BAT_LOG_CRTI,
-					    "[BATTERY] Battery Temperature between %d and %d !!\n\r",
-					    TEMP_NEG_10_THRESHOLD, TEMP_POS_0_THRESHOLD);
-			g_temp_status = TEMP_NEG_10_TO_POS_0;
-			g_jeita_recharging_voltage = JEITA_TEMP_NEG_10_TO_POS_0_RECHARGE_VOLTAGE;
-			v_cc2topoff_threshold = JEITA_TEMP_NEG_10_TO_POS_0_CC2TOPOFF_THRESHOLD;
-			charging_full_current = JEITA_NEG_10_TO_POS_0_FULL_CURRENT;
-		}
-	} else {
-		battery_log(BAT_LOG_CRTI,
-				    "[BATTERY] Battery below low Temperature(%d) !!\n\r",
-				    TEMP_NEG_10_THRESHOLD);
-		g_temp_status = TEMP_BELOW_NEG_10;
-		return PMU_STATUS_FAIL;
-	}
-
-	/* set CV after temperature changed */
-	if (g_temp_status != previous_g_temp_status) {
-		cv_voltage = select_jeita_cv();
-		battery_charging_control(CHARGING_CMD_SET_CV_VOLTAGE, &cv_voltage);
-	}
-
-	return PMU_STATUS_OK;
-}
-
-
-static void set_jeita_charging_current(void)
-{
-#ifdef CONFIG_USB_IF
-	if (BMT_status.charger_type == STANDARD_HOST)
-		return;
-#endif
-
-	if (g_temp_status == TEMP_NEG_10_TO_POS_0) {
-		g_temp_CC_value = CHARGE_CURRENT_200_00_MA;	/* for low temp */
-		battery_log(BAT_LOG_CRTI, "[BATTERY] JEITA set charging current : %d\r\n",
-				    g_temp_CC_value);
-	}
-}
-
-#endif
-
-bool get_usb_current_unlimited(void)
-{
-	if (BMT_status.charger_type == STANDARD_HOST || BMT_status.charger_type == CHARGING_HOST)
-		return usb_unlimited;
-	else
-		return false;
-}
-
-void set_usb_current_unlimited(bool enable)
-{
-	usb_unlimited = enable;
-}
-
-void select_charging_curret_bcct(void)
-{
-	/* done on set_bat_charging_current_limit */
-}
-
-
-kal_uint32 set_bat_charging_current_limit(int current_limit)
-{
-	battery_log(BAT_LOG_CRTI, "[BATTERY] set_bat_charging_current_limit (%d)\r\n",
-			    current_limit);
-
-	if (current_limit != -1) {
-		g_bcct_flag = 1;
-
-		if (current_limit < 70)
-			g_temp_CC_value = CHARGE_CURRENT_0_00_MA;
-		else if (current_limit < 200)
-			g_temp_CC_value = CHARGE_CURRENT_70_00_MA;
-		else if (current_limit < 300)
-			g_temp_CC_value = CHARGE_CURRENT_200_00_MA;
-		else if (current_limit < 400)
-			g_temp_CC_value = CHARGE_CURRENT_300_00_MA;
-		else if (current_limit < 450)
-			g_temp_CC_value = CHARGE_CURRENT_400_00_MA;
-		else if (current_limit < 550)
-			g_temp_CC_value = CHARGE_CURRENT_450_00_MA;
-		else if (current_limit < 650)
-			g_temp_CC_value = CHARGE_CURRENT_550_00_MA;
-		else if (current_limit < 700)
-			g_temp_CC_value = CHARGE_CURRENT_650_00_MA;
-		else if (current_limit < 800)
-			g_temp_CC_value = CHARGE_CURRENT_700_00_MA;
-		else if (current_limit < 900)
-			g_temp_CC_value = CHARGE_CURRENT_800_00_MA;
-		else if (current_limit < 1000)
-			g_temp_CC_value = CHARGE_CURRENT_900_00_MA;
-		else if (current_limit < 1100)
-			g_temp_CC_value = CHARGE_CURRENT_1000_00_MA;
-		else if (current_limit < 1200)
-			g_temp_CC_value = CHARGE_CURRENT_1100_00_MA;
-		else if (current_limit < 1300)
-			g_temp_CC_value = CHARGE_CURRENT_1200_00_MA;
-		else if (current_limit < 1400)
-			g_temp_CC_value = CHARGE_CURRENT_1300_00_MA;
-		else if (current_limit < 1500)
-			g_temp_CC_value = CHARGE_CURRENT_1400_00_MA;
-		else if (current_limit < 1600)
-			g_temp_CC_value = CHARGE_CURRENT_1500_00_MA;
-		else if (current_limit == 1600)
-			g_temp_CC_value = CHARGE_CURRENT_1600_00_MA;
-		else
-			g_temp_CC_value = CHARGE_CURRENT_450_00_MA;
-	} else {
-		/* change to default current setting */
-		g_bcct_flag = 0;
-	}
-
-	wake_up_bat3();
-
-	return g_bcct_flag;
-}
-
-void set_bat_sw_cv_charging_current_limit(int current_limit)
-{
-    battery_log(BAT_LOG_CRTI, "[BATTERY] set_bat_sw_cv_charging_current_limit (%d)\r\n", current_limit);
-
-    if(current_limit <= CHARGE_CURRENT_70_00_MA)         ulc_cv_charging_current=CHARGE_CURRENT_0_00_MA;
-    else if(current_limit <= CHARGE_CURRENT_200_00_MA)   ulc_cv_charging_current=CHARGE_CURRENT_70_00_MA;
-    else if(current_limit <= CHARGE_CURRENT_300_00_MA)   ulc_cv_charging_current=CHARGE_CURRENT_200_00_MA;
-    else if(current_limit <= CHARGE_CURRENT_400_00_MA)   ulc_cv_charging_current=CHARGE_CURRENT_300_00_MA;
-    else if(current_limit <= CHARGE_CURRENT_450_00_MA)   ulc_cv_charging_current=CHARGE_CURRENT_400_00_MA;
-    else if(current_limit <= CHARGE_CURRENT_550_00_MA)   ulc_cv_charging_current=CHARGE_CURRENT_450_00_MA;
-    else if(current_limit <= CHARGE_CURRENT_650_00_MA)   ulc_cv_charging_current=CHARGE_CURRENT_550_00_MA;
-    else if(current_limit <= CHARGE_CURRENT_700_00_MA)   ulc_cv_charging_current=CHARGE_CURRENT_650_00_MA;
-    else if(current_limit <= CHARGE_CURRENT_800_00_MA)   ulc_cv_charging_current=CHARGE_CURRENT_700_00_MA;
-    else if(current_limit <= CHARGE_CURRENT_900_00_MA)   ulc_cv_charging_current=CHARGE_CURRENT_800_00_MA;
-    else if(current_limit <= CHARGE_CURRENT_1000_00_MA)  ulc_cv_charging_current=CHARGE_CURRENT_900_00_MA;
-    else if(current_limit <= CHARGE_CURRENT_1100_00_MA)  ulc_cv_charging_current=CHARGE_CURRENT_1000_00_MA;
-    else if(current_limit <= CHARGE_CURRENT_1200_00_MA)  ulc_cv_charging_current=CHARGE_CURRENT_1100_00_MA;
-    else if(current_limit <= CHARGE_CURRENT_1300_00_MA)  ulc_cv_charging_current=CHARGE_CURRENT_1200_00_MA;
-    else if(current_limit <= CHARGE_CURRENT_1400_00_MA)  ulc_cv_charging_current=CHARGE_CURRENT_1300_00_MA;
-    else if(current_limit <= CHARGE_CURRENT_1500_00_MA)  ulc_cv_charging_current=CHARGE_CURRENT_1400_00_MA;
-    else if(current_limit <= CHARGE_CURRENT_1600_00_MA)  ulc_cv_charging_current=CHARGE_CURRENT_1500_00_MA;
-    else                            ulc_cv_charging_current=CHARGE_CURRENT_450_00_MA;
-}
-
-void select_charging_curret(void)
-{
-	if (g_ftm_battery_flag) {
-		battery_log(BAT_LOG_CRTI, "[BATTERY] FTM charging : %d\r\n",
-				    charging_level_data[0]);
-		g_temp_CC_value =  AC_CHARGER_CURRENT;
-	} else {
-		if (BMT_status.charger_type == STANDARD_HOST) {
-#ifdef CONFIG_USB_IF
-			{
-				if (g_usb_state == USB_SUSPEND) {
-					g_temp_CC_value = USB_CHARGER_CURRENT_SUSPEND;
-				} else if (g_usb_state == USB_UNCONFIGURED) {
-					g_temp_CC_value = USB_CHARGER_CURRENT_UNCONFIGURED;
-				} else if (g_usb_state == USB_CONFIGURED) {
-					g_temp_CC_value = USB_CHARGER_CURRENT_CONFIGURED;
-				} else {
-					g_temp_CC_value = USB_CHARGER_CURRENT_UNCONFIGURED;
-				}
-
-				battery_log(BAT_LOG_CRTI,
-						    "[BATTERY] STANDARD_HOST CC mode charging : %d on %d state\r\n",
-						    g_temp_CC_value, g_usb_state);
-			}
-#else
-			{
-				g_temp_CC_value = USB_CHARGER_CURRENT;
-			}
-#endif
-		} else if (BMT_status.charger_type == NONSTANDARD_CHARGER) {
-			g_temp_CC_value = NON_STD_AC_CHARGER_CURRENT;
-		} else if (BMT_status.charger_type == STANDARD_CHARGER) {
-			g_temp_CC_value = AC_CHARGER_CURRENT;
-#if defined(CONFIG_MTK_PUMP_EXPRESS_SUPPORT)
-			if(is_ta_connect == KAL_TRUE && ta_vchr_tuning == KAL_TRUE)
-				g_temp_CC_value = CHARGE_CURRENT_1500_00_MA;
-#endif
-		} else if (BMT_status.charger_type == CHARGING_HOST) 
-		{
-
-#if defined(CHARGING_HOST_SUPPORT)
-			if (g_usb_state == USB_SUSPEND) {
-				g_temp_CC_value = USB_CHARGER_CURRENT;
-			} else if (g_usb_state == USB_UNCONFIGURED) {
-				g_temp_CC_value = USB_CHARGER_CURRENT;
-			} else if (g_usb_state == USB_CONFIGURED) {
-			g_temp_CC_value = CHARGING_HOST_CHARGER_CURRENT;
-			} else {
-				g_temp_CC_value = USB_CHARGER_CURRENT;
-			}
-			
-			battery_log(BAT_LOG_CRTI,
-						"[BATTERY] CHARGING_HOST CC mode charging : %d on %d state\r\n",
-						g_temp_CC_value, g_usb_state);
-#else	
-			g_temp_CC_value = CHARGING_HOST_CHARGER_CURRENT;
-#endif	
-		} else if (BMT_status.charger_type == APPLE_2_1A_CHARGER) {
-			g_temp_CC_value = APPLE_2_1A_CHARGER_CURRENT;
-		} else if (BMT_status.charger_type == APPLE_1_0A_CHARGER) {
-			g_temp_CC_value = APPLE_1_0A_CHARGER_CURRENT;
-		} else if (BMT_status.charger_type == APPLE_0_5A_CHARGER) {
-			g_temp_CC_value = APPLE_0_5A_CHARGER_CURRENT;
-		} else {
-			g_temp_CC_value = CHARGE_CURRENT_70_00_MA;
-		}
-			g_temp_CC_value = AC_CHARGER_CURRENT;
-		battery_log(BAT_LOG_CRTI, "[BATTERY] Default CC mode charging : %d\r\n",
-				    g_temp_CC_value);
-
-#if defined(CONFIG_MTK_JEITA_STANDARD_SUPPORT)
-		set_jeita_charging_current();
-#endif
-	}
-}
-
-
-
-
-static kal_uint32 charging_full_check(void)
-{
-	kal_uint32 status = KAL_FALSE;
-
-#if defined(POST_TIME_ENABLE)
-	static kal_uint32 post_charging_time = 0; 
-
-	if (post_charging_time >= POST_CHARGING_TIME) {
-		status = KAL_TRUE;
-		post_charging_time = 0;
-
-		battery_log(BAT_LOG_CRTI,
-				    "[BATTERY] Battery real full and disable charging on %d mA\n",
-				    BMT_status.ICharging);
-	} else if (post_charging_time > 0) {
-		post_charging_time += BAT_TASK_PERIOD;
-		battery_log(BAT_LOG_CRTI,
-				    "[BATTERY] post_charging_time=%d,POST_CHARGING_TIME=%d\n",
-				    post_charging_time, POST_CHARGING_TIME);
-	} else if ((BMT_status.TOPOFF_charging_time > 60)
-		   && (BMT_status.ICharging <= charging_full_current)) {
-		post_charging_time = BAT_TASK_PERIOD;
-		battery_log(BAT_LOG_CRTI,
-				    "[BATTERY] Enter Post charge, post_charging_time=%d,POST_CHARGING_TIME=%d\n",
-				    post_charging_time, POST_CHARGING_TIME);
-	} else {
-		post_charging_time = 0;
-	}
-#else
-	static kal_uint8 full_check_count = 0;
-
-	if (BMT_status.ICharging <= charging_full_current) {
-		full_check_count++;
-		if (6 == full_check_count) {
-			status = KAL_TRUE;
-			full_check_count = 0;
-			battery_log(BAT_LOG_CRTI,
-					    "[BATTERY] Battery full and disable charging on %d mA\n",
-					    BMT_status.ICharging);
-		}
-	} else {
-		full_check_count = 0;
-	}
-#endif
-
-	return status;
-}
-
-
-static void charging_current_calibration(void)
-{
-	kal_int32 bat_isense_offset;
-#if 0
-	kal_int32 bat_vol = battery_meter_get_battery_voltage();
-	kal_int32 Vsense = battery_meter_get_VSense();
-
-	bat_isense_offset = bat_vol - Vsense;
-
-	battery_log(BAT_LOG_CRTI, "[BATTERY] bat_vol=%d, Vsense=%d, offset=%d \r\n",
-			    bat_vol, Vsense, bat_isense_offset);
-#else
-	bat_isense_offset = 0;
-#endif
-
-	battery_meter_sync(bat_isense_offset);
-}
-
-static void pchr_sw_cv_charing_current_check(void)
-{
-	kal_bool charging_enable = KAL_TRUE;
-	kal_uint32 csdac_full_flag = KAL_TRUE;
-
-	battery_charging_control(CHARGING_CMD_SET_CURRENT,&ulc_cv_charging_current);
-	battery_charging_control(CHARGING_CMD_ENABLE,&charging_enable);
-
-	msleep(192); 
-
-	battery_charging_control(CHARGING_CMD_GET_CSDAC_FALL_FLAG,&csdac_full_flag);
-
-	if(csdac_full_flag == KAL_TRUE) {
-		ulc_cv_charging_current = battery_meter_get_charging_current() * 100;	/* get immedeate charging current and align to enum value */
-	}	
-	
-	while(csdac_full_flag == KAL_TRUE &&  ulc_cv_charging_current !=CHARGE_CURRENT_0_00_MA) {
-		set_bat_sw_cv_charging_current_limit(ulc_cv_charging_current);
-		battery_charging_control(CHARGING_CMD_SET_CURRENT,&ulc_cv_charging_current);
-		ulc_cv_charging_current_flag = KAL_TRUE;
-
-		msleep(192);	/* large than 512 code x 0.25ms */
-		
-		battery_charging_control(CHARGING_CMD_GET_CSDAC_FALL_FLAG,&csdac_full_flag);
-
-		battery_log(BAT_LOG_CRTI, "[BATTERY] Sw CV set charging current, csdac_full_flag=%d, current=%d !\n",csdac_full_flag,ulc_cv_charging_current);
-	}
-
-	if(ulc_cv_charging_current == CHARGE_CURRENT_0_00_MA)
-		battery_log(BAT_LOG_CRTI, "[BATTERY] Sw CV set charging current Error!\n");
-}
-
-static void pchr_turn_on_charging(void)
-{
-#if !defined(CONFIG_MTK_JEITA_STANDARD_SUPPORT)
-	BATTERY_VOLTAGE_ENUM cv_voltage;
-#endif
-	kal_uint32 charging_enable = KAL_TRUE;
-
-	battery_log(BAT_LOG_FULL, "[BATTERY] pchr_turn_on_charging()!\r\n");
-
-	if (BMT_status.bat_charging_state == CHR_ERROR) {
-		battery_log(BAT_LOG_CRTI, "[BATTERY] Charger Error, turn OFF charging !\n");
-
-		charging_enable = KAL_FALSE;
-	} else if ((g_platform_boot_mode == META_BOOT) || (g_platform_boot_mode == ADVMETA_BOOT)) {
-		battery_log(BAT_LOG_CRTI,
-				    "[BATTERY] In meta or advanced meta mode, disable charging.\n");
-		charging_enable = KAL_FALSE;
-	} else {
-		/*HW initialization */
-		battery_log(BAT_LOG_FULL, "charging_hw_init\n");
-		battery_charging_control(CHARGING_CMD_INIT, NULL);
-
-#if defined(CONFIG_MTK_PUMP_EXPRESS_SUPPORT)
-		battery_pump_express_algorithm_start();
-#endif
-
-		/* Set Charging Current */
-		if (get_usb_current_unlimited()) {
-			g_temp_CC_value = AC_CHARGER_CURRENT;
-			battery_log(BAT_LOG_FULL, "USB_CURRENT_UNLIMITED, use AC_CHARGER_CURRENT\n" );
-		} else {
-			if (g_bcct_flag == 1) {
-				battery_log(BAT_LOG_FULL,
-					    "[BATTERY] select_charging_curret_bcct !\n");
-				select_charging_curret_bcct();
-			} else {
-				battery_log(BAT_LOG_FULL, "[BATTERY] select_charging_current !\n");
-				select_charging_curret();
-			}
-		}
-
-		if (g_temp_CC_value == CHARGE_CURRENT_0_00_MA) {
-			charging_enable = KAL_FALSE;
-			battery_log(BAT_LOG_CRTI,
-					"[BATTERY] charging current is set 0mA, turn off charging !\r\n");
-		} else {
-#if defined(CONFIG_MTK_PUMP_EXPRESS_SUPPORT)
-			if(ta_check_ta_control == KAL_FALSE)
-#endif	
-			{
-				if(ulc_cv_charging_current_flag == KAL_TRUE)
-					battery_charging_control(CHARGING_CMD_SET_CURRENT,&ulc_cv_charging_current);
-				else
-					battery_charging_control(CHARGING_CMD_SET_CURRENT,&g_temp_CC_value);
-			}
-
-			/* Set CV */
-#if !defined(CONFIG_MTK_JEITA_STANDARD_SUPPORT)
-#ifdef HIGH_BATTERY_VOLTAGE_SUPPORT
-			cv_voltage = BATTERY_VOLT_04_350000_V;
-#else
-			cv_voltage = BATTERY_VOLT_04_200000_V;
-#endif
-			battery_charging_control(CHARGING_CMD_SET_CV_VOLTAGE, &cv_voltage);
-#endif
-		}
-	}
-
-	/* enable/disable charging */
-	battery_log(BAT_LOG_CRTI, "[BATTERY] pchr_turn_on_charging(), enable =%d \r\n",
-			    charging_enable);
-	battery_charging_control(CHARGING_CMD_ENABLE, &charging_enable);
-
-
-}
-
-
-PMU_STATUS BAT_PreChargeModeAction(void)
-{
-	battery_log(BAT_LOG_CRTI, "[BATTERY] Pre-CC mode charge, timer=%d on %d !!\n\r",
-			    BMT_status.PRE_charging_time, BMT_status.total_charging_time);
-
-	BMT_status.PRE_charging_time += BAT_TASK_PERIOD;
-	BMT_status.CC_charging_time = 0;
-	BMT_status.TOPOFF_charging_time = 0;
-	BMT_status.total_charging_time += BAT_TASK_PERIOD;
-
-	select_charging_curret();
-	ulc_cv_charging_current = g_temp_CC_value;
-	ulc_cv_charging_current_flag = KAL_FALSE;
-
-	if (BMT_status.UI_SOC == 100) {
-		BMT_status.bat_charging_state = CHR_BATFULL;
-		BMT_status.bat_full = KAL_TRUE;
-		g_charging_full_reset_bat_meter = KAL_TRUE;
-	} else if (BMT_status.bat_vol > V_PRE2CC_THRES) {
-		BMT_status.bat_charging_state = CHR_CC;
-	}
-
-#if defined(CONFIG_MTK_PUMP_EXPRESS_SUPPORT)//defined(MTK_LINEAR_CHARGER_NO_DISCHARGE)    
-	// no disable charging
-#else
-	{
-		kal_bool charging_enable = KAL_FALSE;
-
-		/*Charging 9s and discharging 1s : start */
-		battery_charging_control(CHARGING_CMD_ENABLE, &charging_enable);
-		msleep(1000);
-	}
-#endif
-
-	charging_current_calibration();
-	pchr_turn_on_charging();
-
-	return PMU_STATUS_OK;
-}
-
-
-PMU_STATUS BAT_ConstantCurrentModeAction(void)
-{
-	battery_log(BAT_LOG_CRTI, "[BATTERY] CC mode charge, timer=%d on %d !!\n\r",
-			    BMT_status.CC_charging_time, BMT_status.total_charging_time);
-
-	BMT_status.PRE_charging_time = 0;
-	BMT_status.CC_charging_time += BAT_TASK_PERIOD;
-	BMT_status.TOPOFF_charging_time = 0;
-	BMT_status.total_charging_time += BAT_TASK_PERIOD;
-
-	ulc_cv_charging_current_flag = KAL_FALSE;
-	ulc_cv_charging_current = g_temp_CC_value;
-
-	if (BMT_status.bat_vol > v_cc2topoff_threshold) {
-		BMT_status.bat_charging_state = CHR_TOP_OFF;
-	}
-
-#if defined(CONFIG_MTK_PUMP_EXPRESS_SUPPORT)//defined(MTK_LINEAR_CHARGER_NO_DISCHARGE)
-	// no disable charging#else
-#else
-	{
-		kal_bool charging_enable = KAL_FALSE;
-
-		/* Charging 9s and discharging 1s : start */
-		battery_charging_control(CHARGING_CMD_ENABLE, &charging_enable);
-		msleep(1000);
-	}	
-#endif
-
-	charging_current_calibration();
-
-	pchr_turn_on_charging();
-
-	return PMU_STATUS_OK;
-}
-
-
-PMU_STATUS BAT_TopOffModeAction(void)
-{
-	kal_uint32 charging_enable = KAL_FALSE;
-#ifdef HIGH_BATTERY_VOLTAGE_SUPPORT
-	kal_uint32 cv_voltage = 4350;
-#else
-	kal_uint32 cv_voltage = 4200;
-#endif
-
-	battery_log(BAT_LOG_CRTI, "[BATTERY] Top Off mode charge, timer=%d on %d !!\n\r",
-			    BMT_status.TOPOFF_charging_time, BMT_status.total_charging_time);
-
-	BMT_status.PRE_charging_time = 0;
-	BMT_status.CC_charging_time = 0;
-	BMT_status.TOPOFF_charging_time += BAT_TASK_PERIOD;
-	BMT_status.total_charging_time += BAT_TASK_PERIOD;
-
-
-	if(BMT_status.bat_vol > (cv_voltage-CV_CHECK_DELAT_FOR_BANDGAP)) {	/* CV - 0.08V */
-		pchr_sw_cv_charing_current_check();
-	}
-	pchr_turn_on_charging();
-
-	if ((BMT_status.TOPOFF_charging_time >= MAX_CV_CHARGING_TIME)
-	    || (charging_full_check() == KAL_TRUE)) {
-		BMT_status.bat_charging_state = CHR_BATFULL;
-		BMT_status.bat_full = KAL_TRUE;
-		g_charging_full_reset_bat_meter = KAL_TRUE;
-
-		/*  Disable charging */
-		battery_charging_control(CHARGING_CMD_ENABLE, &charging_enable);
-	}
-
-	return PMU_STATUS_OK;
-}
-
-
-PMU_STATUS BAT_BatteryFullAction(void)
-{
-	kal_uint32 charging_enable = KAL_FALSE;
-
-	battery_log(BAT_LOG_CRTI, "[BATTERY] Battery full !!\n\r");
-
-	BMT_status.bat_full = KAL_TRUE;
-	BMT_status.total_charging_time = 0;
-	BMT_status.PRE_charging_time = 0;
-	BMT_status.CC_charging_time = 0;
-	BMT_status.TOPOFF_charging_time = 0;
-	BMT_status.POSTFULL_charging_time = 0;
-	BMT_status.bat_in_recharging_state = KAL_FALSE;
-
-
-#if defined(CONFIG_MTK_JEITA_STANDARD_SUPPORT)
-	if (BMT_status.bat_vol < g_jeita_recharging_voltage)
-#else
-	if (BMT_status.bat_vol < RECHARGING_VOLTAGE)
-#endif
-	{
-		battery_log(BAT_LOG_CRTI,
-				    "[BATTERY] Battery Enter Re-charging!! , vbat=(%d)\n\r",
-				    BMT_status.bat_vol);
-
-		BMT_status.bat_in_recharging_state = KAL_TRUE;
-		BMT_status.bat_charging_state = CHR_CC;
-		ulc_cv_charging_current = g_temp_CC_value;
-		ulc_cv_charging_current_flag = KAL_FALSE;
-	}
-
-	/*  Disable charging */
-	battery_charging_control(CHARGING_CMD_ENABLE, &charging_enable);
-
-	return PMU_STATUS_OK;
-}
-
-
-PMU_STATUS BAT_BatteryHoldAction(void)
-{
-	kal_uint32 charging_enable;
-
-	battery_log(BAT_LOG_CRTI, "[BATTERY] Hold mode !!\n\r");
-
-	if (BMT_status.bat_vol < TALKING_RECHARGE_VOLTAGE || g_call_state == CALL_IDLE) {
-		BMT_status.bat_charging_state = CHR_CC;
-		battery_log(BAT_LOG_CRTI,
-				    "[BATTERY] Exit Hold mode and Enter CC mode !!\n\r");
-	}
-
-	/*  Disable charger */
-	charging_enable = KAL_FALSE;
-	battery_charging_control(CHARGING_CMD_ENABLE, &charging_enable);
-
-	return PMU_STATUS_OK;
-}
-
-
-PMU_STATUS BAT_BatteryStatusFailAction(void)
-{
-	kal_uint32 charging_enable;
-
-	battery_log(BAT_LOG_CRTI, "[BATTERY] BAD Battery status... Charging Stop !!\n\r");
-
-#if defined(CONFIG_MTK_JEITA_STANDARD_SUPPORT)
-	if ((g_temp_status == TEMP_ABOVE_POS_60) || (g_temp_status == TEMP_BELOW_NEG_10)) {
-		temp_error_recovery_chr_flag = KAL_FALSE;
-	}
-	if ((temp_error_recovery_chr_flag == KAL_FALSE) && (g_temp_status != TEMP_ABOVE_POS_60)
-	    && (g_temp_status != TEMP_BELOW_NEG_10)) {
-		temp_error_recovery_chr_flag = KAL_TRUE;
-		BMT_status.bat_charging_state = CHR_PRE;
-	}
-#endif
-
-	BMT_status.total_charging_time = 0;
-	BMT_status.PRE_charging_time = 0;
-	BMT_status.CC_charging_time = 0;
-	BMT_status.TOPOFF_charging_time = 0;
-	BMT_status.POSTFULL_charging_time = 0;
-
-	/*  Disable charger */
-	charging_enable = KAL_FALSE;
-	battery_charging_control(CHARGING_CMD_ENABLE, &charging_enable);
-
-	return PMU_STATUS_OK;
-}
-
-
-void mt_battery_charging_algorithm(void)
-{
-#if defined(CONFIG_MTK_PUMP_EXPRESS_SUPPORT)
-	battery_pump_express_charger_check();
-#endif
-	switch (BMT_status.bat_charging_state) {
-	case CHR_PRE:
-		BAT_PreChargeModeAction();
-		break;
-
-	case CHR_CC:
-		BAT_ConstantCurrentModeAction();
-		break;
-
-	case CHR_TOP_OFF:
-		BAT_TopOffModeAction();
-		break;
-
-	case CHR_BATFULL:
-		BAT_BatteryFullAction();
-		break;
-
-	case CHR_HOLD:
-		BAT_BatteryHoldAction();
-		break;
-
-	case CHR_ERROR:
-		BAT_BatteryStatusFailAction();
-		break;
-	}
-
-}
diff --git a/drivers/power/mediatek/switch_charging.c~ b/drivers/power/mediatek/switch_charging.c~
deleted file mode 100755
index 52479ed..0000000
--- a/drivers/power/mediatek/switch_charging.c~
+++ /dev/null
@@ -1,918 +0,0 @@
-/*****************************************************************************
- *
- * Filename:
- * ---------
- *    linear_charging.c
- *
- * Project:
- * --------
- *   ALPS_Software
- *
- * Description:
- * ------------
- *   This file implements the interface between BMT and ADC scheduler.
- *
- * Author:
- * -------
- *  Oscar Liu
- *
- *============================================================================
-  * $Revision:   1.0  $
- * $Modtime:   11 Aug 2005 10:28:16  $
- * $Log:   //mtkvs01/vmdata/Maui_sw/archives/mcu/hal/peripheral/inc/bmt_chr_setting.h-arc  $
- *
- * 03 05 2015 wy.chuang
- * [ALPS01921641] [L1_merge] for PMIC and charging
- * .
- *             HISTORY
- * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
- *------------------------------------------------------------------------------
- *------------------------------------------------------------------------------
- * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
- *============================================================================
- ****************************************************************************/
-#include <linux/kernel.h>
-#include <mach/battery_common.h>
-#include <mach/charging.h>
-#include "cust_charging.h"
-#include <mach/mt_boot.h>
-#include <mach/battery_meter.h>
-
-#if defined(CONFIG_MTK_PUMP_EXPRESS_PLUS_SUPPORT)
-#include <linux/mutex.h>
-#include <linux/wakelock.h>
-#include <linux/delay.h>
-#if !defined(TA_AC_CHARGING_CURRENT)
-#include "cust_pe.h"
-#endif
-#endif
-
-#ifdef CONFIG_MTK_DUAL_INPUT_CHARGER_SUPPORT
-#include <mach/diso.h>
-#endif
-
- /* ============================================================ // */
- /* define */
- /* ============================================================ // */
- /* cut off to full */
-#define POST_CHARGING_TIME		30 * 60		/* 30mins */
-#define FULL_CHECK_TIMES		6
-
- /* ============================================================ // */
- /* global variable */
- /* ============================================================ // */
-kal_uint32 g_bcct_flag = 0;
-kal_uint32 g_bcct_value = 0;
-kal_uint32 g_full_check_count = 0;
-CHR_CURRENT_ENUM g_temp_CC_value = CHARGE_CURRENT_0_00_MA;
-CHR_CURRENT_ENUM g_temp_input_CC_value = CHARGE_CURRENT_0_00_MA;
-kal_uint32 g_usb_state = USB_UNCONFIGURED;
-static bool usb_unlimited=false;
-
-  /* ///////////////////////////////////////////////////////////////////////////////////////// */
-  /* // PUMP EXPRESS */
-  /* ///////////////////////////////////////////////////////////////////////////////////////// */
-#if defined(CONFIG_MTK_PUMP_EXPRESS_PLUS_SUPPORT)
-struct wake_lock TA_charger_suspend_lock;
-kal_bool ta_check_chr_type = KAL_TRUE;
-kal_bool ta_cable_out_occur = KAL_FALSE;
-kal_bool is_ta_connect = KAL_FALSE;
-kal_bool ta_vchr_tuning = KAL_TRUE;
-int ta_v_chr_org = 0;
-#endif
-
-  /* ///////////////////////////////////////////////////////////////////////////////////////// */
-  /* // JEITA */
-  /* ///////////////////////////////////////////////////////////////////////////////////////// */
-#if defined(CONFIG_MTK_JEITA_STANDARD_SUPPORT)
-int g_temp_status = TEMP_POS_10_TO_POS_45;
-kal_bool temp_error_recovery_chr_flag = KAL_TRUE;
-#endif
-fdfdfdf
-
-
- /* ============================================================ // */
- /* function prototype */
- /* ============================================================ // */
-
-
- /* ============================================================ // */
- /* extern variable */
- /* ============================================================ // */
-extern int g_platform_boot_mode;
-
- /* ============================================================ // */
- /* extern function */
- /* ============================================================ // */
-
-
- /* ============================================================ // */
-void BATTERY_SetUSBState(int usb_state_value)
-{
-#if defined(CONFIG_POWER_EXT)
-	battery_log(BAT_LOG_CRTI, "[BATTERY_SetUSBState] in FPGA/EVB, no service\r\n");
-#else
-	if ((usb_state_value < USB_SUSPEND) || ((usb_state_value > USB_CONFIGURED))) {
-		battery_log(BAT_LOG_CRTI,
-				    "[BATTERY] BAT_SetUSBState Fail! Restore to default value\r\n");
-		usb_state_value = USB_UNCONFIGURED;
-	} else {
-		battery_log(BAT_LOG_CRTI, "[BATTERY] BAT_SetUSBState Success! Set %d\r\n",
-				    usb_state_value);
-		g_usb_state = usb_state_value;
-	}
-#endif
-}
-
-
-kal_uint32 get_charging_setting_current(void)
-{
-	return g_temp_CC_value;
-}
-
-#if defined(CONFIG_MTK_PUMP_EXPRESS_PLUS_SUPPORT)
-static DEFINE_MUTEX(ta_mutex);
-
-static void set_ta_charging_current(void)
-{
-	int real_v_chrA = 0;
-	
-	real_v_chrA = battery_meter_get_charger_voltage();
-	battery_log(BAT_LOG_CRTI, "set_ta_charging_current, chrA=%d, chrB=%d\n", 
-		ta_v_chr_org, real_v_chrA);
-
-	if((real_v_chrA - ta_v_chr_org) > 3000) {
-		g_temp_input_CC_value = TA_AC_9V_INPUT_CURRENT;  //TA = 9V		
-		g_temp_CC_value = TA_AC_CHARGING_CURRENT;
-	} else if((real_v_chrA - ta_v_chr_org) > 1000) {
-		g_temp_input_CC_value = TA_AC_7V_INPUT_CURRENT;  //TA = 7V
-		g_temp_CC_value = TA_AC_CHARGING_CURRENT;
-	}
-}
-
-static void mtk_ta_reset_vchr(void)
-{
-	CHR_CURRENT_ENUM chr_current = CHARGE_CURRENT_70_00_MA;
-
-	battery_charging_control(CHARGING_CMD_SET_INPUT_CURRENT,&chr_current);
-	msleep(250);    // reset Vchr to 5V
-
-	battery_log(BAT_LOG_CRTI, "mtk_ta_reset_vchr(): reset Vchr to 5V \n");
-}
-
-static void mtk_ta_increase(void)
-{
-	kal_bool ta_current_pattern = KAL_TRUE;  // TRUE = increase
-
-	if(ta_cable_out_occur == KAL_FALSE) {
-		battery_charging_control(CHARGING_CMD_SET_TA_CURRENT_PATTERN, &ta_current_pattern);
-	} else {
-		ta_check_chr_type = KAL_TRUE;
-		battery_log(BAT_LOG_CRTI, "mtk_ta_increase() Cable out \n");
-	}
-}
-
-static kal_bool mtk_ta_retry_increase(void)
-{
-	int real_v_chrA;
-	int real_v_chrB;
-	kal_bool retransmit = KAL_TRUE;
-	kal_uint32 retransmit_count=0;
-	
-	do {
-		real_v_chrA = battery_meter_get_charger_voltage();
-		mtk_ta_increase();  //increase TA voltage to 7V
-		real_v_chrB = battery_meter_get_charger_voltage();
-
-		if(real_v_chrB - real_v_chrA >= 1000) {	/* 1.0V */
-			retransmit = KAL_FALSE;
-		} else {
-			retransmit_count++;
-			battery_log(BAT_LOG_CRTI, "mtk_ta_detector(): retransmit_count =%d, chrA=%d, chrB=%d\n", 
-				retransmit_count, real_v_chrA, real_v_chrB);
-		}
-
-		if((retransmit_count == 3) || (BMT_status.charger_exist == KAL_FALSE)) {
-			retransmit = KAL_FALSE;
-		}
-
-	} while((retransmit == KAL_TRUE) && (ta_cable_out_occur == KAL_FALSE));
-
-	battery_log(BAT_LOG_CRTI, "mtk_ta_retry_increase() real_v_chrA=%d, real_v_chrB=%d, retry=%d\n", 
-	real_v_chrA, real_v_chrB,retransmit_count);
-
-	if(retransmit_count == 3)
-		return KAL_FALSE;	
-	else
-		return KAL_TRUE;	
-}
-
-static void mtk_ta_detector(void)
-{
-	int real_v_chrB = 0;
-
-	battery_log(BAT_LOG_CRTI, "mtk_ta_detector() start\n");
-
-	ta_v_chr_org = battery_meter_get_charger_voltage();
-	mtk_ta_retry_increase();
-	real_v_chrB = battery_meter_get_charger_voltage();
-
-	if(real_v_chrB - ta_v_chr_org >= 1000)
-		is_ta_connect = KAL_TRUE;
-	else
-		is_ta_connect = KAL_FALSE;
-		
-	battery_log(BAT_LOG_CRTI, "mtk_ta_detector() end, is_ta_connect=%d\n",is_ta_connect);
-}
-
-static void mtk_ta_init(void)
-{
-	is_ta_connect = KAL_FALSE;
-	ta_cable_out_occur = KAL_FALSE;
-
-#ifdef TA_9V_SUPPORT
-	ta_vchr_tuning = KAL_FALSE;
-#endif
-
-	battery_charging_control(CHARGING_CMD_INIT,NULL);
-}
-
-static void battery_pump_express_charger_check(void)
-{
-	if (KAL_TRUE == ta_check_chr_type &&
-		STANDARD_CHARGER == BMT_status.charger_type &&
-		BMT_status.SOC >= TA_START_BATTERY_SOC &&
-		BMT_status.SOC < TA_STOP_BATTERY_SOC) {
-
-		mutex_lock(&ta_mutex);
-		wake_lock(&TA_charger_suspend_lock);
-
-		mtk_ta_reset_vchr();
-
-		mtk_ta_init();
-		mtk_ta_detector();
-
-		/* need to re-check if the charger plug out during ta detector */
-		if(KAL_TRUE == ta_cable_out_occur)
-			ta_check_chr_type = KAL_TRUE;
-		else
-			ta_check_chr_type = KAL_FALSE;
-
-		wake_unlock(&TA_charger_suspend_lock);
-		mutex_unlock(&ta_mutex);
-	} else {
-		battery_log(BAT_LOG_CRTI, 
-		"Stop battery_pump_express_charger_check, SOC=%d, ta_check_chr_type = %d, charger_type = %d \n", 
-		BMT_status.SOC, ta_check_chr_type, BMT_status.charger_type);
-	}
-}
-
-static void battery_pump_express_algorithm_start(void)
-{
-	kal_int32 charger_vol;
-	kal_uint32 charging_enable = KAL_FALSE;
-
-	mutex_lock(&ta_mutex);
-	wake_lock(&TA_charger_suspend_lock);
-
-	if(KAL_TRUE == is_ta_connect) {
-		/* check cable impedance */
-		charger_vol = battery_meter_get_charger_voltage();
-		if(KAL_FALSE == ta_vchr_tuning) {
-			mtk_ta_retry_increase();	/* increase TA voltage to 9V */
-			charger_vol = battery_meter_get_charger_voltage();
-			ta_vchr_tuning = KAL_TRUE;
-		} else if(BMT_status.SOC > TA_STOP_BATTERY_SOC) {
-			/* disable charging, avoid Iterm issue */
-			battery_charging_control(CHARGING_CMD_ENABLE,&charging_enable);
-			mtk_ta_reset_vchr();	//decrease TA voltage to 5V
-			charger_vol = battery_meter_get_charger_voltage();
-			if(abs(charger_vol - ta_v_chr_org) <= 1000)	/* 1.0V */
-				is_ta_connect = KAL_FALSE;
-
-			battery_log(BAT_LOG_CRTI, "Stop battery_pump_express_algorithm, SOC=%d is_ta_connect =%d, TA_STOP_BATTERY_SOC: %d\n",
-				BMT_status.SOC, is_ta_connect, TA_STOP_BATTERY_SOC);
-		}
-		battery_log(BAT_LOG_CRTI, "[BATTERY] check cable impedance, VA(%d) VB(%d) delta(%d).\n", 
-		ta_v_chr_org, charger_vol, charger_vol - ta_v_chr_org);
-
-		battery_log(BAT_LOG_CRTI, "mtk_ta_algorithm() end\n");
-	} else {
-		battery_log(BAT_LOG_CRTI, "It's not a TA charger, bypass TA algorithm\n");
-	}
-
-	wake_unlock(&TA_charger_suspend_lock);
-	mutex_unlock(&ta_mutex);
-}
-#endif
-
-#if defined(CONFIG_MTK_JEITA_STANDARD_SUPPORT)
-
-static BATTERY_VOLTAGE_ENUM select_jeita_cv(void)
-{
-	BATTERY_VOLTAGE_ENUM cv_voltage;
-
-	if (g_temp_status == TEMP_ABOVE_POS_60) {
-		cv_voltage = JEITA_TEMP_ABOVE_POS_60_CV_VOLTAGE;
-	} else if (g_temp_status == TEMP_POS_45_TO_POS_60) {
-		cv_voltage = JEITA_TEMP_POS_45_TO_POS_60_CV_VOLTAGE;
-	} else if (g_temp_status == TEMP_POS_10_TO_POS_45) {
-#ifdef HIGH_BATTERY_VOLTAGE_SUPPORT
-		cv_voltage = BATTERY_VOLT_04_340000_V;
-#else
-		cv_voltage = JEITA_TEMP_POS_10_TO_POS_45_CV_VOLTAGE;
-#endif
-	} else if (g_temp_status == TEMP_POS_0_TO_POS_10) {
-		cv_voltage = JEITA_TEMP_POS_0_TO_POS_10_CV_VOLTAGE;
-	} else if (g_temp_status == TEMP_NEG_10_TO_POS_0) {
-		cv_voltage = JEITA_TEMP_NEG_10_TO_POS_0_CV_VOLTAGE;
-	} else if (g_temp_status == TEMP_BELOW_NEG_10) {
-		cv_voltage = JEITA_TEMP_BELOW_NEG_10_CV_VOLTAGE;
-	} else {
-		cv_voltage = BATTERY_VOLT_04_200000_V;
-	}
-
-	return cv_voltage;
-}
-
-PMU_STATUS do_jeita_state_machine(void)
-{
-	BATTERY_VOLTAGE_ENUM cv_voltage;
-
-	/* JEITA battery temp Standard */
-
-	if (BMT_status.temperature >= TEMP_POS_60_THRESHOLD) {
-		battery_log(BAT_LOG_CRTI,
-				    "[BATTERY] Battery Over high Temperature(%d) !!\n\r",
-				    TEMP_POS_60_THRESHOLD);
-
-		g_temp_status = TEMP_ABOVE_POS_60;
-
-		return PMU_STATUS_FAIL;
-	} else if (BMT_status.temperature > TEMP_POS_45_THRESHOLD)	/* control 45c to normal behavior */
-	{
-		if ((g_temp_status == TEMP_ABOVE_POS_60)
-		    && (BMT_status.temperature >= TEMP_POS_60_THRES_MINUS_X_DEGREE)) {
-			battery_log(BAT_LOG_CRTI,
-					    "[BATTERY] Battery Temperature between %d and %d,not allow charging yet!!\n\r",
-					    TEMP_POS_60_THRES_MINUS_X_DEGREE,
-					    TEMP_POS_60_THRESHOLD);
-
-			return PMU_STATUS_FAIL;
-		} else {
-			battery_log(BAT_LOG_CRTI,
-					    "[BATTERY] Battery Temperature between %d and %d !!\n\r",
-					    TEMP_POS_45_THRESHOLD, TEMP_POS_60_THRESHOLD);
-
-			g_temp_status = TEMP_POS_45_TO_POS_60;
-		}
-	} else if (BMT_status.temperature >= TEMP_POS_10_THRESHOLD) {
-		if (((g_temp_status == TEMP_POS_45_TO_POS_60)
-		     && (BMT_status.temperature >= TEMP_POS_45_THRES_MINUS_X_DEGREE))
-		    || ((g_temp_status == TEMP_POS_0_TO_POS_10)
-			&& (BMT_status.temperature <= TEMP_POS_10_THRES_PLUS_X_DEGREE))) {
-			battery_log(BAT_LOG_CRTI,
-					    "[BATTERY] Battery Temperature not recovery to normal temperature charging mode yet!!\n\r");
-		} else {
-			battery_log(BAT_LOG_CRTI,
-					    "[BATTERY] Battery Normal Temperature between %d and %d !!\n\r",
-					    TEMP_POS_10_THRESHOLD, TEMP_POS_45_THRESHOLD);
-			g_temp_status = TEMP_POS_10_TO_POS_45;
-		}
-	} else if (BMT_status.temperature >= TEMP_POS_0_THRESHOLD) {
-		if ((g_temp_status == TEMP_NEG_10_TO_POS_0 || g_temp_status == TEMP_BELOW_NEG_10)
-		    && (BMT_status.temperature <= TEMP_POS_0_THRES_PLUS_X_DEGREE)) {
-			if (g_temp_status == TEMP_NEG_10_TO_POS_0) {
-				battery_log(BAT_LOG_CRTI,
-						    "[BATTERY] Battery Temperature between %d and %d !!\n\r",
-						    TEMP_POS_0_THRES_PLUS_X_DEGREE,
-						    TEMP_POS_10_THRESHOLD);
-			}
-			if (g_temp_status == TEMP_BELOW_NEG_10) {
-				battery_log(BAT_LOG_CRTI,
-						    "[BATTERY] Battery Temperature between %d and %d,not allow charging yet!!\n\r",
-						    TEMP_POS_0_THRESHOLD,
-						    TEMP_POS_0_THRES_PLUS_X_DEGREE);
-				return PMU_STATUS_FAIL;
-			}
-		} else {
-			battery_log(BAT_LOG_CRTI,
-					    "[BATTERY] Battery Temperature between %d and %d !!\n\r",
-					    TEMP_POS_0_THRESHOLD, TEMP_POS_10_THRESHOLD);
-
-			g_temp_status = TEMP_POS_0_TO_POS_10;
-		}
-	} else if (BMT_status.temperature >= TEMP_NEG_10_THRESHOLD) {
-		if ((g_temp_status == TEMP_BELOW_NEG_10)
-		    && (BMT_status.temperature <= TEMP_NEG_10_THRES_PLUS_X_DEGREE)) {
-			battery_log(BAT_LOG_CRTI,
-					    "[BATTERY] Battery Temperature between %d and %d,not allow charging yet!!\n\r",
-					    TEMP_NEG_10_THRESHOLD, TEMP_NEG_10_THRES_PLUS_X_DEGREE);
-
-			return PMU_STATUS_FAIL;
-		} else {
-			battery_log(BAT_LOG_CRTI,
-					    "[BATTERY] Battery Temperature between %d and %d !!\n\r",
-					    TEMP_NEG_10_THRESHOLD, TEMP_POS_0_THRESHOLD);
-
-			g_temp_status = TEMP_NEG_10_TO_POS_0;
-		}
-	} else {
-		battery_log(BAT_LOG_CRTI,
-				    "[BATTERY] Battery below low Temperature(%d) !!\n\r",
-				    TEMP_NEG_10_THRESHOLD);
-		g_temp_status = TEMP_BELOW_NEG_10;
-
-		return PMU_STATUS_FAIL;
-	}
-
-	/* set CV after temperature changed */
-
-	cv_voltage = select_jeita_cv();
-	battery_charging_control(CHARGING_CMD_SET_CV_VOLTAGE, &cv_voltage);
-
-	return PMU_STATUS_OK;
-}
-
-
-static void set_jeita_charging_current(void)
-{
-#ifdef CONFIG_USB_IF
-	if (BMT_status.charger_type == STANDARD_HOST)
-		return;
-#endif
-
-	if (g_temp_status == TEMP_NEG_10_TO_POS_0) {
-		g_temp_CC_value = CHARGE_CURRENT_350_00_MA;
-		g_temp_input_CC_value = CHARGE_CURRENT_500_00_MA;
-		battery_log(BAT_LOG_CRTI, "[BATTERY] JEITA set charging current : %d\r\n",
-				    g_temp_CC_value);
-	}
-}
-
-#endif
-
-bool get_usb_current_unlimited(void)
-{
-	if (BMT_status.charger_type == STANDARD_HOST || BMT_status.charger_type == CHARGING_HOST)
-		return usb_unlimited;
-	else
-		return false;
-}
-
-void set_usb_current_unlimited(bool enable)
-{
-	usb_unlimited = enable;
-}
-
-void select_charging_curret_bcct(void)
-{
-	if ((BMT_status.charger_type == STANDARD_HOST) ||
-	    (BMT_status.charger_type == NONSTANDARD_CHARGER)) {
-		if (g_bcct_value < 100)
-			g_temp_input_CC_value = CHARGE_CURRENT_0_00_MA;
-		else if (g_bcct_value < 500)
-			g_temp_input_CC_value = CHARGE_CURRENT_100_00_MA;
-		else if (g_bcct_value < 800)
-			g_temp_input_CC_value = CHARGE_CURRENT_500_00_MA;
-		else if (g_bcct_value == 800)
-			g_temp_input_CC_value = CHARGE_CURRENT_800_00_MA;
-		else
-			g_temp_input_CC_value = CHARGE_CURRENT_500_00_MA;
-	} else if ((BMT_status.charger_type == STANDARD_CHARGER) ||
-		   (BMT_status.charger_type == CHARGING_HOST)) {
-		g_temp_input_CC_value = CHARGE_CURRENT_MAX;
-
-		/* --------------------------------------------------- */
-		/* set IOCHARGE */
-		if (g_bcct_value < 550)
-			g_temp_CC_value = CHARGE_CURRENT_0_00_MA;
-		else if (g_bcct_value < 650)
-			g_temp_CC_value = CHARGE_CURRENT_550_00_MA;
-		else if (g_bcct_value < 750)
-			g_temp_CC_value = CHARGE_CURRENT_650_00_MA;
-		else if (g_bcct_value < 850)
-			g_temp_CC_value = CHARGE_CURRENT_750_00_MA;
-		else if (g_bcct_value < 950)
-			g_temp_CC_value = CHARGE_CURRENT_850_00_MA;
-		else if (g_bcct_value < 1050)
-			g_temp_CC_value = CHARGE_CURRENT_950_00_MA;
-		else if (g_bcct_value < 1150)
-			g_temp_CC_value = CHARGE_CURRENT_1050_00_MA;
-		else if (g_bcct_value < 1250)
-			g_temp_CC_value = CHARGE_CURRENT_1150_00_MA;
-		else if (g_bcct_value == 1250)
-			g_temp_CC_value = CHARGE_CURRENT_1250_00_MA;
-		else
-			g_temp_CC_value = CHARGE_CURRENT_650_00_MA;
-		/* --------------------------------------------------- */
-
-	} else {
-		g_temp_input_CC_value = CHARGE_CURRENT_500_00_MA;
-	}
-}
-
-static void pchr_turn_on_charging(void);
-kal_uint32 set_bat_charging_current_limit(int current_limit)
-{
-	battery_log(BAT_LOG_CRTI, "[BATTERY] set_bat_charging_current_limit (%d)\r\n",
-			    current_limit);
-
-	if (current_limit != -1) {
-		g_bcct_flag = 1;
-		g_bcct_value = current_limit;
-
-		if (current_limit < 70)
-			g_temp_CC_value = CHARGE_CURRENT_0_00_MA;
-		else if (current_limit < 200)
-			g_temp_CC_value = CHARGE_CURRENT_70_00_MA;
-		else if (current_limit < 300)
-			g_temp_CC_value = CHARGE_CURRENT_200_00_MA;
-		else if (current_limit < 400)
-			g_temp_CC_value = CHARGE_CURRENT_300_00_MA;
-		else if (current_limit < 450)
-			g_temp_CC_value = CHARGE_CURRENT_400_00_MA;
-		else if (current_limit < 550)
-			g_temp_CC_value = CHARGE_CURRENT_450_00_MA;
-		else if (current_limit < 650)
-			g_temp_CC_value = CHARGE_CURRENT_550_00_MA;
-		else if (current_limit < 700)
-			g_temp_CC_value = CHARGE_CURRENT_650_00_MA;
-		else if (current_limit < 800)
-			g_temp_CC_value = CHARGE_CURRENT_700_00_MA;
-		else if (current_limit < 900)
-			g_temp_CC_value = CHARGE_CURRENT_800_00_MA;
-		else if (current_limit < 1000)
-			g_temp_CC_value = CHARGE_CURRENT_900_00_MA;
-		else if (current_limit < 1100)
-			g_temp_CC_value = CHARGE_CURRENT_1000_00_MA;
-		else if (current_limit < 1200)
-			g_temp_CC_value = CHARGE_CURRENT_1100_00_MA;
-		else if (current_limit < 1300)
-			g_temp_CC_value = CHARGE_CURRENT_1200_00_MA;
-		else if (current_limit < 1400)
-			g_temp_CC_value = CHARGE_CURRENT_1300_00_MA;
-		else if (current_limit < 1500)
-			g_temp_CC_value = CHARGE_CURRENT_1400_00_MA;
-		else if (current_limit < 1600)
-			g_temp_CC_value = CHARGE_CURRENT_1500_00_MA;
-		else if (current_limit == 1600)
-			g_temp_CC_value = CHARGE_CURRENT_1600_00_MA;
-		else
-			g_temp_CC_value = CHARGE_CURRENT_450_00_MA;
-	} else {
-		/* change to default current setting */
-		g_bcct_flag = 0;
-	}
-
-	/* wake_up_bat(); */
-	pchr_turn_on_charging();
-
-	return g_bcct_flag;
-}
-
-
-void select_charging_curret(void)
-{
-	if (g_ftm_battery_flag) {
-		battery_log(BAT_LOG_CRTI, "[BATTERY] FTM charging : %d\r\n",
-				    charging_level_data[0]);
-		g_temp_CC_value = charging_level_data[0];
-
-		if (g_temp_CC_value == CHARGE_CURRENT_450_00_MA) {
-			g_temp_input_CC_value = CHARGE_CURRENT_500_00_MA;
-		} else {
-			g_temp_input_CC_value = CHARGE_CURRENT_MAX;
-			g_temp_CC_value = AC_CHARGER_CURRENT;
-
-			battery_log(BAT_LOG_CRTI, "[BATTERY] set_ac_current \r\n");
-		}
-	} else {
-		if (BMT_status.charger_type == STANDARD_HOST) {
-#ifdef CONFIG_USB_IF
-			{
-				g_temp_input_CC_value = CHARGE_CURRENT_MAX;
-				if (g_usb_state == USB_SUSPEND) {
-					g_temp_CC_value = USB_CHARGER_CURRENT_SUSPEND;
-				} else if (g_usb_state == USB_UNCONFIGURED) {
-					g_temp_CC_value = USB_CHARGER_CURRENT_UNCONFIGURED;
-				} else if (g_usb_state == USB_CONFIGURED) {
-					g_temp_CC_value = USB_CHARGER_CURRENT_CONFIGURED;
-				} else {
-					g_temp_CC_value = USB_CHARGER_CURRENT_UNCONFIGURED;
-				}
-
-				battery_log(BAT_LOG_CRTI,
-						    "[BATTERY] STANDARD_HOST CC mode charging : %d on %d state\r\n",
-						    g_temp_CC_value, g_usb_state);
-			}
-#else
-			{
-				g_temp_input_CC_value = USB_CHARGER_CURRENT;
-				g_temp_CC_value = USB_CHARGER_CURRENT;
-			}
-#endif
-		} else if (BMT_status.charger_type == NONSTANDARD_CHARGER) {
-			g_temp_input_CC_value = NON_STD_AC_CHARGER_CURRENT;
-			g_temp_CC_value = NON_STD_AC_CHARGER_CURRENT;
-
-		} else if (BMT_status.charger_type == STANDARD_CHARGER) {
-			g_temp_input_CC_value = AC_CHARGER_CURRENT;
-			g_temp_CC_value = AC_CHARGER_CURRENT;
-#if defined(CONFIG_MTK_PUMP_EXPRESS_PLUS_SUPPORT)
-        		if(is_ta_connect == KAL_TRUE)
-        			set_ta_charging_current();
-#endif
-		} else if (BMT_status.charger_type == CHARGING_HOST) {
-			g_temp_input_CC_value = CHARGING_HOST_CHARGER_CURRENT;
-			g_temp_CC_value = CHARGING_HOST_CHARGER_CURRENT;
-		} else if (BMT_status.charger_type == APPLE_2_1A_CHARGER) {
-			g_temp_input_CC_value = APPLE_2_1A_CHARGER_CURRENT;
-			g_temp_CC_value = APPLE_2_1A_CHARGER_CURRENT;
-		} else if (BMT_status.charger_type == APPLE_1_0A_CHARGER) {
-			g_temp_input_CC_value = APPLE_1_0A_CHARGER_CURRENT;
-			g_temp_CC_value = APPLE_1_0A_CHARGER_CURRENT;
-		} else if (BMT_status.charger_type == APPLE_0_5A_CHARGER) {
-			g_temp_input_CC_value = APPLE_0_5A_CHARGER_CURRENT;
-			g_temp_CC_value = APPLE_0_5A_CHARGER_CURRENT;
-		} else {
-			g_temp_input_CC_value = CHARGE_CURRENT_500_00_MA;
-			g_temp_CC_value = CHARGE_CURRENT_500_00_MA;
-		}
-
-
-		#if defined(CONFIG_MTK_DUAL_INPUT_CHARGER_SUPPORT)
-		if (DISO_data.diso_state.cur_vdc_state == DISO_ONLINE) {
-			g_temp_input_CC_value = AC_CHARGER_CURRENT;
-			g_temp_CC_value = AC_CHARGER_CURRENT;
-		}
-		#endif
-
-#if defined(CONFIG_MTK_JEITA_STANDARD_SUPPORT)
-		set_jeita_charging_current();
-#endif
-	}
-
-
-}
-
-
-static kal_uint32 charging_full_check(void)
-{
-	kal_uint32 status;
-
-	battery_charging_control(CHARGING_CMD_GET_CHARGING_STATUS, &status);
-	if (status == KAL_TRUE) {
-		g_full_check_count++;
-		if (g_full_check_count >= FULL_CHECK_TIMES) {
-			return KAL_TRUE;
-		} else
-			return KAL_FALSE;
-	} else {
-		g_full_check_count = 0;
-		return status;
-	}
-}
-
-
-static void pchr_turn_on_charging(void)
-{
-#if !defined(CONFIG_MTK_JEITA_STANDARD_SUPPORT)
-	BATTERY_VOLTAGE_ENUM cv_voltage;
-#endif
-	kal_uint32 charging_enable = KAL_TRUE;
-
-	#if defined(CONFIG_MTK_DUAL_INPUT_CHARGER_SUPPORT)
-	if(KAL_TRUE == BMT_status.charger_exist)
-		charging_enable = KAL_TRUE;
-	else 
-		charging_enable = KAL_FALSE;
-	#endif
-
-	if (BMT_status.bat_charging_state == CHR_ERROR) {
-		battery_log(BAT_LOG_CRTI, "[BATTERY] Charger Error, turn OFF charging !\n");
-
-		charging_enable = KAL_FALSE;
-
-	} else if ((g_platform_boot_mode == META_BOOT) || (g_platform_boot_mode == ADVMETA_BOOT)) {
-		battery_log(BAT_LOG_CRTI,
-				    "[BATTERY] In meta or advanced meta mode, disable charging.\n");
-		charging_enable = KAL_FALSE;
-	} else {
-		/*HW initialization */
-		battery_charging_control(CHARGING_CMD_INIT, NULL);
-
-		battery_log(BAT_LOG_FULL, "charging_hw_init\n");
-
-#if defined(CONFIG_MTK_PUMP_EXPRESS_PLUS_SUPPORT)
-        battery_pump_express_algorithm_start();
-#endif
-
-		/* Set Charging Current */
-		if (get_usb_current_unlimited()) {
-			g_temp_input_CC_value = AC_CHARGER_CURRENT;
-			g_temp_CC_value = AC_CHARGER_CURRENT;
-			battery_log(BAT_LOG_FULL,
-					    "USB_CURRENT_UNLIMITED, use AC_CHARGER_CURRENT\n");
-		} else if (g_bcct_flag == 1) {
-			select_charging_curret_bcct();
-
-			battery_log(BAT_LOG_FULL,
-					    "[BATTERY] select_charging_curret_bcct !\n");
-		} else {
-			select_charging_curret();
-
-			battery_log(BAT_LOG_FULL, "[BATTERY] select_charging_curret !\n");
-		}
-		battery_log(BAT_LOG_CRTI,
-				    "[BATTERY] Default CC mode charging : %d, input current = %d\r\n",
-				    g_temp_CC_value, g_temp_input_CC_value);
-		if (g_temp_CC_value == CHARGE_CURRENT_0_00_MA
-		    || g_temp_input_CC_value == CHARGE_CURRENT_0_00_MA) {
-
-			charging_enable = KAL_FALSE;
-
-			battery_log(BAT_LOG_CRTI,
-					    "[BATTERY] charging current is set 0mA, turn off charging !\r\n");
-		} else {
-			battery_charging_control(CHARGING_CMD_SET_INPUT_CURRENT,
-						 &g_temp_input_CC_value);
-			battery_charging_control(CHARGING_CMD_SET_CURRENT, &g_temp_CC_value);
-
-			/*Set CV Voltage */
-#if !defined(CONFIG_MTK_JEITA_STANDARD_SUPPORT)
-#ifdef HIGH_BATTERY_VOLTAGE_SUPPORT
-			cv_voltage = BATTERY_VOLT_04_340000_V;
-#else
-			cv_voltage = BATTERY_VOLT_04_200000_V;
-#endif
-			battery_charging_control(CHARGING_CMD_SET_CV_VOLTAGE, &cv_voltage);
-#endif
-		}
-	}
-
-	/* enable/disable charging */
-	battery_charging_control(CHARGING_CMD_ENABLE, &charging_enable);
-
-	battery_log(BAT_LOG_FULL, "[BATTERY] pchr_turn_on_charging(), enable =%d !\r\n",
-			    charging_enable);
-}
-
-
-PMU_STATUS BAT_PreChargeModeAction(void)
-{
-	battery_log(BAT_LOG_CRTI, "[BATTERY] Pre-CC mode charge, timer=%d on %d !!\n\r",
-			    BMT_status.PRE_charging_time, BMT_status.total_charging_time);
-
-	BMT_status.PRE_charging_time += BAT_TASK_PERIOD;
-	BMT_status.CC_charging_time = 0;
-	BMT_status.TOPOFF_charging_time = 0;
-	BMT_status.total_charging_time += BAT_TASK_PERIOD;
-
-	/*  Enable charger */
-	pchr_turn_on_charging();
-
-	if (BMT_status.UI_SOC == 100) {
-		BMT_status.bat_charging_state = CHR_BATFULL;
-		BMT_status.bat_full = KAL_TRUE;
-		g_charging_full_reset_bat_meter = KAL_TRUE;
-	} else if (BMT_status.bat_vol > V_PRE2CC_THRES) {
-		BMT_status.bat_charging_state = CHR_CC;
-	}
-
-
-
-	return PMU_STATUS_OK;
-}
-
-
-PMU_STATUS BAT_ConstantCurrentModeAction(void)
-{
-	battery_log(BAT_LOG_FULL, "[BATTERY] CC mode charge, timer=%d on %d !!\n\r",
-			    BMT_status.CC_charging_time, BMT_status.total_charging_time);
-
-	BMT_status.PRE_charging_time = 0;
-	BMT_status.CC_charging_time += BAT_TASK_PERIOD;
-	BMT_status.TOPOFF_charging_time = 0;
-	BMT_status.total_charging_time += BAT_TASK_PERIOD;
-
-	/*  Enable charger */
-	pchr_turn_on_charging();
-
-	if (charging_full_check() == KAL_TRUE) {
-		BMT_status.bat_charging_state = CHR_BATFULL;
-		BMT_status.bat_full = KAL_TRUE;
-		g_charging_full_reset_bat_meter = KAL_TRUE;
-	}
-
-	return PMU_STATUS_OK;
-}
-
-
-PMU_STATUS BAT_BatteryFullAction(void)
-{
-	battery_log(BAT_LOG_CRTI, "[BATTERY] Battery full !!\n\r");
-
-	BMT_status.bat_full = KAL_TRUE;
-	BMT_status.total_charging_time = 0;
-	BMT_status.PRE_charging_time = 0;
-	BMT_status.CC_charging_time = 0;
-	BMT_status.TOPOFF_charging_time = 0;
-	BMT_status.POSTFULL_charging_time = 0;
-	BMT_status.bat_in_recharging_state = KAL_FALSE;
-
-	if (charging_full_check() == KAL_FALSE) {
-		battery_log(BAT_LOG_CRTI, "[BATTERY] Battery Re-charging !!\n\r");
-
-		BMT_status.bat_in_recharging_state = KAL_TRUE;
-		BMT_status.bat_charging_state = CHR_CC;
-		battery_meter_reset();
-	}
-
-
-	return PMU_STATUS_OK;
-}
-
-
-PMU_STATUS BAT_BatteryHoldAction(void)
-{
-	kal_uint32 charging_enable;
-
-	battery_log(BAT_LOG_CRTI, "[BATTERY] Hold mode !!\n\r");
-
-	if (BMT_status.bat_vol < TALKING_RECHARGE_VOLTAGE || g_call_state == CALL_IDLE) {
-		BMT_status.bat_charging_state = CHR_CC;
-		battery_log(BAT_LOG_CRTI,
-				    "[BATTERY] Exit Hold mode and Enter CC mode !!\n\r");
-	}
-
-	/*  Disable charger */
-	charging_enable = KAL_FALSE;
-	battery_charging_control(CHARGING_CMD_ENABLE, &charging_enable);
-
-	return PMU_STATUS_OK;
-}
-
-
-PMU_STATUS BAT_BatteryStatusFailAction(void)
-{
-	kal_uint32 charging_enable;
-
-	battery_log(BAT_LOG_CRTI, "[BATTERY] BAD Battery status... Charging Stop !!\n\r");
-
-#if defined(CONFIG_MTK_JEITA_STANDARD_SUPPORT)
-	if ((g_temp_status == TEMP_ABOVE_POS_60) || (g_temp_status == TEMP_BELOW_NEG_10)) {
-		temp_error_recovery_chr_flag = KAL_FALSE;
-	}
-	if ((temp_error_recovery_chr_flag == KAL_FALSE) && (g_temp_status != TEMP_ABOVE_POS_60)
-	    && (g_temp_status != TEMP_BELOW_NEG_10)) {
-		temp_error_recovery_chr_flag = KAL_TRUE;
-		BMT_status.bat_charging_state = CHR_PRE;
-	}
-#endif
-
-	BMT_status.total_charging_time = 0;
-	BMT_status.PRE_charging_time = 0;
-	BMT_status.CC_charging_time = 0;
-	BMT_status.TOPOFF_charging_time = 0;
-	BMT_status.POSTFULL_charging_time = 0;
-
-	/*  Disable charger */
-	charging_enable = KAL_FALSE;
-	battery_charging_control(CHARGING_CMD_ENABLE, &charging_enable);
-
-	return PMU_STATUS_OK;
-}
-
-
-void mt_battery_charging_algorithm(void)
-{
-	battery_charging_control(CHARGING_CMD_RESET_WATCH_DOG_TIMER, NULL);
-
-#if defined(CONFIG_MTK_PUMP_EXPRESS_PLUS_SUPPORT)
-	battery_pump_express_charger_check();
-#endif
-	switch (BMT_status.bat_charging_state) {
-	case CHR_PRE:
-		BAT_PreChargeModeAction();
-		break;
-
-	case CHR_CC:
-		BAT_ConstantCurrentModeAction();
-		break;
-
-	case CHR_BATFULL:
-		BAT_BatteryFullAction();
-		break;
-
-	case CHR_HOLD:
-		BAT_BatteryHoldAction();
-		break;
-
-	case CHR_ERROR:
-		BAT_BatteryStatusFailAction();
-		break;
-	}
-
-	battery_charging_control(CHARGING_CMD_DUMP_REGISTER, NULL);
-}
diff --git a/tools/dct/EINT_YuSu.cmp~ b/tools/dct/EINT_YuSu.cmp~
deleted file mode 100755
index 3224564..0000000
--- a/tools/dct/EINT_YuSu.cmp~
+++ /dev/null
@@ -1,172 +0,0 @@
-[EINT_variables]
-MT7118_WIMAX
-MT5921_WIFI
-BT
-KPD_PWRKEY
-KPD_SLIDE
-TOUCH_PANEL
-MT6326_PMIC
-HEADSET
-MHALL
-HALL_1
-HALL_2
-HALL_3
-FM_RDS
-HALL_4
-ALS
-OFN
-WIFI
-COMBO_BGF
-COMBO_ALL
-GSE_1
-GSE_2
-MSE
-MHL
-GYRO
-ACCDET
-OTG_IDDIG
-CMMB
-NFC
-IRQ_NFC
-HEADSET_HOOK
-MT6329_PMIC
-EINT_HDMI_HPD
-DT_EXT_MD_EXP
-DT_EXT_MD_WDT
-DT_EXT_MD_WK_UP
-DT_EXT_MD_WK_UP_USB
-DT_EXT_MD_EXP
-EVDO_DT_EXT_MDM_RDY
-EVDO_DT_EXT_MDM_WAKE_AP
-EVDO_DT_EXT_MDM_RST_IND
-EVDO_DT_EXT_MDM_PWR_ON
-EVDO_DT_EXT_UART_MDM_WAKE_AP
-EVDO_DT_EXT_MDM_ACK
-EVDO_DT_EXT_MDM_FLOW_CTRL
-MT6280_USB_WAKEUP
-MT6280_WD
-SIM1_HOT_PLUG
-SIM2_HOT_PLUG
-MSDC1_INS
-MSDC2_INS
-MT6322_PMIC
-MT6323_PMIC
-MT6333_PMIC
-MT6397_PMIC
-CHR_STAT
-LTE_SDIO
-LTE_WDT
-EXT_BUCK_OC
-EDP_INTN
-DSI_TE_1
-VBUS_DETECT_PIN_EINT
-KEYMUTE
-[MD1_EINT_variables]
-MD1_SIM1_HOT_PLUG_EINT
-MD1_SIM2_HOT_PLUG_EINT
-MD1_SIM3_HOT_PLUG_EINT
-MD1_SIM4_HOT_PLUG_EINT
-
-[MD2_EINT_variables]
-AST_DATA_INTR
-MD2_SIM1_HOT_PLUG_EINT
-MD2_SIM2_HOT_PLUG_EINT
-
-[SRC_PIN]
-PAD_INT_SIM1
-PAD_INT_SIM2
-PAD_SPI_MO
-PAD_SPI_CS
-PAD_URXD0
-PAD_URTS0
-PAD_URXD3
-PAD_DPI_D0
-PAD_DPI_D2
-
-
-[cust_eint.h_HEADER]
-#ifndef __CUST_EINTH
-#define __CUST_EINTH
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define CUST_EINT_POLARITY_LOW              0
-#define CUST_EINT_POLARITY_HIGH             1
-#define CUST_EINT_DEBOUNCE_DISABLE          0
-#define CUST_EINT_DEBOUNCE_ENABLE           1
-#define CUST_EINT_EDGE_SENSITIVE            0
-#define CUST_EINT_LEVEL_SENSITIVE           1
-
-//////////////////////////////////////////////////////////////////////////////
-
-[cust_eint2.h_HEADER]
-#ifndef __CUST_EINTH
-#define __CUST_EINTH
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define CUST_EINTF_TRIGGER_RISING     			1    //High Polarity and Edge Sensitive
-#define CUST_EINTF_TRIGGER_FALLING    			2    //Low Polarity and Edge Sensitive
-#define CUST_EINTF_TRIGGER_HIGH      				4    //High Polarity and Level Sensitive
-#define CUST_EINTF_TRIGGER_LOW       				8    //Low Polarity and Level Sensitive
-
-#define CUST_EINT_DEBOUNCE_DISABLE          0
-#define CUST_EINT_DEBOUNCE_ENABLE           1
-
-//////////////////////////////////////////////////////////////////////////////
-
-[cust_eint_ext.h_HEADER]
-#ifndef __CUST_EINT_EXTH
-#define __CUST_EINT_EXTH
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define CUST_EINT_POLARITY_LOW              0
-#define CUST_EINT_POLARITY_HIGH             1
-#define CUST_EINT_DEBOUNCE_DISABLE          0
-#define CUST_EINT_DEBOUNCE_ENABLE           1
-#define CUST_EINT_EDGE_SENSITIVE            0
-#define CUST_EINT_LEVEL_SENSITIVE           1
-//////////////////////////////////////////////////////////////////////////////
-
-[cust_eint_ext2.h_HEADER]
-#ifndef __CUST_EINTH
-#define __CUST_EINTH
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define CUST_EINTF_TRIGGER_RISING     			1    //High Polarity and Edge Sensitive
-#define CUST_EINTF_TRIGGER_FALLING    			2    //Low Polarity and Edge Sensitive
-#define CUST_EINTF_TRIGGER_HIGH      				4    //High Polarity and Level Sensitive
-#define CUST_EINTF_TRIGGER_LOW       				8    //Low Polarity and Level Sensitive
-
-#define CUST_EINT_DEBOUNCE_DISABLE          0
-#define CUST_EINT_DEBOUNCE_ENABLE           1
-
-//////////////////////////////////////////////////////////////////////////////
-
-[cust_eint.h_TAILER]
-
-//////////////////////////////////////////////////////////////////////////////
-#ifdef __cplusplus
-}
-
-#endif
-#endif //_CUST_EINT_H
-
-[cust_eint_ext.h_TAILER]
-
-//////////////////////////////////////////////////////////////////////////////
-#ifdef __cplusplus
-}
-
-#endif
-#endif //_CUST_EINT__EXT_H
-- 
2.7.4

